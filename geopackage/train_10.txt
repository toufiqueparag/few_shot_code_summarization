private void createAndCloseGeoPackage ( GeoPackageDatabase db ) { GeoPackageConnection connection = new GeoPackageConnection ( db ) ; // Set the GeoPackage application id and user version connection . setApplicationId ( ) ; connection . setUserVersion ( ) ; // Create the minimum required tables GeoPackageTableCreator tableCreator = new GeoPackageTableCreator ( connection ) ; tableCreator . createRequired ( ) ; connection . close ( ) ; }	<s> Create the required GeoPackage application id and tables in the newly created and open database connection . Then close the connection . </s>
public void registerTable ( String tableName , GeoPackageCursorWrapper cursorWrapper ) { // Remove an existing cursor wrapper tableCursors . remove ( tableName ) ; // Add the wrapper tableCursors . put ( tableName , cursorWrapper ) ; String quotedTableName = CoreSQLUtils . quoteWrap ( tableName ) ; tableCursors . put ( quotedTableName , cursorWrapper ) ; // The Android android.database.sqlite.SQLiteDatabase findEditTable method // finds the new cursor edit table name based upon the first space or comma. // Fix (hopefully temporary) to wrap with the expected cursor type int spacePosition = tableName . indexOf ( ' ' ) ; if ( spacePosition > 0 ) { tableCursors . put ( tableName . substring ( 0 , spacePosition ) , cursorWrapper ) ; tableCursors . put ( quotedTableName . substring ( 0 , quotedTableName . indexOf ( ' ' ) ) , cursorWrapper ) ; } }	<s> Register a cursor wrapper for the provided table name . Database queries will wrap the returned cursor </s>
public static File getInternalFile ( Context context , String filePath ) { File internalFile = null ; if ( filePath != null ) { internalFile = new File ( context . getFilesDir ( ) , filePath ) ; } else { internalFile = context . getFilesDir ( ) ; } return internalFile ; }	<s> Get the internal storage file for the file path </s>
public static String getInternalFilePath ( Context context , String filePath ) { return getInternalFile ( context , filePath ) . getAbsolutePath ( ) ; }	<s> Get the internal storage patch for the file path </s>
public static GeoPackageManager getManager ( Context context ) { Thread . currentThread ( ) . setContextClassLoader ( GeoPackageManager . class . getClassLoader ( ) ) ; return new GeoPackageManagerImpl ( context ) ; }	<s> Get a GeoPackage Manager </s>
private TRow getCurrentRow ( ) { TRow row = null ; if ( table != null ) { int [ ] columnTypes = new int [ table . columnCount ( ) ] ; Object [ ] values = new Object [ table . columnCount ( ) ] ; boolean valid = true ; for ( TColumn column : table . getColumns ( ) ) { int index = column . getIndex ( ) ; int columnType = getType ( index ) ; if ( column . isPrimaryKey ( ) && columnType == FIELD_TYPE_NULL ) { valid = false ; } columnTypes [ index ] = columnType ; values [ index ] = getValue ( column ) ; } row = getRow ( columnTypes , values ) ; if ( ! valid ) { invalidPositions . add ( getPosition ( ) ) ; row . setValid ( false ) ; } } return row ; }	<s> Get the current row </s>
private void addExternalDatabases ( Collection < String > databases ) { // Get the external GeoPackages, adding those where the file exists and // deleting those with missing files List < GeoPackageMetadata > externalGeoPackages = getExternalGeoPackages ( ) ; for ( GeoPackageMetadata external : externalGeoPackages ) { if ( new File ( external . getExternalPath ( ) ) . exists ( ) ) { databases . add ( external . getName ( ) ) ; } else { delete ( external . getName ( ) ) ; } } }	<s> Add all external databases to the collection </s>
private void addInternalDatabases ( Collection < String > databases ) { String [ ] databaseArray = context . databaseList ( ) ; for ( String database : databaseArray ) { if ( ! isTemporary ( database ) && ! database . equalsIgnoreCase ( GeoPackageMetadataDb . DATABASE_NAME ) ) { databases . add ( database ) ; } } }	<s> Add all internal databases to the collection </s>
private boolean importGeoPackage ( String database , boolean override , InputStream geoPackageStream , GeoPackageProgress progress ) { try { if ( exists ( database ) ) { if ( override ) { if ( ! delete ( database ) ) { throw new GeoPackageException ( "Failed to delete existing database: " + database ) ; } } else { throw new GeoPackageException ( "GeoPackage database already exists: " + database ) ; } } // Copy the geopackage over as a database File newDbFile = context . getDatabasePath ( database ) ; try { SQLiteDatabase db = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null ) ; db . close ( ) ; GeoPackageIOUtils . copyStream ( geoPackageStream , newDbFile , progress ) ; } catch ( IOException e ) { throw new GeoPackageException ( "Failed to import GeoPackage database: " + database , e ) ; } } finally { GeoPackageIOUtils . closeQuietly ( geoPackageStream ) ; } if ( progress == null || progress . isActive ( ) ) { // Verify that the database is valid try { SQLiteDatabase sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null , new DatabaseErrorHandler ( ) { @ Override public void onCorruption ( SQLiteDatabase dbObj ) { } } ) ; validateDatabaseAndClose ( sqlite , importHeaderValidation , importIntegrityValidation ) ; GeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; metadataDb . open ( ) ; try { GeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; // Save in metadata GeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; metadata . setName ( database ) ; dataSource . create ( metadata ) ; } finally { metadataDb . close ( ) ; } } catch ( Exception e ) { delete ( database ) ; throw new GeoPackageException ( "Invalid GeoPackage database file" , e ) ; } GeoPackage geoPackage = open ( database , false ) ; if ( geoPackage != null ) { try { if ( ! geoPackage . getSpatialReferenceSystemDao ( ) . isTableExists ( ) || ! geoPackage . getContentsDao ( ) . isTableExists ( ) ) { delete ( database ) ; throw new GeoPackageException ( "Invalid GeoPackage database file. Does not contain required tables: " + SpatialReferenceSystem . TABLE_NAME + " & " + Contents . TABLE_NAME + ", Database: " + database ) ; } } catch ( SQLException e ) { delete ( database ) ; throw new GeoPackageException ( "Invalid GeoPackage database file. Could not verify existence of required tables: " + SpatialReferenceSystem . TABLE_NAME + " & " + Contents . TABLE_NAME + ", Database: " + database ) ; } finally { geoPackage . close ( ) ; } } else { delete ( database ) ; throw new GeoPackageException ( "Unable to open GeoPackage database. Database: " + database ) ; } } return exists ( database ) ; }	<s> Import the GeoPackage stream </s>
private GeoPackageMetadata getGeoPackageMetadata ( String database ) { GeoPackageMetadata metadata = null ; GeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; metadataDb . open ( ) ; try { GeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; metadata = dataSource . get ( database ) ; } finally { metadataDb . close ( ) ; } return metadata ; }	<s> Get the GeoPackage metadata </s>
