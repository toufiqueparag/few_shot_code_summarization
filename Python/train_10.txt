def install ( self , param , author = None , constraints = None , origin = '' ) : if isinstance ( param , SkillEntry ) : skill = param else : skill = self . find_skill ( param , author ) entry = build_skill_entry ( skill . name , origin , skill . is_beta ) try : skill . install ( constraints ) entry [ 'installed' ] = time . time ( ) entry [ 'installation' ] = 'installed' entry [ 'status' ] = 'active' entry [ 'beta' ] = skill . is_beta except AlreadyInstalled : entry = None raise except MsmException as e : entry [ 'installation' ] = 'failed' entry [ 'status' ] = 'error' entry [ 'failure_message' ] = repr ( e ) raise finally : # Store the entry in the list if entry : self . skills_data [ 'skills' ] . append ( entry )	<s> Install by url or name </s>
def do_not_pickle_attributes ( * lazy_properties ) : def wrap_class ( cls ) : if not hasattr ( cls , 'load' ) : raise ValueError ( "no load method implemented" ) # Attach the lazy loading properties to the class for lazy_property in lazy_properties : setattr ( cls , lazy_property , property ( * lazy_property_factory ( lazy_property ) ) ) # Delete the values of lazy properties when serializing if not hasattr ( cls , '__getstate__' ) : def __getstate__ ( self ) : serializable_state = self . __dict__ . copy ( ) for lazy_property in lazy_properties : attr = serializable_state . get ( '_' + lazy_property ) # Iterators would lose their state if isinstance ( attr , collections . Iterator ) : raise ValueError ( "Iterators can't be lazy loaded" ) serializable_state . pop ( '_' + lazy_property , None ) return serializable_state setattr ( cls , '__getstate__' , __getstate__ ) return cls return wrap_class	<s> r Decorator to assign non - pickable properties . </s>
def _copy_and_clean_up_expectation ( self , expectation , discard_result_format_kwargs = True , discard_include_configs_kwargs = True , discard_catch_exceptions_kwargs = True , ) : new_expectation = copy . deepcopy ( expectation ) if "success_on_last_run" in new_expectation : del new_expectation [ "success_on_last_run" ] if discard_result_format_kwargs : if "result_format" in new_expectation [ "kwargs" ] : del new_expectation [ "kwargs" ] [ "result_format" ] # discards["result_format"] += 1 if discard_include_configs_kwargs : if "include_configs" in new_expectation [ "kwargs" ] : del new_expectation [ "kwargs" ] [ "include_configs" ] # discards["include_configs"] += 1 if discard_catch_exceptions_kwargs : if "catch_exceptions" in new_expectation [ "kwargs" ] : del new_expectation [ "kwargs" ] [ "catch_exceptions" ] # discards["catch_exceptions"] += 1 return new_expectation	<s> Returns copy of expectation without success_on_last_run and other specified key - value pairs removed </s>
def variableMissingValue ( ncVar ) : attributes = ncVarAttributes ( ncVar ) if not attributes : return None # a premature optimization :-) for key in ( 'missing_value' , 'MissingValue' , 'missingValue' , 'FillValue' , '_FillValue' ) : if key in attributes : missingDataValue = attributes [ key ] return missingDataValue return None	<s> Returns the missingData given a NetCDF variable </s>
def _bin ( self , bin ) : # type: (str) -> str bin_path = ( self . _bin_dir / bin ) . with_suffix ( ".exe" if self . _is_windows else "" ) if not bin_path . exists ( ) : return bin return str ( bin_path )	<s> Return path to the given executable . </s>
def DEFINE_integer_list ( self , name , default , help , constant = False ) : self . AddOption ( type_info . List ( name = name , default = default , description = help , validator = type_info . Integer ( ) ) , constant = constant )	<s> A helper for defining lists of integer options . </s>
def start ( self ) : def first_run ( ) : self . _ioloop_thread_id = get_thread_ident ( ) if self . OBSERVE_UPDATES : self . attach ( ) self . ioloop . add_callback ( first_run )	<s> Start operating the strategy . </s>
def main ( reraise_exceptions = False , * * kwargs ) : exit_status = 0 try : cli . main ( * * kwargs ) except SoftLayer . SoftLayerAPIError as ex : if 'invalid api token' in ex . faultString . lower ( ) : print ( "Authentication Failed: To update your credentials, use 'slcli config setup'" ) exit_status = 1 else : print ( str ( ex ) ) exit_status = 1 except SoftLayer . SoftLayerError as ex : print ( str ( ex ) ) exit_status = 1 except exceptions . CLIAbort as ex : print ( str ( ex . message ) ) exit_status = ex . code except Exception : if reraise_exceptions : raise import traceback print ( "An unexpected error has occured:" ) print ( str ( traceback . format_exc ( ) ) ) print ( "Feel free to report this error as it is likely a bug:" ) print ( "    https://github.com/softlayer/softlayer-python/issues" ) print ( "The following snippet should be able to reproduce the error" ) exit_status = 1 sys . exit ( exit_status )	<s> Main program . Catches several common errors and displays them nicely . </s>
def handle_json_GET_boundboxstops ( self , params ) : schedule = self . server . schedule n = float ( params . get ( 'n' ) ) e = float ( params . get ( 'e' ) ) s = float ( params . get ( 's' ) ) w = float ( params . get ( 'w' ) ) limit = int ( params . get ( 'limit' ) ) stops = schedule . GetStopsInBoundingBox ( north = n , east = e , south = s , west = w , n = limit ) return [ StopToTuple ( s ) for s in stops ]	<s> Return a list of up to limit stops within bounding box with n e and s w in the NE and SW corners . Does not handle boxes crossing longitude line 180 . </s>
def register_introspection_functions ( self ) : self . funcs . update ( { 'system.listMethods' : self . system_listMethods , 'system.methodSignature' : self . system_methodSignature , 'system.methodHelp' : self . system_methodHelp } )	<s> Registers the XML - RPC introspection methods in the system namespace . </s>
