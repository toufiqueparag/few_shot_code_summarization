public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; if ( deploymentRoot == null || ! deploymentRoot . exists ( ) ) return ; VirtualFile serviceXmlFile = null ; if ( deploymentRoot . isDirectory ( ) ) { serviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; } else if ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) { serviceXmlFile = deploymentRoot ; } if ( serviceXmlFile == null || ! serviceXmlFile . exists ( ) ) return ; final XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; final JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; xmlMapper . registerRootElement ( new QName ( "urn:jboss:service:7.0" , "server" ) , jBossServiceXmlDescriptorParser ) ; xmlMapper . registerRootElement ( new QName ( null , "server" ) , jBossServiceXmlDescriptorParser ) ; InputStream xmlStream = null ; try { xmlStream = serviceXmlFile . openStream ( ) ; final XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; final ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; xmlMapper . parseDocument ( result , reader ) ; final JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; if ( xmlDescriptor != null ) phaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; else throw SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; } catch ( Exception e ) { throw SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; } finally { VFSUtils . safeClose ( xmlStream ) ; } }	<s> Process a deployment for jboss - service . xml files . Will parse the xml file and attach a configuration discovered during processing . </s>
public T getValue ( ) throws IllegalStateException { final Context context = contextValue . getValue ( ) ; try { return ( T ) context . lookup ( contextName ) ; } catch ( NamingException e ) { throw NamingLogger . ROOT_LOGGER . entryNotRegistered ( e , contextName , context ) ; } }	<s> Lookup the value from the naming context . </s>
public void start ( StartContext context ) throws StartException { ROOT_LOGGER . startingService ( ) ; try { NamingContext . setActiveNamingStore ( namingStore . getValue ( ) ) ; } catch ( Throwable t ) { throw new StartException ( NamingLogger . ROOT_LOGGER . failedToStart ( "naming service" ) , t ) ; } }	<s> Creates a new NamingServer and sets the naming context to use the naming server . </s>
public void unbind ( final Name name ) throws NamingException { if ( isLastComponentEmpty ( name ) ) { throw emptyNameException ( ) ; } writeLock . lock ( ) ; try { root . accept ( new UnbindVisitor ( name ) ) ; } finally { writeLock . unlock ( ) ; } }	<s> Unbind the entry in the provided location . This will remove the node in the tree and no longer manage it . </s>
public Object lookup ( final Name name ) throws NamingException { if ( isEmpty ( name ) ) { final Name emptyName = new CompositeName ( "" ) ; return new NamingContext ( emptyName , this , new Hashtable < String , Object > ( ) ) ; } return root . accept ( new LookupVisitor ( name ) ) ; }	<s> Lookup the object value of a binding node in the tree . </s>
public static void setActiveNamingStore ( final NamingStore namingStore ) { if ( WildFlySecurityManager . isChecking ( ) ) { System . getSecurityManager ( ) . checkPermission ( SET_ACTIVE_NAMING_STORE ) ; } ACTIVE_NAMING_STORE = namingStore ; }	<s> Set the active naming store </s>
public List < NameClassPair > list ( final Name name ) throws NamingException { final Name nodeName = name . isEmpty ( ) ? new CompositeName ( "" ) : name ; return root . accept ( new ListVisitor ( nodeName ) ) ; }	<s> List all NameClassPair instances at a given location in the tree . </s>
public List < Binding > listBindings ( final Name name ) throws NamingException { final Name nodeName = name . isEmpty ( ) ? new CompositeName ( "" ) : name ; return root . accept ( new ListBindingsVisitor ( nodeName ) ) ; }	<s> List all the Binding instances at a given location in the tree . </s>
public static String getLastComponent ( final Name name ) { if ( name . size ( ) > 0 ) return name . get ( name . size ( ) - 1 ) ; return "" ; }	<s> Get the last component of a name . </s>
public static boolean isEmpty ( final Name name ) { return name . isEmpty ( ) || ( name . size ( ) == 1 && "" . equals ( name . get ( 0 ) ) ) ; }	<s> Determine if a name is empty or if ot contains only one component which is the empty string . </s>
