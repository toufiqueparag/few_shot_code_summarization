def bugs ( self , * bug_ids ) : params = { self . PBUG_ID : bug_ids , self . PCTYPE : self . CTYPE_XML , self . PEXCLUDE_FIELD : 'attachmentdata' } response = self . call ( self . CGI_BUG , params ) return response	<s> Get the information of a list of bugs in XML format . </s>
def metadata ( self ) : params = { self . PCTYPE : self . CTYPE_XML } response = self . call ( self . CGI_BUG , params ) return response	<s> Get metadata information in XML format . </s>
def bug_activity ( self , bug_id ) : params = { self . PBUG_ID : bug_id } response = self . call ( self . CGI_BUG_ACTIVITY , params ) return response	<s> Get the activity of a bug in HTML format . </s>
def buglist ( self , from_date = DEFAULT_DATETIME ) : if not self . version : self . version = self . __fetch_version ( ) if self . version in self . OLD_STYLE_VERSIONS : order = 'Last+Changed' else : order = 'changeddate' date = from_date . strftime ( "%Y-%m-%d %H:%M:%S" ) params = { self . PCHFIELD_FROM : date , self . PCTYPE : self . CTYPE_CSV , self . PLIMIT : self . max_bugs_csv , self . PORDER : order } response = self . call ( self . CGI_BUGLIST , params ) return response	<s> Get a summary of bugs in CSV format . </s>
def parse_buglist ( raw_csv ) : reader = csv . DictReader ( raw_csv . split ( '\n' ) , delimiter = ',' , quotechar = '"' ) for row in reader : yield row	<s> Parse a Bugzilla CSV bug list . </s>
def xml_to_dict ( raw_xml ) : def node_to_dict ( node ) : d = { } d . update ( node . items ( ) ) text = getattr ( node , 'text' , None ) if text is not None : d [ '__text__' ] = text childs = { } for child in node : childs . setdefault ( child . tag , [ ] ) . append ( node_to_dict ( child ) ) d . update ( childs . items ( ) ) return d purged_xml = remove_invalid_xml_chars ( raw_xml ) try : tree = xml . etree . ElementTree . fromstring ( purged_xml ) except xml . etree . ElementTree . ParseError as e : cause = "XML stream %s" % ( str ( e ) ) raise ParseError ( cause = cause ) d = node_to_dict ( tree ) return d	<s> Convert a XML stream into a dictionary . </s>
def parse_bugs_details ( raw_xml ) : bugs = xml_to_dict ( raw_xml ) if 'bug' not in bugs : cause = "No bugs found. XML stream seems to be invalid." raise ParseError ( cause = cause ) for bug in bugs [ 'bug' ] : yield bug	<s> Parse a Bugilla bugs details XML stream . </s>
def parse_bug_activity ( raw_html ) : def is_activity_empty ( bs ) : EMPTY_ACTIVITY = "No changes have been made to this (?:bug|issue) yet." tag = bs . find ( text = re . compile ( EMPTY_ACTIVITY ) ) return tag is not None def find_activity_table ( bs ) : # The first table with 5 columns is the table of activity tables = bs . find_all ( 'table' ) for tb in tables : nheaders = len ( tb . tr . find_all ( 'th' , recursive = False ) ) if nheaders == 5 : return tb raise ParseError ( cause = "Table of bug activity not found." ) def remove_tags ( bs ) : HTML_TAGS_TO_REMOVE = [ 'a' , 'i' , 'span' ] for tag in bs . find_all ( HTML_TAGS_TO_REMOVE ) : tag . replaceWith ( tag . text ) def format_text ( bs ) : strings = [ s . strip ( ' \n\t' ) for s in bs . stripped_strings ] s = ' ' . join ( strings ) return s # Parsing starts here bs = bs4 . BeautifulSoup ( raw_html , 'html.parser' ) if is_activity_empty ( bs ) : fields = [ ] else : activity_tb = find_activity_table ( bs ) remove_tags ( activity_tb ) fields = activity_tb . find_all ( 'td' ) while fields : # First two fields: 'Who' and 'When'. who = fields . pop ( 0 ) when = fields . pop ( 0 ) # The attribute 'rowspan' of 'who' field tells how many # changes were made on the same date. n = int ( who . get ( 'rowspan' ) ) # Next fields are split into chunks of three elements: # 'What', 'Removed' and 'Added'. These chunks share # 'Who' and 'When' values. for _ in range ( n ) : what = fields . pop ( 0 ) removed = fields . pop ( 0 ) added = fields . pop ( 0 ) event = { 'Who' : format_text ( who ) , 'When' : format_text ( when ) , 'What' : format_text ( what ) , 'Removed' : format_text ( removed ) , 'Added' : format_text ( added ) } yield event	<s> Parse a Bugzilla bug activity HTML stream . </s>
def _set_output_arguments ( self ) : group = self . parser . add_argument_group ( 'output arguments' ) group . add_argument ( '-o' , '--output' , type = argparse . FileType ( 'w' ) , dest = 'outfile' , default = sys . stdout , help = "output file" ) group . add_argument ( '--json-line' , dest = 'json_line' , action = 'store_true' , help = "produce a JSON line for each output item" )	<s> Activate output arguments parsing </s>
def reviews ( self , last_item , filter_ = None ) : cmd = self . _get_gerrit_cmd ( last_item , filter_ ) logger . debug ( "Getting reviews with command: %s" , cmd ) raw_data = self . __execute ( cmd ) raw_data = str ( raw_data , "UTF-8" ) return raw_data	<s> Get the reviews starting from last_item . </s>
