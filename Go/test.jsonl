{"repo": "omniscale/go-mapnik", "path": "mapnik.go", "func_name": "NewSized", "original_string": "func NewSized(width, height int) *Map {\n\treturn &Map{\n\t\tm:      C.mapnik_map(C.uint(width), C.uint(height)),\n\t\twidth:  width,\n\t\theight: height,\n\t}\n}", "language": "go", "code": "func NewSized(width, height int) *Map {\n\treturn &Map{\n\t\tm:      C.mapnik_map(C.uint(width), C.uint(height)),\n\t\twidth:  width,\n\t\theight: height,\n\t}\n}", "code_tokens": ["func", "NewSized", "(", "width", ",", "height", "int", ")", "*", "Map", "{", "return", "&", "Map", "{", "m", ":", "C", ".", "mapnik_map", "(", "C", ".", "uint", "(", "width", ")", ",", "C", ".", "uint", "(", "height", ")", ")", ",", "width", ":", "width", ",", "height", ":", "height", ",", "}", "\n", "}"], "docstring": "// NewSized initializes a new Map with the given size.", "docstring_tokens": ["NewSized", "initializes", "a", "new", "Map", "with", "the", "given", "size", "."], "sha": "710dfcc5e486e5760d0a5c46be909d91968e1ffb", "url": "https://github.com/omniscale/go-mapnik/blob/710dfcc5e486e5760d0a5c46be909d91968e1ffb/mapnik.go#L108-L114", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "channel.go", "func_name": "connectionCloseStateChange", "original_string": "func (ch *Channel) connectionCloseStateChange(c *Connection) {\n\tch.removeClosedConn(c)\n\tif peer, ok := ch.RootPeers().Get(c.remotePeerInfo.HostPort); ok {\n\t\tpeer.connectionCloseStateChange(c)\n\t\tch.updatePeer(peer)\n\t}\n\tif c.outboundHP != \"\" && c.outboundHP != c.remotePeerInfo.HostPort {\n\t\t// Outbound connections may be in multiple peers.\n\t\tif peer, ok := ch.RootPeers().Get(c.outboundHP); ok {\n\t\t\tpeer.connectionCloseStateChange(c)\n\t\t\tch.updatePeer(peer)\n\t\t}\n\t}\n\n\tchState := ch.State()\n\tif chState != ChannelStartClose && chState != ChannelInboundClosed {\n\t\treturn\n\t}\n\n\tch.mutable.RLock()\n\tminState := ch.getMinConnectionState()\n\tch.mutable.RUnlock()\n\n\tvar updateTo ChannelState\n\tif minState >= connectionClosed {\n\t\tupdateTo = ChannelClosed\n\t} else if minState >= connectionInboundClosed && chState == ChannelStartClose {\n\t\tupdateTo = ChannelInboundClosed\n\t}\n\n\tvar updatedToState ChannelState\n\tif updateTo > 0 {\n\t\tch.mutable.Lock()\n\t\t// Recheck the state as it's possible another goroutine changed the state\n\t\t// from what we expected, and so we might make a stale change.\n\t\tif ch.mutable.state == chState {\n\t\t\tch.mutable.state = updateTo\n\t\t\tupdatedToState = updateTo\n\t\t}\n\t\tch.mutable.Unlock()\n\t\tchState = updateTo\n\t}\n\n\tc.log.Debugf(\"ConnectionCloseStateChange channel state = %v connection minState = %v\",\n\t\tchState, minState)\n\n\tif updatedToState == ChannelClosed {\n\t\tch.onClosed()\n\t}\n}", "language": "go", "code": "func (ch *Channel) connectionCloseStateChange(c *Connection) {\n\tch.removeClosedConn(c)\n\tif peer, ok := ch.RootPeers().Get(c.remotePeerInfo.HostPort); ok {\n\t\tpeer.connectionCloseStateChange(c)\n\t\tch.updatePeer(peer)\n\t}\n\tif c.outboundHP != \"\" && c.outboundHP != c.remotePeerInfo.HostPort {\n\t\t// Outbound connections may be in multiple peers.\n\t\tif peer, ok := ch.RootPeers().Get(c.outboundHP); ok {\n\t\t\tpeer.connectionCloseStateChange(c)\n\t\t\tch.updatePeer(peer)\n\t\t}\n\t}\n\n\tchState := ch.State()\n\tif chState != ChannelStartClose && chState != ChannelInboundClosed {\n\t\treturn\n\t}\n\n\tch.mutable.RLock()\n\tminState := ch.getMinConnectionState()\n\tch.mutable.RUnlock()\n\n\tvar updateTo ChannelState\n\tif minState >= connectionClosed {\n\t\tupdateTo = ChannelClosed\n\t} else if minState >= connectionInboundClosed && chState == ChannelStartClose {\n\t\tupdateTo = ChannelInboundClosed\n\t}\n\n\tvar updatedToState ChannelState\n\tif updateTo > 0 {\n\t\tch.mutable.Lock()\n\t\t// Recheck the state as it's possible another goroutine changed the state\n\t\t// from what we expected, and so we might make a stale change.\n\t\tif ch.mutable.state == chState {\n\t\t\tch.mutable.state = updateTo\n\t\t\tupdatedToState = updateTo\n\t\t}\n\t\tch.mutable.Unlock()\n\t\tchState = updateTo\n\t}\n\n\tc.log.Debugf(\"ConnectionCloseStateChange channel state = %v connection minState = %v\",\n\t\tchState, minState)\n\n\tif updatedToState == ChannelClosed {\n\t\tch.onClosed()\n\t}\n}", "code_tokens": ["func", "(", "ch", "*", "Channel", ")", "connectionCloseStateChange", "(", "c", "*", "Connection", ")", "{", "ch", ".", "removeClosedConn", "(", "c", ")", "\n", "if", "peer", ",", "ok", ":=", "ch", ".", "RootPeers", "(", ")", ".", "Get", "(", "c", ".", "remotePeerInfo", ".", "HostPort", ")", ";", "ok", "{", "peer", ".", "connectionCloseStateChange", "(", "c", ")", "\n", "ch", ".", "updatePeer", "(", "peer", ")", "\n", "}", "\n", "if", "c", ".", "outboundHP", "!=", "\"", "\"", "&&", "c", ".", "outboundHP", "!=", "c", ".", "remotePeerInfo", ".", "HostPort", "{", "// Outbound connections may be in multiple peers.", "if", "peer", ",", "ok", ":=", "ch", ".", "RootPeers", "(", ")", ".", "Get", "(", "c", ".", "outboundHP", ")", ";", "ok", "{", "peer", ".", "connectionCloseStateChange", "(", "c", ")", "\n", "ch", ".", "updatePeer", "(", "peer", ")", "\n", "}", "\n", "}", "\n\n", "chState", ":=", "ch", ".", "State", "(", ")", "\n", "if", "chState", "!=", "ChannelStartClose", "&&", "chState", "!=", "ChannelInboundClosed", "{", "return", "\n", "}", "\n\n", "ch", ".", "mutable", ".", "RLock", "(", ")", "\n", "minState", ":=", "ch", ".", "getMinConnectionState", "(", ")", "\n", "ch", ".", "mutable", ".", "RUnlock", "(", ")", "\n\n", "var", "updateTo", "ChannelState", "\n", "if", "minState", ">=", "connectionClosed", "{", "updateTo", "=", "ChannelClosed", "\n", "}", "else", "if", "minState", ">=", "connectionInboundClosed", "&&", "chState", "==", "ChannelStartClose", "{", "updateTo", "=", "ChannelInboundClosed", "\n", "}", "\n\n", "var", "updatedToState", "ChannelState", "\n", "if", "updateTo", ">", "0", "{", "ch", ".", "mutable", ".", "Lock", "(", ")", "\n", "// Recheck the state as it's possible another goroutine changed the state", "// from what we expected, and so we might make a stale change.", "if", "ch", ".", "mutable", ".", "state", "==", "chState", "{", "ch", ".", "mutable", ".", "state", "=", "updateTo", "\n", "updatedToState", "=", "updateTo", "\n", "}", "\n", "ch", ".", "mutable", ".", "Unlock", "(", ")", "\n", "chState", "=", "updateTo", "\n", "}", "\n\n", "c", ".", "log", ".", "Debugf", "(", "\"", "\"", ",", "chState", ",", "minState", ")", "\n\n", "if", "updatedToState", "==", "ChannelClosed", "{", "ch", ".", "onClosed", "(", ")", "\n", "}", "\n", "}"], "docstring": "// connectionCloseStateChange is called when a connection's close state changes.", "docstring_tokens": ["connectionCloseStateChange", "is", "called", "when", "a", "connection", "s", "close", "state", "changes", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/channel.go#L710-L759", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/github/types.go", "func_name": "IsAssignee", "original_string": "func (i Issue) IsAssignee(login string) bool {\n\tfor _, assignee := range i.Assignees {\n\t\tif NormLogin(login) == NormLogin(assignee.Login) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "language": "go", "code": "func (i Issue) IsAssignee(login string) bool {\n\tfor _, assignee := range i.Assignees {\n\t\tif NormLogin(login) == NormLogin(assignee.Login) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "code_tokens": ["func", "(", "i", "Issue", ")", "IsAssignee", "(", "login", "string", ")", "bool", "{", "for", "_", ",", "assignee", ":=", "range", "i", ".", "Assignees", "{", "if", "NormLogin", "(", "login", ")", "==", "NormLogin", "(", "assignee", ".", "Login", ")", "{", "return", "true", "\n", "}", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// IsAssignee checks if a user is assigned to the issue.", "docstring_tokens": ["IsAssignee", "checks", "if", "a", "user", "is", "assigned", "to", "the", "issue", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/types.go#L529-L536", "partition": "test"}
{"repo": "kljensen/snowball", "path": "english/common.go", "func_name": "uncapitalizeYs", "original_string": "func uncapitalizeYs(word *snowballword.SnowballWord) {\n\tfor i, r := range word.RS {\n\n\t\t// (Note: Y & y unicode code points = 89 & 121)\n\n\t\tif r == 89 {\n\t\t\tword.RS[i] = 121\n\t\t}\n\t}\n\treturn\n}", "language": "go", "code": "func uncapitalizeYs(word *snowballword.SnowballWord) {\n\tfor i, r := range word.RS {\n\n\t\t// (Note: Y & y unicode code points = 89 & 121)\n\n\t\tif r == 89 {\n\t\t\tword.RS[i] = 121\n\t\t}\n\t}\n\treturn\n}", "code_tokens": ["func", "uncapitalizeYs", "(", "word", "*", "snowballword", ".", "SnowballWord", ")", "{", "for", "i", ",", "r", ":=", "range", "word", ".", "RS", "{", "// (Note: Y & y unicode code points = 89 & 121)", "if", "r", "==", "89", "{", "word", ".", "RS", "[", "i", "]", "=", "121", "\n", "}", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// Uncapitalize all 'Y's\n//", "docstring_tokens": ["Uncapitalize", "all", "Y", "s"], "sha": "115fa8f6419dcfb9ec4653997b1c6803a5eff962", "url": "https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/english/common.go#L68-L78", "partition": "test"}
{"repo": "containers/image", "path": "pkg/tlsclientconfig/tlsclientconfig.go", "func_name": "NewTransport", "original_string": "func NewTransport() *http.Transport {\n\tdirect := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t\tDualStack: true,\n\t}\n\ttr := &http.Transport{\n\t\tProxy:               http.ProxyFromEnvironment,\n\t\tDial:                direct.Dial,\n\t\tTLSHandshakeTimeout: 10 * time.Second,\n\t\t// TODO(dmcgowan): Call close idle connections when complete and use keep alive\n\t\tDisableKeepAlives: true,\n\t}\n\tproxyDialer, err := sockets.DialerFromEnvironment(direct)\n\tif err == nil {\n\t\ttr.Dial = proxyDialer.Dial\n\t}\n\treturn tr\n}", "language": "go", "code": "func NewTransport() *http.Transport {\n\tdirect := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t\tDualStack: true,\n\t}\n\ttr := &http.Transport{\n\t\tProxy:               http.ProxyFromEnvironment,\n\t\tDial:                direct.Dial,\n\t\tTLSHandshakeTimeout: 10 * time.Second,\n\t\t// TODO(dmcgowan): Call close idle connections when complete and use keep alive\n\t\tDisableKeepAlives: true,\n\t}\n\tproxyDialer, err := sockets.DialerFromEnvironment(direct)\n\tif err == nil {\n\t\ttr.Dial = proxyDialer.Dial\n\t}\n\treturn tr\n}", "code_tokens": ["func", "NewTransport", "(", ")", "*", "http", ".", "Transport", "{", "direct", ":=", "&", "net", ".", "Dialer", "{", "Timeout", ":", "30", "*", "time", ".", "Second", ",", "KeepAlive", ":", "30", "*", "time", ".", "Second", ",", "DualStack", ":", "true", ",", "}", "\n", "tr", ":=", "&", "http", ".", "Transport", "{", "Proxy", ":", "http", ".", "ProxyFromEnvironment", ",", "Dial", ":", "direct", ".", "Dial", ",", "TLSHandshakeTimeout", ":", "10", "*", "time", ".", "Second", ",", "// TODO(dmcgowan): Call close idle connections when complete and use keep alive", "DisableKeepAlives", ":", "true", ",", "}", "\n", "proxyDialer", ",", "err", ":=", "sockets", ".", "DialerFromEnvironment", "(", "direct", ")", "\n", "if", "err", "==", "nil", "{", "tr", ".", "Dial", "=", "proxyDialer", ".", "Dial", "\n", "}", "\n", "return", "tr", "\n", "}"], "docstring": "// NewTransport Creates a default transport", "docstring_tokens": ["NewTransport", "Creates", "a", "default", "transport"], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/pkg/tlsclientconfig/tlsclientconfig.go#L94-L112", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "errors.go", "func_name": "NewSystemError", "original_string": "func NewSystemError(code SystemErrCode, msg string, args ...interface{}) error {\n\treturn SystemError{code: code, msg: fmt.Sprintf(msg, args...)}\n}", "language": "go", "code": "func NewSystemError(code SystemErrCode, msg string, args ...interface{}) error {\n\treturn SystemError{code: code, msg: fmt.Sprintf(msg, args...)}\n}", "code_tokens": ["func", "NewSystemError", "(", "code", "SystemErrCode", ",", "msg", "string", ",", "args", "...", "interface", "{", "}", ")", "error", "{", "return", "SystemError", "{", "code", ":", "code", ",", "msg", ":", "fmt", ".", "Sprintf", "(", "msg", ",", "args", "...", ")", "}", "\n", "}"], "docstring": "// NewSystemError defines a new SystemError with a code and message", "docstring_tokens": ["NewSystemError", "defines", "a", "new", "SystemError", "with", "a", "code", "and", "message"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/errors.go#L163-L165", "partition": "test"}
{"repo": "profitbricks/profitbricks-sdk-go", "path": "snapshot.go", "func_name": "GetSnapshot", "original_string": "func (c *Client) GetSnapshot(snapshotID string) (*Snapshot, error) {\n\turl := snapshotColPath() + slash(snapshotID) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &Snapshot{}\n\terr := c.client.Get(url, ret, http.StatusOK)\n\treturn ret, err\n}", "language": "go", "code": "func (c *Client) GetSnapshot(snapshotID string) (*Snapshot, error) {\n\turl := snapshotColPath() + slash(snapshotID) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &Snapshot{}\n\terr := c.client.Get(url, ret, http.StatusOK)\n\treturn ret, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "GetSnapshot", "(", "snapshotID", "string", ")", "(", "*", "Snapshot", ",", "error", ")", "{", "url", ":=", "snapshotColPath", "(", ")", "+", "slash", "(", "snapshotID", ")", "+", "`?depth=`", "+", "c", ".", "client", ".", "depth", "+", "`&pretty=`", "+", "strconv", ".", "FormatBool", "(", "c", ".", "client", ".", "pretty", ")", "\n", "ret", ":=", "&", "Snapshot", "{", "}", "\n", "err", ":=", "c", ".", "client", ".", "Get", "(", "url", ",", "ret", ",", "http", ".", "StatusOK", ")", "\n", "return", "ret", ",", "err", "\n", "}"], "docstring": "//GetSnapshot gets a specific snapshot", "docstring_tokens": ["GetSnapshot", "gets", "a", "specific", "snapshot"], "sha": "1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4", "url": "https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/snapshot.go#L59-L64", "partition": "test"}
{"repo": "abh/geoip", "path": "geoip.go", "func_name": "OpenDb", "original_string": "func OpenDb(files []string, flag int) (*GeoIP, error) {\n\tif len(files) == 0 {\n\t\tfiles = []string{\n\t\t\t\"/usr/share/GeoIP/GeoIP.dat\",       // Linux default\n\t\t\t\"/usr/share/local/GeoIP/GeoIP.dat\", // source install?\n\t\t\t\"/usr/local/share/GeoIP/GeoIP.dat\", // FreeBSD\n\t\t\t\"/opt/local/share/GeoIP/GeoIP.dat\", // MacPorts\n\t\t\t\"/usr/share/GeoIP/GeoIP.dat\",       // ArchLinux\n\t\t}\n\t}\n\n\tg := &GeoIP{}\n\truntime.SetFinalizer(g, (*GeoIP).free)\n\n\tvar err error\n\n\tfor _, file := range files {\n\n\t\t// libgeoip prints errors if it can't open the file, so check first\n\t\tif _, err := os.Stat(file); err != nil {\n\t\t\tif os.IsExist(err) {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tcbase := C.CString(file)\n\t\tdefer C.free(unsafe.Pointer(cbase))\n\n\t\tg.db, err = C.GeoIP_open(cbase, C.int(flag))\n\t\tif g.db != nil && err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error opening GeoIP database (%s): %s\", files, err)\n\t}\n\n\tif g.db == nil {\n\t\treturn nil, fmt.Errorf(\"Didn't open GeoIP database (%s)\", files)\n\t}\n\n\tC.GeoIP_set_charset(g.db, C.GEOIP_CHARSET_UTF8)\n\treturn g, nil\n}", "language": "go", "code": "func OpenDb(files []string, flag int) (*GeoIP, error) {\n\tif len(files) == 0 {\n\t\tfiles = []string{\n\t\t\t\"/usr/share/GeoIP/GeoIP.dat\",       // Linux default\n\t\t\t\"/usr/share/local/GeoIP/GeoIP.dat\", // source install?\n\t\t\t\"/usr/local/share/GeoIP/GeoIP.dat\", // FreeBSD\n\t\t\t\"/opt/local/share/GeoIP/GeoIP.dat\", // MacPorts\n\t\t\t\"/usr/share/GeoIP/GeoIP.dat\",       // ArchLinux\n\t\t}\n\t}\n\n\tg := &GeoIP{}\n\truntime.SetFinalizer(g, (*GeoIP).free)\n\n\tvar err error\n\n\tfor _, file := range files {\n\n\t\t// libgeoip prints errors if it can't open the file, so check first\n\t\tif _, err := os.Stat(file); err != nil {\n\t\t\tif os.IsExist(err) {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tcbase := C.CString(file)\n\t\tdefer C.free(unsafe.Pointer(cbase))\n\n\t\tg.db, err = C.GeoIP_open(cbase, C.int(flag))\n\t\tif g.db != nil && err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error opening GeoIP database (%s): %s\", files, err)\n\t}\n\n\tif g.db == nil {\n\t\treturn nil, fmt.Errorf(\"Didn't open GeoIP database (%s)\", files)\n\t}\n\n\tC.GeoIP_set_charset(g.db, C.GEOIP_CHARSET_UTF8)\n\treturn g, nil\n}", "code_tokens": ["func", "OpenDb", "(", "files", "[", "]", "string", ",", "flag", "int", ")", "(", "*", "GeoIP", ",", "error", ")", "{", "if", "len", "(", "files", ")", "==", "0", "{", "files", "=", "[", "]", "string", "{", "\"", "\"", ",", "// Linux default", "\"", "\"", ",", "// source install?", "\"", "\"", ",", "// FreeBSD", "\"", "\"", ",", "// MacPorts", "\"", "\"", ",", "// ArchLinux", "}", "\n", "}", "\n\n", "g", ":=", "&", "GeoIP", "{", "}", "\n", "runtime", ".", "SetFinalizer", "(", "g", ",", "(", "*", "GeoIP", ")", ".", "free", ")", "\n\n", "var", "err", "error", "\n\n", "for", "_", ",", "file", ":=", "range", "files", "{", "// libgeoip prints errors if it can't open the file, so check first", "if", "_", ",", "err", ":=", "os", ".", "Stat", "(", "file", ")", ";", "err", "!=", "nil", "{", "if", "os", ".", "IsExist", "(", "err", ")", "{", "log", ".", "Println", "(", "err", ")", "\n", "}", "\n", "continue", "\n", "}", "\n\n", "cbase", ":=", "C", ".", "CString", "(", "file", ")", "\n", "defer", "C", ".", "free", "(", "unsafe", ".", "Pointer", "(", "cbase", ")", ")", "\n\n", "g", ".", "db", ",", "err", "=", "C", ".", "GeoIP_open", "(", "cbase", ",", "C", ".", "int", "(", "flag", ")", ")", "\n", "if", "g", ".", "db", "!=", "nil", "&&", "err", "!=", "nil", "{", "break", "\n", "}", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "files", ",", "err", ")", "\n", "}", "\n\n", "if", "g", ".", "db", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "files", ")", "\n", "}", "\n\n", "C", ".", "GeoIP_set_charset", "(", "g", ".", "db", ",", "C", ".", "GEOIP_CHARSET_UTF8", ")", "\n", "return", "g", ",", "nil", "\n", "}"], "docstring": "// Opens a GeoIP database by filename with specified GeoIPOptions flag.\n// All formats supported by libgeoip are supported though there are only\n// functions to access some of the databases in this API.\n// If you don't pass a filename, it will try opening the database from\n// a list of common paths.", "docstring_tokens": ["Opens", "a", "GeoIP", "database", "by", "filename", "with", "specified", "GeoIPOptions", "flag", ".", "All", "formats", "supported", "by", "libgeoip", "are", "supported", "though", "there", "are", "only", "functions", "to", "access", "some", "of", "the", "databases", "in", "this", "API", ".", "If", "you", "don", "t", "pass", "a", "filename", "it", "will", "try", "opening", "the", "database", "from", "a", "list", "of", "common", "paths", "."], "sha": "07cea4480daa3f28edd2856f2a0490fbe83842eb", "url": "https://github.com/abh/geoip/blob/07cea4480daa3f28edd2856f2a0490fbe83842eb/geoip.go#L58-L102", "partition": "test"}
{"repo": "libp2p/go-libp2p-routing", "path": "notifications/query.go", "func_name": "send", "original_string": "func (e *eventChannel) send(ctx context.Context, ev *QueryEvent) {\n\te.mu.Lock()\n\t// Closed.\n\tif e.ch == nil {\n\t\te.mu.Unlock()\n\t\treturn\n\t}\n\t// in case the passed context is unrelated, wait on both.\n\tselect {\n\tcase e.ch <- ev:\n\tcase <-e.ctx.Done():\n\tcase <-ctx.Done():\n\t}\n\te.mu.Unlock()\n}", "language": "go", "code": "func (e *eventChannel) send(ctx context.Context, ev *QueryEvent) {\n\te.mu.Lock()\n\t// Closed.\n\tif e.ch == nil {\n\t\te.mu.Unlock()\n\t\treturn\n\t}\n\t// in case the passed context is unrelated, wait on both.\n\tselect {\n\tcase e.ch <- ev:\n\tcase <-e.ctx.Done():\n\tcase <-ctx.Done():\n\t}\n\te.mu.Unlock()\n}", "code_tokens": ["func", "(", "e", "*", "eventChannel", ")", "send", "(", "ctx", "context", ".", "Context", ",", "ev", "*", "QueryEvent", ")", "{", "e", ".", "mu", ".", "Lock", "(", ")", "\n", "// Closed.", "if", "e", ".", "ch", "==", "nil", "{", "e", ".", "mu", ".", "Unlock", "(", ")", "\n", "return", "\n", "}", "\n", "// in case the passed context is unrelated, wait on both.", "select", "{", "case", "e", ".", "ch", "<-", "ev", ":", "case", "<-", "e", ".", "ctx", ".", "Done", "(", ")", ":", "case", "<-", "ctx", ".", "Done", "(", ")", ":", "}", "\n", "e", ".", "mu", ".", "Unlock", "(", ")", "\n", "}"], "docstring": "// send sends an event on the event channel, aborting if either the passed or\n// the internal context expire.", "docstring_tokens": ["send", "sends", "an", "event", "on", "the", "event", "channel", "aborting", "if", "either", "the", "passed", "or", "the", "internal", "context", "expire", "."], "sha": "15c28e7faa25921fd1160412003fecdc70e09a5c", "url": "https://github.com/libp2p/go-libp2p-routing/blob/15c28e7faa25921fd1160412003fecdc70e09a5c/notifications/query.go#L56-L70", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/statusreconciler/controller.go", "func_name": "migratedBlockingPresubmits", "original_string": "func migratedBlockingPresubmits(old, new map[string][]config.Presubmit) map[string][]presubmitMigration {\n\tmigrated := map[string][]presubmitMigration{}\n\n\tfor repo, oldPresubmits := range old {\n\t\tmigrated[repo] = []presubmitMigration{}\n\t\tfor _, newPresubmit := range new[repo] {\n\t\t\tif !newPresubmit.ContextRequired() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, oldPresubmit := range oldPresubmits {\n\t\t\t\tif oldPresubmit.Context != newPresubmit.Context && oldPresubmit.Name == newPresubmit.Name {\n\t\t\t\t\tmigrated[repo] = append(migrated[repo], presubmitMigration{from: oldPresubmit, to: newPresubmit})\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"repo\": repo,\n\t\t\t\t\t\t\"name\": oldPresubmit.Name,\n\t\t\t\t\t\t\"from\": oldPresubmit.Context,\n\t\t\t\t\t\t\"to\":   newPresubmit.Context,\n\t\t\t\t\t}).Debug(\"Identified a migrated blocking presubmit.\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar numMigrated int\n\tfor _, presubmits := range migrated {\n\t\tnumMigrated += len(presubmits)\n\t}\n\tlogrus.Infof(\"Identified %d migrated blocking presubmits.\", numMigrated)\n\treturn migrated\n}", "language": "go", "code": "func migratedBlockingPresubmits(old, new map[string][]config.Presubmit) map[string][]presubmitMigration {\n\tmigrated := map[string][]presubmitMigration{}\n\n\tfor repo, oldPresubmits := range old {\n\t\tmigrated[repo] = []presubmitMigration{}\n\t\tfor _, newPresubmit := range new[repo] {\n\t\t\tif !newPresubmit.ContextRequired() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, oldPresubmit := range oldPresubmits {\n\t\t\t\tif oldPresubmit.Context != newPresubmit.Context && oldPresubmit.Name == newPresubmit.Name {\n\t\t\t\t\tmigrated[repo] = append(migrated[repo], presubmitMigration{from: oldPresubmit, to: newPresubmit})\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"repo\": repo,\n\t\t\t\t\t\t\"name\": oldPresubmit.Name,\n\t\t\t\t\t\t\"from\": oldPresubmit.Context,\n\t\t\t\t\t\t\"to\":   newPresubmit.Context,\n\t\t\t\t\t}).Debug(\"Identified a migrated blocking presubmit.\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar numMigrated int\n\tfor _, presubmits := range migrated {\n\t\tnumMigrated += len(presubmits)\n\t}\n\tlogrus.Infof(\"Identified %d migrated blocking presubmits.\", numMigrated)\n\treturn migrated\n}", "code_tokens": ["func", "migratedBlockingPresubmits", "(", "old", ",", "new", "map", "[", "string", "]", "[", "]", "config", ".", "Presubmit", ")", "map", "[", "string", "]", "[", "]", "presubmitMigration", "{", "migrated", ":=", "map", "[", "string", "]", "[", "]", "presubmitMigration", "{", "}", "\n\n", "for", "repo", ",", "oldPresubmits", ":=", "range", "old", "{", "migrated", "[", "repo", "]", "=", "[", "]", "presubmitMigration", "{", "}", "\n", "for", "_", ",", "newPresubmit", ":=", "range", "new", "[", "repo", "]", "{", "if", "!", "newPresubmit", ".", "ContextRequired", "(", ")", "{", "continue", "\n", "}", "\n", "for", "_", ",", "oldPresubmit", ":=", "range", "oldPresubmits", "{", "if", "oldPresubmit", ".", "Context", "!=", "newPresubmit", ".", "Context", "&&", "oldPresubmit", ".", "Name", "==", "newPresubmit", ".", "Name", "{", "migrated", "[", "repo", "]", "=", "append", "(", "migrated", "[", "repo", "]", ",", "presubmitMigration", "{", "from", ":", "oldPresubmit", ",", "to", ":", "newPresubmit", "}", ")", "\n", "logrus", ".", "WithFields", "(", "logrus", ".", "Fields", "{", "\"", "\"", ":", "repo", ",", "\"", "\"", ":", "oldPresubmit", ".", "Name", ",", "\"", "\"", ":", "oldPresubmit", ".", "Context", ",", "\"", "\"", ":", "newPresubmit", ".", "Context", ",", "}", ")", ".", "Debug", "(", "\"", "\"", ")", "\n", "}", "\n", "}", "\n", "}", "\n", "}", "\n\n", "var", "numMigrated", "int", "\n", "for", "_", ",", "presubmits", ":=", "range", "migrated", "{", "numMigrated", "+=", "len", "(", "presubmits", ")", "\n", "}", "\n", "logrus", ".", "Infof", "(", "\"", "\"", ",", "numMigrated", ")", "\n", "return", "migrated", "\n", "}"], "docstring": "// migratedBlockingPresubmits determines blocking presubmits that have had\n// their status contexts migrated. This is a best-effort evaluation as we\n// can only track a presubmit between configuration versions by its name.\n// A presubmit \"migration\" that had its underlying job and context changed\n// will be treated as a deletion and creation.", "docstring_tokens": ["migratedBlockingPresubmits", "determines", "blocking", "presubmits", "that", "have", "had", "their", "status", "contexts", "migrated", ".", "This", "is", "a", "best", "-", "effort", "evaluation", "as", "we", "can", "only", "track", "a", "presubmit", "between", "configuration", "versions", "by", "its", "name", ".", "A", "presubmit", "migration", "that", "had", "its", "underlying", "job", "and", "context", "changed", "will", "be", "treated", "as", "a", "deletion", "and", "creation", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/statusreconciler/controller.go#L388-L417", "partition": "test"}
{"repo": "golang/debug", "path": "internal/gocore/region.go", "func_name": "SliceLen", "original_string": "func (r region) SliceLen() int64 {\n\tif r.typ.Kind != KindSlice {\n\t\tpanic(\"can't len a non-slice\")\n\t}\n\treturn r.p.proc.ReadInt(r.a.Add(r.p.proc.PtrSize()))\n}", "language": "go", "code": "func (r region) SliceLen() int64 {\n\tif r.typ.Kind != KindSlice {\n\t\tpanic(\"can't len a non-slice\")\n\t}\n\treturn r.p.proc.ReadInt(r.a.Add(r.p.proc.PtrSize()))\n}", "code_tokens": ["func", "(", "r", "region", ")", "SliceLen", "(", ")", "int64", "{", "if", "r", ".", "typ", ".", "Kind", "!=", "KindSlice", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "r", ".", "p", ".", "proc", ".", "ReadInt", "(", "r", ".", "a", ".", "Add", "(", "r", ".", "p", ".", "proc", ".", "PtrSize", "(", ")", ")", ")", "\n", "}"], "docstring": "// SliceLen returns the length of a slice. r must contain a slice.", "docstring_tokens": ["SliceLen", "returns", "the", "length", "of", "a", "slice", ".", "r", "must", "contain", "a", "slice", "."], "sha": "19561fee47cf8cd0400d1b094c5898002f97cf90", "url": "https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/gocore/region.go#L136-L141", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "provision/kubernetes/pkg/client/listers/tsuru/v1/app.go", "func_name": "List", "original_string": "func (s appNamespaceLister) List(selector labels.Selector) (ret []*v1.App, err error) {\n\terr = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1.App))\n\t})\n\treturn ret, err\n}", "language": "go", "code": "func (s appNamespaceLister) List(selector labels.Selector) (ret []*v1.App, err error) {\n\terr = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1.App))\n\t})\n\treturn ret, err\n}", "code_tokens": ["func", "(", "s", "appNamespaceLister", ")", "List", "(", "selector", "labels", ".", "Selector", ")", "(", "ret", "[", "]", "*", "v1", ".", "App", ",", "err", "error", ")", "{", "err", "=", "cache", ".", "ListAllByNamespace", "(", "s", ".", "indexer", ",", "s", ".", "namespace", ",", "selector", ",", "func", "(", "m", "interface", "{", "}", ")", "{", "ret", "=", "append", "(", "ret", ",", "m", ".", "(", "*", "v1", ".", "App", ")", ")", "\n", "}", ")", "\n", "return", "ret", ",", "err", "\n", "}"], "docstring": "// List lists all Apps in the indexer for a given namespace.", "docstring_tokens": ["List", "lists", "all", "Apps", "in", "the", "indexer", "for", "a", "given", "namespace", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/kubernetes/pkg/client/listers/tsuru/v1/app.go#L67-L72", "partition": "test"}
{"repo": "hashicorp/raft", "path": "replication.go", "func_name": "appendStats", "original_string": "func appendStats(peer string, start time.Time, logs float32) {\n\tmetrics.MeasureSince([]string{\"raft\", \"replication\", \"appendEntries\", \"rpc\", peer}, start)\n\tmetrics.IncrCounter([]string{\"raft\", \"replication\", \"appendEntries\", \"logs\", peer}, logs)\n}", "language": "go", "code": "func appendStats(peer string, start time.Time, logs float32) {\n\tmetrics.MeasureSince([]string{\"raft\", \"replication\", \"appendEntries\", \"rpc\", peer}, start)\n\tmetrics.IncrCounter([]string{\"raft\", \"replication\", \"appendEntries\", \"logs\", peer}, logs)\n}", "code_tokens": ["func", "appendStats", "(", "peer", "string", ",", "start", "time", ".", "Time", ",", "logs", "float32", ")", "{", "metrics", ".", "MeasureSince", "(", "[", "]", "string", "{", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "peer", "}", ",", "start", ")", "\n", "metrics", ".", "IncrCounter", "(", "[", "]", "string", "{", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "peer", "}", ",", "logs", ")", "\n", "}"], "docstring": "// appendStats is used to emit stats about an AppendEntries invocation.", "docstring_tokens": ["appendStats", "is", "used", "to", "emit", "stats", "about", "an", "AppendEntries", "invocation", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/replication.go#L547-L550", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "response.go", "func_name": "Flush", "original_string": "func (w *Response) Flush() {\n\tif f, ok := w.ResponseWriter.(http.Flusher); ok {\n\t\tf.Flush()\n\t}\n}", "language": "go", "code": "func (w *Response) Flush() {\n\tif f, ok := w.ResponseWriter.(http.Flusher); ok {\n\t\tf.Flush()\n\t}\n}", "code_tokens": ["func", "(", "w", "*", "Response", ")", "Flush", "(", ")", "{", "if", "f", ",", "ok", ":=", "w", ".", "ResponseWriter", ".", "(", "http", ".", "Flusher", ")", ";", "ok", "{", "f", ".", "Flush", "(", ")", "\n", "}", "\n", "}"], "docstring": "// Flush the response", "docstring_tokens": ["Flush", "the", "response"], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/response.go#L42-L46", "partition": "test"}
{"repo": "golang/debug", "path": "cmd/viewcore/main.go", "func_name": "typeName", "original_string": "func typeName(c *gocore.Process, x gocore.Object) string {\n\tsize := c.Size(x)\n\ttyp, repeat := c.Type(x)\n\tif typ == nil {\n\t\treturn fmt.Sprintf(\"unk%d\", size)\n\t}\n\tname := typ.String()\n\tn := size / typ.Size\n\tif n > 1 {\n\t\tif repeat < n {\n\t\t\tname = fmt.Sprintf(\"[%d+%d?]%s\", repeat, n-repeat, name)\n\t\t} else {\n\t\t\tname = fmt.Sprintf(\"[%d]%s\", repeat, name)\n\t\t}\n\t}\n\treturn name\n}", "language": "go", "code": "func typeName(c *gocore.Process, x gocore.Object) string {\n\tsize := c.Size(x)\n\ttyp, repeat := c.Type(x)\n\tif typ == nil {\n\t\treturn fmt.Sprintf(\"unk%d\", size)\n\t}\n\tname := typ.String()\n\tn := size / typ.Size\n\tif n > 1 {\n\t\tif repeat < n {\n\t\t\tname = fmt.Sprintf(\"[%d+%d?]%s\", repeat, n-repeat, name)\n\t\t} else {\n\t\t\tname = fmt.Sprintf(\"[%d]%s\", repeat, name)\n\t\t}\n\t}\n\treturn name\n}", "code_tokens": ["func", "typeName", "(", "c", "*", "gocore", ".", "Process", ",", "x", "gocore", ".", "Object", ")", "string", "{", "size", ":=", "c", ".", "Size", "(", "x", ")", "\n", "typ", ",", "repeat", ":=", "c", ".", "Type", "(", "x", ")", "\n", "if", "typ", "==", "nil", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "size", ")", "\n", "}", "\n", "name", ":=", "typ", ".", "String", "(", ")", "\n", "n", ":=", "size", "/", "typ", ".", "Size", "\n", "if", "n", ">", "1", "{", "if", "repeat", "<", "n", "{", "name", "=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "repeat", ",", "n", "-", "repeat", ",", "name", ")", "\n", "}", "else", "{", "name", "=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "repeat", ",", "name", ")", "\n", "}", "\n", "}", "\n", "return", "name", "\n", "}"], "docstring": "// typeName returns a string representing the type of this object.", "docstring_tokens": ["typeName", "returns", "a", "string", "representing", "the", "type", "of", "this", "object", "."], "sha": "19561fee47cf8cd0400d1b094c5898002f97cf90", "url": "https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/cmd/viewcore/main.go#L749-L765", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_containers.go", "func_name": "MigrateContainerSnapshot", "original_string": "func (r *ProtocolLXD) MigrateContainerSnapshot(containerName string, name string, container api.ContainerSnapshotPost) (Operation, error) {\n\t// Sanity check\n\tif !container.Migration {\n\t\treturn nil, fmt.Errorf(\"Can't ask for a rename through MigrateContainerSnapshot\")\n\t}\n\n\t// Send the request\n\top, _, err := r.queryOperation(\"POST\", fmt.Sprintf(\"/containers/%s/snapshots/%s\", url.QueryEscape(containerName), url.QueryEscape(name)), container, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "language": "go", "code": "func (r *ProtocolLXD) MigrateContainerSnapshot(containerName string, name string, container api.ContainerSnapshotPost) (Operation, error) {\n\t// Sanity check\n\tif !container.Migration {\n\t\treturn nil, fmt.Errorf(\"Can't ask for a rename through MigrateContainerSnapshot\")\n\t}\n\n\t// Send the request\n\top, _, err := r.queryOperation(\"POST\", fmt.Sprintf(\"/containers/%s/snapshots/%s\", url.QueryEscape(containerName), url.QueryEscape(name)), container, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "MigrateContainerSnapshot", "(", "containerName", "string", ",", "name", "string", ",", "container", "api", ".", "ContainerSnapshotPost", ")", "(", "Operation", ",", "error", ")", "{", "// Sanity check", "if", "!", "container", ".", "Migration", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n\n", "// Send the request", "op", ",", "_", ",", "err", ":=", "r", ".", "queryOperation", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "containerName", ")", ",", "url", ".", "QueryEscape", "(", "name", ")", ")", ",", "container", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "op", ",", "nil", "\n", "}"], "docstring": "// MigrateContainerSnapshot requests that LXD prepares for a snapshot migration", "docstring_tokens": ["MigrateContainerSnapshot", "requests", "that", "LXD", "prepares", "for", "a", "snapshot", "migration"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_containers.go#L1334-L1347", "partition": "test"}
{"repo": "google/acme", "path": "config.go", "func_name": "readKey", "original_string": "func readKey(path string) (crypto.Signer, error) {\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\td, _ := pem.Decode(b)\n\tif d == nil {\n\t\treturn nil, fmt.Errorf(\"no block found in %q\", path)\n\t}\n\tswitch d.Type {\n\tcase rsaPrivateKey:\n\t\treturn x509.ParsePKCS1PrivateKey(d.Bytes)\n\tcase ecPrivateKey:\n\t\treturn x509.ParseECPrivateKey(d.Bytes)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"%q is unsupported\", d.Type)\n\t}\n}", "language": "go", "code": "func readKey(path string) (crypto.Signer, error) {\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\td, _ := pem.Decode(b)\n\tif d == nil {\n\t\treturn nil, fmt.Errorf(\"no block found in %q\", path)\n\t}\n\tswitch d.Type {\n\tcase rsaPrivateKey:\n\t\treturn x509.ParsePKCS1PrivateKey(d.Bytes)\n\tcase ecPrivateKey:\n\t\treturn x509.ParseECPrivateKey(d.Bytes)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"%q is unsupported\", d.Type)\n\t}\n}", "code_tokens": ["func", "readKey", "(", "path", "string", ")", "(", "crypto", ".", "Signer", ",", "error", ")", "{", "b", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "d", ",", "_", ":=", "pem", ".", "Decode", "(", "b", ")", "\n", "if", "d", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "path", ")", "\n", "}", "\n", "switch", "d", ".", "Type", "{", "case", "rsaPrivateKey", ":", "return", "x509", ".", "ParsePKCS1PrivateKey", "(", "d", ".", "Bytes", ")", "\n", "case", "ecPrivateKey", ":", "return", "x509", ".", "ParseECPrivateKey", "(", "d", ".", "Bytes", ")", "\n", "default", ":", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "d", ".", "Type", ")", "\n", "}", "\n", "}"], "docstring": "// readKey reads a private rsa key from path.\n// The key is expected to be in PEM format.", "docstring_tokens": ["readKey", "reads", "a", "private", "rsa", "key", "from", "path", ".", "The", "key", "is", "expected", "to", "be", "in", "PEM", "format", "."], "sha": "7c6dfc908d68ed254a16c126f6770f4d9d9352da", "url": "https://github.com/google/acme/blob/7c6dfc908d68ed254a16c126f6770f4d9d9352da/config.go#L106-L123", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "introspection.go", "func_name": "IntrospectState", "original_string": "func (p *Peer) IntrospectState(opts *IntrospectionOptions) PeerRuntimeState {\n\tp.RLock()\n\tdefer p.RUnlock()\n\n\treturn PeerRuntimeState{\n\t\tHostPort:            p.hostPort,\n\t\tInboundConnections:  getConnectionRuntimeState(p.inboundConnections, opts),\n\t\tOutboundConnections: getConnectionRuntimeState(p.outboundConnections, opts),\n\t\tChosenCount:         p.chosenCount.Load(),\n\t\tSCCount:             p.scCount,\n\t}\n}", "language": "go", "code": "func (p *Peer) IntrospectState(opts *IntrospectionOptions) PeerRuntimeState {\n\tp.RLock()\n\tdefer p.RUnlock()\n\n\treturn PeerRuntimeState{\n\t\tHostPort:            p.hostPort,\n\t\tInboundConnections:  getConnectionRuntimeState(p.inboundConnections, opts),\n\t\tOutboundConnections: getConnectionRuntimeState(p.outboundConnections, opts),\n\t\tChosenCount:         p.chosenCount.Load(),\n\t\tSCCount:             p.scCount,\n\t}\n}", "code_tokens": ["func", "(", "p", "*", "Peer", ")", "IntrospectState", "(", "opts", "*", "IntrospectionOptions", ")", "PeerRuntimeState", "{", "p", ".", "RLock", "(", ")", "\n", "defer", "p", ".", "RUnlock", "(", ")", "\n\n", "return", "PeerRuntimeState", "{", "HostPort", ":", "p", ".", "hostPort", ",", "InboundConnections", ":", "getConnectionRuntimeState", "(", "p", ".", "inboundConnections", ",", "opts", ")", ",", "OutboundConnections", ":", "getConnectionRuntimeState", "(", "p", ".", "outboundConnections", ",", "opts", ")", ",", "ChosenCount", ":", "p", ".", "chosenCount", ".", "Load", "(", ")", ",", "SCCount", ":", "p", ".", "scCount", ",", "}", "\n", "}"], "docstring": "// IntrospectState returns the runtime state for this peer.", "docstring_tokens": ["IntrospectState", "returns", "the", "runtime", "state", "for", "this", "peer", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/introspection.go#L336-L347", "partition": "test"}
{"repo": "Financial-Times/neo-model-utils-go", "path": "mapper/types.go", "func_name": "SortTypes", "original_string": "func SortTypes(types []string) ([]string, error) {\n\tts := &typeSorter{types: make([]string, len(types))}\n\tcopy(ts.types, types)\n\tsort.Sort(ts)\n\tif ts.invalid {\n\t\treturn types, ErrNotHierarchy\n\t}\n\treturn ts.types, nil\n}", "language": "go", "code": "func SortTypes(types []string) ([]string, error) {\n\tts := &typeSorter{types: make([]string, len(types))}\n\tcopy(ts.types, types)\n\tsort.Sort(ts)\n\tif ts.invalid {\n\t\treturn types, ErrNotHierarchy\n\t}\n\treturn ts.types, nil\n}", "code_tokens": ["func", "SortTypes", "(", "types", "[", "]", "string", ")", "(", "[", "]", "string", ",", "error", ")", "{", "ts", ":=", "&", "typeSorter", "{", "types", ":", "make", "(", "[", "]", "string", ",", "len", "(", "types", ")", ")", "}", "\n", "copy", "(", "ts", ".", "types", ",", "types", ")", "\n", "sort", ".", "Sort", "(", "ts", ")", "\n", "if", "ts", ".", "invalid", "{", "return", "types", ",", "ErrNotHierarchy", "\n", "}", "\n", "return", "ts", ".", "types", ",", "nil", "\n", "}"], "docstring": "// SortTypes sorts the given types from least specific to most specific", "docstring_tokens": ["SortTypes", "sorts", "the", "given", "types", "from", "least", "specific", "to", "most", "specific"], "sha": "aea1e95c83055aaed6761c5e546400dd383fb220", "url": "https://github.com/Financial-Times/neo-model-utils-go/blob/aea1e95c83055aaed6761c5e546400dd383fb220/mapper/types.go#L83-L91", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "velodrome/transform/plugins/events.go", "func_name": "Match", "original_string": "func (u UnlabelEvent) Match(eventName, label string) bool {\n\treturn eventName == \"unlabeled\" && label == u.Label\n}", "language": "go", "code": "func (u UnlabelEvent) Match(eventName, label string) bool {\n\treturn eventName == \"unlabeled\" && label == u.Label\n}", "code_tokens": ["func", "(", "u", "UnlabelEvent", ")", "Match", "(", "eventName", ",", "label", "string", ")", "bool", "{", "return", "eventName", "==", "\"", "\"", "&&", "label", "==", "u", ".", "Label", "\n", "}"], "docstring": "// Match is \"unlabeled\"", "docstring_tokens": ["Match", "is", "unlabeled"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/transform/plugins/events.go#L117-L119", "partition": "test"}
{"repo": "ianschenck/envflag", "path": "envflag.go", "func_name": "Uint", "original_string": "func Uint(name string, value uint, usage string) *uint {\n\treturn EnvironmentFlags.Uint(name, value, usage)\n}", "language": "go", "code": "func Uint(name string, value uint, usage string) *uint {\n\treturn EnvironmentFlags.Uint(name, value, usage)\n}", "code_tokens": ["func", "Uint", "(", "name", "string", ",", "value", "uint", ",", "usage", "string", ")", "*", "uint", "{", "return", "EnvironmentFlags", ".", "Uint", "(", "name", ",", "value", ",", "usage", ")", "\n", "}"], "docstring": "// Uint defines a uint flag with specified name, default value, and\n// usage string.  The return value is the address of a uint variable\n// that stores the value of the flag.", "docstring_tokens": ["Uint", "defines", "a", "uint", "flag", "with", "specified", "name", "default", "value", "and", "usage", "string", ".", "The", "return", "value", "is", "the", "address", "of", "a", "uint", "variable", "that", "stores", "the", "value", "of", "the", "flag", "."], "sha": "9111d830d133f952887a936367fb0211c3134f0d", "url": "https://github.com/ianschenck/envflag/blob/9111d830d133f952887a936367fb0211c3134f0d/envflag.go#L102-L104", "partition": "test"}
{"repo": "op/go-logging", "path": "level.go", "func_name": "IsEnabledFor", "original_string": "func (l *moduleLeveled) IsEnabledFor(level Level, module string) bool {\n\treturn level <= l.GetLevel(module)\n}", "language": "go", "code": "func (l *moduleLeveled) IsEnabledFor(level Level, module string) bool {\n\treturn level <= l.GetLevel(module)\n}", "code_tokens": ["func", "(", "l", "*", "moduleLeveled", ")", "IsEnabledFor", "(", "level", "Level", ",", "module", "string", ")", "bool", "{", "return", "level", "<=", "l", ".", "GetLevel", "(", "module", ")", "\n", "}"], "docstring": "// IsEnabledFor will return true if logging is enabled for the given module.", "docstring_tokens": ["IsEnabledFor", "will", "return", "true", "if", "logging", "is", "enabled", "for", "the", "given", "module", "."], "sha": "970db520ece77730c7e4724c61121037378659d9", "url": "https://github.com/op/go-logging/blob/970db520ece77730c7e4724c61121037378659d9/level.go#L108-L110", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "context.go", "func_name": "DeleteSession", "original_string": "func (ctx *Context) DeleteSession() error {\n\tsid := ctx.Data[\"Sid\"].(string)\n\tctx.Data[\"session\"] = nil\n\tprovider.Destroy(sid)\n\tcookie := httpCookie\n\tcookie.MaxAge = -1\n\thttp.SetCookie(ctx.ResponseWriter, &cookie)\n\treturn nil\n}", "language": "go", "code": "func (ctx *Context) DeleteSession() error {\n\tsid := ctx.Data[\"Sid\"].(string)\n\tctx.Data[\"session\"] = nil\n\tprovider.Destroy(sid)\n\tcookie := httpCookie\n\tcookie.MaxAge = -1\n\thttp.SetCookie(ctx.ResponseWriter, &cookie)\n\treturn nil\n}", "code_tokens": ["func", "(", "ctx", "*", "Context", ")", "DeleteSession", "(", ")", "error", "{", "sid", ":=", "ctx", ".", "Data", "[", "\"", "\"", "]", ".", "(", "string", ")", "\n", "ctx", ".", "Data", "[", "\"", "\"", "]", "=", "nil", "\n", "provider", ".", "Destroy", "(", "sid", ")", "\n", "cookie", ":=", "httpCookie", "\n", "cookie", ".", "MaxAge", "=", "-", "1", "\n", "http", ".", "SetCookie", "(", "ctx", ".", "ResponseWriter", ",", "&", "cookie", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// DeleteSession delete session", "docstring_tokens": ["DeleteSession", "delete", "session"], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/context.go#L239-L247", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/storage_volumes.go", "func_name": "StorageVolumeConfigClear", "original_string": "func StorageVolumeConfigClear(tx *sql.Tx, volumeID int64) error {\n\t_, err := tx.Exec(\"DELETE FROM storage_volumes_config WHERE storage_volume_id=?\", volumeID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func StorageVolumeConfigClear(tx *sql.Tx, volumeID int64) error {\n\t_, err := tx.Exec(\"DELETE FROM storage_volumes_config WHERE storage_volume_id=?\", volumeID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "StorageVolumeConfigClear", "(", "tx", "*", "sql", ".", "Tx", ",", "volumeID", "int64", ")", "error", "{", "_", ",", "err", ":=", "tx", ".", "Exec", "(", "\"", "\"", ",", "volumeID", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// StorageVolumeConfigClear deletes storage volume config.", "docstring_tokens": ["StorageVolumeConfigClear", "deletes", "storage", "volume", "config", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/storage_volumes.go#L282-L289", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/logging/log.go", "func_name": "SetLogger", "original_string": "func SetLogger(newLogger logger.Logger) func() {\n\torigLog := logger.Log\n\tlogger.Log = newLogger\n\treturn func() {\n\t\tlogger.Log = origLog\n\t}\n}", "language": "go", "code": "func SetLogger(newLogger logger.Logger) func() {\n\torigLog := logger.Log\n\tlogger.Log = newLogger\n\treturn func() {\n\t\tlogger.Log = origLog\n\t}\n}", "code_tokens": ["func", "SetLogger", "(", "newLogger", "logger", ".", "Logger", ")", "func", "(", ")", "{", "origLog", ":=", "logger", ".", "Log", "\n", "logger", ".", "Log", "=", "newLogger", "\n", "return", "func", "(", ")", "{", "logger", ".", "Log", "=", "origLog", "\n", "}", "\n", "}"], "docstring": "// SetLogger installs the given logger as global logger. It returns a function\n// that can be used to restore whatever logger was installed beforehand.", "docstring_tokens": ["SetLogger", "installs", "the", "given", "logger", "as", "global", "logger", ".", "It", "returns", "a", "function", "that", "can", "be", "used", "to", "restore", "whatever", "logger", "was", "installed", "beforehand", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/logging/log.go#L86-L92", "partition": "test"}
{"repo": "r3labs/sse", "path": "event_log.go", "func_name": "Replay", "original_string": "func (e *EventLog) Replay(s *Subscriber) {\n\tfor i := 0; i < len((*e)); i++ {\n\t\tif string((*e)[i].ID) >= s.eventid {\n\t\t\ts.connection <- (*e)[i]\n\t\t}\n\t}\n}", "language": "go", "code": "func (e *EventLog) Replay(s *Subscriber) {\n\tfor i := 0; i < len((*e)); i++ {\n\t\tif string((*e)[i].ID) >= s.eventid {\n\t\t\ts.connection <- (*e)[i]\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "e", "*", "EventLog", ")", "Replay", "(", "s", "*", "Subscriber", ")", "{", "for", "i", ":=", "0", ";", "i", "<", "len", "(", "(", "*", "e", ")", ")", ";", "i", "++", "{", "if", "string", "(", "(", "*", "e", ")", "[", "i", "]", ".", "ID", ")", ">=", "s", ".", "eventid", "{", "s", ".", "connection", "<-", "(", "*", "e", ")", "[", "i", "]", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// Replay events to a subscriber", "docstring_tokens": ["Replay", "events", "to", "a", "subscriber"], "sha": "2f90368216802092e9ed520c43e974e11d50438d", "url": "https://github.com/r3labs/sse/blob/2f90368216802092e9ed520c43e974e11d50438d/event_log.go#L28-L34", "partition": "test"}
{"repo": "iron-io/functions_go", "path": "client/routes/post_apps_app_routes_parameters.go", "func_name": "WithApp", "original_string": "func (o *PostAppsAppRoutesParams) WithApp(app string) *PostAppsAppRoutesParams {\n\to.SetApp(app)\n\treturn o\n}", "language": "go", "code": "func (o *PostAppsAppRoutesParams) WithApp(app string) *PostAppsAppRoutesParams {\n\to.SetApp(app)\n\treturn o\n}", "code_tokens": ["func", "(", "o", "*", "PostAppsAppRoutesParams", ")", "WithApp", "(", "app", "string", ")", "*", "PostAppsAppRoutesParams", "{", "o", ".", "SetApp", "(", "app", ")", "\n", "return", "o", "\n", "}"], "docstring": "// WithApp adds the app to the post apps app routes params", "docstring_tokens": ["WithApp", "adds", "the", "app", "to", "the", "post", "apps", "app", "routes", "params"], "sha": "91b84f5bbb17095bf1c7028ec6e70a3dc06a5893", "url": "https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/routes/post_apps_app_routes_parameters.go#L117-L120", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "robots/issue-creator/sources/triage-filer.go", "func_name": "parseTriageData", "original_string": "func parseTriageData(jsonIn []byte) (*triageData, error) {\n\tvar data triageData\n\tif err := json.Unmarshal(jsonIn, &data); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif data.Builds.Cols.Started == nil {\n\t\treturn nil, fmt.Errorf(\"triage data json is missing the builds.cols.started key\")\n\t}\n\tif data.Builds.JobsRaw == nil {\n\t\treturn nil, fmt.Errorf(\"triage data is missing the builds.jobs key\")\n\t}\n\tif data.Builds.JobPaths == nil {\n\t\treturn nil, fmt.Errorf(\"triage data is missing the builds.job_paths key\")\n\t}\n\tif data.Clustered == nil {\n\t\treturn nil, fmt.Errorf(\"triage data is missing the clustered key\")\n\t}\n\t// Populate 'Jobs' with the BuildIndexer for each job.\n\tdata.Builds.Jobs = make(map[string]BuildIndexer)\n\tfor jobID, mapper := range data.Builds.JobsRaw {\n\t\tswitch mapper := mapper.(type) {\n\t\tcase []interface{}:\n\t\t\t// In this case mapper is a 3 member array. 0:first buildnum, 1:number of builds, 2:start index.\n\t\t\tdata.Builds.Jobs[jobID] = ContigIndexer{\n\t\t\t\tstartBuild: int(mapper[0].(float64)),\n\t\t\t\tcount:      int(mapper[1].(float64)),\n\t\t\t\tstartRow:   int(mapper[2].(float64)),\n\t\t\t}\n\t\tcase map[string]interface{}:\n\t\t\t// In this case mapper is a dictionary.\n\t\t\tdata.Builds.Jobs[jobID] = DictIndexer(mapper)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"the build number to row index mapping for job '%s' is not an accepted type. Type is: %v\", jobID, reflect.TypeOf(mapper))\n\t\t}\n\t}\n\treturn &data, nil\n}", "language": "go", "code": "func parseTriageData(jsonIn []byte) (*triageData, error) {\n\tvar data triageData\n\tif err := json.Unmarshal(jsonIn, &data); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif data.Builds.Cols.Started == nil {\n\t\treturn nil, fmt.Errorf(\"triage data json is missing the builds.cols.started key\")\n\t}\n\tif data.Builds.JobsRaw == nil {\n\t\treturn nil, fmt.Errorf(\"triage data is missing the builds.jobs key\")\n\t}\n\tif data.Builds.JobPaths == nil {\n\t\treturn nil, fmt.Errorf(\"triage data is missing the builds.job_paths key\")\n\t}\n\tif data.Clustered == nil {\n\t\treturn nil, fmt.Errorf(\"triage data is missing the clustered key\")\n\t}\n\t// Populate 'Jobs' with the BuildIndexer for each job.\n\tdata.Builds.Jobs = make(map[string]BuildIndexer)\n\tfor jobID, mapper := range data.Builds.JobsRaw {\n\t\tswitch mapper := mapper.(type) {\n\t\tcase []interface{}:\n\t\t\t// In this case mapper is a 3 member array. 0:first buildnum, 1:number of builds, 2:start index.\n\t\t\tdata.Builds.Jobs[jobID] = ContigIndexer{\n\t\t\t\tstartBuild: int(mapper[0].(float64)),\n\t\t\t\tcount:      int(mapper[1].(float64)),\n\t\t\t\tstartRow:   int(mapper[2].(float64)),\n\t\t\t}\n\t\tcase map[string]interface{}:\n\t\t\t// In this case mapper is a dictionary.\n\t\t\tdata.Builds.Jobs[jobID] = DictIndexer(mapper)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"the build number to row index mapping for job '%s' is not an accepted type. Type is: %v\", jobID, reflect.TypeOf(mapper))\n\t\t}\n\t}\n\treturn &data, nil\n}", "code_tokens": ["func", "parseTriageData", "(", "jsonIn", "[", "]", "byte", ")", "(", "*", "triageData", ",", "error", ")", "{", "var", "data", "triageData", "\n", "if", "err", ":=", "json", ".", "Unmarshal", "(", "jsonIn", ",", "&", "data", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "if", "data", ".", "Builds", ".", "Cols", ".", "Started", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "data", ".", "Builds", ".", "JobsRaw", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "data", ".", "Builds", ".", "JobPaths", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "data", ".", "Clustered", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "// Populate 'Jobs' with the BuildIndexer for each job.", "data", ".", "Builds", ".", "Jobs", "=", "make", "(", "map", "[", "string", "]", "BuildIndexer", ")", "\n", "for", "jobID", ",", "mapper", ":=", "range", "data", ".", "Builds", ".", "JobsRaw", "{", "switch", "mapper", ":=", "mapper", ".", "(", "type", ")", "{", "case", "[", "]", "interface", "{", "}", ":", "// In this case mapper is a 3 member array. 0:first buildnum, 1:number of builds, 2:start index.", "data", ".", "Builds", ".", "Jobs", "[", "jobID", "]", "=", "ContigIndexer", "{", "startBuild", ":", "int", "(", "mapper", "[", "0", "]", ".", "(", "float64", ")", ")", ",", "count", ":", "int", "(", "mapper", "[", "1", "]", ".", "(", "float64", ")", ")", ",", "startRow", ":", "int", "(", "mapper", "[", "2", "]", ".", "(", "float64", ")", ")", ",", "}", "\n", "case", "map", "[", "string", "]", "interface", "{", "}", ":", "// In this case mapper is a dictionary.", "data", ".", "Builds", ".", "Jobs", "[", "jobID", "]", "=", "DictIndexer", "(", "mapper", ")", "\n", "default", ":", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "jobID", ",", "reflect", ".", "TypeOf", "(", "mapper", ")", ")", "\n", "}", "\n", "}", "\n", "return", "&", "data", ",", "nil", "\n", "}"], "docstring": "// parseTriageData unmarshals raw json data into a triageData struct and creates a BuildIndexer for\n// every job.", "docstring_tokens": ["parseTriageData", "unmarshals", "raw", "json", "data", "into", "a", "triageData", "struct", "and", "creates", "a", "BuildIndexer", "for", "every", "job", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/robots/issue-creator/sources/triage-filer.go#L285-L322", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "runtime/runtime.go", "func_name": "Do", "original_string": "func (p *RemoveBindingParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandRemoveBinding, p, nil)\n}", "language": "go", "code": "func (p *RemoveBindingParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandRemoveBinding, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "RemoveBindingParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandRemoveBinding", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Runtime.removeBinding against the provided context.", "docstring_tokens": ["Do", "executes", "Runtime", ".", "removeBinding", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/runtime.go#L914-L916", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/peribolos/main.go", "func_name": "configureOrgMeta", "original_string": "func configureOrgMeta(client orgMetadataClient, orgName string, want org.Metadata) error {\n\tcur, err := client.GetOrg(orgName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get %s metadata: %v\", orgName, err)\n\t}\n\tchange := false\n\tchange = updateString(&cur.BillingEmail, want.BillingEmail) || change\n\tchange = updateString(&cur.Company, want.Company) || change\n\tchange = updateString(&cur.Email, want.Email) || change\n\tchange = updateString(&cur.Name, want.Name) || change\n\tchange = updateString(&cur.Description, want.Description) || change\n\tchange = updateString(&cur.Location, want.Location) || change\n\tif want.DefaultRepositoryPermission != nil {\n\t\tw := string(*want.DefaultRepositoryPermission)\n\t\tchange = updateString(&cur.DefaultRepositoryPermission, &w)\n\t}\n\tchange = updateBool(&cur.HasOrganizationProjects, want.HasOrganizationProjects) || change\n\tchange = updateBool(&cur.HasRepositoryProjects, want.HasRepositoryProjects) || change\n\tchange = updateBool(&cur.MembersCanCreateRepositories, want.MembersCanCreateRepositories) || change\n\tif change {\n\t\tif _, err := client.EditOrg(orgName, *cur); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to edit %s metadata: %v\", orgName, err)\n\t\t}\n\t}\n\treturn nil\n}", "language": "go", "code": "func configureOrgMeta(client orgMetadataClient, orgName string, want org.Metadata) error {\n\tcur, err := client.GetOrg(orgName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get %s metadata: %v\", orgName, err)\n\t}\n\tchange := false\n\tchange = updateString(&cur.BillingEmail, want.BillingEmail) || change\n\tchange = updateString(&cur.Company, want.Company) || change\n\tchange = updateString(&cur.Email, want.Email) || change\n\tchange = updateString(&cur.Name, want.Name) || change\n\tchange = updateString(&cur.Description, want.Description) || change\n\tchange = updateString(&cur.Location, want.Location) || change\n\tif want.DefaultRepositoryPermission != nil {\n\t\tw := string(*want.DefaultRepositoryPermission)\n\t\tchange = updateString(&cur.DefaultRepositoryPermission, &w)\n\t}\n\tchange = updateBool(&cur.HasOrganizationProjects, want.HasOrganizationProjects) || change\n\tchange = updateBool(&cur.HasRepositoryProjects, want.HasRepositoryProjects) || change\n\tchange = updateBool(&cur.MembersCanCreateRepositories, want.MembersCanCreateRepositories) || change\n\tif change {\n\t\tif _, err := client.EditOrg(orgName, *cur); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to edit %s metadata: %v\", orgName, err)\n\t\t}\n\t}\n\treturn nil\n}", "code_tokens": ["func", "configureOrgMeta", "(", "client", "orgMetadataClient", ",", "orgName", "string", ",", "want", "org", ".", "Metadata", ")", "error", "{", "cur", ",", "err", ":=", "client", ".", "GetOrg", "(", "orgName", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "orgName", ",", "err", ")", "\n", "}", "\n", "change", ":=", "false", "\n", "change", "=", "updateString", "(", "&", "cur", ".", "BillingEmail", ",", "want", ".", "BillingEmail", ")", "||", "change", "\n", "change", "=", "updateString", "(", "&", "cur", ".", "Company", ",", "want", ".", "Company", ")", "||", "change", "\n", "change", "=", "updateString", "(", "&", "cur", ".", "Email", ",", "want", ".", "Email", ")", "||", "change", "\n", "change", "=", "updateString", "(", "&", "cur", ".", "Name", ",", "want", ".", "Name", ")", "||", "change", "\n", "change", "=", "updateString", "(", "&", "cur", ".", "Description", ",", "want", ".", "Description", ")", "||", "change", "\n", "change", "=", "updateString", "(", "&", "cur", ".", "Location", ",", "want", ".", "Location", ")", "||", "change", "\n", "if", "want", ".", "DefaultRepositoryPermission", "!=", "nil", "{", "w", ":=", "string", "(", "*", "want", ".", "DefaultRepositoryPermission", ")", "\n", "change", "=", "updateString", "(", "&", "cur", ".", "DefaultRepositoryPermission", ",", "&", "w", ")", "\n", "}", "\n", "change", "=", "updateBool", "(", "&", "cur", ".", "HasOrganizationProjects", ",", "want", ".", "HasOrganizationProjects", ")", "||", "change", "\n", "change", "=", "updateBool", "(", "&", "cur", ".", "HasRepositoryProjects", ",", "want", ".", "HasRepositoryProjects", ")", "||", "change", "\n", "change", "=", "updateBool", "(", "&", "cur", ".", "MembersCanCreateRepositories", ",", "want", ".", "MembersCanCreateRepositories", ")", "||", "change", "\n", "if", "change", "{", "if", "_", ",", "err", ":=", "client", ".", "EditOrg", "(", "orgName", ",", "*", "cur", ")", ";", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "orgName", ",", "err", ")", "\n", "}", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// configureOrgMeta will update github to have the non-nil wanted metadata values.", "docstring_tokens": ["configureOrgMeta", "will", "update", "github", "to", "have", "the", "non", "-", "nil", "wanted", "metadata", "values", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/peribolos/main.go#L719-L744", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "raw/handler.go", "func_name": "WriteResponse", "original_string": "func WriteResponse(response *tchannel.InboundCallResponse, resp *Res) error {\n\tif resp.SystemErr != nil {\n\t\treturn response.SendSystemError(resp.SystemErr)\n\t}\n\tif resp.IsErr {\n\t\tif err := response.SetApplicationError(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := tchannel.NewArgWriter(response.Arg2Writer()).Write(resp.Arg2); err != nil {\n\t\treturn err\n\t}\n\treturn tchannel.NewArgWriter(response.Arg3Writer()).Write(resp.Arg3)\n}", "language": "go", "code": "func WriteResponse(response *tchannel.InboundCallResponse, resp *Res) error {\n\tif resp.SystemErr != nil {\n\t\treturn response.SendSystemError(resp.SystemErr)\n\t}\n\tif resp.IsErr {\n\t\tif err := response.SetApplicationError(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := tchannel.NewArgWriter(response.Arg2Writer()).Write(resp.Arg2); err != nil {\n\t\treturn err\n\t}\n\treturn tchannel.NewArgWriter(response.Arg3Writer()).Write(resp.Arg3)\n}", "code_tokens": ["func", "WriteResponse", "(", "response", "*", "tchannel", ".", "InboundCallResponse", ",", "resp", "*", "Res", ")", "error", "{", "if", "resp", ".", "SystemErr", "!=", "nil", "{", "return", "response", ".", "SendSystemError", "(", "resp", ".", "SystemErr", ")", "\n", "}", "\n", "if", "resp", ".", "IsErr", "{", "if", "err", ":=", "response", ".", "SetApplicationError", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n", "if", "err", ":=", "tchannel", ".", "NewArgWriter", "(", "response", ".", "Arg2Writer", "(", ")", ")", ".", "Write", "(", "resp", ".", "Arg2", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "return", "tchannel", ".", "NewArgWriter", "(", "response", ".", "Arg3Writer", "(", ")", ")", ".", "Write", "(", "resp", ".", "Arg3", ")", "\n", "}"], "docstring": "// WriteResponse writes the given Res to the InboundCallResponse.", "docstring_tokens": ["WriteResponse", "writes", "the", "given", "Res", "to", "the", "InboundCallResponse", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/raw/handler.go#L71-L84", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "handlers/cli/cli.go", "func_name": "New", "original_string": "func New(w io.Writer) *Handler {\n\tvar useColor bool\n\tif os.Getenv(\"COLORTERM\") != \"\" {\n\t\tuseColor = true\n\t}\n\tif term := os.Getenv(\"TERM\"); term != \"\" {\n\t\tfor _, substring := range colorTermSubstrings {\n\t\t\tif strings.Contains(term, substring) {\n\t\t\t\tuseColor = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn &Handler{\n\t\tWriter:   w,\n\t\tUseColor: useColor,\n\t}\n}", "language": "go", "code": "func New(w io.Writer) *Handler {\n\tvar useColor bool\n\tif os.Getenv(\"COLORTERM\") != \"\" {\n\t\tuseColor = true\n\t}\n\tif term := os.Getenv(\"TERM\"); term != \"\" {\n\t\tfor _, substring := range colorTermSubstrings {\n\t\t\tif strings.Contains(term, substring) {\n\t\t\t\tuseColor = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn &Handler{\n\t\tWriter:   w,\n\t\tUseColor: useColor,\n\t}\n}", "code_tokens": ["func", "New", "(", "w", "io", ".", "Writer", ")", "*", "Handler", "{", "var", "useColor", "bool", "\n", "if", "os", ".", "Getenv", "(", "\"", "\"", ")", "!=", "\"", "\"", "{", "useColor", "=", "true", "\n", "}", "\n", "if", "term", ":=", "os", ".", "Getenv", "(", "\"", "\"", ")", ";", "term", "!=", "\"", "\"", "{", "for", "_", ",", "substring", ":=", "range", "colorTermSubstrings", "{", "if", "strings", ".", "Contains", "(", "term", ",", "substring", ")", "{", "useColor", "=", "true", "\n", "break", "\n", "}", "\n", "}", "\n", "}", "\n", "return", "&", "Handler", "{", "Writer", ":", "w", ",", "UseColor", ":", "useColor", ",", "}", "\n", "}"], "docstring": "// New handler.", "docstring_tokens": ["New", "handler", "."], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/handlers/cli/cli.go#L72-L89", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "samples/gopher2/gopher2.go", "func_name": "Main", "original_string": "func Main(gc draw2d.GraphicContext, ext string) (string, error) {\n\tgc.SetStrokeColor(image.Black)\n\tgc.SetFillColor(image.White)\n\tgc.Save()\n\t// Draw a (partial) gopher\n\tgc.Translate(-60, 65)\n\tgc.Rotate(-30 * (math.Pi / 180.0))\n\tDraw(gc, 48, 48, 240, 72)\n\tgc.Restore()\n\n\t// Return the output filename\n\treturn samples.Output(\"gopher2\", ext), nil\n}", "language": "go", "code": "func Main(gc draw2d.GraphicContext, ext string) (string, error) {\n\tgc.SetStrokeColor(image.Black)\n\tgc.SetFillColor(image.White)\n\tgc.Save()\n\t// Draw a (partial) gopher\n\tgc.Translate(-60, 65)\n\tgc.Rotate(-30 * (math.Pi / 180.0))\n\tDraw(gc, 48, 48, 240, 72)\n\tgc.Restore()\n\n\t// Return the output filename\n\treturn samples.Output(\"gopher2\", ext), nil\n}", "code_tokens": ["func", "Main", "(", "gc", "draw2d", ".", "GraphicContext", ",", "ext", "string", ")", "(", "string", ",", "error", ")", "{", "gc", ".", "SetStrokeColor", "(", "image", ".", "Black", ")", "\n", "gc", ".", "SetFillColor", "(", "image", ".", "White", ")", "\n", "gc", ".", "Save", "(", ")", "\n", "// Draw a (partial) gopher", "gc", ".", "Translate", "(", "-", "60", ",", "65", ")", "\n", "gc", ".", "Rotate", "(", "-", "30", "*", "(", "math", ".", "Pi", "/", "180.0", ")", ")", "\n", "Draw", "(", "gc", ",", "48", ",", "48", ",", "240", ",", "72", ")", "\n", "gc", ".", "Restore", "(", ")", "\n\n", "// Return the output filename", "return", "samples", ".", "Output", "(", "\"", "\"", ",", "ext", ")", ",", "nil", "\n", "}"], "docstring": "// Main draws a rotated face of the gopher. Afterwards it returns\n// the filename. This should only be used during testing.", "docstring_tokens": ["Main", "draws", "a", "rotated", "face", "of", "the", "gopher", ".", "Afterwards", "it", "returns", "the", "filename", ".", "This", "should", "only", "be", "used", "during", "testing", "."], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/samples/gopher2/gopher2.go#L20-L32", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "input/input.go", "func_name": "Do", "original_string": "func (p *DispatchTouchEventParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandDispatchTouchEvent, p, nil)\n}", "language": "go", "code": "func (p *DispatchTouchEventParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandDispatchTouchEvent, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "DispatchTouchEventParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandDispatchTouchEvent", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Input.dispatchTouchEvent against the provided context.", "docstring_tokens": ["Do", "executes", "Input", ".", "dispatchTouchEvent", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L286-L288", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/pool/pool.go", "func_name": "NewPool", "original_string": "func NewPool(kubeClient *kube.Clientset, namespace string, serviceName string, port int, queueSize int64, opts ...grpc.DialOption) (*Pool, error) {\n\tendpointsInterface := kubeClient.CoreV1().Endpoints(namespace)\n\n\twatch, err := endpointsInterface.Watch(metav1.ListOptions{\n\t\tLabelSelector: metav1.FormatLabelSelector(metav1.SetAsLabelSelector(\n\t\t\tmap[string]string{\"app\": serviceName},\n\t\t)),\n\t\tWatch: true,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpool := &Pool{\n\t\tport:           port,\n\t\tendpointsWatch: watch,\n\t\topts:           opts,\n\t\tdone:           make(chan struct{}),\n\t\tqueueSize:      queueSize,\n\t}\n\tpool.connsCond = sync.NewCond(&pool.connsLock)\n\tgo pool.watchEndpoints()\n\treturn pool, nil\n}", "language": "go", "code": "func NewPool(kubeClient *kube.Clientset, namespace string, serviceName string, port int, queueSize int64, opts ...grpc.DialOption) (*Pool, error) {\n\tendpointsInterface := kubeClient.CoreV1().Endpoints(namespace)\n\n\twatch, err := endpointsInterface.Watch(metav1.ListOptions{\n\t\tLabelSelector: metav1.FormatLabelSelector(metav1.SetAsLabelSelector(\n\t\t\tmap[string]string{\"app\": serviceName},\n\t\t)),\n\t\tWatch: true,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpool := &Pool{\n\t\tport:           port,\n\t\tendpointsWatch: watch,\n\t\topts:           opts,\n\t\tdone:           make(chan struct{}),\n\t\tqueueSize:      queueSize,\n\t}\n\tpool.connsCond = sync.NewCond(&pool.connsLock)\n\tgo pool.watchEndpoints()\n\treturn pool, nil\n}", "code_tokens": ["func", "NewPool", "(", "kubeClient", "*", "kube", ".", "Clientset", ",", "namespace", "string", ",", "serviceName", "string", ",", "port", "int", ",", "queueSize", "int64", ",", "opts", "...", "grpc", ".", "DialOption", ")", "(", "*", "Pool", ",", "error", ")", "{", "endpointsInterface", ":=", "kubeClient", ".", "CoreV1", "(", ")", ".", "Endpoints", "(", "namespace", ")", "\n\n", "watch", ",", "err", ":=", "endpointsInterface", ".", "Watch", "(", "metav1", ".", "ListOptions", "{", "LabelSelector", ":", "metav1", ".", "FormatLabelSelector", "(", "metav1", ".", "SetAsLabelSelector", "(", "map", "[", "string", "]", "string", "{", "\"", "\"", ":", "serviceName", "}", ",", ")", ")", ",", "Watch", ":", "true", ",", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "pool", ":=", "&", "Pool", "{", "port", ":", "port", ",", "endpointsWatch", ":", "watch", ",", "opts", ":", "opts", ",", "done", ":", "make", "(", "chan", "struct", "{", "}", ")", ",", "queueSize", ":", "queueSize", ",", "}", "\n", "pool", ".", "connsCond", "=", "sync", ".", "NewCond", "(", "&", "pool", ".", "connsLock", ")", "\n", "go", "pool", ".", "watchEndpoints", "(", ")", "\n", "return", "pool", ",", "nil", "\n", "}"], "docstring": "// NewPool creates a new connection pool with connections to pods in the\n// given service.", "docstring_tokens": ["NewPool", "creates", "a", "new", "connection", "pool", "with", "connections", "to", "pods", "in", "the", "given", "service", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/pool/pool.go#L38-L61", "partition": "test"}
{"repo": "knq/sdhook", "path": "opts.go", "func_name": "EntriesService", "original_string": "func EntriesService(service *logging.EntriesService) Option {\n\treturn func(sh *StackdriverHook) error {\n\t\tsh.service = service\n\t\treturn nil\n\t}\n}", "language": "go", "code": "func EntriesService(service *logging.EntriesService) Option {\n\treturn func(sh *StackdriverHook) error {\n\t\tsh.service = service\n\t\treturn nil\n\t}\n}", "code_tokens": ["func", "EntriesService", "(", "service", "*", "logging", ".", "EntriesService", ")", "Option", "{", "return", "func", "(", "sh", "*", "StackdriverHook", ")", "error", "{", "sh", ".", "service", "=", "service", "\n", "return", "nil", "\n", "}", "\n", "}"], "docstring": "// EntriesService is an option that sets the Google API entry service to use\n// with Stackdriver.", "docstring_tokens": ["EntriesService", "is", "an", "option", "that", "sets", "the", "Google", "API", "entry", "service", "to", "use", "with", "Stackdriver", "."], "sha": "41b9ccbff0b5fa5a56fbdccf2eb8653e7afe8d4b", "url": "https://github.com/knq/sdhook/blob/41b9ccbff0b5fa5a56fbdccf2eb8653e7afe8d4b/opts.go#L45-L50", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "mail/mail.go", "func_name": "NewFromData", "original_string": "func NewFromData(data render.Data) Message {\n\td := render.Data{}\n\tfor k, v := range data {\n\t\td[k] = v\n\t}\n\tm := NewMessage()\n\tm.Data = d\n\treturn m\n}", "language": "go", "code": "func NewFromData(data render.Data) Message {\n\td := render.Data{}\n\tfor k, v := range data {\n\t\td[k] = v\n\t}\n\tm := NewMessage()\n\tm.Data = d\n\treturn m\n}", "code_tokens": ["func", "NewFromData", "(", "data", "render", ".", "Data", ")", "Message", "{", "d", ":=", "render", ".", "Data", "{", "}", "\n", "for", "k", ",", "v", ":=", "range", "data", "{", "d", "[", "k", "]", "=", "v", "\n", "}", "\n", "m", ":=", "NewMessage", "(", ")", "\n", "m", ".", "Data", "=", "d", "\n", "return", "m", "\n", "}"], "docstring": "// NewFromData builds a new message with raw template data given", "docstring_tokens": ["NewFromData", "builds", "a", "new", "message", "with", "raw", "template", "data", "given"], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/mail/mail.go#L22-L30", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "WithReferrer", "original_string": "func (p NavigateParams) WithReferrer(referrer string) *NavigateParams {\n\tp.Referrer = referrer\n\treturn &p\n}", "language": "go", "code": "func (p NavigateParams) WithReferrer(referrer string) *NavigateParams {\n\tp.Referrer = referrer\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "NavigateParams", ")", "WithReferrer", "(", "referrer", "string", ")", "*", "NavigateParams", "{", "p", ".", "Referrer", "=", "referrer", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithReferrer referrer URL.", "docstring_tokens": ["WithReferrer", "referrer", "URL", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L592-L595", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/config/agent.go", "func_name": "Set", "original_string": "func (ca *Agent) Set(c *Config) {\n\tca.mut.Lock()\n\tdefer ca.mut.Unlock()\n\tvar oldConfig Config\n\tif ca.c != nil {\n\t\toldConfig = *ca.c\n\t}\n\tdelta := Delta{oldConfig, *c}\n\tca.c = c\n\tfor _, subscription := range ca.subscriptions {\n\t\tgo func(sub DeltaChan) { // wait a minute to send each event\n\t\t\tend := time.NewTimer(time.Minute)\n\t\t\tselect {\n\t\t\tcase sub <- delta:\n\t\t\tcase <-end.C:\n\t\t\t}\n\t\t\tif !end.Stop() { // prevent new events\n\t\t\t\t<-end.C // drain the pending event\n\t\t\t}\n\t\t}(subscription)\n\t}\n}", "language": "go", "code": "func (ca *Agent) Set(c *Config) {\n\tca.mut.Lock()\n\tdefer ca.mut.Unlock()\n\tvar oldConfig Config\n\tif ca.c != nil {\n\t\toldConfig = *ca.c\n\t}\n\tdelta := Delta{oldConfig, *c}\n\tca.c = c\n\tfor _, subscription := range ca.subscriptions {\n\t\tgo func(sub DeltaChan) { // wait a minute to send each event\n\t\t\tend := time.NewTimer(time.Minute)\n\t\t\tselect {\n\t\t\tcase sub <- delta:\n\t\t\tcase <-end.C:\n\t\t\t}\n\t\t\tif !end.Stop() { // prevent new events\n\t\t\t\t<-end.C // drain the pending event\n\t\t\t}\n\t\t}(subscription)\n\t}\n}", "code_tokens": ["func", "(", "ca", "*", "Agent", ")", "Set", "(", "c", "*", "Config", ")", "{", "ca", ".", "mut", ".", "Lock", "(", ")", "\n", "defer", "ca", ".", "mut", ".", "Unlock", "(", ")", "\n", "var", "oldConfig", "Config", "\n", "if", "ca", ".", "c", "!=", "nil", "{", "oldConfig", "=", "*", "ca", ".", "c", "\n", "}", "\n", "delta", ":=", "Delta", "{", "oldConfig", ",", "*", "c", "}", "\n", "ca", ".", "c", "=", "c", "\n", "for", "_", ",", "subscription", ":=", "range", "ca", ".", "subscriptions", "{", "go", "func", "(", "sub", "DeltaChan", ")", "{", "// wait a minute to send each event", "end", ":=", "time", ".", "NewTimer", "(", "time", ".", "Minute", ")", "\n", "select", "{", "case", "sub", "<-", "delta", ":", "case", "<-", "end", ".", "C", ":", "}", "\n", "if", "!", "end", ".", "Stop", "(", ")", "{", "// prevent new events", "<-", "end", ".", "C", "// drain the pending event", "\n", "}", "\n", "}", "(", "subscription", ")", "\n", "}", "\n", "}"], "docstring": "// Set sets the config. Useful for testing.", "docstring_tokens": ["Set", "sets", "the", "config", ".", "Useful", "for", "testing", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/agent.go#L123-L144", "partition": "test"}
{"repo": "rightscale/rsc", "path": "rl10/commands.go", "func_name": "ShowCommandHelp", "original_string": "func (a *API) ShowCommandHelp(cmd string) error {\n\treturn a.ShowHelp(cmd, \"/rll\", commandValues)\n}", "language": "go", "code": "func (a *API) ShowCommandHelp(cmd string) error {\n\treturn a.ShowHelp(cmd, \"/rll\", commandValues)\n}", "code_tokens": ["func", "(", "a", "*", "API", ")", "ShowCommandHelp", "(", "cmd", "string", ")", "error", "{", "return", "a", ".", "ShowHelp", "(", "cmd", ",", "\"", "\"", ",", "commandValues", ")", "\n", "}"], "docstring": "// ShowCommandHelp displays the command help.", "docstring_tokens": ["ShowCommandHelp", "displays", "the", "command", "help", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/rl10/commands.go#L37-L39", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/op.go", "func_name": "OpPut", "original_string": "func OpPut(key, val string, opts ...OpOption) Op {\n\tret := Op{t: tPut, key: []byte(key), val: []byte(val)}\n\tret.applyOpts(opts)\n\tswitch {\n\tcase ret.end != nil:\n\t\tpanic(\"unexpected range in put\")\n\tcase ret.limit != 0:\n\t\tpanic(\"unexpected limit in put\")\n\tcase ret.rev != 0:\n\t\tpanic(\"unexpected revision in put\")\n\tcase ret.sort != nil:\n\t\tpanic(\"unexpected sort in put\")\n\tcase ret.serializable:\n\t\tpanic(\"unexpected serializable in put\")\n\tcase ret.countOnly:\n\t\tpanic(\"unexpected countOnly in put\")\n\tcase ret.minModRev != 0, ret.maxModRev != 0:\n\t\tpanic(\"unexpected mod revision filter in put\")\n\tcase ret.minCreateRev != 0, ret.maxCreateRev != 0:\n\t\tpanic(\"unexpected create revision filter in put\")\n\tcase ret.filterDelete, ret.filterPut:\n\t\tpanic(\"unexpected filter in put\")\n\tcase ret.createdNotify:\n\t\tpanic(\"unexpected createdNotify in put\")\n\t}\n\treturn ret\n}", "language": "go", "code": "func OpPut(key, val string, opts ...OpOption) Op {\n\tret := Op{t: tPut, key: []byte(key), val: []byte(val)}\n\tret.applyOpts(opts)\n\tswitch {\n\tcase ret.end != nil:\n\t\tpanic(\"unexpected range in put\")\n\tcase ret.limit != 0:\n\t\tpanic(\"unexpected limit in put\")\n\tcase ret.rev != 0:\n\t\tpanic(\"unexpected revision in put\")\n\tcase ret.sort != nil:\n\t\tpanic(\"unexpected sort in put\")\n\tcase ret.serializable:\n\t\tpanic(\"unexpected serializable in put\")\n\tcase ret.countOnly:\n\t\tpanic(\"unexpected countOnly in put\")\n\tcase ret.minModRev != 0, ret.maxModRev != 0:\n\t\tpanic(\"unexpected mod revision filter in put\")\n\tcase ret.minCreateRev != 0, ret.maxCreateRev != 0:\n\t\tpanic(\"unexpected create revision filter in put\")\n\tcase ret.filterDelete, ret.filterPut:\n\t\tpanic(\"unexpected filter in put\")\n\tcase ret.createdNotify:\n\t\tpanic(\"unexpected createdNotify in put\")\n\t}\n\treturn ret\n}", "code_tokens": ["func", "OpPut", "(", "key", ",", "val", "string", ",", "opts", "...", "OpOption", ")", "Op", "{", "ret", ":=", "Op", "{", "t", ":", "tPut", ",", "key", ":", "[", "]", "byte", "(", "key", ")", ",", "val", ":", "[", "]", "byte", "(", "val", ")", "}", "\n", "ret", ".", "applyOpts", "(", "opts", ")", "\n", "switch", "{", "case", "ret", ".", "end", "!=", "nil", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "limit", "!=", "0", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "rev", "!=", "0", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "sort", "!=", "nil", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "serializable", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "countOnly", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "minModRev", "!=", "0", ",", "ret", ".", "maxModRev", "!=", "0", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "minCreateRev", "!=", "0", ",", "ret", ".", "maxCreateRev", "!=", "0", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "filterDelete", ",", "ret", ".", "filterPut", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "ret", ".", "createdNotify", ":", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "ret", "\n", "}"], "docstring": "// OpPut returns \"put\" operation based on given key-value and operation options.", "docstring_tokens": ["OpPut", "returns", "put", "operation", "based", "on", "given", "key", "-", "value", "and", "operation", "options", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/op.go#L264-L290", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "parser/symbols.go", "func_name": "GetSortedList", "original_string": "func (l *LexSymbolSet) GetSortedList() LexSymbolList {\n\t// Because symbols are parsed automatically in a loop, we need to make\n\t// sure that we search starting with the longest term (e.g., \"INCLUDE\"\n\t// must come before \"IN\")\n\t// However, simply sorting the symbols using alphabetical sort then\n\t// max-length forces us to make more comparisons than necessary.\n\t// To get the best of both world, we allow passing a floating point\n\t// \"priority\" parameter to sort the symbols\n\tif l.SortedList != nil {\n\t\treturn l.SortedList\n\t}\n\n\tnum := len(l.Map)\n\tlist := make(LexSymbolList, num)\n\ti := 0\n\tfor _, v := range l.Map {\n\t\tlist[i] = v\n\t\ti++\n\t}\n\tl.SortedList = list.Sort()\n\n\treturn l.SortedList\n}", "language": "go", "code": "func (l *LexSymbolSet) GetSortedList() LexSymbolList {\n\t// Because symbols are parsed automatically in a loop, we need to make\n\t// sure that we search starting with the longest term (e.g., \"INCLUDE\"\n\t// must come before \"IN\")\n\t// However, simply sorting the symbols using alphabetical sort then\n\t// max-length forces us to make more comparisons than necessary.\n\t// To get the best of both world, we allow passing a floating point\n\t// \"priority\" parameter to sort the symbols\n\tif l.SortedList != nil {\n\t\treturn l.SortedList\n\t}\n\n\tnum := len(l.Map)\n\tlist := make(LexSymbolList, num)\n\ti := 0\n\tfor _, v := range l.Map {\n\t\tlist[i] = v\n\t\ti++\n\t}\n\tl.SortedList = list.Sort()\n\n\treturn l.SortedList\n}", "code_tokens": ["func", "(", "l", "*", "LexSymbolSet", ")", "GetSortedList", "(", ")", "LexSymbolList", "{", "// Because symbols are parsed automatically in a loop, we need to make", "// sure that we search starting with the longest term (e.g., \"INCLUDE\"", "// must come before \"IN\")", "// However, simply sorting the symbols using alphabetical sort then", "// max-length forces us to make more comparisons than necessary.", "// To get the best of both world, we allow passing a floating point", "// \"priority\" parameter to sort the symbols", "if", "l", ".", "SortedList", "!=", "nil", "{", "return", "l", ".", "SortedList", "\n", "}", "\n\n", "num", ":=", "len", "(", "l", ".", "Map", ")", "\n", "list", ":=", "make", "(", "LexSymbolList", ",", "num", ")", "\n", "i", ":=", "0", "\n", "for", "_", ",", "v", ":=", "range", "l", ".", "Map", "{", "list", "[", "i", "]", "=", "v", "\n", "i", "++", "\n", "}", "\n", "l", ".", "SortedList", "=", "list", ".", "Sort", "(", ")", "\n\n", "return", "l", ".", "SortedList", "\n", "}"], "docstring": "// GetSortedList returns the lsit of LexSymbols in order that they should\n// be searched for in the tempalte", "docstring_tokens": ["GetSortedList", "returns", "the", "lsit", "of", "LexSymbols", "in", "order", "that", "they", "should", "be", "searched", "for", "in", "the", "tempalte"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/parser/symbols.go#L103-L125", "partition": "test"}
{"repo": "hashicorp/raft", "path": "configuration.go", "func_name": "nextConfiguration", "original_string": "func nextConfiguration(current Configuration, currentIndex uint64, change configurationChangeRequest) (Configuration, error) {\n\tif change.prevIndex > 0 && change.prevIndex != currentIndex {\n\t\treturn Configuration{}, fmt.Errorf(\"Configuration changed since %v (latest is %v)\", change.prevIndex, currentIndex)\n\t}\n\n\tconfiguration := current.Clone()\n\tswitch change.command {\n\tcase AddStaging:\n\t\t// TODO: barf on new address?\n\t\tnewServer := Server{\n\t\t\t// TODO: This should add the server as Staging, to be automatically\n\t\t\t// promoted to Voter later. However, the promotion to Voter is not yet\n\t\t\t// implemented, and doing so is not trivial with the way the leader loop\n\t\t\t// coordinates with the replication goroutines today. So, for now, the\n\t\t\t// server will have a vote right away, and the Promote case below is\n\t\t\t// unused.\n\t\t\tSuffrage: Voter,\n\t\t\tID:       change.serverID,\n\t\t\tAddress:  change.serverAddress,\n\t\t}\n\t\tfound := false\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID {\n\t\t\t\tif server.Suffrage == Voter {\n\t\t\t\t\tconfiguration.Servers[i].Address = change.serverAddress\n\t\t\t\t} else {\n\t\t\t\t\tconfiguration.Servers[i] = newServer\n\t\t\t\t}\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tconfiguration.Servers = append(configuration.Servers, newServer)\n\t\t}\n\tcase AddNonvoter:\n\t\tnewServer := Server{\n\t\t\tSuffrage: Nonvoter,\n\t\t\tID:       change.serverID,\n\t\t\tAddress:  change.serverAddress,\n\t\t}\n\t\tfound := false\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID {\n\t\t\t\tif server.Suffrage != Nonvoter {\n\t\t\t\t\tconfiguration.Servers[i].Address = change.serverAddress\n\t\t\t\t} else {\n\t\t\t\t\tconfiguration.Servers[i] = newServer\n\t\t\t\t}\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tconfiguration.Servers = append(configuration.Servers, newServer)\n\t\t}\n\tcase DemoteVoter:\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID {\n\t\t\t\tconfiguration.Servers[i].Suffrage = Nonvoter\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase RemoveServer:\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID {\n\t\t\t\tconfiguration.Servers = append(configuration.Servers[:i], configuration.Servers[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase Promote:\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID && server.Suffrage == Staging {\n\t\t\t\tconfiguration.Servers[i].Suffrage = Voter\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make sure we didn't do something bad like remove the last voter\n\tif err := checkConfiguration(configuration); err != nil {\n\t\treturn Configuration{}, err\n\t}\n\n\treturn configuration, nil\n}", "language": "go", "code": "func nextConfiguration(current Configuration, currentIndex uint64, change configurationChangeRequest) (Configuration, error) {\n\tif change.prevIndex > 0 && change.prevIndex != currentIndex {\n\t\treturn Configuration{}, fmt.Errorf(\"Configuration changed since %v (latest is %v)\", change.prevIndex, currentIndex)\n\t}\n\n\tconfiguration := current.Clone()\n\tswitch change.command {\n\tcase AddStaging:\n\t\t// TODO: barf on new address?\n\t\tnewServer := Server{\n\t\t\t// TODO: This should add the server as Staging, to be automatically\n\t\t\t// promoted to Voter later. However, the promotion to Voter is not yet\n\t\t\t// implemented, and doing so is not trivial with the way the leader loop\n\t\t\t// coordinates with the replication goroutines today. So, for now, the\n\t\t\t// server will have a vote right away, and the Promote case below is\n\t\t\t// unused.\n\t\t\tSuffrage: Voter,\n\t\t\tID:       change.serverID,\n\t\t\tAddress:  change.serverAddress,\n\t\t}\n\t\tfound := false\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID {\n\t\t\t\tif server.Suffrage == Voter {\n\t\t\t\t\tconfiguration.Servers[i].Address = change.serverAddress\n\t\t\t\t} else {\n\t\t\t\t\tconfiguration.Servers[i] = newServer\n\t\t\t\t}\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tconfiguration.Servers = append(configuration.Servers, newServer)\n\t\t}\n\tcase AddNonvoter:\n\t\tnewServer := Server{\n\t\t\tSuffrage: Nonvoter,\n\t\t\tID:       change.serverID,\n\t\t\tAddress:  change.serverAddress,\n\t\t}\n\t\tfound := false\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID {\n\t\t\t\tif server.Suffrage != Nonvoter {\n\t\t\t\t\tconfiguration.Servers[i].Address = change.serverAddress\n\t\t\t\t} else {\n\t\t\t\t\tconfiguration.Servers[i] = newServer\n\t\t\t\t}\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tconfiguration.Servers = append(configuration.Servers, newServer)\n\t\t}\n\tcase DemoteVoter:\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID {\n\t\t\t\tconfiguration.Servers[i].Suffrage = Nonvoter\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase RemoveServer:\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID {\n\t\t\t\tconfiguration.Servers = append(configuration.Servers[:i], configuration.Servers[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase Promote:\n\t\tfor i, server := range configuration.Servers {\n\t\t\tif server.ID == change.serverID && server.Suffrage == Staging {\n\t\t\t\tconfiguration.Servers[i].Suffrage = Voter\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make sure we didn't do something bad like remove the last voter\n\tif err := checkConfiguration(configuration); err != nil {\n\t\treturn Configuration{}, err\n\t}\n\n\treturn configuration, nil\n}", "code_tokens": ["func", "nextConfiguration", "(", "current", "Configuration", ",", "currentIndex", "uint64", ",", "change", "configurationChangeRequest", ")", "(", "Configuration", ",", "error", ")", "{", "if", "change", ".", "prevIndex", ">", "0", "&&", "change", ".", "prevIndex", "!=", "currentIndex", "{", "return", "Configuration", "{", "}", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "change", ".", "prevIndex", ",", "currentIndex", ")", "\n", "}", "\n\n", "configuration", ":=", "current", ".", "Clone", "(", ")", "\n", "switch", "change", ".", "command", "{", "case", "AddStaging", ":", "// TODO: barf on new address?", "newServer", ":=", "Server", "{", "// TODO: This should add the server as Staging, to be automatically", "// promoted to Voter later. However, the promotion to Voter is not yet", "// implemented, and doing so is not trivial with the way the leader loop", "// coordinates with the replication goroutines today. So, for now, the", "// server will have a vote right away, and the Promote case below is", "// unused.", "Suffrage", ":", "Voter", ",", "ID", ":", "change", ".", "serverID", ",", "Address", ":", "change", ".", "serverAddress", ",", "}", "\n", "found", ":=", "false", "\n", "for", "i", ",", "server", ":=", "range", "configuration", ".", "Servers", "{", "if", "server", ".", "ID", "==", "change", ".", "serverID", "{", "if", "server", ".", "Suffrage", "==", "Voter", "{", "configuration", ".", "Servers", "[", "i", "]", ".", "Address", "=", "change", ".", "serverAddress", "\n", "}", "else", "{", "configuration", ".", "Servers", "[", "i", "]", "=", "newServer", "\n", "}", "\n", "found", "=", "true", "\n", "break", "\n", "}", "\n", "}", "\n", "if", "!", "found", "{", "configuration", ".", "Servers", "=", "append", "(", "configuration", ".", "Servers", ",", "newServer", ")", "\n", "}", "\n", "case", "AddNonvoter", ":", "newServer", ":=", "Server", "{", "Suffrage", ":", "Nonvoter", ",", "ID", ":", "change", ".", "serverID", ",", "Address", ":", "change", ".", "serverAddress", ",", "}", "\n", "found", ":=", "false", "\n", "for", "i", ",", "server", ":=", "range", "configuration", ".", "Servers", "{", "if", "server", ".", "ID", "==", "change", ".", "serverID", "{", "if", "server", ".", "Suffrage", "!=", "Nonvoter", "{", "configuration", ".", "Servers", "[", "i", "]", ".", "Address", "=", "change", ".", "serverAddress", "\n", "}", "else", "{", "configuration", ".", "Servers", "[", "i", "]", "=", "newServer", "\n", "}", "\n", "found", "=", "true", "\n", "break", "\n", "}", "\n", "}", "\n", "if", "!", "found", "{", "configuration", ".", "Servers", "=", "append", "(", "configuration", ".", "Servers", ",", "newServer", ")", "\n", "}", "\n", "case", "DemoteVoter", ":", "for", "i", ",", "server", ":=", "range", "configuration", ".", "Servers", "{", "if", "server", ".", "ID", "==", "change", ".", "serverID", "{", "configuration", ".", "Servers", "[", "i", "]", ".", "Suffrage", "=", "Nonvoter", "\n", "break", "\n", "}", "\n", "}", "\n", "case", "RemoveServer", ":", "for", "i", ",", "server", ":=", "range", "configuration", ".", "Servers", "{", "if", "server", ".", "ID", "==", "change", ".", "serverID", "{", "configuration", ".", "Servers", "=", "append", "(", "configuration", ".", "Servers", "[", ":", "i", "]", ",", "configuration", ".", "Servers", "[", "i", "+", "1", ":", "]", "...", ")", "\n", "break", "\n", "}", "\n", "}", "\n", "case", "Promote", ":", "for", "i", ",", "server", ":=", "range", "configuration", ".", "Servers", "{", "if", "server", ".", "ID", "==", "change", ".", "serverID", "&&", "server", ".", "Suffrage", "==", "Staging", "{", "configuration", ".", "Servers", "[", "i", "]", ".", "Suffrage", "=", "Voter", "\n", "break", "\n", "}", "\n", "}", "\n", "}", "\n\n", "// Make sure we didn't do something bad like remove the last voter", "if", "err", ":=", "checkConfiguration", "(", "configuration", ")", ";", "err", "!=", "nil", "{", "return", "Configuration", "{", "}", ",", "err", "\n", "}", "\n\n", "return", "configuration", ",", "nil", "\n", "}"], "docstring": "// nextConfiguration generates a new Configuration from the current one and a\n// configuration change request. It's split from appendConfigurationEntry so\n// that it can be unit tested easily.", "docstring_tokens": ["nextConfiguration", "generates", "a", "new", "Configuration", "from", "the", "current", "one", "and", "a", "configuration", "change", "request", ".", "It", "s", "split", "from", "appendConfigurationEntry", "so", "that", "it", "can", "be", "unit", "tested", "easily", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/configuration.go#L190-L275", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "errors/grpc.go", "func_name": "FromGRPC", "original_string": "func FromGRPC(in error) Error {\n\tout := &impl{\n\t\tmessage: grpc.ErrorDesc(in),\n\t\ttyp:     GRPCCodeToType(grpc.Code(in)),\n\t\tcode:    NoCode,\n\t}\n\n\tmatches := grpcMessageFormat.FindStringSubmatch(in.Error())\n\n\tif len(matches) < 4 {\n\t\treturn out\n\t}\n\n\tout.message = matches[1]\n\tout.code = parseCode(matches[2])\n\t_ = json.Unmarshal([]byte(matches[3]), &out.attributes)\n\n\tgot := Get(Code(out.code))\n\tif got == nil {\n\t\treturn out\n\t}\n\n\treturn got.New(out.attributes)\n}", "language": "go", "code": "func FromGRPC(in error) Error {\n\tout := &impl{\n\t\tmessage: grpc.ErrorDesc(in),\n\t\ttyp:     GRPCCodeToType(grpc.Code(in)),\n\t\tcode:    NoCode,\n\t}\n\n\tmatches := grpcMessageFormat.FindStringSubmatch(in.Error())\n\n\tif len(matches) < 4 {\n\t\treturn out\n\t}\n\n\tout.message = matches[1]\n\tout.code = parseCode(matches[2])\n\t_ = json.Unmarshal([]byte(matches[3]), &out.attributes)\n\n\tgot := Get(Code(out.code))\n\tif got == nil {\n\t\treturn out\n\t}\n\n\treturn got.New(out.attributes)\n}", "code_tokens": ["func", "FromGRPC", "(", "in", "error", ")", "Error", "{", "out", ":=", "&", "impl", "{", "message", ":", "grpc", ".", "ErrorDesc", "(", "in", ")", ",", "typ", ":", "GRPCCodeToType", "(", "grpc", ".", "Code", "(", "in", ")", ")", ",", "code", ":", "NoCode", ",", "}", "\n\n", "matches", ":=", "grpcMessageFormat", ".", "FindStringSubmatch", "(", "in", ".", "Error", "(", ")", ")", "\n\n", "if", "len", "(", "matches", ")", "<", "4", "{", "return", "out", "\n", "}", "\n\n", "out", ".", "message", "=", "matches", "[", "1", "]", "\n", "out", ".", "code", "=", "parseCode", "(", "matches", "[", "2", "]", ")", "\n", "_", "=", "json", ".", "Unmarshal", "(", "[", "]", "byte", "(", "matches", "[", "3", "]", ")", ",", "&", "out", ".", "attributes", ")", "\n\n", "got", ":=", "Get", "(", "Code", "(", "out", ".", "code", ")", ")", "\n", "if", "got", "==", "nil", "{", "return", "out", "\n", "}", "\n\n", "return", "got", ".", "New", "(", "out", ".", "attributes", ")", "\n", "}"], "docstring": "// FromGRPC parses a gRPC error and returns an Error", "docstring_tokens": ["FromGRPC", "parses", "a", "gRPC", "error", "and", "returns", "an", "Error"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/errors/grpc.go#L98-L121", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_networks.go", "func_name": "GetNetworks", "original_string": "func (r *ProtocolLXD) GetNetworks() ([]api.Network, error) {\n\tif !r.HasExtension(\"network\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"network\\\" API extension\")\n\t}\n\n\tnetworks := []api.Network{}\n\n\t// Fetch the raw value\n\t_, err := r.queryStruct(\"GET\", \"/networks?recursion=1\", nil, \"\", &networks)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn networks, nil\n}", "language": "go", "code": "func (r *ProtocolLXD) GetNetworks() ([]api.Network, error) {\n\tif !r.HasExtension(\"network\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"network\\\" API extension\")\n\t}\n\n\tnetworks := []api.Network{}\n\n\t// Fetch the raw value\n\t_, err := r.queryStruct(\"GET\", \"/networks?recursion=1\", nil, \"\", &networks)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn networks, nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "GetNetworks", "(", ")", "(", "[", "]", "api", ".", "Network", ",", "error", ")", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "networks", ":=", "[", "]", "api", ".", "Network", "{", "}", "\n\n", "// Fetch the raw value", "_", ",", "err", ":=", "r", ".", "queryStruct", "(", "\"", "\"", ",", "\"", "\"", ",", "nil", ",", "\"", "\"", ",", "&", "networks", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "networks", ",", "nil", "\n", "}"], "docstring": "// GetNetworks returns a list of Network struct", "docstring_tokens": ["GetNetworks", "returns", "a", "list", "of", "Network", "struct"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_networks.go#L36-L50", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "pkg/ghclient/core.go", "func_name": "NewClient", "original_string": "func NewClient(token string, dryRun bool) *Client {\n\thttpClient := &http.Client{\n\t\tTransport: &oauth2.Transport{\n\t\t\tBase:   http.DefaultTransport,\n\t\t\tSource: oauth2.ReuseTokenSource(nil, oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})),\n\t\t},\n\t}\n\tclient := github.NewClient(httpClient)\n\treturn &Client{\n\t\tissueService:        client.Issues,\n\t\tprService:           client.PullRequests,\n\t\trepoService:         client.Repositories,\n\t\tuserService:         client.Users,\n\t\tretries:             5,\n\t\tretryInitialBackoff: time.Second,\n\t\ttokenReserve:        50,\n\t\tdryRun:              dryRun,\n\t}\n}", "language": "go", "code": "func NewClient(token string, dryRun bool) *Client {\n\thttpClient := &http.Client{\n\t\tTransport: &oauth2.Transport{\n\t\t\tBase:   http.DefaultTransport,\n\t\t\tSource: oauth2.ReuseTokenSource(nil, oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})),\n\t\t},\n\t}\n\tclient := github.NewClient(httpClient)\n\treturn &Client{\n\t\tissueService:        client.Issues,\n\t\tprService:           client.PullRequests,\n\t\trepoService:         client.Repositories,\n\t\tuserService:         client.Users,\n\t\tretries:             5,\n\t\tretryInitialBackoff: time.Second,\n\t\ttokenReserve:        50,\n\t\tdryRun:              dryRun,\n\t}\n}", "code_tokens": ["func", "NewClient", "(", "token", "string", ",", "dryRun", "bool", ")", "*", "Client", "{", "httpClient", ":=", "&", "http", ".", "Client", "{", "Transport", ":", "&", "oauth2", ".", "Transport", "{", "Base", ":", "http", ".", "DefaultTransport", ",", "Source", ":", "oauth2", ".", "ReuseTokenSource", "(", "nil", ",", "oauth2", ".", "StaticTokenSource", "(", "&", "oauth2", ".", "Token", "{", "AccessToken", ":", "token", "}", ")", ")", ",", "}", ",", "}", "\n", "client", ":=", "github", ".", "NewClient", "(", "httpClient", ")", "\n", "return", "&", "Client", "{", "issueService", ":", "client", ".", "Issues", ",", "prService", ":", "client", ".", "PullRequests", ",", "repoService", ":", "client", ".", "Repositories", ",", "userService", ":", "client", ".", "Users", ",", "retries", ":", "5", ",", "retryInitialBackoff", ":", "time", ".", "Second", ",", "tokenReserve", ":", "50", ",", "dryRun", ":", "dryRun", ",", "}", "\n", "}"], "docstring": "// NewClient makes a new Client with the specified token and dry-run status.", "docstring_tokens": ["NewClient", "makes", "a", "new", "Client", "with", "the", "specified", "token", "and", "dry", "-", "run", "status", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/pkg/ghclient/core.go#L49-L67", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/client.go", "func_name": "Close", "original_string": "func (c *APIClient) Close() error {\n\tif err := c.clientConn.Close(); err != nil {\n\t\treturn err\n\t}\n\n\tif c.portForwarder != nil {\n\t\tc.portForwarder.Close()\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *APIClient) Close() error {\n\tif err := c.clientConn.Close(); err != nil {\n\t\treturn err\n\t}\n\n\tif c.portForwarder != nil {\n\t\tc.portForwarder.Close()\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "APIClient", ")", "Close", "(", ")", "error", "{", "if", "err", ":=", "c", ".", "clientConn", ".", "Close", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "c", ".", "portForwarder", "!=", "nil", "{", "c", ".", "portForwarder", ".", "Close", "(", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Close the connection to gRPC", "docstring_tokens": ["Close", "the", "connection", "to", "gRPC"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/client.go#L429-L439", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "language/go/fileinfo.go", "func_name": "check", "original_string": "func (l tagLine) check(c *config.Config, os, arch string) bool {\n\tif len(l) == 0 {\n\t\treturn false\n\t}\n\tfor _, g := range l {\n\t\tif g.check(c, os, arch) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "language": "go", "code": "func (l tagLine) check(c *config.Config, os, arch string) bool {\n\tif len(l) == 0 {\n\t\treturn false\n\t}\n\tfor _, g := range l {\n\t\tif g.check(c, os, arch) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "code_tokens": ["func", "(", "l", "tagLine", ")", "check", "(", "c", "*", "config", ".", "Config", ",", "os", ",", "arch", "string", ")", "bool", "{", "if", "len", "(", "l", ")", "==", "0", "{", "return", "false", "\n", "}", "\n", "for", "_", ",", "g", ":=", "range", "l", "{", "if", "g", ".", "check", "(", "c", ",", "os", ",", "arch", ")", "{", "return", "true", "\n", "}", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// check returns true if at least one of the tag groups is satisfied.", "docstring_tokens": ["check", "returns", "true", "if", "at", "least", "one", "of", "the", "tag", "groups", "is", "satisfied", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/language/go/fileinfo.go#L92-L102", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/deck/jobs/jobs.go", "func_name": "GetJobLog", "original_string": "func (ja *JobAgent) GetJobLog(job, id string) ([]byte, error) {\n\tj, err := ja.GetProwJob(job, id)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting prowjob: %v\", err)\n\t}\n\tif j.Spec.Agent == prowapi.KubernetesAgent {\n\t\tclient, ok := ja.pkcs[j.ClusterAlias()]\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"cannot get logs for prowjob %q with agent %q: unknown cluster alias %q\", j.ObjectMeta.Name, j.Spec.Agent, j.ClusterAlias())\n\t\t}\n\t\treturn client.GetLogs(j.Status.PodName, &coreapi.PodLogOptions{Container: kube.TestContainerName})\n\t}\n\tfor _, agentToTmpl := range ja.config().Deck.ExternalAgentLogs {\n\t\tif agentToTmpl.Agent != string(j.Spec.Agent) {\n\t\t\tcontinue\n\t\t}\n\t\tif !agentToTmpl.Selector.Matches(labels.Set(j.ObjectMeta.Labels)) {\n\t\t\tcontinue\n\t\t}\n\t\tvar b bytes.Buffer\n\t\tif err := agentToTmpl.URLTemplate.Execute(&b, &j); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot execute URL template for prowjob %q with agent %q: %v\", j.ObjectMeta.Name, j.Spec.Agent, err)\n\t\t}\n\t\tresp, err := http.Get(b.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\treturn ioutil.ReadAll(resp.Body)\n\n\t}\n\treturn nil, fmt.Errorf(\"cannot get logs for prowjob %q with agent %q: the agent is missing from the prow config file\", j.ObjectMeta.Name, j.Spec.Agent)\n}", "language": "go", "code": "func (ja *JobAgent) GetJobLog(job, id string) ([]byte, error) {\n\tj, err := ja.GetProwJob(job, id)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting prowjob: %v\", err)\n\t}\n\tif j.Spec.Agent == prowapi.KubernetesAgent {\n\t\tclient, ok := ja.pkcs[j.ClusterAlias()]\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"cannot get logs for prowjob %q with agent %q: unknown cluster alias %q\", j.ObjectMeta.Name, j.Spec.Agent, j.ClusterAlias())\n\t\t}\n\t\treturn client.GetLogs(j.Status.PodName, &coreapi.PodLogOptions{Container: kube.TestContainerName})\n\t}\n\tfor _, agentToTmpl := range ja.config().Deck.ExternalAgentLogs {\n\t\tif agentToTmpl.Agent != string(j.Spec.Agent) {\n\t\t\tcontinue\n\t\t}\n\t\tif !agentToTmpl.Selector.Matches(labels.Set(j.ObjectMeta.Labels)) {\n\t\t\tcontinue\n\t\t}\n\t\tvar b bytes.Buffer\n\t\tif err := agentToTmpl.URLTemplate.Execute(&b, &j); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot execute URL template for prowjob %q with agent %q: %v\", j.ObjectMeta.Name, j.Spec.Agent, err)\n\t\t}\n\t\tresp, err := http.Get(b.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\treturn ioutil.ReadAll(resp.Body)\n\n\t}\n\treturn nil, fmt.Errorf(\"cannot get logs for prowjob %q with agent %q: the agent is missing from the prow config file\", j.ObjectMeta.Name, j.Spec.Agent)\n}", "code_tokens": ["func", "(", "ja", "*", "JobAgent", ")", "GetJobLog", "(", "job", ",", "id", "string", ")", "(", "[", "]", "byte", ",", "error", ")", "{", "j", ",", "err", ":=", "ja", ".", "GetProwJob", "(", "job", ",", "id", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "if", "j", ".", "Spec", ".", "Agent", "==", "prowapi", ".", "KubernetesAgent", "{", "client", ",", "ok", ":=", "ja", ".", "pkcs", "[", "j", ".", "ClusterAlias", "(", ")", "]", "\n", "if", "!", "ok", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "j", ".", "ObjectMeta", ".", "Name", ",", "j", ".", "Spec", ".", "Agent", ",", "j", ".", "ClusterAlias", "(", ")", ")", "\n", "}", "\n", "return", "client", ".", "GetLogs", "(", "j", ".", "Status", ".", "PodName", ",", "&", "coreapi", ".", "PodLogOptions", "{", "Container", ":", "kube", ".", "TestContainerName", "}", ")", "\n", "}", "\n", "for", "_", ",", "agentToTmpl", ":=", "range", "ja", ".", "config", "(", ")", ".", "Deck", ".", "ExternalAgentLogs", "{", "if", "agentToTmpl", ".", "Agent", "!=", "string", "(", "j", ".", "Spec", ".", "Agent", ")", "{", "continue", "\n", "}", "\n", "if", "!", "agentToTmpl", ".", "Selector", ".", "Matches", "(", "labels", ".", "Set", "(", "j", ".", "ObjectMeta", ".", "Labels", ")", ")", "{", "continue", "\n", "}", "\n", "var", "b", "bytes", ".", "Buffer", "\n", "if", "err", ":=", "agentToTmpl", ".", "URLTemplate", ".", "Execute", "(", "&", "b", ",", "&", "j", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "j", ".", "ObjectMeta", ".", "Name", ",", "j", ".", "Spec", ".", "Agent", ",", "err", ")", "\n", "}", "\n", "resp", ",", "err", ":=", "http", ".", "Get", "(", "b", ".", "String", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "defer", "resp", ".", "Body", ".", "Close", "(", ")", "\n", "return", "ioutil", ".", "ReadAll", "(", "resp", ".", "Body", ")", "\n\n", "}", "\n", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "j", ".", "ObjectMeta", ".", "Name", ",", "j", ".", "Spec", ".", "Agent", ")", "\n", "}"], "docstring": "// GetJobLog returns the job logs, works for both kubernetes and jenkins agent types.", "docstring_tokens": ["GetJobLog", "returns", "the", "job", "logs", "works", "for", "both", "kubernetes", "and", "jenkins", "agent", "types", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/deck/jobs/jobs.go#L150-L182", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_containers.go", "func_name": "RenameContainerBackup", "original_string": "func (r *ProtocolLXD) RenameContainerBackup(containerName string, name string, backup api.ContainerBackupPost) (Operation, error) {\n\tif !r.HasExtension(\"container_backup\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"container_backup\\\" API extension\")\n\t}\n\n\t// Send the request\n\top, _, err := r.queryOperation(\"POST\", fmt.Sprintf(\"/containers/%s/backups/%s\",\n\t\turl.QueryEscape(containerName), url.QueryEscape(name)), backup, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "language": "go", "code": "func (r *ProtocolLXD) RenameContainerBackup(containerName string, name string, backup api.ContainerBackupPost) (Operation, error) {\n\tif !r.HasExtension(\"container_backup\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"container_backup\\\" API extension\")\n\t}\n\n\t// Send the request\n\top, _, err := r.queryOperation(\"POST\", fmt.Sprintf(\"/containers/%s/backups/%s\",\n\t\turl.QueryEscape(containerName), url.QueryEscape(name)), backup, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "RenameContainerBackup", "(", "containerName", "string", ",", "name", "string", ",", "backup", "api", ".", "ContainerBackupPost", ")", "(", "Operation", ",", "error", ")", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "// Send the request", "op", ",", "_", ",", "err", ":=", "r", ".", "queryOperation", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "containerName", ")", ",", "url", ".", "QueryEscape", "(", "name", ")", ")", ",", "backup", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "op", ",", "nil", "\n", "}"], "docstring": "// RenameContainerBackup requests that LXD renames the backup", "docstring_tokens": ["RenameContainerBackup", "requests", "that", "LXD", "renames", "the", "backup"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_containers.go#L1816-L1829", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/containers.go", "func_name": "ContainerConfig", "original_string": "func (c *Cluster) ContainerConfig(id int) (map[string]string, error) {\n\tvar key, value string\n\tq := `SELECT key, value FROM containers_config WHERE container_id=?`\n\n\tinargs := []interface{}{id}\n\toutfmt := []interface{}{key, value}\n\n\t// Results is already a slice here, not db Rows anymore.\n\tresults, err := queryScan(c.db, q, inargs, outfmt)\n\tif err != nil {\n\t\treturn nil, err //SmartError will wrap this and make \"not found\" errors pretty\n\t}\n\n\tconfig := map[string]string{}\n\n\tfor _, r := range results {\n\t\tkey = r[0].(string)\n\t\tvalue = r[1].(string)\n\n\t\tconfig[key] = value\n\t}\n\n\treturn config, nil\n}", "language": "go", "code": "func (c *Cluster) ContainerConfig(id int) (map[string]string, error) {\n\tvar key, value string\n\tq := `SELECT key, value FROM containers_config WHERE container_id=?`\n\n\tinargs := []interface{}{id}\n\toutfmt := []interface{}{key, value}\n\n\t// Results is already a slice here, not db Rows anymore.\n\tresults, err := queryScan(c.db, q, inargs, outfmt)\n\tif err != nil {\n\t\treturn nil, err //SmartError will wrap this and make \"not found\" errors pretty\n\t}\n\n\tconfig := map[string]string{}\n\n\tfor _, r := range results {\n\t\tkey = r[0].(string)\n\t\tvalue = r[1].(string)\n\n\t\tconfig[key] = value\n\t}\n\n\treturn config, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "ContainerConfig", "(", "id", "int", ")", "(", "map", "[", "string", "]", "string", ",", "error", ")", "{", "var", "key", ",", "value", "string", "\n", "q", ":=", "`SELECT key, value FROM containers_config WHERE container_id=?`", "\n\n", "inargs", ":=", "[", "]", "interface", "{", "}", "{", "id", "}", "\n", "outfmt", ":=", "[", "]", "interface", "{", "}", "{", "key", ",", "value", "}", "\n\n", "// Results is already a slice here, not db Rows anymore.", "results", ",", "err", ":=", "queryScan", "(", "c", ".", "db", ",", "q", ",", "inargs", ",", "outfmt", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "//SmartError will wrap this and make \"not found\" errors pretty", "\n", "}", "\n\n", "config", ":=", "map", "[", "string", "]", "string", "{", "}", "\n\n", "for", "_", ",", "r", ":=", "range", "results", "{", "key", "=", "r", "[", "0", "]", ".", "(", "string", ")", "\n", "value", "=", "r", "[", "1", "]", ".", "(", "string", ")", "\n\n", "config", "[", "key", "]", "=", "value", "\n", "}", "\n\n", "return", "config", ",", "nil", "\n", "}"], "docstring": "// ContainerConfig gets the container configuration map from the DB", "docstring_tokens": ["ContainerConfig", "gets", "the", "container", "configuration", "map", "from", "the", "DB"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/containers.go#L720-L743", "partition": "test"}
{"repo": "knq/sdhook", "path": "opts.go", "func_name": "LoggingService", "original_string": "func LoggingService(service *logging.Service) Option {\n\treturn func(sh *StackdriverHook) error {\n\t\tsh.service = service.Entries\n\t\treturn nil\n\t}\n}", "language": "go", "code": "func LoggingService(service *logging.Service) Option {\n\treturn func(sh *StackdriverHook) error {\n\t\tsh.service = service.Entries\n\t\treturn nil\n\t}\n}", "code_tokens": ["func", "LoggingService", "(", "service", "*", "logging", ".", "Service", ")", "Option", "{", "return", "func", "(", "sh", "*", "StackdriverHook", ")", "error", "{", "sh", ".", "service", "=", "service", ".", "Entries", "\n", "return", "nil", "\n", "}", "\n", "}"], "docstring": "// LoggingService is an option that sets the Google API logging service to use.", "docstring_tokens": ["LoggingService", "is", "an", "option", "that", "sets", "the", "Google", "API", "logging", "service", "to", "use", "."], "sha": "41b9ccbff0b5fa5a56fbdccf2eb8653e7afe8d4b", "url": "https://github.com/knq/sdhook/blob/41b9ccbff0b5fa5a56fbdccf2eb8653e7afe8d4b/opts.go#L53-L58", "partition": "test"}
{"repo": "hashicorp/raft", "path": "tcp_transport.go", "func_name": "Accept", "original_string": "func (t *TCPStreamLayer) Accept() (c net.Conn, err error) {\n\treturn t.listener.Accept()\n}", "language": "go", "code": "func (t *TCPStreamLayer) Accept() (c net.Conn, err error) {\n\treturn t.listener.Accept()\n}", "code_tokens": ["func", "(", "t", "*", "TCPStreamLayer", ")", "Accept", "(", ")", "(", "c", "net", ".", "Conn", ",", "err", "error", ")", "{", "return", "t", ".", "listener", ".", "Accept", "(", ")", "\n", "}"], "docstring": "// Accept implements the net.Listener interface.", "docstring_tokens": ["Accept", "implements", "the", "net", ".", "Listener", "interface", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/tcp_transport.go#L100-L102", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/github/fakegithub/fakegithub.go", "func_name": "ListIssueEvents", "original_string": "func (f *FakeClient) ListIssueEvents(owner, repo string, number int) ([]github.ListedIssueEvent, error) {\n\treturn append([]github.ListedIssueEvent{}, f.IssueEvents[number]...), nil\n}", "language": "go", "code": "func (f *FakeClient) ListIssueEvents(owner, repo string, number int) ([]github.ListedIssueEvent, error) {\n\treturn append([]github.ListedIssueEvent{}, f.IssueEvents[number]...), nil\n}", "code_tokens": ["func", "(", "f", "*", "FakeClient", ")", "ListIssueEvents", "(", "owner", ",", "repo", "string", ",", "number", "int", ")", "(", "[", "]", "github", ".", "ListedIssueEvent", ",", "error", ")", "{", "return", "append", "(", "[", "]", "github", ".", "ListedIssueEvent", "{", "}", ",", "f", ".", "IssueEvents", "[", "number", "]", "...", ")", ",", "nil", "\n", "}"], "docstring": "// ListIssueEvents returns issue events", "docstring_tokens": ["ListIssueEvents", "returns", "issue", "events"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/fakegithub/fakegithub.go#L135-L137", "partition": "test"}
{"repo": "mikespook/possum", "path": "helper.go", "func_name": "WrapHTTPHandlerFunc", "original_string": "func WrapHTTPHandlerFunc(f http.HandlerFunc) HandlerFunc {\n\tnewF := func(ctx *Context) error {\n\t\tf(ctx.Response, ctx.Request)\n\t\treturn nil\n\t}\n\treturn newF\n}", "language": "go", "code": "func WrapHTTPHandlerFunc(f http.HandlerFunc) HandlerFunc {\n\tnewF := func(ctx *Context) error {\n\t\tf(ctx.Response, ctx.Request)\n\t\treturn nil\n\t}\n\treturn newF\n}", "code_tokens": ["func", "WrapHTTPHandlerFunc", "(", "f", "http", ".", "HandlerFunc", ")", "HandlerFunc", "{", "newF", ":=", "func", "(", "ctx", "*", "Context", ")", "error", "{", "f", "(", "ctx", ".", "Response", ",", "ctx", ".", "Request", ")", "\n", "return", "nil", "\n", "}", "\n", "return", "newF", "\n", "}"], "docstring": "// WrapHTTPHandlerFunc wraps http.HandlerFunc in possum.HandlerFunc.\n// See pprof.go.", "docstring_tokens": ["WrapHTTPHandlerFunc", "wraps", "http", ".", "HandlerFunc", "in", "possum", ".", "HandlerFunc", ".", "See", "pprof", ".", "go", "."], "sha": "56d7ebb6470b670001632b11be7fc089038f4dd7", "url": "https://github.com/mikespook/possum/blob/56d7ebb6470b670001632b11be7fc089038f4dd7/helper.go#L50-L56", "partition": "test"}
{"repo": "mikespook/possum", "path": "helper.go", "func_name": "WebSocketHandlerFunc", "original_string": "func WebSocketHandlerFunc(f func(ws *websocket.Conn)) HandlerFunc {\n\th := websocket.Handler(f)\n\treturn WrapHTTPHandlerFunc(h.ServeHTTP)\n}", "language": "go", "code": "func WebSocketHandlerFunc(f func(ws *websocket.Conn)) HandlerFunc {\n\th := websocket.Handler(f)\n\treturn WrapHTTPHandlerFunc(h.ServeHTTP)\n}", "code_tokens": ["func", "WebSocketHandlerFunc", "(", "f", "func", "(", "ws", "*", "websocket", ".", "Conn", ")", ")", "HandlerFunc", "{", "h", ":=", "websocket", ".", "Handler", "(", "f", ")", "\n", "return", "WrapHTTPHandlerFunc", "(", "h", ".", "ServeHTTP", ")", "\n", "}"], "docstring": "// WebSocketHandlerFunc convert websocket function to possum.HandlerFunc.", "docstring_tokens": ["WebSocketHandlerFunc", "convert", "websocket", "function", "to", "possum", ".", "HandlerFunc", "."], "sha": "56d7ebb6470b670001632b11be7fc089038f4dd7", "url": "https://github.com/mikespook/possum/blob/56d7ebb6470b670001632b11be7fc089038f4dd7/helper.go#L59-L62", "partition": "test"}
{"repo": "golang/appengine", "path": "taskqueue/taskqueue.go", "func_name": "Lease", "original_string": "func Lease(c context.Context, maxTasks int, queueName string, leaseTime int) ([]*Task, error) {\n\treturn lease(c, maxTasks, queueName, leaseTime, false, nil)\n}", "language": "go", "code": "func Lease(c context.Context, maxTasks int, queueName string, leaseTime int) ([]*Task, error) {\n\treturn lease(c, maxTasks, queueName, leaseTime, false, nil)\n}", "code_tokens": ["func", "Lease", "(", "c", "context", ".", "Context", ",", "maxTasks", "int", ",", "queueName", "string", ",", "leaseTime", "int", ")", "(", "[", "]", "*", "Task", ",", "error", ")", "{", "return", "lease", "(", "c", ",", "maxTasks", ",", "queueName", ",", "leaseTime", ",", "false", ",", "nil", ")", "\n", "}"], "docstring": "// Lease leases tasks from a queue.\n// leaseTime is in seconds.\n// The number of tasks fetched will be at most maxTasks.", "docstring_tokens": ["Lease", "leases", "tasks", "from", "a", "queue", ".", "leaseTime", "is", "in", "seconds", ".", "The", "number", "of", "tasks", "fetched", "will", "be", "at", "most", "maxTasks", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/taskqueue/taskqueue.go#L436-L438", "partition": "test"}
{"repo": "rlmcpherson/s3gof3r", "path": "s3gof3r.go", "func_name": "PutWriter", "original_string": "func (b *Bucket) PutWriter(path string, h http.Header, c *Config) (w io.WriteCloser, err error) {\n\tif c == nil {\n\t\tc = b.conf()\n\t}\n\tu, err := b.url(path, c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newPutter(*u, h, c, b)\n}", "language": "go", "code": "func (b *Bucket) PutWriter(path string, h http.Header, c *Config) (w io.WriteCloser, err error) {\n\tif c == nil {\n\t\tc = b.conf()\n\t}\n\tu, err := b.url(path, c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newPutter(*u, h, c, b)\n}", "code_tokens": ["func", "(", "b", "*", "Bucket", ")", "PutWriter", "(", "path", "string", ",", "h", "http", ".", "Header", ",", "c", "*", "Config", ")", "(", "w", "io", ".", "WriteCloser", ",", "err", "error", ")", "{", "if", "c", "==", "nil", "{", "c", "=", "b", ".", "conf", "(", ")", "\n", "}", "\n", "u", ",", "err", ":=", "b", ".", "url", "(", "path", ",", "c", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "newPutter", "(", "*", "u", ",", "h", ",", "c", ",", "b", ")", "\n", "}"], "docstring": "// PutWriter provides a writer to upload data as multipart upload requests.\n//\n// Each header in h is added to the HTTP request header. This is useful for specifying\n// options such as server-side encryption in metadata as well as custom user metadata.\n// DefaultConfig is used if c is nil.\n// Callers should call Close on w to ensure that all resources are released.", "docstring_tokens": ["PutWriter", "provides", "a", "writer", "to", "upload", "data", "as", "multipart", "upload", "requests", ".", "Each", "header", "in", "h", "is", "added", "to", "the", "HTTP", "request", "header", ".", "This", "is", "useful", "for", "specifying", "options", "such", "as", "server", "-", "side", "encryption", "in", "metadata", "as", "well", "as", "custom", "user", "metadata", ".", "DefaultConfig", "is", "used", "if", "c", "is", "nil", ".", "Callers", "should", "call", "Close", "on", "w", "to", "ensure", "that", "all", "resources", "are", "released", "."], "sha": "864ae0bf7cf2e20c0002b7ea17f4d84fec1abc14", "url": "https://github.com/rlmcpherson/s3gof3r/blob/864ae0bf7cf2e20c0002b7ea17f4d84fec1abc14/s3gof3r.go#L136-L146", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdctl/ctlv2/command/ls_command.go", "func_name": "printLs", "original_string": "func printLs(c *cli.Context, resp *client.Response) {\n\tif c.GlobalString(\"output\") == \"simple\" {\n\t\tif !resp.Node.Dir {\n\t\t\tfmt.Println(resp.Node.Key)\n\t\t}\n\t\tfor _, node := range resp.Node.Nodes {\n\t\t\trPrint(c, node)\n\t\t}\n\t} else {\n\t\t// user wants JSON or extended output\n\t\tprintResponseKey(resp, c.GlobalString(\"output\"))\n\t}\n}", "language": "go", "code": "func printLs(c *cli.Context, resp *client.Response) {\n\tif c.GlobalString(\"output\") == \"simple\" {\n\t\tif !resp.Node.Dir {\n\t\t\tfmt.Println(resp.Node.Key)\n\t\t}\n\t\tfor _, node := range resp.Node.Nodes {\n\t\t\trPrint(c, node)\n\t\t}\n\t} else {\n\t\t// user wants JSON or extended output\n\t\tprintResponseKey(resp, c.GlobalString(\"output\"))\n\t}\n}", "code_tokens": ["func", "printLs", "(", "c", "*", "cli", ".", "Context", ",", "resp", "*", "client", ".", "Response", ")", "{", "if", "c", ".", "GlobalString", "(", "\"", "\"", ")", "==", "\"", "\"", "{", "if", "!", "resp", ".", "Node", ".", "Dir", "{", "fmt", ".", "Println", "(", "resp", ".", "Node", ".", "Key", ")", "\n", "}", "\n", "for", "_", ",", "node", ":=", "range", "resp", ".", "Node", ".", "Nodes", "{", "rPrint", "(", "c", ",", "node", ")", "\n", "}", "\n", "}", "else", "{", "// user wants JSON or extended output", "printResponseKey", "(", "resp", ",", "c", ".", "GlobalString", "(", "\"", "\"", ")", ")", "\n", "}", "\n", "}"], "docstring": "// printLs writes a response out in a manner similar to the `ls` command in unix.\n// Non-empty directories list their contents and files list their name.", "docstring_tokens": ["printLs", "writes", "a", "response", "out", "in", "a", "manner", "similar", "to", "the", "ls", "command", "in", "unix", ".", "Non", "-", "empty", "directories", "list", "their", "contents", "and", "files", "list", "their", "name", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv2/command/ls_command.go#L65-L77", "partition": "test"}
{"repo": "segmentio/objconv", "path": "encode.go", "func_name": "EncodeArray", "original_string": "func (e Encoder) EncodeArray(n int, f func(Encoder) error) (err error) {\n\tif e.key {\n\t\tif e.key, err = false, e.Emitter.EmitMapValue(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif err = e.Emitter.EmitArrayBegin(n); err != nil {\n\t\treturn\n\t}\n\nencodeArray:\n\tfor i := 0; n < 0 || i < n; i++ {\n\t\tif i != 0 {\n\t\t\tif e.Emitter.EmitArrayNext(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tswitch err = f(e); err {\n\t\tcase nil:\n\t\tcase End:\n\t\t\tbreak encodeArray\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn e.Emitter.EmitArrayEnd()\n}", "language": "go", "code": "func (e Encoder) EncodeArray(n int, f func(Encoder) error) (err error) {\n\tif e.key {\n\t\tif e.key, err = false, e.Emitter.EmitMapValue(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif err = e.Emitter.EmitArrayBegin(n); err != nil {\n\t\treturn\n\t}\n\nencodeArray:\n\tfor i := 0; n < 0 || i < n; i++ {\n\t\tif i != 0 {\n\t\t\tif e.Emitter.EmitArrayNext(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tswitch err = f(e); err {\n\t\tcase nil:\n\t\tcase End:\n\t\t\tbreak encodeArray\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn e.Emitter.EmitArrayEnd()\n}", "code_tokens": ["func", "(", "e", "Encoder", ")", "EncodeArray", "(", "n", "int", ",", "f", "func", "(", "Encoder", ")", "error", ")", "(", "err", "error", ")", "{", "if", "e", ".", "key", "{", "if", "e", ".", "key", ",", "err", "=", "false", ",", "e", ".", "Emitter", ".", "EmitMapValue", "(", ")", ";", "err", "!=", "nil", "{", "return", "\n", "}", "\n", "}", "\n\n", "if", "err", "=", "e", ".", "Emitter", ".", "EmitArrayBegin", "(", "n", ")", ";", "err", "!=", "nil", "{", "return", "\n", "}", "\n\n", "encodeArray", ":", "for", "i", ":=", "0", ";", "n", "<", "0", "||", "i", "<", "n", ";", "i", "++", "{", "if", "i", "!=", "0", "{", "if", "e", ".", "Emitter", ".", "EmitArrayNext", "(", ")", ";", "err", "!=", "nil", "{", "return", "\n", "}", "\n", "}", "\n", "switch", "err", "=", "f", "(", "e", ")", ";", "err", "{", "case", "nil", ":", "case", "End", ":", "break", "encodeArray", "\n", "default", ":", "return", "\n", "}", "\n", "}", "\n\n", "return", "e", ".", "Emitter", ".", "EmitArrayEnd", "(", ")", "\n", "}"], "docstring": "// EncodeArray provides the implementation of the array encoding algorithm,\n// where n is the number of elements in the array, and f a function called to\n// encode each element.\n//\n// The n argument can be set to a negative value to indicate that the program\n// doesn't know how many elements it will output to the array. Be mindful that\n// not all emitters support encoding arrays of unknown lengths.\n//\n// The f function is called to encode each element of the array.", "docstring_tokens": ["EncodeArray", "provides", "the", "implementation", "of", "the", "array", "encoding", "algorithm", "where", "n", "is", "the", "number", "of", "elements", "in", "the", "array", "and", "f", "a", "function", "called", "to", "encode", "each", "element", ".", "The", "n", "argument", "can", "be", "set", "to", "a", "negative", "value", "to", "indicate", "that", "the", "program", "doesn", "t", "know", "how", "many", "elements", "it", "will", "output", "to", "the", "array", ".", "Be", "mindful", "that", "not", "all", "emitters", "support", "encoding", "arrays", "of", "unknown", "lengths", ".", "The", "f", "function", "is", "called", "to", "encode", "each", "element", "of", "the", "array", "."], "sha": "7a1d7b8e6f3551b30751e6b2ea6bae500883870e", "url": "https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/encode.go#L620-L648", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "ValidEnum", "original_string": "func (e CreateAccountResultCode) ValidEnum(v int32) bool {\n\t_, ok := createAccountResultCodeMap[v]\n\treturn ok\n}", "language": "go", "code": "func (e CreateAccountResultCode) ValidEnum(v int32) bool {\n\t_, ok := createAccountResultCodeMap[v]\n\treturn ok\n}", "code_tokens": ["func", "(", "e", "CreateAccountResultCode", ")", "ValidEnum", "(", "v", "int32", ")", "bool", "{", "_", ",", "ok", ":=", "createAccountResultCodeMap", "[", "v", "]", "\n", "return", "ok", "\n", "}"], "docstring": "// ValidEnum validates a proposed value for this enum.  Implements\n// the Enum interface for CreateAccountResultCode", "docstring_tokens": ["ValidEnum", "validates", "a", "proposed", "value", "for", "this", "enum", ".", "Implements", "the", "Enum", "interface", "for", "CreateAccountResultCode"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L2511-L2514", "partition": "test"}
{"repo": "jhillyerd/enmime", "path": "match.go", "func_name": "DepthMatchFirst", "original_string": "func (p *Part) DepthMatchFirst(matcher PartMatcher) *Part {\n\troot := p\n\tfor {\n\t\tif matcher(p) {\n\t\t\treturn p\n\t\t}\n\t\tc := p.FirstChild\n\t\tif c != nil {\n\t\t\tp = c\n\t\t} else {\n\t\t\tfor p.NextSibling == nil {\n\t\t\t\tif p == root {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tp = p.Parent\n\t\t\t}\n\t\t\tp = p.NextSibling\n\t\t}\n\t}\n}", "language": "go", "code": "func (p *Part) DepthMatchFirst(matcher PartMatcher) *Part {\n\troot := p\n\tfor {\n\t\tif matcher(p) {\n\t\t\treturn p\n\t\t}\n\t\tc := p.FirstChild\n\t\tif c != nil {\n\t\t\tp = c\n\t\t} else {\n\t\t\tfor p.NextSibling == nil {\n\t\t\t\tif p == root {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tp = p.Parent\n\t\t\t}\n\t\t\tp = p.NextSibling\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "p", "*", "Part", ")", "DepthMatchFirst", "(", "matcher", "PartMatcher", ")", "*", "Part", "{", "root", ":=", "p", "\n", "for", "{", "if", "matcher", "(", "p", ")", "{", "return", "p", "\n", "}", "\n", "c", ":=", "p", ".", "FirstChild", "\n", "if", "c", "!=", "nil", "{", "p", "=", "c", "\n", "}", "else", "{", "for", "p", ".", "NextSibling", "==", "nil", "{", "if", "p", "==", "root", "{", "return", "nil", "\n", "}", "\n", "p", "=", "p", ".", "Parent", "\n", "}", "\n", "p", "=", "p", ".", "NextSibling", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// DepthMatchFirst performs a depth first search of the Part tree and returns the first part that\n// causes the given matcher to return true", "docstring_tokens": ["DepthMatchFirst", "performs", "a", "depth", "first", "search", "of", "the", "Part", "tree", "and", "returns", "the", "first", "part", "that", "causes", "the", "given", "matcher", "to", "return", "true"], "sha": "874cc30e023f36bd1df525716196887b0f04851b", "url": "https://github.com/jhillyerd/enmime/blob/874cc30e023f36bd1df525716196887b0f04851b/match.go#L64-L83", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/server.go", "func_name": "monitorVersions", "original_string": "func (s *EtcdServer) monitorVersions() {\n\tfor {\n\t\tselect {\n\t\tcase <-s.forceVersionC:\n\t\tcase <-time.After(monitorVersionInterval):\n\t\tcase <-s.stopping:\n\t\t\treturn\n\t\t}\n\n\t\tif s.Leader() != s.ID() {\n\t\t\tcontinue\n\t\t}\n\n\t\tv := decideClusterVersion(s.getLogger(), getVersions(s.getLogger(), s.cluster, s.id, s.peerRt))\n\t\tif v != nil {\n\t\t\t// only keep major.minor version for comparison\n\t\t\tv = &semver.Version{\n\t\t\t\tMajor: v.Major,\n\t\t\t\tMinor: v.Minor,\n\t\t\t}\n\t\t}\n\n\t\t// if the current version is nil:\n\t\t// 1. use the decided version if possible\n\t\t// 2. or use the min cluster version\n\t\tif s.cluster.Version() == nil {\n\t\t\tverStr := version.MinClusterVersion\n\t\t\tif v != nil {\n\t\t\t\tverStr = v.String()\n\t\t\t}\n\t\t\ts.goAttach(func() { s.updateClusterVersion(verStr) })\n\t\t\tcontinue\n\t\t}\n\n\t\t// update cluster version only if the decided version is greater than\n\t\t// the current cluster version\n\t\tif v != nil && s.cluster.Version().LessThan(*v) {\n\t\t\ts.goAttach(func() { s.updateClusterVersion(v.String()) })\n\t\t}\n\t}\n}", "language": "go", "code": "func (s *EtcdServer) monitorVersions() {\n\tfor {\n\t\tselect {\n\t\tcase <-s.forceVersionC:\n\t\tcase <-time.After(monitorVersionInterval):\n\t\tcase <-s.stopping:\n\t\t\treturn\n\t\t}\n\n\t\tif s.Leader() != s.ID() {\n\t\t\tcontinue\n\t\t}\n\n\t\tv := decideClusterVersion(s.getLogger(), getVersions(s.getLogger(), s.cluster, s.id, s.peerRt))\n\t\tif v != nil {\n\t\t\t// only keep major.minor version for comparison\n\t\t\tv = &semver.Version{\n\t\t\t\tMajor: v.Major,\n\t\t\t\tMinor: v.Minor,\n\t\t\t}\n\t\t}\n\n\t\t// if the current version is nil:\n\t\t// 1. use the decided version if possible\n\t\t// 2. or use the min cluster version\n\t\tif s.cluster.Version() == nil {\n\t\t\tverStr := version.MinClusterVersion\n\t\t\tif v != nil {\n\t\t\t\tverStr = v.String()\n\t\t\t}\n\t\t\ts.goAttach(func() { s.updateClusterVersion(verStr) })\n\t\t\tcontinue\n\t\t}\n\n\t\t// update cluster version only if the decided version is greater than\n\t\t// the current cluster version\n\t\tif v != nil && s.cluster.Version().LessThan(*v) {\n\t\t\ts.goAttach(func() { s.updateClusterVersion(v.String()) })\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "EtcdServer", ")", "monitorVersions", "(", ")", "{", "for", "{", "select", "{", "case", "<-", "s", ".", "forceVersionC", ":", "case", "<-", "time", ".", "After", "(", "monitorVersionInterval", ")", ":", "case", "<-", "s", ".", "stopping", ":", "return", "\n", "}", "\n\n", "if", "s", ".", "Leader", "(", ")", "!=", "s", ".", "ID", "(", ")", "{", "continue", "\n", "}", "\n\n", "v", ":=", "decideClusterVersion", "(", "s", ".", "getLogger", "(", ")", ",", "getVersions", "(", "s", ".", "getLogger", "(", ")", ",", "s", ".", "cluster", ",", "s", ".", "id", ",", "s", ".", "peerRt", ")", ")", "\n", "if", "v", "!=", "nil", "{", "// only keep major.minor version for comparison", "v", "=", "&", "semver", ".", "Version", "{", "Major", ":", "v", ".", "Major", ",", "Minor", ":", "v", ".", "Minor", ",", "}", "\n", "}", "\n\n", "// if the current version is nil:", "// 1. use the decided version if possible", "// 2. or use the min cluster version", "if", "s", ".", "cluster", ".", "Version", "(", ")", "==", "nil", "{", "verStr", ":=", "version", ".", "MinClusterVersion", "\n", "if", "v", "!=", "nil", "{", "verStr", "=", "v", ".", "String", "(", ")", "\n", "}", "\n", "s", ".", "goAttach", "(", "func", "(", ")", "{", "s", ".", "updateClusterVersion", "(", "verStr", ")", "}", ")", "\n", "continue", "\n", "}", "\n\n", "// update cluster version only if the decided version is greater than", "// the current cluster version", "if", "v", "!=", "nil", "&&", "s", ".", "cluster", ".", "Version", "(", ")", ".", "LessThan", "(", "*", "v", ")", "{", "s", ".", "goAttach", "(", "func", "(", ")", "{", "s", ".", "updateClusterVersion", "(", "v", ".", "String", "(", ")", ")", "}", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// monitorVersions checks the member's version every monitorVersionInterval.\n// It updates the cluster version if all members agrees on a higher one.\n// It prints out log if there is a member with a higher version than the\n// local version.", "docstring_tokens": ["monitorVersions", "checks", "the", "member", "s", "version", "every", "monitorVersionInterval", ".", "It", "updates", "the", "cluster", "version", "if", "all", "members", "agrees", "on", "a", "higher", "one", ".", "It", "prints", "out", "log", "if", "there", "is", "a", "member", "with", "a", "higher", "version", "than", "the", "local", "version", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/server.go#L2248-L2288", "partition": "test"}
{"repo": "onsi/gomega", "path": "gomega_dsl.go", "func_name": "EventuallyWithOffset", "original_string": "func EventuallyWithOffset(offset int, actual interface{}, intervals ...interface{}) AsyncAssertion {\n\tif globalFailWrapper == nil {\n\t\tpanic(nilFailHandlerPanic)\n\t}\n\ttimeoutInterval := defaultEventuallyTimeout\n\tpollingInterval := defaultEventuallyPollingInterval\n\tif len(intervals) > 0 {\n\t\ttimeoutInterval = toDuration(intervals[0])\n\t}\n\tif len(intervals) > 1 {\n\t\tpollingInterval = toDuration(intervals[1])\n\t}\n\treturn asyncassertion.New(asyncassertion.AsyncAssertionTypeEventually, actual, globalFailWrapper, timeoutInterval, pollingInterval, offset)\n}", "language": "go", "code": "func EventuallyWithOffset(offset int, actual interface{}, intervals ...interface{}) AsyncAssertion {\n\tif globalFailWrapper == nil {\n\t\tpanic(nilFailHandlerPanic)\n\t}\n\ttimeoutInterval := defaultEventuallyTimeout\n\tpollingInterval := defaultEventuallyPollingInterval\n\tif len(intervals) > 0 {\n\t\ttimeoutInterval = toDuration(intervals[0])\n\t}\n\tif len(intervals) > 1 {\n\t\tpollingInterval = toDuration(intervals[1])\n\t}\n\treturn asyncassertion.New(asyncassertion.AsyncAssertionTypeEventually, actual, globalFailWrapper, timeoutInterval, pollingInterval, offset)\n}", "code_tokens": ["func", "EventuallyWithOffset", "(", "offset", "int", ",", "actual", "interface", "{", "}", ",", "intervals", "...", "interface", "{", "}", ")", "AsyncAssertion", "{", "if", "globalFailWrapper", "==", "nil", "{", "panic", "(", "nilFailHandlerPanic", ")", "\n", "}", "\n", "timeoutInterval", ":=", "defaultEventuallyTimeout", "\n", "pollingInterval", ":=", "defaultEventuallyPollingInterval", "\n", "if", "len", "(", "intervals", ")", ">", "0", "{", "timeoutInterval", "=", "toDuration", "(", "intervals", "[", "0", "]", ")", "\n", "}", "\n", "if", "len", "(", "intervals", ")", ">", "1", "{", "pollingInterval", "=", "toDuration", "(", "intervals", "[", "1", "]", ")", "\n", "}", "\n", "return", "asyncassertion", ".", "New", "(", "asyncassertion", ".", "AsyncAssertionTypeEventually", ",", "actual", ",", "globalFailWrapper", ",", "timeoutInterval", ",", "pollingInterval", ",", "offset", ")", "\n", "}"], "docstring": "// EventuallyWithOffset operates like Eventually but takes an additional\n// initial argument to indicate an offset in the call stack.  This is useful when building helper\n// functions that contain matchers.  To learn more, read about `ExpectWithOffset`.", "docstring_tokens": ["EventuallyWithOffset", "operates", "like", "Eventually", "but", "takes", "an", "additional", "initial", "argument", "to", "indicate", "an", "offset", "in", "the", "call", "stack", ".", "This", "is", "useful", "when", "building", "helper", "functions", "that", "contain", "matchers", ".", "To", "learn", "more", "read", "about", "ExpectWithOffset", "."], "sha": "f0e010e04c08c48a875f83d17df37b04eb3a985b", "url": "https://github.com/onsi/gomega/blob/f0e010e04c08c48a875f83d17df37b04eb3a985b/gomega_dsl.go#L213-L226", "partition": "test"}
{"repo": "rightscale/rsc", "path": "cm15/codegen_client.go", "func_name": "AlertSpecLocator", "original_string": "func (api *API) AlertSpecLocator(href string) *AlertSpecLocator {\n\treturn &AlertSpecLocator{Href(href), api}\n}", "language": "go", "code": "func (api *API) AlertSpecLocator(href string) *AlertSpecLocator {\n\treturn &AlertSpecLocator{Href(href), api}\n}", "code_tokens": ["func", "(", "api", "*", "API", ")", "AlertSpecLocator", "(", "href", "string", ")", "*", "AlertSpecLocator", "{", "return", "&", "AlertSpecLocator", "{", "Href", "(", "href", ")", ",", "api", "}", "\n", "}"], "docstring": "// AlertSpecLocator builds a locator from the given href.", "docstring_tokens": ["AlertSpecLocator", "builds", "a", "locator", "from", "the", "given", "href", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L590-L592", "partition": "test"}
{"repo": "libp2p/go-libp2p-net", "path": "notifiee.go", "func_name": "OpenedStream", "original_string": "func (nb *NotifyBundle) OpenedStream(n Network, s Stream) {\n\tif nb.OpenedStreamF != nil {\n\t\tnb.OpenedStreamF(n, s)\n\t}\n}", "language": "go", "code": "func (nb *NotifyBundle) OpenedStream(n Network, s Stream) {\n\tif nb.OpenedStreamF != nil {\n\t\tnb.OpenedStreamF(n, s)\n\t}\n}", "code_tokens": ["func", "(", "nb", "*", "NotifyBundle", ")", "OpenedStream", "(", "n", "Network", ",", "s", "Stream", ")", "{", "if", "nb", ".", "OpenedStreamF", "!=", "nil", "{", "nb", ".", "OpenedStreamF", "(", "n", ",", "s", ")", "\n", "}", "\n", "}"], "docstring": "// OpenedStream calls OpenedStreamF if it is not null.", "docstring_tokens": ["OpenedStream", "calls", "OpenedStreamF", "if", "it", "is", "not", "null", "."], "sha": "a60cde50df6872512892ca85019341d281f72a42", "url": "https://github.com/libp2p/go-libp2p-net/blob/a60cde50df6872512892ca85019341d281f72a42/notifiee.go#L52-L56", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "language/proto/generate.go", "func_name": "RuleName", "original_string": "func RuleName(names ...string) string {\n\tbase := \"root\"\n\tfor _, name := range names {\n\t\tnotIdent := func(c rune) bool {\n\t\t\treturn !('A' <= c && c <= 'Z' ||\n\t\t\t\t'a' <= c && c <= 'z' ||\n\t\t\t\t'0' <= c && c <= '9' ||\n\t\t\t\tc == '_')\n\t\t}\n\t\tif i := strings.LastIndexFunc(name, notIdent); i >= 0 {\n\t\t\tname = name[i+1:]\n\t\t}\n\t\tif name != \"\" {\n\t\t\tbase = name\n\t\t\tbreak\n\t\t}\n\t}\n\treturn base + \"_proto\"\n}", "language": "go", "code": "func RuleName(names ...string) string {\n\tbase := \"root\"\n\tfor _, name := range names {\n\t\tnotIdent := func(c rune) bool {\n\t\t\treturn !('A' <= c && c <= 'Z' ||\n\t\t\t\t'a' <= c && c <= 'z' ||\n\t\t\t\t'0' <= c && c <= '9' ||\n\t\t\t\tc == '_')\n\t\t}\n\t\tif i := strings.LastIndexFunc(name, notIdent); i >= 0 {\n\t\t\tname = name[i+1:]\n\t\t}\n\t\tif name != \"\" {\n\t\t\tbase = name\n\t\t\tbreak\n\t\t}\n\t}\n\treturn base + \"_proto\"\n}", "code_tokens": ["func", "RuleName", "(", "names", "...", "string", ")", "string", "{", "base", ":=", "\"", "\"", "\n", "for", "_", ",", "name", ":=", "range", "names", "{", "notIdent", ":=", "func", "(", "c", "rune", ")", "bool", "{", "return", "!", "(", "'A'", "<=", "c", "&&", "c", "<=", "'Z'", "||", "'a'", "<=", "c", "&&", "c", "<=", "'z'", "||", "'0'", "<=", "c", "&&", "c", "<=", "'9'", "||", "c", "==", "'_'", ")", "\n", "}", "\n", "if", "i", ":=", "strings", ".", "LastIndexFunc", "(", "name", ",", "notIdent", ")", ";", "i", ">=", "0", "{", "name", "=", "name", "[", "i", "+", "1", ":", "]", "\n", "}", "\n", "if", "name", "!=", "\"", "\"", "{", "base", "=", "name", "\n", "break", "\n", "}", "\n", "}", "\n", "return", "base", "+", "\"", "\"", "\n", "}"], "docstring": "// RuleName returns a name for a proto_library derived from the given strings.\n// For each string, RuleName will look for a non-empty suffix of identifier\n// characters and then append \"_proto\" to that.", "docstring_tokens": ["RuleName", "returns", "a", "name", "for", "a", "proto_library", "derived", "from", "the", "given", "strings", ".", "For", "each", "string", "RuleName", "will", "look", "for", "a", "non", "-", "empty", "suffix", "of", "identifier", "characters", "and", "then", "append", "_proto", "to", "that", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/language/proto/generate.go#L75-L93", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "proxy/grpcproxy/cache/store.go", "func_name": "Compact", "original_string": "func (c *cache) Compact(revision int64) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif revision > c.compactedRev {\n\t\tc.compactedRev = revision\n\t}\n}", "language": "go", "code": "func (c *cache) Compact(revision int64) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif revision > c.compactedRev {\n\t\tc.compactedRev = revision\n\t}\n}", "code_tokens": ["func", "(", "c", "*", "cache", ")", "Compact", "(", "revision", "int64", ")", "{", "c", ".", "mu", ".", "Lock", "(", ")", "\n", "defer", "c", ".", "mu", ".", "Unlock", "(", ")", "\n\n", "if", "revision", ">", "c", ".", "compactedRev", "{", "c", ".", "compactedRev", "=", "revision", "\n", "}", "\n", "}"], "docstring": "// Compact invalidate all caching response before the given rev.\n// Replace with the invalidation is lazy. The actual removal happens when the entries is accessed.", "docstring_tokens": ["Compact", "invalidate", "all", "caching", "response", "before", "the", "given", "rev", ".", "Replace", "with", "the", "invalidation", "is", "lazy", ".", "The", "actual", "removal", "happens", "when", "the", "entries", "is", "accessed", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/proxy/grpcproxy/cache/store.go#L158-L165", "partition": "test"}
{"repo": "containers/image", "path": "image/docker_schema1.go", "func_name": "manifestSchema1FromComponents", "original_string": "func manifestSchema1FromComponents(ref reference.Named, fsLayers []manifest.Schema1FSLayers, history []manifest.Schema1History, architecture string) (genericManifest, error) {\n\tm, err := manifest.Schema1FromComponents(ref, fsLayers, history, architecture)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &manifestSchema1{m: m}, nil\n}", "language": "go", "code": "func manifestSchema1FromComponents(ref reference.Named, fsLayers []manifest.Schema1FSLayers, history []manifest.Schema1History, architecture string) (genericManifest, error) {\n\tm, err := manifest.Schema1FromComponents(ref, fsLayers, history, architecture)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &manifestSchema1{m: m}, nil\n}", "code_tokens": ["func", "manifestSchema1FromComponents", "(", "ref", "reference", ".", "Named", ",", "fsLayers", "[", "]", "manifest", ".", "Schema1FSLayers", ",", "history", "[", "]", "manifest", ".", "Schema1History", ",", "architecture", "string", ")", "(", "genericManifest", ",", "error", ")", "{", "m", ",", "err", ":=", "manifest", ".", "Schema1FromComponents", "(", "ref", ",", "fsLayers", ",", "history", ",", "architecture", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "&", "manifestSchema1", "{", "m", ":", "m", "}", ",", "nil", "\n", "}"], "docstring": "// manifestSchema1FromComponents builds a new manifestSchema1 from the supplied data.", "docstring_tokens": ["manifestSchema1FromComponents", "builds", "a", "new", "manifestSchema1", "from", "the", "supplied", "data", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/image/docker_schema1.go#L27-L33", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "proxy/grpcproxy/cache/store.go", "func_name": "keyFunc", "original_string": "func keyFunc(req *pb.RangeRequest) string {\n\t// TODO: use marshalTo to reduce allocation\n\tb, err := req.Marshal()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn string(b)\n}", "language": "go", "code": "func keyFunc(req *pb.RangeRequest) string {\n\t// TODO: use marshalTo to reduce allocation\n\tb, err := req.Marshal()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn string(b)\n}", "code_tokens": ["func", "keyFunc", "(", "req", "*", "pb", ".", "RangeRequest", ")", "string", "{", "// TODO: use marshalTo to reduce allocation", "b", ",", "err", ":=", "req", ".", "Marshal", "(", ")", "\n", "if", "err", "!=", "nil", "{", "panic", "(", "err", ")", "\n", "}", "\n", "return", "string", "(", "b", ")", "\n", "}"], "docstring": "// keyFunc returns the key of a request, which is used to look up its caching response in the cache.", "docstring_tokens": ["keyFunc", "returns", "the", "key", "of", "a", "request", "which", "is", "used", "to", "look", "up", "its", "caching", "response", "in", "the", "cache", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/proxy/grpcproxy/cache/store.go#L44-L51", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/pod-utils/clone/clone.go", "func_name": "gitCtxForRefs", "original_string": "func gitCtxForRefs(refs prowapi.Refs, baseDir string, env []string) gitCtx {\n\tg := gitCtx{\n\t\tcloneDir:      PathForRefs(baseDir, refs),\n\t\tenv:           env,\n\t\trepositoryURI: fmt.Sprintf(\"https://github.com/%s/%s.git\", refs.Org, refs.Repo),\n\t}\n\tif refs.CloneURI != \"\" {\n\t\tg.repositoryURI = refs.CloneURI\n\t}\n\treturn g\n}", "language": "go", "code": "func gitCtxForRefs(refs prowapi.Refs, baseDir string, env []string) gitCtx {\n\tg := gitCtx{\n\t\tcloneDir:      PathForRefs(baseDir, refs),\n\t\tenv:           env,\n\t\trepositoryURI: fmt.Sprintf(\"https://github.com/%s/%s.git\", refs.Org, refs.Repo),\n\t}\n\tif refs.CloneURI != \"\" {\n\t\tg.repositoryURI = refs.CloneURI\n\t}\n\treturn g\n}", "code_tokens": ["func", "gitCtxForRefs", "(", "refs", "prowapi", ".", "Refs", ",", "baseDir", "string", ",", "env", "[", "]", "string", ")", "gitCtx", "{", "g", ":=", "gitCtx", "{", "cloneDir", ":", "PathForRefs", "(", "baseDir", ",", "refs", ")", ",", "env", ":", "env", ",", "repositoryURI", ":", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "refs", ".", "Org", ",", "refs", ".", "Repo", ")", ",", "}", "\n", "if", "refs", ".", "CloneURI", "!=", "\"", "\"", "{", "g", ".", "repositoryURI", "=", "refs", ".", "CloneURI", "\n", "}", "\n", "return", "g", "\n", "}"], "docstring": "// gitCtxForRefs creates a gitCtx based on the provide refs and baseDir.", "docstring_tokens": ["gitCtxForRefs", "creates", "a", "gitCtx", "based", "on", "the", "provide", "refs", "and", "baseDir", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pod-utils/clone/clone.go#L99-L109", "partition": "test"}
{"repo": "aphistic/gomol", "path": "log_adapter.go", "func_name": "SetAttr", "original_string": "func (la *LogAdapter) SetAttr(key string, value interface{}) {\n\tla.attrs.SetAttr(key, value)\n}", "language": "go", "code": "func (la *LogAdapter) SetAttr(key string, value interface{}) {\n\tla.attrs.SetAttr(key, value)\n}", "code_tokens": ["func", "(", "la", "*", "LogAdapter", ")", "SetAttr", "(", "key", "string", ",", "value", "interface", "{", "}", ")", "{", "la", ".", "attrs", ".", "SetAttr", "(", "key", ",", "value", ")", "\n", "}"], "docstring": "// SetAttr sets the attribute key to value for this LogAdapter only", "docstring_tokens": ["SetAttr", "sets", "the", "attribute", "key", "to", "value", "for", "this", "LogAdapter", "only"], "sha": "1546845ba714699f76f484ad3af64cf0503064d1", "url": "https://github.com/aphistic/gomol/blob/1546845ba714699f76f484ad3af64cf0503064d1/log_adapter.go#L57-L59", "partition": "test"}
{"repo": "containers/image", "path": "oci/archive/oci_transport.go", "func_name": "createOCIRef", "original_string": "func createOCIRef(image string) (tempDirOCIRef, error) {\n\tdir, err := ioutil.TempDir(tmpdir.TemporaryDirectoryForBigFiles(), \"oci\")\n\tif err != nil {\n\t\treturn tempDirOCIRef{}, errors.Wrapf(err, \"error creating temp directory\")\n\t}\n\tociRef, err := ocilayout.NewReference(dir, image)\n\tif err != nil {\n\t\treturn tempDirOCIRef{}, err\n\t}\n\n\ttempDirRef := tempDirOCIRef{tempDirectory: dir, ociRefExtracted: ociRef}\n\treturn tempDirRef, nil\n}", "language": "go", "code": "func createOCIRef(image string) (tempDirOCIRef, error) {\n\tdir, err := ioutil.TempDir(tmpdir.TemporaryDirectoryForBigFiles(), \"oci\")\n\tif err != nil {\n\t\treturn tempDirOCIRef{}, errors.Wrapf(err, \"error creating temp directory\")\n\t}\n\tociRef, err := ocilayout.NewReference(dir, image)\n\tif err != nil {\n\t\treturn tempDirOCIRef{}, err\n\t}\n\n\ttempDirRef := tempDirOCIRef{tempDirectory: dir, ociRefExtracted: ociRef}\n\treturn tempDirRef, nil\n}", "code_tokens": ["func", "createOCIRef", "(", "image", "string", ")", "(", "tempDirOCIRef", ",", "error", ")", "{", "dir", ",", "err", ":=", "ioutil", ".", "TempDir", "(", "tmpdir", ".", "TemporaryDirectoryForBigFiles", "(", ")", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "tempDirOCIRef", "{", "}", ",", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "ociRef", ",", "err", ":=", "ocilayout", ".", "NewReference", "(", "dir", ",", "image", ")", "\n", "if", "err", "!=", "nil", "{", "return", "tempDirOCIRef", "{", "}", ",", "err", "\n", "}", "\n\n", "tempDirRef", ":=", "tempDirOCIRef", "{", "tempDirectory", ":", "dir", ",", "ociRefExtracted", ":", "ociRef", "}", "\n", "return", "tempDirRef", ",", "nil", "\n", "}"], "docstring": "// createOCIRef creates the oci reference of the image", "docstring_tokens": ["createOCIRef", "creates", "the", "oci", "reference", "of", "the", "image"], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/oci/archive/oci_transport.go#L162-L174", "partition": "test"}
{"repo": "profitbricks/profitbricks-sdk-go", "path": "server.go", "func_name": "AttachCdrom", "original_string": "func (c *Client) AttachCdrom(dcid string, srvid string, cdid string) (*Image, error) {\n\tdata := struct {\n\t\tID string `json:\"id,omitempty\"`\n\t}{\n\t\tcdid,\n\t}\n\turl := serverCdromColPath(dcid, srvid) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &Image{}\n\terr := c.client.Post(url, data, ret, http.StatusAccepted)\n\treturn ret, err\n}", "language": "go", "code": "func (c *Client) AttachCdrom(dcid string, srvid string, cdid string) (*Image, error) {\n\tdata := struct {\n\t\tID string `json:\"id,omitempty\"`\n\t}{\n\t\tcdid,\n\t}\n\turl := serverCdromColPath(dcid, srvid) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &Image{}\n\terr := c.client.Post(url, data, ret, http.StatusAccepted)\n\treturn ret, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "AttachCdrom", "(", "dcid", "string", ",", "srvid", "string", ",", "cdid", "string", ")", "(", "*", "Image", ",", "error", ")", "{", "data", ":=", "struct", "{", "ID", "string", "`json:\"id,omitempty\"`", "\n", "}", "{", "cdid", ",", "}", "\n", "url", ":=", "serverCdromColPath", "(", "dcid", ",", "srvid", ")", "+", "`?depth=`", "+", "c", ".", "client", ".", "depth", "+", "`&pretty=`", "+", "strconv", ".", "FormatBool", "(", "c", ".", "client", ".", "pretty", ")", "\n", "ret", ":=", "&", "Image", "{", "}", "\n", "err", ":=", "c", ".", "client", ".", "Post", "(", "url", ",", "data", ",", "ret", ",", "http", ".", "StatusAccepted", ")", "\n", "return", "ret", ",", "err", "\n", "}"], "docstring": "//AttachCdrom attaches a CD rom", "docstring_tokens": ["AttachCdrom", "attaches", "a", "CD", "rom"], "sha": "1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4", "url": "https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/server.go#L107-L117", "partition": "test"}
{"repo": "urandom/handler", "path": "response_wrapper.go", "func_name": "Hijack", "original_string": "func (w *ResponseWrapper) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\tif hijacker, ok := w.writer.(http.Hijacker); ok {\n\t\tc, rw, err := hijacker.Hijack()\n\n\t\tif err == nil {\n\t\t\tw.Hijacked = true\n\t\t}\n\n\t\treturn c, rw, err\n\t}\n\n\treturn nil, nil, errors.New(\"Wrapped ResponseWriter is not a Hijacker\")\n}", "language": "go", "code": "func (w *ResponseWrapper) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\tif hijacker, ok := w.writer.(http.Hijacker); ok {\n\t\tc, rw, err := hijacker.Hijack()\n\n\t\tif err == nil {\n\t\t\tw.Hijacked = true\n\t\t}\n\n\t\treturn c, rw, err\n\t}\n\n\treturn nil, nil, errors.New(\"Wrapped ResponseWriter is not a Hijacker\")\n}", "code_tokens": ["func", "(", "w", "*", "ResponseWrapper", ")", "Hijack", "(", ")", "(", "net", ".", "Conn", ",", "*", "bufio", ".", "ReadWriter", ",", "error", ")", "{", "if", "hijacker", ",", "ok", ":=", "w", ".", "writer", ".", "(", "http", ".", "Hijacker", ")", ";", "ok", "{", "c", ",", "rw", ",", "err", ":=", "hijacker", ".", "Hijack", "(", ")", "\n\n", "if", "err", "==", "nil", "{", "w", ".", "Hijacked", "=", "true", "\n", "}", "\n\n", "return", "c", ",", "rw", ",", "err", "\n", "}", "\n\n", "return", "nil", ",", "nil", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}"], "docstring": "// Hijack tries to use the original http.ResponseWriter for hijacking. If the\n// original writer doesn't implement http.Hijacker, it returns an error.", "docstring_tokens": ["Hijack", "tries", "to", "use", "the", "original", "http", ".", "ResponseWriter", "for", "hijacking", ".", "If", "the", "original", "writer", "doesn", "t", "implement", "http", ".", "Hijacker", "it", "returns", "an", "error", "."], "sha": "61508044a5569d1609521d81e81f6737567fd104", "url": "https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/response_wrapper.go#L31-L43", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/prstatus/prstatus.go", "func_name": "GetHeadContexts", "original_string": "func (da *DashboardAgent) GetHeadContexts(ghc githubClient, pr PullRequest) ([]Context, error) {\n\torg := string(pr.Repository.Owner.Login)\n\trepo := string(pr.Repository.Name)\n\tcombined, err := ghc.GetCombinedStatus(org, repo, string(pr.HeadRefOID))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get the combined status: %v\", err)\n\t}\n\tcontexts := make([]Context, 0, len(combined.Statuses))\n\tfor _, status := range combined.Statuses {\n\t\tcontexts = append(\n\t\t\tcontexts,\n\t\t\tContext{\n\t\t\t\tContext:     status.Context,\n\t\t\t\tDescription: status.Description,\n\t\t\t\tState:       strings.ToUpper(status.State),\n\t\t\t},\n\t\t)\n\t}\n\treturn contexts, nil\n}", "language": "go", "code": "func (da *DashboardAgent) GetHeadContexts(ghc githubClient, pr PullRequest) ([]Context, error) {\n\torg := string(pr.Repository.Owner.Login)\n\trepo := string(pr.Repository.Name)\n\tcombined, err := ghc.GetCombinedStatus(org, repo, string(pr.HeadRefOID))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get the combined status: %v\", err)\n\t}\n\tcontexts := make([]Context, 0, len(combined.Statuses))\n\tfor _, status := range combined.Statuses {\n\t\tcontexts = append(\n\t\t\tcontexts,\n\t\t\tContext{\n\t\t\t\tContext:     status.Context,\n\t\t\t\tDescription: status.Description,\n\t\t\t\tState:       strings.ToUpper(status.State),\n\t\t\t},\n\t\t)\n\t}\n\treturn contexts, nil\n}", "code_tokens": ["func", "(", "da", "*", "DashboardAgent", ")", "GetHeadContexts", "(", "ghc", "githubClient", ",", "pr", "PullRequest", ")", "(", "[", "]", "Context", ",", "error", ")", "{", "org", ":=", "string", "(", "pr", ".", "Repository", ".", "Owner", ".", "Login", ")", "\n", "repo", ":=", "string", "(", "pr", ".", "Repository", ".", "Name", ")", "\n", "combined", ",", "err", ":=", "ghc", ".", "GetCombinedStatus", "(", "org", ",", "repo", ",", "string", "(", "pr", ".", "HeadRefOID", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "contexts", ":=", "make", "(", "[", "]", "Context", ",", "0", ",", "len", "(", "combined", ".", "Statuses", ")", ")", "\n", "for", "_", ",", "status", ":=", "range", "combined", ".", "Statuses", "{", "contexts", "=", "append", "(", "contexts", ",", "Context", "{", "Context", ":", "status", ".", "Context", ",", "Description", ":", "status", ".", "Description", ",", "State", ":", "strings", ".", "ToUpper", "(", "status", ".", "State", ")", ",", "}", ",", ")", "\n", "}", "\n", "return", "contexts", ",", "nil", "\n", "}"], "docstring": "// GetHeadContexts returns the status checks' contexts of the head commit of the PR.", "docstring_tokens": ["GetHeadContexts", "returns", "the", "status", "checks", "contexts", "of", "the", "head", "commit", "of", "the", "PR", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/prstatus/prstatus.go#L320-L339", "partition": "test"}
{"repo": "rightscale/rsc", "path": "recorder/main.go", "func_name": "readAllAsync", "original_string": "func readAllAsync(f io.ReadCloser) (*[]byte, chan struct{}) {\n\tdone := make(chan struct{}, 1) // signal that the read is done\n\tvar buf []byte                 // placeholder buffer for the result\n\tgo func() {\n\t\tvar err error\n\t\tbuf, err = ioutil.ReadAll(f)\n\t\tif err != nil {\n\t\t\tbuf = make([]byte, 0)\n\t\t}\n\t\tf.Close()\n\t\tdone <- struct{}{}\n\t}()\n\treturn &buf, done\n}", "language": "go", "code": "func readAllAsync(f io.ReadCloser) (*[]byte, chan struct{}) {\n\tdone := make(chan struct{}, 1) // signal that the read is done\n\tvar buf []byte                 // placeholder buffer for the result\n\tgo func() {\n\t\tvar err error\n\t\tbuf, err = ioutil.ReadAll(f)\n\t\tif err != nil {\n\t\t\tbuf = make([]byte, 0)\n\t\t}\n\t\tf.Close()\n\t\tdone <- struct{}{}\n\t}()\n\treturn &buf, done\n}", "code_tokens": ["func", "readAllAsync", "(", "f", "io", ".", "ReadCloser", ")", "(", "*", "[", "]", "byte", ",", "chan", "struct", "{", "}", ")", "{", "done", ":=", "make", "(", "chan", "struct", "{", "}", ",", "1", ")", "// signal that the read is done", "\n", "var", "buf", "[", "]", "byte", "// placeholder buffer for the result", "\n", "go", "func", "(", ")", "{", "var", "err", "error", "\n", "buf", ",", "err", "=", "ioutil", ".", "ReadAll", "(", "f", ")", "\n", "if", "err", "!=", "nil", "{", "buf", "=", "make", "(", "[", "]", "byte", ",", "0", ")", "\n", "}", "\n", "f", ".", "Close", "(", ")", "\n", "done", "<-", "struct", "{", "}", "{", "}", "\n", "}", "(", ")", "\n", "return", "&", "buf", ",", "done", "\n", "}"], "docstring": "// Read file asynchronously", "docstring_tokens": ["Read", "file", "asynchronously"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/recorder/main.go#L104-L117", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "gossip.go", "func_name": "Flush", "original_string": "func (gs *gossipSenders) Flush() bool {\n\tsent := false\n\tgs.Lock()\n\tdefer gs.Unlock()\n\tfor _, sender := range gs.senders {\n\t\tsent = sender.Flush() || sent\n\t}\n\treturn sent\n}", "language": "go", "code": "func (gs *gossipSenders) Flush() bool {\n\tsent := false\n\tgs.Lock()\n\tdefer gs.Unlock()\n\tfor _, sender := range gs.senders {\n\t\tsent = sender.Flush() || sent\n\t}\n\treturn sent\n}", "code_tokens": ["func", "(", "gs", "*", "gossipSenders", ")", "Flush", "(", ")", "bool", "{", "sent", ":=", "false", "\n", "gs", ".", "Lock", "(", ")", "\n", "defer", "gs", ".", "Unlock", "(", ")", "\n", "for", "_", ",", "sender", ":=", "range", "gs", ".", "senders", "{", "sent", "=", "sender", ".", "Flush", "(", ")", "||", "sent", "\n", "}", "\n", "return", "sent", "\n", "}"], "docstring": "// Flush flushes all managed senders. Used for testing.", "docstring_tokens": ["Flush", "flushes", "all", "managed", "senders", ".", "Used", "for", "testing", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/gossip.go#L254-L262", "partition": "test"}
{"repo": "ant0ine/go-json-rest", "path": "rest/request.go", "func_name": "UrlFor", "original_string": "func (r *Request) UrlFor(path string, queryParams map[string][]string) *url.URL {\n\tbaseUrl := r.BaseUrl()\n\tbaseUrl.Path = path\n\tif queryParams != nil {\n\t\tquery := url.Values{}\n\t\tfor k, v := range queryParams {\n\t\t\tfor _, vv := range v {\n\t\t\t\tquery.Add(k, vv)\n\t\t\t}\n\t\t}\n\t\tbaseUrl.RawQuery = query.Encode()\n\t}\n\treturn baseUrl\n}", "language": "go", "code": "func (r *Request) UrlFor(path string, queryParams map[string][]string) *url.URL {\n\tbaseUrl := r.BaseUrl()\n\tbaseUrl.Path = path\n\tif queryParams != nil {\n\t\tquery := url.Values{}\n\t\tfor k, v := range queryParams {\n\t\t\tfor _, vv := range v {\n\t\t\t\tquery.Add(k, vv)\n\t\t\t}\n\t\t}\n\t\tbaseUrl.RawQuery = query.Encode()\n\t}\n\treturn baseUrl\n}", "code_tokens": ["func", "(", "r", "*", "Request", ")", "UrlFor", "(", "path", "string", ",", "queryParams", "map", "[", "string", "]", "[", "]", "string", ")", "*", "url", ".", "URL", "{", "baseUrl", ":=", "r", ".", "BaseUrl", "(", ")", "\n", "baseUrl", ".", "Path", "=", "path", "\n", "if", "queryParams", "!=", "nil", "{", "query", ":=", "url", ".", "Values", "{", "}", "\n", "for", "k", ",", "v", ":=", "range", "queryParams", "{", "for", "_", ",", "vv", ":=", "range", "v", "{", "query", ".", "Add", "(", "k", ",", "vv", ")", "\n", "}", "\n", "}", "\n", "baseUrl", ".", "RawQuery", "=", "query", ".", "Encode", "(", ")", "\n", "}", "\n", "return", "baseUrl", "\n", "}"], "docstring": "// UrlFor returns the URL object from UriBase with the Path set to path, and the query\n// string built with queryParams.", "docstring_tokens": ["UrlFor", "returns", "the", "URL", "object", "from", "UriBase", "with", "the", "Path", "set", "to", "path", "and", "the", "query", "string", "built", "with", "queryParams", "."], "sha": "ebb33769ae013bd5f518a8bac348c310dea768b8", "url": "https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/request.go#L77-L90", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pfs.go", "func_name": "ListObject", "original_string": "func (c APIClient) ListObject(f func(*pfs.Object) error) error {\n\tlistObjectClient, err := c.ObjectAPIClient.ListObjects(c.Ctx(), &pfs.ListObjectsRequest{})\n\tif err != nil {\n\t\treturn grpcutil.ScrubGRPC(err)\n\t}\n\tfor {\n\t\tobject, err := listObjectClient.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn grpcutil.ScrubGRPC(err)\n\t\t}\n\t\tif err := f(object); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}", "language": "go", "code": "func (c APIClient) ListObject(f func(*pfs.Object) error) error {\n\tlistObjectClient, err := c.ObjectAPIClient.ListObjects(c.Ctx(), &pfs.ListObjectsRequest{})\n\tif err != nil {\n\t\treturn grpcutil.ScrubGRPC(err)\n\t}\n\tfor {\n\t\tobject, err := listObjectClient.Recv()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn grpcutil.ScrubGRPC(err)\n\t\t}\n\t\tif err := f(object); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "c", "APIClient", ")", "ListObject", "(", "f", "func", "(", "*", "pfs", ".", "Object", ")", "error", ")", "error", "{", "listObjectClient", ",", "err", ":=", "c", ".", "ObjectAPIClient", ".", "ListObjects", "(", "c", ".", "Ctx", "(", ")", ",", "&", "pfs", ".", "ListObjectsRequest", "{", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}", "\n", "for", "{", "object", ",", "err", ":=", "listObjectClient", ".", "Recv", "(", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", "==", "io", ".", "EOF", "{", "return", "nil", "\n", "}", "\n", "return", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}", "\n", "if", "err", ":=", "f", "(", "object", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// ListObject lists objects stored in pfs.", "docstring_tokens": ["ListObject", "lists", "objects", "stored", "in", "pfs", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L697-L714", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pfs/pretty/pretty.go", "func_name": "PrintDetailedCommitInfo", "original_string": "func PrintDetailedCommitInfo(commitInfo *PrintableCommitInfo) error {\n\ttemplate, err := template.New(\"CommitInfo\").Funcs(funcMap).Parse(\n\t\t`Commit: {{.Commit.Repo.Name}}@{{.Commit.ID}}{{if .Branch}}\nOriginal Branch: {{.Branch.Name}}{{end}}{{if .Description}}\nDescription: {{.Description}}{{end}}{{if .ParentCommit}}\nParent: {{.ParentCommit.ID}}{{end}}{{if .FullTimestamps}}\nStarted: {{.Started}}{{else}}\nStarted: {{prettyAgo .Started}}{{end}}{{if .Finished}}{{if .FullTimestamps}}\nFinished: {{.Finished}}{{else}}\nFinished: {{prettyAgo .Finished}}{{end}}{{end}}\nSize: {{prettySize .SizeBytes}}{{if .Provenance}}\nProvenance: {{range .Provenance}} {{.Commit.Repo.Name}}@{{.Commit.ID}} ({{.Branch.Name}}) {{end}} {{end}}\n`)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = template.Execute(os.Stdout, commitInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "language": "go", "code": "func PrintDetailedCommitInfo(commitInfo *PrintableCommitInfo) error {\n\ttemplate, err := template.New(\"CommitInfo\").Funcs(funcMap).Parse(\n\t\t`Commit: {{.Commit.Repo.Name}}@{{.Commit.ID}}{{if .Branch}}\nOriginal Branch: {{.Branch.Name}}{{end}}{{if .Description}}\nDescription: {{.Description}}{{end}}{{if .ParentCommit}}\nParent: {{.ParentCommit.ID}}{{end}}{{if .FullTimestamps}}\nStarted: {{.Started}}{{else}}\nStarted: {{prettyAgo .Started}}{{end}}{{if .Finished}}{{if .FullTimestamps}}\nFinished: {{.Finished}}{{else}}\nFinished: {{prettyAgo .Finished}}{{end}}{{end}}\nSize: {{prettySize .SizeBytes}}{{if .Provenance}}\nProvenance: {{range .Provenance}} {{.Commit.Repo.Name}}@{{.Commit.ID}} ({{.Branch.Name}}) {{end}} {{end}}\n`)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = template.Execute(os.Stdout, commitInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "code_tokens": ["func", "PrintDetailedCommitInfo", "(", "commitInfo", "*", "PrintableCommitInfo", ")", "error", "{", "template", ",", "err", ":=", "template", ".", "New", "(", "\"", "\"", ")", ".", "Funcs", "(", "funcMap", ")", ".", "Parse", "(", "`Commit: {{.Commit.Repo.Name}}@{{.Commit.ID}}{{if .Branch}}\nOriginal Branch: {{.Branch.Name}}{{end}}{{if .Description}}\nDescription: {{.Description}}{{end}}{{if .ParentCommit}}\nParent: {{.ParentCommit.ID}}{{end}}{{if .FullTimestamps}}\nStarted: {{.Started}}{{else}}\nStarted: {{prettyAgo .Started}}{{end}}{{if .Finished}}{{if .FullTimestamps}}\nFinished: {{.Finished}}{{else}}\nFinished: {{prettyAgo .Finished}}{{end}}{{end}}\nSize: {{prettySize .SizeBytes}}{{if .Provenance}}\nProvenance: {{range .Provenance}} {{.Commit.Repo.Name}}@{{.Commit.ID}} ({{.Branch.Name}}) {{end}} {{end}}\n`", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "err", "=", "template", ".", "Execute", "(", "os", ".", "Stdout", ",", "commitInfo", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// PrintDetailedCommitInfo pretty-prints detailed commit info.", "docstring_tokens": ["PrintDetailedCommitInfo", "pretty", "-", "prints", "detailed", "commit", "info", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pfs/pretty/pretty.go#L145-L166", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "service/sync.go", "func_name": "start", "original_string": "func (b *bindSyncer) start() error {\n\tif b.started {\n\t\treturn errors.New(\"syncer already started\")\n\t}\n\tif b.appLister == nil {\n\t\treturn errors.New(\"must set app lister function\")\n\t}\n\tif b.interval == 0 {\n\t\tb.interval = 5 * time.Minute\n\t}\n\tb.shutdown = make(chan struct{}, 1)\n\tb.done = make(chan struct{})\n\tb.started = true\n\tlog.Debugf(\"[bind-syncer] starting. Running every %s.\\n\", b.interval)\n\tgo func(d time.Duration) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(d):\n\t\t\t\tstart := time.Now()\n\t\t\t\tlog.Debug(\"[bind-syncer] starting run\")\n\t\t\t\tapps, err := b.appLister()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Errorf(\"[bind-syncer] error listing apps: %v. Aborting sync.\", err)\n\t\t\t\t\tsyncDuration.Set(time.Since(start).Seconds())\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfor _, a := range apps {\n\t\t\t\t\terr = b.sync(a)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Errorf(\"[bind-syncer] error syncing app %q: %v\", a.GetName(), err)\n\t\t\t\t\t}\n\t\t\t\t\tif len(b.shutdown) > 0 {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlog.Debugf(\"[bind-syncer] finished running. Synced %d apps.\", len(apps))\n\t\t\t\td = b.interval\n\t\t\t\tsyncDuration.Set(time.Since(start).Seconds())\n\t\t\tcase <-b.shutdown:\n\t\t\t\tb.done <- struct{}{}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}(time.Millisecond * 100)\n\treturn nil\n}", "language": "go", "code": "func (b *bindSyncer) start() error {\n\tif b.started {\n\t\treturn errors.New(\"syncer already started\")\n\t}\n\tif b.appLister == nil {\n\t\treturn errors.New(\"must set app lister function\")\n\t}\n\tif b.interval == 0 {\n\t\tb.interval = 5 * time.Minute\n\t}\n\tb.shutdown = make(chan struct{}, 1)\n\tb.done = make(chan struct{})\n\tb.started = true\n\tlog.Debugf(\"[bind-syncer] starting. Running every %s.\\n\", b.interval)\n\tgo func(d time.Duration) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(d):\n\t\t\t\tstart := time.Now()\n\t\t\t\tlog.Debug(\"[bind-syncer] starting run\")\n\t\t\t\tapps, err := b.appLister()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Errorf(\"[bind-syncer] error listing apps: %v. Aborting sync.\", err)\n\t\t\t\t\tsyncDuration.Set(time.Since(start).Seconds())\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfor _, a := range apps {\n\t\t\t\t\terr = b.sync(a)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Errorf(\"[bind-syncer] error syncing app %q: %v\", a.GetName(), err)\n\t\t\t\t\t}\n\t\t\t\t\tif len(b.shutdown) > 0 {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlog.Debugf(\"[bind-syncer] finished running. Synced %d apps.\", len(apps))\n\t\t\t\td = b.interval\n\t\t\t\tsyncDuration.Set(time.Since(start).Seconds())\n\t\t\tcase <-b.shutdown:\n\t\t\t\tb.done <- struct{}{}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}(time.Millisecond * 100)\n\treturn nil\n}", "code_tokens": ["func", "(", "b", "*", "bindSyncer", ")", "start", "(", ")", "error", "{", "if", "b", ".", "started", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "b", ".", "appLister", "==", "nil", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "b", ".", "interval", "==", "0", "{", "b", ".", "interval", "=", "5", "*", "time", ".", "Minute", "\n", "}", "\n", "b", ".", "shutdown", "=", "make", "(", "chan", "struct", "{", "}", ",", "1", ")", "\n", "b", ".", "done", "=", "make", "(", "chan", "struct", "{", "}", ")", "\n", "b", ".", "started", "=", "true", "\n", "log", ".", "Debugf", "(", "\"", "\\n", "\"", ",", "b", ".", "interval", ")", "\n", "go", "func", "(", "d", "time", ".", "Duration", ")", "{", "for", "{", "select", "{", "case", "<-", "time", ".", "After", "(", "d", ")", ":", "start", ":=", "time", ".", "Now", "(", ")", "\n", "log", ".", "Debug", "(", "\"", "\"", ")", "\n", "apps", ",", "err", ":=", "b", ".", "appLister", "(", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "syncDuration", ".", "Set", "(", "time", ".", "Since", "(", "start", ")", ".", "Seconds", "(", ")", ")", "\n", "break", "\n", "}", "\n", "for", "_", ",", "a", ":=", "range", "apps", "{", "err", "=", "b", ".", "sync", "(", "a", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Errorf", "(", "\"", "\"", ",", "a", ".", "GetName", "(", ")", ",", "err", ")", "\n", "}", "\n", "if", "len", "(", "b", ".", "shutdown", ")", ">", "0", "{", "break", "\n", "}", "\n", "}", "\n", "log", ".", "Debugf", "(", "\"", "\"", ",", "len", "(", "apps", ")", ")", "\n", "d", "=", "b", ".", "interval", "\n", "syncDuration", ".", "Set", "(", "time", ".", "Since", "(", "start", ")", ".", "Seconds", "(", ")", ")", "\n", "case", "<-", "b", ".", "shutdown", ":", "b", ".", "done", "<-", "struct", "{", "}", "{", "}", "\n", "return", "\n", "}", "\n", "}", "\n", "}", "(", "time", ".", "Millisecond", "*", "100", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// start starts the sync process on a different goroutine", "docstring_tokens": ["start", "starts", "the", "sync", "process", "on", "a", "different", "goroutine"], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/service/sync.go#L71-L116", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/connection.go", "func_name": "httpsLXD", "original_string": "func httpsLXD(url string, args *ConnectionArgs) (ContainerServer, error) {\n\t// Use empty args if not specified\n\tif args == nil {\n\t\targs = &ConnectionArgs{}\n\t}\n\n\t// Initialize the client struct\n\tserver := ProtocolLXD{\n\t\thttpCertificate:  args.TLSServerCert,\n\t\thttpHost:         url,\n\t\thttpProtocol:     \"https\",\n\t\thttpUserAgent:    args.UserAgent,\n\t\tbakeryInteractor: args.AuthInteractor,\n\t}\n\tif args.AuthType == \"candid\" {\n\t\tserver.RequireAuthenticated(true)\n\t}\n\n\t// Setup the HTTP client\n\thttpClient, err := tlsHTTPClient(args.HTTPClient, args.TLSClientCert, args.TLSClientKey, args.TLSCA, args.TLSServerCert, args.InsecureSkipVerify, args.Proxy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif args.CookieJar != nil {\n\t\thttpClient.Jar = args.CookieJar\n\t}\n\n\tserver.http = httpClient\n\tif args.AuthType == \"candid\" {\n\t\tserver.setupBakeryClient()\n\t}\n\n\t// Test the connection and seed the server information\n\tif !args.SkipGetServer {\n\t\t_, _, err := server.GetServer()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn &server, nil\n}", "language": "go", "code": "func httpsLXD(url string, args *ConnectionArgs) (ContainerServer, error) {\n\t// Use empty args if not specified\n\tif args == nil {\n\t\targs = &ConnectionArgs{}\n\t}\n\n\t// Initialize the client struct\n\tserver := ProtocolLXD{\n\t\thttpCertificate:  args.TLSServerCert,\n\t\thttpHost:         url,\n\t\thttpProtocol:     \"https\",\n\t\thttpUserAgent:    args.UserAgent,\n\t\tbakeryInteractor: args.AuthInteractor,\n\t}\n\tif args.AuthType == \"candid\" {\n\t\tserver.RequireAuthenticated(true)\n\t}\n\n\t// Setup the HTTP client\n\thttpClient, err := tlsHTTPClient(args.HTTPClient, args.TLSClientCert, args.TLSClientKey, args.TLSCA, args.TLSServerCert, args.InsecureSkipVerify, args.Proxy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif args.CookieJar != nil {\n\t\thttpClient.Jar = args.CookieJar\n\t}\n\n\tserver.http = httpClient\n\tif args.AuthType == \"candid\" {\n\t\tserver.setupBakeryClient()\n\t}\n\n\t// Test the connection and seed the server information\n\tif !args.SkipGetServer {\n\t\t_, _, err := server.GetServer()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn &server, nil\n}", "code_tokens": ["func", "httpsLXD", "(", "url", "string", ",", "args", "*", "ConnectionArgs", ")", "(", "ContainerServer", ",", "error", ")", "{", "// Use empty args if not specified", "if", "args", "==", "nil", "{", "args", "=", "&", "ConnectionArgs", "{", "}", "\n", "}", "\n\n", "// Initialize the client struct", "server", ":=", "ProtocolLXD", "{", "httpCertificate", ":", "args", ".", "TLSServerCert", ",", "httpHost", ":", "url", ",", "httpProtocol", ":", "\"", "\"", ",", "httpUserAgent", ":", "args", ".", "UserAgent", ",", "bakeryInteractor", ":", "args", ".", "AuthInteractor", ",", "}", "\n", "if", "args", ".", "AuthType", "==", "\"", "\"", "{", "server", ".", "RequireAuthenticated", "(", "true", ")", "\n", "}", "\n\n", "// Setup the HTTP client", "httpClient", ",", "err", ":=", "tlsHTTPClient", "(", "args", ".", "HTTPClient", ",", "args", ".", "TLSClientCert", ",", "args", ".", "TLSClientKey", ",", "args", ".", "TLSCA", ",", "args", ".", "TLSServerCert", ",", "args", ".", "InsecureSkipVerify", ",", "args", ".", "Proxy", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "if", "args", ".", "CookieJar", "!=", "nil", "{", "httpClient", ".", "Jar", "=", "args", ".", "CookieJar", "\n", "}", "\n\n", "server", ".", "http", "=", "httpClient", "\n", "if", "args", ".", "AuthType", "==", "\"", "\"", "{", "server", ".", "setupBakeryClient", "(", ")", "\n", "}", "\n\n", "// Test the connection and seed the server information", "if", "!", "args", ".", "SkipGetServer", "{", "_", ",", "_", ",", "err", ":=", "server", ".", "GetServer", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "}", "\n", "return", "&", "server", ",", "nil", "\n", "}"], "docstring": "// Internal function called by ConnectLXD and ConnectPublicLXD", "docstring_tokens": ["Internal", "function", "called", "by", "ConnectLXD", "and", "ConnectPublicLXD"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/connection.go#L173-L214", "partition": "test"}
{"repo": "omniscale/go-mapnik", "path": "mapnik.go", "func_name": "SRS", "original_string": "func (m *Map) SRS() string {\n\treturn C.GoString(C.mapnik_map_get_srs(m.m))\n}", "language": "go", "code": "func (m *Map) SRS() string {\n\treturn C.GoString(C.mapnik_map_get_srs(m.m))\n}", "code_tokens": ["func", "(", "m", "*", "Map", ")", "SRS", "(", ")", "string", "{", "return", "C", ".", "GoString", "(", "C", ".", "mapnik_map_get_srs", "(", "m", ".", "m", ")", ")", "\n", "}"], "docstring": "// SRS returns the projection of the map.", "docstring_tokens": ["SRS", "returns", "the", "projection", "of", "the", "map", "."], "sha": "710dfcc5e486e5760d0a5c46be909d91968e1ffb", "url": "https://github.com/omniscale/go-mapnik/blob/710dfcc5e486e5760d0a5c46be909d91968e1ffb/mapnik.go#L146-L148", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewOfferEntryExt", "original_string": "func NewOfferEntryExt(v int32, value interface{}) (result OfferEntryExt, err error) {\n\tresult.V = v\n\tswitch int32(v) {\n\tcase 0:\n\t\t// void\n\t}\n\treturn\n}", "language": "go", "code": "func NewOfferEntryExt(v int32, value interface{}) (result OfferEntryExt, err error) {\n\tresult.V = v\n\tswitch int32(v) {\n\tcase 0:\n\t\t// void\n\t}\n\treturn\n}", "code_tokens": ["func", "NewOfferEntryExt", "(", "v", "int32", ",", "value", "interface", "{", "}", ")", "(", "result", "OfferEntryExt", ",", "err", "error", ")", "{", "result", ".", "V", "=", "v", "\n", "switch", "int32", "(", "v", ")", "{", "case", "0", ":", "// void", "}", "\n", "return", "\n", "}"], "docstring": "// NewOfferEntryExt creates a new  OfferEntryExt.", "docstring_tokens": ["NewOfferEntryExt", "creates", "a", "new", "OfferEntryExt", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L909-L916", "partition": "test"}
{"repo": "ant0ine/go-json-rest", "path": "rest/access_log_json.go", "func_name": "MiddlewareFunc", "original_string": "func (mw *AccessLogJsonMiddleware) MiddlewareFunc(h HandlerFunc) HandlerFunc {\n\n\t// set the default Logger\n\tif mw.Logger == nil {\n\t\tmw.Logger = log.New(os.Stderr, \"\", 0)\n\t}\n\n\treturn func(w ResponseWriter, r *Request) {\n\n\t\t// call the handler\n\t\th(w, r)\n\n\t\tmw.Logger.Printf(\"%s\", makeAccessLogJsonRecord(r).asJson())\n\t}\n}", "language": "go", "code": "func (mw *AccessLogJsonMiddleware) MiddlewareFunc(h HandlerFunc) HandlerFunc {\n\n\t// set the default Logger\n\tif mw.Logger == nil {\n\t\tmw.Logger = log.New(os.Stderr, \"\", 0)\n\t}\n\n\treturn func(w ResponseWriter, r *Request) {\n\n\t\t// call the handler\n\t\th(w, r)\n\n\t\tmw.Logger.Printf(\"%s\", makeAccessLogJsonRecord(r).asJson())\n\t}\n}", "code_tokens": ["func", "(", "mw", "*", "AccessLogJsonMiddleware", ")", "MiddlewareFunc", "(", "h", "HandlerFunc", ")", "HandlerFunc", "{", "// set the default Logger", "if", "mw", ".", "Logger", "==", "nil", "{", "mw", ".", "Logger", "=", "log", ".", "New", "(", "os", ".", "Stderr", ",", "\"", "\"", ",", "0", ")", "\n", "}", "\n\n", "return", "func", "(", "w", "ResponseWriter", ",", "r", "*", "Request", ")", "{", "// call the handler", "h", "(", "w", ",", "r", ")", "\n\n", "mw", ".", "Logger", ".", "Printf", "(", "\"", "\"", ",", "makeAccessLogJsonRecord", "(", "r", ")", ".", "asJson", "(", ")", ")", "\n", "}", "\n", "}"], "docstring": "// MiddlewareFunc makes AccessLogJsonMiddleware implement the Middleware interface.", "docstring_tokens": ["MiddlewareFunc", "makes", "AccessLogJsonMiddleware", "implement", "the", "Middleware", "interface", "."], "sha": "ebb33769ae013bd5f518a8bac348c310dea768b8", "url": "https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/access_log_json.go#L21-L35", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/v2store/node.go", "func_name": "Add", "original_string": "func (n *node) Add(child *node) *v2error.Error {\n\tif !n.IsDir() {\n\t\treturn v2error.NewError(v2error.EcodeNotDir, \"\", n.store.CurrentIndex)\n\t}\n\n\t_, name := path.Split(child.Path)\n\n\tif _, ok := n.Children[name]; ok {\n\t\treturn v2error.NewError(v2error.EcodeNodeExist, \"\", n.store.CurrentIndex)\n\t}\n\n\tn.Children[name] = child\n\n\treturn nil\n}", "language": "go", "code": "func (n *node) Add(child *node) *v2error.Error {\n\tif !n.IsDir() {\n\t\treturn v2error.NewError(v2error.EcodeNotDir, \"\", n.store.CurrentIndex)\n\t}\n\n\t_, name := path.Split(child.Path)\n\n\tif _, ok := n.Children[name]; ok {\n\t\treturn v2error.NewError(v2error.EcodeNodeExist, \"\", n.store.CurrentIndex)\n\t}\n\n\tn.Children[name] = child\n\n\treturn nil\n}", "code_tokens": ["func", "(", "n", "*", "node", ")", "Add", "(", "child", "*", "node", ")", "*", "v2error", ".", "Error", "{", "if", "!", "n", ".", "IsDir", "(", ")", "{", "return", "v2error", ".", "NewError", "(", "v2error", ".", "EcodeNotDir", ",", "\"", "\"", ",", "n", ".", "store", ".", "CurrentIndex", ")", "\n", "}", "\n\n", "_", ",", "name", ":=", "path", ".", "Split", "(", "child", ".", "Path", ")", "\n\n", "if", "_", ",", "ok", ":=", "n", ".", "Children", "[", "name", "]", ";", "ok", "{", "return", "v2error", ".", "NewError", "(", "v2error", ".", "EcodeNodeExist", ",", "\"", "\"", ",", "n", ".", "store", ".", "CurrentIndex", ")", "\n", "}", "\n\n", "n", ".", "Children", "[", "name", "]", "=", "child", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Add function adds a node to the receiver node.\n// If the receiver is not a directory, a \"Not A Directory\" error will be returned.\n// If there is an existing node with the same name under the directory, a \"Already Exist\"\n// error will be returned", "docstring_tokens": ["Add", "function", "adds", "a", "node", "to", "the", "receiver", "node", ".", "If", "the", "receiver", "is", "not", "a", "directory", "a", "Not", "A", "Directory", "error", "will", "be", "returned", ".", "If", "there", "is", "an", "existing", "node", "with", "the", "same", "name", "under", "the", "directory", "a", "Already", "Exist", "error", "will", "be", "returned"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2store/node.go#L189-L203", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/server_access_control.go", "func_name": "OriginAllowed", "original_string": "func (ac *AccessController) OriginAllowed(origin string) bool {\n\tac.corsMu.RLock()\n\tdefer ac.corsMu.RUnlock()\n\tif len(ac.CORS) == 0 { // allow all\n\t\treturn true\n\t}\n\t_, ok := ac.CORS[\"*\"]\n\tif ok {\n\t\treturn true\n\t}\n\t_, ok = ac.CORS[origin]\n\treturn ok\n}", "language": "go", "code": "func (ac *AccessController) OriginAllowed(origin string) bool {\n\tac.corsMu.RLock()\n\tdefer ac.corsMu.RUnlock()\n\tif len(ac.CORS) == 0 { // allow all\n\t\treturn true\n\t}\n\t_, ok := ac.CORS[\"*\"]\n\tif ok {\n\t\treturn true\n\t}\n\t_, ok = ac.CORS[origin]\n\treturn ok\n}", "code_tokens": ["func", "(", "ac", "*", "AccessController", ")", "OriginAllowed", "(", "origin", "string", ")", "bool", "{", "ac", ".", "corsMu", ".", "RLock", "(", ")", "\n", "defer", "ac", ".", "corsMu", ".", "RUnlock", "(", ")", "\n", "if", "len", "(", "ac", ".", "CORS", ")", "==", "0", "{", "// allow all", "return", "true", "\n", "}", "\n", "_", ",", "ok", ":=", "ac", ".", "CORS", "[", "\"", "\"", "]", "\n", "if", "ok", "{", "return", "true", "\n", "}", "\n", "_", ",", "ok", "=", "ac", ".", "CORS", "[", "origin", "]", "\n", "return", "ok", "\n", "}"], "docstring": "// OriginAllowed determines whether the server will allow a given CORS origin.\n// If CORS is empty, allow all.", "docstring_tokens": ["OriginAllowed", "determines", "whether", "the", "server", "will", "allow", "a", "given", "CORS", "origin", ".", "If", "CORS", "is", "empty", "allow", "all", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/server_access_control.go#L37-L49", "partition": "test"}
{"repo": "golang/appengine", "path": "xmpp/xmpp.go", "func_name": "Send", "original_string": "func (m *Message) Send(c context.Context) error {\n\treq := &pb.XmppMessageRequest{\n\t\tJid:    m.To,\n\t\tBody:   &m.Body,\n\t\tRawXml: &m.RawXML,\n\t}\n\tif m.Type != \"\" && m.Type != \"chat\" {\n\t\treq.Type = &m.Type\n\t}\n\tif m.Sender != \"\" {\n\t\treq.FromJid = &m.Sender\n\t}\n\tres := &pb.XmppMessageResponse{}\n\tif err := internal.Call(c, \"xmpp\", \"SendMessage\", req, res); err != nil {\n\t\treturn err\n\t}\n\n\tif len(res.Status) != len(req.Jid) {\n\t\treturn fmt.Errorf(\"xmpp: sent message to %d JIDs, but only got %d statuses back\", len(req.Jid), len(res.Status))\n\t}\n\tme, any := make(appengine.MultiError, len(req.Jid)), false\n\tfor i, st := range res.Status {\n\t\tif st != pb.XmppMessageResponse_NO_ERROR {\n\t\t\tme[i] = errors.New(st.String())\n\t\t\tany = true\n\t\t}\n\t}\n\tif any {\n\t\treturn me\n\t}\n\treturn nil\n}", "language": "go", "code": "func (m *Message) Send(c context.Context) error {\n\treq := &pb.XmppMessageRequest{\n\t\tJid:    m.To,\n\t\tBody:   &m.Body,\n\t\tRawXml: &m.RawXML,\n\t}\n\tif m.Type != \"\" && m.Type != \"chat\" {\n\t\treq.Type = &m.Type\n\t}\n\tif m.Sender != \"\" {\n\t\treq.FromJid = &m.Sender\n\t}\n\tres := &pb.XmppMessageResponse{}\n\tif err := internal.Call(c, \"xmpp\", \"SendMessage\", req, res); err != nil {\n\t\treturn err\n\t}\n\n\tif len(res.Status) != len(req.Jid) {\n\t\treturn fmt.Errorf(\"xmpp: sent message to %d JIDs, but only got %d statuses back\", len(req.Jid), len(res.Status))\n\t}\n\tme, any := make(appengine.MultiError, len(req.Jid)), false\n\tfor i, st := range res.Status {\n\t\tif st != pb.XmppMessageResponse_NO_ERROR {\n\t\t\tme[i] = errors.New(st.String())\n\t\t\tany = true\n\t\t}\n\t}\n\tif any {\n\t\treturn me\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "m", "*", "Message", ")", "Send", "(", "c", "context", ".", "Context", ")", "error", "{", "req", ":=", "&", "pb", ".", "XmppMessageRequest", "{", "Jid", ":", "m", ".", "To", ",", "Body", ":", "&", "m", ".", "Body", ",", "RawXml", ":", "&", "m", ".", "RawXML", ",", "}", "\n", "if", "m", ".", "Type", "!=", "\"", "\"", "&&", "m", ".", "Type", "!=", "\"", "\"", "{", "req", ".", "Type", "=", "&", "m", ".", "Type", "\n", "}", "\n", "if", "m", ".", "Sender", "!=", "\"", "\"", "{", "req", ".", "FromJid", "=", "&", "m", ".", "Sender", "\n", "}", "\n", "res", ":=", "&", "pb", ".", "XmppMessageResponse", "{", "}", "\n", "if", "err", ":=", "internal", ".", "Call", "(", "c", ",", "\"", "\"", ",", "\"", "\"", ",", "req", ",", "res", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "len", "(", "res", ".", "Status", ")", "!=", "len", "(", "req", ".", "Jid", ")", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "len", "(", "req", ".", "Jid", ")", ",", "len", "(", "res", ".", "Status", ")", ")", "\n", "}", "\n", "me", ",", "any", ":=", "make", "(", "appengine", ".", "MultiError", ",", "len", "(", "req", ".", "Jid", ")", ")", ",", "false", "\n", "for", "i", ",", "st", ":=", "range", "res", ".", "Status", "{", "if", "st", "!=", "pb", ".", "XmppMessageResponse_NO_ERROR", "{", "me", "[", "i", "]", "=", "errors", ".", "New", "(", "st", ".", "String", "(", ")", ")", "\n", "any", "=", "true", "\n", "}", "\n", "}", "\n", "if", "any", "{", "return", "me", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// Send sends a message.\n// If any failures occur with specific recipients, the error will be an appengine.MultiError.", "docstring_tokens": ["Send", "sends", "a", "message", ".", "If", "any", "failures", "occur", "with", "specific", "recipients", "the", "error", "will", "be", "an", "appengine", ".", "MultiError", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/xmpp/xmpp.go#L98-L129", "partition": "test"}
{"repo": "onsi/gomega", "path": "ghttp/handlers.go", "func_name": "VerifyBasicAuth", "original_string": "func VerifyBasicAuth(username string, password string) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, req *http.Request) {\n\t\tauth := req.Header.Get(\"Authorization\")\n\t\tExpect(auth).ShouldNot(Equal(\"\"), \"Authorization header must be specified\")\n\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tExpect(err).ShouldNot(HaveOccurred())\n\n\t\tExpect(string(decoded)).Should(Equal(fmt.Sprintf(\"%s:%s\", username, password)), \"Authorization mismatch\")\n\t}\n}", "language": "go", "code": "func VerifyBasicAuth(username string, password string) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, req *http.Request) {\n\t\tauth := req.Header.Get(\"Authorization\")\n\t\tExpect(auth).ShouldNot(Equal(\"\"), \"Authorization header must be specified\")\n\n\t\tdecoded, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tExpect(err).ShouldNot(HaveOccurred())\n\n\t\tExpect(string(decoded)).Should(Equal(fmt.Sprintf(\"%s:%s\", username, password)), \"Authorization mismatch\")\n\t}\n}", "code_tokens": ["func", "VerifyBasicAuth", "(", "username", "string", ",", "password", "string", ")", "http", ".", "HandlerFunc", "{", "return", "func", "(", "w", "http", ".", "ResponseWriter", ",", "req", "*", "http", ".", "Request", ")", "{", "auth", ":=", "req", ".", "Header", ".", "Get", "(", "\"", "\"", ")", "\n", "Expect", "(", "auth", ")", ".", "ShouldNot", "(", "Equal", "(", "\"", "\"", ")", ",", "\"", "\"", ")", "\n\n", "decoded", ",", "err", ":=", "base64", ".", "StdEncoding", ".", "DecodeString", "(", "auth", "[", "6", ":", "]", ")", "\n", "Expect", "(", "err", ")", ".", "ShouldNot", "(", "HaveOccurred", "(", ")", ")", "\n\n", "Expect", "(", "string", "(", "decoded", ")", ")", ".", "Should", "(", "Equal", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "username", ",", "password", ")", ")", ",", "\"", "\"", ")", "\n", "}", "\n", "}"], "docstring": "//VerifyBasicAuth returns a handler that verifies the request contains a BasicAuth Authorization header\n//matching the passed in username and password", "docstring_tokens": ["VerifyBasicAuth", "returns", "a", "handler", "that", "verifies", "the", "request", "contains", "a", "BasicAuth", "Authorization", "header", "matching", "the", "passed", "in", "username", "and", "password"], "sha": "f0e010e04c08c48a875f83d17df37b04eb3a985b", "url": "https://github.com/onsi/gomega/blob/f0e010e04c08c48a875f83d17df37b04eb3a985b/ghttp/handlers.go#L69-L79", "partition": "test"}
{"repo": "janos/web", "path": "servers/http/http.go", "func_name": "ServeTCP", "original_string": "func (s *Server) ServeTCP(ln net.Listener) (err error) {\n\tif l, ok := ln.(*net.TCPListener); ok {\n\t\tln = tcpKeepAliveListener{TCPListener: l}\n\t}\n\tif s.TLSConfig != nil {\n\t\tln = tls.NewListener(ln, s.TLSConfig)\n\t}\n\n\terr = s.Server.Serve(ln)\n\tif err == http.ErrServerClosed {\n\t\treturn nil\n\t}\n\treturn\n}", "language": "go", "code": "func (s *Server) ServeTCP(ln net.Listener) (err error) {\n\tif l, ok := ln.(*net.TCPListener); ok {\n\t\tln = tcpKeepAliveListener{TCPListener: l}\n\t}\n\tif s.TLSConfig != nil {\n\t\tln = tls.NewListener(ln, s.TLSConfig)\n\t}\n\n\terr = s.Server.Serve(ln)\n\tif err == http.ErrServerClosed {\n\t\treturn nil\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "s", "*", "Server", ")", "ServeTCP", "(", "ln", "net", ".", "Listener", ")", "(", "err", "error", ")", "{", "if", "l", ",", "ok", ":=", "ln", ".", "(", "*", "net", ".", "TCPListener", ")", ";", "ok", "{", "ln", "=", "tcpKeepAliveListener", "{", "TCPListener", ":", "l", "}", "\n", "}", "\n", "if", "s", ".", "TLSConfig", "!=", "nil", "{", "ln", "=", "tls", ".", "NewListener", "(", "ln", ",", "s", ".", "TLSConfig", ")", "\n", "}", "\n\n", "err", "=", "s", ".", "Server", ".", "Serve", "(", "ln", ")", "\n", "if", "err", "==", "http", ".", "ErrServerClosed", "{", "return", "nil", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// ServeTCP executes http.Server.Serve method.\n// If the provided listener is net.TCPListener, keep alive\n// will be enabled. If server is configured with TLS,\n// a tls.Listener will be created with provided listener.", "docstring_tokens": ["ServeTCP", "executes", "http", ".", "Server", ".", "Serve", "method", ".", "If", "the", "provided", "listener", "is", "net", ".", "TCPListener", "keep", "alive", "will", "be", "enabled", ".", "If", "server", "is", "configured", "with", "TLS", "a", "tls", ".", "Listener", "will", "be", "created", "with", "provided", "listener", "."], "sha": "0fb0203103deb84424510a8d5166ac00700f2b0e", "url": "https://github.com/janos/web/blob/0fb0203103deb84424510a8d5166ac00700f2b0e/servers/http/http.go#L61-L74", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "grpc/ttnctx/context.go", "func_name": "IDFromMetadata", "original_string": "func IDFromMetadata(md metadata.MD) (string, error) {\n\tid, ok := md[\"id\"]\n\tif !ok || len(id) == 0 {\n\t\treturn \"\", ErrNoID\n\t}\n\treturn id[0], nil\n}", "language": "go", "code": "func IDFromMetadata(md metadata.MD) (string, error) {\n\tid, ok := md[\"id\"]\n\tif !ok || len(id) == 0 {\n\t\treturn \"\", ErrNoID\n\t}\n\treturn id[0], nil\n}", "code_tokens": ["func", "IDFromMetadata", "(", "md", "metadata", ".", "MD", ")", "(", "string", ",", "error", ")", "{", "id", ",", "ok", ":=", "md", "[", "\"", "\"", "]", "\n", "if", "!", "ok", "||", "len", "(", "id", ")", "==", "0", "{", "return", "\"", "\"", ",", "ErrNoID", "\n", "}", "\n", "return", "id", "[", "0", "]", ",", "nil", "\n", "}"], "docstring": "// IDFromMetadata gets the key from the metadata or returns ErrNoID", "docstring_tokens": ["IDFromMetadata", "gets", "the", "key", "from", "the", "metadata", "or", "returns", "ErrNoID"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/grpc/ttnctx/context.go#L73-L79", "partition": "test"}
{"repo": "256dpi/fire", "path": "group.go", "func_name": "Endpoint", "original_string": "func (g *Group) Endpoint(prefix string) http.Handler {\n\t// trim prefix\n\tprefix = strings.Trim(prefix, \"/\")\n\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// create tracer\n\t\ttracer := NewTracerFromRequest(r, \"fire/Group.Endpoint\")\n\t\tdefer tracer.Finish(true)\n\n\t\t// continue any previous aborts\n\t\tdefer stack.Resume(func(err error) {\n\t\t\t// directly write jsonapi errors\n\t\t\tif jsonapiError, ok := err.(*jsonapi.Error); ok {\n\t\t\t\t_ = jsonapi.WriteError(w, jsonapiError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// set critical error on last span\n\t\t\ttracer.Tag(\"error\", true)\n\t\t\ttracer.Log(\"error\", err.Error())\n\t\t\ttracer.Log(\"stack\", stack.Trace())\n\n\t\t\t// report critical errors if possible\n\t\t\tif g.Reporter != nil {\n\t\t\t\tg.Reporter(err)\n\t\t\t}\n\n\t\t\t// ignore errors caused by writing critical errors\n\t\t\t_ = jsonapi.WriteError(w, jsonapi.InternalServerError(\"\"))\n\t\t})\n\n\t\t// trim path\n\t\tpath := strings.Trim(r.URL.Path, \"/\")\n\t\tpath = strings.TrimPrefix(path, prefix)\n\t\tpath = strings.Trim(path, \"/\")\n\n\t\t// check path\n\t\tif path == \"\" {\n\t\t\tstack.Abort(jsonapi.NotFound(\"resource not found\"))\n\t\t}\n\n\t\t// split path\n\t\ts := strings.Split(path, \"/\")\n\n\t\t// prepare context\n\t\tctx := &Context{\n\t\t\tData:           Map{},\n\t\t\tHTTPRequest:    r,\n\t\t\tResponseWriter: w,\n\t\t\tGroup:          g,\n\t\t\tTracer:         tracer,\n\t\t}\n\n\t\t// get controller\n\t\tcontroller, ok := g.controllers[s[0]]\n\t\tif ok {\n\t\t\t// set controller\n\t\t\tctx.Controller = controller\n\n\t\t\t// call controller with context\n\t\t\tcontroller.generalHandler(prefix, ctx)\n\n\t\t\treturn\n\t\t}\n\n\t\t// get action\n\t\taction, ok := g.actions[s[0]]\n\t\tif ok {\n\t\t\t// check if action is allowed\n\t\t\tif Contains(action.Action.Methods, r.Method) {\n\t\t\t\t// check if action matches the context\n\t\t\t\tif action.Action.Callback.Matcher(ctx) {\n\t\t\t\t\t// run authorizers and handle errors\n\t\t\t\t\tfor _, cb := range action.Authorizers {\n\t\t\t\t\t\t// check if callback should be run\n\t\t\t\t\t\tif !cb.Matcher(ctx) {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// call callback\n\t\t\t\t\t\terr := cb.Handler(ctx)\n\t\t\t\t\t\tif IsSafe(err) {\n\t\t\t\t\t\t\tstack.Abort(&jsonapi.Error{\n\t\t\t\t\t\t\t\tStatus: http.StatusUnauthorized,\n\t\t\t\t\t\t\t\tDetail: err.Error(),\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t} else if err != nil {\n\t\t\t\t\t\t\tstack.Abort(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// limit request body size\n\t\t\t\t\tLimitBody(ctx.ResponseWriter, ctx.HTTPRequest, int64(action.Action.BodyLimit))\n\n\t\t\t\t\t// call action with context\n\t\t\t\t\tstack.AbortIf(action.Action.Callback.Handler(ctx))\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// otherwise return error\n\t\tstack.Abort(jsonapi.NotFound(\"resource not found\"))\n\t})\n}", "language": "go", "code": "func (g *Group) Endpoint(prefix string) http.Handler {\n\t// trim prefix\n\tprefix = strings.Trim(prefix, \"/\")\n\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// create tracer\n\t\ttracer := NewTracerFromRequest(r, \"fire/Group.Endpoint\")\n\t\tdefer tracer.Finish(true)\n\n\t\t// continue any previous aborts\n\t\tdefer stack.Resume(func(err error) {\n\t\t\t// directly write jsonapi errors\n\t\t\tif jsonapiError, ok := err.(*jsonapi.Error); ok {\n\t\t\t\t_ = jsonapi.WriteError(w, jsonapiError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// set critical error on last span\n\t\t\ttracer.Tag(\"error\", true)\n\t\t\ttracer.Log(\"error\", err.Error())\n\t\t\ttracer.Log(\"stack\", stack.Trace())\n\n\t\t\t// report critical errors if possible\n\t\t\tif g.Reporter != nil {\n\t\t\t\tg.Reporter(err)\n\t\t\t}\n\n\t\t\t// ignore errors caused by writing critical errors\n\t\t\t_ = jsonapi.WriteError(w, jsonapi.InternalServerError(\"\"))\n\t\t})\n\n\t\t// trim path\n\t\tpath := strings.Trim(r.URL.Path, \"/\")\n\t\tpath = strings.TrimPrefix(path, prefix)\n\t\tpath = strings.Trim(path, \"/\")\n\n\t\t// check path\n\t\tif path == \"\" {\n\t\t\tstack.Abort(jsonapi.NotFound(\"resource not found\"))\n\t\t}\n\n\t\t// split path\n\t\ts := strings.Split(path, \"/\")\n\n\t\t// prepare context\n\t\tctx := &Context{\n\t\t\tData:           Map{},\n\t\t\tHTTPRequest:    r,\n\t\t\tResponseWriter: w,\n\t\t\tGroup:          g,\n\t\t\tTracer:         tracer,\n\t\t}\n\n\t\t// get controller\n\t\tcontroller, ok := g.controllers[s[0]]\n\t\tif ok {\n\t\t\t// set controller\n\t\t\tctx.Controller = controller\n\n\t\t\t// call controller with context\n\t\t\tcontroller.generalHandler(prefix, ctx)\n\n\t\t\treturn\n\t\t}\n\n\t\t// get action\n\t\taction, ok := g.actions[s[0]]\n\t\tif ok {\n\t\t\t// check if action is allowed\n\t\t\tif Contains(action.Action.Methods, r.Method) {\n\t\t\t\t// check if action matches the context\n\t\t\t\tif action.Action.Callback.Matcher(ctx) {\n\t\t\t\t\t// run authorizers and handle errors\n\t\t\t\t\tfor _, cb := range action.Authorizers {\n\t\t\t\t\t\t// check if callback should be run\n\t\t\t\t\t\tif !cb.Matcher(ctx) {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// call callback\n\t\t\t\t\t\terr := cb.Handler(ctx)\n\t\t\t\t\t\tif IsSafe(err) {\n\t\t\t\t\t\t\tstack.Abort(&jsonapi.Error{\n\t\t\t\t\t\t\t\tStatus: http.StatusUnauthorized,\n\t\t\t\t\t\t\t\tDetail: err.Error(),\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t} else if err != nil {\n\t\t\t\t\t\t\tstack.Abort(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// limit request body size\n\t\t\t\t\tLimitBody(ctx.ResponseWriter, ctx.HTTPRequest, int64(action.Action.BodyLimit))\n\n\t\t\t\t\t// call action with context\n\t\t\t\t\tstack.AbortIf(action.Action.Callback.Handler(ctx))\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// otherwise return error\n\t\tstack.Abort(jsonapi.NotFound(\"resource not found\"))\n\t})\n}", "code_tokens": ["func", "(", "g", "*", "Group", ")", "Endpoint", "(", "prefix", "string", ")", "http", ".", "Handler", "{", "// trim prefix", "prefix", "=", "strings", ".", "Trim", "(", "prefix", ",", "\"", "\"", ")", "\n\n", "return", "http", ".", "HandlerFunc", "(", "func", "(", "w", "http", ".", "ResponseWriter", ",", "r", "*", "http", ".", "Request", ")", "{", "// create tracer", "tracer", ":=", "NewTracerFromRequest", "(", "r", ",", "\"", "\"", ")", "\n", "defer", "tracer", ".", "Finish", "(", "true", ")", "\n\n", "// continue any previous aborts", "defer", "stack", ".", "Resume", "(", "func", "(", "err", "error", ")", "{", "// directly write jsonapi errors", "if", "jsonapiError", ",", "ok", ":=", "err", ".", "(", "*", "jsonapi", ".", "Error", ")", ";", "ok", "{", "_", "=", "jsonapi", ".", "WriteError", "(", "w", ",", "jsonapiError", ")", "\n", "return", "\n", "}", "\n\n", "// set critical error on last span", "tracer", ".", "Tag", "(", "\"", "\"", ",", "true", ")", "\n", "tracer", ".", "Log", "(", "\"", "\"", ",", "err", ".", "Error", "(", ")", ")", "\n", "tracer", ".", "Log", "(", "\"", "\"", ",", "stack", ".", "Trace", "(", ")", ")", "\n\n", "// report critical errors if possible", "if", "g", ".", "Reporter", "!=", "nil", "{", "g", ".", "Reporter", "(", "err", ")", "\n", "}", "\n\n", "// ignore errors caused by writing critical errors", "_", "=", "jsonapi", ".", "WriteError", "(", "w", ",", "jsonapi", ".", "InternalServerError", "(", "\"", "\"", ")", ")", "\n", "}", ")", "\n\n", "// trim path", "path", ":=", "strings", ".", "Trim", "(", "r", ".", "URL", ".", "Path", ",", "\"", "\"", ")", "\n", "path", "=", "strings", ".", "TrimPrefix", "(", "path", ",", "prefix", ")", "\n", "path", "=", "strings", ".", "Trim", "(", "path", ",", "\"", "\"", ")", "\n\n", "// check path", "if", "path", "==", "\"", "\"", "{", "stack", ".", "Abort", "(", "jsonapi", ".", "NotFound", "(", "\"", "\"", ")", ")", "\n", "}", "\n\n", "// split path", "s", ":=", "strings", ".", "Split", "(", "path", ",", "\"", "\"", ")", "\n\n", "// prepare context", "ctx", ":=", "&", "Context", "{", "Data", ":", "Map", "{", "}", ",", "HTTPRequest", ":", "r", ",", "ResponseWriter", ":", "w", ",", "Group", ":", "g", ",", "Tracer", ":", "tracer", ",", "}", "\n\n", "// get controller", "controller", ",", "ok", ":=", "g", ".", "controllers", "[", "s", "[", "0", "]", "]", "\n", "if", "ok", "{", "// set controller", "ctx", ".", "Controller", "=", "controller", "\n\n", "// call controller with context", "controller", ".", "generalHandler", "(", "prefix", ",", "ctx", ")", "\n\n", "return", "\n", "}", "\n\n", "// get action", "action", ",", "ok", ":=", "g", ".", "actions", "[", "s", "[", "0", "]", "]", "\n", "if", "ok", "{", "// check if action is allowed", "if", "Contains", "(", "action", ".", "Action", ".", "Methods", ",", "r", ".", "Method", ")", "{", "// check if action matches the context", "if", "action", ".", "Action", ".", "Callback", ".", "Matcher", "(", "ctx", ")", "{", "// run authorizers and handle errors", "for", "_", ",", "cb", ":=", "range", "action", ".", "Authorizers", "{", "// check if callback should be run", "if", "!", "cb", ".", "Matcher", "(", "ctx", ")", "{", "continue", "\n", "}", "\n\n", "// call callback", "err", ":=", "cb", ".", "Handler", "(", "ctx", ")", "\n", "if", "IsSafe", "(", "err", ")", "{", "stack", ".", "Abort", "(", "&", "jsonapi", ".", "Error", "{", "Status", ":", "http", ".", "StatusUnauthorized", ",", "Detail", ":", "err", ".", "Error", "(", ")", ",", "}", ")", "\n", "}", "else", "if", "err", "!=", "nil", "{", "stack", ".", "Abort", "(", "err", ")", "\n", "}", "\n", "}", "\n\n", "// limit request body size", "LimitBody", "(", "ctx", ".", "ResponseWriter", ",", "ctx", ".", "HTTPRequest", ",", "int64", "(", "action", ".", "Action", ".", "BodyLimit", ")", ")", "\n\n", "// call action with context", "stack", ".", "AbortIf", "(", "action", ".", "Action", ".", "Callback", ".", "Handler", "(", "ctx", ")", ")", "\n\n", "return", "\n", "}", "\n", "}", "\n", "}", "\n\n", "// otherwise return error", "stack", ".", "Abort", "(", "jsonapi", ".", "NotFound", "(", "\"", "\"", ")", ")", "\n", "}", ")", "\n", "}"], "docstring": "// Endpoint will return an http handler that serves requests for this group. The\n// specified prefix is used to parse the requests and generate urls for the\n// resources.", "docstring_tokens": ["Endpoint", "will", "return", "an", "http", "handler", "that", "serves", "requests", "for", "this", "group", ".", "The", "specified", "prefix", "is", "used", "to", "parse", "the", "requests", "and", "generate", "urls", "for", "the", "resources", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/group.go#L87-L192", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "horizon/main.go", "func_name": "SequenceForAccount", "original_string": "func (c *Client) SequenceForAccount(\n\taccountID string,\n) (xdr.SequenceNumber, error) {\n\n\ta, err := c.LoadAccount(accountID)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tseq, err := strconv.ParseUint(a.Sequence, 10, 64)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn xdr.SequenceNumber(seq), nil\n}", "language": "go", "code": "func (c *Client) SequenceForAccount(\n\taccountID string,\n) (xdr.SequenceNumber, error) {\n\n\ta, err := c.LoadAccount(accountID)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tseq, err := strconv.ParseUint(a.Sequence, 10, 64)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn xdr.SequenceNumber(seq), nil\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "SequenceForAccount", "(", "accountID", "string", ",", ")", "(", "xdr", ".", "SequenceNumber", ",", "error", ")", "{", "a", ",", "err", ":=", "c", ".", "LoadAccount", "(", "accountID", ")", "\n", "if", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n\n", "seq", ",", "err", ":=", "strconv", ".", "ParseUint", "(", "a", ".", "Sequence", ",", "10", ",", "64", ")", "\n", "if", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n\n", "return", "xdr", ".", "SequenceNumber", "(", "seq", ")", ",", "nil", "\n", "}"], "docstring": "// SequenceForAccount implements build.SequenceProvider", "docstring_tokens": ["SequenceForAccount", "implements", "build", ".", "SequenceProvider"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/horizon/main.go#L60-L75", "partition": "test"}
{"repo": "janos/web", "path": "templates/templates.go", "func_name": "WithDelims", "original_string": "func WithDelims(open, close string) Option {\n\treturn func(o *Options) {\n\t\to.delimOpen = open\n\t\to.delimClose = close\n\t}\n}", "language": "go", "code": "func WithDelims(open, close string) Option {\n\treturn func(o *Options) {\n\t\to.delimOpen = open\n\t\to.delimClose = close\n\t}\n}", "code_tokens": ["func", "WithDelims", "(", "open", ",", "close", "string", ")", "Option", "{", "return", "func", "(", "o", "*", "Options", ")", "{", "o", ".", "delimOpen", "=", "open", "\n", "o", ".", "delimClose", "=", "close", "\n", "}", "\n", "}"], "docstring": "// WithDelims sets the delimiters used in templates.", "docstring_tokens": ["WithDelims", "sets", "the", "delimiters", "used", "in", "templates", "."], "sha": "0fb0203103deb84424510a8d5166ac00700f2b0e", "url": "https://github.com/janos/web/blob/0fb0203103deb84424510a8d5166ac00700f2b0e/templates/templates.go#L129-L134", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "gossip_channel.go", "func_name": "Send", "original_string": "func (c *gossipChannel) Send(data GossipData) {\n\tc.relay(c.ourself.Name, data)\n}", "language": "go", "code": "func (c *gossipChannel) Send(data GossipData) {\n\tc.relay(c.ourself.Name, data)\n}", "code_tokens": ["func", "(", "c", "*", "gossipChannel", ")", "Send", "(", "data", "GossipData", ")", "{", "c", ".", "relay", "(", "c", ".", "ourself", ".", "Name", ",", "data", ")", "\n", "}"], "docstring": "// Send relays data into the channel topology via random neighbours.", "docstring_tokens": ["Send", "relays", "data", "into", "the", "channel", "topology", "via", "random", "neighbours", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/gossip_channel.go#L87-L89", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewAccountId", "original_string": "func NewAccountId(aType CryptoKeyType, value interface{}) (result AccountId, err error) {\n\tu, err := NewPublicKey(aType, value)\n\tresult = AccountId(u)\n\treturn\n}", "language": "go", "code": "func NewAccountId(aType CryptoKeyType, value interface{}) (result AccountId, err error) {\n\tu, err := NewPublicKey(aType, value)\n\tresult = AccountId(u)\n\treturn\n}", "code_tokens": ["func", "NewAccountId", "(", "aType", "CryptoKeyType", ",", "value", "interface", "{", "}", ")", "(", "result", "AccountId", ",", "err", "error", ")", "{", "u", ",", "err", ":=", "NewPublicKey", "(", "aType", ",", "value", ")", "\n", "result", "=", "AccountId", "(", "u", ")", "\n", "return", "\n", "}"], "docstring": "// NewAccountId creates a new  AccountId.", "docstring_tokens": ["NewAccountId", "creates", "a", "new", "AccountId", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L279-L283", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "robots/issue-creator/sources/flakyjob-reporter.go", "func_name": "ReadHTTP", "original_string": "func ReadHTTP(url string) ([]byte, error) {\n\tvar err error\n\tretryDelay := time.Duration(2) * time.Second\n\tfor retryCount := 0; retryCount < 5; retryCount++ {\n\t\tif retryCount > 0 {\n\t\t\ttime.Sleep(retryDelay)\n\t\t\tretryDelay *= time.Duration(2)\n\t\t}\n\n\t\tresp, err := http.Get(url)\n\t\tif resp != nil && resp.StatusCode >= 500 {\n\t\t\t// Retry on this type of error.\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\treturn body, nil\n\t}\n\treturn nil, fmt.Errorf(\"ran out of retries reading from '%s'. Last error was %v\", url, err)\n}", "language": "go", "code": "func ReadHTTP(url string) ([]byte, error) {\n\tvar err error\n\tretryDelay := time.Duration(2) * time.Second\n\tfor retryCount := 0; retryCount < 5; retryCount++ {\n\t\tif retryCount > 0 {\n\t\t\ttime.Sleep(retryDelay)\n\t\t\tretryDelay *= time.Duration(2)\n\t\t}\n\n\t\tresp, err := http.Get(url)\n\t\tif resp != nil && resp.StatusCode >= 500 {\n\t\t\t// Retry on this type of error.\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\treturn body, nil\n\t}\n\treturn nil, fmt.Errorf(\"ran out of retries reading from '%s'. Last error was %v\", url, err)\n}", "code_tokens": ["func", "ReadHTTP", "(", "url", "string", ")", "(", "[", "]", "byte", ",", "error", ")", "{", "var", "err", "error", "\n", "retryDelay", ":=", "time", ".", "Duration", "(", "2", ")", "*", "time", ".", "Second", "\n", "for", "retryCount", ":=", "0", ";", "retryCount", "<", "5", ";", "retryCount", "++", "{", "if", "retryCount", ">", "0", "{", "time", ".", "Sleep", "(", "retryDelay", ")", "\n", "retryDelay", "*=", "time", ".", "Duration", "(", "2", ")", "\n", "}", "\n\n", "resp", ",", "err", ":=", "http", ".", "Get", "(", "url", ")", "\n", "if", "resp", "!=", "nil", "&&", "resp", ".", "StatusCode", ">=", "500", "{", "// Retry on this type of error.", "continue", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "defer", "resp", ".", "Body", ".", "Close", "(", ")", "\n\n", "body", ",", "err", ":=", "ioutil", ".", "ReadAll", "(", "resp", ".", "Body", ")", "\n", "if", "err", "!=", "nil", "{", "continue", "\n", "}", "\n", "return", "body", ",", "nil", "\n", "}", "\n", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "url", ",", "err", ")", "\n", "}"], "docstring": "// ReadHTTP fetches file contents from a URL with retries.", "docstring_tokens": ["ReadHTTP", "fetches", "file", "contents", "from", "a", "URL", "with", "retries", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/robots/issue-creator/sources/flakyjob-reporter.go#L256-L282", "partition": "test"}
{"repo": "dailyburn/bigquery", "path": "client/client.go", "func_name": "pagedQuery", "original_string": "func (c *Client) pagedQuery(pageSize int, dataset, project, queryStr string, dataChan chan Data) ([][]interface{}, []string, error) {\n\t// connect to service\n\tservice, err := c.connect()\n\tif err != nil {\n\t\tif dataChan != nil {\n\t\t\tdataChan <- Data{Err: err}\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\n\tif c.allowLargeResults && len(c.tempTableName) > 0 {\n\t\treturn c.largeDataPagedQuery(service, pageSize, dataset, project, queryStr, dataChan)\n\t}\n\n\treturn c.stdPagedQuery(service, pageSize, dataset, project, queryStr, dataChan)\n}", "language": "go", "code": "func (c *Client) pagedQuery(pageSize int, dataset, project, queryStr string, dataChan chan Data) ([][]interface{}, []string, error) {\n\t// connect to service\n\tservice, err := c.connect()\n\tif err != nil {\n\t\tif dataChan != nil {\n\t\t\tdataChan <- Data{Err: err}\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\n\tif c.allowLargeResults && len(c.tempTableName) > 0 {\n\t\treturn c.largeDataPagedQuery(service, pageSize, dataset, project, queryStr, dataChan)\n\t}\n\n\treturn c.stdPagedQuery(service, pageSize, dataset, project, queryStr, dataChan)\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "pagedQuery", "(", "pageSize", "int", ",", "dataset", ",", "project", ",", "queryStr", "string", ",", "dataChan", "chan", "Data", ")", "(", "[", "]", "[", "]", "interface", "{", "}", ",", "[", "]", "string", ",", "error", ")", "{", "// connect to service", "service", ",", "err", ":=", "c", ".", "connect", "(", ")", "\n", "if", "err", "!=", "nil", "{", "if", "dataChan", "!=", "nil", "{", "dataChan", "<-", "Data", "{", "Err", ":", "err", "}", "\n", "}", "\n", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n\n", "if", "c", ".", "allowLargeResults", "&&", "len", "(", "c", ".", "tempTableName", ")", ">", "0", "{", "return", "c", ".", "largeDataPagedQuery", "(", "service", ",", "pageSize", ",", "dataset", ",", "project", ",", "queryStr", ",", "dataChan", ")", "\n", "}", "\n\n", "return", "c", ".", "stdPagedQuery", "(", "service", ",", "pageSize", ",", "dataset", ",", "project", ",", "queryStr", ",", "dataChan", ")", "\n", "}"], "docstring": "// pagedQuery executes the query using bq's paging mechanism to load all results and sends them back via dataChan if available, otherwise it returns the full result set, headers and error as return values", "docstring_tokens": ["pagedQuery", "executes", "the", "query", "using", "bq", "s", "paging", "mechanism", "to", "load", "all", "results", "and", "sends", "them", "back", "via", "dataChan", "if", "available", "otherwise", "it", "returns", "the", "full", "result", "set", "headers", "and", "error", "as", "return", "values"], "sha": "b6f18972580ed8882d195da0e9b7c9b94902a1ea", "url": "https://github.com/dailyburn/bigquery/blob/b6f18972580ed8882d195da0e9b7c9b94902a1ea/client/client.go#L298-L313", "partition": "test"}
{"repo": "containers/image", "path": "ostree/ostree_transport.go", "func_name": "signaturePath", "original_string": "func (ref ostreeReference) signaturePath(index int) string {\n\treturn filepath.Join(\"manifest\", fmt.Sprintf(\"signature-%d\", index+1))\n}", "language": "go", "code": "func (ref ostreeReference) signaturePath(index int) string {\n\treturn filepath.Join(\"manifest\", fmt.Sprintf(\"signature-%d\", index+1))\n}", "code_tokens": ["func", "(", "ref", "ostreeReference", ")", "signaturePath", "(", "index", "int", ")", "string", "{", "return", "filepath", ".", "Join", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "index", "+", "1", ")", ")", "\n", "}"], "docstring": "// signaturePath returns a path for a signature within a ostree using our conventions.", "docstring_tokens": ["signaturePath", "returns", "a", "path", "for", "a", "signature", "within", "a", "ostree", "using", "our", "conventions", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/ostree/ostree_transport.go#L250-L252", "partition": "test"}
{"repo": "justinfx/gofileseq", "path": "frameset.go", "func_name": "FrameRangePadded", "original_string": "func (s *FrameSet) FrameRangePadded(pad int) string {\n\treturn PadFrameRange(s.frange, pad)\n}", "language": "go", "code": "func (s *FrameSet) FrameRangePadded(pad int) string {\n\treturn PadFrameRange(s.frange, pad)\n}", "code_tokens": ["func", "(", "s", "*", "FrameSet", ")", "FrameRangePadded", "(", "pad", "int", ")", "string", "{", "return", "PadFrameRange", "(", "s", ".", "frange", ",", "pad", ")", "\n", "}"], "docstring": "// FrameRangePadded returns the range string that was used\n// to initialize the FrameSet, with each number padded out\n// with zeros to a given width", "docstring_tokens": ["FrameRangePadded", "returns", "the", "range", "string", "that", "was", "used", "to", "initialize", "the", "FrameSet", "with", "each", "number", "padded", "out", "with", "zeros", "to", "a", "given", "width"], "sha": "2555f296b4493d1825f5f6fab4aa0ff51a8306cd", "url": "https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/frameset.go#L198-L200", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/statusreconciler/controller.go", "func_name": "Run", "original_string": "func (c *Controller) Run(stop <-chan os.Signal, changes <-chan config.Delta) {\n\tfor {\n\t\tselect {\n\t\tcase change := <-changes:\n\t\t\tstart := time.Now()\n\t\t\tif err := c.reconcile(change); err != nil {\n\t\t\t\tlogrus.WithError(err).Error(\"Error reconciling statuses.\")\n\t\t\t}\n\t\t\tlogrus.WithField(\"duration\", fmt.Sprintf(\"%v\", time.Since(start))).Info(\"Statuses reconciled\")\n\t\tcase <-stop:\n\t\t\tlogrus.Info(\"status-reconciler is shutting down...\")\n\t\t\treturn\n\t\t}\n\t}\n}", "language": "go", "code": "func (c *Controller) Run(stop <-chan os.Signal, changes <-chan config.Delta) {\n\tfor {\n\t\tselect {\n\t\tcase change := <-changes:\n\t\t\tstart := time.Now()\n\t\t\tif err := c.reconcile(change); err != nil {\n\t\t\t\tlogrus.WithError(err).Error(\"Error reconciling statuses.\")\n\t\t\t}\n\t\t\tlogrus.WithField(\"duration\", fmt.Sprintf(\"%v\", time.Since(start))).Info(\"Statuses reconciled\")\n\t\tcase <-stop:\n\t\t\tlogrus.Info(\"status-reconciler is shutting down...\")\n\t\t\treturn\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "c", "*", "Controller", ")", "Run", "(", "stop", "<-", "chan", "os", ".", "Signal", ",", "changes", "<-", "chan", "config", ".", "Delta", ")", "{", "for", "{", "select", "{", "case", "change", ":=", "<-", "changes", ":", "start", ":=", "time", ".", "Now", "(", ")", "\n", "if", "err", ":=", "c", ".", "reconcile", "(", "change", ")", ";", "err", "!=", "nil", "{", "logrus", ".", "WithError", "(", "err", ")", ".", "Error", "(", "\"", "\"", ")", "\n", "}", "\n", "logrus", ".", "WithField", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "time", ".", "Since", "(", "start", ")", ")", ")", ".", "Info", "(", "\"", "\"", ")", "\n", "case", "<-", "stop", ":", "logrus", ".", "Info", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// Run monitors the incoming configuration changes to determine when statuses need to be\n// reconciled on PRs in flight when blocking presubmits change", "docstring_tokens": ["Run", "monitors", "the", "incoming", "configuration", "changes", "to", "determine", "when", "statuses", "need", "to", "be", "reconciled", "on", "PRs", "in", "flight", "when", "blocking", "presubmits", "change"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/statusreconciler/controller.go#L139-L153", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/networks.go", "func_name": "NetworkNodeJoin", "original_string": "func (c *ClusterTx) NetworkNodeJoin(networkID, nodeID int64) error {\n\tcolumns := []string{\"network_id\", \"node_id\"}\n\tvalues := []interface{}{networkID, nodeID}\n\t_, err := query.UpsertObject(c.tx, \"networks_nodes\", columns, values)\n\treturn err\n}", "language": "go", "code": "func (c *ClusterTx) NetworkNodeJoin(networkID, nodeID int64) error {\n\tcolumns := []string{\"network_id\", \"node_id\"}\n\tvalues := []interface{}{networkID, nodeID}\n\t_, err := query.UpsertObject(c.tx, \"networks_nodes\", columns, values)\n\treturn err\n}", "code_tokens": ["func", "(", "c", "*", "ClusterTx", ")", "NetworkNodeJoin", "(", "networkID", ",", "nodeID", "int64", ")", "error", "{", "columns", ":=", "[", "]", "string", "{", "\"", "\"", ",", "\"", "\"", "}", "\n", "values", ":=", "[", "]", "interface", "{", "}", "{", "networkID", ",", "nodeID", "}", "\n", "_", ",", "err", ":=", "query", ".", "UpsertObject", "(", "c", ".", "tx", ",", "\"", "\"", ",", "columns", ",", "values", ")", "\n", "return", "err", "\n", "}"], "docstring": "// NetworkNodeJoin adds a new entry in the networks_nodes table.\n//\n// It should only be used when a new node joins the cluster, when it's safe to\n// assume that the relevant network has already been created on the joining node,\n// and we just need to track it.", "docstring_tokens": ["NetworkNodeJoin", "adds", "a", "new", "entry", "in", "the", "networks_nodes", "table", ".", "It", "should", "only", "be", "used", "when", "a", "new", "node", "joins", "the", "cluster", "when", "it", "s", "safe", "to", "assume", "that", "the", "relevant", "network", "has", "already", "been", "created", "on", "the", "joining", "node", "and", "we", "just", "need", "to", "track", "it", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/networks.go#L93-L98", "partition": "test"}
{"repo": "containers/image", "path": "signature/policy_config.go", "func_name": "newPRMExactRepository", "original_string": "func newPRMExactRepository(dockerRepository string) (*prmExactRepository, error) {\n\tif _, err := reference.ParseNormalizedNamed(dockerRepository); err != nil {\n\t\treturn nil, InvalidPolicyFormatError(fmt.Sprintf(\"Invalid format of dockerRepository %s: %s\", dockerRepository, err.Error()))\n\t}\n\treturn &prmExactRepository{\n\t\tprmCommon:        prmCommon{Type: prmTypeExactRepository},\n\t\tDockerRepository: dockerRepository,\n\t}, nil\n}", "language": "go", "code": "func newPRMExactRepository(dockerRepository string) (*prmExactRepository, error) {\n\tif _, err := reference.ParseNormalizedNamed(dockerRepository); err != nil {\n\t\treturn nil, InvalidPolicyFormatError(fmt.Sprintf(\"Invalid format of dockerRepository %s: %s\", dockerRepository, err.Error()))\n\t}\n\treturn &prmExactRepository{\n\t\tprmCommon:        prmCommon{Type: prmTypeExactRepository},\n\t\tDockerRepository: dockerRepository,\n\t}, nil\n}", "code_tokens": ["func", "newPRMExactRepository", "(", "dockerRepository", "string", ")", "(", "*", "prmExactRepository", ",", "error", ")", "{", "if", "_", ",", "err", ":=", "reference", ".", "ParseNormalizedNamed", "(", "dockerRepository", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "InvalidPolicyFormatError", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "dockerRepository", ",", "err", ".", "Error", "(", ")", ")", ")", "\n", "}", "\n", "return", "&", "prmExactRepository", "{", "prmCommon", ":", "prmCommon", "{", "Type", ":", "prmTypeExactRepository", "}", ",", "DockerRepository", ":", "dockerRepository", ",", "}", ",", "nil", "\n", "}"], "docstring": "// newPRMExactRepository is NewPRMExactRepository, except it resturns the private type.", "docstring_tokens": ["newPRMExactRepository", "is", "NewPRMExactRepository", "except", "it", "resturns", "the", "private", "type", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/signature/policy_config.go#L649-L657", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/endpoints/cluster.go", "func_name": "ClusterAddress", "original_string": "func (e *Endpoints) ClusterAddress() string {\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tlistener := e.listeners[cluster]\n\tif listener == nil {\n\t\treturn \"\"\n\t}\n\treturn listener.Addr().String()\n}", "language": "go", "code": "func (e *Endpoints) ClusterAddress() string {\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tlistener := e.listeners[cluster]\n\tif listener == nil {\n\t\treturn \"\"\n\t}\n\treturn listener.Addr().String()\n}", "code_tokens": ["func", "(", "e", "*", "Endpoints", ")", "ClusterAddress", "(", ")", "string", "{", "e", ".", "mu", ".", "RLock", "(", ")", "\n", "defer", "e", ".", "mu", ".", "RUnlock", "(", ")", "\n\n", "listener", ":=", "e", ".", "listeners", "[", "cluster", "]", "\n", "if", "listener", "==", "nil", "{", "return", "\"", "\"", "\n", "}", "\n", "return", "listener", ".", "Addr", "(", ")", ".", "String", "(", ")", "\n", "}"], "docstring": "// ClusterAddress returns the cluster addresss of the cluster endpoint, or an\n// empty string if there's no cluster endpoint.", "docstring_tokens": ["ClusterAddress", "returns", "the", "cluster", "addresss", "of", "the", "cluster", "endpoint", "or", "an", "empty", "string", "if", "there", "s", "no", "cluster", "endpoint", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/endpoints/cluster.go#L16-L25", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "router.go", "func_name": "NewRouter", "original_string": "func NewRouter(config Config, name PeerName, nickName string, overlay Overlay, logger Logger) (*Router, error) {\n\trouter := &Router{Config: config, gossipChannels: make(gossipChannels)}\n\n\tif overlay == nil {\n\t\toverlay = NullOverlay{}\n\t}\n\n\trouter.Overlay = overlay\n\trouter.Ourself = newLocalPeer(name, nickName, router)\n\trouter.Peers = newPeers(router.Ourself)\n\trouter.Peers.OnGC(func(peer *Peer) {\n\t\tlogger.Printf(\"Removed unreachable peer %s\", peer)\n\t})\n\trouter.Routes = newRoutes(router.Ourself, router.Peers)\n\trouter.ConnectionMaker = newConnectionMaker(router.Ourself, router.Peers, net.JoinHostPort(router.Host, \"0\"), router.Port, router.PeerDiscovery, logger)\n\trouter.logger = logger\n\tgossip, err := router.NewGossip(\"topology\", router)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trouter.topologyGossip = gossip\n\trouter.acceptLimiter = newTokenBucket(acceptMaxTokens, acceptTokenDelay)\n\treturn router, nil\n}", "language": "go", "code": "func NewRouter(config Config, name PeerName, nickName string, overlay Overlay, logger Logger) (*Router, error) {\n\trouter := &Router{Config: config, gossipChannels: make(gossipChannels)}\n\n\tif overlay == nil {\n\t\toverlay = NullOverlay{}\n\t}\n\n\trouter.Overlay = overlay\n\trouter.Ourself = newLocalPeer(name, nickName, router)\n\trouter.Peers = newPeers(router.Ourself)\n\trouter.Peers.OnGC(func(peer *Peer) {\n\t\tlogger.Printf(\"Removed unreachable peer %s\", peer)\n\t})\n\trouter.Routes = newRoutes(router.Ourself, router.Peers)\n\trouter.ConnectionMaker = newConnectionMaker(router.Ourself, router.Peers, net.JoinHostPort(router.Host, \"0\"), router.Port, router.PeerDiscovery, logger)\n\trouter.logger = logger\n\tgossip, err := router.NewGossip(\"topology\", router)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trouter.topologyGossip = gossip\n\trouter.acceptLimiter = newTokenBucket(acceptMaxTokens, acceptTokenDelay)\n\treturn router, nil\n}", "code_tokens": ["func", "NewRouter", "(", "config", "Config", ",", "name", "PeerName", ",", "nickName", "string", ",", "overlay", "Overlay", ",", "logger", "Logger", ")", "(", "*", "Router", ",", "error", ")", "{", "router", ":=", "&", "Router", "{", "Config", ":", "config", ",", "gossipChannels", ":", "make", "(", "gossipChannels", ")", "}", "\n\n", "if", "overlay", "==", "nil", "{", "overlay", "=", "NullOverlay", "{", "}", "\n", "}", "\n\n", "router", ".", "Overlay", "=", "overlay", "\n", "router", ".", "Ourself", "=", "newLocalPeer", "(", "name", ",", "nickName", ",", "router", ")", "\n", "router", ".", "Peers", "=", "newPeers", "(", "router", ".", "Ourself", ")", "\n", "router", ".", "Peers", ".", "OnGC", "(", "func", "(", "peer", "*", "Peer", ")", "{", "logger", ".", "Printf", "(", "\"", "\"", ",", "peer", ")", "\n", "}", ")", "\n", "router", ".", "Routes", "=", "newRoutes", "(", "router", ".", "Ourself", ",", "router", ".", "Peers", ")", "\n", "router", ".", "ConnectionMaker", "=", "newConnectionMaker", "(", "router", ".", "Ourself", ",", "router", ".", "Peers", ",", "net", ".", "JoinHostPort", "(", "router", ".", "Host", ",", "\"", "\"", ")", ",", "router", ".", "Port", ",", "router", ".", "PeerDiscovery", ",", "logger", ")", "\n", "router", ".", "logger", "=", "logger", "\n", "gossip", ",", "err", ":=", "router", ".", "NewGossip", "(", "\"", "\"", ",", "router", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "router", ".", "topologyGossip", "=", "gossip", "\n", "router", ".", "acceptLimiter", "=", "newTokenBucket", "(", "acceptMaxTokens", ",", "acceptTokenDelay", ")", "\n", "return", "router", ",", "nil", "\n", "}"], "docstring": "// NewRouter returns a new router. It must be started.", "docstring_tokens": ["NewRouter", "returns", "a", "new", "router", ".", "It", "must", "be", "started", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/router.go#L59-L82", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "animation/animation.go", "func_name": "Do", "original_string": "func (p *SetPlaybackRateParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetPlaybackRate, p, nil)\n}", "language": "go", "code": "func (p *SetPlaybackRateParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetPlaybackRate, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetPlaybackRateParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetPlaybackRate", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Animation.setPlaybackRate against the provided context.", "docstring_tokens": ["Do", "executes", "Animation", ".", "setPlaybackRate", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/animation/animation.go#L244-L246", "partition": "test"}
{"repo": "tylerb/gls", "path": "gls.go", "func_name": "getValues", "original_string": "func getValues() Values {\n\tgid := curGoroutineID()\n\tdataLock.Lock()\n\tvalues := data[gid]\n\tdataLock.Unlock()\n\treturn values\n}", "language": "go", "code": "func getValues() Values {\n\tgid := curGoroutineID()\n\tdataLock.Lock()\n\tvalues := data[gid]\n\tdataLock.Unlock()\n\treturn values\n}", "code_tokens": ["func", "getValues", "(", ")", "Values", "{", "gid", ":=", "curGoroutineID", "(", ")", "\n", "dataLock", ".", "Lock", "(", ")", "\n", "values", ":=", "data", "[", "gid", "]", "\n", "dataLock", ".", "Unlock", "(", ")", "\n", "return", "values", "\n", "}"], "docstring": "// getValues unlinks two goroutines", "docstring_tokens": ["getValues", "unlinks", "two", "goroutines"], "sha": "e606233f194d6c314156dc6a35f21a42a470c6f6", "url": "https://github.com/tylerb/gls/blob/e606233f194d6c314156dc6a35f21a42a470c6f6/gls.go#L88-L94", "partition": "test"}
{"repo": "danott/envflag", "path": "envflag.go", "func_name": "getenv", "original_string": "func getenv(name string) (s string, ok bool) {\n\tm := make(map[string]bool)\n\n\tfor _, keyVal := range os.Environ() {\n\t\tsplit := strings.Split(keyVal, \"=\")\n\t\tm[split[0]] = true\n\t}\n\n\tname = flagAsEnv(name)\n\tif _, ok = m[name]; ok {\n\t\ts = os.Getenv(name)\n\t}\n\n\treturn\n}", "language": "go", "code": "func getenv(name string) (s string, ok bool) {\n\tm := make(map[string]bool)\n\n\tfor _, keyVal := range os.Environ() {\n\t\tsplit := strings.Split(keyVal, \"=\")\n\t\tm[split[0]] = true\n\t}\n\n\tname = flagAsEnv(name)\n\tif _, ok = m[name]; ok {\n\t\ts = os.Getenv(name)\n\t}\n\n\treturn\n}", "code_tokens": ["func", "getenv", "(", "name", "string", ")", "(", "s", "string", ",", "ok", "bool", ")", "{", "m", ":=", "make", "(", "map", "[", "string", "]", "bool", ")", "\n\n", "for", "_", ",", "keyVal", ":=", "range", "os", ".", "Environ", "(", ")", "{", "split", ":=", "strings", ".", "Split", "(", "keyVal", ",", "\"", "\"", ")", "\n", "m", "[", "split", "[", "0", "]", "]", "=", "true", "\n", "}", "\n\n", "name", "=", "flagAsEnv", "(", "name", ")", "\n", "if", "_", ",", "ok", "=", "m", "[", "name", "]", ";", "ok", "{", "s", "=", "os", ".", "Getenv", "(", "name", ")", "\n", "}", "\n\n", "return", "\n", "}"], "docstring": "// Just like os.Getenv, but with a second return value; a boolean specifying\n// if name was actually set in the environment.", "docstring_tokens": ["Just", "like", "os", ".", "Getenv", "but", "with", "a", "second", "return", "value", ";", "a", "boolean", "specifying", "if", "name", "was", "actually", "set", "in", "the", "environment", "."], "sha": "14c5f9aaa227ddb49f3206fe06432edfc27735a5", "url": "https://github.com/danott/envflag/blob/14c5f9aaa227ddb49f3206fe06432edfc27735a5/envflag.go#L96-L110", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "thrift/thrift-gen/main.go", "func_name": "NewStringSliceFlag", "original_string": "func NewStringSliceFlag(name string, usage string) *[]string {\n\tvar ss stringSliceFlag\n\tflag.Var(&ss, name, usage)\n\treturn (*[]string)(&ss)\n}", "language": "go", "code": "func NewStringSliceFlag(name string, usage string) *[]string {\n\tvar ss stringSliceFlag\n\tflag.Var(&ss, name, usage)\n\treturn (*[]string)(&ss)\n}", "code_tokens": ["func", "NewStringSliceFlag", "(", "name", "string", ",", "usage", "string", ")", "*", "[", "]", "string", "{", "var", "ss", "stringSliceFlag", "\n", "flag", ".", "Var", "(", "&", "ss", ",", "name", ",", "usage", ")", "\n", "return", "(", "*", "[", "]", "string", ")", "(", "&", "ss", ")", "\n", "}"], "docstring": "// NewStringSliceFlag creates a new string slice flag. The default value is always nil.", "docstring_tokens": ["NewStringSliceFlag", "creates", "a", "new", "string", "slice", "flag", ".", "The", "default", "value", "is", "always", "nil", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/thrift/thrift-gen/main.go#L232-L236", "partition": "test"}
{"repo": "kpango/glg", "path": "glg.go", "func_name": "SetWriter", "original_string": "func (g *Glg) SetWriter(writer io.Writer) *Glg {\n\tif writer == nil {\n\t\treturn g\n\t}\n\n\tg.logger.Range(func(key, val interface{}) bool {\n\t\tl := val.(*logger)\n\t\tl.writer = writer\n\t\tl.updateMode()\n\t\tg.logger.Store(key.(LEVEL), l)\n\t\treturn true\n\t})\n\n\treturn g\n}", "language": "go", "code": "func (g *Glg) SetWriter(writer io.Writer) *Glg {\n\tif writer == nil {\n\t\treturn g\n\t}\n\n\tg.logger.Range(func(key, val interface{}) bool {\n\t\tl := val.(*logger)\n\t\tl.writer = writer\n\t\tl.updateMode()\n\t\tg.logger.Store(key.(LEVEL), l)\n\t\treturn true\n\t})\n\n\treturn g\n}", "code_tokens": ["func", "(", "g", "*", "Glg", ")", "SetWriter", "(", "writer", "io", ".", "Writer", ")", "*", "Glg", "{", "if", "writer", "==", "nil", "{", "return", "g", "\n", "}", "\n\n", "g", ".", "logger", ".", "Range", "(", "func", "(", "key", ",", "val", "interface", "{", "}", ")", "bool", "{", "l", ":=", "val", ".", "(", "*", "logger", ")", "\n", "l", ".", "writer", "=", "writer", "\n", "l", ".", "updateMode", "(", ")", "\n", "g", ".", "logger", ".", "Store", "(", "key", ".", "(", "LEVEL", ")", ",", "l", ")", "\n", "return", "true", "\n", "}", ")", "\n\n", "return", "g", "\n", "}"], "docstring": "// SetWriter sets writer to glg std writers", "docstring_tokens": ["SetWriter", "sets", "writer", "to", "glg", "std", "writers"], "sha": "68d2670cb2dbff047331daad841149a82ac37796", "url": "https://github.com/kpango/glg/blob/68d2670cb2dbff047331daad841149a82ac37796/glg.go#L329-L343", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/auth/cmds/cmds.go", "func_name": "GetCmd", "original_string": "func GetCmd(noMetrics, noPortForwarding *bool) *cobra.Command {\n\tget := &cobra.Command{\n\t\tUse:   \"{{alias}} [<username>] <repo>\",\n\t\tShort: \"Get the ACL for 'repo' or the access that 'username' has to 'repo'\",\n\t\tLong: \"Get the ACL for 'repo' or the access that 'username' has to \" +\n\t\t\t\"'repo'. For example, 'pachctl auth get github-alice private-data' \" +\n\t\t\t\"prints \\\"reader\\\", \\\"writer\\\", \\\"owner\\\", or \\\"none\\\", depending on \" +\n\t\t\t\"the privileges that \\\"github-alice\\\" has in \\\"repo\\\". Currently all \" +\n\t\t\t\"Pachyderm authentication uses GitHub OAuth, so 'username' must be a \" +\n\t\t\t\"GitHub username\",\n\t\tRun: cmdutil.RunBoundedArgs(1, 2, func(args []string) error {\n\t\t\tc, err := client.NewOnUserMachine(!*noMetrics, !*noPortForwarding, \"user\")\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not connect: %v\", err)\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tif len(args) == 1 {\n\t\t\t\t// Get ACL for a repo\n\t\t\t\trepo := args[0]\n\t\t\t\tresp, err := c.GetACL(c.Ctx(), &auth.GetACLRequest{\n\t\t\t\t\tRepo: repo,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn grpcutil.ScrubGRPC(err)\n\t\t\t\t}\n\t\t\t\tt := template.Must(template.New(\"ACLEntries\").Parse(\n\t\t\t\t\t\"{{range .}}{{.Username }}: {{.Scope}}\\n{{end}}\"))\n\t\t\t\treturn t.Execute(os.Stdout, resp.Entries)\n\t\t\t}\n\t\t\t// Get User's scope on an acl\n\t\t\tusername, repo := args[0], args[1]\n\t\t\tresp, err := c.GetScope(c.Ctx(), &auth.GetScopeRequest{\n\t\t\t\tRepos:    []string{repo},\n\t\t\t\tUsername: username,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn grpcutil.ScrubGRPC(err)\n\t\t\t}\n\t\t\tfmt.Println(resp.Scopes[0].String())\n\t\t\treturn nil\n\t\t}),\n\t}\n\treturn cmdutil.CreateAlias(get, \"auth get\")\n}", "language": "go", "code": "func GetCmd(noMetrics, noPortForwarding *bool) *cobra.Command {\n\tget := &cobra.Command{\n\t\tUse:   \"{{alias}} [<username>] <repo>\",\n\t\tShort: \"Get the ACL for 'repo' or the access that 'username' has to 'repo'\",\n\t\tLong: \"Get the ACL for 'repo' or the access that 'username' has to \" +\n\t\t\t\"'repo'. For example, 'pachctl auth get github-alice private-data' \" +\n\t\t\t\"prints \\\"reader\\\", \\\"writer\\\", \\\"owner\\\", or \\\"none\\\", depending on \" +\n\t\t\t\"the privileges that \\\"github-alice\\\" has in \\\"repo\\\". Currently all \" +\n\t\t\t\"Pachyderm authentication uses GitHub OAuth, so 'username' must be a \" +\n\t\t\t\"GitHub username\",\n\t\tRun: cmdutil.RunBoundedArgs(1, 2, func(args []string) error {\n\t\t\tc, err := client.NewOnUserMachine(!*noMetrics, !*noPortForwarding, \"user\")\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not connect: %v\", err)\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tif len(args) == 1 {\n\t\t\t\t// Get ACL for a repo\n\t\t\t\trepo := args[0]\n\t\t\t\tresp, err := c.GetACL(c.Ctx(), &auth.GetACLRequest{\n\t\t\t\t\tRepo: repo,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn grpcutil.ScrubGRPC(err)\n\t\t\t\t}\n\t\t\t\tt := template.Must(template.New(\"ACLEntries\").Parse(\n\t\t\t\t\t\"{{range .}}{{.Username }}: {{.Scope}}\\n{{end}}\"))\n\t\t\t\treturn t.Execute(os.Stdout, resp.Entries)\n\t\t\t}\n\t\t\t// Get User's scope on an acl\n\t\t\tusername, repo := args[0], args[1]\n\t\t\tresp, err := c.GetScope(c.Ctx(), &auth.GetScopeRequest{\n\t\t\t\tRepos:    []string{repo},\n\t\t\t\tUsername: username,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn grpcutil.ScrubGRPC(err)\n\t\t\t}\n\t\t\tfmt.Println(resp.Scopes[0].String())\n\t\t\treturn nil\n\t\t}),\n\t}\n\treturn cmdutil.CreateAlias(get, \"auth get\")\n}", "code_tokens": ["func", "GetCmd", "(", "noMetrics", ",", "noPortForwarding", "*", "bool", ")", "*", "cobra", ".", "Command", "{", "get", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Long", ":", "\"", "\"", "+", "\"", "\"", "+", "\"", "\\\"", "\\\"", "\\\"", "\\\"", "\\\"", "\\\"", "\\\"", "\\\"", "\"", "+", "\"", "\\\"", "\\\"", "\\\"", "\\\"", "\"", "+", "\"", "\"", "+", "\"", "\"", ",", "Run", ":", "cmdutil", ".", "RunBoundedArgs", "(", "1", ",", "2", ",", "func", "(", "args", "[", "]", "string", ")", "error", "{", "c", ",", "err", ":=", "client", ".", "NewOnUserMachine", "(", "!", "*", "noMetrics", ",", "!", "*", "noPortForwarding", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "defer", "c", ".", "Close", "(", ")", "\n", "if", "len", "(", "args", ")", "==", "1", "{", "// Get ACL for a repo", "repo", ":=", "args", "[", "0", "]", "\n", "resp", ",", "err", ":=", "c", ".", "GetACL", "(", "c", ".", "Ctx", "(", ")", ",", "&", "auth", ".", "GetACLRequest", "{", "Repo", ":", "repo", ",", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}", "\n", "t", ":=", "template", ".", "Must", "(", "template", ".", "New", "(", "\"", "\"", ")", ".", "Parse", "(", "\"", "\\n", "\"", ")", ")", "\n", "return", "t", ".", "Execute", "(", "os", ".", "Stdout", ",", "resp", ".", "Entries", ")", "\n", "}", "\n", "// Get User's scope on an acl", "username", ",", "repo", ":=", "args", "[", "0", "]", ",", "args", "[", "1", "]", "\n", "resp", ",", "err", ":=", "c", ".", "GetScope", "(", "c", ".", "Ctx", "(", ")", ",", "&", "auth", ".", "GetScopeRequest", "{", "Repos", ":", "[", "]", "string", "{", "repo", "}", ",", "Username", ":", "username", ",", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}", "\n", "fmt", ".", "Println", "(", "resp", ".", "Scopes", "[", "0", "]", ".", "String", "(", ")", ")", "\n", "return", "nil", "\n", "}", ")", ",", "}", "\n", "return", "cmdutil", ".", "CreateAlias", "(", "get", ",", "\"", "\"", ")", "\n", "}"], "docstring": "// GetCmd returns a cobra command that gets either the ACL for a Pachyderm\n// repo or another user's scope of access to that repo", "docstring_tokens": ["GetCmd", "returns", "a", "cobra", "command", "that", "gets", "either", "the", "ACL", "for", "a", "Pachyderm", "repo", "or", "another", "user", "s", "scope", "of", "access", "to", "that", "repo"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/auth/cmds/cmds.go#L294-L337", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/certificates.go", "func_name": "CertDelete", "original_string": "func (c *Cluster) CertDelete(fingerprint string) error {\n\terr := exec(c.db, \"DELETE FROM certificates WHERE fingerprint=?\", fingerprint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *Cluster) CertDelete(fingerprint string) error {\n\terr := exec(c.db, \"DELETE FROM certificates WHERE fingerprint=?\", fingerprint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "CertDelete", "(", "fingerprint", "string", ")", "error", "{", "err", ":=", "exec", "(", "c", ".", "db", ",", "\"", "\"", ",", "fingerprint", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// CertDelete deletes a certificate from the db.", "docstring_tokens": ["CertDelete", "deletes", "a", "certificate", "from", "the", "db", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/certificates.go#L116-L123", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/node/update.go", "func_name": "updateFromV37", "original_string": "func updateFromV37(tx *sql.Tx) error {\n\tcount, err := query.Count(tx, \"raft_nodes\", \"\")\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Fetch count of Raft nodes\")\n\t}\n\n\tif count == 0 {\n\t\t// This node is not clustered, nothing to do.\n\t\treturn nil\n\t}\n\n\t// Copy the core.https_address config.\n\t_, err = tx.Exec(`\nINSERT INTO config (key, value)\n  SELECT 'cluster.https_address', value FROM config WHERE key = 'core.https_address'\n`)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Insert cluster.https_address config\")\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func updateFromV37(tx *sql.Tx) error {\n\tcount, err := query.Count(tx, \"raft_nodes\", \"\")\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Fetch count of Raft nodes\")\n\t}\n\n\tif count == 0 {\n\t\t// This node is not clustered, nothing to do.\n\t\treturn nil\n\t}\n\n\t// Copy the core.https_address config.\n\t_, err = tx.Exec(`\nINSERT INTO config (key, value)\n  SELECT 'cluster.https_address', value FROM config WHERE key = 'core.https_address'\n`)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Insert cluster.https_address config\")\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "updateFromV37", "(", "tx", "*", "sql", ".", "Tx", ")", "error", "{", "count", ",", "err", ":=", "query", ".", "Count", "(", "tx", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n\n", "if", "count", "==", "0", "{", "// This node is not clustered, nothing to do.", "return", "nil", "\n", "}", "\n\n", "// Copy the core.https_address config.", "_", ",", "err", "=", "tx", ".", "Exec", "(", "`\nINSERT INTO config (key, value)\n  SELECT 'cluster.https_address', value FROM config WHERE key = 'core.https_address'\n`", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Schema updates begin here\n// Copy core.https_address to cluster.https_address in case this node is\n// clustered.", "docstring_tokens": ["Schema", "updates", "begin", "here", "Copy", "core", ".", "https_address", "to", "cluster", ".", "https_address", "in", "case", "this", "node", "is", "clustered", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/node/update.go#L106-L127", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/health/health.go", "func_name": "Health", "original_string": "func (h *healthServer) Health(context.Context, *types.Empty) (*types.Empty, error) {\n\tif !h.ready {\n\t\treturn nil, fmt.Errorf(\"server not ready\")\n\t}\n\treturn &types.Empty{}, nil\n}", "language": "go", "code": "func (h *healthServer) Health(context.Context, *types.Empty) (*types.Empty, error) {\n\tif !h.ready {\n\t\treturn nil, fmt.Errorf(\"server not ready\")\n\t}\n\treturn &types.Empty{}, nil\n}", "code_tokens": ["func", "(", "h", "*", "healthServer", ")", "Health", "(", "context", ".", "Context", ",", "*", "types", ".", "Empty", ")", "(", "*", "types", ".", "Empty", ",", "error", ")", "{", "if", "!", "h", ".", "ready", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "&", "types", ".", "Empty", "{", "}", ",", "nil", "\n", "}"], "docstring": "// Health implements the Health method for healthServer.", "docstring_tokens": ["Health", "implements", "the", "Health", "method", "for", "healthServer", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/health/health.go#L27-L32", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "loader/loader.go", "func_name": "DumpAST", "original_string": "func (f *Flags) DumpAST(b bool) {\n\tif b {\n\t\tf.flags |= MaskDumpAST\n\t} else {\n\t\tf.flags &= ^MaskDumpAST\n\t}\n}", "language": "go", "code": "func (f *Flags) DumpAST(b bool) {\n\tif b {\n\t\tf.flags |= MaskDumpAST\n\t} else {\n\t\tf.flags &= ^MaskDumpAST\n\t}\n}", "code_tokens": ["func", "(", "f", "*", "Flags", ")", "DumpAST", "(", "b", "bool", ")", "{", "if", "b", "{", "f", ".", "flags", "|=", "MaskDumpAST", "\n", "}", "else", "{", "f", ".", "flags", "&=", "^", "MaskDumpAST", "\n", "}", "\n", "}"], "docstring": "// DumpAST sets the bitmask for DumpAST debug flag", "docstring_tokens": ["DumpAST", "sets", "the", "bitmask", "for", "DumpAST", "debug", "flag"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/loader/loader.go#L13-L19", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pfs.go", "func_name": "FlushCommit", "original_string": "func (c APIClient) FlushCommit(commits []*pfs.Commit, toRepos []*pfs.Repo) (CommitInfoIterator, error) {\n\tctx, cancel := context.WithCancel(c.Ctx())\n\tstream, err := c.PfsAPIClient.FlushCommit(\n\t\tctx,\n\t\t&pfs.FlushCommitRequest{\n\t\t\tCommits: commits,\n\t\t\tToRepos: toRepos,\n\t\t},\n\t)\n\tif err != nil {\n\t\tcancel()\n\t\treturn nil, grpcutil.ScrubGRPC(err)\n\t}\n\treturn &commitInfoIterator{stream, cancel}, nil\n}", "language": "go", "code": "func (c APIClient) FlushCommit(commits []*pfs.Commit, toRepos []*pfs.Repo) (CommitInfoIterator, error) {\n\tctx, cancel := context.WithCancel(c.Ctx())\n\tstream, err := c.PfsAPIClient.FlushCommit(\n\t\tctx,\n\t\t&pfs.FlushCommitRequest{\n\t\t\tCommits: commits,\n\t\t\tToRepos: toRepos,\n\t\t},\n\t)\n\tif err != nil {\n\t\tcancel()\n\t\treturn nil, grpcutil.ScrubGRPC(err)\n\t}\n\treturn &commitInfoIterator{stream, cancel}, nil\n}", "code_tokens": ["func", "(", "c", "APIClient", ")", "FlushCommit", "(", "commits", "[", "]", "*", "pfs", ".", "Commit", ",", "toRepos", "[", "]", "*", "pfs", ".", "Repo", ")", "(", "CommitInfoIterator", ",", "error", ")", "{", "ctx", ",", "cancel", ":=", "context", ".", "WithCancel", "(", "c", ".", "Ctx", "(", ")", ")", "\n", "stream", ",", "err", ":=", "c", ".", "PfsAPIClient", ".", "FlushCommit", "(", "ctx", ",", "&", "pfs", ".", "FlushCommitRequest", "{", "Commits", ":", "commits", ",", "ToRepos", ":", "toRepos", ",", "}", ",", ")", "\n", "if", "err", "!=", "nil", "{", "cancel", "(", ")", "\n", "return", "nil", ",", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}", "\n", "return", "&", "commitInfoIterator", "{", "stream", ",", "cancel", "}", ",", "nil", "\n", "}"], "docstring": "// FlushCommit returns an iterator that returns commits that have the\n// specified `commits` as provenance.  Note that the iterator can block if\n// jobs have not successfully completed. This in effect waits for all of the\n// jobs that are triggered by a set of commits to complete.\n//\n// If toRepos is not nil then only the commits up to and including those\n// repos will be considered, otherwise all repos are considered.\n//\n// Note that it's never necessary to call FlushCommit to run jobs, they'll\n// run no matter what, FlushCommit just allows you to wait for them to\n// complete and see their output once they do.", "docstring_tokens": ["FlushCommit", "returns", "an", "iterator", "that", "returns", "commits", "that", "have", "the", "specified", "commits", "as", "provenance", ".", "Note", "that", "the", "iterator", "can", "block", "if", "jobs", "have", "not", "successfully", "completed", ".", "This", "in", "effect", "waits", "for", "all", "of", "the", "jobs", "that", "are", "triggered", "by", "a", "set", "of", "commits", "to", "complete", ".", "If", "toRepos", "is", "not", "nil", "then", "only", "the", "commits", "up", "to", "and", "including", "those", "repos", "will", "be", "considered", "otherwise", "all", "repos", "are", "considered", ".", "Note", "that", "it", "s", "never", "necessary", "to", "call", "FlushCommit", "to", "run", "jobs", "they", "ll", "run", "no", "matter", "what", "FlushCommit", "just", "allows", "you", "to", "wait", "for", "them", "to", "complete", "and", "see", "their", "output", "once", "they", "do", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L400-L414", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "domdebugger/domdebugger.go", "func_name": "Do", "original_string": "func (p *RemoveXHRBreakpointParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandRemoveXHRBreakpoint, p, nil)\n}", "language": "go", "code": "func (p *RemoveXHRBreakpointParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandRemoveXHRBreakpoint, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "RemoveXHRBreakpointParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandRemoveXHRBreakpoint", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes DOMDebugger.removeXHRBreakpoint against the provided context.", "docstring_tokens": ["Do", "executes", "DOMDebugger", ".", "removeXHRBreakpoint", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/domdebugger/domdebugger.go#L174-L176", "partition": "test"}
{"repo": "siddontang/go-log", "path": "log/filehandler.go", "func_name": "Close", "original_string": "func (h *RotatingFileHandler) Close() error {\n\tif h.fd != nil {\n\t\treturn h.fd.Close()\n\t}\n\treturn nil\n}", "language": "go", "code": "func (h *RotatingFileHandler) Close() error {\n\tif h.fd != nil {\n\t\treturn h.fd.Close()\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "h", "*", "RotatingFileHandler", ")", "Close", "(", ")", "error", "{", "if", "h", ".", "fd", "!=", "nil", "{", "return", "h", ".", "fd", ".", "Close", "(", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// Close implements Handler interface", "docstring_tokens": ["Close", "implements", "Handler", "interface"], "sha": "1e957dd83bed18c84716181da7b80d4af48eaefe", "url": "https://github.com/siddontang/go-log/blob/1e957dd83bed18c84716181da7b80d4af48eaefe/log/filehandler.go#L94-L99", "partition": "test"}
{"repo": "hashicorp/raft", "path": "raft.go", "func_name": "processLog", "original_string": "func (r *Raft) processLog(l *Log, future *logFuture) {\n\tswitch l.Type {\n\tcase LogBarrier:\n\t\t// Barrier is handled by the FSM\n\t\tfallthrough\n\n\tcase LogCommand:\n\t\t// Forward to the fsm handler\n\t\tselect {\n\t\tcase r.fsmMutateCh <- &commitTuple{l, future}:\n\t\tcase <-r.shutdownCh:\n\t\t\tif future != nil {\n\t\t\t\tfuture.respond(ErrRaftShutdown)\n\t\t\t}\n\t\t}\n\n\t\t// Return so that the future is only responded to\n\t\t// by the FSM handler when the application is done\n\t\treturn\n\n\tcase LogConfiguration:\n\tcase LogAddPeerDeprecated:\n\tcase LogRemovePeerDeprecated:\n\tcase LogNoop:\n\t\t// Ignore the no-op\n\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unrecognized log type: %#v\", l))\n\t}\n\n\t// Invoke the future if given\n\tif future != nil {\n\t\tfuture.respond(nil)\n\t}\n}", "language": "go", "code": "func (r *Raft) processLog(l *Log, future *logFuture) {\n\tswitch l.Type {\n\tcase LogBarrier:\n\t\t// Barrier is handled by the FSM\n\t\tfallthrough\n\n\tcase LogCommand:\n\t\t// Forward to the fsm handler\n\t\tselect {\n\t\tcase r.fsmMutateCh <- &commitTuple{l, future}:\n\t\tcase <-r.shutdownCh:\n\t\t\tif future != nil {\n\t\t\t\tfuture.respond(ErrRaftShutdown)\n\t\t\t}\n\t\t}\n\n\t\t// Return so that the future is only responded to\n\t\t// by the FSM handler when the application is done\n\t\treturn\n\n\tcase LogConfiguration:\n\tcase LogAddPeerDeprecated:\n\tcase LogRemovePeerDeprecated:\n\tcase LogNoop:\n\t\t// Ignore the no-op\n\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unrecognized log type: %#v\", l))\n\t}\n\n\t// Invoke the future if given\n\tif future != nil {\n\t\tfuture.respond(nil)\n\t}\n}", "code_tokens": ["func", "(", "r", "*", "Raft", ")", "processLog", "(", "l", "*", "Log", ",", "future", "*", "logFuture", ")", "{", "switch", "l", ".", "Type", "{", "case", "LogBarrier", ":", "// Barrier is handled by the FSM", "fallthrough", "\n\n", "case", "LogCommand", ":", "// Forward to the fsm handler", "select", "{", "case", "r", ".", "fsmMutateCh", "<-", "&", "commitTuple", "{", "l", ",", "future", "}", ":", "case", "<-", "r", ".", "shutdownCh", ":", "if", "future", "!=", "nil", "{", "future", ".", "respond", "(", "ErrRaftShutdown", ")", "\n", "}", "\n", "}", "\n\n", "// Return so that the future is only responded to", "// by the FSM handler when the application is done", "return", "\n\n", "case", "LogConfiguration", ":", "case", "LogAddPeerDeprecated", ":", "case", "LogRemovePeerDeprecated", ":", "case", "LogNoop", ":", "// Ignore the no-op", "default", ":", "panic", "(", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "l", ")", ")", "\n", "}", "\n\n", "// Invoke the future if given", "if", "future", "!=", "nil", "{", "future", ".", "respond", "(", "nil", ")", "\n", "}", "\n", "}"], "docstring": "// processLog is invoked to process the application of a single committed log entry.", "docstring_tokens": ["processLog", "is", "invoked", "to", "process", "the", "application", "of", "a", "single", "committed", "log", "entry", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/raft.go#L931-L965", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "peer.go", "func_name": "NumPendingOutbound", "original_string": "func (p *Peer) NumPendingOutbound() int {\n\tcount := 0\n\tp.RLock()\n\tfor _, c := range p.outboundConnections {\n\t\tcount += c.outbound.count()\n\t}\n\n\tfor _, c := range p.inboundConnections {\n\t\tcount += c.outbound.count()\n\t}\n\tp.RUnlock()\n\treturn count\n}", "language": "go", "code": "func (p *Peer) NumPendingOutbound() int {\n\tcount := 0\n\tp.RLock()\n\tfor _, c := range p.outboundConnections {\n\t\tcount += c.outbound.count()\n\t}\n\n\tfor _, c := range p.inboundConnections {\n\t\tcount += c.outbound.count()\n\t}\n\tp.RUnlock()\n\treturn count\n}", "code_tokens": ["func", "(", "p", "*", "Peer", ")", "NumPendingOutbound", "(", ")", "int", "{", "count", ":=", "0", "\n", "p", ".", "RLock", "(", ")", "\n", "for", "_", ",", "c", ":=", "range", "p", ".", "outboundConnections", "{", "count", "+=", "c", ".", "outbound", ".", "count", "(", ")", "\n", "}", "\n\n", "for", "_", ",", "c", ":=", "range", "p", ".", "inboundConnections", "{", "count", "+=", "c", ".", "outbound", ".", "count", "(", ")", "\n", "}", "\n", "p", ".", "RUnlock", "(", ")", "\n", "return", "count", "\n", "}"], "docstring": "// NumPendingOutbound returns the number of pending outbound calls.", "docstring_tokens": ["NumPendingOutbound", "returns", "the", "number", "of", "pending", "outbound", "calls", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/peer.go#L573-L585", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxc/config/file.go", "func_name": "SaveConfig", "original_string": "func (c *Config) SaveConfig(path string) error {\n\t// Create a new copy for the config file\n\tconf := Config{}\n\terr := shared.DeepCopy(c, &conf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to copy the configuration: %v\", err)\n\t}\n\n\t// Remove the static remotes\n\tfor k := range StaticRemotes {\n\t\tif k == \"local\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tdelete(conf.Remotes, k)\n\t}\n\n\t// Create the config file (or truncate an existing one)\n\tf, err := os.Create(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to create the configuration file: %v\", err)\n\t}\n\tdefer f.Close()\n\n\t// Write the new config\n\tdata, err := yaml.Marshal(conf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to marshal the configuration: %v\", err)\n\t}\n\n\t_, err = f.Write(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to write the configuration: %v\", err)\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *Config) SaveConfig(path string) error {\n\t// Create a new copy for the config file\n\tconf := Config{}\n\terr := shared.DeepCopy(c, &conf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to copy the configuration: %v\", err)\n\t}\n\n\t// Remove the static remotes\n\tfor k := range StaticRemotes {\n\t\tif k == \"local\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tdelete(conf.Remotes, k)\n\t}\n\n\t// Create the config file (or truncate an existing one)\n\tf, err := os.Create(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to create the configuration file: %v\", err)\n\t}\n\tdefer f.Close()\n\n\t// Write the new config\n\tdata, err := yaml.Marshal(conf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to marshal the configuration: %v\", err)\n\t}\n\n\t_, err = f.Write(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to write the configuration: %v\", err)\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Config", ")", "SaveConfig", "(", "path", "string", ")", "error", "{", "// Create a new copy for the config file", "conf", ":=", "Config", "{", "}", "\n", "err", ":=", "shared", ".", "DeepCopy", "(", "c", ",", "&", "conf", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "// Remove the static remotes", "for", "k", ":=", "range", "StaticRemotes", "{", "if", "k", "==", "\"", "\"", "{", "continue", "\n", "}", "\n\n", "delete", "(", "conf", ".", "Remotes", ",", "k", ")", "\n", "}", "\n\n", "// Create the config file (or truncate an existing one)", "f", ",", "err", ":=", "os", ".", "Create", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "defer", "f", ".", "Close", "(", ")", "\n\n", "// Write the new config", "data", ",", "err", ":=", "yaml", ".", "Marshal", "(", "conf", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "_", ",", "err", "=", "f", ".", "Write", "(", "data", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// SaveConfig writes the provided configuration to the config file.", "docstring_tokens": ["SaveConfig", "writes", "the", "provided", "configuration", "to", "the", "config", "file", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxc/config/file.go#L63-L99", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/storage_pools.go", "func_name": "StoragePoolVolumeSnapshotsGetType", "original_string": "func (c *Cluster) StoragePoolVolumeSnapshotsGetType(volumeName string, volumeType int, poolID int64) ([]string, error) {\n\tresult := []string{}\n\tregexp := volumeName + shared.SnapshotDelimiter\n\tlength := len(regexp)\n\n\tquery := \"SELECT name FROM storage_volumes WHERE storage_pool_id=? AND node_id=? AND type=? AND snapshot=? AND SUBSTR(name,1,?)=?\"\n\tinargs := []interface{}{poolID, c.nodeID, volumeType, true, length, regexp}\n\toutfmt := []interface{}{volumeName}\n\n\tdbResults, err := queryScan(c.db, query, inargs, outfmt)\n\tif err != nil {\n\t\treturn result, err\n\t}\n\n\tfor _, r := range dbResults {\n\t\tresult = append(result, r[0].(string))\n\t}\n\n\treturn result, nil\n}", "language": "go", "code": "func (c *Cluster) StoragePoolVolumeSnapshotsGetType(volumeName string, volumeType int, poolID int64) ([]string, error) {\n\tresult := []string{}\n\tregexp := volumeName + shared.SnapshotDelimiter\n\tlength := len(regexp)\n\n\tquery := \"SELECT name FROM storage_volumes WHERE storage_pool_id=? AND node_id=? AND type=? AND snapshot=? AND SUBSTR(name,1,?)=?\"\n\tinargs := []interface{}{poolID, c.nodeID, volumeType, true, length, regexp}\n\toutfmt := []interface{}{volumeName}\n\n\tdbResults, err := queryScan(c.db, query, inargs, outfmt)\n\tif err != nil {\n\t\treturn result, err\n\t}\n\n\tfor _, r := range dbResults {\n\t\tresult = append(result, r[0].(string))\n\t}\n\n\treturn result, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "StoragePoolVolumeSnapshotsGetType", "(", "volumeName", "string", ",", "volumeType", "int", ",", "poolID", "int64", ")", "(", "[", "]", "string", ",", "error", ")", "{", "result", ":=", "[", "]", "string", "{", "}", "\n", "regexp", ":=", "volumeName", "+", "shared", ".", "SnapshotDelimiter", "\n", "length", ":=", "len", "(", "regexp", ")", "\n\n", "query", ":=", "\"", "\"", "\n", "inargs", ":=", "[", "]", "interface", "{", "}", "{", "poolID", ",", "c", ".", "nodeID", ",", "volumeType", ",", "true", ",", "length", ",", "regexp", "}", "\n", "outfmt", ":=", "[", "]", "interface", "{", "}", "{", "volumeName", "}", "\n\n", "dbResults", ",", "err", ":=", "queryScan", "(", "c", ".", "db", ",", "query", ",", "inargs", ",", "outfmt", ")", "\n", "if", "err", "!=", "nil", "{", "return", "result", ",", "err", "\n", "}", "\n\n", "for", "_", ",", "r", ":=", "range", "dbResults", "{", "result", "=", "append", "(", "result", ",", "r", "[", "0", "]", ".", "(", "string", ")", ")", "\n", "}", "\n\n", "return", "result", ",", "nil", "\n", "}"], "docstring": "// StoragePoolVolumeSnapshotsGetType get all snapshots of a storage volume\n// attached to a given storage pool of a given volume type, on the given node.", "docstring_tokens": ["StoragePoolVolumeSnapshotsGetType", "get", "all", "snapshots", "of", "a", "storage", "volume", "attached", "to", "a", "given", "storage", "pool", "of", "a", "given", "volume", "type", "on", "the", "given", "node", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/storage_pools.go#L779-L798", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "gcsweb/cmd/gcsweb/gcsweb.go", "func_name": "parseXML", "original_string": "func parseXML(body []byte, object string) (*gcsDir, error) {\n\tdir := new(gcsDir)\n\tif err := xml.Unmarshal(body, &dir); err != nil {\n\t\treturn nil, err\n\t}\n\t// We think this is a dir if the object is \"/\" (just the bucket) or if we\n\t// find any Contents or CommonPrefixes.\n\tisDir := object == \"/\" || len(dir.Contents)+len(dir.CommonPrefixes) > 0\n\tselfIndex := -1\n\tfor i := range dir.Contents {\n\t\trec := &dir.Contents[i]\n\t\tname := strings.TrimPrefix(rec.Name, object)\n\t\tif name == \"\" {\n\t\t\tselfIndex = i\n\t\t\tcontinue\n\t\t}\n\t\trec.Name = name\n\t\tif strings.HasSuffix(name, \"/\") {\n\t\t\trec.isDir = true\n\t\t}\n\t}\n\n\tfor i := range dir.CommonPrefixes {\n\t\tcp := &dir.CommonPrefixes[i]\n\t\tcp.Prefix = strings.TrimPrefix(cp.Prefix, object)\n\t}\n\n\tif !isDir {\n\t\treturn nil, nil\n\t}\n\n\tif selfIndex >= 0 {\n\t\t// Strip out the record that indicates this object.\n\t\tdir.Contents = append(dir.Contents[:selfIndex], dir.Contents[selfIndex+1:]...)\n\t}\n\treturn dir, nil\n}", "language": "go", "code": "func parseXML(body []byte, object string) (*gcsDir, error) {\n\tdir := new(gcsDir)\n\tif err := xml.Unmarshal(body, &dir); err != nil {\n\t\treturn nil, err\n\t}\n\t// We think this is a dir if the object is \"/\" (just the bucket) or if we\n\t// find any Contents or CommonPrefixes.\n\tisDir := object == \"/\" || len(dir.Contents)+len(dir.CommonPrefixes) > 0\n\tselfIndex := -1\n\tfor i := range dir.Contents {\n\t\trec := &dir.Contents[i]\n\t\tname := strings.TrimPrefix(rec.Name, object)\n\t\tif name == \"\" {\n\t\t\tselfIndex = i\n\t\t\tcontinue\n\t\t}\n\t\trec.Name = name\n\t\tif strings.HasSuffix(name, \"/\") {\n\t\t\trec.isDir = true\n\t\t}\n\t}\n\n\tfor i := range dir.CommonPrefixes {\n\t\tcp := &dir.CommonPrefixes[i]\n\t\tcp.Prefix = strings.TrimPrefix(cp.Prefix, object)\n\t}\n\n\tif !isDir {\n\t\treturn nil, nil\n\t}\n\n\tif selfIndex >= 0 {\n\t\t// Strip out the record that indicates this object.\n\t\tdir.Contents = append(dir.Contents[:selfIndex], dir.Contents[selfIndex+1:]...)\n\t}\n\treturn dir, nil\n}", "code_tokens": ["func", "parseXML", "(", "body", "[", "]", "byte", ",", "object", "string", ")", "(", "*", "gcsDir", ",", "error", ")", "{", "dir", ":=", "new", "(", "gcsDir", ")", "\n", "if", "err", ":=", "xml", ".", "Unmarshal", "(", "body", ",", "&", "dir", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "// We think this is a dir if the object is \"/\" (just the bucket) or if we", "// find any Contents or CommonPrefixes.", "isDir", ":=", "object", "==", "\"", "\"", "||", "len", "(", "dir", ".", "Contents", ")", "+", "len", "(", "dir", ".", "CommonPrefixes", ")", ">", "0", "\n", "selfIndex", ":=", "-", "1", "\n", "for", "i", ":=", "range", "dir", ".", "Contents", "{", "rec", ":=", "&", "dir", ".", "Contents", "[", "i", "]", "\n", "name", ":=", "strings", ".", "TrimPrefix", "(", "rec", ".", "Name", ",", "object", ")", "\n", "if", "name", "==", "\"", "\"", "{", "selfIndex", "=", "i", "\n", "continue", "\n", "}", "\n", "rec", ".", "Name", "=", "name", "\n", "if", "strings", ".", "HasSuffix", "(", "name", ",", "\"", "\"", ")", "{", "rec", ".", "isDir", "=", "true", "\n", "}", "\n", "}", "\n\n", "for", "i", ":=", "range", "dir", ".", "CommonPrefixes", "{", "cp", ":=", "&", "dir", ".", "CommonPrefixes", "[", "i", "]", "\n", "cp", ".", "Prefix", "=", "strings", ".", "TrimPrefix", "(", "cp", ".", "Prefix", ",", "object", ")", "\n", "}", "\n\n", "if", "!", "isDir", "{", "return", "nil", ",", "nil", "\n", "}", "\n\n", "if", "selfIndex", ">=", "0", "{", "// Strip out the record that indicates this object.", "dir", ".", "Contents", "=", "append", "(", "dir", ".", "Contents", "[", ":", "selfIndex", "]", ",", "dir", ".", "Contents", "[", "selfIndex", "+", "1", ":", "]", "...", ")", "\n", "}", "\n", "return", "dir", ",", "nil", "\n", "}"], "docstring": "// parseXML extracts a gcsDir object from XML.  If this returns a nil gcsDir,\n// the XML indicated that this was not a directory at all.", "docstring_tokens": ["parseXML", "extracts", "a", "gcsDir", "object", "from", "XML", ".", "If", "this", "returns", "a", "nil", "gcsDir", "the", "XML", "indicated", "that", "this", "was", "not", "a", "directory", "at", "all", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/gcsweb/cmd/gcsweb/gcsweb.go#L297-L333", "partition": "test"}
{"repo": "rightscale/rsc", "path": "gen/praxisgen/helpers.go", "func_name": "isBuiltInType", "original_string": "func isBuiltInType(name string) bool {\n\tfor _, n := range BuiltInTypes {\n\t\tif name == n {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "language": "go", "code": "func isBuiltInType(name string) bool {\n\tfor _, n := range BuiltInTypes {\n\t\tif name == n {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "code_tokens": ["func", "isBuiltInType", "(", "name", "string", ")", "bool", "{", "for", "_", ",", "n", ":=", "range", "BuiltInTypes", "{", "if", "name", "==", "n", "{", "return", "true", "\n", "}", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// Returns true if given name is the name of a built-in type", "docstring_tokens": ["Returns", "true", "if", "given", "name", "is", "the", "name", "of", "a", "built", "-", "in", "type"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/praxisgen/helpers.go#L91-L98", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "provision/kubernetes/pkg/apis/tsuru/v1/zz_generated.deepcopy.go", "func_name": "DeepCopy", "original_string": "func (in *App) DeepCopy() *App {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(App)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "language": "go", "code": "func (in *App) DeepCopy() *App {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(App)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "code_tokens": ["func", "(", "in", "*", "App", ")", "DeepCopy", "(", ")", "*", "App", "{", "if", "in", "==", "nil", "{", "return", "nil", "\n", "}", "\n", "out", ":=", "new", "(", "App", ")", "\n", "in", ".", "DeepCopyInto", "(", "out", ")", "\n", "return", "out", "\n", "}"], "docstring": "// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new App.", "docstring_tokens": ["DeepCopy", "is", "an", "autogenerated", "deepcopy", "function", "copying", "the", "receiver", "creating", "a", "new", "App", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/kubernetes/pkg/apis/tsuru/v1/zz_generated.deepcopy.go#L25-L32", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/cert/logging_conn.go", "func_name": "newLoggingPipe", "original_string": "func newLoggingPipe() *loggingPipe {\n\tp := &loggingPipe{}\n\tp.clientReader, p.clientWriter = io.Pipe()\n\tp.clientReader = io.TeeReader(p.clientReader, &p.ServerToClientBuf)\n\tp.serverReader, p.serverWriter = io.Pipe()\n\tp.serverReader = io.TeeReader(p.serverReader, &p.ClientToServerBuf)\n\treturn p\n}", "language": "go", "code": "func newLoggingPipe() *loggingPipe {\n\tp := &loggingPipe{}\n\tp.clientReader, p.clientWriter = io.Pipe()\n\tp.clientReader = io.TeeReader(p.clientReader, &p.ServerToClientBuf)\n\tp.serverReader, p.serverWriter = io.Pipe()\n\tp.serverReader = io.TeeReader(p.serverReader, &p.ClientToServerBuf)\n\treturn p\n}", "code_tokens": ["func", "newLoggingPipe", "(", ")", "*", "loggingPipe", "{", "p", ":=", "&", "loggingPipe", "{", "}", "\n", "p", ".", "clientReader", ",", "p", ".", "clientWriter", "=", "io", ".", "Pipe", "(", ")", "\n", "p", ".", "clientReader", "=", "io", ".", "TeeReader", "(", "p", ".", "clientReader", ",", "&", "p", ".", "ServerToClientBuf", ")", "\n", "p", ".", "serverReader", ",", "p", ".", "serverWriter", "=", "io", ".", "Pipe", "(", ")", "\n", "p", ".", "serverReader", "=", "io", ".", "TeeReader", "(", "p", ".", "serverReader", ",", "&", "p", ".", "ClientToServerBuf", ")", "\n", "return", "p", "\n", "}"], "docstring": "// newLoggingPipe initializes a loggingPipe", "docstring_tokens": ["newLoggingPipe", "initializes", "a", "loggingPipe"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/cert/logging_conn.go#L40-L47", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "outbound.go", "func_name": "handleCallRes", "original_string": "func (c *Connection) handleCallRes(frame *Frame) bool {\n\tif err := c.outbound.forwardPeerFrame(frame); err != nil {\n\t\treturn true\n\t}\n\treturn false\n}", "language": "go", "code": "func (c *Connection) handleCallRes(frame *Frame) bool {\n\tif err := c.outbound.forwardPeerFrame(frame); err != nil {\n\t\treturn true\n\t}\n\treturn false\n}", "code_tokens": ["func", "(", "c", "*", "Connection", ")", "handleCallRes", "(", "frame", "*", "Frame", ")", "bool", "{", "if", "err", ":=", "c", ".", "outbound", ".", "forwardPeerFrame", "(", "frame", ")", ";", "err", "!=", "nil", "{", "return", "true", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// handleCallRes handles an incoming call req message, forwarding the\n// frame to the response channel waiting for it", "docstring_tokens": ["handleCallRes", "handles", "an", "incoming", "call", "req", "message", "forwarding", "the", "frame", "to", "the", "response", "channel", "waiting", "for", "it"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/outbound.go#L142-L147", "partition": "test"}
{"repo": "akutz/gotil", "path": "gotil.go", "func_name": "HomeDir", "original_string": "func HomeDir() string {\n\tif homeDirSet {\n\t\treturn homeDir\n\t}\n\tif user, err := user.Current(); err == nil {\n\t\thomeDir = user.HomeDir\n\t}\n\thomeDirSet = true\n\treturn homeDir\n}", "language": "go", "code": "func HomeDir() string {\n\tif homeDirSet {\n\t\treturn homeDir\n\t}\n\tif user, err := user.Current(); err == nil {\n\t\thomeDir = user.HomeDir\n\t}\n\thomeDirSet = true\n\treturn homeDir\n}", "code_tokens": ["func", "HomeDir", "(", ")", "string", "{", "if", "homeDirSet", "{", "return", "homeDir", "\n", "}", "\n", "if", "user", ",", "err", ":=", "user", ".", "Current", "(", ")", ";", "err", "==", "nil", "{", "homeDir", "=", "user", ".", "HomeDir", "\n", "}", "\n", "homeDirSet", "=", "true", "\n", "return", "homeDir", "\n", "}"], "docstring": "// HomeDir returns the home directory of the user that owns the current process.", "docstring_tokens": ["HomeDir", "returns", "the", "home", "directory", "of", "the", "user", "that", "owns", "the", "current", "process", "."], "sha": "6fa2e80bd3ac40f15788cfc3d12ebba49a0add92", "url": "https://github.com/akutz/gotil/blob/6fa2e80bd3ac40f15788cfc3d12ebba49a0add92/gotil.go#L273-L282", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "db.go", "func_name": "writeRequests", "original_string": "func (db *DB) writeRequests(reqs []*request) error {\n\tif len(reqs) == 0 {\n\t\treturn nil\n\t}\n\n\tdone := func(err error) {\n\t\tfor _, r := range reqs {\n\t\t\tr.Err = err\n\t\t\tr.Wg.Done()\n\t\t}\n\t}\n\tdb.elog.Printf(\"writeRequests called. Writing to value log\")\n\n\terr := db.vlog.write(reqs)\n\tif err != nil {\n\t\tdone(err)\n\t\treturn err\n\t}\n\n\tdb.elog.Printf(\"Writing to memtable\")\n\tvar count int\n\tfor _, b := range reqs {\n\t\tif len(b.Entries) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tcount += len(b.Entries)\n\t\tvar i uint64\n\t\tfor err = db.ensureRoomForWrite(); err == errNoRoom; err = db.ensureRoomForWrite() {\n\t\t\ti++\n\t\t\tif i%100 == 0 {\n\t\t\t\tdb.elog.Printf(\"Making room for writes\")\n\t\t\t}\n\t\t\t// We need to poll a bit because both hasRoomForWrite and the flusher need access to s.imm.\n\t\t\t// When flushChan is full and you are blocked there, and the flusher is trying to update s.imm,\n\t\t\t// you will get a deadlock.\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t\tif err != nil {\n\t\t\tdone(err)\n\t\t\treturn errors.Wrap(err, \"writeRequests\")\n\t\t}\n\t\tif err := db.writeToLSM(b); err != nil {\n\t\t\tdone(err)\n\t\t\treturn errors.Wrap(err, \"writeRequests\")\n\t\t}\n\t\tdb.updateHead(b.Ptrs)\n\t}\n\tdone(nil)\n\tdb.elog.Printf(\"%d entries written\", count)\n\treturn nil\n}", "language": "go", "code": "func (db *DB) writeRequests(reqs []*request) error {\n\tif len(reqs) == 0 {\n\t\treturn nil\n\t}\n\n\tdone := func(err error) {\n\t\tfor _, r := range reqs {\n\t\t\tr.Err = err\n\t\t\tr.Wg.Done()\n\t\t}\n\t}\n\tdb.elog.Printf(\"writeRequests called. Writing to value log\")\n\n\terr := db.vlog.write(reqs)\n\tif err != nil {\n\t\tdone(err)\n\t\treturn err\n\t}\n\n\tdb.elog.Printf(\"Writing to memtable\")\n\tvar count int\n\tfor _, b := range reqs {\n\t\tif len(b.Entries) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tcount += len(b.Entries)\n\t\tvar i uint64\n\t\tfor err = db.ensureRoomForWrite(); err == errNoRoom; err = db.ensureRoomForWrite() {\n\t\t\ti++\n\t\t\tif i%100 == 0 {\n\t\t\t\tdb.elog.Printf(\"Making room for writes\")\n\t\t\t}\n\t\t\t// We need to poll a bit because both hasRoomForWrite and the flusher need access to s.imm.\n\t\t\t// When flushChan is full and you are blocked there, and the flusher is trying to update s.imm,\n\t\t\t// you will get a deadlock.\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t\tif err != nil {\n\t\t\tdone(err)\n\t\t\treturn errors.Wrap(err, \"writeRequests\")\n\t\t}\n\t\tif err := db.writeToLSM(b); err != nil {\n\t\t\tdone(err)\n\t\t\treturn errors.Wrap(err, \"writeRequests\")\n\t\t}\n\t\tdb.updateHead(b.Ptrs)\n\t}\n\tdone(nil)\n\tdb.elog.Printf(\"%d entries written\", count)\n\treturn nil\n}", "code_tokens": ["func", "(", "db", "*", "DB", ")", "writeRequests", "(", "reqs", "[", "]", "*", "request", ")", "error", "{", "if", "len", "(", "reqs", ")", "==", "0", "{", "return", "nil", "\n", "}", "\n\n", "done", ":=", "func", "(", "err", "error", ")", "{", "for", "_", ",", "r", ":=", "range", "reqs", "{", "r", ".", "Err", "=", "err", "\n", "r", ".", "Wg", ".", "Done", "(", ")", "\n", "}", "\n", "}", "\n", "db", ".", "elog", ".", "Printf", "(", "\"", "\"", ")", "\n\n", "err", ":=", "db", ".", "vlog", ".", "write", "(", "reqs", ")", "\n", "if", "err", "!=", "nil", "{", "done", "(", "err", ")", "\n", "return", "err", "\n", "}", "\n\n", "db", ".", "elog", ".", "Printf", "(", "\"", "\"", ")", "\n", "var", "count", "int", "\n", "for", "_", ",", "b", ":=", "range", "reqs", "{", "if", "len", "(", "b", ".", "Entries", ")", "==", "0", "{", "continue", "\n", "}", "\n", "count", "+=", "len", "(", "b", ".", "Entries", ")", "\n", "var", "i", "uint64", "\n", "for", "err", "=", "db", ".", "ensureRoomForWrite", "(", ")", ";", "err", "==", "errNoRoom", ";", "err", "=", "db", ".", "ensureRoomForWrite", "(", ")", "{", "i", "++", "\n", "if", "i", "%", "100", "==", "0", "{", "db", ".", "elog", ".", "Printf", "(", "\"", "\"", ")", "\n", "}", "\n", "// We need to poll a bit because both hasRoomForWrite and the flusher need access to s.imm.", "// When flushChan is full and you are blocked there, and the flusher is trying to update s.imm,", "// you will get a deadlock.", "time", ".", "Sleep", "(", "10", "*", "time", ".", "Millisecond", ")", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "done", "(", "err", ")", "\n", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "if", "err", ":=", "db", ".", "writeToLSM", "(", "b", ")", ";", "err", "!=", "nil", "{", "done", "(", "err", ")", "\n", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "db", ".", "updateHead", "(", "b", ".", "Ptrs", ")", "\n", "}", "\n", "done", "(", "nil", ")", "\n", "db", ".", "elog", ".", "Printf", "(", "\"", "\"", ",", "count", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// writeRequests is called serially by only one goroutine.", "docstring_tokens": ["writeRequests", "is", "called", "serially", "by", "only", "one", "goroutine", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/db.go#L589-L639", "partition": "test"}
{"repo": "rightscale/rsc", "path": "gen/api15gen/api_analyzer.go", "func_name": "Analyze", "original_string": "func (a *APIAnalyzer) Analyze() *gen.APIDescriptor {\n\ta.AnalyzeAliases()\n\tvar descriptor = &gen.APIDescriptor{\n\t\tResources: make(map[string]*gen.Resource),\n\t\tTypes:     make(map[string]*gen.ObjectDataType),\n\t}\n\tvar rawResourceNames = make([]string, len(a.rawResources))\n\tvar idx = 0\n\tfor n := range a.rawResources {\n\t\trawResourceNames[idx] = n\n\t\tidx++\n\t}\n\tsort.Strings(rawResourceNames)\n\tfor _, name := range rawResourceNames {\n\t\tvar resource = a.rawResources[name]\n\t\ta.AnalyzeResource(name, resource, descriptor)\n\t}\n\tdescriptor.FinalizeTypeNames(a.rawTypes)\n\treturn descriptor\n}", "language": "go", "code": "func (a *APIAnalyzer) Analyze() *gen.APIDescriptor {\n\ta.AnalyzeAliases()\n\tvar descriptor = &gen.APIDescriptor{\n\t\tResources: make(map[string]*gen.Resource),\n\t\tTypes:     make(map[string]*gen.ObjectDataType),\n\t}\n\tvar rawResourceNames = make([]string, len(a.rawResources))\n\tvar idx = 0\n\tfor n := range a.rawResources {\n\t\trawResourceNames[idx] = n\n\t\tidx++\n\t}\n\tsort.Strings(rawResourceNames)\n\tfor _, name := range rawResourceNames {\n\t\tvar resource = a.rawResources[name]\n\t\ta.AnalyzeResource(name, resource, descriptor)\n\t}\n\tdescriptor.FinalizeTypeNames(a.rawTypes)\n\treturn descriptor\n}", "code_tokens": ["func", "(", "a", "*", "APIAnalyzer", ")", "Analyze", "(", ")", "*", "gen", ".", "APIDescriptor", "{", "a", ".", "AnalyzeAliases", "(", ")", "\n", "var", "descriptor", "=", "&", "gen", ".", "APIDescriptor", "{", "Resources", ":", "make", "(", "map", "[", "string", "]", "*", "gen", ".", "Resource", ")", ",", "Types", ":", "make", "(", "map", "[", "string", "]", "*", "gen", ".", "ObjectDataType", ")", ",", "}", "\n", "var", "rawResourceNames", "=", "make", "(", "[", "]", "string", ",", "len", "(", "a", ".", "rawResources", ")", ")", "\n", "var", "idx", "=", "0", "\n", "for", "n", ":=", "range", "a", ".", "rawResources", "{", "rawResourceNames", "[", "idx", "]", "=", "n", "\n", "idx", "++", "\n", "}", "\n", "sort", ".", "Strings", "(", "rawResourceNames", ")", "\n", "for", "_", ",", "name", ":=", "range", "rawResourceNames", "{", "var", "resource", "=", "a", ".", "rawResources", "[", "name", "]", "\n", "a", ".", "AnalyzeResource", "(", "name", ",", "resource", ",", "descriptor", ")", "\n", "}", "\n", "descriptor", ".", "FinalizeTypeNames", "(", "a", ".", "rawTypes", ")", "\n", "return", "descriptor", "\n", "}"], "docstring": "// Analyze iterate through all resources and initializes the Resources and ParamTypes fields of\n// the APIAnalyzer struct accordingly.", "docstring_tokens": ["Analyze", "iterate", "through", "all", "resources", "and", "initializes", "the", "Resources", "and", "ParamTypes", "fields", "of", "the", "APIAnalyzer", "struct", "accordingly", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/api15gen/api_analyzer.go#L49-L68", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "boskos/crds/client.go", "func_name": "Client", "original_string": "func (o *KubernetesClientOptions) Client(t Type) (ClientInterface, error) {\n\tif o.inMemory {\n\t\treturn newDummyClient(t), nil\n\t}\n\treturn o.newCRDClient(t)\n}", "language": "go", "code": "func (o *KubernetesClientOptions) Client(t Type) (ClientInterface, error) {\n\tif o.inMemory {\n\t\treturn newDummyClient(t), nil\n\t}\n\treturn o.newCRDClient(t)\n}", "code_tokens": ["func", "(", "o", "*", "KubernetesClientOptions", ")", "Client", "(", "t", "Type", ")", "(", "ClientInterface", ",", "error", ")", "{", "if", "o", ".", "inMemory", "{", "return", "newDummyClient", "(", "t", ")", ",", "nil", "\n", "}", "\n", "return", "o", ".", "newCRDClient", "(", "t", ")", "\n", "}"], "docstring": "// Client returns a ClientInterface based on the flags provided.", "docstring_tokens": ["Client", "returns", "a", "ClientInterface", "based", "on", "the", "flags", "provided", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/crds/client.go#L67-L72", "partition": "test"}
{"repo": "golang/appengine", "path": "channel/channel.go", "func_name": "Send", "original_string": "func Send(c context.Context, clientID, message string) error {\n\treq := &pb.SendMessageRequest{\n\t\tApplicationKey: &clientID,\n\t\tMessage:        &message,\n\t}\n\tresp := &basepb.VoidProto{}\n\treturn remapError(internal.Call(c, service, \"SendChannelMessage\", req, resp))\n}", "language": "go", "code": "func Send(c context.Context, clientID, message string) error {\n\treq := &pb.SendMessageRequest{\n\t\tApplicationKey: &clientID,\n\t\tMessage:        &message,\n\t}\n\tresp := &basepb.VoidProto{}\n\treturn remapError(internal.Call(c, service, \"SendChannelMessage\", req, resp))\n}", "code_tokens": ["func", "Send", "(", "c", "context", ".", "Context", ",", "clientID", ",", "message", "string", ")", "error", "{", "req", ":=", "&", "pb", ".", "SendMessageRequest", "{", "ApplicationKey", ":", "&", "clientID", ",", "Message", ":", "&", "message", ",", "}", "\n", "resp", ":=", "&", "basepb", ".", "VoidProto", "{", "}", "\n", "return", "remapError", "(", "internal", ".", "Call", "(", "c", ",", "service", ",", "\"", "\"", ",", "req", ",", "resp", ")", ")", "\n", "}"], "docstring": "// Send sends a message on the channel associated with clientID.", "docstring_tokens": ["Send", "sends", "a", "message", "on", "the", "channel", "associated", "with", "clientID", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/channel/channel.go#L51-L58", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "runtime/runtime.go", "func_name": "Do", "original_string": "func (p *ReleaseObjectGroupParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandReleaseObjectGroup, p, nil)\n}", "language": "go", "code": "func (p *ReleaseObjectGroupParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandReleaseObjectGroup, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "ReleaseObjectGroupParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandReleaseObjectGroup", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Runtime.releaseObjectGroup against the provided context.", "docstring_tokens": ["Do", "executes", "Runtime", ".", "releaseObjectGroup", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/runtime.go#L674-L676", "partition": "test"}
{"repo": "libp2p/go-libp2p-pubsub", "path": "pubsub.go", "func_name": "Subscribe", "original_string": "func (p *PubSub) Subscribe(topic string, opts ...SubOpt) (*Subscription, error) {\n\ttd := pb.TopicDescriptor{Name: &topic}\n\n\treturn p.SubscribeByTopicDescriptor(&td, opts...)\n}", "language": "go", "code": "func (p *PubSub) Subscribe(topic string, opts ...SubOpt) (*Subscription, error) {\n\ttd := pb.TopicDescriptor{Name: &topic}\n\n\treturn p.SubscribeByTopicDescriptor(&td, opts...)\n}", "code_tokens": ["func", "(", "p", "*", "PubSub", ")", "Subscribe", "(", "topic", "string", ",", "opts", "...", "SubOpt", ")", "(", "*", "Subscription", ",", "error", ")", "{", "td", ":=", "pb", ".", "TopicDescriptor", "{", "Name", ":", "&", "topic", "}", "\n\n", "return", "p", ".", "SubscribeByTopicDescriptor", "(", "&", "td", ",", "opts", "...", ")", "\n", "}"], "docstring": "// Subscribe returns a new Subscription for the given topic.\n// Note that subscription is not an instanteneous operation. It may take some time\n// before the subscription is processed by the pubsub main loop and propagated to our peers.", "docstring_tokens": ["Subscribe", "returns", "a", "new", "Subscription", "for", "the", "given", "topic", ".", "Note", "that", "subscription", "is", "not", "an", "instanteneous", "operation", ".", "It", "may", "take", "some", "time", "before", "the", "subscription", "is", "processed", "by", "the", "pubsub", "main", "loop", "and", "propagated", "to", "our", "peers", "."], "sha": "9db3dbdde90f44d1c420192c5cefd60682fbdbb9", "url": "https://github.com/libp2p/go-libp2p-pubsub/blob/9db3dbdde90f44d1c420192c5cefd60682fbdbb9/pubsub.go#L785-L789", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/tide/history/history.go", "func_name": "New", "original_string": "func New(maxRecordsPerKey int, opener io.Opener, path string) (*History, error) {\n\thist := &History{\n\t\tlogs:         map[string]*recordLog{},\n\t\tlogSizeLimit: maxRecordsPerKey,\n\t\topener:       opener,\n\t\tpath:         path,\n\t}\n\n\tif path != \"\" {\n\t\t// Load existing history from GCS.\n\t\tvar err error\n\t\tstart := time.Now()\n\t\thist.logs, err = readHistory(maxRecordsPerKey, hist.opener, hist.path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"duration\": time.Since(start).String(),\n\t\t\t\"path\":     hist.path,\n\t\t}).Debugf(\"Successfully read action history for %d pools.\", len(hist.logs))\n\t}\n\n\treturn hist, nil\n}", "language": "go", "code": "func New(maxRecordsPerKey int, opener io.Opener, path string) (*History, error) {\n\thist := &History{\n\t\tlogs:         map[string]*recordLog{},\n\t\tlogSizeLimit: maxRecordsPerKey,\n\t\topener:       opener,\n\t\tpath:         path,\n\t}\n\n\tif path != \"\" {\n\t\t// Load existing history from GCS.\n\t\tvar err error\n\t\tstart := time.Now()\n\t\thist.logs, err = readHistory(maxRecordsPerKey, hist.opener, hist.path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"duration\": time.Since(start).String(),\n\t\t\t\"path\":     hist.path,\n\t\t}).Debugf(\"Successfully read action history for %d pools.\", len(hist.logs))\n\t}\n\n\treturn hist, nil\n}", "code_tokens": ["func", "New", "(", "maxRecordsPerKey", "int", ",", "opener", "io", ".", "Opener", ",", "path", "string", ")", "(", "*", "History", ",", "error", ")", "{", "hist", ":=", "&", "History", "{", "logs", ":", "map", "[", "string", "]", "*", "recordLog", "{", "}", ",", "logSizeLimit", ":", "maxRecordsPerKey", ",", "opener", ":", "opener", ",", "path", ":", "path", ",", "}", "\n\n", "if", "path", "!=", "\"", "\"", "{", "// Load existing history from GCS.", "var", "err", "error", "\n", "start", ":=", "time", ".", "Now", "(", ")", "\n", "hist", ".", "logs", ",", "err", "=", "readHistory", "(", "maxRecordsPerKey", ",", "hist", ".", "opener", ",", "hist", ".", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "logrus", ".", "WithFields", "(", "logrus", ".", "Fields", "{", "\"", "\"", ":", "time", ".", "Since", "(", "start", ")", ".", "String", "(", ")", ",", "\"", "\"", ":", "hist", ".", "path", ",", "}", ")", ".", "Debugf", "(", "\"", "\"", ",", "len", "(", "hist", ".", "logs", ")", ")", "\n", "}", "\n\n", "return", "hist", ",", "nil", "\n", "}"], "docstring": "// New creates a new History struct with the specificed recordLog size limit.", "docstring_tokens": ["New", "creates", "a", "new", "History", "struct", "with", "the", "specificed", "recordLog", "size", "limit", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/tide/history/history.go#L114-L137", "partition": "test"}
{"repo": "kljensen/snowball", "path": "russian/step4.go", "func_name": "step4", "original_string": "func step4(word *snowballword.SnowballWord) bool {\n\n\t// (1) Undouble \"\u043d\", or, 2) if the word ends with a SUPERLATIVE ending,\n\t// (remove it and undouble \u043d n), or 3) if the word ends \u044c (') (soft sign)\n\t// remove it.\n\n\t// Undouble \"\u043d\"\n\tif word.HasSuffixRunes([]rune(\"\u043d\u043d\")) {\n\t\tword.RemoveLastNRunes(1)\n\t\treturn true\n\t}\n\n\t// Remove superlative endings\n\tsuffix, _ := word.RemoveFirstSuffix(\"\u0435\u0439\u0448\u0435\", \"\u0435\u0439\u0448\")\n\tif suffix != \"\" {\n\t\t// Undouble \"\u043d\"\n\t\tif word.HasSuffixRunes([]rune(\"\u043d\u043d\")) {\n\t\t\tword.RemoveLastNRunes(1)\n\t\t}\n\t\treturn true\n\t}\n\n\t// Remove soft sign\n\tif rsLen := len(word.RS); rsLen > 0 && word.RS[rsLen-1] == '\u044c' {\n\t\tword.RemoveLastNRunes(1)\n\t\treturn true\n\t}\n\treturn false\n}", "language": "go", "code": "func step4(word *snowballword.SnowballWord) bool {\n\n\t// (1) Undouble \"\u043d\", or, 2) if the word ends with a SUPERLATIVE ending,\n\t// (remove it and undouble \u043d n), or 3) if the word ends \u044c (') (soft sign)\n\t// remove it.\n\n\t// Undouble \"\u043d\"\n\tif word.HasSuffixRunes([]rune(\"\u043d\u043d\")) {\n\t\tword.RemoveLastNRunes(1)\n\t\treturn true\n\t}\n\n\t// Remove superlative endings\n\tsuffix, _ := word.RemoveFirstSuffix(\"\u0435\u0439\u0448\u0435\", \"\u0435\u0439\u0448\")\n\tif suffix != \"\" {\n\t\t// Undouble \"\u043d\"\n\t\tif word.HasSuffixRunes([]rune(\"\u043d\u043d\")) {\n\t\t\tword.RemoveLastNRunes(1)\n\t\t}\n\t\treturn true\n\t}\n\n\t// Remove soft sign\n\tif rsLen := len(word.RS); rsLen > 0 && word.RS[rsLen-1] == '\u044c' {\n\t\tword.RemoveLastNRunes(1)\n\t\treturn true\n\t}\n\treturn false\n}", "code_tokens": ["func", "step4", "(", "word", "*", "snowballword", ".", "SnowballWord", ")", "bool", "{", "// (1) Undouble \"\u043d\", or, 2) if the word ends with a SUPERLATIVE ending,", "// (remove it and undouble \u043d n), or 3) if the word ends \u044c (') (soft sign)", "// remove it.", "// Undouble \"\u043d\"", "if", "word", ".", "HasSuffixRunes", "(", "[", "]", "rune", "(", "\"", ")", " ", "{", "", "word", ".", "RemoveLastNRunes", "(", "1", ")", "\n", "return", "true", "\n", "}", "\n\n", "// Remove superlative endings", "suffix", ",", "_", ":=", "word", ".", "RemoveFirstSuffix", "(", "\"", "\u0435", "\u0439", "\"", "", "", "\n", "if", "suffix", "!=", "\"", "\"", "{", "// Undouble \"\u043d\"", "if", "word", ".", "HasSuffixRunes", "(", "[", "]", "rune", "(", "\"", ")", " ", "{", "", "word", ".", "RemoveLastNRunes", "(", "1", ")", "\n", "}", "\n", "return", "true", "\n", "}", "\n\n", "// Remove soft sign", "if", "rsLen", ":=", "len", "(", "word", ".", "RS", ")", ";", "rsLen", ">", "0", "&&", "word", ".", "RS", "[", "rsLen", "-", "1", "]", "==", "'\u044c' ", "", "word", ".", "RemoveLastNRunes", "(", "1", ")", "\n", "return", "true", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// Step 4 is the undoubling of double non-vowel endings\n// and removal of superlative endings.\n//", "docstring_tokens": ["Step", "4", "is", "the", "undoubling", "of", "double", "non", "-", "vowel", "endings", "and", "removal", "of", "superlative", "endings", "."], "sha": "115fa8f6419dcfb9ec4653997b1c6803a5eff962", "url": "https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/russian/step4.go#L10-L38", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "skiplist/builder.go", "func_name": "Add", "original_string": "func (s *Segment) Add(itm unsafe.Pointer) {\n\titemLevel := s.builder.store.NewLevel(s.rand.Float32)\n\tx := s.builder.store.newNode(itm, itemLevel)\n\ts.sts.AddInt64(&s.sts.nodeAllocs, 1)\n\ts.sts.AddInt64(&s.sts.levelNodesCount[itemLevel], 1)\n\ts.sts.AddInt64(&s.sts.usedBytes, int64(s.builder.store.Size(x)))\n\n\tfor l := 0; l <= itemLevel; l++ {\n\t\tif s.tail[l] != nil {\n\t\t\ts.tail[l].setNext(l, x, false)\n\t\t} else {\n\t\t\ts.head[l] = x\n\t\t}\n\t\ts.tail[l] = x\n\t}\n\n\tif s.callb != nil {\n\t\ts.callb(x)\n\t}\n}", "language": "go", "code": "func (s *Segment) Add(itm unsafe.Pointer) {\n\titemLevel := s.builder.store.NewLevel(s.rand.Float32)\n\tx := s.builder.store.newNode(itm, itemLevel)\n\ts.sts.AddInt64(&s.sts.nodeAllocs, 1)\n\ts.sts.AddInt64(&s.sts.levelNodesCount[itemLevel], 1)\n\ts.sts.AddInt64(&s.sts.usedBytes, int64(s.builder.store.Size(x)))\n\n\tfor l := 0; l <= itemLevel; l++ {\n\t\tif s.tail[l] != nil {\n\t\t\ts.tail[l].setNext(l, x, false)\n\t\t} else {\n\t\t\ts.head[l] = x\n\t\t}\n\t\ts.tail[l] = x\n\t}\n\n\tif s.callb != nil {\n\t\ts.callb(x)\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "Segment", ")", "Add", "(", "itm", "unsafe", ".", "Pointer", ")", "{", "itemLevel", ":=", "s", ".", "builder", ".", "store", ".", "NewLevel", "(", "s", ".", "rand", ".", "Float32", ")", "\n", "x", ":=", "s", ".", "builder", ".", "store", ".", "newNode", "(", "itm", ",", "itemLevel", ")", "\n", "s", ".", "sts", ".", "AddInt64", "(", "&", "s", ".", "sts", ".", "nodeAllocs", ",", "1", ")", "\n", "s", ".", "sts", ".", "AddInt64", "(", "&", "s", ".", "sts", ".", "levelNodesCount", "[", "itemLevel", "]", ",", "1", ")", "\n", "s", ".", "sts", ".", "AddInt64", "(", "&", "s", ".", "sts", ".", "usedBytes", ",", "int64", "(", "s", ".", "builder", ".", "store", ".", "Size", "(", "x", ")", ")", ")", "\n\n", "for", "l", ":=", "0", ";", "l", "<=", "itemLevel", ";", "l", "++", "{", "if", "s", ".", "tail", "[", "l", "]", "!=", "nil", "{", "s", ".", "tail", "[", "l", "]", ".", "setNext", "(", "l", ",", "x", ",", "false", ")", "\n", "}", "else", "{", "s", ".", "head", "[", "l", "]", "=", "x", "\n", "}", "\n", "s", ".", "tail", "[", "l", "]", "=", "x", "\n", "}", "\n\n", "if", "s", ".", "callb", "!=", "nil", "{", "s", ".", "callb", "(", "x", ")", "\n", "}", "\n", "}"], "docstring": "// Add an item into skiplist segment", "docstring_tokens": ["Add", "an", "item", "into", "skiplist", "segment"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/skiplist/builder.go#L36-L55", "partition": "test"}
{"repo": "aphistic/gomol", "path": "attrs.go", "func_name": "MergeAttrs", "original_string": "func (a *Attrs) MergeAttrs(attrs *Attrs) {\n\tif attrs == nil {\n\t\treturn\n\t}\n\ta.attrsLock.Lock()\n\tdefer a.attrsLock.Unlock()\n\tfor hash, val := range attrs.attrs {\n\t\ta.attrs[hash] = val\n\t}\n}", "language": "go", "code": "func (a *Attrs) MergeAttrs(attrs *Attrs) {\n\tif attrs == nil {\n\t\treturn\n\t}\n\ta.attrsLock.Lock()\n\tdefer a.attrsLock.Unlock()\n\tfor hash, val := range attrs.attrs {\n\t\ta.attrs[hash] = val\n\t}\n}", "code_tokens": ["func", "(", "a", "*", "Attrs", ")", "MergeAttrs", "(", "attrs", "*", "Attrs", ")", "{", "if", "attrs", "==", "nil", "{", "return", "\n", "}", "\n", "a", ".", "attrsLock", ".", "Lock", "(", ")", "\n", "defer", "a", ".", "attrsLock", ".", "Unlock", "(", ")", "\n", "for", "hash", ",", "val", ":=", "range", "attrs", ".", "attrs", "{", "a", ".", "attrs", "[", "hash", "]", "=", "val", "\n", "}", "\n", "}"], "docstring": "// MergeAttrs accepts another existing Attrs and merges the attributes into its own.", "docstring_tokens": ["MergeAttrs", "accepts", "another", "existing", "Attrs", "and", "merges", "the", "attributes", "into", "its", "own", "."], "sha": "1546845ba714699f76f484ad3af64cf0503064d1", "url": "https://github.com/aphistic/gomol/blob/1546845ba714699f76f484ad3af64cf0503064d1/attrs.go#L44-L53", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/spyglass/podlogartifact.go", "func_name": "CanonicalLink", "original_string": "func (a *PodLogArtifact) CanonicalLink() string {\n\tq := url.Values{\n\t\t\"job\": []string{a.name},\n\t\t\"id\":  []string{a.buildID},\n\t}\n\tu := url.URL{\n\t\tPath:     \"/log\",\n\t\tRawQuery: q.Encode(),\n\t}\n\treturn u.String()\n}", "language": "go", "code": "func (a *PodLogArtifact) CanonicalLink() string {\n\tq := url.Values{\n\t\t\"job\": []string{a.name},\n\t\t\"id\":  []string{a.buildID},\n\t}\n\tu := url.URL{\n\t\tPath:     \"/log\",\n\t\tRawQuery: q.Encode(),\n\t}\n\treturn u.String()\n}", "code_tokens": ["func", "(", "a", "*", "PodLogArtifact", ")", "CanonicalLink", "(", ")", "string", "{", "q", ":=", "url", ".", "Values", "{", "\"", "\"", ":", "[", "]", "string", "{", "a", ".", "name", "}", ",", "\"", "\"", ":", "[", "]", "string", "{", "a", ".", "buildID", "}", ",", "}", "\n", "u", ":=", "url", ".", "URL", "{", "Path", ":", "\"", "\"", ",", "RawQuery", ":", "q", ".", "Encode", "(", ")", ",", "}", "\n", "return", "u", ".", "String", "(", ")", "\n", "}"], "docstring": "// CanonicalLink returns a link to where pod logs are streamed", "docstring_tokens": ["CanonicalLink", "returns", "a", "link", "to", "where", "pod", "logs", "are", "streamed"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/spyglass/podlogartifact.go#L69-L79", "partition": "test"}
{"repo": "libp2p/go-libp2p-pubsub", "path": "pubsub.go", "func_name": "NewPubSub", "original_string": "func NewPubSub(ctx context.Context, h host.Host, rt PubSubRouter, opts ...Option) (*PubSub, error) {\n\tps := &PubSub{\n\t\thost:             h,\n\t\tctx:              ctx,\n\t\trt:               rt,\n\t\tsignID:           h.ID(),\n\t\tsignKey:          h.Peerstore().PrivKey(h.ID()),\n\t\tsignStrict:       true,\n\t\tincoming:         make(chan *RPC, 32),\n\t\tpublish:          make(chan *Message),\n\t\tnewPeers:         make(chan peer.ID),\n\t\tnewPeerStream:    make(chan inet.Stream),\n\t\tnewPeerError:     make(chan peer.ID),\n\t\tpeerDead:         make(chan peer.ID),\n\t\tcancelCh:         make(chan *Subscription),\n\t\tgetPeers:         make(chan *listPeerReq),\n\t\taddSub:           make(chan *addSubReq),\n\t\tgetTopics:        make(chan *topicReq),\n\t\tsendMsg:          make(chan *sendReq, 32),\n\t\taddVal:           make(chan *addValReq),\n\t\trmVal:            make(chan *rmValReq),\n\t\tvalidateThrottle: make(chan struct{}, defaultValidateThrottle),\n\t\teval:             make(chan func()),\n\t\tmyTopics:         make(map[string]map[*Subscription]struct{}),\n\t\ttopics:           make(map[string]map[peer.ID]struct{}),\n\t\tpeers:            make(map[peer.ID]chan *RPC),\n\t\ttopicVals:        make(map[string]*topicVal),\n\t\tblacklist:        NewMapBlacklist(),\n\t\tblacklistPeer:    make(chan peer.ID),\n\t\tseenMessages:     timecache.NewTimeCache(TimeCacheDuration),\n\t\tcounter:          uint64(time.Now().UnixNano()),\n\t}\n\n\tfor _, opt := range opts {\n\t\terr := opt(ps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif ps.signStrict && ps.signKey == nil {\n\t\treturn nil, fmt.Errorf(\"strict signature verification enabled but message signing is disabled\")\n\t}\n\n\trt.Attach(ps)\n\n\tfor _, id := range rt.Protocols() {\n\t\th.SetStreamHandler(id, ps.handleNewStream)\n\t}\n\th.Network().Notify((*PubSubNotif)(ps))\n\n\tgo ps.processLoop(ctx)\n\n\treturn ps, nil\n}", "language": "go", "code": "func NewPubSub(ctx context.Context, h host.Host, rt PubSubRouter, opts ...Option) (*PubSub, error) {\n\tps := &PubSub{\n\t\thost:             h,\n\t\tctx:              ctx,\n\t\trt:               rt,\n\t\tsignID:           h.ID(),\n\t\tsignKey:          h.Peerstore().PrivKey(h.ID()),\n\t\tsignStrict:       true,\n\t\tincoming:         make(chan *RPC, 32),\n\t\tpublish:          make(chan *Message),\n\t\tnewPeers:         make(chan peer.ID),\n\t\tnewPeerStream:    make(chan inet.Stream),\n\t\tnewPeerError:     make(chan peer.ID),\n\t\tpeerDead:         make(chan peer.ID),\n\t\tcancelCh:         make(chan *Subscription),\n\t\tgetPeers:         make(chan *listPeerReq),\n\t\taddSub:           make(chan *addSubReq),\n\t\tgetTopics:        make(chan *topicReq),\n\t\tsendMsg:          make(chan *sendReq, 32),\n\t\taddVal:           make(chan *addValReq),\n\t\trmVal:            make(chan *rmValReq),\n\t\tvalidateThrottle: make(chan struct{}, defaultValidateThrottle),\n\t\teval:             make(chan func()),\n\t\tmyTopics:         make(map[string]map[*Subscription]struct{}),\n\t\ttopics:           make(map[string]map[peer.ID]struct{}),\n\t\tpeers:            make(map[peer.ID]chan *RPC),\n\t\ttopicVals:        make(map[string]*topicVal),\n\t\tblacklist:        NewMapBlacklist(),\n\t\tblacklistPeer:    make(chan peer.ID),\n\t\tseenMessages:     timecache.NewTimeCache(TimeCacheDuration),\n\t\tcounter:          uint64(time.Now().UnixNano()),\n\t}\n\n\tfor _, opt := range opts {\n\t\terr := opt(ps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif ps.signStrict && ps.signKey == nil {\n\t\treturn nil, fmt.Errorf(\"strict signature verification enabled but message signing is disabled\")\n\t}\n\n\trt.Attach(ps)\n\n\tfor _, id := range rt.Protocols() {\n\t\th.SetStreamHandler(id, ps.handleNewStream)\n\t}\n\th.Network().Notify((*PubSubNotif)(ps))\n\n\tgo ps.processLoop(ctx)\n\n\treturn ps, nil\n}", "code_tokens": ["func", "NewPubSub", "(", "ctx", "context", ".", "Context", ",", "h", "host", ".", "Host", ",", "rt", "PubSubRouter", ",", "opts", "...", "Option", ")", "(", "*", "PubSub", ",", "error", ")", "{", "ps", ":=", "&", "PubSub", "{", "host", ":", "h", ",", "ctx", ":", "ctx", ",", "rt", ":", "rt", ",", "signID", ":", "h", ".", "ID", "(", ")", ",", "signKey", ":", "h", ".", "Peerstore", "(", ")", ".", "PrivKey", "(", "h", ".", "ID", "(", ")", ")", ",", "signStrict", ":", "true", ",", "incoming", ":", "make", "(", "chan", "*", "RPC", ",", "32", ")", ",", "publish", ":", "make", "(", "chan", "*", "Message", ")", ",", "newPeers", ":", "make", "(", "chan", "peer", ".", "ID", ")", ",", "newPeerStream", ":", "make", "(", "chan", "inet", ".", "Stream", ")", ",", "newPeerError", ":", "make", "(", "chan", "peer", ".", "ID", ")", ",", "peerDead", ":", "make", "(", "chan", "peer", ".", "ID", ")", ",", "cancelCh", ":", "make", "(", "chan", "*", "Subscription", ")", ",", "getPeers", ":", "make", "(", "chan", "*", "listPeerReq", ")", ",", "addSub", ":", "make", "(", "chan", "*", "addSubReq", ")", ",", "getTopics", ":", "make", "(", "chan", "*", "topicReq", ")", ",", "sendMsg", ":", "make", "(", "chan", "*", "sendReq", ",", "32", ")", ",", "addVal", ":", "make", "(", "chan", "*", "addValReq", ")", ",", "rmVal", ":", "make", "(", "chan", "*", "rmValReq", ")", ",", "validateThrottle", ":", "make", "(", "chan", "struct", "{", "}", ",", "defaultValidateThrottle", ")", ",", "eval", ":", "make", "(", "chan", "func", "(", ")", ")", ",", "myTopics", ":", "make", "(", "map", "[", "string", "]", "map", "[", "*", "Subscription", "]", "struct", "{", "}", ")", ",", "topics", ":", "make", "(", "map", "[", "string", "]", "map", "[", "peer", ".", "ID", "]", "struct", "{", "}", ")", ",", "peers", ":", "make", "(", "map", "[", "peer", ".", "ID", "]", "chan", "*", "RPC", ")", ",", "topicVals", ":", "make", "(", "map", "[", "string", "]", "*", "topicVal", ")", ",", "blacklist", ":", "NewMapBlacklist", "(", ")", ",", "blacklistPeer", ":", "make", "(", "chan", "peer", ".", "ID", ")", ",", "seenMessages", ":", "timecache", ".", "NewTimeCache", "(", "TimeCacheDuration", ")", ",", "counter", ":", "uint64", "(", "time", ".", "Now", "(", ")", ".", "UnixNano", "(", ")", ")", ",", "}", "\n\n", "for", "_", ",", "opt", ":=", "range", "opts", "{", "err", ":=", "opt", "(", "ps", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "}", "\n\n", "if", "ps", ".", "signStrict", "&&", "ps", ".", "signKey", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n\n", "rt", ".", "Attach", "(", "ps", ")", "\n\n", "for", "_", ",", "id", ":=", "range", "rt", ".", "Protocols", "(", ")", "{", "h", ".", "SetStreamHandler", "(", "id", ",", "ps", ".", "handleNewStream", ")", "\n", "}", "\n", "h", ".", "Network", "(", ")", ".", "Notify", "(", "(", "*", "PubSubNotif", ")", "(", "ps", ")", ")", "\n\n", "go", "ps", ".", "processLoop", "(", "ctx", ")", "\n\n", "return", "ps", ",", "nil", "\n", "}"], "docstring": "// NewPubSub returns a new PubSub management object.", "docstring_tokens": ["NewPubSub", "returns", "a", "new", "PubSub", "management", "object", "."], "sha": "9db3dbdde90f44d1c420192c5cefd60682fbdbb9", "url": "https://github.com/libp2p/go-libp2p-pubsub/blob/9db3dbdde90f44d1c420192c5cefd60682fbdbb9/pubsub.go#L160-L214", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "keypair/main.go", "func_name": "Master", "original_string": "func Master(networkPassphrase string) KP {\n\tkp, err := FromRawSeed(network.ID(networkPassphrase))\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn kp\n}", "language": "go", "code": "func Master(networkPassphrase string) KP {\n\tkp, err := FromRawSeed(network.ID(networkPassphrase))\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn kp\n}", "code_tokens": ["func", "Master", "(", "networkPassphrase", "string", ")", "KP", "{", "kp", ",", "err", ":=", "FromRawSeed", "(", "network", ".", "ID", "(", "networkPassphrase", ")", ")", "\n\n", "if", "err", "!=", "nil", "{", "panic", "(", "err", ")", "\n", "}", "\n\n", "return", "kp", "\n", "}"], "docstring": "// Master returns the master keypair for a given network passphrase", "docstring_tokens": ["Master", "returns", "the", "master", "keypair", "for", "a", "given", "network", "passphrase"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/keypair/main.go#L62-L70", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "mvcc/backend/tx_buffer.go", "func_name": "merge", "original_string": "func (bb *bucketBuffer) merge(bbsrc *bucketBuffer) {\n\tfor i := 0; i < bbsrc.used; i++ {\n\t\tbb.add(bbsrc.buf[i].key, bbsrc.buf[i].val)\n\t}\n\tif bb.used == bbsrc.used {\n\t\treturn\n\t}\n\tif bytes.Compare(bb.buf[(bb.used-bbsrc.used)-1].key, bbsrc.buf[0].key) < 0 {\n\t\treturn\n\t}\n\n\tsort.Stable(bb)\n\n\t// remove duplicates, using only newest update\n\twidx := 0\n\tfor ridx := 1; ridx < bb.used; ridx++ {\n\t\tif !bytes.Equal(bb.buf[ridx].key, bb.buf[widx].key) {\n\t\t\twidx++\n\t\t}\n\t\tbb.buf[widx] = bb.buf[ridx]\n\t}\n\tbb.used = widx + 1\n}", "language": "go", "code": "func (bb *bucketBuffer) merge(bbsrc *bucketBuffer) {\n\tfor i := 0; i < bbsrc.used; i++ {\n\t\tbb.add(bbsrc.buf[i].key, bbsrc.buf[i].val)\n\t}\n\tif bb.used == bbsrc.used {\n\t\treturn\n\t}\n\tif bytes.Compare(bb.buf[(bb.used-bbsrc.used)-1].key, bbsrc.buf[0].key) < 0 {\n\t\treturn\n\t}\n\n\tsort.Stable(bb)\n\n\t// remove duplicates, using only newest update\n\twidx := 0\n\tfor ridx := 1; ridx < bb.used; ridx++ {\n\t\tif !bytes.Equal(bb.buf[ridx].key, bb.buf[widx].key) {\n\t\t\twidx++\n\t\t}\n\t\tbb.buf[widx] = bb.buf[ridx]\n\t}\n\tbb.used = widx + 1\n}", "code_tokens": ["func", "(", "bb", "*", "bucketBuffer", ")", "merge", "(", "bbsrc", "*", "bucketBuffer", ")", "{", "for", "i", ":=", "0", ";", "i", "<", "bbsrc", ".", "used", ";", "i", "++", "{", "bb", ".", "add", "(", "bbsrc", ".", "buf", "[", "i", "]", ".", "key", ",", "bbsrc", ".", "buf", "[", "i", "]", ".", "val", ")", "\n", "}", "\n", "if", "bb", ".", "used", "==", "bbsrc", ".", "used", "{", "return", "\n", "}", "\n", "if", "bytes", ".", "Compare", "(", "bb", ".", "buf", "[", "(", "bb", ".", "used", "-", "bbsrc", ".", "used", ")", "-", "1", "]", ".", "key", ",", "bbsrc", ".", "buf", "[", "0", "]", ".", "key", ")", "<", "0", "{", "return", "\n", "}", "\n\n", "sort", ".", "Stable", "(", "bb", ")", "\n\n", "// remove duplicates, using only newest update", "widx", ":=", "0", "\n", "for", "ridx", ":=", "1", ";", "ridx", "<", "bb", ".", "used", ";", "ridx", "++", "{", "if", "!", "bytes", ".", "Equal", "(", "bb", ".", "buf", "[", "ridx", "]", ".", "key", ",", "bb", ".", "buf", "[", "widx", "]", ".", "key", ")", "{", "widx", "++", "\n", "}", "\n", "bb", ".", "buf", "[", "widx", "]", "=", "bb", ".", "buf", "[", "ridx", "]", "\n", "}", "\n", "bb", ".", "used", "=", "widx", "+", "1", "\n", "}"], "docstring": "// merge merges data from bb into bbsrc.", "docstring_tokens": ["merge", "merges", "data", "from", "bb", "into", "bbsrc", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/mvcc/backend/tx_buffer.go#L153-L175", "partition": "test"}
{"repo": "pact-foundation/pact-go", "path": "examples/consumer/goconsumer/client.go", "func_name": "getUser", "original_string": "func (c *Client) getUser(id string) (*ex.User, error) {\n\n\tu := fmt.Sprintf(\"%s/users/%s\", c.Host, id)\n\treq, err := http.NewRequest(\"GET\", u, nil)\n\n\t// NOTE: by default, request bodies are expected to be sent with a Content-Type\n\t// of application/json. If you don't explicitly set the content-type, you\n\t// will get a mismatch during Verification.\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", c.token)\n\n\tres, err := http.DefaultClient.Do(req)\n\n\tif res.StatusCode != 200 || err != nil {\n\t\treturn nil, fmt.Errorf(\"get user failed\")\n\t}\n\n\tdata, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response ex.User\n\terr = json.Unmarshal(data, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, err\n}", "language": "go", "code": "func (c *Client) getUser(id string) (*ex.User, error) {\n\n\tu := fmt.Sprintf(\"%s/users/%s\", c.Host, id)\n\treq, err := http.NewRequest(\"GET\", u, nil)\n\n\t// NOTE: by default, request bodies are expected to be sent with a Content-Type\n\t// of application/json. If you don't explicitly set the content-type, you\n\t// will get a mismatch during Verification.\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", c.token)\n\n\tres, err := http.DefaultClient.Do(req)\n\n\tif res.StatusCode != 200 || err != nil {\n\t\treturn nil, fmt.Errorf(\"get user failed\")\n\t}\n\n\tdata, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response ex.User\n\terr = json.Unmarshal(data, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "getUser", "(", "id", "string", ")", "(", "*", "ex", ".", "User", ",", "error", ")", "{", "u", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "c", ".", "Host", ",", "id", ")", "\n", "req", ",", "err", ":=", "http", ".", "NewRequest", "(", "\"", "\"", ",", "u", ",", "nil", ")", "\n\n", "// NOTE: by default, request bodies are expected to be sent with a Content-Type", "// of application/json. If you don't explicitly set the content-type, you", "// will get a mismatch during Verification.", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "c", ".", "token", ")", "\n\n", "res", ",", "err", ":=", "http", ".", "DefaultClient", ".", "Do", "(", "req", ")", "\n\n", "if", "res", ".", "StatusCode", "!=", "200", "||", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n\n", "data", ",", "err", ":=", "ioutil", ".", "ReadAll", "(", "res", ".", "Body", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "var", "response", "ex", ".", "User", "\n", "err", "=", "json", ".", "Unmarshal", "(", "data", ",", "&", "response", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "&", "response", ",", "err", "\n", "}"], "docstring": "// getUser finds a user", "docstring_tokens": ["getUser", "finds", "a", "user"], "sha": "467dea56d27e154363e1975f6e9f4dbf66148e79", "url": "https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/examples/consumer/goconsumer/client.go#L36-L65", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/db.go", "func_name": "Scan", "original_string": "func (t *Int64) Scan(src interface{}) error {\n\tval, ok := src.(int64)\n\tif !ok {\n\t\treturn errors.New(\"Invalid value for xdr.Int64\")\n\t}\n\n\t*t = Int64(val)\n\treturn nil\n}", "language": "go", "code": "func (t *Int64) Scan(src interface{}) error {\n\tval, ok := src.(int64)\n\tif !ok {\n\t\treturn errors.New(\"Invalid value for xdr.Int64\")\n\t}\n\n\t*t = Int64(val)\n\treturn nil\n}", "code_tokens": ["func", "(", "t", "*", "Int64", ")", "Scan", "(", "src", "interface", "{", "}", ")", "error", "{", "val", ",", "ok", ":=", "src", ".", "(", "int64", ")", "\n", "if", "!", "ok", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n\n", "*", "t", "=", "Int64", "(", "val", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// Scan reads from src into an Int64", "docstring_tokens": ["Scan", "reads", "from", "src", "into", "an", "Int64"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/db.go#L33-L41", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/metrics/metrics.go", "func_name": "FinishReportAndFlushUserAction", "original_string": "func FinishReportAndFlushUserAction(action string, err error, start time.Time) func() {\n\tvar wait func()\n\tif err != nil {\n\t\twait = reportAndFlushUserAction(fmt.Sprintf(\"%vErrored\", action), err)\n\t} else {\n\t\twait = reportAndFlushUserAction(fmt.Sprintf(\"%vFinished\", action), time.Since(start).Seconds())\n\t}\n\treturn wait\n}", "language": "go", "code": "func FinishReportAndFlushUserAction(action string, err error, start time.Time) func() {\n\tvar wait func()\n\tif err != nil {\n\t\twait = reportAndFlushUserAction(fmt.Sprintf(\"%vErrored\", action), err)\n\t} else {\n\t\twait = reportAndFlushUserAction(fmt.Sprintf(\"%vFinished\", action), time.Since(start).Seconds())\n\t}\n\treturn wait\n}", "code_tokens": ["func", "FinishReportAndFlushUserAction", "(", "action", "string", ",", "err", "error", ",", "start", "time", ".", "Time", ")", "func", "(", ")", "{", "var", "wait", "func", "(", ")", "\n", "if", "err", "!=", "nil", "{", "wait", "=", "reportAndFlushUserAction", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "action", ")", ",", "err", ")", "\n", "}", "else", "{", "wait", "=", "reportAndFlushUserAction", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "action", ")", ",", "time", ".", "Since", "(", "start", ")", ".", "Seconds", "(", ")", ")", "\n", "}", "\n", "return", "wait", "\n", "}"], "docstring": "// FinishReportAndFlushUserAction immediately reports the metric but does\n// not block execution. It returns a wait function which waits or times\n// out after 5s.\n// It is used by the pachctl binary and runs on users' machines", "docstring_tokens": ["FinishReportAndFlushUserAction", "immediately", "reports", "the", "metric", "but", "does", "not", "block", "execution", ".", "It", "returns", "a", "wait", "function", "which", "waits", "or", "times", "out", "after", "5s", ".", "It", "is", "used", "by", "the", "pachctl", "binary", "and", "runs", "on", "users", "machines"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/metrics/metrics.go#L126-L134", "partition": "test"}
{"repo": "auth0/go-jwt-middleware", "path": "jwtmiddleware.go", "func_name": "HandlerWithNext", "original_string": "func (m *JWTMiddleware) HandlerWithNext(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\terr := m.CheckJWT(w, r)\n\n\t// If there was an error, do not call next.\n\tif err == nil && next != nil {\n\t\tnext(w, r)\n\t}\n}", "language": "go", "code": "func (m *JWTMiddleware) HandlerWithNext(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\terr := m.CheckJWT(w, r)\n\n\t// If there was an error, do not call next.\n\tif err == nil && next != nil {\n\t\tnext(w, r)\n\t}\n}", "code_tokens": ["func", "(", "m", "*", "JWTMiddleware", ")", "HandlerWithNext", "(", "w", "http", ".", "ResponseWriter", ",", "r", "*", "http", ".", "Request", ",", "next", "http", ".", "HandlerFunc", ")", "{", "err", ":=", "m", ".", "CheckJWT", "(", "w", ",", "r", ")", "\n\n", "// If there was an error, do not call next.", "if", "err", "==", "nil", "&&", "next", "!=", "nil", "{", "next", "(", "w", ",", "r", ")", "\n", "}", "\n", "}"], "docstring": "// Special implementation for Negroni, but could be used elsewhere.", "docstring_tokens": ["Special", "implementation", "for", "Negroni", "but", "could", "be", "used", "elsewhere", "."], "sha": "5493cabe49f7bfa6e2ec444a09d334d90cd4e2bd", "url": "https://github.com/auth0/go-jwt-middleware/blob/5493cabe49f7bfa6e2ec444a09d334d90cd4e2bd/jwtmiddleware.go#L97-L104", "partition": "test"}
{"repo": "siddontang/go-log", "path": "log/logger.go", "func_name": "String", "original_string": "func (l Level) String() string {\n\tswitch l {\n\tcase LevelTrace:\n\t\treturn \"trace\"\n\tcase LevelDebug:\n\t\treturn \"debug\"\n\tcase LevelInfo:\n\t\treturn \"info\"\n\tcase LevelWarn:\n\t\treturn \"warn\"\n\tcase LevelError:\n\t\treturn \"error\"\n\tcase LevelFatal:\n\t\treturn \"fatal\"\n\t}\n\t// return default info\n\treturn \"info\"\n}", "language": "go", "code": "func (l Level) String() string {\n\tswitch l {\n\tcase LevelTrace:\n\t\treturn \"trace\"\n\tcase LevelDebug:\n\t\treturn \"debug\"\n\tcase LevelInfo:\n\t\treturn \"info\"\n\tcase LevelWarn:\n\t\treturn \"warn\"\n\tcase LevelError:\n\t\treturn \"error\"\n\tcase LevelFatal:\n\t\treturn \"fatal\"\n\t}\n\t// return default info\n\treturn \"info\"\n}", "code_tokens": ["func", "(", "l", "Level", ")", "String", "(", ")", "string", "{", "switch", "l", "{", "case", "LevelTrace", ":", "return", "\"", "\"", "\n", "case", "LevelDebug", ":", "return", "\"", "\"", "\n", "case", "LevelInfo", ":", "return", "\"", "\"", "\n", "case", "LevelWarn", ":", "return", "\"", "\"", "\n", "case", "LevelError", ":", "return", "\"", "\"", "\n", "case", "LevelFatal", ":", "return", "\"", "\"", "\n", "}", "\n", "// return default info", "return", "\"", "\"", "\n", "}"], "docstring": "// String returns level String", "docstring_tokens": ["String", "returns", "level", "String"], "sha": "1e957dd83bed18c84716181da7b80d4af48eaefe", "url": "https://github.com/siddontang/go-log/blob/1e957dd83bed18c84716181da7b80d4af48eaefe/log/logger.go#L42-L59", "partition": "test"}
{"repo": "fcavani/text", "path": "util.go", "func_name": "Reticence", "original_string": "func Reticence(str string, length int) string {\n\tif length > len(str) {\n\t\treturn str\n\t}\n\tvar i int\nF:\n\tfor i = len(str) - 1; i >= 0; i-- {\n\t\tswitch str[i] {\n\t\tcase ' ', ',', '?', ';', ':', '\\'', '\"', '!':\n\t\t\tif i <= length {\n\t\t\t\tbreak F\n\t\t\t}\n\t\tcase '.':\n\t\t\tif i-2 >= 0 {\n\t\t\t\ts := str[i-2 : i]\n\t\t\t\tif s == \"..\" {\n\t\t\t\t\ti = i - 2\n\t\t\t\t\tif i <= length {\n\t\t\t\t\t\tbreak F\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif i <= length {\n\t\t\t\tbreak F\n\t\t\t}\n\t\t}\n\t}\n\tif i-1 > 0 {\n\t\tswitch str[i-1] {\n\t\tcase ' ', ',', '?', ';', ':', '\\'', '\"', '!':\n\t\t\ti--\n\t\tcase '.':\n\t\t\tif i-2 > 0 && str[i-2:i] == \"..\" {\n\t\t\t\ti -= 3\n\t\t\t}\n\t\t}\n\t}\n\tif i >= 2 {\n\t\tif i+3 >= len(str) {\n\t\t\treturn str\n\t\t}\n\t\treturn str[:i] + \"...\"\n\t}\n\tif length >= 2 && length < len(str) {\n\t\tif length+3 >= len(str) {\n\t\t\treturn str\n\t\t}\n\t\treturn str[:length] + \"...\"\n\t}\n\treturn str\n}", "language": "go", "code": "func Reticence(str string, length int) string {\n\tif length > len(str) {\n\t\treturn str\n\t}\n\tvar i int\nF:\n\tfor i = len(str) - 1; i >= 0; i-- {\n\t\tswitch str[i] {\n\t\tcase ' ', ',', '?', ';', ':', '\\'', '\"', '!':\n\t\t\tif i <= length {\n\t\t\t\tbreak F\n\t\t\t}\n\t\tcase '.':\n\t\t\tif i-2 >= 0 {\n\t\t\t\ts := str[i-2 : i]\n\t\t\t\tif s == \"..\" {\n\t\t\t\t\ti = i - 2\n\t\t\t\t\tif i <= length {\n\t\t\t\t\t\tbreak F\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif i <= length {\n\t\t\t\tbreak F\n\t\t\t}\n\t\t}\n\t}\n\tif i-1 > 0 {\n\t\tswitch str[i-1] {\n\t\tcase ' ', ',', '?', ';', ':', '\\'', '\"', '!':\n\t\t\ti--\n\t\tcase '.':\n\t\t\tif i-2 > 0 && str[i-2:i] == \"..\" {\n\t\t\t\ti -= 3\n\t\t\t}\n\t\t}\n\t}\n\tif i >= 2 {\n\t\tif i+3 >= len(str) {\n\t\t\treturn str\n\t\t}\n\t\treturn str[:i] + \"...\"\n\t}\n\tif length >= 2 && length < len(str) {\n\t\tif length+3 >= len(str) {\n\t\t\treturn str\n\t\t}\n\t\treturn str[:length] + \"...\"\n\t}\n\treturn str\n}", "code_tokens": ["func", "Reticence", "(", "str", "string", ",", "length", "int", ")", "string", "{", "if", "length", ">", "len", "(", "str", ")", "{", "return", "str", "\n", "}", "\n", "var", "i", "int", "\n", "F", ":", "for", "i", "=", "len", "(", "str", ")", "-", "1", ";", "i", ">=", "0", ";", "i", "--", "{", "switch", "str", "[", "i", "]", "{", "case", "' '", ",", "','", ",", "'?'", ",", "';'", ",", "':'", ",", "'\\''", ",", "'\"'", ",", "'!'", ":", "if", "i", "<=", "length", "{", "break", "F", "\n", "}", "\n", "case", "'.'", ":", "if", "i", "-", "2", ">=", "0", "{", "s", ":=", "str", "[", "i", "-", "2", ":", "i", "]", "\n", "if", "s", "==", "\"", "\"", "{", "i", "=", "i", "-", "2", "\n", "if", "i", "<=", "length", "{", "break", "F", "\n", "}", "\n", "}", "\n", "}", "\n", "if", "i", "<=", "length", "{", "break", "F", "\n", "}", "\n", "}", "\n", "}", "\n", "if", "i", "-", "1", ">", "0", "{", "switch", "str", "[", "i", "-", "1", "]", "{", "case", "' '", ",", "','", ",", "'?'", ",", "';'", ",", "':'", ",", "'\\''", ",", "'\"'", ",", "'!'", ":", "i", "--", "\n", "case", "'.'", ":", "if", "i", "-", "2", ">", "0", "&&", "str", "[", "i", "-", "2", ":", "i", "]", "==", "\"", "\"", "{", "i", "-=", "3", "\n", "}", "\n", "}", "\n", "}", "\n", "if", "i", ">=", "2", "{", "if", "i", "+", "3", ">=", "len", "(", "str", ")", "{", "return", "str", "\n", "}", "\n", "return", "str", "[", ":", "i", "]", "+", "\"", "\"", "\n", "}", "\n", "if", "length", ">=", "2", "&&", "length", "<", "len", "(", "str", ")", "{", "if", "length", "+", "3", ">=", "len", "(", "str", ")", "{", "return", "str", "\n", "}", "\n", "return", "str", "[", ":", "length", "]", "+", "\"", "\"", "\n", "}", "\n", "return", "str", "\n", "}"], "docstring": "// Reticence trucate the string in the space or on pontuation mark and put\n// reticences in the resulting string.", "docstring_tokens": ["Reticence", "trucate", "the", "string", "in", "the", "space", "or", "on", "pontuation", "mark", "and", "put", "reticences", "in", "the", "resulting", "string", "."], "sha": "023e76809b57fc8cfc80c855ba59537720821cb5", "url": "https://github.com/fcavani/text/blob/023e76809b57fc8cfc80c855ba59537720821cb5/util.go#L27-L77", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "language/proto/generate.go", "func_name": "generateEmpty", "original_string": "func generateEmpty(f *rule.File, regularFiles, genFiles []string) []*rule.Rule {\n\tif f == nil {\n\t\treturn nil\n\t}\n\tknownFiles := make(map[string]bool)\n\tfor _, f := range regularFiles {\n\t\tknownFiles[f] = true\n\t}\n\tfor _, f := range genFiles {\n\t\tknownFiles[f] = true\n\t}\n\tvar empty []*rule.Rule\nouter:\n\tfor _, r := range f.Rules {\n\t\tif r.Kind() != \"proto_library\" {\n\t\t\tcontinue\n\t\t}\n\t\tsrcs := r.AttrStrings(\"srcs\")\n\t\tif len(srcs) == 0 && r.Attr(\"srcs\") != nil {\n\t\t\t// srcs is not a string list; leave it alone\n\t\t\tcontinue\n\t\t}\n\t\tfor _, src := range r.AttrStrings(\"srcs\") {\n\t\t\tif knownFiles[src] {\n\t\t\t\tcontinue outer\n\t\t\t}\n\t\t}\n\t\tempty = append(empty, rule.NewRule(\"proto_library\", r.Name()))\n\t}\n\treturn empty\n}", "language": "go", "code": "func generateEmpty(f *rule.File, regularFiles, genFiles []string) []*rule.Rule {\n\tif f == nil {\n\t\treturn nil\n\t}\n\tknownFiles := make(map[string]bool)\n\tfor _, f := range regularFiles {\n\t\tknownFiles[f] = true\n\t}\n\tfor _, f := range genFiles {\n\t\tknownFiles[f] = true\n\t}\n\tvar empty []*rule.Rule\nouter:\n\tfor _, r := range f.Rules {\n\t\tif r.Kind() != \"proto_library\" {\n\t\t\tcontinue\n\t\t}\n\t\tsrcs := r.AttrStrings(\"srcs\")\n\t\tif len(srcs) == 0 && r.Attr(\"srcs\") != nil {\n\t\t\t// srcs is not a string list; leave it alone\n\t\t\tcontinue\n\t\t}\n\t\tfor _, src := range r.AttrStrings(\"srcs\") {\n\t\t\tif knownFiles[src] {\n\t\t\t\tcontinue outer\n\t\t\t}\n\t\t}\n\t\tempty = append(empty, rule.NewRule(\"proto_library\", r.Name()))\n\t}\n\treturn empty\n}", "code_tokens": ["func", "generateEmpty", "(", "f", "*", "rule", ".", "File", ",", "regularFiles", ",", "genFiles", "[", "]", "string", ")", "[", "]", "*", "rule", ".", "Rule", "{", "if", "f", "==", "nil", "{", "return", "nil", "\n", "}", "\n", "knownFiles", ":=", "make", "(", "map", "[", "string", "]", "bool", ")", "\n", "for", "_", ",", "f", ":=", "range", "regularFiles", "{", "knownFiles", "[", "f", "]", "=", "true", "\n", "}", "\n", "for", "_", ",", "f", ":=", "range", "genFiles", "{", "knownFiles", "[", "f", "]", "=", "true", "\n", "}", "\n", "var", "empty", "[", "]", "*", "rule", ".", "Rule", "\n", "outer", ":", "for", "_", ",", "r", ":=", "range", "f", ".", "Rules", "{", "if", "r", ".", "Kind", "(", ")", "!=", "\"", "\"", "{", "continue", "\n", "}", "\n", "srcs", ":=", "r", ".", "AttrStrings", "(", "\"", "\"", ")", "\n", "if", "len", "(", "srcs", ")", "==", "0", "&&", "r", ".", "Attr", "(", "\"", "\"", ")", "!=", "nil", "{", "// srcs is not a string list; leave it alone", "continue", "\n", "}", "\n", "for", "_", ",", "src", ":=", "range", "r", ".", "AttrStrings", "(", "\"", "\"", ")", "{", "if", "knownFiles", "[", "src", "]", "{", "continue", "outer", "\n", "}", "\n", "}", "\n", "empty", "=", "append", "(", "empty", ",", "rule", ".", "NewRule", "(", "\"", "\"", ",", "r", ".", "Name", "(", ")", ")", ")", "\n", "}", "\n", "return", "empty", "\n", "}"], "docstring": "// generateEmpty generates a list of proto_library rules that may be deleted.\n// This is generated from existing proto_library rules with srcs lists that\n// don't match any static or generated files.", "docstring_tokens": ["generateEmpty", "generates", "a", "list", "of", "proto_library", "rules", "that", "may", "be", "deleted", ".", "This", "is", "generated", "from", "existing", "proto_library", "rules", "with", "srcs", "lists", "that", "don", "t", "match", "any", "static", "or", "generated", "files", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/language/proto/generate.go#L235-L265", "partition": "test"}
{"repo": "hashicorp/raft", "path": "inmem_store.go", "func_name": "FirstIndex", "original_string": "func (i *InmemStore) FirstIndex() (uint64, error) {\n\ti.l.RLock()\n\tdefer i.l.RUnlock()\n\treturn i.lowIndex, nil\n}", "language": "go", "code": "func (i *InmemStore) FirstIndex() (uint64, error) {\n\ti.l.RLock()\n\tdefer i.l.RUnlock()\n\treturn i.lowIndex, nil\n}", "code_tokens": ["func", "(", "i", "*", "InmemStore", ")", "FirstIndex", "(", ")", "(", "uint64", ",", "error", ")", "{", "i", ".", "l", ".", "RLock", "(", ")", "\n", "defer", "i", ".", "l", ".", "RUnlock", "(", ")", "\n", "return", "i", ".", "lowIndex", ",", "nil", "\n", "}"], "docstring": "// FirstIndex implements the LogStore interface.", "docstring_tokens": ["FirstIndex", "implements", "the", "LogStore", "interface", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/inmem_store.go#L32-L36", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "boskos/mason/storage.go", "func_name": "GetConfig", "original_string": "func (s *Storage) GetConfig(name string) (common.ResourcesConfig, error) {\n\ti, err := s.configs.Get(name)\n\tif err != nil {\n\t\treturn common.ResourcesConfig{}, err\n\t}\n\tvar conf common.ResourcesConfig\n\tconf, err = common.ItemToResourcesConfig(i)\n\tif err != nil {\n\t\treturn common.ResourcesConfig{}, err\n\t}\n\treturn conf, nil\n}", "language": "go", "code": "func (s *Storage) GetConfig(name string) (common.ResourcesConfig, error) {\n\ti, err := s.configs.Get(name)\n\tif err != nil {\n\t\treturn common.ResourcesConfig{}, err\n\t}\n\tvar conf common.ResourcesConfig\n\tconf, err = common.ItemToResourcesConfig(i)\n\tif err != nil {\n\t\treturn common.ResourcesConfig{}, err\n\t}\n\treturn conf, nil\n}", "code_tokens": ["func", "(", "s", "*", "Storage", ")", "GetConfig", "(", "name", "string", ")", "(", "common", ".", "ResourcesConfig", ",", "error", ")", "{", "i", ",", "err", ":=", "s", ".", "configs", ".", "Get", "(", "name", ")", "\n", "if", "err", "!=", "nil", "{", "return", "common", ".", "ResourcesConfig", "{", "}", ",", "err", "\n", "}", "\n", "var", "conf", "common", ".", "ResourcesConfig", "\n", "conf", ",", "err", "=", "common", ".", "ItemToResourcesConfig", "(", "i", ")", "\n", "if", "err", "!=", "nil", "{", "return", "common", ".", "ResourcesConfig", "{", "}", ",", "err", "\n", "}", "\n", "return", "conf", ",", "nil", "\n", "}"], "docstring": "// GetConfig returns an existing if it exists errors out otherwise", "docstring_tokens": ["GetConfig", "returns", "an", "existing", "if", "it", "exists", "errors", "out", "otherwise"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/mason/storage.go#L58-L69", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "skl/skl.go", "func_name": "Key", "original_string": "func (s *Iterator) Key() []byte {\n\treturn s.list.arena.getKey(s.n.keyOffset, s.n.keySize)\n}", "language": "go", "code": "func (s *Iterator) Key() []byte {\n\treturn s.list.arena.getKey(s.n.keyOffset, s.n.keySize)\n}", "code_tokens": ["func", "(", "s", "*", "Iterator", ")", "Key", "(", ")", "[", "]", "byte", "{", "return", "s", ".", "list", ".", "arena", ".", "getKey", "(", "s", ".", "n", ".", "keyOffset", ",", "s", ".", "n", ".", "keySize", ")", "\n", "}"], "docstring": "// Key returns the key at the current position.", "docstring_tokens": ["Key", "returns", "the", "key", "at", "the", "current", "position", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/skl/skl.go#L419-L421", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "stream.go", "func_name": "produceKVs", "original_string": "func (st *Stream) produceKVs(ctx context.Context) error {\n\tvar size int\n\tvar txn *Txn\n\tif st.readTs > 0 {\n\t\ttxn = st.db.NewTransactionAt(st.readTs, false)\n\t} else {\n\t\ttxn = st.db.NewTransaction(false)\n\t}\n\tdefer txn.Discard()\n\n\titerate := func(kr keyRange) error {\n\t\titerOpts := DefaultIteratorOptions\n\t\titerOpts.AllVersions = true\n\t\titerOpts.Prefix = st.Prefix\n\t\titerOpts.PrefetchValues = false\n\t\titr := txn.NewIterator(iterOpts)\n\t\tdefer itr.Close()\n\n\t\toutList := new(pb.KVList)\n\t\tvar prevKey []byte\n\t\tfor itr.Seek(kr.left); itr.Valid(); {\n\t\t\t// it.Valid would only return true for keys with the provided Prefix in iterOpts.\n\t\t\titem := itr.Item()\n\t\t\tif bytes.Equal(item.Key(), prevKey) {\n\t\t\t\titr.Next()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprevKey = append(prevKey[:0], item.Key()...)\n\n\t\t\t// Check if we reached the end of the key range.\n\t\t\tif len(kr.right) > 0 && bytes.Compare(item.Key(), kr.right) >= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Check if we should pick this key.\n\t\t\tif st.ChooseKey != nil && !st.ChooseKey(item) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Now convert to key value.\n\t\t\tlist, err := st.KeyToList(item.KeyCopy(nil), itr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif list == nil || len(list.Kv) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\toutList.Kv = append(outList.Kv, list.Kv...)\n\t\t\tsize += list.Size()\n\t\t\tif size >= pageSize {\n\t\t\t\tst.kvChan <- outList\n\t\t\t\toutList = new(pb.KVList)\n\t\t\t\tsize = 0\n\t\t\t}\n\t\t}\n\t\tif len(outList.Kv) > 0 {\n\t\t\tst.kvChan <- outList\n\t\t}\n\t\treturn nil\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase kr, ok := <-st.rangeCh:\n\t\t\tif !ok {\n\t\t\t\t// Done with the keys.\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := iterate(kr); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\t}\n\t}\n}", "language": "go", "code": "func (st *Stream) produceKVs(ctx context.Context) error {\n\tvar size int\n\tvar txn *Txn\n\tif st.readTs > 0 {\n\t\ttxn = st.db.NewTransactionAt(st.readTs, false)\n\t} else {\n\t\ttxn = st.db.NewTransaction(false)\n\t}\n\tdefer txn.Discard()\n\n\titerate := func(kr keyRange) error {\n\t\titerOpts := DefaultIteratorOptions\n\t\titerOpts.AllVersions = true\n\t\titerOpts.Prefix = st.Prefix\n\t\titerOpts.PrefetchValues = false\n\t\titr := txn.NewIterator(iterOpts)\n\t\tdefer itr.Close()\n\n\t\toutList := new(pb.KVList)\n\t\tvar prevKey []byte\n\t\tfor itr.Seek(kr.left); itr.Valid(); {\n\t\t\t// it.Valid would only return true for keys with the provided Prefix in iterOpts.\n\t\t\titem := itr.Item()\n\t\t\tif bytes.Equal(item.Key(), prevKey) {\n\t\t\t\titr.Next()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprevKey = append(prevKey[:0], item.Key()...)\n\n\t\t\t// Check if we reached the end of the key range.\n\t\t\tif len(kr.right) > 0 && bytes.Compare(item.Key(), kr.right) >= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Check if we should pick this key.\n\t\t\tif st.ChooseKey != nil && !st.ChooseKey(item) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Now convert to key value.\n\t\t\tlist, err := st.KeyToList(item.KeyCopy(nil), itr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif list == nil || len(list.Kv) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\toutList.Kv = append(outList.Kv, list.Kv...)\n\t\t\tsize += list.Size()\n\t\t\tif size >= pageSize {\n\t\t\t\tst.kvChan <- outList\n\t\t\t\toutList = new(pb.KVList)\n\t\t\t\tsize = 0\n\t\t\t}\n\t\t}\n\t\tif len(outList.Kv) > 0 {\n\t\t\tst.kvChan <- outList\n\t\t}\n\t\treturn nil\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase kr, ok := <-st.rangeCh:\n\t\t\tif !ok {\n\t\t\t\t// Done with the keys.\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := iterate(kr); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "st", "*", "Stream", ")", "produceKVs", "(", "ctx", "context", ".", "Context", ")", "error", "{", "var", "size", "int", "\n", "var", "txn", "*", "Txn", "\n", "if", "st", ".", "readTs", ">", "0", "{", "txn", "=", "st", ".", "db", ".", "NewTransactionAt", "(", "st", ".", "readTs", ",", "false", ")", "\n", "}", "else", "{", "txn", "=", "st", ".", "db", ".", "NewTransaction", "(", "false", ")", "\n", "}", "\n", "defer", "txn", ".", "Discard", "(", ")", "\n\n", "iterate", ":=", "func", "(", "kr", "keyRange", ")", "error", "{", "iterOpts", ":=", "DefaultIteratorOptions", "\n", "iterOpts", ".", "AllVersions", "=", "true", "\n", "iterOpts", ".", "Prefix", "=", "st", ".", "Prefix", "\n", "iterOpts", ".", "PrefetchValues", "=", "false", "\n", "itr", ":=", "txn", ".", "NewIterator", "(", "iterOpts", ")", "\n", "defer", "itr", ".", "Close", "(", ")", "\n\n", "outList", ":=", "new", "(", "pb", ".", "KVList", ")", "\n", "var", "prevKey", "[", "]", "byte", "\n", "for", "itr", ".", "Seek", "(", "kr", ".", "left", ")", ";", "itr", ".", "Valid", "(", ")", ";", "{", "// it.Valid would only return true for keys with the provided Prefix in iterOpts.", "item", ":=", "itr", ".", "Item", "(", ")", "\n", "if", "bytes", ".", "Equal", "(", "item", ".", "Key", "(", ")", ",", "prevKey", ")", "{", "itr", ".", "Next", "(", ")", "\n", "continue", "\n", "}", "\n", "prevKey", "=", "append", "(", "prevKey", "[", ":", "0", "]", ",", "item", ".", "Key", "(", ")", "...", ")", "\n\n", "// Check if we reached the end of the key range.", "if", "len", "(", "kr", ".", "right", ")", ">", "0", "&&", "bytes", ".", "Compare", "(", "item", ".", "Key", "(", ")", ",", "kr", ".", "right", ")", ">=", "0", "{", "break", "\n", "}", "\n", "// Check if we should pick this key.", "if", "st", ".", "ChooseKey", "!=", "nil", "&&", "!", "st", ".", "ChooseKey", "(", "item", ")", "{", "continue", "\n", "}", "\n\n", "// Now convert to key value.", "list", ",", "err", ":=", "st", ".", "KeyToList", "(", "item", ".", "KeyCopy", "(", "nil", ")", ",", "itr", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "list", "==", "nil", "||", "len", "(", "list", ".", "Kv", ")", "==", "0", "{", "continue", "\n", "}", "\n", "outList", ".", "Kv", "=", "append", "(", "outList", ".", "Kv", ",", "list", ".", "Kv", "...", ")", "\n", "size", "+=", "list", ".", "Size", "(", ")", "\n", "if", "size", ">=", "pageSize", "{", "st", ".", "kvChan", "<-", "outList", "\n", "outList", "=", "new", "(", "pb", ".", "KVList", ")", "\n", "size", "=", "0", "\n", "}", "\n", "}", "\n", "if", "len", "(", "outList", ".", "Kv", ")", ">", "0", "{", "st", ".", "kvChan", "<-", "outList", "\n", "}", "\n", "return", "nil", "\n", "}", "\n\n", "for", "{", "select", "{", "case", "kr", ",", "ok", ":=", "<-", "st", ".", "rangeCh", ":", "if", "!", "ok", "{", "// Done with the keys.", "return", "nil", "\n", "}", "\n", "if", "err", ":=", "iterate", "(", "kr", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "case", "<-", "ctx", ".", "Done", "(", ")", ":", "return", "ctx", ".", "Err", "(", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// produceKVs picks up ranges from rangeCh, generates KV lists and sends them to kvChan.", "docstring_tokens": ["produceKVs", "picks", "up", "ranges", "from", "rangeCh", "generates", "KV", "lists", "and", "sends", "them", "to", "kvChan", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/stream.go#L128-L202", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/profiles.go", "func_name": "profileDelete", "original_string": "func profileDelete(d *Daemon, r *http.Request) Response {\n\tproject := projectParam(r)\n\tname := mux.Vars(r)[\"name\"]\n\n\tif name == \"default\" {\n\t\treturn Forbidden(errors.New(\"The 'default' profile cannot be deleted\"))\n\t}\n\n\terr := d.cluster.Transaction(func(tx *db.ClusterTx) error {\n\t\thasProfiles, err := tx.ProjectHasProfiles(project)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"Check project features\")\n\t\t}\n\n\t\tif !hasProfiles {\n\t\t\tproject = \"default\"\n\t\t}\n\n\t\tprofile, err := tx.ProfileGet(project, name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(profile.UsedBy) > 0 {\n\t\t\treturn fmt.Errorf(\"Profile is currently in use\")\n\t\t}\n\n\t\treturn tx.ProfileDelete(project, name)\n\t})\n\tif err != nil {\n\t\treturn SmartError(err)\n\t}\n\n\treturn EmptySyncResponse\n}", "language": "go", "code": "func profileDelete(d *Daemon, r *http.Request) Response {\n\tproject := projectParam(r)\n\tname := mux.Vars(r)[\"name\"]\n\n\tif name == \"default\" {\n\t\treturn Forbidden(errors.New(\"The 'default' profile cannot be deleted\"))\n\t}\n\n\terr := d.cluster.Transaction(func(tx *db.ClusterTx) error {\n\t\thasProfiles, err := tx.ProjectHasProfiles(project)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"Check project features\")\n\t\t}\n\n\t\tif !hasProfiles {\n\t\t\tproject = \"default\"\n\t\t}\n\n\t\tprofile, err := tx.ProfileGet(project, name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(profile.UsedBy) > 0 {\n\t\t\treturn fmt.Errorf(\"Profile is currently in use\")\n\t\t}\n\n\t\treturn tx.ProfileDelete(project, name)\n\t})\n\tif err != nil {\n\t\treturn SmartError(err)\n\t}\n\n\treturn EmptySyncResponse\n}", "code_tokens": ["func", "profileDelete", "(", "d", "*", "Daemon", ",", "r", "*", "http", ".", "Request", ")", "Response", "{", "project", ":=", "projectParam", "(", "r", ")", "\n", "name", ":=", "mux", ".", "Vars", "(", "r", ")", "[", "\"", "\"", "]", "\n\n", "if", "name", "==", "\"", "\"", "{", "return", "Forbidden", "(", "errors", ".", "New", "(", "\"", "\"", ")", ")", "\n", "}", "\n\n", "err", ":=", "d", ".", "cluster", ".", "Transaction", "(", "func", "(", "tx", "*", "db", ".", "ClusterTx", ")", "error", "{", "hasProfiles", ",", "err", ":=", "tx", ".", "ProjectHasProfiles", "(", "project", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n\n", "if", "!", "hasProfiles", "{", "project", "=", "\"", "\"", "\n", "}", "\n\n", "profile", ",", "err", ":=", "tx", ".", "ProfileGet", "(", "project", ",", "name", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "len", "(", "profile", ".", "UsedBy", ")", ">", "0", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "tx", ".", "ProfileDelete", "(", "project", ",", "name", ")", "\n", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "SmartError", "(", "err", ")", "\n", "}", "\n\n", "return", "EmptySyncResponse", "\n", "}"], "docstring": "// The handler for the delete operation.", "docstring_tokens": ["The", "handler", "for", "the", "delete", "operation", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/profiles.go#L414-L447", "partition": "test"}
{"repo": "segmentio/objconv", "path": "codec.go", "func_name": "Codecs", "original_string": "func (reg *Registry) Codecs() (codecs map[string]Codec) {\n\tcodecs = make(map[string]Codec)\n\treg.mutex.RLock()\n\tfor mimetype, codec := range reg.codecs {\n\t\tcodecs[mimetype] = codec\n\t}\n\treg.mutex.RUnlock()\n\treturn\n}", "language": "go", "code": "func (reg *Registry) Codecs() (codecs map[string]Codec) {\n\tcodecs = make(map[string]Codec)\n\treg.mutex.RLock()\n\tfor mimetype, codec := range reg.codecs {\n\t\tcodecs[mimetype] = codec\n\t}\n\treg.mutex.RUnlock()\n\treturn\n}", "code_tokens": ["func", "(", "reg", "*", "Registry", ")", "Codecs", "(", ")", "(", "codecs", "map", "[", "string", "]", "Codec", ")", "{", "codecs", "=", "make", "(", "map", "[", "string", "]", "Codec", ")", "\n", "reg", ".", "mutex", ".", "RLock", "(", ")", "\n", "for", "mimetype", ",", "codec", ":=", "range", "reg", ".", "codecs", "{", "codecs", "[", "mimetype", "]", "=", "codec", "\n", "}", "\n", "reg", ".", "mutex", ".", "RUnlock", "(", ")", "\n", "return", "\n", "}"], "docstring": "// Codecs returns a map of all codecs registered in reg.", "docstring_tokens": ["Codecs", "returns", "a", "map", "of", "all", "codecs", "registered", "in", "reg", "."], "sha": "7a1d7b8e6f3551b30751e6b2ea6bae500883870e", "url": "https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/codec.go#L72-L80", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "samples/line/line.go", "func_name": "Main", "original_string": "func Main(gc draw2d.GraphicContext, ext string) (string, error) {\n\tgc.SetFillRule(draw2d.FillRuleWinding)\n\tgc.Clear()\n\t// Draw the line\n\tfor x := 5.0; x < 297; x += 10 {\n\t\tDraw(gc, x, 0, x, 210)\n\t}\n\tgc.ClearRect(100, 75, 197, 135)\n\tdraw2dkit.Ellipse(gc, 148.5, 105, 35, 25)\n\tgc.SetFillColor(color.RGBA{0xff, 0xff, 0x44, 0xff})\n\tgc.FillStroke()\n\n\t// Return the output filename\n\treturn samples.Output(\"line\", ext), nil\n}", "language": "go", "code": "func Main(gc draw2d.GraphicContext, ext string) (string, error) {\n\tgc.SetFillRule(draw2d.FillRuleWinding)\n\tgc.Clear()\n\t// Draw the line\n\tfor x := 5.0; x < 297; x += 10 {\n\t\tDraw(gc, x, 0, x, 210)\n\t}\n\tgc.ClearRect(100, 75, 197, 135)\n\tdraw2dkit.Ellipse(gc, 148.5, 105, 35, 25)\n\tgc.SetFillColor(color.RGBA{0xff, 0xff, 0x44, 0xff})\n\tgc.FillStroke()\n\n\t// Return the output filename\n\treturn samples.Output(\"line\", ext), nil\n}", "code_tokens": ["func", "Main", "(", "gc", "draw2d", ".", "GraphicContext", ",", "ext", "string", ")", "(", "string", ",", "error", ")", "{", "gc", ".", "SetFillRule", "(", "draw2d", ".", "FillRuleWinding", ")", "\n", "gc", ".", "Clear", "(", ")", "\n", "// Draw the line", "for", "x", ":=", "5.0", ";", "x", "<", "297", ";", "x", "+=", "10", "{", "Draw", "(", "gc", ",", "x", ",", "0", ",", "x", ",", "210", ")", "\n", "}", "\n", "gc", ".", "ClearRect", "(", "100", ",", "75", ",", "197", ",", "135", ")", "\n", "draw2dkit", ".", "Ellipse", "(", "gc", ",", "148.5", ",", "105", ",", "35", ",", "25", ")", "\n", "gc", ".", "SetFillColor", "(", "color", ".", "RGBA", "{", "0xff", ",", "0xff", ",", "0x44", ",", "0xff", "}", ")", "\n", "gc", ".", "FillStroke", "(", ")", "\n\n", "// Return the output filename", "return", "samples", ".", "Output", "(", "\"", "\"", ",", "ext", ")", ",", "nil", "\n", "}"], "docstring": "// Main draws vertically spaced lines and returns the filename.\n// This should only be used during testing.", "docstring_tokens": ["Main", "draws", "vertically", "spaced", "lines", "and", "returns", "the", "filename", ".", "This", "should", "only", "be", "used", "during", "testing", "."], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/samples/line/line.go#L17-L31", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/containers.go", "func_name": "ContainerConfigRemove", "original_string": "func (c *Cluster) ContainerConfigRemove(id int, key string) error {\n\terr := exec(c.db, \"DELETE FROM containers_config WHERE key=? AND container_id=?\", key, id)\n\treturn err\n}", "language": "go", "code": "func (c *Cluster) ContainerConfigRemove(id int, key string) error {\n\terr := exec(c.db, \"DELETE FROM containers_config WHERE key=? AND container_id=?\", key, id)\n\treturn err\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "ContainerConfigRemove", "(", "id", "int", ",", "key", "string", ")", "error", "{", "err", ":=", "exec", "(", "c", ".", "db", ",", "\"", "\"", ",", "key", ",", "id", ")", "\n", "return", "err", "\n", "}"], "docstring": "// ContainerConfigRemove removes the given key from the config of the container\n// with the given ID.", "docstring_tokens": ["ContainerConfigRemove", "removes", "the", "given", "key", "from", "the", "config", "of", "the", "container", "with", "the", "given", "ID", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/containers.go#L634-L637", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pps/util.go", "func_name": "InputName", "original_string": "func InputName(input *Input) string {\n\tswitch {\n\tcase input == nil:\n\t\treturn \"\"\n\tcase input.Pfs != nil:\n\t\treturn input.Pfs.Name\n\tcase input.Cross != nil:\n\t\tif len(input.Cross) > 0 {\n\t\t\treturn InputName(input.Cross[0])\n\t\t}\n\tcase input.Union != nil:\n\t\tif len(input.Union) > 0 {\n\t\t\treturn InputName(input.Union[0])\n\t\t}\n\t}\n\treturn \"\"\n}", "language": "go", "code": "func InputName(input *Input) string {\n\tswitch {\n\tcase input == nil:\n\t\treturn \"\"\n\tcase input.Pfs != nil:\n\t\treturn input.Pfs.Name\n\tcase input.Cross != nil:\n\t\tif len(input.Cross) > 0 {\n\t\t\treturn InputName(input.Cross[0])\n\t\t}\n\tcase input.Union != nil:\n\t\tif len(input.Union) > 0 {\n\t\t\treturn InputName(input.Union[0])\n\t\t}\n\t}\n\treturn \"\"\n}", "code_tokens": ["func", "InputName", "(", "input", "*", "Input", ")", "string", "{", "switch", "{", "case", "input", "==", "nil", ":", "return", "\"", "\"", "\n", "case", "input", ".", "Pfs", "!=", "nil", ":", "return", "input", ".", "Pfs", ".", "Name", "\n", "case", "input", ".", "Cross", "!=", "nil", ":", "if", "len", "(", "input", ".", "Cross", ")", ">", "0", "{", "return", "InputName", "(", "input", ".", "Cross", "[", "0", "]", ")", "\n", "}", "\n", "case", "input", ".", "Union", "!=", "nil", ":", "if", "len", "(", "input", ".", "Union", ")", ">", "0", "{", "return", "InputName", "(", "input", ".", "Union", "[", "0", "]", ")", "\n", "}", "\n", "}", "\n", "return", "\"", "\"", "\n", "}"], "docstring": "// InputName computes the name of an Input.", "docstring_tokens": ["InputName", "computes", "the", "name", "of", "an", "Input", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pps/util.go#L31-L47", "partition": "test"}
{"repo": "st3v/tracerr", "path": "tracerr.go", "func_name": "string", "original_string": "func (s *stackFrame) string() string {\n\treturn fmt.Sprintf(\"%s (%s:%d)\", s.function, s.file, s.line)\n}", "language": "go", "code": "func (s *stackFrame) string() string {\n\treturn fmt.Sprintf(\"%s (%s:%d)\", s.function, s.file, s.line)\n}", "code_tokens": ["func", "(", "s", "*", "stackFrame", ")", "string", "(", ")", "string", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "s", ".", "function", ",", "s", ".", "file", ",", "s", ".", "line", ")", "\n", "}"], "docstring": "// string converts a given stack frame to a formated string.", "docstring_tokens": ["string", "converts", "a", "given", "stack", "frame", "to", "a", "formated", "string", "."], "sha": "07f754d5ee02576c14a8272df820e8947d87e723", "url": "https://github.com/st3v/tracerr/blob/07f754d5ee02576c14a8272df820e8947d87e723/tracerr.go#L81-L83", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "stream.go", "func_name": "NewStream", "original_string": "func (db *DB) NewStream() *Stream {\n\tif db.opt.managedTxns {\n\t\tpanic(\"This API can not be called in managed mode.\")\n\t}\n\treturn db.newStream()\n}", "language": "go", "code": "func (db *DB) NewStream() *Stream {\n\tif db.opt.managedTxns {\n\t\tpanic(\"This API can not be called in managed mode.\")\n\t}\n\treturn db.newStream()\n}", "code_tokens": ["func", "(", "db", "*", "DB", ")", "NewStream", "(", ")", "*", "Stream", "{", "if", "db", ".", "opt", ".", "managedTxns", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "db", ".", "newStream", "(", ")", "\n", "}"], "docstring": "// NewStream creates a new Stream.", "docstring_tokens": ["NewStream", "creates", "a", "new", "Stream", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/stream.go#L332-L337", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/leasing/kv.go", "func_name": "rescind", "original_string": "func (lkv *leasingKV) rescind(ctx context.Context, key string, rev int64) {\n\tif lkv.leases.Evict(key) > rev {\n\t\treturn\n\t}\n\tcmp := v3.Compare(v3.CreateRevision(lkv.pfx+key), \"<\", rev)\n\top := v3.OpDelete(lkv.pfx + key)\n\tfor ctx.Err() == nil {\n\t\tif _, err := lkv.kv.Txn(ctx).If(cmp).Then(op).Commit(); err == nil {\n\t\t\treturn\n\t\t}\n\t}\n}", "language": "go", "code": "func (lkv *leasingKV) rescind(ctx context.Context, key string, rev int64) {\n\tif lkv.leases.Evict(key) > rev {\n\t\treturn\n\t}\n\tcmp := v3.Compare(v3.CreateRevision(lkv.pfx+key), \"<\", rev)\n\top := v3.OpDelete(lkv.pfx + key)\n\tfor ctx.Err() == nil {\n\t\tif _, err := lkv.kv.Txn(ctx).If(cmp).Then(op).Commit(); err == nil {\n\t\t\treturn\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "lkv", "*", "leasingKV", ")", "rescind", "(", "ctx", "context", ".", "Context", ",", "key", "string", ",", "rev", "int64", ")", "{", "if", "lkv", ".", "leases", ".", "Evict", "(", "key", ")", ">", "rev", "{", "return", "\n", "}", "\n", "cmp", ":=", "v3", ".", "Compare", "(", "v3", ".", "CreateRevision", "(", "lkv", ".", "pfx", "+", "key", ")", ",", "\"", "\"", ",", "rev", ")", "\n", "op", ":=", "v3", ".", "OpDelete", "(", "lkv", ".", "pfx", "+", "key", ")", "\n", "for", "ctx", ".", "Err", "(", ")", "==", "nil", "{", "if", "_", ",", "err", ":=", "lkv", ".", "kv", ".", "Txn", "(", "ctx", ")", ".", "If", "(", "cmp", ")", ".", "Then", "(", "op", ")", ".", "Commit", "(", ")", ";", "err", "==", "nil", "{", "return", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// rescind releases a lease from this client.", "docstring_tokens": ["rescind", "releases", "a", "lease", "from", "this", "client", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/leasing/kv.go#L186-L197", "partition": "test"}
{"repo": "gravitational/roundtrip", "path": "client.go", "func_name": "FileName", "original_string": "func (r *FileResponse) FileName() string {\n\tvalue := r.headers.Get(\"Content-Disposition\")\n\tif len(value) == 0 {\n\t\treturn \"\"\n\t}\n\t_, params, err := mime.ParseMediaType(value)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn params[\"filename\"]\n}", "language": "go", "code": "func (r *FileResponse) FileName() string {\n\tvalue := r.headers.Get(\"Content-Disposition\")\n\tif len(value) == 0 {\n\t\treturn \"\"\n\t}\n\t_, params, err := mime.ParseMediaType(value)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn params[\"filename\"]\n}", "code_tokens": ["func", "(", "r", "*", "FileResponse", ")", "FileName", "(", ")", "string", "{", "value", ":=", "r", ".", "headers", ".", "Get", "(", "\"", "\"", ")", "\n", "if", "len", "(", "value", ")", "==", "0", "{", "return", "\"", "\"", "\n", "}", "\n", "_", ",", "params", ",", "err", ":=", "mime", ".", "ParseMediaType", "(", "value", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", "\n", "}", "\n", "return", "params", "[", "\"", "\"", "]", "\n", "}"], "docstring": "// FileName returns HTTP file name", "docstring_tokens": ["FileName", "returns", "HTTP", "file", "name"], "sha": "e1e0cd6b05a6bb1791b262e63160038828fd7b3a", "url": "https://github.com/gravitational/roundtrip/blob/e1e0cd6b05a6bb1791b262e63160038828fd7b3a/client.go#L555-L565", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "log/namespaced/namespaces.go", "func_name": "Set", "original_string": "func (n *ns) Set(namespaces []string) {\n\tn.Lock()\n\tdefer n.Unlock()\n\tn.namespaces = namespaces\n}", "language": "go", "code": "func (n *ns) Set(namespaces []string) {\n\tn.Lock()\n\tdefer n.Unlock()\n\tn.namespaces = namespaces\n}", "code_tokens": ["func", "(", "n", "*", "ns", ")", "Set", "(", "namespaces", "[", "]", "string", ")", "{", "n", ".", "Lock", "(", ")", "\n", "defer", "n", ".", "Unlock", "(", ")", "\n", "n", ".", "namespaces", "=", "namespaces", "\n", "}"], "docstring": "// Set updates the namespaces", "docstring_tokens": ["Set", "updates", "the", "namespaces"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/log/namespaced/namespaces.go#L49-L53", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/gerrit/client/client.go", "func_name": "SetReview", "original_string": "func (c *Client) SetReview(instance, id, revision, message string, labels map[string]string) error {\n\th, ok := c.handlers[instance]\n\tif !ok {\n\t\treturn fmt.Errorf(\"not activated gerrit instance: %s\", instance)\n\t}\n\n\tif _, _, err := h.changeService.SetReview(id, revision, &gerrit.ReviewInput{\n\t\tMessage: message,\n\t\tLabels:  labels,\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"cannot comment to gerrit: %v\", err)\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *Client) SetReview(instance, id, revision, message string, labels map[string]string) error {\n\th, ok := c.handlers[instance]\n\tif !ok {\n\t\treturn fmt.Errorf(\"not activated gerrit instance: %s\", instance)\n\t}\n\n\tif _, _, err := h.changeService.SetReview(id, revision, &gerrit.ReviewInput{\n\t\tMessage: message,\n\t\tLabels:  labels,\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"cannot comment to gerrit: %v\", err)\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "SetReview", "(", "instance", ",", "id", ",", "revision", ",", "message", "string", ",", "labels", "map", "[", "string", "]", "string", ")", "error", "{", "h", ",", "ok", ":=", "c", ".", "handlers", "[", "instance", "]", "\n", "if", "!", "ok", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "instance", ")", "\n", "}", "\n\n", "if", "_", ",", "_", ",", "err", ":=", "h", ".", "changeService", ".", "SetReview", "(", "id", ",", "revision", ",", "&", "gerrit", ".", "ReviewInput", "{", "Message", ":", "message", ",", "Labels", ":", "labels", ",", "}", ")", ";", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// SetReview writes a review comment base on the change id + revision", "docstring_tokens": ["SetReview", "writes", "a", "review", "comment", "base", "on", "the", "change", "id", "+", "revision"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/gerrit/client/client.go#L208-L222", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "fragmenting_writer.go", "func_name": "newWritableChunk", "original_string": "func newWritableChunk(checksum Checksum, contents *typed.WriteBuffer) *writableChunk {\n\treturn &writableChunk{\n\t\tsize:     0,\n\t\tsizeRef:  contents.DeferUint16(),\n\t\tchecksum: checksum,\n\t\tcontents: contents,\n\t}\n}", "language": "go", "code": "func newWritableChunk(checksum Checksum, contents *typed.WriteBuffer) *writableChunk {\n\treturn &writableChunk{\n\t\tsize:     0,\n\t\tsizeRef:  contents.DeferUint16(),\n\t\tchecksum: checksum,\n\t\tcontents: contents,\n\t}\n}", "code_tokens": ["func", "newWritableChunk", "(", "checksum", "Checksum", ",", "contents", "*", "typed", ".", "WriteBuffer", ")", "*", "writableChunk", "{", "return", "&", "writableChunk", "{", "size", ":", "0", ",", "sizeRef", ":", "contents", ".", "DeferUint16", "(", ")", ",", "checksum", ":", "checksum", ",", "contents", ":", "contents", ",", "}", "\n", "}"], "docstring": "// newWritableChunk creates a new writable chunk around a checksum and a buffer to hold data", "docstring_tokens": ["newWritableChunk", "creates", "a", "new", "writable", "chunk", "around", "a", "checksum", "and", "a", "buffer", "to", "hold", "data"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/fragmenting_writer.go#L72-L79", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/tide/tide.go", "func_name": "accumulate", "original_string": "func accumulate(presubmits map[int][]config.Presubmit, prs []PullRequest, pjs []prowapi.ProwJob, log *logrus.Entry) (successes, pendings, nones []PullRequest) {\n\tfor _, pr := range prs {\n\t\t// Accumulate the best result for each job.\n\t\tpsStates := make(map[string]simpleState)\n\t\tfor _, pj := range pjs {\n\t\t\tif pj.Spec.Type != prowapi.PresubmitJob {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif pj.Spec.Refs.Pulls[0].Number != int(pr.Number) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif pj.Spec.Refs.Pulls[0].SHA != string(pr.HeadRefOID) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tname := pj.Spec.Context\n\t\t\toldState := psStates[name]\n\t\t\tnewState := toSimpleState(pj.Status.State)\n\t\t\tif oldState == failureState || oldState == \"\" {\n\t\t\t\tpsStates[name] = newState\n\t\t\t} else if oldState == pendingState && newState == successState {\n\t\t\t\tpsStates[name] = successState\n\t\t\t}\n\t\t}\n\t\t// The overall result is the worst of the best.\n\t\toverallState := successState\n\t\tfor _, ps := range presubmits[int(pr.Number)] {\n\t\t\tif s, ok := psStates[ps.Context]; !ok {\n\t\t\t\toverallState = failureState\n\t\t\t\tlog.WithFields(pr.logFields()).Debugf(\"missing presubmit %s\", ps.Context)\n\t\t\t\tbreak\n\t\t\t} else if s == failureState {\n\t\t\t\toverallState = failureState\n\t\t\t\tlog.WithFields(pr.logFields()).Debugf(\"presubmit %s not passing\", ps.Context)\n\t\t\t\tbreak\n\t\t\t} else if s == pendingState {\n\t\t\t\tlog.WithFields(pr.logFields()).Debugf(\"presubmit %s pending\", ps.Context)\n\t\t\t\toverallState = pendingState\n\t\t\t}\n\t\t}\n\t\tif overallState == successState {\n\t\t\tsuccesses = append(successes, pr)\n\t\t} else if overallState == pendingState {\n\t\t\tpendings = append(pendings, pr)\n\t\t} else {\n\t\t\tnones = append(nones, pr)\n\t\t}\n\t}\n\treturn\n}", "language": "go", "code": "func accumulate(presubmits map[int][]config.Presubmit, prs []PullRequest, pjs []prowapi.ProwJob, log *logrus.Entry) (successes, pendings, nones []PullRequest) {\n\tfor _, pr := range prs {\n\t\t// Accumulate the best result for each job.\n\t\tpsStates := make(map[string]simpleState)\n\t\tfor _, pj := range pjs {\n\t\t\tif pj.Spec.Type != prowapi.PresubmitJob {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif pj.Spec.Refs.Pulls[0].Number != int(pr.Number) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif pj.Spec.Refs.Pulls[0].SHA != string(pr.HeadRefOID) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tname := pj.Spec.Context\n\t\t\toldState := psStates[name]\n\t\t\tnewState := toSimpleState(pj.Status.State)\n\t\t\tif oldState == failureState || oldState == \"\" {\n\t\t\t\tpsStates[name] = newState\n\t\t\t} else if oldState == pendingState && newState == successState {\n\t\t\t\tpsStates[name] = successState\n\t\t\t}\n\t\t}\n\t\t// The overall result is the worst of the best.\n\t\toverallState := successState\n\t\tfor _, ps := range presubmits[int(pr.Number)] {\n\t\t\tif s, ok := psStates[ps.Context]; !ok {\n\t\t\t\toverallState = failureState\n\t\t\t\tlog.WithFields(pr.logFields()).Debugf(\"missing presubmit %s\", ps.Context)\n\t\t\t\tbreak\n\t\t\t} else if s == failureState {\n\t\t\t\toverallState = failureState\n\t\t\t\tlog.WithFields(pr.logFields()).Debugf(\"presubmit %s not passing\", ps.Context)\n\t\t\t\tbreak\n\t\t\t} else if s == pendingState {\n\t\t\t\tlog.WithFields(pr.logFields()).Debugf(\"presubmit %s pending\", ps.Context)\n\t\t\t\toverallState = pendingState\n\t\t\t}\n\t\t}\n\t\tif overallState == successState {\n\t\t\tsuccesses = append(successes, pr)\n\t\t} else if overallState == pendingState {\n\t\t\tpendings = append(pendings, pr)\n\t\t} else {\n\t\t\tnones = append(nones, pr)\n\t\t}\n\t}\n\treturn\n}", "code_tokens": ["func", "accumulate", "(", "presubmits", "map", "[", "int", "]", "[", "]", "config", ".", "Presubmit", ",", "prs", "[", "]", "PullRequest", ",", "pjs", "[", "]", "prowapi", ".", "ProwJob", ",", "log", "*", "logrus", ".", "Entry", ")", "(", "successes", ",", "pendings", ",", "nones", "[", "]", "PullRequest", ")", "{", "for", "_", ",", "pr", ":=", "range", "prs", "{", "// Accumulate the best result for each job.", "psStates", ":=", "make", "(", "map", "[", "string", "]", "simpleState", ")", "\n", "for", "_", ",", "pj", ":=", "range", "pjs", "{", "if", "pj", ".", "Spec", ".", "Type", "!=", "prowapi", ".", "PresubmitJob", "{", "continue", "\n", "}", "\n", "if", "pj", ".", "Spec", ".", "Refs", ".", "Pulls", "[", "0", "]", ".", "Number", "!=", "int", "(", "pr", ".", "Number", ")", "{", "continue", "\n", "}", "\n", "if", "pj", ".", "Spec", ".", "Refs", ".", "Pulls", "[", "0", "]", ".", "SHA", "!=", "string", "(", "pr", ".", "HeadRefOID", ")", "{", "continue", "\n", "}", "\n\n", "name", ":=", "pj", ".", "Spec", ".", "Context", "\n", "oldState", ":=", "psStates", "[", "name", "]", "\n", "newState", ":=", "toSimpleState", "(", "pj", ".", "Status", ".", "State", ")", "\n", "if", "oldState", "==", "failureState", "||", "oldState", "==", "\"", "\"", "{", "psStates", "[", "name", "]", "=", "newState", "\n", "}", "else", "if", "oldState", "==", "pendingState", "&&", "newState", "==", "successState", "{", "psStates", "[", "name", "]", "=", "successState", "\n", "}", "\n", "}", "\n", "// The overall result is the worst of the best.", "overallState", ":=", "successState", "\n", "for", "_", ",", "ps", ":=", "range", "presubmits", "[", "int", "(", "pr", ".", "Number", ")", "]", "{", "if", "s", ",", "ok", ":=", "psStates", "[", "ps", ".", "Context", "]", ";", "!", "ok", "{", "overallState", "=", "failureState", "\n", "log", ".", "WithFields", "(", "pr", ".", "logFields", "(", ")", ")", ".", "Debugf", "(", "\"", "\"", ",", "ps", ".", "Context", ")", "\n", "break", "\n", "}", "else", "if", "s", "==", "failureState", "{", "overallState", "=", "failureState", "\n", "log", ".", "WithFields", "(", "pr", ".", "logFields", "(", ")", ")", ".", "Debugf", "(", "\"", "\"", ",", "ps", ".", "Context", ")", "\n", "break", "\n", "}", "else", "if", "s", "==", "pendingState", "{", "log", ".", "WithFields", "(", "pr", ".", "logFields", "(", ")", ")", ".", "Debugf", "(", "\"", "\"", ",", "ps", ".", "Context", ")", "\n", "overallState", "=", "pendingState", "\n", "}", "\n", "}", "\n", "if", "overallState", "==", "successState", "{", "successes", "=", "append", "(", "successes", ",", "pr", ")", "\n", "}", "else", "if", "overallState", "==", "pendingState", "{", "pendings", "=", "append", "(", "pendings", ",", "pr", ")", "\n", "}", "else", "{", "nones", "=", "append", "(", "nones", ",", "pr", ")", "\n", "}", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// accumulate returns the supplied PRs sorted into three buckets based on their\n// accumulated state across the presubmits.", "docstring_tokens": ["accumulate", "returns", "the", "supplied", "PRs", "sorted", "into", "three", "buckets", "based", "on", "their", "accumulated", "state", "across", "the", "presubmits", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/tide/tide.go#L701-L750", "partition": "test"}
{"repo": "urandom/handler", "path": "response_wrapper.go", "func_name": "CloseNotify", "original_string": "func (w *ResponseWrapper) CloseNotify() <-chan bool {\n\tif notifier, ok := w.writer.(http.CloseNotifier); ok {\n\t\tc := notifier.CloseNotify()\n\t\treturn c\n\t}\n\n\treturn make(chan bool)\n}", "language": "go", "code": "func (w *ResponseWrapper) CloseNotify() <-chan bool {\n\tif notifier, ok := w.writer.(http.CloseNotifier); ok {\n\t\tc := notifier.CloseNotify()\n\t\treturn c\n\t}\n\n\treturn make(chan bool)\n}", "code_tokens": ["func", "(", "w", "*", "ResponseWrapper", ")", "CloseNotify", "(", ")", "<-", "chan", "bool", "{", "if", "notifier", ",", "ok", ":=", "w", ".", "writer", ".", "(", "http", ".", "CloseNotifier", ")", ";", "ok", "{", "c", ":=", "notifier", ".", "CloseNotify", "(", ")", "\n", "return", "c", "\n", "}", "\n\n", "return", "make", "(", "chan", "bool", ")", "\n", "}"], "docstring": "// CloseNotify tries to use the original http.ResponseWriter for close\n// notification. If the original writer doesn't implement http.CloseNotifier,\n// it returns a channel that will never close.", "docstring_tokens": ["CloseNotify", "tries", "to", "use", "the", "original", "http", ".", "ResponseWriter", "for", "close", "notification", ".", "If", "the", "original", "writer", "doesn", "t", "implement", "http", ".", "CloseNotifier", "it", "returns", "a", "channel", "that", "will", "never", "close", "."], "sha": "61508044a5569d1609521d81e81f6737567fd104", "url": "https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/response_wrapper.go#L48-L55", "partition": "test"}
{"repo": "jhillyerd/enmime", "path": "envelope.go", "func_name": "GetHeaderValues", "original_string": "func (e *Envelope) GetHeaderValues(name string) []string {\n\tif e.header == nil {\n\t\treturn []string{}\n\t}\n\n\trawValues := (*e.header)[textproto.CanonicalMIMEHeaderKey(name)]\n\tvar values []string\n\tfor _, v := range rawValues {\n\t\tvalues = append(values, decodeHeader(v))\n\t}\n\treturn values\n}", "language": "go", "code": "func (e *Envelope) GetHeaderValues(name string) []string {\n\tif e.header == nil {\n\t\treturn []string{}\n\t}\n\n\trawValues := (*e.header)[textproto.CanonicalMIMEHeaderKey(name)]\n\tvar values []string\n\tfor _, v := range rawValues {\n\t\tvalues = append(values, decodeHeader(v))\n\t}\n\treturn values\n}", "code_tokens": ["func", "(", "e", "*", "Envelope", ")", "GetHeaderValues", "(", "name", "string", ")", "[", "]", "string", "{", "if", "e", ".", "header", "==", "nil", "{", "return", "[", "]", "string", "{", "}", "\n", "}", "\n\n", "rawValues", ":=", "(", "*", "e", ".", "header", ")", "[", "textproto", ".", "CanonicalMIMEHeaderKey", "(", "name", ")", "]", "\n", "var", "values", "[", "]", "string", "\n", "for", "_", ",", "v", ":=", "range", "rawValues", "{", "values", "=", "append", "(", "values", ",", "decodeHeader", "(", "v", ")", ")", "\n", "}", "\n", "return", "values", "\n", "}"], "docstring": "// GetHeaderValues processes the specified header for RFC 2047 encoded words and returns all existing\n// values as a list of UTF-8 strings", "docstring_tokens": ["GetHeaderValues", "processes", "the", "specified", "header", "for", "RFC", "2047", "encoded", "words", "and", "returns", "all", "existing", "values", "as", "a", "list", "of", "UTF", "-", "8", "strings"], "sha": "874cc30e023f36bd1df525716196887b0f04851b", "url": "https://github.com/jhillyerd/enmime/blob/874cc30e023f36bd1df525716196887b0f04851b/envelope.go#L53-L64", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/github/client.go", "func_name": "IsMergeable", "original_string": "func (c *Client) IsMergeable(org, repo string, number int, SHA string) (bool, error) {\n\tbackoff := time.Second * 3\n\tmaxTries := 3\n\tfor try := 0; try < maxTries; try++ {\n\t\tpr, err := c.GetPullRequest(org, repo, number)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif pr.Head.SHA != SHA {\n\t\t\treturn false, fmt.Errorf(\"pull request head changed while checking mergeability (%s -> %s)\", SHA, pr.Head.SHA)\n\t\t}\n\t\tif pr.Merged {\n\t\t\treturn false, errors.New(\"pull request was merged while checking mergeability\")\n\t\t}\n\t\tif pr.Mergable != nil {\n\t\t\treturn *pr.Mergable, nil\n\t\t}\n\t\tif try+1 < maxTries {\n\t\t\tc.time.Sleep(backoff)\n\t\t\tbackoff *= 2\n\t\t}\n\t}\n\treturn false, fmt.Errorf(\"reached maximum number of retries (%d) checking mergeability\", maxTries)\n}", "language": "go", "code": "func (c *Client) IsMergeable(org, repo string, number int, SHA string) (bool, error) {\n\tbackoff := time.Second * 3\n\tmaxTries := 3\n\tfor try := 0; try < maxTries; try++ {\n\t\tpr, err := c.GetPullRequest(org, repo, number)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif pr.Head.SHA != SHA {\n\t\t\treturn false, fmt.Errorf(\"pull request head changed while checking mergeability (%s -> %s)\", SHA, pr.Head.SHA)\n\t\t}\n\t\tif pr.Merged {\n\t\t\treturn false, errors.New(\"pull request was merged while checking mergeability\")\n\t\t}\n\t\tif pr.Mergable != nil {\n\t\t\treturn *pr.Mergable, nil\n\t\t}\n\t\tif try+1 < maxTries {\n\t\t\tc.time.Sleep(backoff)\n\t\t\tbackoff *= 2\n\t\t}\n\t}\n\treturn false, fmt.Errorf(\"reached maximum number of retries (%d) checking mergeability\", maxTries)\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "IsMergeable", "(", "org", ",", "repo", "string", ",", "number", "int", ",", "SHA", "string", ")", "(", "bool", ",", "error", ")", "{", "backoff", ":=", "time", ".", "Second", "*", "3", "\n", "maxTries", ":=", "3", "\n", "for", "try", ":=", "0", ";", "try", "<", "maxTries", ";", "try", "++", "{", "pr", ",", "err", ":=", "c", ".", "GetPullRequest", "(", "org", ",", "repo", ",", "number", ")", "\n", "if", "err", "!=", "nil", "{", "return", "false", ",", "err", "\n", "}", "\n", "if", "pr", ".", "Head", ".", "SHA", "!=", "SHA", "{", "return", "false", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "SHA", ",", "pr", ".", "Head", ".", "SHA", ")", "\n", "}", "\n", "if", "pr", ".", "Merged", "{", "return", "false", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "pr", ".", "Mergable", "!=", "nil", "{", "return", "*", "pr", ".", "Mergable", ",", "nil", "\n", "}", "\n", "if", "try", "+", "1", "<", "maxTries", "{", "c", ".", "time", ".", "Sleep", "(", "backoff", ")", "\n", "backoff", "*=", "2", "\n", "}", "\n", "}", "\n", "return", "false", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "maxTries", ")", "\n", "}"], "docstring": "// IsMergeable determines if a PR can be merged.\n// Mergeability is calculated by a background job on GitHub and is not immediately available when\n// new commits are added so the PR must be polled until the background job completes.", "docstring_tokens": ["IsMergeable", "determines", "if", "a", "PR", "can", "be", "merged", ".", "Mergeability", "is", "calculated", "by", "a", "background", "job", "on", "GitHub", "and", "is", "not", "immediately", "available", "when", "new", "commits", "are", "added", "so", "the", "PR", "must", "be", "polled", "until", "the", "background", "job", "completes", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/client.go#L2480-L2503", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pps/util.go", "func_name": "ValidateGitCloneURL", "original_string": "func ValidateGitCloneURL(url string) error {\n\texampleURL := \"https://github.com/org/foo.git\"\n\tif url == \"\" {\n\t\treturn fmt.Errorf(\"clone URL is missing (example clone URL %v)\", exampleURL)\n\t}\n\t// Use the git client's validator to make sure its a valid URL\n\to := &git.CloneOptions{\n\t\tURL: url,\n\t}\n\tif err := o.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure its the type that we want. Of the following we\n\t// only accept the 'clone' type of url:\n\t//     git_url: \"git://github.com/sjezewski/testgithook.git\",\n\t//     ssh_url: \"git@github.com:sjezewski/testgithook.git\",\n\t//     clone_url: \"https://github.com/sjezewski/testgithook.git\",\n\t//     svn_url: \"https://github.com/sjezewski/testgithook\",\n\tinvalidErr := fmt.Errorf(\"clone URL is missing .git suffix (example clone URL %v)\", exampleURL)\n\n\tif !strings.HasSuffix(url, \".git\") {\n\t\t// svn_url case\n\t\treturn invalidErr\n\t}\n\tif !strings.HasPrefix(url, \"https://\") {\n\t\t// git_url or ssh_url cases\n\t\treturn invalidErr\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func ValidateGitCloneURL(url string) error {\n\texampleURL := \"https://github.com/org/foo.git\"\n\tif url == \"\" {\n\t\treturn fmt.Errorf(\"clone URL is missing (example clone URL %v)\", exampleURL)\n\t}\n\t// Use the git client's validator to make sure its a valid URL\n\to := &git.CloneOptions{\n\t\tURL: url,\n\t}\n\tif err := o.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure its the type that we want. Of the following we\n\t// only accept the 'clone' type of url:\n\t//     git_url: \"git://github.com/sjezewski/testgithook.git\",\n\t//     ssh_url: \"git@github.com:sjezewski/testgithook.git\",\n\t//     clone_url: \"https://github.com/sjezewski/testgithook.git\",\n\t//     svn_url: \"https://github.com/sjezewski/testgithook\",\n\tinvalidErr := fmt.Errorf(\"clone URL is missing .git suffix (example clone URL %v)\", exampleURL)\n\n\tif !strings.HasSuffix(url, \".git\") {\n\t\t// svn_url case\n\t\treturn invalidErr\n\t}\n\tif !strings.HasPrefix(url, \"https://\") {\n\t\t// git_url or ssh_url cases\n\t\treturn invalidErr\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "ValidateGitCloneURL", "(", "url", "string", ")", "error", "{", "exampleURL", ":=", "\"", "\"", "\n", "if", "url", "==", "\"", "\"", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "exampleURL", ")", "\n", "}", "\n", "// Use the git client's validator to make sure its a valid URL", "o", ":=", "&", "git", ".", "CloneOptions", "{", "URL", ":", "url", ",", "}", "\n", "if", "err", ":=", "o", ".", "Validate", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "// Make sure its the type that we want. Of the following we", "// only accept the 'clone' type of url:", "//     git_url: \"git://github.com/sjezewski/testgithook.git\",", "//     ssh_url: \"git@github.com:sjezewski/testgithook.git\",", "//     clone_url: \"https://github.com/sjezewski/testgithook.git\",", "//     svn_url: \"https://github.com/sjezewski/testgithook\",", "invalidErr", ":=", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "exampleURL", ")", "\n\n", "if", "!", "strings", ".", "HasSuffix", "(", "url", ",", "\"", "\"", ")", "{", "// svn_url case", "return", "invalidErr", "\n", "}", "\n", "if", "!", "strings", ".", "HasPrefix", "(", "url", ",", "\"", "\"", ")", "{", "// git_url or ssh_url cases", "return", "invalidErr", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// ValidateGitCloneURL returns an error if the provided URL is invalid", "docstring_tokens": ["ValidateGitCloneURL", "returns", "an", "error", "if", "the", "provided", "URL", "is", "invalid"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pps/util.go#L91-L122", "partition": "test"}
{"repo": "xwb1989/sqlparser", "path": "ast.go", "func_name": "Backtick", "original_string": "func Backtick(in string) string {\n\tvar buf bytes.Buffer\n\tbuf.WriteByte('`')\n\tfor _, c := range in {\n\t\tbuf.WriteRune(c)\n\t\tif c == '`' {\n\t\t\tbuf.WriteByte('`')\n\t\t}\n\t}\n\tbuf.WriteByte('`')\n\treturn buf.String()\n}", "language": "go", "code": "func Backtick(in string) string {\n\tvar buf bytes.Buffer\n\tbuf.WriteByte('`')\n\tfor _, c := range in {\n\t\tbuf.WriteRune(c)\n\t\tif c == '`' {\n\t\t\tbuf.WriteByte('`')\n\t\t}\n\t}\n\tbuf.WriteByte('`')\n\treturn buf.String()\n}", "code_tokens": ["func", "Backtick", "(", "in", "string", ")", "string", "{", "var", "buf", "bytes", ".", "Buffer", "\n", "buf", ".", "WriteByte", "(", "'`'", ")", "\n", "for", "_", ",", "c", ":=", "range", "in", "{", "buf", ".", "WriteRune", "(", "c", ")", "\n", "if", "c", "==", "'`'", "{", "buf", ".", "WriteByte", "(", "'`'", ")", "\n", "}", "\n", "}", "\n", "buf", ".", "WriteByte", "(", "'`'", ")", "\n", "return", "buf", ".", "String", "(", ")", "\n", "}"], "docstring": "// Backtick produces a backticked literal given an input string.", "docstring_tokens": ["Backtick", "produces", "a", "backticked", "literal", "given", "an", "input", "string", "."], "sha": "120387863bf27d04bc07db8015110a6e96d0146c", "url": "https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/ast.go#L3395-L3406", "partition": "test"}
{"repo": "giantswarm/certctl", "path": "service/role/service.go", "func_name": "Create", "original_string": "func (s *service) Create(params CreateParams) error {\n\tlogicalStore := s.vaultClient.Logical()\n\n\tdata := map[string]interface{}{\n\t\t\"allowed_domains\":    params.AllowedDomains,\n\t\t\"allow_subdomains\":   params.AllowSubdomains,\n\t\t\"ttl\":                params.TTL,\n\t\t\"allow_bare_domains\": params.AllowBareDomains,\n\t\t\"organization\":       params.Organizations,\n\t}\n\n\t_, err := logicalStore.Write(fmt.Sprintf(\"%s/roles/%s\", s.pkiMountpoint, params.Name), data)\n\tif err != nil {\n\t\treturn microerror.Mask(err)\n\t}\n\treturn nil\n}", "language": "go", "code": "func (s *service) Create(params CreateParams) error {\n\tlogicalStore := s.vaultClient.Logical()\n\n\tdata := map[string]interface{}{\n\t\t\"allowed_domains\":    params.AllowedDomains,\n\t\t\"allow_subdomains\":   params.AllowSubdomains,\n\t\t\"ttl\":                params.TTL,\n\t\t\"allow_bare_domains\": params.AllowBareDomains,\n\t\t\"organization\":       params.Organizations,\n\t}\n\n\t_, err := logicalStore.Write(fmt.Sprintf(\"%s/roles/%s\", s.pkiMountpoint, params.Name), data)\n\tif err != nil {\n\t\treturn microerror.Mask(err)\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "s", "*", "service", ")", "Create", "(", "params", "CreateParams", ")", "error", "{", "logicalStore", ":=", "s", ".", "vaultClient", ".", "Logical", "(", ")", "\n\n", "data", ":=", "map", "[", "string", "]", "interface", "{", "}", "{", "\"", "\"", ":", "params", ".", "AllowedDomains", ",", "\"", "\"", ":", "params", ".", "AllowSubdomains", ",", "\"", "\"", ":", "params", ".", "TTL", ",", "\"", "\"", ":", "params", ".", "AllowBareDomains", ",", "\"", "\"", ":", "params", ".", "Organizations", ",", "}", "\n\n", "_", ",", "err", ":=", "logicalStore", ".", "Write", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "s", ".", "pkiMountpoint", ",", "params", ".", "Name", ")", ",", "data", ")", "\n", "if", "err", "!=", "nil", "{", "return", "microerror", ".", "Mask", "(", "err", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// Create creates a role if it doesn't exist yet. Creating roles is idempotent\n// in the vault api, so no need to check if it already exists.", "docstring_tokens": ["Create", "creates", "a", "role", "if", "it", "doesn", "t", "exist", "yet", ".", "Creating", "roles", "is", "idempotent", "in", "the", "vault", "api", "so", "no", "need", "to", "check", "if", "it", "already", "exists", "."], "sha": "2a6615f61499cd09a8d5ced9a5fade322d2de254", "url": "https://github.com/giantswarm/certctl/blob/2a6615f61499cd09a8d5ced9a5fade322d2de254/service/role/service.go#L55-L71", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/types/devices.go", "func_name": "Contains", "original_string": "func (list Devices) Contains(k string, d Device) bool {\n\t// If it didn't exist, it's different\n\tif list[k] == nil {\n\t\treturn false\n\t}\n\n\told := list[k]\n\n\treturn deviceEquals(old, d)\n}", "language": "go", "code": "func (list Devices) Contains(k string, d Device) bool {\n\t// If it didn't exist, it's different\n\tif list[k] == nil {\n\t\treturn false\n\t}\n\n\told := list[k]\n\n\treturn deviceEquals(old, d)\n}", "code_tokens": ["func", "(", "list", "Devices", ")", "Contains", "(", "k", "string", ",", "d", "Device", ")", "bool", "{", "// If it didn't exist, it's different", "if", "list", "[", "k", "]", "==", "nil", "{", "return", "false", "\n", "}", "\n\n", "old", ":=", "list", "[", "k", "]", "\n\n", "return", "deviceEquals", "(", "old", ",", "d", ")", "\n", "}"], "docstring": "// Contains checks if a given device exists in the set and if it's\n// identical to that provided", "docstring_tokens": ["Contains", "checks", "if", "a", "given", "device", "exists", "in", "the", "set", "and", "if", "it", "s", "identical", "to", "that", "provided"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/types/devices.go#L17-L26", "partition": "test"}
{"repo": "enaml-ops/enaml", "path": "diff/boshreleasediffer.go", "func_name": "allJobNames", "original_string": "func (d boshReleaseDiffer) allJobNames() []string {\n\tjobNamesMap := make(map[string]string)\n\tvar addJobNames = func(br *release.BoshRelease) {\n\t\tif br != nil {\n\t\t\tfor jbname := range br.JobManifests {\n\t\t\t\tjobNamesMap[jbname] = jbname\n\t\t\t}\n\t\t}\n\t}\n\taddJobNames(d.release1)\n\taddJobNames(d.release2)\n\tvar jobNames []string\n\tfor jname := range jobNamesMap {\n\t\tjobNames = append(jobNames, jname)\n\t}\n\treturn jobNames\n}", "language": "go", "code": "func (d boshReleaseDiffer) allJobNames() []string {\n\tjobNamesMap := make(map[string]string)\n\tvar addJobNames = func(br *release.BoshRelease) {\n\t\tif br != nil {\n\t\t\tfor jbname := range br.JobManifests {\n\t\t\t\tjobNamesMap[jbname] = jbname\n\t\t\t}\n\t\t}\n\t}\n\taddJobNames(d.release1)\n\taddJobNames(d.release2)\n\tvar jobNames []string\n\tfor jname := range jobNamesMap {\n\t\tjobNames = append(jobNames, jname)\n\t}\n\treturn jobNames\n}", "code_tokens": ["func", "(", "d", "boshReleaseDiffer", ")", "allJobNames", "(", ")", "[", "]", "string", "{", "jobNamesMap", ":=", "make", "(", "map", "[", "string", "]", "string", ")", "\n", "var", "addJobNames", "=", "func", "(", "br", "*", "release", ".", "BoshRelease", ")", "{", "if", "br", "!=", "nil", "{", "for", "jbname", ":=", "range", "br", ".", "JobManifests", "{", "jobNamesMap", "[", "jbname", "]", "=", "jbname", "\n", "}", "\n", "}", "\n", "}", "\n", "addJobNames", "(", "d", ".", "release1", ")", "\n", "addJobNames", "(", "d", ".", "release2", ")", "\n", "var", "jobNames", "[", "]", "string", "\n", "for", "jname", ":=", "range", "jobNamesMap", "{", "jobNames", "=", "append", "(", "jobNames", ",", "jname", ")", "\n", "}", "\n", "return", "jobNames", "\n", "}"], "docstring": "// allJobNames returns a union of unique job names across both BOSH releases", "docstring_tokens": ["allJobNames", "returns", "a", "union", "of", "unique", "job", "names", "across", "both", "BOSH", "releases"], "sha": "4f847ee10b41afca41fe09fa839cb2f6ade06fb5", "url": "https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/diff/boshreleasediffer.go#L52-L68", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "meshconn/peer.go", "func_name": "Register", "original_string": "func (p *Peer) Register(gossip mesh.Gossip) {\n\tp.actions <- func() { p.gossip = gossip }\n}", "language": "go", "code": "func (p *Peer) Register(gossip mesh.Gossip) {\n\tp.actions <- func() { p.gossip = gossip }\n}", "code_tokens": ["func", "(", "p", "*", "Peer", ")", "Register", "(", "gossip", "mesh", ".", "Gossip", ")", "{", "p", ".", "actions", "<-", "func", "(", ")", "{", "p", ".", "gossip", "=", "gossip", "}", "\n", "}"], "docstring": "// Register injects the mesh.Gossip and enables full-duplex communication.\n// Clients should consume from ReadFrom without blocking.", "docstring_tokens": ["Register", "injects", "the", "mesh", ".", "Gossip", "and", "enables", "full", "-", "duplex", "communication", ".", "Clients", "should", "consume", "from", "ReadFrom", "without", "blocking", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/meshconn/peer.go#L73-L75", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "checksum.go", "func_name": "New", "original_string": "func (t ChecksumType) New() Checksum {\n\ts := t.pool().Get().(Checksum)\n\ts.Reset()\n\treturn s\n}", "language": "go", "code": "func (t ChecksumType) New() Checksum {\n\ts := t.pool().Get().(Checksum)\n\ts.Reset()\n\treturn s\n}", "code_tokens": ["func", "(", "t", "ChecksumType", ")", "New", "(", ")", "Checksum", "{", "s", ":=", "t", ".", "pool", "(", ")", ".", "Get", "(", ")", ".", "(", "Checksum", ")", "\n", "s", ".", "Reset", "(", ")", "\n", "return", "s", "\n", "}"], "docstring": "// New creates a new Checksum of the given type", "docstring_tokens": ["New", "creates", "a", "new", "Checksum", "of", "the", "given", "type"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/checksum.go#L89-L93", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/client.go", "func_name": "NewFromURL", "original_string": "func NewFromURL(url string) (*Client, error) {\n\treturn New(Config{Endpoints: []string{url}})\n}", "language": "go", "code": "func NewFromURL(url string) (*Client, error) {\n\treturn New(Config{Endpoints: []string{url}})\n}", "code_tokens": ["func", "NewFromURL", "(", "url", "string", ")", "(", "*", "Client", ",", "error", ")", "{", "return", "New", "(", "Config", "{", "Endpoints", ":", "[", "]", "string", "{", "url", "}", "}", ")", "\n", "}"], "docstring": "// NewFromURL creates a new etcdv3 client from a URL.", "docstring_tokens": ["NewFromURL", "creates", "a", "new", "etcdv3", "client", "from", "a", "URL", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/client.go#L117-L119", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "histogram.go", "func_name": "newSizeHistogram", "original_string": "func newSizeHistogram() *sizeHistogram {\n\t// TODO(ibrahim): find appropriate bin size.\n\tkeyBins := createHistogramBins(1, 16)\n\tvalueBins := createHistogramBins(1, 30)\n\treturn &sizeHistogram{\n\t\tkeySizeHistogram: histogramData{\n\t\t\tbins:        keyBins,\n\t\t\tcountPerBin: make([]int64, len(keyBins)+1),\n\t\t\tmax:         math.MinInt64,\n\t\t\tmin:         math.MaxInt64,\n\t\t\tsum:         0,\n\t\t},\n\t\tvalueSizeHistogram: histogramData{\n\t\t\tbins:        valueBins,\n\t\t\tcountPerBin: make([]int64, len(valueBins)+1),\n\t\t\tmax:         math.MinInt64,\n\t\t\tmin:         math.MaxInt64,\n\t\t\tsum:         0,\n\t\t},\n\t}\n}", "language": "go", "code": "func newSizeHistogram() *sizeHistogram {\n\t// TODO(ibrahim): find appropriate bin size.\n\tkeyBins := createHistogramBins(1, 16)\n\tvalueBins := createHistogramBins(1, 30)\n\treturn &sizeHistogram{\n\t\tkeySizeHistogram: histogramData{\n\t\t\tbins:        keyBins,\n\t\t\tcountPerBin: make([]int64, len(keyBins)+1),\n\t\t\tmax:         math.MinInt64,\n\t\t\tmin:         math.MaxInt64,\n\t\t\tsum:         0,\n\t\t},\n\t\tvalueSizeHistogram: histogramData{\n\t\t\tbins:        valueBins,\n\t\t\tcountPerBin: make([]int64, len(valueBins)+1),\n\t\t\tmax:         math.MinInt64,\n\t\t\tmin:         math.MaxInt64,\n\t\t\tsum:         0,\n\t\t},\n\t}\n}", "code_tokens": ["func", "newSizeHistogram", "(", ")", "*", "sizeHistogram", "{", "// TODO(ibrahim): find appropriate bin size.", "keyBins", ":=", "createHistogramBins", "(", "1", ",", "16", ")", "\n", "valueBins", ":=", "createHistogramBins", "(", "1", ",", "30", ")", "\n", "return", "&", "sizeHistogram", "{", "keySizeHistogram", ":", "histogramData", "{", "bins", ":", "keyBins", ",", "countPerBin", ":", "make", "(", "[", "]", "int64", ",", "len", "(", "keyBins", ")", "+", "1", ")", ",", "max", ":", "math", ".", "MinInt64", ",", "min", ":", "math", ".", "MaxInt64", ",", "sum", ":", "0", ",", "}", ",", "valueSizeHistogram", ":", "histogramData", "{", "bins", ":", "valueBins", ",", "countPerBin", ":", "make", "(", "[", "]", "int64", ",", "len", "(", "valueBins", ")", "+", "1", ")", ",", "max", ":", "math", ".", "MinInt64", ",", "min", ":", "math", ".", "MaxInt64", ",", "sum", ":", "0", ",", "}", ",", "}", "\n", "}"], "docstring": "// newSizeHistogram returns a new instance of keyValueSizeHistogram with\n// properly initialized fields.", "docstring_tokens": ["newSizeHistogram", "returns", "a", "new", "instance", "of", "keyValueSizeHistogram", "with", "properly", "initialized", "fields", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/histogram.go#L56-L76", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "mex.go", "func_name": "Notify", "original_string": "func (e *errNotifier) Notify(err error) error {\n\t// The code should never try to Notify(nil).\n\tif err == nil {\n\t\tpanic(\"cannot Notify with no error\")\n\t}\n\n\t// There may be some sort of race where we try to notify the mex twice.\n\tif !e.notified.CAS(false, true) {\n\t\treturn fmt.Errorf(\"cannot broadcast error: %v, already have: %v\", err, e.err)\n\t}\n\n\te.err = err\n\tclose(e.c)\n\treturn nil\n}", "language": "go", "code": "func (e *errNotifier) Notify(err error) error {\n\t// The code should never try to Notify(nil).\n\tif err == nil {\n\t\tpanic(\"cannot Notify with no error\")\n\t}\n\n\t// There may be some sort of race where we try to notify the mex twice.\n\tif !e.notified.CAS(false, true) {\n\t\treturn fmt.Errorf(\"cannot broadcast error: %v, already have: %v\", err, e.err)\n\t}\n\n\te.err = err\n\tclose(e.c)\n\treturn nil\n}", "code_tokens": ["func", "(", "e", "*", "errNotifier", ")", "Notify", "(", "err", "error", ")", "error", "{", "// The code should never try to Notify(nil).", "if", "err", "==", "nil", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "// There may be some sort of race where we try to notify the mex twice.", "if", "!", "e", ".", "notified", ".", "CAS", "(", "false", ",", "true", ")", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ",", "e", ".", "err", ")", "\n", "}", "\n\n", "e", ".", "err", "=", "err", "\n", "close", "(", "e", ".", "c", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// Notify will store the error and notify all waiters on c that there's an error.", "docstring_tokens": ["Notify", "will", "store", "the", "error", "and", "notify", "all", "waiters", "on", "c", "that", "there", "s", "an", "error", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/mex.go#L61-L75", "partition": "test"}
{"repo": "mrd0ll4r/tbotapi", "path": "ctors.go", "func_name": "NewOutgoingMessage", "original_string": "func (api *TelegramBotAPI) NewOutgoingMessage(recipient Recipient, text string) *OutgoingMessage {\n\treturn &OutgoingMessage{\n\t\toutgoingMessageBase: outgoingMessageBase{\n\t\t\toutgoingBase: outgoingBase{\n\t\t\t\tapi:       api,\n\t\t\t\tRecipient: recipient,\n\t\t\t},\n\t\t},\n\t\tText:      text,\n\t\tParseMode: ModeDefault,\n\t}\n}", "language": "go", "code": "func (api *TelegramBotAPI) NewOutgoingMessage(recipient Recipient, text string) *OutgoingMessage {\n\treturn &OutgoingMessage{\n\t\toutgoingMessageBase: outgoingMessageBase{\n\t\t\toutgoingBase: outgoingBase{\n\t\t\t\tapi:       api,\n\t\t\t\tRecipient: recipient,\n\t\t\t},\n\t\t},\n\t\tText:      text,\n\t\tParseMode: ModeDefault,\n\t}\n}", "code_tokens": ["func", "(", "api", "*", "TelegramBotAPI", ")", "NewOutgoingMessage", "(", "recipient", "Recipient", ",", "text", "string", ")", "*", "OutgoingMessage", "{", "return", "&", "OutgoingMessage", "{", "outgoingMessageBase", ":", "outgoingMessageBase", "{", "outgoingBase", ":", "outgoingBase", "{", "api", ":", "api", ",", "Recipient", ":", "recipient", ",", "}", ",", "}", ",", "Text", ":", "text", ",", "ParseMode", ":", "ModeDefault", ",", "}", "\n", "}"], "docstring": "// NewOutgoingMessage creates a new outgoing message.", "docstring_tokens": ["NewOutgoingMessage", "creates", "a", "new", "outgoing", "message", "."], "sha": "edc257282178bb5cebbfcc41260ec04c1ec7ac19", "url": "https://github.com/mrd0ll4r/tbotapi/blob/edc257282178bb5cebbfcc41260ec04c1ec7ac19/ctors.go#L10-L21", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "rule/platform_strings.go", "func_name": "Map", "original_string": "func (ps *PlatformStrings) Map(f func(s string) (string, error)) (PlatformStrings, []error) {\n\tvar errors []error\n\tmapSlice := func(ss []string) ([]string, error) {\n\t\trs := make([]string, 0, len(ss))\n\t\tfor _, s := range ss {\n\t\t\tif r, err := f(s); err != nil {\n\t\t\t\terrors = append(errors, err)\n\t\t\t} else if r != \"\" {\n\t\t\t\trs = append(rs, r)\n\t\t\t}\n\t\t}\n\t\treturn rs, nil\n\t}\n\tresult, _ := ps.MapSlice(mapSlice)\n\treturn result, errors\n}", "language": "go", "code": "func (ps *PlatformStrings) Map(f func(s string) (string, error)) (PlatformStrings, []error) {\n\tvar errors []error\n\tmapSlice := func(ss []string) ([]string, error) {\n\t\trs := make([]string, 0, len(ss))\n\t\tfor _, s := range ss {\n\t\t\tif r, err := f(s); err != nil {\n\t\t\t\terrors = append(errors, err)\n\t\t\t} else if r != \"\" {\n\t\t\t\trs = append(rs, r)\n\t\t\t}\n\t\t}\n\t\treturn rs, nil\n\t}\n\tresult, _ := ps.MapSlice(mapSlice)\n\treturn result, errors\n}", "code_tokens": ["func", "(", "ps", "*", "PlatformStrings", ")", "Map", "(", "f", "func", "(", "s", "string", ")", "(", "string", ",", "error", ")", ")", "(", "PlatformStrings", ",", "[", "]", "error", ")", "{", "var", "errors", "[", "]", "error", "\n", "mapSlice", ":=", "func", "(", "ss", "[", "]", "string", ")", "(", "[", "]", "string", ",", "error", ")", "{", "rs", ":=", "make", "(", "[", "]", "string", ",", "0", ",", "len", "(", "ss", ")", ")", "\n", "for", "_", ",", "s", ":=", "range", "ss", "{", "if", "r", ",", "err", ":=", "f", "(", "s", ")", ";", "err", "!=", "nil", "{", "errors", "=", "append", "(", "errors", ",", "err", ")", "\n", "}", "else", "if", "r", "!=", "\"", "\"", "{", "rs", "=", "append", "(", "rs", ",", "r", ")", "\n", "}", "\n", "}", "\n", "return", "rs", ",", "nil", "\n", "}", "\n", "result", ",", "_", ":=", "ps", ".", "MapSlice", "(", "mapSlice", ")", "\n", "return", "result", ",", "errors", "\n", "}"], "docstring": "// Map applies a function that processes individual strings to the strings\n// in \"ps\" and returns a new PlatformStrings with the result. Empty strings\n// returned by the function are dropped.", "docstring_tokens": ["Map", "applies", "a", "function", "that", "processes", "individual", "strings", "to", "the", "strings", "in", "ps", "and", "returns", "a", "new", "PlatformStrings", "with", "the", "result", ".", "Empty", "strings", "returned", "by", "the", "function", "are", "dropped", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/rule/platform_strings.go#L120-L135", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/v3rpc/header.go", "func_name": "fill", "original_string": "func (h *header) fill(rh *pb.ResponseHeader) {\n\tif rh == nil {\n\t\tplog.Panic(\"unexpected nil resp.Header\")\n\t}\n\trh.ClusterId = uint64(h.clusterID)\n\trh.MemberId = uint64(h.memberID)\n\trh.RaftTerm = h.sg.Term()\n\tif rh.Revision == 0 {\n\t\trh.Revision = h.rev()\n\t}\n}", "language": "go", "code": "func (h *header) fill(rh *pb.ResponseHeader) {\n\tif rh == nil {\n\t\tplog.Panic(\"unexpected nil resp.Header\")\n\t}\n\trh.ClusterId = uint64(h.clusterID)\n\trh.MemberId = uint64(h.memberID)\n\trh.RaftTerm = h.sg.Term()\n\tif rh.Revision == 0 {\n\t\trh.Revision = h.rev()\n\t}\n}", "code_tokens": ["func", "(", "h", "*", "header", ")", "fill", "(", "rh", "*", "pb", ".", "ResponseHeader", ")", "{", "if", "rh", "==", "nil", "{", "plog", ".", "Panic", "(", "\"", "\"", ")", "\n", "}", "\n", "rh", ".", "ClusterId", "=", "uint64", "(", "h", ".", "clusterID", ")", "\n", "rh", ".", "MemberId", "=", "uint64", "(", "h", ".", "memberID", ")", "\n", "rh", ".", "RaftTerm", "=", "h", ".", "sg", ".", "Term", "(", ")", "\n", "if", "rh", ".", "Revision", "==", "0", "{", "rh", ".", "Revision", "=", "h", ".", "rev", "(", ")", "\n", "}", "\n", "}"], "docstring": "// fill populates pb.ResponseHeader using etcdserver information", "docstring_tokens": ["fill", "populates", "pb", ".", "ResponseHeader", "using", "etcdserver", "information"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v3rpc/header.go#L39-L49", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "build/payment.go", "func_name": "MutatePayment", "original_string": "func (m NativeAmount) MutatePayment(o interface{}) (err error) {\n\tswitch o := o.(type) {\n\tdefault:\n\t\terr = errors.New(\"Unexpected operation type\")\n\tcase *xdr.PaymentOp:\n\t\to.Amount, err = amount.Parse(m.Amount)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\to.Asset, err = xdr.NewAsset(xdr.AssetTypeAssetTypeNative, nil)\n\tcase *xdr.PathPaymentOp:\n\t\to.DestAmount, err = amount.Parse(m.Amount)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\to.DestAsset, err = xdr.NewAsset(xdr.AssetTypeAssetTypeNative, nil)\n\t}\n\treturn\n}", "language": "go", "code": "func (m NativeAmount) MutatePayment(o interface{}) (err error) {\n\tswitch o := o.(type) {\n\tdefault:\n\t\terr = errors.New(\"Unexpected operation type\")\n\tcase *xdr.PaymentOp:\n\t\to.Amount, err = amount.Parse(m.Amount)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\to.Asset, err = xdr.NewAsset(xdr.AssetTypeAssetTypeNative, nil)\n\tcase *xdr.PathPaymentOp:\n\t\to.DestAmount, err = amount.Parse(m.Amount)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\to.DestAsset, err = xdr.NewAsset(xdr.AssetTypeAssetTypeNative, nil)\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "m", "NativeAmount", ")", "MutatePayment", "(", "o", "interface", "{", "}", ")", "(", "err", "error", ")", "{", "switch", "o", ":=", "o", ".", "(", "type", ")", "{", "default", ":", "err", "=", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "case", "*", "xdr", ".", "PaymentOp", ":", "o", ".", "Amount", ",", "err", "=", "amount", ".", "Parse", "(", "m", ".", "Amount", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\n", "}", "\n\n", "o", ".", "Asset", ",", "err", "=", "xdr", ".", "NewAsset", "(", "xdr", ".", "AssetTypeAssetTypeNative", ",", "nil", ")", "\n", "case", "*", "xdr", ".", "PathPaymentOp", ":", "o", ".", "DestAmount", ",", "err", "=", "amount", ".", "Parse", "(", "m", ".", "Amount", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\n", "}", "\n\n", "o", ".", "DestAsset", ",", "err", "=", "xdr", ".", "NewAsset", "(", "xdr", ".", "AssetTypeAssetTypeNative", ",", "nil", ")", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// MutatePayment for NativeAmount sets the PaymentOp's currency field to\n// native and sets its amount to the provided integer", "docstring_tokens": ["MutatePayment", "for", "NativeAmount", "sets", "the", "PaymentOp", "s", "currency", "field", "to", "native", "and", "sets", "its", "amount", "to", "the", "provided", "integer"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/payment.go#L101-L121", "partition": "test"}
{"repo": "256dpi/fire", "path": "coal/indexer.go", "func_name": "AddRaw", "original_string": "func (i *Indexer) AddRaw(coll string, idx mgo.Index) {\n\ti.indexes = append(i.indexes, index{\n\t\tcoll:  coll,\n\t\tindex: idx,\n\t})\n}", "language": "go", "code": "func (i *Indexer) AddRaw(coll string, idx mgo.Index) {\n\ti.indexes = append(i.indexes, index{\n\t\tcoll:  coll,\n\t\tindex: idx,\n\t})\n}", "code_tokens": ["func", "(", "i", "*", "Indexer", ")", "AddRaw", "(", "coll", "string", ",", "idx", "mgo", ".", "Index", ")", "{", "i", ".", "indexes", "=", "append", "(", "i", ".", "indexes", ",", "index", "{", "coll", ":", "coll", ",", "index", ":", "idx", ",", "}", ")", "\n", "}"], "docstring": "// AddRaw will add a raw mgo.Index to the internal index list.", "docstring_tokens": ["AddRaw", "will", "add", "a", "raw", "mgo", ".", "Index", "to", "the", "internal", "index", "list", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/coal/indexer.go#L63-L68", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/storage_pools.go", "func_name": "StoragePoolVolumeTypeToName", "original_string": "func StoragePoolVolumeTypeToName(volumeType int) (string, error) {\n\tswitch volumeType {\n\tcase StoragePoolVolumeTypeContainer:\n\t\treturn StoragePoolVolumeTypeNameContainer, nil\n\tcase StoragePoolVolumeTypeImage:\n\t\treturn StoragePoolVolumeTypeNameImage, nil\n\tcase StoragePoolVolumeTypeCustom:\n\t\treturn StoragePoolVolumeTypeNameCustom, nil\n\t}\n\n\treturn \"\", fmt.Errorf(\"invalid storage volume type\")\n}", "language": "go", "code": "func StoragePoolVolumeTypeToName(volumeType int) (string, error) {\n\tswitch volumeType {\n\tcase StoragePoolVolumeTypeContainer:\n\t\treturn StoragePoolVolumeTypeNameContainer, nil\n\tcase StoragePoolVolumeTypeImage:\n\t\treturn StoragePoolVolumeTypeNameImage, nil\n\tcase StoragePoolVolumeTypeCustom:\n\t\treturn StoragePoolVolumeTypeNameCustom, nil\n\t}\n\n\treturn \"\", fmt.Errorf(\"invalid storage volume type\")\n}", "code_tokens": ["func", "StoragePoolVolumeTypeToName", "(", "volumeType", "int", ")", "(", "string", ",", "error", ")", "{", "switch", "volumeType", "{", "case", "StoragePoolVolumeTypeContainer", ":", "return", "StoragePoolVolumeTypeNameContainer", ",", "nil", "\n", "case", "StoragePoolVolumeTypeImage", ":", "return", "StoragePoolVolumeTypeNameImage", ",", "nil", "\n", "case", "StoragePoolVolumeTypeCustom", ":", "return", "StoragePoolVolumeTypeNameCustom", ",", "nil", "\n", "}", "\n\n", "return", "\"", "\"", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}"], "docstring": "// StoragePoolVolumeTypeToName converts a volume integer type code to its\n// human-readable name.", "docstring_tokens": ["StoragePoolVolumeTypeToName", "converts", "a", "volume", "integer", "type", "code", "to", "its", "human", "-", "readable", "name", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/storage_pools.go#L1071-L1082", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "logexporter/cmd/main.go", "func_name": "prepareLogfiles", "original_string": "func prepareLogfiles(logDir string) {\n\tglog.Info(\"Preparing logfiles relevant to this node\")\n\tlogfiles := nodeLogs[:]\n\n\tswitch *cloudProvider {\n\tcase \"gce\", \"gke\":\n\t\tlogfiles = append(logfiles, gceLogs...)\n\tcase \"aws\":\n\t\tlogfiles = append(logfiles, awsLogs...)\n\tdefault:\n\t\tglog.Errorf(\"Unknown cloud provider '%v' provided, skipping any provider specific logs\", *cloudProvider)\n\t}\n\n\t// Grab kubemark logs too, if asked for.\n\tif *enableHollowNodeLogs {\n\t\tlogfiles = append(logfiles, kubemarkLogs...)\n\t}\n\n\t// Select system/service specific logs.\n\tif _, err := os.Stat(\"/workspace/etc/systemd/journald.conf\"); err == nil {\n\t\tglog.Info(\"Journalctl found on host. Collecting systemd logs\")\n\t\tcreateSystemdLogfiles(logDir)\n\t} else {\n\t\tglog.Infof(\"Journalctl not found on host (%v). Collecting supervisord logs instead\", err)\n\t\tlogfiles = append(logfiles, kernelLog)\n\t\tlogfiles = append(logfiles, initdLogs...)\n\t\tlogfiles = append(logfiles, supervisordLogs...)\n\t}\n\n\t// Copy all the logfiles that exist, to logDir.\n\tfor _, logfile := range logfiles {\n\t\tlogfileFullPath := filepath.Join(localLogPath, logfile+\".log*\") // Append .log* to copy rotated logs too.\n\t\tcmd := exec.Command(\"/bin/sh\", \"-c\", fmt.Sprintf(\"cp %v %v\", logfileFullPath, logDir))\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tglog.Warningf(\"Failed to copy any logfiles with pattern '%v': %v\", logfileFullPath, err)\n\t\t}\n\t}\n}", "language": "go", "code": "func prepareLogfiles(logDir string) {\n\tglog.Info(\"Preparing logfiles relevant to this node\")\n\tlogfiles := nodeLogs[:]\n\n\tswitch *cloudProvider {\n\tcase \"gce\", \"gke\":\n\t\tlogfiles = append(logfiles, gceLogs...)\n\tcase \"aws\":\n\t\tlogfiles = append(logfiles, awsLogs...)\n\tdefault:\n\t\tglog.Errorf(\"Unknown cloud provider '%v' provided, skipping any provider specific logs\", *cloudProvider)\n\t}\n\n\t// Grab kubemark logs too, if asked for.\n\tif *enableHollowNodeLogs {\n\t\tlogfiles = append(logfiles, kubemarkLogs...)\n\t}\n\n\t// Select system/service specific logs.\n\tif _, err := os.Stat(\"/workspace/etc/systemd/journald.conf\"); err == nil {\n\t\tglog.Info(\"Journalctl found on host. Collecting systemd logs\")\n\t\tcreateSystemdLogfiles(logDir)\n\t} else {\n\t\tglog.Infof(\"Journalctl not found on host (%v). Collecting supervisord logs instead\", err)\n\t\tlogfiles = append(logfiles, kernelLog)\n\t\tlogfiles = append(logfiles, initdLogs...)\n\t\tlogfiles = append(logfiles, supervisordLogs...)\n\t}\n\n\t// Copy all the logfiles that exist, to logDir.\n\tfor _, logfile := range logfiles {\n\t\tlogfileFullPath := filepath.Join(localLogPath, logfile+\".log*\") // Append .log* to copy rotated logs too.\n\t\tcmd := exec.Command(\"/bin/sh\", \"-c\", fmt.Sprintf(\"cp %v %v\", logfileFullPath, logDir))\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tglog.Warningf(\"Failed to copy any logfiles with pattern '%v': %v\", logfileFullPath, err)\n\t\t}\n\t}\n}", "code_tokens": ["func", "prepareLogfiles", "(", "logDir", "string", ")", "{", "glog", ".", "Info", "(", "\"", "\"", ")", "\n", "logfiles", ":=", "nodeLogs", "[", ":", "]", "\n\n", "switch", "*", "cloudProvider", "{", "case", "\"", "\"", ",", "\"", "\"", ":", "logfiles", "=", "append", "(", "logfiles", ",", "gceLogs", "...", ")", "\n", "case", "\"", "\"", ":", "logfiles", "=", "append", "(", "logfiles", ",", "awsLogs", "...", ")", "\n", "default", ":", "glog", ".", "Errorf", "(", "\"", "\"", ",", "*", "cloudProvider", ")", "\n", "}", "\n\n", "// Grab kubemark logs too, if asked for.", "if", "*", "enableHollowNodeLogs", "{", "logfiles", "=", "append", "(", "logfiles", ",", "kubemarkLogs", "...", ")", "\n", "}", "\n\n", "// Select system/service specific logs.", "if", "_", ",", "err", ":=", "os", ".", "Stat", "(", "\"", "\"", ")", ";", "err", "==", "nil", "{", "glog", ".", "Info", "(", "\"", "\"", ")", "\n", "createSystemdLogfiles", "(", "logDir", ")", "\n", "}", "else", "{", "glog", ".", "Infof", "(", "\"", "\"", ",", "err", ")", "\n", "logfiles", "=", "append", "(", "logfiles", ",", "kernelLog", ")", "\n", "logfiles", "=", "append", "(", "logfiles", ",", "initdLogs", "...", ")", "\n", "logfiles", "=", "append", "(", "logfiles", ",", "supervisordLogs", "...", ")", "\n", "}", "\n\n", "// Copy all the logfiles that exist, to logDir.", "for", "_", ",", "logfile", ":=", "range", "logfiles", "{", "logfileFullPath", ":=", "filepath", ".", "Join", "(", "localLogPath", ",", "logfile", "+", "\"", "\"", ")", "// Append .log* to copy rotated logs too.", "\n", "cmd", ":=", "exec", ".", "Command", "(", "\"", "\"", ",", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "logfileFullPath", ",", "logDir", ")", ")", "\n", "if", "err", ":=", "cmd", ".", "Run", "(", ")", ";", "err", "!=", "nil", "{", "glog", ".", "Warningf", "(", "\"", "\"", ",", "logfileFullPath", ",", "err", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// Copy logfiles specific to this node based on the cloud-provider, system services, etc\n// to a temporary directory. Also create logfiles for systemd services if journalctl is present.\n// We do not expect this function to see an error.", "docstring_tokens": ["Copy", "logfiles", "specific", "to", "this", "node", "based", "on", "the", "cloud", "-", "provider", "system", "services", "etc", "to", "a", "temporary", "directory", ".", "Also", "create", "logfiles", "for", "systemd", "services", "if", "journalctl", "is", "present", ".", "We", "do", "not", "expect", "this", "function", "to", "see", "an", "error", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/logexporter/cmd/main.go#L157-L194", "partition": "test"}
{"repo": "brankas/sentinel", "path": "sentinel.go", "func_name": "New", "original_string": "func New(opts ...Option) (*Sentinel, error) {\n\ts := &Sentinel{\n\t\tshutdownDuration: DefaultShutdownDuration,\n\t\tlogf:             func(string, ...interface{}) {},\n\t}\n\n\tvar err error\n\n\t// apply options\n\tfor _, o := range opts {\n\t\tif err = o(s); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// ensure sigs set\n\tif s.shutdownSigs == nil {\n\t\ts.shutdownSigs = []os.Signal{os.Interrupt}\n\t}\n\n\t// ensure errf set\n\tif s.errf == nil {\n\t\ts.errf = func(str string, v ...interface{}) {\n\t\t\ts.logf(\"ERROR: \"+str, v...)\n\t\t}\n\t}\n\n\treturn s, nil\n}", "language": "go", "code": "func New(opts ...Option) (*Sentinel, error) {\n\ts := &Sentinel{\n\t\tshutdownDuration: DefaultShutdownDuration,\n\t\tlogf:             func(string, ...interface{}) {},\n\t}\n\n\tvar err error\n\n\t// apply options\n\tfor _, o := range opts {\n\t\tif err = o(s); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// ensure sigs set\n\tif s.shutdownSigs == nil {\n\t\ts.shutdownSigs = []os.Signal{os.Interrupt}\n\t}\n\n\t// ensure errf set\n\tif s.errf == nil {\n\t\ts.errf = func(str string, v ...interface{}) {\n\t\t\ts.logf(\"ERROR: \"+str, v...)\n\t\t}\n\t}\n\n\treturn s, nil\n}", "code_tokens": ["func", "New", "(", "opts", "...", "Option", ")", "(", "*", "Sentinel", ",", "error", ")", "{", "s", ":=", "&", "Sentinel", "{", "shutdownDuration", ":", "DefaultShutdownDuration", ",", "logf", ":", "func", "(", "string", ",", "...", "interface", "{", "}", ")", "{", "}", ",", "}", "\n\n", "var", "err", "error", "\n\n", "// apply options", "for", "_", ",", "o", ":=", "range", "opts", "{", "if", "err", "=", "o", "(", "s", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "}", "\n\n", "// ensure sigs set", "if", "s", ".", "shutdownSigs", "==", "nil", "{", "s", ".", "shutdownSigs", "=", "[", "]", "os", ".", "Signal", "{", "os", ".", "Interrupt", "}", "\n", "}", "\n\n", "// ensure errf set", "if", "s", ".", "errf", "==", "nil", "{", "s", ".", "errf", "=", "func", "(", "str", "string", ",", "v", "...", "interface", "{", "}", ")", "{", "s", ".", "logf", "(", "\"", "\"", "+", "str", ",", "v", "...", ")", "\n", "}", "\n", "}", "\n\n", "return", "s", ",", "nil", "\n", "}"], "docstring": "// New creates a new sentinel server group.", "docstring_tokens": ["New", "creates", "a", "new", "sentinel", "server", "group", "."], "sha": "0ff081867c31a45cb71f5976ea6144fd06a557b5", "url": "https://github.com/brankas/sentinel/blob/0ff081867c31a45cb71f5976ea6144fd06a557b5/sentinel.go#L38-L66", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "greenhouse/diskutil/diskutil.go", "func_name": "GetATime", "original_string": "func GetATime(path string, defaultTime time.Time) time.Time {\n\tat, err := atime.Stat(path)\n\tif err != nil {\n\t\tlog.WithError(err).Errorf(\"Could not get atime for %s\", path)\n\t\treturn defaultTime\n\t}\n\treturn at\n}", "language": "go", "code": "func GetATime(path string, defaultTime time.Time) time.Time {\n\tat, err := atime.Stat(path)\n\tif err != nil {\n\t\tlog.WithError(err).Errorf(\"Could not get atime for %s\", path)\n\t\treturn defaultTime\n\t}\n\treturn at\n}", "code_tokens": ["func", "GetATime", "(", "path", "string", ",", "defaultTime", "time", ".", "Time", ")", "time", ".", "Time", "{", "at", ",", "err", ":=", "atime", ".", "Stat", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "WithError", "(", "err", ")", ".", "Errorf", "(", "\"", "\"", ",", "path", ")", "\n", "return", "defaultTime", "\n", "}", "\n", "return", "at", "\n", "}"], "docstring": "// GetATime the atime for a file, logging errors instead of failing\n// and returning defaultTime instead", "docstring_tokens": ["GetATime", "the", "atime", "for", "a", "file", "logging", "errors", "instead", "of", "failing", "and", "returning", "defaultTime", "instead"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/greenhouse/diskutil/diskutil.go#L43-L50", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "app/app.go", "func_name": "Start", "original_string": "func (app *App) Start(w io.Writer, process string) error {\n\tw = app.withLogWriter(w)\n\tmsg := fmt.Sprintf(\"\\n ---> Starting the process %q\", process)\n\tif process == \"\" {\n\t\tmsg = fmt.Sprintf(\"\\n ---> Starting the app %q\", app.Name)\n\t}\n\tfmt.Fprintf(w, \"%s\\n\", msg)\n\tprov, err := app.getProvisioner()\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = prov.Start(app, process)\n\tif err != nil {\n\t\tlog.Errorf(\"[start] error on start the app %s - %s\", app.Name, err)\n\t\treturn err\n\t}\n\trebuild.RoutesRebuildOrEnqueue(app.Name)\n\treturn err\n}", "language": "go", "code": "func (app *App) Start(w io.Writer, process string) error {\n\tw = app.withLogWriter(w)\n\tmsg := fmt.Sprintf(\"\\n ---> Starting the process %q\", process)\n\tif process == \"\" {\n\t\tmsg = fmt.Sprintf(\"\\n ---> Starting the app %q\", app.Name)\n\t}\n\tfmt.Fprintf(w, \"%s\\n\", msg)\n\tprov, err := app.getProvisioner()\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = prov.Start(app, process)\n\tif err != nil {\n\t\tlog.Errorf(\"[start] error on start the app %s - %s\", app.Name, err)\n\t\treturn err\n\t}\n\trebuild.RoutesRebuildOrEnqueue(app.Name)\n\treturn err\n}", "code_tokens": ["func", "(", "app", "*", "App", ")", "Start", "(", "w", "io", ".", "Writer", ",", "process", "string", ")", "error", "{", "w", "=", "app", ".", "withLogWriter", "(", "w", ")", "\n", "msg", ":=", "fmt", ".", "Sprintf", "(", "\"", "\\n", "\"", ",", "process", ")", "\n", "if", "process", "==", "\"", "\"", "{", "msg", "=", "fmt", ".", "Sprintf", "(", "\"", "\\n", "\"", ",", "app", ".", "Name", ")", "\n", "}", "\n", "fmt", ".", "Fprintf", "(", "w", ",", "\"", "\\n", "\"", ",", "msg", ")", "\n", "prov", ",", "err", ":=", "app", ".", "getProvisioner", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "err", "=", "prov", ".", "Start", "(", "app", ",", "process", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Errorf", "(", "\"", "\"", ",", "app", ".", "Name", ",", "err", ")", "\n", "return", "err", "\n", "}", "\n", "rebuild", ".", "RoutesRebuildOrEnqueue", "(", "app", ".", "Name", ")", "\n", "return", "err", "\n", "}"], "docstring": "// Start starts the app calling the provisioner.Start method and\n// changing the units state to StatusStarted.", "docstring_tokens": ["Start", "starts", "the", "app", "calling", "the", "provisioner", ".", "Start", "method", "and", "changing", "the", "units", "state", "to", "StatusStarted", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/app/app.go#L2108-L2126", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "fetch/fetch.go", "func_name": "WithURL", "original_string": "func (p ContinueRequestParams) WithURL(url string) *ContinueRequestParams {\n\tp.URL = url\n\treturn &p\n}", "language": "go", "code": "func (p ContinueRequestParams) WithURL(url string) *ContinueRequestParams {\n\tp.URL = url\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "ContinueRequestParams", ")", "WithURL", "(", "url", "string", ")", "*", "ContinueRequestParams", "{", "p", ".", "URL", "=", "url", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithURL if set, the request url will be modified in a way that's not\n// observable by page.", "docstring_tokens": ["WithURL", "if", "set", "the", "request", "url", "will", "be", "modified", "in", "a", "way", "that", "s", "not", "observable", "by", "page", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/fetch/fetch.go#L168-L171", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pfs/server/obj_block_api_server.go", "func_name": "watchGC", "original_string": "func (s *objBlockAPIServer) watchGC(etcdAddress string) {\n\tb := backoff.NewInfiniteBackOff()\n\tbackoff.RetryNotify(func() error {\n\t\tetcdClient, err := etcd.New(etcd.Config{\n\t\t\tEndpoints:   []string{etcdAddress},\n\t\t\tDialOptions: client.DefaultDialOptions(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error instantiating etcd client: %v\", err)\n\t\t}\n\n\t\twatcher, err := watch.NewWatcher(context.Background(), etcdClient, \"\", client.GCGenerationKey, nil)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error instantiating watch stream from generation number: %v\", err)\n\t\t}\n\t\tdefer watcher.Close()\n\n\t\tfor {\n\t\t\tev, ok := <-watcher.Watch()\n\t\t\tif ev.Err != nil {\n\t\t\t\treturn fmt.Errorf(\"error from generation number watch: %v\", ev.Err)\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"generation number watch stream closed unexpectedly\")\n\t\t\t}\n\t\t\tnewGen, err := strconv.Atoi(string(ev.Value))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error converting the generation number: %v\", err)\n\t\t\t}\n\t\t\ts.setGeneration(newGen)\n\t\t}\n\t}, b, func(err error, d time.Duration) error {\n\t\tlogrus.Errorf(\"error running GC watcher in block server: %v; retrying in %s\", err, d)\n\t\treturn nil\n\t})\n}", "language": "go", "code": "func (s *objBlockAPIServer) watchGC(etcdAddress string) {\n\tb := backoff.NewInfiniteBackOff()\n\tbackoff.RetryNotify(func() error {\n\t\tetcdClient, err := etcd.New(etcd.Config{\n\t\t\tEndpoints:   []string{etcdAddress},\n\t\t\tDialOptions: client.DefaultDialOptions(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error instantiating etcd client: %v\", err)\n\t\t}\n\n\t\twatcher, err := watch.NewWatcher(context.Background(), etcdClient, \"\", client.GCGenerationKey, nil)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error instantiating watch stream from generation number: %v\", err)\n\t\t}\n\t\tdefer watcher.Close()\n\n\t\tfor {\n\t\t\tev, ok := <-watcher.Watch()\n\t\t\tif ev.Err != nil {\n\t\t\t\treturn fmt.Errorf(\"error from generation number watch: %v\", ev.Err)\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"generation number watch stream closed unexpectedly\")\n\t\t\t}\n\t\t\tnewGen, err := strconv.Atoi(string(ev.Value))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error converting the generation number: %v\", err)\n\t\t\t}\n\t\t\ts.setGeneration(newGen)\n\t\t}\n\t}, b, func(err error, d time.Duration) error {\n\t\tlogrus.Errorf(\"error running GC watcher in block server: %v; retrying in %s\", err, d)\n\t\treturn nil\n\t})\n}", "code_tokens": ["func", "(", "s", "*", "objBlockAPIServer", ")", "watchGC", "(", "etcdAddress", "string", ")", "{", "b", ":=", "backoff", ".", "NewInfiniteBackOff", "(", ")", "\n", "backoff", ".", "RetryNotify", "(", "func", "(", ")", "error", "{", "etcdClient", ",", "err", ":=", "etcd", ".", "New", "(", "etcd", ".", "Config", "{", "Endpoints", ":", "[", "]", "string", "{", "etcdAddress", "}", ",", "DialOptions", ":", "client", ".", "DefaultDialOptions", "(", ")", ",", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "watcher", ",", "err", ":=", "watch", ".", "NewWatcher", "(", "context", ".", "Background", "(", ")", ",", "etcdClient", ",", "\"", "\"", ",", "client", ".", "GCGenerationKey", ",", "nil", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "defer", "watcher", ".", "Close", "(", ")", "\n\n", "for", "{", "ev", ",", "ok", ":=", "<-", "watcher", ".", "Watch", "(", ")", "\n", "if", "ev", ".", "Err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "ev", ".", "Err", ")", "\n", "}", "\n", "if", "!", "ok", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "newGen", ",", "err", ":=", "strconv", ".", "Atoi", "(", "string", "(", "ev", ".", "Value", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "s", ".", "setGeneration", "(", "newGen", ")", "\n", "}", "\n", "}", ",", "b", ",", "func", "(", "err", "error", ",", "d", "time", ".", "Duration", ")", "error", "{", "logrus", ".", "Errorf", "(", "\"", "\"", ",", "err", ",", "d", ")", "\n", "return", "nil", "\n", "}", ")", "\n", "}"], "docstring": "// watchGC watches for GC runs and invalidate all cache when GC happens.", "docstring_tokens": ["watchGC", "watches", "for", "GC", "runs", "and", "invalidate", "all", "cache", "when", "GC", "happens", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pfs/server/obj_block_api_server.go#L113-L148", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/plugins.go", "func_name": "Set", "original_string": "func (pa *ConfigAgent) Set(pc *Configuration) {\n\tpa.mut.Lock()\n\tdefer pa.mut.Unlock()\n\tpa.configuration = pc\n}", "language": "go", "code": "func (pa *ConfigAgent) Set(pc *Configuration) {\n\tpa.mut.Lock()\n\tdefer pa.mut.Unlock()\n\tpa.configuration = pc\n}", "code_tokens": ["func", "(", "pa", "*", "ConfigAgent", ")", "Set", "(", "pc", "*", "Configuration", ")", "{", "pa", ".", "mut", ".", "Lock", "(", ")", "\n", "defer", "pa", ".", "mut", ".", "Unlock", "(", ")", "\n", "pa", ".", "configuration", "=", "pc", "\n", "}"], "docstring": "// Set attempts to set the plugins that are enabled on repos. Plugins are listed\n// as a map from repositories to the list of plugins that are enabled on them.\n// Specifying simply an org name will also work, and will enable the plugin on\n// all repos in the org.", "docstring_tokens": ["Set", "attempts", "to", "set", "the", "plugins", "that", "are", "enabled", "on", "repos", ".", "Plugins", "are", "listed", "as", "a", "map", "from", "repositories", "to", "the", "list", "of", "plugins", "that", "are", "enabled", "on", "them", ".", "Specifying", "simply", "an", "org", "name", "will", "also", "work", "and", "will", "enable", "the", "plugin", "on", "all", "repos", "in", "the", "org", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/plugins.go#L236-L240", "partition": "test"}
{"repo": "containers/image", "path": "docker/tarfile/dest.go", "func_name": "sendFile", "original_string": "func (d *Destination) sendFile(path string, expectedSize int64, stream io.Reader) error {\n\thdr, err := tar.FileInfoHeader(&tarFI{path: path, size: expectedSize}, \"\")\n\tif err != nil {\n\t\treturn nil\n\t}\n\tlogrus.Debugf(\"Sending as tar file %s\", path)\n\tif err := d.tar.WriteHeader(hdr); err != nil {\n\t\treturn err\n\t}\n\t// TODO: This can take quite some time, and should ideally be cancellable using a context.Context.\n\tsize, err := io.Copy(d.tar, stream)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif size != expectedSize {\n\t\treturn errors.Errorf(\"Size mismatch when copying %s, expected %d, got %d\", path, expectedSize, size)\n\t}\n\treturn nil\n}", "language": "go", "code": "func (d *Destination) sendFile(path string, expectedSize int64, stream io.Reader) error {\n\thdr, err := tar.FileInfoHeader(&tarFI{path: path, size: expectedSize}, \"\")\n\tif err != nil {\n\t\treturn nil\n\t}\n\tlogrus.Debugf(\"Sending as tar file %s\", path)\n\tif err := d.tar.WriteHeader(hdr); err != nil {\n\t\treturn err\n\t}\n\t// TODO: This can take quite some time, and should ideally be cancellable using a context.Context.\n\tsize, err := io.Copy(d.tar, stream)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif size != expectedSize {\n\t\treturn errors.Errorf(\"Size mismatch when copying %s, expected %d, got %d\", path, expectedSize, size)\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "d", "*", "Destination", ")", "sendFile", "(", "path", "string", ",", "expectedSize", "int64", ",", "stream", "io", ".", "Reader", ")", "error", "{", "hdr", ",", "err", ":=", "tar", ".", "FileInfoHeader", "(", "&", "tarFI", "{", "path", ":", "path", ",", "size", ":", "expectedSize", "}", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", "\n", "}", "\n", "logrus", ".", "Debugf", "(", "\"", "\"", ",", "path", ")", "\n", "if", "err", ":=", "d", ".", "tar", ".", "WriteHeader", "(", "hdr", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "// TODO: This can take quite some time, and should ideally be cancellable using a context.Context.", "size", ",", "err", ":=", "io", ".", "Copy", "(", "d", ".", "tar", ",", "stream", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "size", "!=", "expectedSize", "{", "return", "errors", ".", "Errorf", "(", "\"", "\"", ",", "path", ",", "expectedSize", ",", "size", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// sendFile sends a file into the tar stream.", "docstring_tokens": ["sendFile", "sends", "a", "file", "into", "the", "tar", "stream", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/docker/tarfile/dest.go#L373-L391", "partition": "test"}
{"repo": "texttheater/golang-levenshtein", "path": "levenshtein/levenshtein.go", "func_name": "EditScriptForMatrix", "original_string": "func EditScriptForMatrix(matrix [][]int, op Options) EditScript {\n\treturn backtrace(len(matrix)-1, len(matrix[0])-1, matrix, op)\n}", "language": "go", "code": "func EditScriptForMatrix(matrix [][]int, op Options) EditScript {\n\treturn backtrace(len(matrix)-1, len(matrix[0])-1, matrix, op)\n}", "code_tokens": ["func", "EditScriptForMatrix", "(", "matrix", "[", "]", "[", "]", "int", ",", "op", "Options", ")", "EditScript", "{", "return", "backtrace", "(", "len", "(", "matrix", ")", "-", "1", ",", "len", "(", "matrix", "[", "0", "]", ")", "-", "1", ",", "matrix", ",", "op", ")", "\n", "}"], "docstring": "// EditScriptForMatrix returns an optimal edit script based on the given\n// Levenshtein matrix.", "docstring_tokens": ["EditScriptForMatrix", "returns", "an", "optimal", "edit", "script", "based", "on", "the", "given", "Levenshtein", "matrix", "."], "sha": "d188e65d659ef53fcdb0691c12f1bba64928b649", "url": "https://github.com/texttheater/golang-levenshtein/blob/d188e65d659ef53fcdb0691c12f1bba64928b649/levenshtein/levenshtein.go#L184-L186", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pps.go", "func_name": "CreateJob", "original_string": "func (c APIClient) CreateJob(pipeline string, outputCommit *pfs.Commit) (*pps.Job, error) {\n\tjob, err := c.PpsAPIClient.CreateJob(\n\t\tc.Ctx(),\n\t\t&pps.CreateJobRequest{\n\t\t\tPipeline:     NewPipeline(pipeline),\n\t\t\tOutputCommit: outputCommit,\n\t\t},\n\t)\n\treturn job, grpcutil.ScrubGRPC(err)\n}", "language": "go", "code": "func (c APIClient) CreateJob(pipeline string, outputCommit *pfs.Commit) (*pps.Job, error) {\n\tjob, err := c.PpsAPIClient.CreateJob(\n\t\tc.Ctx(),\n\t\t&pps.CreateJobRequest{\n\t\t\tPipeline:     NewPipeline(pipeline),\n\t\t\tOutputCommit: outputCommit,\n\t\t},\n\t)\n\treturn job, grpcutil.ScrubGRPC(err)\n}", "code_tokens": ["func", "(", "c", "APIClient", ")", "CreateJob", "(", "pipeline", "string", ",", "outputCommit", "*", "pfs", ".", "Commit", ")", "(", "*", "pps", ".", "Job", ",", "error", ")", "{", "job", ",", "err", ":=", "c", ".", "PpsAPIClient", ".", "CreateJob", "(", "c", ".", "Ctx", "(", ")", ",", "&", "pps", ".", "CreateJobRequest", "{", "Pipeline", ":", "NewPipeline", "(", "pipeline", ")", ",", "OutputCommit", ":", "outputCommit", ",", "}", ",", ")", "\n", "return", "job", ",", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}"], "docstring": "// CreateJob creates and runs a job in PPS.\n// This function is mostly useful internally, users should generally run work\n// by creating pipelines as well.", "docstring_tokens": ["CreateJob", "creates", "and", "runs", "a", "job", "in", "PPS", ".", "This", "function", "is", "mostly", "useful", "internally", "users", "should", "generally", "run", "work", "by", "creating", "pipelines", "as", "well", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pps.go#L167-L176", "partition": "test"}
{"repo": "jhillyerd/enmime", "path": "builder.go", "func_name": "Date", "original_string": "func (p MailBuilder) Date(date time.Time) MailBuilder {\n\tp.date = date\n\treturn p\n}", "language": "go", "code": "func (p MailBuilder) Date(date time.Time) MailBuilder {\n\tp.date = date\n\treturn p\n}", "code_tokens": ["func", "(", "p", "MailBuilder", ")", "Date", "(", "date", "time", ".", "Time", ")", "MailBuilder", "{", "p", ".", "date", "=", "date", "\n", "return", "p", "\n", "}"], "docstring": "// Date returns a copy of MailBuilder with the specified Date header.", "docstring_tokens": ["Date", "returns", "a", "copy", "of", "MailBuilder", "with", "the", "specified", "Date", "header", "."], "sha": "874cc30e023f36bd1df525716196887b0f04851b", "url": "https://github.com/jhillyerd/enmime/blob/874cc30e023f36bd1df525716196887b0f04851b/builder.go#L46-L49", "partition": "test"}
{"repo": "golang/appengine", "path": "appengine.go", "func_name": "WithContext", "original_string": "func WithContext(parent context.Context, req *http.Request) context.Context {\n\treturn internal.WithContext(parent, req)\n}", "language": "go", "code": "func WithContext(parent context.Context, req *http.Request) context.Context {\n\treturn internal.WithContext(parent, req)\n}", "code_tokens": ["func", "WithContext", "(", "parent", "context", ".", "Context", ",", "req", "*", "http", ".", "Request", ")", "context", ".", "Context", "{", "return", "internal", ".", "WithContext", "(", "parent", ",", "req", ")", "\n", "}"], "docstring": "// WithContext returns a copy of the parent context\n// and associates it with an in-flight HTTP request.\n// This function is cheap.", "docstring_tokens": ["WithContext", "returns", "a", "copy", "of", "the", "parent", "context", "and", "associates", "it", "with", "an", "in", "-", "flight", "HTTP", "request", ".", "This", "function", "is", "cheap", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/appengine.go#L96-L98", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/generate/db/lex.go", "func_name": "entityPost", "original_string": "func entityPost(entity string) string {\n\treturn fmt.Sprintf(\"%sPost\", lex.Capital(lex.Plural(entity)))\n}", "language": "go", "code": "func entityPost(entity string) string {\n\treturn fmt.Sprintf(\"%sPost\", lex.Capital(lex.Plural(entity)))\n}", "code_tokens": ["func", "entityPost", "(", "entity", "string", ")", "string", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "lex", ".", "Capital", "(", "lex", ".", "Plural", "(", "entity", ")", ")", ")", "\n", "}"], "docstring": "// Return the name of the Post struct for the given entity.", "docstring_tokens": ["Return", "the", "name", "of", "the", "Post", "struct", "for", "the", "given", "entity", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/generate/db/lex.go#L30-L32", "partition": "test"}
{"repo": "Unknwon/goconfig", "path": "conf.go", "func_name": "GetKeyList", "original_string": "func (c *ConfigFile) GetKeyList(section string) []string {\n\t// Blank section name represents DEFAULT section.\n\tif len(section) == 0 {\n\t\tsection = DEFAULT_SECTION\n\t}\n\n\tif c.BlockMode {\n\t\tc.lock.RLock()\n\t\tdefer c.lock.RUnlock()\n\t}\n\n\t// Check if section exists.\n\tif _, ok := c.data[section]; !ok {\n\t\treturn nil\n\t}\n\n\t// Non-default section has a blank key as section keeper.\n\tlist := make([]string, 0, len(c.keyList[section]))\n\tfor _, key := range c.keyList[section] {\n\t\tif key != \" \" {\n\t\t\tlist = append(list, key)\n\t\t}\n\t}\n\treturn list\n}", "language": "go", "code": "func (c *ConfigFile) GetKeyList(section string) []string {\n\t// Blank section name represents DEFAULT section.\n\tif len(section) == 0 {\n\t\tsection = DEFAULT_SECTION\n\t}\n\n\tif c.BlockMode {\n\t\tc.lock.RLock()\n\t\tdefer c.lock.RUnlock()\n\t}\n\n\t// Check if section exists.\n\tif _, ok := c.data[section]; !ok {\n\t\treturn nil\n\t}\n\n\t// Non-default section has a blank key as section keeper.\n\tlist := make([]string, 0, len(c.keyList[section]))\n\tfor _, key := range c.keyList[section] {\n\t\tif key != \" \" {\n\t\t\tlist = append(list, key)\n\t\t}\n\t}\n\treturn list\n}", "code_tokens": ["func", "(", "c", "*", "ConfigFile", ")", "GetKeyList", "(", "section", "string", ")", "[", "]", "string", "{", "// Blank section name represents DEFAULT section.", "if", "len", "(", "section", ")", "==", "0", "{", "section", "=", "DEFAULT_SECTION", "\n", "}", "\n\n", "if", "c", ".", "BlockMode", "{", "c", ".", "lock", ".", "RLock", "(", ")", "\n", "defer", "c", ".", "lock", ".", "RUnlock", "(", ")", "\n", "}", "\n\n", "// Check if section exists.", "if", "_", ",", "ok", ":=", "c", ".", "data", "[", "section", "]", ";", "!", "ok", "{", "return", "nil", "\n", "}", "\n\n", "// Non-default section has a blank key as section keeper.", "list", ":=", "make", "(", "[", "]", "string", ",", "0", ",", "len", "(", "c", ".", "keyList", "[", "section", "]", ")", ")", "\n", "for", "_", ",", "key", ":=", "range", "c", ".", "keyList", "[", "section", "]", "{", "if", "key", "!=", "\"", "\"", "{", "list", "=", "append", "(", "list", ",", "key", ")", "\n", "}", "\n", "}", "\n", "return", "list", "\n", "}"], "docstring": "// GetKeyList returns the list of all keys in give section\n// in the same order in the file.\n// It returns nil if given section does not exist.", "docstring_tokens": ["GetKeyList", "returns", "the", "list", "of", "all", "keys", "in", "give", "section", "in", "the", "same", "order", "in", "the", "file", ".", "It", "returns", "nil", "if", "given", "section", "does", "not", "exist", "."], "sha": "3dba17dd7b9ec8509b3621a73a30a4b333eb28da", "url": "https://github.com/Unknwon/goconfig/blob/3dba17dd7b9ec8509b3621a73a30a4b333eb28da/conf.go#L360-L384", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "db.go", "func_name": "Release", "original_string": "func (seq *Sequence) Release() error {\n\tseq.Lock()\n\tdefer seq.Unlock()\n\terr := seq.db.Update(func(txn *Txn) error {\n\t\tvar buf [8]byte\n\t\tbinary.BigEndian.PutUint64(buf[:], seq.next)\n\t\treturn txn.Set(seq.key, buf[:])\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tseq.leased = seq.next\n\treturn nil\n}", "language": "go", "code": "func (seq *Sequence) Release() error {\n\tseq.Lock()\n\tdefer seq.Unlock()\n\terr := seq.db.Update(func(txn *Txn) error {\n\t\tvar buf [8]byte\n\t\tbinary.BigEndian.PutUint64(buf[:], seq.next)\n\t\treturn txn.Set(seq.key, buf[:])\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tseq.leased = seq.next\n\treturn nil\n}", "code_tokens": ["func", "(", "seq", "*", "Sequence", ")", "Release", "(", ")", "error", "{", "seq", ".", "Lock", "(", ")", "\n", "defer", "seq", ".", "Unlock", "(", ")", "\n", "err", ":=", "seq", ".", "db", ".", "Update", "(", "func", "(", "txn", "*", "Txn", ")", "error", "{", "var", "buf", "[", "8", "]", "byte", "\n", "binary", ".", "BigEndian", ".", "PutUint64", "(", "buf", "[", ":", "]", ",", "seq", ".", "next", ")", "\n", "return", "txn", ".", "Set", "(", "seq", ".", "key", ",", "buf", "[", ":", "]", ")", "\n", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "seq", ".", "leased", "=", "seq", ".", "next", "\n", "return", "nil", "\n", "}"], "docstring": "// Release the leased sequence to avoid wasted integers. This should be done right\n// before closing the associated DB. However it is valid to use the sequence after\n// it was released, causing a new lease with full bandwidth.", "docstring_tokens": ["Release", "the", "leased", "sequence", "to", "avoid", "wasted", "integers", ".", "This", "should", "be", "done", "right", "before", "closing", "the", "associated", "DB", ".", "However", "it", "is", "valid", "to", "use", "the", "sequence", "after", "it", "was", "released", "causing", "a", "new", "lease", "with", "full", "bandwidth", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/db.go#L1060-L1073", "partition": "test"}
{"repo": "hashicorp/raft", "path": "api.go", "func_name": "RemoveServer", "original_string": "func (r *Raft) RemoveServer(id ServerID, prevIndex uint64, timeout time.Duration) IndexFuture {\n\tif r.protocolVersion < 2 {\n\t\treturn errorFuture{ErrUnsupportedProtocol}\n\t}\n\n\treturn r.requestConfigChange(configurationChangeRequest{\n\t\tcommand:   RemoveServer,\n\t\tserverID:  id,\n\t\tprevIndex: prevIndex,\n\t}, timeout)\n}", "language": "go", "code": "func (r *Raft) RemoveServer(id ServerID, prevIndex uint64, timeout time.Duration) IndexFuture {\n\tif r.protocolVersion < 2 {\n\t\treturn errorFuture{ErrUnsupportedProtocol}\n\t}\n\n\treturn r.requestConfigChange(configurationChangeRequest{\n\t\tcommand:   RemoveServer,\n\t\tserverID:  id,\n\t\tprevIndex: prevIndex,\n\t}, timeout)\n}", "code_tokens": ["func", "(", "r", "*", "Raft", ")", "RemoveServer", "(", "id", "ServerID", ",", "prevIndex", "uint64", ",", "timeout", "time", ".", "Duration", ")", "IndexFuture", "{", "if", "r", ".", "protocolVersion", "<", "2", "{", "return", "errorFuture", "{", "ErrUnsupportedProtocol", "}", "\n", "}", "\n\n", "return", "r", ".", "requestConfigChange", "(", "configurationChangeRequest", "{", "command", ":", "RemoveServer", ",", "serverID", ":", "id", ",", "prevIndex", ":", "prevIndex", ",", "}", ",", "timeout", ")", "\n", "}"], "docstring": "// RemoveServer will remove the given server from the cluster. If the current\n// leader is being removed, it will cause a new election to occur. This must be\n// run on the leader or it will fail. For prevIndex and timeout, see AddVoter.", "docstring_tokens": ["RemoveServer", "will", "remove", "the", "given", "server", "from", "the", "cluster", ".", "If", "the", "current", "leader", "is", "being", "removed", "it", "will", "cause", "a", "new", "election", "to", "occur", ".", "This", "must", "be", "run", "on", "the", "leader", "or", "it", "will", "fail", ".", "For", "prevIndex", "and", "timeout", "see", "AddVoter", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/api.go#L766-L776", "partition": "test"}
{"repo": "mgutz/str", "path": "funcsPZ.go", "func_name": "StripPunctuation", "original_string": "func StripPunctuation(s string) string {\n\ts = stripPuncRe.ReplaceAllString(s, \"\")\n\ts = nWhitespaceRe.ReplaceAllString(s, \" \")\n\treturn s\n}", "language": "go", "code": "func StripPunctuation(s string) string {\n\ts = stripPuncRe.ReplaceAllString(s, \"\")\n\ts = nWhitespaceRe.ReplaceAllString(s, \" \")\n\treturn s\n}", "code_tokens": ["func", "StripPunctuation", "(", "s", "string", ")", "string", "{", "s", "=", "stripPuncRe", ".", "ReplaceAllString", "(", "s", ",", "\"", "\"", ")", "\n", "s", "=", "nWhitespaceRe", ".", "ReplaceAllString", "(", "s", ",", "\"", "\"", ")", "\n", "return", "s", "\n", "}"], "docstring": "// StripPunctuation strips puncation from string.", "docstring_tokens": ["StripPunctuation", "strips", "puncation", "from", "string", "."], "sha": "968bf66e3da857419e4f6e71b2d5c9ae95682dc4", "url": "https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsPZ.go#L197-L201", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "buffalo/cmd/fix/imports.go", "func_name": "match", "original_string": "func (c ImportConverter) match(importpath string) (string, bool) {\n\tfor key, value := range c.Data {\n\t\tif !strings.HasPrefix(importpath, key) {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := strings.Replace(importpath, key, value, 1)\n\t\treturn result, true\n\t}\n\n\treturn importpath, false\n}", "language": "go", "code": "func (c ImportConverter) match(importpath string) (string, bool) {\n\tfor key, value := range c.Data {\n\t\tif !strings.HasPrefix(importpath, key) {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := strings.Replace(importpath, key, value, 1)\n\t\treturn result, true\n\t}\n\n\treturn importpath, false\n}", "code_tokens": ["func", "(", "c", "ImportConverter", ")", "match", "(", "importpath", "string", ")", "(", "string", ",", "bool", ")", "{", "for", "key", ",", "value", ":=", "range", "c", ".", "Data", "{", "if", "!", "strings", ".", "HasPrefix", "(", "importpath", ",", "key", ")", "{", "continue", "\n", "}", "\n\n", "result", ":=", "strings", ".", "Replace", "(", "importpath", ",", "key", ",", "value", ",", "1", ")", "\n", "return", "result", ",", "true", "\n", "}", "\n\n", "return", "importpath", ",", "false", "\n", "}"], "docstring": "// match takes an import path and replacement map.", "docstring_tokens": ["match", "takes", "an", "import", "path", "and", "replacement", "map", "."], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/buffalo/cmd/fix/imports.go#L151-L162", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/collection/transaction.go", "func_name": "NewSTM", "original_string": "func NewSTM(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\n\treturn newSTMSerializable(ctx, c, apply, false)\n}", "language": "go", "code": "func NewSTM(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\n\treturn newSTMSerializable(ctx, c, apply, false)\n}", "code_tokens": ["func", "NewSTM", "(", "ctx", "context", ".", "Context", ",", "c", "*", "v3", ".", "Client", ",", "apply", "func", "(", "STM", ")", "error", ")", "(", "*", "v3", ".", "TxnResponse", ",", "error", ")", "{", "return", "newSTMSerializable", "(", "ctx", ",", "c", ",", "apply", ",", "false", ")", "\n", "}"], "docstring": "// NewSTM intiates a new STM operation. It uses a serializable model.", "docstring_tokens": ["NewSTM", "intiates", "a", "new", "STM", "operation", ".", "It", "uses", "a", "serializable", "model", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/collection/transaction.go#L63-L65", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "vm/state.go", "func_name": "Reset", "original_string": "func (st *State) Reset() {\n\tst.opidx = 0\n\tst.sa = nil\n\tst.sb = nil\n\tst.stack.Reset()\n\tst.markstack.Reset()\n\tst.frames.Reset()\n\tst.framestack.Reset()\n\n\tst.Pushmark()\n\tst.PushFrame()\n}", "language": "go", "code": "func (st *State) Reset() {\n\tst.opidx = 0\n\tst.sa = nil\n\tst.sb = nil\n\tst.stack.Reset()\n\tst.markstack.Reset()\n\tst.frames.Reset()\n\tst.framestack.Reset()\n\n\tst.Pushmark()\n\tst.PushFrame()\n}", "code_tokens": ["func", "(", "st", "*", "State", ")", "Reset", "(", ")", "{", "st", ".", "opidx", "=", "0", "\n", "st", ".", "sa", "=", "nil", "\n", "st", ".", "sb", "=", "nil", "\n", "st", ".", "stack", ".", "Reset", "(", ")", "\n", "st", ".", "markstack", ".", "Reset", "(", ")", "\n", "st", ".", "frames", ".", "Reset", "(", ")", "\n", "st", ".", "framestack", ".", "Reset", "(", ")", "\n\n", "st", ".", "Pushmark", "(", ")", "\n", "st", ".", "PushFrame", "(", ")", "\n", "}"], "docstring": "// Reset resets the whole State object", "docstring_tokens": ["Reset", "resets", "the", "whole", "State", "object"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/vm/state.go#L149-L160", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "WithFromSurface", "original_string": "func (p CaptureScreenshotParams) WithFromSurface(fromSurface bool) *CaptureScreenshotParams {\n\tp.FromSurface = fromSurface\n\treturn &p\n}", "language": "go", "code": "func (p CaptureScreenshotParams) WithFromSurface(fromSurface bool) *CaptureScreenshotParams {\n\tp.FromSurface = fromSurface\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "CaptureScreenshotParams", ")", "WithFromSurface", "(", "fromSurface", "bool", ")", "*", "CaptureScreenshotParams", "{", "p", ".", "FromSurface", "=", "fromSurface", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithFromSurface capture the screenshot from the surface, rather than the\n// view. Defaults to true.", "docstring_tokens": ["WithFromSurface", "capture", "the", "screenshot", "from", "the", "surface", "rather", "than", "the", "view", ".", "Defaults", "to", "true", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L122-L125", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "boskos/crds/resource_crd.go", "func_name": "SetItems", "original_string": "func (in *ResourceCollection) SetItems(objects []Object) {\n\tvar items []*ResourceObject\n\tfor _, b := range objects {\n\t\titems = append(items, b.(*ResourceObject))\n\t}\n\tin.Items = items\n}", "language": "go", "code": "func (in *ResourceCollection) SetItems(objects []Object) {\n\tvar items []*ResourceObject\n\tfor _, b := range objects {\n\t\titems = append(items, b.(*ResourceObject))\n\t}\n\tin.Items = items\n}", "code_tokens": ["func", "(", "in", "*", "ResourceCollection", ")", "SetItems", "(", "objects", "[", "]", "Object", ")", "{", "var", "items", "[", "]", "*", "ResourceObject", "\n", "for", "_", ",", "b", ":=", "range", "objects", "{", "items", "=", "append", "(", "items", ",", "b", ".", "(", "*", "ResourceObject", ")", ")", "\n", "}", "\n", "in", ".", "Items", "=", "items", "\n", "}"], "docstring": "// SetItems implements Collection interface", "docstring_tokens": ["SetItems", "implements", "Collection", "interface"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/crds/resource_crd.go#L147-L153", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "skiplist/builder.go", "func_name": "NewSegment", "original_string": "func (b *Builder) NewSegment() *Segment {\n\tseg := &Segment{tail: make([]*Node, MaxLevel+1),\n\t\thead: make([]*Node, MaxLevel+1), builder: b,\n\t\trand: rand.New(rand.NewSource(int64(rand.Int()))),\n\t}\n\n\tseg.sts.IsLocal(true)\n\treturn seg\n}", "language": "go", "code": "func (b *Builder) NewSegment() *Segment {\n\tseg := &Segment{tail: make([]*Node, MaxLevel+1),\n\t\thead: make([]*Node, MaxLevel+1), builder: b,\n\t\trand: rand.New(rand.NewSource(int64(rand.Int()))),\n\t}\n\n\tseg.sts.IsLocal(true)\n\treturn seg\n}", "code_tokens": ["func", "(", "b", "*", "Builder", ")", "NewSegment", "(", ")", "*", "Segment", "{", "seg", ":=", "&", "Segment", "{", "tail", ":", "make", "(", "[", "]", "*", "Node", ",", "MaxLevel", "+", "1", ")", ",", "head", ":", "make", "(", "[", "]", "*", "Node", ",", "MaxLevel", "+", "1", ")", ",", "builder", ":", "b", ",", "rand", ":", "rand", ".", "New", "(", "rand", ".", "NewSource", "(", "int64", "(", "rand", ".", "Int", "(", ")", ")", ")", ")", ",", "}", "\n\n", "seg", ".", "sts", ".", "IsLocal", "(", "true", ")", "\n", "return", "seg", "\n", "}"], "docstring": "// NewSegment creates a new skiplist segment", "docstring_tokens": ["NewSegment", "creates", "a", "new", "skiplist", "segment"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/skiplist/builder.go#L68-L76", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/util_linux.go", "func_name": "GetErrno", "original_string": "func GetErrno(err error) (errno error, iserrno bool) {\n\tsysErr, ok := err.(*os.SyscallError)\n\tif ok {\n\t\treturn sysErr.Err, true\n\t}\n\n\tpathErr, ok := err.(*os.PathError)\n\tif ok {\n\t\treturn pathErr.Err, true\n\t}\n\n\ttmpErrno, ok := err.(syscall.Errno)\n\tif ok {\n\t\treturn tmpErrno, true\n\t}\n\n\treturn nil, false\n}", "language": "go", "code": "func GetErrno(err error) (errno error, iserrno bool) {\n\tsysErr, ok := err.(*os.SyscallError)\n\tif ok {\n\t\treturn sysErr.Err, true\n\t}\n\n\tpathErr, ok := err.(*os.PathError)\n\tif ok {\n\t\treturn pathErr.Err, true\n\t}\n\n\ttmpErrno, ok := err.(syscall.Errno)\n\tif ok {\n\t\treturn tmpErrno, true\n\t}\n\n\treturn nil, false\n}", "code_tokens": ["func", "GetErrno", "(", "err", "error", ")", "(", "errno", "error", ",", "iserrno", "bool", ")", "{", "sysErr", ",", "ok", ":=", "err", ".", "(", "*", "os", ".", "SyscallError", ")", "\n", "if", "ok", "{", "return", "sysErr", ".", "Err", ",", "true", "\n", "}", "\n\n", "pathErr", ",", "ok", ":=", "err", ".", "(", "*", "os", ".", "PathError", ")", "\n", "if", "ok", "{", "return", "pathErr", ".", "Err", ",", "true", "\n", "}", "\n\n", "tmpErrno", ",", "ok", ":=", "err", ".", "(", "syscall", ".", "Errno", ")", "\n", "if", "ok", "{", "return", "tmpErrno", ",", "true", "\n", "}", "\n\n", "return", "nil", ",", "false", "\n", "}"], "docstring": "// Detect whether err is an errno.", "docstring_tokens": ["Detect", "whether", "err", "is", "an", "errno", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/util_linux.go#L265-L282", "partition": "test"}
{"repo": "justinfx/gofileseq", "path": "ranges/ranges.go", "func_name": "Start", "original_string": "func (l *InclusiveRanges) Start() int {\n\tfor _, b := range l.blocks {\n\t\treturn b.Start()\n\t}\n\treturn 0\n}", "language": "go", "code": "func (l *InclusiveRanges) Start() int {\n\tfor _, b := range l.blocks {\n\t\treturn b.Start()\n\t}\n\treturn 0\n}", "code_tokens": ["func", "(", "l", "*", "InclusiveRanges", ")", "Start", "(", ")", "int", "{", "for", "_", ",", "b", ":=", "range", "l", ".", "blocks", "{", "return", "b", ".", "Start", "(", ")", "\n", "}", "\n", "return", "0", "\n", "}"], "docstring": "// Start returns the first value of the first range", "docstring_tokens": ["Start", "returns", "the", "first", "value", "of", "the", "first", "range"], "sha": "2555f296b4493d1825f5f6fab4aa0ff51a8306cd", "url": "https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/ranges/ranges.go#L331-L336", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/generate/db/mapping.go", "func_name": "FieldByName", "original_string": "func (m *Mapping) FieldByName(name string) *Field {\n\tfor _, field := range m.Fields {\n\t\tif field.Name == name {\n\t\t\treturn field\n\t\t}\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (m *Mapping) FieldByName(name string) *Field {\n\tfor _, field := range m.Fields {\n\t\tif field.Name == name {\n\t\t\treturn field\n\t\t}\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "m", "*", "Mapping", ")", "FieldByName", "(", "name", "string", ")", "*", "Field", "{", "for", "_", ",", "field", ":=", "range", "m", ".", "Fields", "{", "if", "field", ".", "Name", "==", "name", "{", "return", "field", "\n", "}", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// FieldByName returns the field with the given name, if any.", "docstring_tokens": ["FieldByName", "returns", "the", "field", "with", "the", "given", "name", "if", "any", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/generate/db/mapping.go#L58-L66", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/flags/urls.go", "func_name": "NewURLsValue", "original_string": "func NewURLsValue(s string) *URLsValue {\n\tif s == \"\" {\n\t\treturn &URLsValue{}\n\t}\n\tv := &URLsValue{}\n\tif err := v.Set(s); err != nil {\n\t\tplog.Panicf(\"new URLsValue should never fail: %v\", err)\n\t}\n\treturn v\n}", "language": "go", "code": "func NewURLsValue(s string) *URLsValue {\n\tif s == \"\" {\n\t\treturn &URLsValue{}\n\t}\n\tv := &URLsValue{}\n\tif err := v.Set(s); err != nil {\n\t\tplog.Panicf(\"new URLsValue should never fail: %v\", err)\n\t}\n\treturn v\n}", "code_tokens": ["func", "NewURLsValue", "(", "s", "string", ")", "*", "URLsValue", "{", "if", "s", "==", "\"", "\"", "{", "return", "&", "URLsValue", "{", "}", "\n", "}", "\n", "v", ":=", "&", "URLsValue", "{", "}", "\n", "if", "err", ":=", "v", ".", "Set", "(", "s", ")", ";", "err", "!=", "nil", "{", "plog", ".", "Panicf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "return", "v", "\n", "}"], "docstring": "// NewURLsValue implements \"url.URL\" slice as flag.Value interface.\n// Given value is to be separated by comma.", "docstring_tokens": ["NewURLsValue", "implements", "url", ".", "URL", "slice", "as", "flag", ".", "Value", "interface", ".", "Given", "value", "is", "to", "be", "separated", "by", "comma", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/flags/urls.go#L51-L60", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/config/config.go", "func_name": "Load", "original_string": "func Load(prowConfig, jobConfig string) (c *Config, err error) {\n\t// we never want config loading to take down the prow components\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tc, err = nil, fmt.Errorf(\"panic loading config: %v\", r)\n\t\t}\n\t}()\n\tc, err = loadConfig(prowConfig, jobConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := c.finalizeJobConfig(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := c.validateComponentConfig(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := c.validateJobConfig(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}", "language": "go", "code": "func Load(prowConfig, jobConfig string) (c *Config, err error) {\n\t// we never want config loading to take down the prow components\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tc, err = nil, fmt.Errorf(\"panic loading config: %v\", r)\n\t\t}\n\t}()\n\tc, err = loadConfig(prowConfig, jobConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := c.finalizeJobConfig(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := c.validateComponentConfig(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := c.validateJobConfig(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}", "code_tokens": ["func", "Load", "(", "prowConfig", ",", "jobConfig", "string", ")", "(", "c", "*", "Config", ",", "err", "error", ")", "{", "// we never want config loading to take down the prow components", "defer", "func", "(", ")", "{", "if", "r", ":=", "recover", "(", ")", ";", "r", "!=", "nil", "{", "c", ",", "err", "=", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "r", ")", "\n", "}", "\n", "}", "(", ")", "\n", "c", ",", "err", "=", "loadConfig", "(", "prowConfig", ",", "jobConfig", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "err", ":=", "c", ".", "finalizeJobConfig", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "err", ":=", "c", ".", "validateComponentConfig", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "err", ":=", "c", ".", "validateJobConfig", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "c", ",", "nil", "\n", "}"], "docstring": "// Load loads and parses the config at path.", "docstring_tokens": ["Load", "loads", "and", "parses", "the", "config", "at", "path", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/config.go#L414-L435", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/hook/server.go", "func_name": "demuxExternal", "original_string": "func (s *Server) demuxExternal(l *logrus.Entry, externalPlugins []plugins.ExternalPlugin, payload []byte, h http.Header) {\n\th.Set(\"User-Agent\", \"ProwHook\")\n\tfor _, p := range externalPlugins {\n\t\ts.wg.Add(1)\n\t\tgo func(p plugins.ExternalPlugin) {\n\t\t\tdefer s.wg.Done()\n\t\t\tif err := s.dispatch(p.Endpoint, payload, h); err != nil {\n\t\t\t\tl.WithError(err).WithField(\"external-plugin\", p.Name).Error(\"Error dispatching event to external plugin.\")\n\t\t\t} else {\n\t\t\t\tl.WithField(\"external-plugin\", p.Name).Info(\"Dispatched event to external plugin\")\n\t\t\t}\n\t\t}(p)\n\t}\n}", "language": "go", "code": "func (s *Server) demuxExternal(l *logrus.Entry, externalPlugins []plugins.ExternalPlugin, payload []byte, h http.Header) {\n\th.Set(\"User-Agent\", \"ProwHook\")\n\tfor _, p := range externalPlugins {\n\t\ts.wg.Add(1)\n\t\tgo func(p plugins.ExternalPlugin) {\n\t\t\tdefer s.wg.Done()\n\t\t\tif err := s.dispatch(p.Endpoint, payload, h); err != nil {\n\t\t\t\tl.WithError(err).WithField(\"external-plugin\", p.Name).Error(\"Error dispatching event to external plugin.\")\n\t\t\t} else {\n\t\t\t\tl.WithField(\"external-plugin\", p.Name).Info(\"Dispatched event to external plugin\")\n\t\t\t}\n\t\t}(p)\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "Server", ")", "demuxExternal", "(", "l", "*", "logrus", ".", "Entry", ",", "externalPlugins", "[", "]", "plugins", ".", "ExternalPlugin", ",", "payload", "[", "]", "byte", ",", "h", "http", ".", "Header", ")", "{", "h", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "for", "_", ",", "p", ":=", "range", "externalPlugins", "{", "s", ".", "wg", ".", "Add", "(", "1", ")", "\n", "go", "func", "(", "p", "plugins", ".", "ExternalPlugin", ")", "{", "defer", "s", ".", "wg", ".", "Done", "(", ")", "\n", "if", "err", ":=", "s", ".", "dispatch", "(", "p", ".", "Endpoint", ",", "payload", ",", "h", ")", ";", "err", "!=", "nil", "{", "l", ".", "WithError", "(", "err", ")", ".", "WithField", "(", "\"", "\"", ",", "p", ".", "Name", ")", ".", "Error", "(", "\"", "\"", ")", "\n", "}", "else", "{", "l", ".", "WithField", "(", "\"", "\"", ",", "p", ".", "Name", ")", ".", "Info", "(", "\"", "\"", ")", "\n", "}", "\n", "}", "(", "p", ")", "\n", "}", "\n", "}"], "docstring": "// demuxExternal dispatches the provided payload to the external plugins.", "docstring_tokens": ["demuxExternal", "dispatches", "the", "provided", "payload", "to", "the", "external", "plugins", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/hook/server.go#L193-L206", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/projects.go", "func_name": "ProjectMap", "original_string": "func (c *ClusterTx) ProjectMap() (map[int64]string, error) {\n\tstmt := \"SELECT id, name FROM projects\"\n\n\trows, err := c.tx.Query(stmt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tresult := map[int64]string{}\n\tfor i := 0; rows.Next(); i++ {\n\t\tvar id int64\n\t\tvar name string\n\n\t\terr := rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresult[id] = name\n\t}\n\n\terr = rows.Err()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}", "language": "go", "code": "func (c *ClusterTx) ProjectMap() (map[int64]string, error) {\n\tstmt := \"SELECT id, name FROM projects\"\n\n\trows, err := c.tx.Query(stmt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tresult := map[int64]string{}\n\tfor i := 0; rows.Next(); i++ {\n\t\tvar id int64\n\t\tvar name string\n\n\t\terr := rows.Scan(&id, &name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresult[id] = name\n\t}\n\n\terr = rows.Err()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}", "code_tokens": ["func", "(", "c", "*", "ClusterTx", ")", "ProjectMap", "(", ")", "(", "map", "[", "int64", "]", "string", ",", "error", ")", "{", "stmt", ":=", "\"", "\"", "\n\n", "rows", ",", "err", ":=", "c", ".", "tx", ".", "Query", "(", "stmt", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "defer", "rows", ".", "Close", "(", ")", "\n\n", "result", ":=", "map", "[", "int64", "]", "string", "{", "}", "\n", "for", "i", ":=", "0", ";", "rows", ".", "Next", "(", ")", ";", "i", "++", "{", "var", "id", "int64", "\n", "var", "name", "string", "\n\n", "err", ":=", "rows", ".", "Scan", "(", "&", "id", ",", "&", "name", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "result", "[", "id", "]", "=", "name", "\n", "}", "\n\n", "err", "=", "rows", ".", "Err", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "result", ",", "nil", "\n", "}"], "docstring": "// ProjectMap returns the names and ids of all available projects.", "docstring_tokens": ["ProjectMap", "returns", "the", "names", "and", "ids", "of", "all", "available", "projects", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/projects.go#L67-L95", "partition": "test"}
{"repo": "rightscale/rsc", "path": "policy/auth.go", "func_name": "HostFromLogin", "original_string": "func HostFromLogin(host string) string {\n\turlElems := strings.Split(host, \".\")\n\thostPrefix := urlElems[0]\n\telems := strings.Split(hostPrefix, \"-\")\n\n\tif len(elems) == 1 && elems[0] == \"cm\" {\n\t\t// accommodates micromoo host inference, such as \"cm.rightscale.local\" => \"selfservice.rightscale.local\"\n\t\telems[0] = \"governance\"\n\t} else if len(elems) < 2 {\n\t\t// don't know how to compute this policy host; use the cm host\n\t\treturn host\n\t} else {\n\t\telems[len(elems)-2] = \"governance\"\n\t}\n\tpolicyHostPrefix := strings.Join(elems, \"-\")\n\treturn strings.Join(append([]string{policyHostPrefix}, urlElems[1:]...), \".\")\n}", "language": "go", "code": "func HostFromLogin(host string) string {\n\turlElems := strings.Split(host, \".\")\n\thostPrefix := urlElems[0]\n\telems := strings.Split(hostPrefix, \"-\")\n\n\tif len(elems) == 1 && elems[0] == \"cm\" {\n\t\t// accommodates micromoo host inference, such as \"cm.rightscale.local\" => \"selfservice.rightscale.local\"\n\t\telems[0] = \"governance\"\n\t} else if len(elems) < 2 {\n\t\t// don't know how to compute this policy host; use the cm host\n\t\treturn host\n\t} else {\n\t\telems[len(elems)-2] = \"governance\"\n\t}\n\tpolicyHostPrefix := strings.Join(elems, \"-\")\n\treturn strings.Join(append([]string{policyHostPrefix}, urlElems[1:]...), \".\")\n}", "code_tokens": ["func", "HostFromLogin", "(", "host", "string", ")", "string", "{", "urlElems", ":=", "strings", ".", "Split", "(", "host", ",", "\"", "\"", ")", "\n", "hostPrefix", ":=", "urlElems", "[", "0", "]", "\n", "elems", ":=", "strings", ".", "Split", "(", "hostPrefix", ",", "\"", "\"", ")", "\n\n", "if", "len", "(", "elems", ")", "==", "1", "&&", "elems", "[", "0", "]", "==", "\"", "\"", "{", "// accommodates micromoo host inference, such as \"cm.rightscale.local\" => \"selfservice.rightscale.local\"", "elems", "[", "0", "]", "=", "\"", "\"", "\n", "}", "else", "if", "len", "(", "elems", ")", "<", "2", "{", "// don't know how to compute this policy host; use the cm host", "return", "host", "\n", "}", "else", "{", "elems", "[", "len", "(", "elems", ")", "-", "2", "]", "=", "\"", "\"", "\n", "}", "\n", "policyHostPrefix", ":=", "strings", ".", "Join", "(", "elems", ",", "\"", "\"", ")", "\n", "return", "strings", ".", "Join", "(", "append", "(", "[", "]", "string", "{", "policyHostPrefix", "}", ",", "urlElems", "[", "1", ":", "]", "...", ")", ",", "\"", "\"", ")", "\n", "}"], "docstring": "// HostFromLogin returns the policy endpoint from its login endpoint.\n// The following isn't great but seems better than having to enter by hand.", "docstring_tokens": ["HostFromLogin", "returns", "the", "policy", "endpoint", "from", "its", "login", "endpoint", ".", "The", "following", "isn", "t", "great", "but", "seems", "better", "than", "having", "to", "enter", "by", "hand", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/policy/auth.go#L45-L61", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "target/target.go", "func_name": "Do", "original_string": "func (p *SetRemoteLocationsParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetRemoteLocations, p, nil)\n}", "language": "go", "code": "func (p *SetRemoteLocationsParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetRemoteLocations, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetRemoteLocationsParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetRemoteLocations", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Target.setRemoteLocations against the provided context.", "docstring_tokens": ["Do", "executes", "Target", ".", "setRemoteLocations", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/target/target.go#L557-L559", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/watch/watch.go", "func_name": "MakeWatcher", "original_string": "func MakeWatcher(eventCh chan *Event, done chan struct{}) Watcher {\n\treturn &watcher{\n\t\teventCh: eventCh,\n\t\tdone:    done,\n\t}\n}", "language": "go", "code": "func MakeWatcher(eventCh chan *Event, done chan struct{}) Watcher {\n\treturn &watcher{\n\t\teventCh: eventCh,\n\t\tdone:    done,\n\t}\n}", "code_tokens": ["func", "MakeWatcher", "(", "eventCh", "chan", "*", "Event", ",", "done", "chan", "struct", "{", "}", ")", "Watcher", "{", "return", "&", "watcher", "{", "eventCh", ":", "eventCh", ",", "done", ":", "done", ",", "}", "\n", "}"], "docstring": "// MakeWatcher returns a Watcher that uses the given event channel and done\n// channel internally to deliver events and signal closure, respectively.", "docstring_tokens": ["MakeWatcher", "returns", "a", "Watcher", "that", "uses", "the", "given", "event", "channel", "and", "done", "channel", "internally", "to", "deliver", "events", "and", "signal", "closure", "respectively", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/watch/watch.go#L195-L200", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "parser/symbols.go", "func_name": "Set", "original_string": "func (l *LexSymbolSet) Set(name string, typ lex.ItemType, prio ...float32) {\n\tvar x float32\n\tif len(prio) < 1 {\n\t\tx = 1.0\n\t} else {\n\t\tx = prio[0]\n\t}\n\tl.Map[name] = LexSymbol{name, typ, x}\n\tl.SortedList = nil // reset\n}", "language": "go", "code": "func (l *LexSymbolSet) Set(name string, typ lex.ItemType, prio ...float32) {\n\tvar x float32\n\tif len(prio) < 1 {\n\t\tx = 1.0\n\t} else {\n\t\tx = prio[0]\n\t}\n\tl.Map[name] = LexSymbol{name, typ, x}\n\tl.SortedList = nil // reset\n}", "code_tokens": ["func", "(", "l", "*", "LexSymbolSet", ")", "Set", "(", "name", "string", ",", "typ", "lex", ".", "ItemType", ",", "prio", "...", "float32", ")", "{", "var", "x", "float32", "\n", "if", "len", "(", "prio", ")", "<", "1", "{", "x", "=", "1.0", "\n", "}", "else", "{", "x", "=", "prio", "[", "0", "]", "\n", "}", "\n", "l", ".", "Map", "[", "name", "]", "=", "LexSymbol", "{", "name", ",", "typ", ",", "x", "}", "\n", "l", ".", "SortedList", "=", "nil", "// reset", "\n", "}"], "docstring": "// Set creates and sets a new LexItem to `name`", "docstring_tokens": ["Set", "creates", "and", "sets", "a", "new", "LexItem", "to", "name"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/parser/symbols.go#L90-L99", "partition": "test"}
{"repo": "urandom/handler", "path": "lang/i18n.go", "func_name": "Session", "original_string": "func Session(s handler.Session) Option {\n\treturn Option{func(o *options) {\n\t\to.session = s\n\t}}\n}", "language": "go", "code": "func Session(s handler.Session) Option {\n\treturn Option{func(o *options) {\n\t\to.session = s\n\t}}\n}", "code_tokens": ["func", "Session", "(", "s", "handler", ".", "Session", ")", "Option", "{", "return", "Option", "{", "func", "(", "o", "*", "options", ")", "{", "o", ".", "session", "=", "s", "\n", "}", "}", "\n", "}"], "docstring": "// Session will be used to set the current language.", "docstring_tokens": ["Session", "will", "be", "used", "to", "set", "the", "current", "language", "."], "sha": "61508044a5569d1609521d81e81f6737567fd104", "url": "https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/lang/i18n.go#L35-L39", "partition": "test"}
{"repo": "qor/action_bar", "path": "controller.go", "func_name": "InlineEdit", "original_string": "func (controller) InlineEdit(context *admin.Context) {\n\tcontext.Writer.Write([]byte(context.Render(\"action_bar/inline_edit\")))\n}", "language": "go", "code": "func (controller) InlineEdit(context *admin.Context) {\n\tcontext.Writer.Write([]byte(context.Render(\"action_bar/inline_edit\")))\n}", "code_tokens": ["func", "(", "controller", ")", "InlineEdit", "(", "context", "*", "admin", ".", "Context", ")", "{", "context", ".", "Writer", ".", "Write", "(", "[", "]", "byte", "(", "context", ".", "Render", "(", "\"", "\"", ")", ")", ")", "\n", "}"], "docstring": "// InlineEdit using to make inline edit resource shown as slideout", "docstring_tokens": ["InlineEdit", "using", "to", "make", "inline", "edit", "resource", "shown", "as", "slideout"], "sha": "136e5e2c5b8c50976dc39edddf523fcaab0a73b8", "url": "https://github.com/qor/action_bar/blob/136e5e2c5b8c50976dc39edddf523fcaab0a73b8/controller.go#L27-L29", "partition": "test"}
{"repo": "drone/drone-plugin-go", "path": "plugin/param.go", "func_name": "deprecated_init", "original_string": "func deprecated_init() {\n\t// if piping from stdin we can just exit\n\t// and use the default Stdin value\n\tstat, _ := os.Stdin.Stat()\n\tif (stat.Mode() & os.ModeCharDevice) == 0 {\n\t\treturn\n\t}\n\n\t// check for params after the double dash\n\t// in the command string\n\tfor i, argv := range os.Args {\n\t\tif argv == \"--\" {\n\t\t\targ := os.Args[i+1]\n\t\t\tbuf := bytes.NewBufferString(arg)\n\t\t\tStdin = NewParamSet(buf)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// else use the first variable in the list\n\tif len(os.Args) > 1 {\n\t\tbuf := bytes.NewBufferString(os.Args[1])\n\t\tStdin = NewParamSet(buf)\n\t}\n}", "language": "go", "code": "func deprecated_init() {\n\t// if piping from stdin we can just exit\n\t// and use the default Stdin value\n\tstat, _ := os.Stdin.Stat()\n\tif (stat.Mode() & os.ModeCharDevice) == 0 {\n\t\treturn\n\t}\n\n\t// check for params after the double dash\n\t// in the command string\n\tfor i, argv := range os.Args {\n\t\tif argv == \"--\" {\n\t\t\targ := os.Args[i+1]\n\t\t\tbuf := bytes.NewBufferString(arg)\n\t\t\tStdin = NewParamSet(buf)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// else use the first variable in the list\n\tif len(os.Args) > 1 {\n\t\tbuf := bytes.NewBufferString(os.Args[1])\n\t\tStdin = NewParamSet(buf)\n\t}\n}", "code_tokens": ["func", "deprecated_init", "(", ")", "{", "// if piping from stdin we can just exit", "// and use the default Stdin value", "stat", ",", "_", ":=", "os", ".", "Stdin", ".", "Stat", "(", ")", "\n", "if", "(", "stat", ".", "Mode", "(", ")", "&", "os", ".", "ModeCharDevice", ")", "==", "0", "{", "return", "\n", "}", "\n\n", "// check for params after the double dash", "// in the command string", "for", "i", ",", "argv", ":=", "range", "os", ".", "Args", "{", "if", "argv", "==", "\"", "\"", "{", "arg", ":=", "os", ".", "Args", "[", "i", "+", "1", "]", "\n", "buf", ":=", "bytes", ".", "NewBufferString", "(", "arg", ")", "\n", "Stdin", "=", "NewParamSet", "(", "buf", ")", "\n", "return", "\n", "}", "\n", "}", "\n\n", "// else use the first variable in the list", "if", "len", "(", "os", ".", "Args", ")", ">", "1", "{", "buf", ":=", "bytes", ".", "NewBufferString", "(", "os", ".", "Args", "[", "1", "]", ")", "\n", "Stdin", "=", "NewParamSet", "(", "buf", ")", "\n", "}", "\n", "}"], "docstring": "// this init function is deprecated, but I'm keeping it\n// around just in case it proves useful in the future.", "docstring_tokens": ["this", "init", "function", "is", "deprecated", "but", "I", "m", "keeping", "it", "around", "just", "in", "case", "it", "proves", "useful", "in", "the", "future", "."], "sha": "d6109f644c5935c22620081b4c234bb2263743c7", "url": "https://github.com/drone/drone-plugin-go/blob/d6109f644c5935c22620081b4c234bb2263743c7/plugin/param.go#L31-L55", "partition": "test"}
{"repo": "urandom/handler", "path": "auth/jwt.go", "func_name": "Claimer", "original_string": "func Claimer(c func(claims *jwt.StandardClaims) jwt.Claims) TokenOpt {\n\treturn TokenOpt{func(o *options) {\n\t\to.claimer = c\n\t}}\n}", "language": "go", "code": "func Claimer(c func(claims *jwt.StandardClaims) jwt.Claims) TokenOpt {\n\treturn TokenOpt{func(o *options) {\n\t\to.claimer = c\n\t}}\n}", "code_tokens": ["func", "Claimer", "(", "c", "func", "(", "claims", "*", "jwt", ".", "StandardClaims", ")", "jwt", ".", "Claims", ")", "TokenOpt", "{", "return", "TokenOpt", "{", "func", "(", "o", "*", "options", ")", "{", "o", ".", "claimer", "=", "c", "\n", "}", "}", "\n", "}"], "docstring": "// Claimer is responsible for transforming a standard claims object into a\n// custom one.", "docstring_tokens": ["Claimer", "is", "responsible", "for", "transforming", "a", "standard", "claims", "object", "into", "a", "custom", "one", "."], "sha": "61508044a5569d1609521d81e81f6737567fd104", "url": "https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/auth/jwt.go#L78-L82", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/response.go", "func_name": "ForwardedOperationResponse", "original_string": "func ForwardedOperationResponse(project string, op *api.Operation) Response {\n\treturn &forwardedOperationResponse{\n\t\top:      op,\n\t\tproject: project,\n\t}\n}", "language": "go", "code": "func ForwardedOperationResponse(project string, op *api.Operation) Response {\n\treturn &forwardedOperationResponse{\n\t\top:      op,\n\t\tproject: project,\n\t}\n}", "code_tokens": ["func", "ForwardedOperationResponse", "(", "project", "string", ",", "op", "*", "api", ".", "Operation", ")", "Response", "{", "return", "&", "forwardedOperationResponse", "{", "op", ":", "op", ",", "project", ":", "project", ",", "}", "\n", "}"], "docstring": "// ForwardedOperationResponse creates a response that forwards the metadata of\n// an operation created on another node.", "docstring_tokens": ["ForwardedOperationResponse", "creates", "a", "response", "that", "forwards", "the", "metadata", "of", "an", "operation", "created", "on", "another", "node", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/response.go#L419-L424", "partition": "test"}
{"repo": "ipfs/go-ipfs-api", "path": "ipns.go", "func_name": "Publish", "original_string": "func (s *Shell) Publish(node string, value string) error {\n\tvar pubResp PublishResponse\n\treq := s.Request(\"name/publish\")\n\tif node != \"\" {\n\t\treq.Arguments(node)\n\t}\n\treq.Arguments(value)\n\n\treturn req.Exec(context.Background(), &pubResp)\n}", "language": "go", "code": "func (s *Shell) Publish(node string, value string) error {\n\tvar pubResp PublishResponse\n\treq := s.Request(\"name/publish\")\n\tif node != \"\" {\n\t\treq.Arguments(node)\n\t}\n\treq.Arguments(value)\n\n\treturn req.Exec(context.Background(), &pubResp)\n}", "code_tokens": ["func", "(", "s", "*", "Shell", ")", "Publish", "(", "node", "string", ",", "value", "string", ")", "error", "{", "var", "pubResp", "PublishResponse", "\n", "req", ":=", "s", ".", "Request", "(", "\"", "\"", ")", "\n", "if", "node", "!=", "\"", "\"", "{", "req", ".", "Arguments", "(", "node", ")", "\n", "}", "\n", "req", ".", "Arguments", "(", "value", ")", "\n\n", "return", "req", ".", "Exec", "(", "context", ".", "Background", "(", ")", ",", "&", "pubResp", ")", "\n", "}"], "docstring": "// Publish updates a mutable name to point to a given value", "docstring_tokens": ["Publish", "updates", "a", "mutable", "name", "to", "point", "to", "a", "given", "value"], "sha": "a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32", "url": "https://github.com/ipfs/go-ipfs-api/blob/a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32/ipns.go#L14-L23", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "lease/lessor.go", "func_name": "forever", "original_string": "func (l *Lease) forever() {\n\tl.expiryMu.Lock()\n\tdefer l.expiryMu.Unlock()\n\tl.expiry = forever\n}", "language": "go", "code": "func (l *Lease) forever() {\n\tl.expiryMu.Lock()\n\tdefer l.expiryMu.Unlock()\n\tl.expiry = forever\n}", "code_tokens": ["func", "(", "l", "*", "Lease", ")", "forever", "(", ")", "{", "l", ".", "expiryMu", ".", "Lock", "(", ")", "\n", "defer", "l", ".", "expiryMu", ".", "Unlock", "(", ")", "\n", "l", ".", "expiry", "=", "forever", "\n", "}"], "docstring": "// forever sets the expiry of lease to be forever.", "docstring_tokens": ["forever", "sets", "the", "expiry", "of", "lease", "to", "be", "forever", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/lease/lessor.go#L841-L845", "partition": "test"}
{"repo": "st3v/tracerr", "path": "tracerr.go", "func_name": "Errorf", "original_string": "func Errorf(message string, a ...interface{}) error {\n\treturn wrap(fmt.Errorf(message, a...))\n}", "language": "go", "code": "func Errorf(message string, a ...interface{}) error {\n\treturn wrap(fmt.Errorf(message, a...))\n}", "code_tokens": ["func", "Errorf", "(", "message", "string", ",", "a", "...", "interface", "{", "}", ")", "error", "{", "return", "wrap", "(", "fmt", ".", "Errorf", "(", "message", ",", "a", "...", ")", ")", "\n", "}"], "docstring": "// Errorf returns a traceable error with the given formatted message.", "docstring_tokens": ["Errorf", "returns", "a", "traceable", "error", "with", "the", "given", "formatted", "message", "."], "sha": "07f754d5ee02576c14a8272df820e8947d87e723", "url": "https://github.com/st3v/tracerr/blob/07f754d5ee02576c14a8272df820e8947d87e723/tracerr.go#L39-L41", "partition": "test"}
{"repo": "hashicorp/raft", "path": "raft.go", "func_name": "setLeader", "original_string": "func (r *Raft) setLeader(leader ServerAddress) {\n\tr.leaderLock.Lock()\n\toldLeader := r.leader\n\tr.leader = leader\n\tr.leaderLock.Unlock()\n\tif oldLeader != leader {\n\t\tr.observe(LeaderObservation{leader: leader})\n\t}\n}", "language": "go", "code": "func (r *Raft) setLeader(leader ServerAddress) {\n\tr.leaderLock.Lock()\n\toldLeader := r.leader\n\tr.leader = leader\n\tr.leaderLock.Unlock()\n\tif oldLeader != leader {\n\t\tr.observe(LeaderObservation{leader: leader})\n\t}\n}", "code_tokens": ["func", "(", "r", "*", "Raft", ")", "setLeader", "(", "leader", "ServerAddress", ")", "{", "r", ".", "leaderLock", ".", "Lock", "(", ")", "\n", "oldLeader", ":=", "r", ".", "leader", "\n", "r", ".", "leader", "=", "leader", "\n", "r", ".", "leaderLock", ".", "Unlock", "(", ")", "\n", "if", "oldLeader", "!=", "leader", "{", "r", ".", "observe", "(", "LeaderObservation", "{", "leader", ":", "leader", "}", ")", "\n", "}", "\n", "}"], "docstring": "// setLeader is used to modify the current leader of the cluster", "docstring_tokens": ["setLeader", "is", "used", "to", "modify", "the", "current", "leader", "of", "the", "cluster"], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/raft.go#L89-L97", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/query/transaction.go", "func_name": "rollback", "original_string": "func rollback(tx *sql.Tx, reason error) error {\n\terr := tx.Rollback()\n\tif err != nil {\n\t\tlogger.Warnf(\"Failed to rollback transaction after error (%v): %v\", reason, err)\n\t}\n\n\treturn reason\n}", "language": "go", "code": "func rollback(tx *sql.Tx, reason error) error {\n\terr := tx.Rollback()\n\tif err != nil {\n\t\tlogger.Warnf(\"Failed to rollback transaction after error (%v): %v\", reason, err)\n\t}\n\n\treturn reason\n}", "code_tokens": ["func", "rollback", "(", "tx", "*", "sql", ".", "Tx", ",", "reason", "error", ")", "error", "{", "err", ":=", "tx", ".", "Rollback", "(", ")", "\n", "if", "err", "!=", "nil", "{", "logger", ".", "Warnf", "(", "\"", "\"", ",", "reason", ",", "err", ")", "\n", "}", "\n\n", "return", "reason", "\n", "}"], "docstring": "// Rollback a transaction after the given error occurred. If the rollback\n// succeeds the given error is returned, otherwise a new error that wraps it\n// gets generated and returned.", "docstring_tokens": ["Rollback", "a", "transaction", "after", "the", "given", "error", "occurred", ".", "If", "the", "rollback", "succeeds", "the", "given", "error", "is", "returned", "otherwise", "a", "new", "error", "that", "wraps", "it", "gets", "generated", "and", "returned", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/query/transaction.go#L32-L39", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "ArmForSwitch", "original_string": "func (u PathPaymentResult) ArmForSwitch(sw int32) (string, bool) {\n\tswitch PathPaymentResultCode(sw) {\n\tcase PathPaymentResultCodePathPaymentSuccess:\n\t\treturn \"Success\", true\n\tcase PathPaymentResultCodePathPaymentNoIssuer:\n\t\treturn \"NoIssuer\", true\n\tdefault:\n\t\treturn \"\", true\n\t}\n}", "language": "go", "code": "func (u PathPaymentResult) ArmForSwitch(sw int32) (string, bool) {\n\tswitch PathPaymentResultCode(sw) {\n\tcase PathPaymentResultCodePathPaymentSuccess:\n\t\treturn \"Success\", true\n\tcase PathPaymentResultCodePathPaymentNoIssuer:\n\t\treturn \"NoIssuer\", true\n\tdefault:\n\t\treturn \"\", true\n\t}\n}", "code_tokens": ["func", "(", "u", "PathPaymentResult", ")", "ArmForSwitch", "(", "sw", "int32", ")", "(", "string", ",", "bool", ")", "{", "switch", "PathPaymentResultCode", "(", "sw", ")", "{", "case", "PathPaymentResultCodePathPaymentSuccess", ":", "return", "\"", "\"", ",", "true", "\n", "case", "PathPaymentResultCodePathPaymentNoIssuer", ":", "return", "\"", "\"", ",", "true", "\n", "default", ":", "return", "\"", "\"", ",", "true", "\n", "}", "\n", "}"], "docstring": "// ArmForSwitch returns which field name should be used for storing\n// the value for an instance of PathPaymentResult", "docstring_tokens": ["ArmForSwitch", "returns", "which", "field", "name", "should", "be", "used", "for", "storing", "the", "value", "for", "an", "instance", "of", "PathPaymentResult"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L2795-L2804", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "typed/buffer.go", "func_name": "Wrap", "original_string": "func (r *ReadBuffer) Wrap(b []byte) {\n\tr.buffer = b\n\tr.remaining = b\n\tr.err = nil\n}", "language": "go", "code": "func (r *ReadBuffer) Wrap(b []byte) {\n\tr.buffer = b\n\tr.remaining = b\n\tr.err = nil\n}", "code_tokens": ["func", "(", "r", "*", "ReadBuffer", ")", "Wrap", "(", "b", "[", "]", "byte", ")", "{", "r", ".", "buffer", "=", "b", "\n", "r", ".", "remaining", "=", "b", "\n", "r", ".", "err", "=", "nil", "\n", "}"], "docstring": "// Wrap initializes the buffer to read from the given byte slice", "docstring_tokens": ["Wrap", "initializes", "the", "buffer", "to", "read", "from", "the", "given", "byte", "slice"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/typed/buffer.go#L170-L174", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "language/go/fix.go", "func_name": "removeLegacyProto", "original_string": "func removeLegacyProto(c *config.Config, f *rule.File) {\n\t// Don't fix if the proto mode was set to something other than the default.\n\tif pcMode := getProtoMode(c); pcMode != proto.DefaultMode {\n\t\treturn\n\t}\n\n\t// Scan for definitions to delete.\n\tvar protoLoads []*rule.Load\n\tfor _, l := range f.Loads {\n\t\tif l.Name() == \"@io_bazel_rules_go//proto:go_proto_library.bzl\" {\n\t\t\tprotoLoads = append(protoLoads, l)\n\t\t}\n\t}\n\tvar protoFilegroups, protoRules []*rule.Rule\n\tfor _, r := range f.Rules {\n\t\tif r.Kind() == \"filegroup\" && r.Name() == legacyProtoFilegroupName {\n\t\t\tprotoFilegroups = append(protoFilegroups, r)\n\t\t}\n\t\tif r.Kind() == \"go_proto_library\" {\n\t\t\tprotoRules = append(protoRules, r)\n\t\t}\n\t}\n\tif len(protoLoads)+len(protoFilegroups) == 0 {\n\t\treturn\n\t}\n\tif !c.ShouldFix {\n\t\tlog.Printf(\"%s: go_proto_library.bzl is deprecated. Run 'gazelle fix' to replace old rules.\", f.Path)\n\t\treturn\n\t}\n\n\t// Delete legacy proto loads and filegroups. Only delete go_proto_library\n\t// rules if we deleted a load.\n\tfor _, l := range protoLoads {\n\t\tl.Delete()\n\t}\n\tfor _, r := range protoFilegroups {\n\t\tr.Delete()\n\t}\n\tif len(protoLoads) > 0 {\n\t\tfor _, r := range protoRules {\n\t\t\tr.Delete()\n\t\t}\n\t}\n}", "language": "go", "code": "func removeLegacyProto(c *config.Config, f *rule.File) {\n\t// Don't fix if the proto mode was set to something other than the default.\n\tif pcMode := getProtoMode(c); pcMode != proto.DefaultMode {\n\t\treturn\n\t}\n\n\t// Scan for definitions to delete.\n\tvar protoLoads []*rule.Load\n\tfor _, l := range f.Loads {\n\t\tif l.Name() == \"@io_bazel_rules_go//proto:go_proto_library.bzl\" {\n\t\t\tprotoLoads = append(protoLoads, l)\n\t\t}\n\t}\n\tvar protoFilegroups, protoRules []*rule.Rule\n\tfor _, r := range f.Rules {\n\t\tif r.Kind() == \"filegroup\" && r.Name() == legacyProtoFilegroupName {\n\t\t\tprotoFilegroups = append(protoFilegroups, r)\n\t\t}\n\t\tif r.Kind() == \"go_proto_library\" {\n\t\t\tprotoRules = append(protoRules, r)\n\t\t}\n\t}\n\tif len(protoLoads)+len(protoFilegroups) == 0 {\n\t\treturn\n\t}\n\tif !c.ShouldFix {\n\t\tlog.Printf(\"%s: go_proto_library.bzl is deprecated. Run 'gazelle fix' to replace old rules.\", f.Path)\n\t\treturn\n\t}\n\n\t// Delete legacy proto loads and filegroups. Only delete go_proto_library\n\t// rules if we deleted a load.\n\tfor _, l := range protoLoads {\n\t\tl.Delete()\n\t}\n\tfor _, r := range protoFilegroups {\n\t\tr.Delete()\n\t}\n\tif len(protoLoads) > 0 {\n\t\tfor _, r := range protoRules {\n\t\t\tr.Delete()\n\t\t}\n\t}\n}", "code_tokens": ["func", "removeLegacyProto", "(", "c", "*", "config", ".", "Config", ",", "f", "*", "rule", ".", "File", ")", "{", "// Don't fix if the proto mode was set to something other than the default.", "if", "pcMode", ":=", "getProtoMode", "(", "c", ")", ";", "pcMode", "!=", "proto", ".", "DefaultMode", "{", "return", "\n", "}", "\n\n", "// Scan for definitions to delete.", "var", "protoLoads", "[", "]", "*", "rule", ".", "Load", "\n", "for", "_", ",", "l", ":=", "range", "f", ".", "Loads", "{", "if", "l", ".", "Name", "(", ")", "==", "\"", "\"", "{", "protoLoads", "=", "append", "(", "protoLoads", ",", "l", ")", "\n", "}", "\n", "}", "\n", "var", "protoFilegroups", ",", "protoRules", "[", "]", "*", "rule", ".", "Rule", "\n", "for", "_", ",", "r", ":=", "range", "f", ".", "Rules", "{", "if", "r", ".", "Kind", "(", ")", "==", "\"", "\"", "&&", "r", ".", "Name", "(", ")", "==", "legacyProtoFilegroupName", "{", "protoFilegroups", "=", "append", "(", "protoFilegroups", ",", "r", ")", "\n", "}", "\n", "if", "r", ".", "Kind", "(", ")", "==", "\"", "\"", "{", "protoRules", "=", "append", "(", "protoRules", ",", "r", ")", "\n", "}", "\n", "}", "\n", "if", "len", "(", "protoLoads", ")", "+", "len", "(", "protoFilegroups", ")", "==", "0", "{", "return", "\n", "}", "\n", "if", "!", "c", ".", "ShouldFix", "{", "log", ".", "Printf", "(", "\"", "\"", ",", "f", ".", "Path", ")", "\n", "return", "\n", "}", "\n\n", "// Delete legacy proto loads and filegroups. Only delete go_proto_library", "// rules if we deleted a load.", "for", "_", ",", "l", ":=", "range", "protoLoads", "{", "l", ".", "Delete", "(", ")", "\n", "}", "\n", "for", "_", ",", "r", ":=", "range", "protoFilegroups", "{", "r", ".", "Delete", "(", ")", "\n", "}", "\n", "if", "len", "(", "protoLoads", ")", ">", "0", "{", "for", "_", ",", "r", ":=", "range", "protoRules", "{", "r", ".", "Delete", "(", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// removeLegacyProto removes uses of the old proto rules. It deletes loads\n// from go_proto_library.bzl. It deletes proto filegroups. It removes\n// go_proto_library attributes which are no longer recognized. New rules\n// are generated in place of the deleted rules, but attributes and comments\n// are not migrated.", "docstring_tokens": ["removeLegacyProto", "removes", "uses", "of", "the", "old", "proto", "rules", ".", "It", "deletes", "loads", "from", "go_proto_library", ".", "bzl", ".", "It", "deletes", "proto", "filegroups", ".", "It", "removes", "go_proto_library", "attributes", "which", "are", "no", "longer", "recognized", ".", "New", "rules", "are", "generated", "in", "place", "of", "the", "deleted", "rules", "but", "attributes", "and", "comments", "are", "not", "migrated", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/language/go/fix.go#L188-L231", "partition": "test"}
{"repo": "kljensen/snowball", "path": "english/common.go", "func_name": "stemSpecialWord", "original_string": "func stemSpecialWord(word string) (stemmed string) {\n\tswitch word {\n\tcase \"skis\":\n\t\tstemmed = \"ski\"\n\tcase \"skies\":\n\t\tstemmed = \"sky\"\n\tcase \"dying\":\n\t\tstemmed = \"die\"\n\tcase \"lying\":\n\t\tstemmed = \"lie\"\n\tcase \"tying\":\n\t\tstemmed = \"tie\"\n\tcase \"idly\":\n\t\tstemmed = \"idl\"\n\tcase \"gently\":\n\t\tstemmed = \"gentl\"\n\tcase \"ugly\":\n\t\tstemmed = \"ugli\"\n\tcase \"early\":\n\t\tstemmed = \"earli\"\n\tcase \"only\":\n\t\tstemmed = \"onli\"\n\tcase \"singly\":\n\t\tstemmed = \"singl\"\n\tcase \"sky\":\n\t\tstemmed = \"sky\"\n\tcase \"news\":\n\t\tstemmed = \"news\"\n\tcase \"howe\":\n\t\tstemmed = \"howe\"\n\tcase \"atlas\":\n\t\tstemmed = \"atlas\"\n\tcase \"cosmos\":\n\t\tstemmed = \"cosmos\"\n\tcase \"bias\":\n\t\tstemmed = \"bias\"\n\tcase \"andes\":\n\t\tstemmed = \"andes\"\n\tcase \"inning\":\n\t\tstemmed = \"inning\"\n\tcase \"innings\":\n\t\tstemmed = \"inning\"\n\tcase \"outing\":\n\t\tstemmed = \"outing\"\n\tcase \"outings\":\n\t\tstemmed = \"outing\"\n\tcase \"canning\":\n\t\tstemmed = \"canning\"\n\tcase \"cannings\":\n\t\tstemmed = \"canning\"\n\tcase \"herring\":\n\t\tstemmed = \"herring\"\n\tcase \"herrings\":\n\t\tstemmed = \"herring\"\n\tcase \"earring\":\n\t\tstemmed = \"earring\"\n\tcase \"earrings\":\n\t\tstemmed = \"earring\"\n\tcase \"proceed\":\n\t\tstemmed = \"proceed\"\n\tcase \"proceeds\":\n\t\tstemmed = \"proceed\"\n\tcase \"proceeded\":\n\t\tstemmed = \"proceed\"\n\tcase \"proceeding\":\n\t\tstemmed = \"proceed\"\n\tcase \"exceed\":\n\t\tstemmed = \"exceed\"\n\tcase \"exceeds\":\n\t\tstemmed = \"exceed\"\n\tcase \"exceeded\":\n\t\tstemmed = \"exceed\"\n\tcase \"exceeding\":\n\t\tstemmed = \"exceed\"\n\tcase \"succeed\":\n\t\tstemmed = \"succeed\"\n\tcase \"succeeds\":\n\t\tstemmed = \"succeed\"\n\tcase \"succeeded\":\n\t\tstemmed = \"succeed\"\n\tcase \"succeeding\":\n\t\tstemmed = \"succeed\"\n\t}\n\treturn\n}", "language": "go", "code": "func stemSpecialWord(word string) (stemmed string) {\n\tswitch word {\n\tcase \"skis\":\n\t\tstemmed = \"ski\"\n\tcase \"skies\":\n\t\tstemmed = \"sky\"\n\tcase \"dying\":\n\t\tstemmed = \"die\"\n\tcase \"lying\":\n\t\tstemmed = \"lie\"\n\tcase \"tying\":\n\t\tstemmed = \"tie\"\n\tcase \"idly\":\n\t\tstemmed = \"idl\"\n\tcase \"gently\":\n\t\tstemmed = \"gentl\"\n\tcase \"ugly\":\n\t\tstemmed = \"ugli\"\n\tcase \"early\":\n\t\tstemmed = \"earli\"\n\tcase \"only\":\n\t\tstemmed = \"onli\"\n\tcase \"singly\":\n\t\tstemmed = \"singl\"\n\tcase \"sky\":\n\t\tstemmed = \"sky\"\n\tcase \"news\":\n\t\tstemmed = \"news\"\n\tcase \"howe\":\n\t\tstemmed = \"howe\"\n\tcase \"atlas\":\n\t\tstemmed = \"atlas\"\n\tcase \"cosmos\":\n\t\tstemmed = \"cosmos\"\n\tcase \"bias\":\n\t\tstemmed = \"bias\"\n\tcase \"andes\":\n\t\tstemmed = \"andes\"\n\tcase \"inning\":\n\t\tstemmed = \"inning\"\n\tcase \"innings\":\n\t\tstemmed = \"inning\"\n\tcase \"outing\":\n\t\tstemmed = \"outing\"\n\tcase \"outings\":\n\t\tstemmed = \"outing\"\n\tcase \"canning\":\n\t\tstemmed = \"canning\"\n\tcase \"cannings\":\n\t\tstemmed = \"canning\"\n\tcase \"herring\":\n\t\tstemmed = \"herring\"\n\tcase \"herrings\":\n\t\tstemmed = \"herring\"\n\tcase \"earring\":\n\t\tstemmed = \"earring\"\n\tcase \"earrings\":\n\t\tstemmed = \"earring\"\n\tcase \"proceed\":\n\t\tstemmed = \"proceed\"\n\tcase \"proceeds\":\n\t\tstemmed = \"proceed\"\n\tcase \"proceeded\":\n\t\tstemmed = \"proceed\"\n\tcase \"proceeding\":\n\t\tstemmed = \"proceed\"\n\tcase \"exceed\":\n\t\tstemmed = \"exceed\"\n\tcase \"exceeds\":\n\t\tstemmed = \"exceed\"\n\tcase \"exceeded\":\n\t\tstemmed = \"exceed\"\n\tcase \"exceeding\":\n\t\tstemmed = \"exceed\"\n\tcase \"succeed\":\n\t\tstemmed = \"succeed\"\n\tcase \"succeeds\":\n\t\tstemmed = \"succeed\"\n\tcase \"succeeded\":\n\t\tstemmed = \"succeed\"\n\tcase \"succeeding\":\n\t\tstemmed = \"succeed\"\n\t}\n\treturn\n}", "code_tokens": ["func", "stemSpecialWord", "(", "word", "string", ")", "(", "stemmed", "string", ")", "{", "switch", "word", "{", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "case", "\"", "\"", ":", "stemmed", "=", "\"", "\"", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// Returns the stemmed version of a word if it is a special\n// case, otherwise returns the empty string.\n//", "docstring_tokens": ["Returns", "the", "stemmed", "version", "of", "a", "word", "if", "it", "is", "a", "special", "case", "otherwise", "returns", "the", "empty", "string", "."], "sha": "115fa8f6419dcfb9ec4653997b1c6803a5eff962", "url": "https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/english/common.go#L118-L202", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/node/open.go", "func_name": "EnsureSchema", "original_string": "func EnsureSchema(db *sql.DB, dir string, hook schema.Hook) (int, error) {\n\tbackupDone := false\n\n\tschema := Schema()\n\tschema.File(filepath.Join(dir, \"patch.local.sql\")) // Optional custom queries\n\tschema.Hook(func(version int, tx *sql.Tx) error {\n\t\tif !backupDone {\n\t\t\tlogger.Infof(\"Updating the LXD database schema. Backup made as \\\"local.db.bak\\\"\")\n\t\t\tpath := filepath.Join(dir, \"local.db\")\n\t\t\terr := shared.FileCopy(path, path+\".bak\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tbackupDone = true\n\t\t}\n\n\t\tif version == -1 {\n\t\t\tlogger.Debugf(\"Running pre-update queries from file for local DB schema\")\n\t\t} else {\n\t\t\tlogger.Debugf(\"Updating DB schema from %d to %d\", version, version+1)\n\t\t}\n\n\t\t// Run the given hook only against actual update versions, not\n\t\t// when a custom query file is passed (signaled by version == -1).\n\t\tif hook != nil && version != -1 {\n\t\t\terr := hook(version, tx)\n\t\t\tif err != nil {\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\treturn schema.Ensure(db)\n}", "language": "go", "code": "func EnsureSchema(db *sql.DB, dir string, hook schema.Hook) (int, error) {\n\tbackupDone := false\n\n\tschema := Schema()\n\tschema.File(filepath.Join(dir, \"patch.local.sql\")) // Optional custom queries\n\tschema.Hook(func(version int, tx *sql.Tx) error {\n\t\tif !backupDone {\n\t\t\tlogger.Infof(\"Updating the LXD database schema. Backup made as \\\"local.db.bak\\\"\")\n\t\t\tpath := filepath.Join(dir, \"local.db\")\n\t\t\terr := shared.FileCopy(path, path+\".bak\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tbackupDone = true\n\t\t}\n\n\t\tif version == -1 {\n\t\t\tlogger.Debugf(\"Running pre-update queries from file for local DB schema\")\n\t\t} else {\n\t\t\tlogger.Debugf(\"Updating DB schema from %d to %d\", version, version+1)\n\t\t}\n\n\t\t// Run the given hook only against actual update versions, not\n\t\t// when a custom query file is passed (signaled by version == -1).\n\t\tif hook != nil && version != -1 {\n\t\t\terr := hook(version, tx)\n\t\t\tif err != nil {\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\treturn schema.Ensure(db)\n}", "code_tokens": ["func", "EnsureSchema", "(", "db", "*", "sql", ".", "DB", ",", "dir", "string", ",", "hook", "schema", ".", "Hook", ")", "(", "int", ",", "error", ")", "{", "backupDone", ":=", "false", "\n\n", "schema", ":=", "Schema", "(", ")", "\n", "schema", ".", "File", "(", "filepath", ".", "Join", "(", "dir", ",", "\"", "\"", ")", ")", "// Optional custom queries", "\n", "schema", ".", "Hook", "(", "func", "(", "version", "int", ",", "tx", "*", "sql", ".", "Tx", ")", "error", "{", "if", "!", "backupDone", "{", "logger", ".", "Infof", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "path", ":=", "filepath", ".", "Join", "(", "dir", ",", "\"", "\"", ")", "\n", "err", ":=", "shared", ".", "FileCopy", "(", "path", ",", "path", "+", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "backupDone", "=", "true", "\n", "}", "\n\n", "if", "version", "==", "-", "1", "{", "logger", ".", "Debugf", "(", "\"", "\"", ")", "\n", "}", "else", "{", "logger", ".", "Debugf", "(", "\"", "\"", ",", "version", ",", "version", "+", "1", ")", "\n", "}", "\n\n", "// Run the given hook only against actual update versions, not", "// when a custom query file is passed (signaled by version == -1).", "if", "hook", "!=", "nil", "&&", "version", "!=", "-", "1", "{", "err", ":=", "hook", "(", "version", ",", "tx", ")", "\n", "if", "err", "!=", "nil", "{", "}", "\n", "}", "\n\n", "return", "nil", "\n", "}", ")", "\n", "return", "schema", ".", "Ensure", "(", "db", ")", "\n", "}"], "docstring": "// EnsureSchema applies all relevant schema updates to the node-local\n// database.\n//\n// Return the initial schema version found before starting the update, along\n// with any error occurred.", "docstring_tokens": ["EnsureSchema", "applies", "all", "relevant", "schema", "updates", "to", "the", "node", "-", "local", "database", ".", "Return", "the", "initial", "schema", "version", "found", "before", "starting", "the", "update", "along", "with", "any", "error", "occurred", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/node/open.go#L29-L63", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/query/retry.go", "func_name": "IsRetriableError", "original_string": "func IsRetriableError(err error) bool {\n\terr = errors.Cause(err)\n\n\tif err == nil {\n\t\treturn false\n\t}\n\tif err == sqlite3.ErrLocked || err == sqlite3.ErrBusy {\n\t\treturn true\n\t}\n\n\tif strings.Contains(err.Error(), \"database is locked\") {\n\t\treturn true\n\t}\n\tif strings.Contains(err.Error(), \"bad connection\") {\n\t\treturn true\n\t}\n\n\t// Despite the description this is usually a lost leadership error.\n\tif strings.Contains(err.Error(), \"disk I/O error\") {\n\t\treturn true\n\t}\n\n\treturn false\n}", "language": "go", "code": "func IsRetriableError(err error) bool {\n\terr = errors.Cause(err)\n\n\tif err == nil {\n\t\treturn false\n\t}\n\tif err == sqlite3.ErrLocked || err == sqlite3.ErrBusy {\n\t\treturn true\n\t}\n\n\tif strings.Contains(err.Error(), \"database is locked\") {\n\t\treturn true\n\t}\n\tif strings.Contains(err.Error(), \"bad connection\") {\n\t\treturn true\n\t}\n\n\t// Despite the description this is usually a lost leadership error.\n\tif strings.Contains(err.Error(), \"disk I/O error\") {\n\t\treturn true\n\t}\n\n\treturn false\n}", "code_tokens": ["func", "IsRetriableError", "(", "err", "error", ")", "bool", "{", "err", "=", "errors", ".", "Cause", "(", "err", ")", "\n\n", "if", "err", "==", "nil", "{", "return", "false", "\n", "}", "\n", "if", "err", "==", "sqlite3", ".", "ErrLocked", "||", "err", "==", "sqlite3", ".", "ErrBusy", "{", "return", "true", "\n", "}", "\n\n", "if", "strings", ".", "Contains", "(", "err", ".", "Error", "(", ")", ",", "\"", "\"", ")", "{", "return", "true", "\n", "}", "\n", "if", "strings", ".", "Contains", "(", "err", ".", "Error", "(", ")", ",", "\"", "\"", ")", "{", "return", "true", "\n", "}", "\n\n", "// Despite the description this is usually a lost leadership error.", "if", "strings", ".", "Contains", "(", "err", ".", "Error", "(", ")", ",", "\"", "\"", ")", "{", "return", "true", "\n", "}", "\n\n", "return", "false", "\n", "}"], "docstring": "// IsRetriableError returns true if the given error might be transient and the\n// interaction can be safely retried.", "docstring_tokens": ["IsRetriableError", "returns", "true", "if", "the", "given", "error", "might", "be", "transient", "and", "the", "interaction", "can", "be", "safely", "retried", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/query/retry.go#L37-L60", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/statusreconciler/controller.go", "func_name": "NewController", "original_string": "func NewController(continueOnError bool, addedPresubmitBlacklist sets.String, prowJobClient prowv1.ProwJobInterface, githubClient *github.Client, configAgent *config.Agent, pluginAgent *plugins.ConfigAgent) *Controller {\n\treturn &Controller{\n\t\tcontinueOnError:         continueOnError,\n\t\taddedPresubmitBlacklist: addedPresubmitBlacklist,\n\t\tprowJobTriggerer: &kubeProwJobTriggerer{\n\t\t\tprowJobClient: prowJobClient,\n\t\t\tgithubClient:  githubClient,\n\t\t\tconfigAgent:   configAgent,\n\t\t},\n\t\tgithubClient: githubClient,\n\t\tstatusMigrator: &gitHubMigrator{\n\t\t\tgithubClient:    githubClient,\n\t\t\tcontinueOnError: continueOnError,\n\t\t},\n\t\ttrustedChecker: &githubTrustedChecker{\n\t\t\tgithubClient: githubClient,\n\t\t\tpluginAgent:  pluginAgent,\n\t\t},\n\t}\n}", "language": "go", "code": "func NewController(continueOnError bool, addedPresubmitBlacklist sets.String, prowJobClient prowv1.ProwJobInterface, githubClient *github.Client, configAgent *config.Agent, pluginAgent *plugins.ConfigAgent) *Controller {\n\treturn &Controller{\n\t\tcontinueOnError:         continueOnError,\n\t\taddedPresubmitBlacklist: addedPresubmitBlacklist,\n\t\tprowJobTriggerer: &kubeProwJobTriggerer{\n\t\t\tprowJobClient: prowJobClient,\n\t\t\tgithubClient:  githubClient,\n\t\t\tconfigAgent:   configAgent,\n\t\t},\n\t\tgithubClient: githubClient,\n\t\tstatusMigrator: &gitHubMigrator{\n\t\t\tgithubClient:    githubClient,\n\t\t\tcontinueOnError: continueOnError,\n\t\t},\n\t\ttrustedChecker: &githubTrustedChecker{\n\t\t\tgithubClient: githubClient,\n\t\t\tpluginAgent:  pluginAgent,\n\t\t},\n\t}\n}", "code_tokens": ["func", "NewController", "(", "continueOnError", "bool", ",", "addedPresubmitBlacklist", "sets", ".", "String", ",", "prowJobClient", "prowv1", ".", "ProwJobInterface", ",", "githubClient", "*", "github", ".", "Client", ",", "configAgent", "*", "config", ".", "Agent", ",", "pluginAgent", "*", "plugins", ".", "ConfigAgent", ")", "*", "Controller", "{", "return", "&", "Controller", "{", "continueOnError", ":", "continueOnError", ",", "addedPresubmitBlacklist", ":", "addedPresubmitBlacklist", ",", "prowJobTriggerer", ":", "&", "kubeProwJobTriggerer", "{", "prowJobClient", ":", "prowJobClient", ",", "githubClient", ":", "githubClient", ",", "configAgent", ":", "configAgent", ",", "}", ",", "githubClient", ":", "githubClient", ",", "statusMigrator", ":", "&", "gitHubMigrator", "{", "githubClient", ":", "githubClient", ",", "continueOnError", ":", "continueOnError", ",", "}", ",", "trustedChecker", ":", "&", "githubTrustedChecker", "{", "githubClient", ":", "githubClient", ",", "pluginAgent", ":", "pluginAgent", ",", "}", ",", "}", "\n", "}"], "docstring": "// NewController constructs a new controller to reconcile stauses on config change", "docstring_tokens": ["NewController", "constructs", "a", "new", "controller", "to", "reconcile", "stauses", "on", "config", "change"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/statusreconciler/controller.go#L38-L57", "partition": "test"}
{"repo": "rightscale/rsc", "path": "gen/praxisgen/api_analyzer.go", "func_name": "FinalizeTypeNames", "original_string": "func (reg *TypeRegistry) FinalizeTypeNames(d *gen.APIDescriptor) {\n\tfor n, named := range reg.NamedTypes {\n\t\treg.InlineTypes[n] = append(reg.InlineTypes[n], named)\n\t}\n\td.FinalizeTypeNames(reg.InlineTypes)\n}", "language": "go", "code": "func (reg *TypeRegistry) FinalizeTypeNames(d *gen.APIDescriptor) {\n\tfor n, named := range reg.NamedTypes {\n\t\treg.InlineTypes[n] = append(reg.InlineTypes[n], named)\n\t}\n\td.FinalizeTypeNames(reg.InlineTypes)\n}", "code_tokens": ["func", "(", "reg", "*", "TypeRegistry", ")", "FinalizeTypeNames", "(", "d", "*", "gen", ".", "APIDescriptor", ")", "{", "for", "n", ",", "named", ":=", "range", "reg", ".", "NamedTypes", "{", "reg", ".", "InlineTypes", "[", "n", "]", "=", "append", "(", "reg", ".", "InlineTypes", "[", "n", "]", ",", "named", ")", "\n", "}", "\n", "d", ".", "FinalizeTypeNames", "(", "reg", ".", "InlineTypes", ")", "\n", "}"], "docstring": "// FinalizeTypeNames makes sure type names are unique, it should be called after analysis\n// has completed.", "docstring_tokens": ["FinalizeTypeNames", "makes", "sure", "type", "names", "are", "unique", "it", "should", "be", "called", "after", "analysis", "has", "completed", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/praxisgen/api_analyzer.go#L116-L121", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "target/target.go", "func_name": "Do", "original_string": "func (p *SendMessageToTargetParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSendMessageToTarget, p, nil)\n}", "language": "go", "code": "func (p *SendMessageToTargetParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSendMessageToTarget, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SendMessageToTargetParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSendMessageToTarget", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Target.sendMessageToTarget against the provided context.", "docstring_tokens": ["Do", "executes", "Target", ".", "sendMessageToTarget", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/target/target.go#L470-L472", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/container_lxc.go", "func_name": "getLxcState", "original_string": "func (c *containerLXC) getLxcState() (lxc.State, error) {\n\tif c.IsSnapshot() {\n\t\treturn lxc.StateMap[\"STOPPED\"], nil\n\t}\n\n\t// Load the go-lxc struct\n\terr := c.initLXC(false)\n\tif err != nil {\n\t\treturn lxc.StateMap[\"STOPPED\"], err\n\t}\n\n\tmonitor := make(chan lxc.State, 1)\n\n\tgo func(c *lxc.Container) {\n\t\tmonitor <- c.State()\n\t}(c.c)\n\n\tselect {\n\tcase state := <-monitor:\n\t\treturn state, nil\n\tcase <-time.After(5 * time.Second):\n\t\treturn lxc.StateMap[\"FROZEN\"], LxcMonitorStateError\n\t}\n}", "language": "go", "code": "func (c *containerLXC) getLxcState() (lxc.State, error) {\n\tif c.IsSnapshot() {\n\t\treturn lxc.StateMap[\"STOPPED\"], nil\n\t}\n\n\t// Load the go-lxc struct\n\terr := c.initLXC(false)\n\tif err != nil {\n\t\treturn lxc.StateMap[\"STOPPED\"], err\n\t}\n\n\tmonitor := make(chan lxc.State, 1)\n\n\tgo func(c *lxc.Container) {\n\t\tmonitor <- c.State()\n\t}(c.c)\n\n\tselect {\n\tcase state := <-monitor:\n\t\treturn state, nil\n\tcase <-time.After(5 * time.Second):\n\t\treturn lxc.StateMap[\"FROZEN\"], LxcMonitorStateError\n\t}\n}", "code_tokens": ["func", "(", "c", "*", "containerLXC", ")", "getLxcState", "(", ")", "(", "lxc", ".", "State", ",", "error", ")", "{", "if", "c", ".", "IsSnapshot", "(", ")", "{", "return", "lxc", ".", "StateMap", "[", "\"", "\"", "]", ",", "nil", "\n", "}", "\n\n", "// Load the go-lxc struct", "err", ":=", "c", ".", "initLXC", "(", "false", ")", "\n", "if", "err", "!=", "nil", "{", "return", "lxc", ".", "StateMap", "[", "\"", "\"", "]", ",", "err", "\n", "}", "\n\n", "monitor", ":=", "make", "(", "chan", "lxc", ".", "State", ",", "1", ")", "\n\n", "go", "func", "(", "c", "*", "lxc", ".", "Container", ")", "{", "monitor", "<-", "c", ".", "State", "(", ")", "\n", "}", "(", "c", ".", "c", ")", "\n\n", "select", "{", "case", "state", ":=", "<-", "monitor", ":", "return", "state", ",", "nil", "\n", "case", "<-", "time", ".", "After", "(", "5", "*", "time", ".", "Second", ")", ":", "return", "lxc", ".", "StateMap", "[", "\"", "\"", "]", ",", "LxcMonitorStateError", "\n", "}", "\n", "}"], "docstring": "// Get lxc container state, with 1 second timeout\n// If we don't get a reply, assume the lxc monitor is hung", "docstring_tokens": ["Get", "lxc", "container", "state", "with", "1", "second", "timeout", "If", "we", "don", "t", "get", "a", "reply", "assume", "the", "lxc", "monitor", "is", "hung"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/container_lxc.go#L3149-L3172", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "build/transaction.go", "func_name": "MutateTransaction", "original_string": "func (m MemoReturn) MutateTransaction(o *TransactionBuilder) (err error) {\n\to.TX.Memo, err = xdr.NewMemo(xdr.MemoTypeMemoReturn, m.Value)\n\treturn\n}", "language": "go", "code": "func (m MemoReturn) MutateTransaction(o *TransactionBuilder) (err error) {\n\to.TX.Memo, err = xdr.NewMemo(xdr.MemoTypeMemoReturn, m.Value)\n\treturn\n}", "code_tokens": ["func", "(", "m", "MemoReturn", ")", "MutateTransaction", "(", "o", "*", "TransactionBuilder", ")", "(", "err", "error", ")", "{", "o", ".", "TX", ".", "Memo", ",", "err", "=", "xdr", ".", "NewMemo", "(", "xdr", ".", "MemoTypeMemoReturn", ",", "m", ".", "Value", ")", "\n", "return", "\n", "}"], "docstring": "// MutateTransaction for MemoReturn sets the memo.", "docstring_tokens": ["MutateTransaction", "for", "MemoReturn", "sets", "the", "memo", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/transaction.go#L241-L244", "partition": "test"}
{"repo": "containers/image", "path": "oci/archive/oci_src.go", "func_name": "newImageSource", "original_string": "func newImageSource(ctx context.Context, sys *types.SystemContext, ref ociArchiveReference) (types.ImageSource, error) {\n\ttempDirRef, err := createUntarTempDir(ref)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"error creating temp directory\")\n\t}\n\n\tunpackedSrc, err := tempDirRef.ociRefExtracted.NewImageSource(ctx, sys)\n\tif err != nil {\n\t\tif err := tempDirRef.deleteTempDir(); err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error deleting temp directory %q\", tempDirRef.tempDirectory)\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &ociArchiveImageSource{ref: ref,\n\t\tunpackedSrc: unpackedSrc,\n\t\ttempDirRef:  tempDirRef}, nil\n}", "language": "go", "code": "func newImageSource(ctx context.Context, sys *types.SystemContext, ref ociArchiveReference) (types.ImageSource, error) {\n\ttempDirRef, err := createUntarTempDir(ref)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"error creating temp directory\")\n\t}\n\n\tunpackedSrc, err := tempDirRef.ociRefExtracted.NewImageSource(ctx, sys)\n\tif err != nil {\n\t\tif err := tempDirRef.deleteTempDir(); err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error deleting temp directory %q\", tempDirRef.tempDirectory)\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &ociArchiveImageSource{ref: ref,\n\t\tunpackedSrc: unpackedSrc,\n\t\ttempDirRef:  tempDirRef}, nil\n}", "code_tokens": ["func", "newImageSource", "(", "ctx", "context", ".", "Context", ",", "sys", "*", "types", ".", "SystemContext", ",", "ref", "ociArchiveReference", ")", "(", "types", ".", "ImageSource", ",", "error", ")", "{", "tempDirRef", ",", "err", ":=", "createUntarTempDir", "(", "ref", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n\n", "unpackedSrc", ",", "err", ":=", "tempDirRef", ".", "ociRefExtracted", ".", "NewImageSource", "(", "ctx", ",", "sys", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", ":=", "tempDirRef", ".", "deleteTempDir", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ",", "tempDirRef", ".", "tempDirectory", ")", "\n", "}", "\n", "return", "nil", ",", "err", "\n", "}", "\n", "return", "&", "ociArchiveImageSource", "{", "ref", ":", "ref", ",", "unpackedSrc", ":", "unpackedSrc", ",", "tempDirRef", ":", "tempDirRef", "}", ",", "nil", "\n", "}"], "docstring": "// newImageSource returns an ImageSource for reading from an existing directory.\n// newImageSource untars the file and saves it in a temp directory", "docstring_tokens": ["newImageSource", "returns", "an", "ImageSource", "for", "reading", "from", "an", "existing", "directory", ".", "newImageSource", "untars", "the", "file", "and", "saves", "it", "in", "a", "temp", "directory"], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/oci/archive/oci_src.go#L22-L38", "partition": "test"}
{"repo": "rightscale/rsc", "path": "ss/ssc/codegen_client.go", "func_name": "UserPreferenceInfoLocator", "original_string": "func (api *API) UserPreferenceInfoLocator(href string) *UserPreferenceInfoLocator {\n\treturn &UserPreferenceInfoLocator{Href(href), api}\n}", "language": "go", "code": "func (api *API) UserPreferenceInfoLocator(href string) *UserPreferenceInfoLocator {\n\treturn &UserPreferenceInfoLocator{Href(href), api}\n}", "code_tokens": ["func", "(", "api", "*", "API", ")", "UserPreferenceInfoLocator", "(", "href", "string", ")", "*", "UserPreferenceInfoLocator", "{", "return", "&", "UserPreferenceInfoLocator", "{", "Href", "(", "href", ")", ",", "api", "}", "\n", "}"], "docstring": "// UserPreferenceInfoLocator builds a locator from the given href.", "docstring_tokens": ["UserPreferenceInfoLocator", "builds", "a", "locator", "from", "the", "given", "href", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/ss/ssc/codegen_client.go#L1487-L1489", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/serviceenv/service_env.go", "func_name": "GetKubeClient", "original_string": "func (env *ServiceEnv) GetKubeClient() *kube.Clientset {\n\tif err := env.kubeEg.Wait(); err != nil {\n\t\tpanic(err) // If env can't connect, there's no sensible way to recover\n\t}\n\tif env.kubeClient == nil {\n\t\tpanic(\"service env never connected to kubernetes\")\n\t}\n\treturn env.kubeClient\n}", "language": "go", "code": "func (env *ServiceEnv) GetKubeClient() *kube.Clientset {\n\tif err := env.kubeEg.Wait(); err != nil {\n\t\tpanic(err) // If env can't connect, there's no sensible way to recover\n\t}\n\tif env.kubeClient == nil {\n\t\tpanic(\"service env never connected to kubernetes\")\n\t}\n\treturn env.kubeClient\n}", "code_tokens": ["func", "(", "env", "*", "ServiceEnv", ")", "GetKubeClient", "(", ")", "*", "kube", ".", "Clientset", "{", "if", "err", ":=", "env", ".", "kubeEg", ".", "Wait", "(", ")", ";", "err", "!=", "nil", "{", "panic", "(", "err", ")", "// If env can't connect, there's no sensible way to recover", "\n", "}", "\n", "if", "env", ".", "kubeClient", "==", "nil", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "env", ".", "kubeClient", "\n", "}"], "docstring": "// GetKubeClient returns the already connected Kubernetes API client without\n// modification.", "docstring_tokens": ["GetKubeClient", "returns", "the", "already", "connected", "Kubernetes", "API", "client", "without", "modification", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/serviceenv/service_env.go#L186-L194", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/storage_pools.go", "func_name": "StoragePoolGetID", "original_string": "func (c *Cluster) StoragePoolGetID(poolName string) (int64, error) {\n\tpoolID := int64(-1)\n\tquery := \"SELECT id FROM storage_pools WHERE name=?\"\n\tinargs := []interface{}{poolName}\n\toutargs := []interface{}{&poolID}\n\n\terr := dbQueryRowScan(c.db, query, inargs, outargs)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn -1, ErrNoSuchObject\n\t\t}\n\t}\n\n\treturn poolID, nil\n}", "language": "go", "code": "func (c *Cluster) StoragePoolGetID(poolName string) (int64, error) {\n\tpoolID := int64(-1)\n\tquery := \"SELECT id FROM storage_pools WHERE name=?\"\n\tinargs := []interface{}{poolName}\n\toutargs := []interface{}{&poolID}\n\n\terr := dbQueryRowScan(c.db, query, inargs, outargs)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn -1, ErrNoSuchObject\n\t\t}\n\t}\n\n\treturn poolID, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "StoragePoolGetID", "(", "poolName", "string", ")", "(", "int64", ",", "error", ")", "{", "poolID", ":=", "int64", "(", "-", "1", ")", "\n", "query", ":=", "\"", "\"", "\n", "inargs", ":=", "[", "]", "interface", "{", "}", "{", "poolName", "}", "\n", "outargs", ":=", "[", "]", "interface", "{", "}", "{", "&", "poolID", "}", "\n\n", "err", ":=", "dbQueryRowScan", "(", "c", ".", "db", ",", "query", ",", "inargs", ",", "outargs", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", "==", "sql", ".", "ErrNoRows", "{", "return", "-", "1", ",", "ErrNoSuchObject", "\n", "}", "\n", "}", "\n\n", "return", "poolID", ",", "nil", "\n", "}"], "docstring": "// StoragePoolGetID returns the id of a single storage pool.", "docstring_tokens": ["StoragePoolGetID", "returns", "the", "id", "of", "a", "single", "storage", "pool", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/storage_pools.go#L418-L432", "partition": "test"}
{"repo": "golang/appengine", "path": "cmd/aefix/fix.go", "func_name": "newPkgDot", "original_string": "func newPkgDot(pos token.Pos, pkg, name string) ast.Expr {\n\treturn &ast.SelectorExpr{\n\t\tX: &ast.Ident{\n\t\t\tNamePos: pos,\n\t\t\tName:    pkg,\n\t\t},\n\t\tSel: &ast.Ident{\n\t\t\tNamePos: pos,\n\t\t\tName:    name,\n\t\t},\n\t}\n}", "language": "go", "code": "func newPkgDot(pos token.Pos, pkg, name string) ast.Expr {\n\treturn &ast.SelectorExpr{\n\t\tX: &ast.Ident{\n\t\t\tNamePos: pos,\n\t\t\tName:    pkg,\n\t\t},\n\t\tSel: &ast.Ident{\n\t\t\tNamePos: pos,\n\t\t\tName:    name,\n\t\t},\n\t}\n}", "code_tokens": ["func", "newPkgDot", "(", "pos", "token", ".", "Pos", ",", "pkg", ",", "name", "string", ")", "ast", ".", "Expr", "{", "return", "&", "ast", ".", "SelectorExpr", "{", "X", ":", "&", "ast", ".", "Ident", "{", "NamePos", ":", "pos", ",", "Name", ":", "pkg", ",", "}", ",", "Sel", ":", "&", "ast", ".", "Ident", "{", "NamePos", ":", "pos", ",", "Name", ":", "name", ",", "}", ",", "}", "\n", "}"], "docstring": "// newPkgDot returns an ast.Expr referring to \"pkg.name\" at position pos.", "docstring_tokens": ["newPkgDot", "returns", "an", "ast", ".", "Expr", "referring", "to", "pkg", ".", "name", "at", "position", "pos", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/cmd/aefix/fix.go#L466-L477", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "raft/log.go", "func_name": "findConflict", "original_string": "func (l *raftLog) findConflict(ents []pb.Entry) uint64 {\n\tfor _, ne := range ents {\n\t\tif !l.matchTerm(ne.Index, ne.Term) {\n\t\t\tif ne.Index <= l.lastIndex() {\n\t\t\t\tl.logger.Infof(\"found conflict at index %d [existing term: %d, conflicting term: %d]\",\n\t\t\t\t\tne.Index, l.zeroTermOnErrCompacted(l.term(ne.Index)), ne.Term)\n\t\t\t}\n\t\t\treturn ne.Index\n\t\t}\n\t}\n\treturn 0\n}", "language": "go", "code": "func (l *raftLog) findConflict(ents []pb.Entry) uint64 {\n\tfor _, ne := range ents {\n\t\tif !l.matchTerm(ne.Index, ne.Term) {\n\t\t\tif ne.Index <= l.lastIndex() {\n\t\t\t\tl.logger.Infof(\"found conflict at index %d [existing term: %d, conflicting term: %d]\",\n\t\t\t\t\tne.Index, l.zeroTermOnErrCompacted(l.term(ne.Index)), ne.Term)\n\t\t\t}\n\t\t\treturn ne.Index\n\t\t}\n\t}\n\treturn 0\n}", "code_tokens": ["func", "(", "l", "*", "raftLog", ")", "findConflict", "(", "ents", "[", "]", "pb", ".", "Entry", ")", "uint64", "{", "for", "_", ",", "ne", ":=", "range", "ents", "{", "if", "!", "l", ".", "matchTerm", "(", "ne", ".", "Index", ",", "ne", ".", "Term", ")", "{", "if", "ne", ".", "Index", "<=", "l", ".", "lastIndex", "(", ")", "{", "l", ".", "logger", ".", "Infof", "(", "\"", "\"", ",", "ne", ".", "Index", ",", "l", ".", "zeroTermOnErrCompacted", "(", "l", ".", "term", "(", "ne", ".", "Index", ")", ")", ",", "ne", ".", "Term", ")", "\n", "}", "\n", "return", "ne", ".", "Index", "\n", "}", "\n", "}", "\n", "return", "0", "\n", "}"], "docstring": "// findConflict finds the index of the conflict.\n// It returns the first pair of conflicting entries between the existing\n// entries and the given entries, if there are any.\n// If there is no conflicting entries, and the existing entries contains\n// all the given entries, zero will be returned.\n// If there is no conflicting entries, but the given entries contains new\n// entries, the index of the first new entry will be returned.\n// An entry is considered to be conflicting if it has the same index but\n// a different term.\n// The first entry MUST have an index equal to the argument 'from'.\n// The index of the given entries MUST be continuously increasing.", "docstring_tokens": ["findConflict", "finds", "the", "index", "of", "the", "conflict", ".", "It", "returns", "the", "first", "pair", "of", "conflicting", "entries", "between", "the", "existing", "entries", "and", "the", "given", "entries", "if", "there", "are", "any", ".", "If", "there", "is", "no", "conflicting", "entries", "and", "the", "existing", "entries", "contains", "all", "the", "given", "entries", "zero", "will", "be", "returned", ".", "If", "there", "is", "no", "conflicting", "entries", "but", "the", "given", "entries", "contains", "new", "entries", "the", "index", "of", "the", "first", "new", "entry", "will", "be", "returned", ".", "An", "entry", "is", "considered", "to", "be", "conflicting", "if", "it", "has", "the", "same", "index", "but", "a", "different", "term", ".", "The", "first", "entry", "MUST", "have", "an", "index", "equal", "to", "the", "argument", "from", ".", "The", "index", "of", "the", "given", "entries", "MUST", "be", "continuously", "increasing", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/log.go#L128-L139", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "y/watermark.go", "func_name": "BeginMany", "original_string": "func (w *WaterMark) BeginMany(indices []uint64) {\n\tatomic.StoreUint64(&w.lastIndex, indices[len(indices)-1])\n\tw.markCh <- mark{index: 0, indices: indices, done: false}\n}", "language": "go", "code": "func (w *WaterMark) BeginMany(indices []uint64) {\n\tatomic.StoreUint64(&w.lastIndex, indices[len(indices)-1])\n\tw.markCh <- mark{index: 0, indices: indices, done: false}\n}", "code_tokens": ["func", "(", "w", "*", "WaterMark", ")", "BeginMany", "(", "indices", "[", "]", "uint64", ")", "{", "atomic", ".", "StoreUint64", "(", "&", "w", ".", "lastIndex", ",", "indices", "[", "len", "(", "indices", ")", "-", "1", "]", ")", "\n", "w", ".", "markCh", "<-", "mark", "{", "index", ":", "0", ",", "indices", ":", "indices", ",", "done", ":", "false", "}", "\n", "}"], "docstring": "// BeginMany works like Begin but accepts multiple indices.", "docstring_tokens": ["BeginMany", "works", "like", "Begin", "but", "accepts", "multiple", "indices", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/y/watermark.go#L84-L87", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "store.go", "func_name": "Destroy", "original_string": "func (rp *redisProvider) Destroy(sid string) error {\n\tvar err error\n\tredisPool.Exec(func(c *redis.Client) {\n\t\terr = c.Del(sid).Err()\n\t})\n\treturn err\n}", "language": "go", "code": "func (rp *redisProvider) Destroy(sid string) error {\n\tvar err error\n\tredisPool.Exec(func(c *redis.Client) {\n\t\terr = c.Del(sid).Err()\n\t})\n\treturn err\n}", "code_tokens": ["func", "(", "rp", "*", "redisProvider", ")", "Destroy", "(", "sid", "string", ")", "error", "{", "var", "err", "error", "\n", "redisPool", ".", "Exec", "(", "func", "(", "c", "*", "redis", ".", "Client", ")", "{", "err", "=", "c", ".", "Del", "(", "sid", ")", ".", "Err", "(", ")", "\n", "}", ")", "\n", "return", "err", "\n", "}"], "docstring": "// Destroy delete redis session by id", "docstring_tokens": ["Destroy", "delete", "redis", "session", "by", "id"], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/store.go#L95-L101", "partition": "test"}
{"repo": "taskcluster/taskcluster-client-go", "path": "tcqueue/types.go", "func_name": "MarshalJSON", "original_string": "func (this *PostArtifactResponse) MarshalJSON() ([]byte, error) {\n\tx := json.RawMessage(*this)\n\treturn (&x).MarshalJSON()\n}", "language": "go", "code": "func (this *PostArtifactResponse) MarshalJSON() ([]byte, error) {\n\tx := json.RawMessage(*this)\n\treturn (&x).MarshalJSON()\n}", "code_tokens": ["func", "(", "this", "*", "PostArtifactResponse", ")", "MarshalJSON", "(", ")", "(", "[", "]", "byte", ",", "error", ")", "{", "x", ":=", "json", ".", "RawMessage", "(", "*", "this", ")", "\n", "return", "(", "&", "x", ")", ".", "MarshalJSON", "(", ")", "\n", "}"], "docstring": "// MarshalJSON calls json.RawMessage method of the same name. Required since\n// PostArtifactResponse is of type json.RawMessage...", "docstring_tokens": ["MarshalJSON", "calls", "json", ".", "RawMessage", "method", "of", "the", "same", "name", ".", "Required", "since", "PostArtifactResponse", "is", "of", "type", "json", ".", "RawMessage", "..."], "sha": "ef6acd428ae5844a933792ed6479d0e7dca61ef8", "url": "https://github.com/taskcluster/taskcluster-client-go/blob/ef6acd428ae5844a933792ed6479d0e7dca61ef8/tcqueue/types.go#L2473-L2476", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "logger.go", "func_name": "Errorf", "original_string": "func (opt *Options) Errorf(format string, v ...interface{}) {\n\tif opt.Logger == nil {\n\t\treturn\n\t}\n\topt.Logger.Errorf(format, v...)\n}", "language": "go", "code": "func (opt *Options) Errorf(format string, v ...interface{}) {\n\tif opt.Logger == nil {\n\t\treturn\n\t}\n\topt.Logger.Errorf(format, v...)\n}", "code_tokens": ["func", "(", "opt", "*", "Options", ")", "Errorf", "(", "format", "string", ",", "v", "...", "interface", "{", "}", ")", "{", "if", "opt", ".", "Logger", "==", "nil", "{", "return", "\n", "}", "\n", "opt", ".", "Logger", ".", "Errorf", "(", "format", ",", "v", "...", ")", "\n", "}"], "docstring": "// Errorf logs an ERROR log message to the logger specified in opts or to the\n// global logger if no logger is specified in opts.", "docstring_tokens": ["Errorf", "logs", "an", "ERROR", "log", "message", "to", "the", "logger", "specified", "in", "opts", "or", "to", "the", "global", "logger", "if", "no", "logger", "is", "specified", "in", "opts", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/logger.go#L34-L39", "partition": "test"}
{"repo": "rightscale/rsc", "path": "gen/goav2gen/swagger.go", "func_name": "ID", "original_string": "func (r Ref) ID() string {\n\tif refIF, ok := r[\"$ref\"]; ok {\n\t\treturn strings.TrimPrefix(refIF.(string), \"#/definitions/\")\n\t}\n\treturn \"\"\n}", "language": "go", "code": "func (r Ref) ID() string {\n\tif refIF, ok := r[\"$ref\"]; ok {\n\t\treturn strings.TrimPrefix(refIF.(string), \"#/definitions/\")\n\t}\n\treturn \"\"\n}", "code_tokens": ["func", "(", "r", "Ref", ")", "ID", "(", ")", "string", "{", "if", "refIF", ",", "ok", ":=", "r", "[", "\"", "\"", "]", ";", "ok", "{", "return", "strings", ".", "TrimPrefix", "(", "refIF", ".", "(", "string", ")", ",", "\"", "\"", ")", "\n", "}", "\n", "return", "\"", "\"", "\n", "}"], "docstring": "// ID of the reference", "docstring_tokens": ["ID", "of", "the", "reference"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/goav2gen/swagger.go#L138-L143", "partition": "test"}
{"repo": "golang/appengine", "path": "xmpp/xmpp.go", "func_name": "Send", "original_string": "func (p *Presence) Send(c context.Context) error {\n\treq := &pb.XmppSendPresenceRequest{\n\t\tJid: &p.To,\n\t}\n\tif p.State != \"\" {\n\t\treq.Show = &p.State\n\t}\n\tif p.Type != \"\" {\n\t\treq.Type = &p.Type\n\t}\n\tif p.Sender != \"\" {\n\t\treq.FromJid = &p.Sender\n\t}\n\tif p.Status != \"\" {\n\t\treq.Status = &p.Status\n\t}\n\tres := &pb.XmppSendPresenceResponse{}\n\treturn internal.Call(c, \"xmpp\", \"SendPresence\", req, res)\n}", "language": "go", "code": "func (p *Presence) Send(c context.Context) error {\n\treq := &pb.XmppSendPresenceRequest{\n\t\tJid: &p.To,\n\t}\n\tif p.State != \"\" {\n\t\treq.Show = &p.State\n\t}\n\tif p.Type != \"\" {\n\t\treq.Type = &p.Type\n\t}\n\tif p.Sender != \"\" {\n\t\treq.FromJid = &p.Sender\n\t}\n\tif p.Status != \"\" {\n\t\treq.Status = &p.Status\n\t}\n\tres := &pb.XmppSendPresenceResponse{}\n\treturn internal.Call(c, \"xmpp\", \"SendPresence\", req, res)\n}", "code_tokens": ["func", "(", "p", "*", "Presence", ")", "Send", "(", "c", "context", ".", "Context", ")", "error", "{", "req", ":=", "&", "pb", ".", "XmppSendPresenceRequest", "{", "Jid", ":", "&", "p", ".", "To", ",", "}", "\n", "if", "p", ".", "State", "!=", "\"", "\"", "{", "req", ".", "Show", "=", "&", "p", ".", "State", "\n", "}", "\n", "if", "p", ".", "Type", "!=", "\"", "\"", "{", "req", ".", "Type", "=", "&", "p", ".", "Type", "\n", "}", "\n", "if", "p", ".", "Sender", "!=", "\"", "\"", "{", "req", ".", "FromJid", "=", "&", "p", ".", "Sender", "\n", "}", "\n", "if", "p", ".", "Status", "!=", "\"", "\"", "{", "req", ".", "Status", "=", "&", "p", ".", "Status", "\n", "}", "\n", "res", ":=", "&", "pb", ".", "XmppSendPresenceResponse", "{", "}", "\n", "return", "internal", ".", "Call", "(", "c", ",", "\"", "\"", ",", "\"", "\"", ",", "req", ",", "res", ")", "\n", "}"], "docstring": "// Send sends a presence update.", "docstring_tokens": ["Send", "sends", "a", "presence", "update", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/xmpp/xmpp.go#L145-L163", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "skiplist/skiplist.go", "func_name": "NewWithConfig", "original_string": "func NewWithConfig(cfg Config) *Skiplist {\n\tif runtime.GOARCH != \"amd64\" {\n\t\tcfg.UseMemoryMgmt = false\n\t}\n\n\ts := &Skiplist{\n\t\tConfig:  cfg,\n\t\tbarrier: newAccessBarrier(cfg.UseMemoryMgmt, cfg.BarrierDestructor),\n\t}\n\n\ts.newNode = func(itm unsafe.Pointer, level int) *Node {\n\t\treturn allocNode(itm, level, cfg.Malloc)\n\t}\n\n\tif cfg.UseMemoryMgmt {\n\t\ts.freeNode = func(n *Node) {\n\t\t\tif Debug {\n\t\t\t\tdebugMarkFree(n)\n\t\t\t}\n\t\t\tcfg.Free(unsafe.Pointer(n))\n\t\t}\n\t} else {\n\t\ts.freeNode = func(*Node) {}\n\t}\n\n\thead := allocNode(minItem, MaxLevel, nil)\n\ttail := allocNode(maxItem, MaxLevel, nil)\n\n\tfor i := 0; i <= MaxLevel; i++ {\n\t\thead.setNext(i, tail, false)\n\t}\n\n\ts.head = head\n\ts.tail = tail\n\n\treturn s\n}", "language": "go", "code": "func NewWithConfig(cfg Config) *Skiplist {\n\tif runtime.GOARCH != \"amd64\" {\n\t\tcfg.UseMemoryMgmt = false\n\t}\n\n\ts := &Skiplist{\n\t\tConfig:  cfg,\n\t\tbarrier: newAccessBarrier(cfg.UseMemoryMgmt, cfg.BarrierDestructor),\n\t}\n\n\ts.newNode = func(itm unsafe.Pointer, level int) *Node {\n\t\treturn allocNode(itm, level, cfg.Malloc)\n\t}\n\n\tif cfg.UseMemoryMgmt {\n\t\ts.freeNode = func(n *Node) {\n\t\t\tif Debug {\n\t\t\t\tdebugMarkFree(n)\n\t\t\t}\n\t\t\tcfg.Free(unsafe.Pointer(n))\n\t\t}\n\t} else {\n\t\ts.freeNode = func(*Node) {}\n\t}\n\n\thead := allocNode(minItem, MaxLevel, nil)\n\ttail := allocNode(maxItem, MaxLevel, nil)\n\n\tfor i := 0; i <= MaxLevel; i++ {\n\t\thead.setNext(i, tail, false)\n\t}\n\n\ts.head = head\n\ts.tail = tail\n\n\treturn s\n}", "code_tokens": ["func", "NewWithConfig", "(", "cfg", "Config", ")", "*", "Skiplist", "{", "if", "runtime", ".", "GOARCH", "!=", "\"", "\"", "{", "cfg", ".", "UseMemoryMgmt", "=", "false", "\n", "}", "\n\n", "s", ":=", "&", "Skiplist", "{", "Config", ":", "cfg", ",", "barrier", ":", "newAccessBarrier", "(", "cfg", ".", "UseMemoryMgmt", ",", "cfg", ".", "BarrierDestructor", ")", ",", "}", "\n\n", "s", ".", "newNode", "=", "func", "(", "itm", "unsafe", ".", "Pointer", ",", "level", "int", ")", "*", "Node", "{", "return", "allocNode", "(", "itm", ",", "level", ",", "cfg", ".", "Malloc", ")", "\n", "}", "\n\n", "if", "cfg", ".", "UseMemoryMgmt", "{", "s", ".", "freeNode", "=", "func", "(", "n", "*", "Node", ")", "{", "if", "Debug", "{", "debugMarkFree", "(", "n", ")", "\n", "}", "\n", "cfg", ".", "Free", "(", "unsafe", ".", "Pointer", "(", "n", ")", ")", "\n", "}", "\n", "}", "else", "{", "s", ".", "freeNode", "=", "func", "(", "*", "Node", ")", "{", "}", "\n", "}", "\n\n", "head", ":=", "allocNode", "(", "minItem", ",", "MaxLevel", ",", "nil", ")", "\n", "tail", ":=", "allocNode", "(", "maxItem", ",", "MaxLevel", ",", "nil", ")", "\n\n", "for", "i", ":=", "0", ";", "i", "<=", "MaxLevel", ";", "i", "++", "{", "head", ".", "setNext", "(", "i", ",", "tail", ",", "false", ")", "\n", "}", "\n\n", "s", ".", "head", "=", "head", "\n", "s", ".", "tail", "=", "tail", "\n\n", "return", "s", "\n", "}"], "docstring": "// NewWithConfig creates a config from given config", "docstring_tokens": ["NewWithConfig", "creates", "a", "config", "from", "given", "config"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/skiplist/skiplist.go#L85-L121", "partition": "test"}
{"repo": "Unknwon/goconfig", "path": "read.go", "func_name": "LoadFromReader", "original_string": "func LoadFromReader(in io.Reader) (c *ConfigFile, err error) {\n\tc = newConfigFile([]string{\"\"})\n\terr = c.read(in)\n\treturn c, err\n}", "language": "go", "code": "func LoadFromReader(in io.Reader) (c *ConfigFile, err error) {\n\tc = newConfigFile([]string{\"\"})\n\terr = c.read(in)\n\treturn c, err\n}", "code_tokens": ["func", "LoadFromReader", "(", "in", "io", ".", "Reader", ")", "(", "c", "*", "ConfigFile", ",", "err", "error", ")", "{", "c", "=", "newConfigFile", "(", "[", "]", "string", "{", "\"", "\"", "}", ")", "\n", "err", "=", "c", ".", "read", "(", "in", ")", "\n", "return", "c", ",", "err", "\n", "}"], "docstring": "// LoadFromReader accepts raw data directly from a reader\n// and returns a new configuration representation.\n// You must use ReloadData to reload.\n// You cannot append files a configfile read this way.", "docstring_tokens": ["LoadFromReader", "accepts", "raw", "data", "directly", "from", "a", "reader", "and", "returns", "a", "new", "configuration", "representation", ".", "You", "must", "use", "ReloadData", "to", "reload", ".", "You", "cannot", "append", "files", "a", "configfile", "read", "this", "way", "."], "sha": "3dba17dd7b9ec8509b3621a73a30a4b333eb28da", "url": "https://github.com/Unknwon/goconfig/blob/3dba17dd7b9ec8509b3621a73a30a4b333eb28da/read.go#L201-L205", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/gerrit/client/client.go", "func_name": "GetBranchRevision", "original_string": "func (c *Client) GetBranchRevision(instance, project, branch string) (string, error) {\n\th, ok := c.handlers[instance]\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"not activated gerrit instance: %s\", instance)\n\t}\n\n\tres, _, err := h.projectService.GetBranch(project, branch)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn res.Revision, nil\n}", "language": "go", "code": "func (c *Client) GetBranchRevision(instance, project, branch string) (string, error) {\n\th, ok := c.handlers[instance]\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"not activated gerrit instance: %s\", instance)\n\t}\n\n\tres, _, err := h.projectService.GetBranch(project, branch)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn res.Revision, nil\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "GetBranchRevision", "(", "instance", ",", "project", ",", "branch", "string", ")", "(", "string", ",", "error", ")", "{", "h", ",", "ok", ":=", "c", ".", "handlers", "[", "instance", "]", "\n", "if", "!", "ok", "{", "return", "\"", "\"", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "instance", ")", "\n", "}", "\n\n", "res", ",", "_", ",", "err", ":=", "h", ".", "projectService", ".", "GetBranch", "(", "project", ",", "branch", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n\n", "return", "res", ".", "Revision", ",", "nil", "\n", "}"], "docstring": "// GetBranchRevision returns SHA of HEAD of a branch", "docstring_tokens": ["GetBranchRevision", "returns", "SHA", "of", "HEAD", "of", "a", "branch"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/gerrit/client/client.go#L225-L237", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "serviceworker/serviceworker.go", "func_name": "Do", "original_string": "func (p *StartWorkerParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStartWorker, p, nil)\n}", "language": "go", "code": "func (p *StartWorkerParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStartWorker, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "StartWorkerParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandStartWorker", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes ServiceWorker.startWorker against the provided context.", "docstring_tokens": ["Do", "executes", "ServiceWorker", ".", "startWorker", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/serviceworker/serviceworker.go#L188-L190", "partition": "test"}
{"repo": "kjk/lzmadec", "path": "lzmadec.go", "func_name": "ExtractToFile", "original_string": "func (a *Archive) ExtractToFile(dstPath string, name string) error {\n\tf, err := os.Create(dstPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn a.ExtractToWriter(f, name)\n}", "language": "go", "code": "func (a *Archive) ExtractToFile(dstPath string, name string) error {\n\tf, err := os.Create(dstPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn a.ExtractToWriter(f, name)\n}", "code_tokens": ["func", "(", "a", "*", "Archive", ")", "ExtractToFile", "(", "dstPath", "string", ",", "name", "string", ")", "error", "{", "f", ",", "err", ":=", "os", ".", "Create", "(", "dstPath", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "defer", "f", ".", "Close", "(", ")", "\n", "return", "a", ".", "ExtractToWriter", "(", "f", ",", "name", ")", "\n", "}"], "docstring": "// ExtractToFile extracts a given file from the archive to a file on disk", "docstring_tokens": ["ExtractToFile", "extracts", "a", "given", "file", "from", "the", "archive", "to", "a", "file", "on", "disk"], "sha": "4c61f00ce86f6f11ed9630fa16b771889b08147b", "url": "https://github.com/kjk/lzmadec/blob/4c61f00ce86f6f11ed9630fa16b771889b08147b/lzmadec.go#L285-L292", "partition": "test"}
{"repo": "mota/klash", "path": "params.go", "func_name": "Parse", "original_string": "func (p *Params) Parse(pvalue *reflect.Value) error {\n\tvtype := pvalue.Type().Elem()\n\n\tfor idx := 0; idx < vtype.NumField(); idx++ {\n\t\tfield := vtype.Field(idx)\n\n\t\tvalue := pvalue.Elem().Field(idx)\n\n\t\tif value.Kind() == reflect.Slice {\n\t\t\tvalue.Set(reflect.MakeSlice(value.Type(), 0, 0))\n\t\t}\n\n\t\tparameter := NewParameter(field.Name, value)\n\t\tif err := parameter.DiscoverProperties(field.Tag); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := p.Set(parameter.Name, parameter); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif parameter.Alias != \"\" {\n\t\t\tif err := p.Set(parameter.Alias, parameter); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tp.Listing = append(p.Listing, parameter)\n\t}\n\treturn nil\n}", "language": "go", "code": "func (p *Params) Parse(pvalue *reflect.Value) error {\n\tvtype := pvalue.Type().Elem()\n\n\tfor idx := 0; idx < vtype.NumField(); idx++ {\n\t\tfield := vtype.Field(idx)\n\n\t\tvalue := pvalue.Elem().Field(idx)\n\n\t\tif value.Kind() == reflect.Slice {\n\t\t\tvalue.Set(reflect.MakeSlice(value.Type(), 0, 0))\n\t\t}\n\n\t\tparameter := NewParameter(field.Name, value)\n\t\tif err := parameter.DiscoverProperties(field.Tag); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := p.Set(parameter.Name, parameter); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif parameter.Alias != \"\" {\n\t\t\tif err := p.Set(parameter.Alias, parameter); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tp.Listing = append(p.Listing, parameter)\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "p", "*", "Params", ")", "Parse", "(", "pvalue", "*", "reflect", ".", "Value", ")", "error", "{", "vtype", ":=", "pvalue", ".", "Type", "(", ")", ".", "Elem", "(", ")", "\n\n", "for", "idx", ":=", "0", ";", "idx", "<", "vtype", ".", "NumField", "(", ")", ";", "idx", "++", "{", "field", ":=", "vtype", ".", "Field", "(", "idx", ")", "\n\n", "value", ":=", "pvalue", ".", "Elem", "(", ")", ".", "Field", "(", "idx", ")", "\n\n", "if", "value", ".", "Kind", "(", ")", "==", "reflect", ".", "Slice", "{", "value", ".", "Set", "(", "reflect", ".", "MakeSlice", "(", "value", ".", "Type", "(", ")", ",", "0", ",", "0", ")", ")", "\n", "}", "\n\n", "parameter", ":=", "NewParameter", "(", "field", ".", "Name", ",", "value", ")", "\n", "if", "err", ":=", "parameter", ".", "DiscoverProperties", "(", "field", ".", "Tag", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "err", ":=", "p", ".", "Set", "(", "parameter", ".", "Name", ",", "parameter", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "parameter", ".", "Alias", "!=", "\"", "\"", "{", "if", "err", ":=", "p", ".", "Set", "(", "parameter", ".", "Alias", ",", "parameter", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n", "p", ".", "Listing", "=", "append", "(", "p", ".", "Listing", ",", "parameter", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// Parse discovers the given parameters structure and associates the structure's\n// field names with their values into the Params structure.", "docstring_tokens": ["Parse", "discovers", "the", "given", "parameters", "structure", "and", "associates", "the", "structure", "s", "field", "names", "with", "their", "values", "into", "the", "Params", "structure", "."], "sha": "ca6c37a4c8c2e69831c428cf0c6daac80ab56c22", "url": "https://github.com/mota/klash/blob/ca6c37a4c8c2e69831c428cf0c6daac80ab56c22/params.go#L41-L70", "partition": "test"}
{"repo": "golang/appengine", "path": "taskqueue/taskqueue.go", "func_name": "NewPOSTTask", "original_string": "func NewPOSTTask(path string, params url.Values) *Task {\n\th := make(http.Header)\n\th.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treturn &Task{\n\t\tPath:    path,\n\t\tPayload: []byte(params.Encode()),\n\t\tHeader:  h,\n\t\tMethod:  \"POST\",\n\t}\n}", "language": "go", "code": "func NewPOSTTask(path string, params url.Values) *Task {\n\th := make(http.Header)\n\th.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treturn &Task{\n\t\tPath:    path,\n\t\tPayload: []byte(params.Encode()),\n\t\tHeader:  h,\n\t\tMethod:  \"POST\",\n\t}\n}", "code_tokens": ["func", "NewPOSTTask", "(", "path", "string", ",", "params", "url", ".", "Values", ")", "*", "Task", "{", "h", ":=", "make", "(", "http", ".", "Header", ")", "\n", "h", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "return", "&", "Task", "{", "Path", ":", "path", ",", "Payload", ":", "[", "]", "byte", "(", "params", ".", "Encode", "(", ")", ")", ",", "Header", ":", "h", ",", "Method", ":", "\"", "\"", ",", "}", "\n", "}"], "docstring": "// NewPOSTTask creates a Task that will POST to a path with the given form data.", "docstring_tokens": ["NewPOSTTask", "creates", "a", "Task", "that", "will", "POST", "to", "a", "path", "with", "the", "given", "form", "data", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/taskqueue/taskqueue.go#L140-L149", "partition": "test"}
{"repo": "gin-contrib/location", "path": "location.go", "func_name": "Get", "original_string": "func Get(c *gin.Context) *url.URL {\n\tv, ok := c.Get(key)\n\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tvv, ok := v.(*url.URL)\n\n\tif !ok {\n\t\treturn nil\n\t}\n\n\treturn vv\n}", "language": "go", "code": "func Get(c *gin.Context) *url.URL {\n\tv, ok := c.Get(key)\n\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tvv, ok := v.(*url.URL)\n\n\tif !ok {\n\t\treturn nil\n\t}\n\n\treturn vv\n}", "code_tokens": ["func", "Get", "(", "c", "*", "gin", ".", "Context", ")", "*", "url", ".", "URL", "{", "v", ",", "ok", ":=", "c", ".", "Get", "(", "key", ")", "\n\n", "if", "!", "ok", "{", "return", "nil", "\n", "}", "\n\n", "vv", ",", "ok", ":=", "v", ".", "(", "*", "url", ".", "URL", ")", "\n\n", "if", "!", "ok", "{", "return", "nil", "\n", "}", "\n\n", "return", "vv", "\n", "}"], "docstring": "// Get returns the Location information for the incoming http.Request from the\n// context. If the location is not set a nil value is returned.", "docstring_tokens": ["Get", "returns", "the", "Location", "information", "for", "the", "incoming", "http", ".", "Request", "from", "the", "context", ".", "If", "the", "location", "is", "not", "set", "a", "nil", "value", "is", "returned", "."], "sha": "0462caccbb9cc0b222a2d75a64830c360c603798", "url": "https://github.com/gin-contrib/location/blob/0462caccbb9cc0b222a2d75a64830c360c603798/location.go#L51-L65", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nitro.go", "func_name": "Delete", "original_string": "func (w *Writer) Delete(bs []byte) (success bool) {\n\t_, success = w.Delete2(bs)\n\treturn\n}", "language": "go", "code": "func (w *Writer) Delete(bs []byte) (success bool) {\n\t_, success = w.Delete2(bs)\n\treturn\n}", "code_tokens": ["func", "(", "w", "*", "Writer", ")", "Delete", "(", "bs", "[", "]", "byte", ")", "(", "success", "bool", ")", "{", "_", ",", "success", "=", "w", ".", "Delete2", "(", "bs", ")", "\n", "return", "\n", "}"], "docstring": "// Delete an item\n// Delete always succeed if an item exists.", "docstring_tokens": ["Delete", "an", "item", "Delete", "always", "succeed", "if", "an", "item", "exists", "."], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nitro.go#L220-L223", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pps/cmds/cmds.go", "func_name": "buildImage", "original_string": "func buildImage(client *docker.Client, repo string, contextDir string, dockerfile string, destTag string) error {\n\tdestImage := fmt.Sprintf(\"%s:%s\", repo, destTag)\n\n\tfmt.Printf(\"Building %s, this may take a while.\\n\", destImage)\n\n\terr := client.BuildImage(docker.BuildImageOptions{\n\t\tName:         destImage,\n\t\tContextDir:   contextDir,\n\t\tDockerfile:   dockerfile,\n\t\tOutputStream: os.Stdout,\n\t})\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not build docker image: %s\", err)\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func buildImage(client *docker.Client, repo string, contextDir string, dockerfile string, destTag string) error {\n\tdestImage := fmt.Sprintf(\"%s:%s\", repo, destTag)\n\n\tfmt.Printf(\"Building %s, this may take a while.\\n\", destImage)\n\n\terr := client.BuildImage(docker.BuildImageOptions{\n\t\tName:         destImage,\n\t\tContextDir:   contextDir,\n\t\tDockerfile:   dockerfile,\n\t\tOutputStream: os.Stdout,\n\t})\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not build docker image: %s\", err)\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "buildImage", "(", "client", "*", "docker", ".", "Client", ",", "repo", "string", ",", "contextDir", "string", ",", "dockerfile", "string", ",", "destTag", "string", ")", "error", "{", "destImage", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "repo", ",", "destTag", ")", "\n\n", "fmt", ".", "Printf", "(", "\"", "\\n", "\"", ",", "destImage", ")", "\n\n", "err", ":=", "client", ".", "BuildImage", "(", "docker", ".", "BuildImageOptions", "{", "Name", ":", "destImage", ",", "ContextDir", ":", "contextDir", ",", "Dockerfile", ":", "dockerfile", ",", "OutputStream", ":", "os", ".", "Stdout", ",", "}", ")", "\n\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// buildImage builds a new docker image.", "docstring_tokens": ["buildImage", "builds", "a", "new", "docker", "image", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pps/cmds/cmds.go#L898-L915", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/generate/db/parse.go", "func_name": "Filters", "original_string": "func Filters(pkg *ast.Package, entity string) [][]string {\n\tobjects := pkg.Scope.Objects\n\tfilters := [][]string{}\n\n\tprefix := fmt.Sprintf(\"%sObjectsBy\", entity)\n\n\tfor name := range objects {\n\t\tif !strings.HasPrefix(name, prefix) {\n\t\t\tcontinue\n\t\t}\n\t\trest := name[len(prefix):]\n\t\tfilters = append(filters, strings.Split(rest, \"And\"))\n\t}\n\n\tsort.SliceStable(filters, func(i, j int) bool {\n\t\treturn len(filters[i]) > len(filters[j])\n\t})\n\n\treturn filters\n}", "language": "go", "code": "func Filters(pkg *ast.Package, entity string) [][]string {\n\tobjects := pkg.Scope.Objects\n\tfilters := [][]string{}\n\n\tprefix := fmt.Sprintf(\"%sObjectsBy\", entity)\n\n\tfor name := range objects {\n\t\tif !strings.HasPrefix(name, prefix) {\n\t\t\tcontinue\n\t\t}\n\t\trest := name[len(prefix):]\n\t\tfilters = append(filters, strings.Split(rest, \"And\"))\n\t}\n\n\tsort.SliceStable(filters, func(i, j int) bool {\n\t\treturn len(filters[i]) > len(filters[j])\n\t})\n\n\treturn filters\n}", "code_tokens": ["func", "Filters", "(", "pkg", "*", "ast", ".", "Package", ",", "entity", "string", ")", "[", "]", "[", "]", "string", "{", "objects", ":=", "pkg", ".", "Scope", ".", "Objects", "\n", "filters", ":=", "[", "]", "[", "]", "string", "{", "}", "\n\n", "prefix", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "entity", ")", "\n\n", "for", "name", ":=", "range", "objects", "{", "if", "!", "strings", ".", "HasPrefix", "(", "name", ",", "prefix", ")", "{", "continue", "\n", "}", "\n", "rest", ":=", "name", "[", "len", "(", "prefix", ")", ":", "]", "\n", "filters", "=", "append", "(", "filters", ",", "strings", ".", "Split", "(", "rest", ",", "\"", "\"", ")", ")", "\n", "}", "\n\n", "sort", ".", "SliceStable", "(", "filters", ",", "func", "(", "i", ",", "j", "int", ")", "bool", "{", "return", "len", "(", "filters", "[", "i", "]", ")", ">", "len", "(", "filters", "[", "j", "]", ")", "\n", "}", ")", "\n\n", "return", "filters", "\n", "}"], "docstring": "// Filters parses all filtering statement defined for the given entity. It\n// returns all supported combinations of filters, sorted by number of criteria.", "docstring_tokens": ["Filters", "parses", "all", "filtering", "statement", "defined", "for", "the", "given", "entity", ".", "It", "returns", "all", "supported", "combinations", "of", "filters", "sorted", "by", "number", "of", "criteria", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/generate/db/parse.go#L40-L59", "partition": "test"}
{"repo": "256dpi/fire", "path": "tracer.go", "func_name": "NewTracerFromRequest", "original_string": "func NewTracerFromRequest(r *http.Request, name string) *Tracer {\n\tspan, _ := opentracing.StartSpanFromContext(r.Context(), name)\n\treturn NewTracer(span)\n}", "language": "go", "code": "func NewTracerFromRequest(r *http.Request, name string) *Tracer {\n\tspan, _ := opentracing.StartSpanFromContext(r.Context(), name)\n\treturn NewTracer(span)\n}", "code_tokens": ["func", "NewTracerFromRequest", "(", "r", "*", "http", ".", "Request", ",", "name", "string", ")", "*", "Tracer", "{", "span", ",", "_", ":=", "opentracing", ".", "StartSpanFromContext", "(", "r", ".", "Context", "(", ")", ",", "name", ")", "\n", "return", "NewTracer", "(", "span", ")", "\n", "}"], "docstring": "// NewTracerFromRequest returns a new tracer that has a root span derived from\n// the specified request. A span previously added to the request context using\n// Context is automatically used as the parent.", "docstring_tokens": ["NewTracerFromRequest", "returns", "a", "new", "tracer", "that", "has", "a", "root", "span", "derived", "from", "the", "specified", "request", ".", "A", "span", "previously", "added", "to", "the", "request", "context", "using", "Context", "is", "automatically", "used", "as", "the", "parent", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/tracer.go#L60-L63", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "peer.go", "func_name": "forEachConnectedPeer", "original_string": "func (peer *Peer) forEachConnectedPeer(establishedAndSymmetric bool, exclude map[PeerName]PeerName, f func(*Peer)) {\n\tfor remoteName, conn := range peer.connections {\n\t\tif establishedAndSymmetric && !conn.isEstablished() {\n\t\t\tcontinue\n\t\t}\n\t\tif _, found := exclude[remoteName]; found {\n\t\t\tcontinue\n\t\t}\n\t\tremotePeer := conn.Remote()\n\t\tif remoteConn, found := remotePeer.connections[peer.Name]; !establishedAndSymmetric || (found && remoteConn.isEstablished()) {\n\t\t\tf(remotePeer)\n\t\t}\n\t}\n}", "language": "go", "code": "func (peer *Peer) forEachConnectedPeer(establishedAndSymmetric bool, exclude map[PeerName]PeerName, f func(*Peer)) {\n\tfor remoteName, conn := range peer.connections {\n\t\tif establishedAndSymmetric && !conn.isEstablished() {\n\t\t\tcontinue\n\t\t}\n\t\tif _, found := exclude[remoteName]; found {\n\t\t\tcontinue\n\t\t}\n\t\tremotePeer := conn.Remote()\n\t\tif remoteConn, found := remotePeer.connections[peer.Name]; !establishedAndSymmetric || (found && remoteConn.isEstablished()) {\n\t\t\tf(remotePeer)\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "peer", "*", "Peer", ")", "forEachConnectedPeer", "(", "establishedAndSymmetric", "bool", ",", "exclude", "map", "[", "PeerName", "]", "PeerName", ",", "f", "func", "(", "*", "Peer", ")", ")", "{", "for", "remoteName", ",", "conn", ":=", "range", "peer", ".", "connections", "{", "if", "establishedAndSymmetric", "&&", "!", "conn", ".", "isEstablished", "(", ")", "{", "continue", "\n", "}", "\n", "if", "_", ",", "found", ":=", "exclude", "[", "remoteName", "]", ";", "found", "{", "continue", "\n", "}", "\n", "remotePeer", ":=", "conn", ".", "Remote", "(", ")", "\n", "if", "remoteConn", ",", "found", ":=", "remotePeer", ".", "connections", "[", "peer", ".", "Name", "]", ";", "!", "establishedAndSymmetric", "||", "(", "found", "&&", "remoteConn", ".", "isEstablished", "(", ")", ")", "{", "f", "(", "remotePeer", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// Apply f to all peers reachable by peer. If establishedAndSymmetric is true,\n// only peers with established bidirectional connections will be selected. The\n// exclude maps is treated as a set of remote peers to blacklist.", "docstring_tokens": ["Apply", "f", "to", "all", "peers", "reachable", "by", "peer", ".", "If", "establishedAndSymmetric", "is", "true", "only", "peers", "with", "established", "bidirectional", "connections", "will", "be", "selected", ".", "The", "exclude", "maps", "is", "treated", "as", "a", "set", "of", "remote", "peers", "to", "blacklist", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/peer.go#L123-L136", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/git/localgit/localgit.go", "func_name": "New", "original_string": "func New() (*LocalGit, *git.Client, error) {\n\tg, err := exec.LookPath(\"git\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tt, err := ioutil.TempDir(\"\", \"localgit\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tc, err := git.NewClient()\n\tif err != nil {\n\t\tos.RemoveAll(t)\n\t\treturn nil, nil, err\n\t}\n\n\tgetSecret := func() []byte {\n\t\treturn []byte(\"\")\n\t}\n\n\tc.SetCredentials(\"\", getSecret)\n\n\tc.SetRemote(t)\n\treturn &LocalGit{\n\t\tDir: t,\n\t\tGit: g,\n\t}, c, nil\n}", "language": "go", "code": "func New() (*LocalGit, *git.Client, error) {\n\tg, err := exec.LookPath(\"git\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tt, err := ioutil.TempDir(\"\", \"localgit\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tc, err := git.NewClient()\n\tif err != nil {\n\t\tos.RemoveAll(t)\n\t\treturn nil, nil, err\n\t}\n\n\tgetSecret := func() []byte {\n\t\treturn []byte(\"\")\n\t}\n\n\tc.SetCredentials(\"\", getSecret)\n\n\tc.SetRemote(t)\n\treturn &LocalGit{\n\t\tDir: t,\n\t\tGit: g,\n\t}, c, nil\n}", "code_tokens": ["func", "New", "(", ")", "(", "*", "LocalGit", ",", "*", "git", ".", "Client", ",", "error", ")", "{", "g", ",", "err", ":=", "exec", ".", "LookPath", "(", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n", "t", ",", "err", ":=", "ioutil", ".", "TempDir", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n", "c", ",", "err", ":=", "git", ".", "NewClient", "(", ")", "\n", "if", "err", "!=", "nil", "{", "os", ".", "RemoveAll", "(", "t", ")", "\n", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n\n", "getSecret", ":=", "func", "(", ")", "[", "]", "byte", "{", "return", "[", "]", "byte", "(", "\"", "\"", ")", "\n", "}", "\n\n", "c", ".", "SetCredentials", "(", "\"", "\"", ",", "getSecret", ")", "\n\n", "c", ".", "SetRemote", "(", "t", ")", "\n", "return", "&", "LocalGit", "{", "Dir", ":", "t", ",", "Git", ":", "g", ",", "}", ",", "c", ",", "nil", "\n", "}"], "docstring": "// New creates a LocalGit and a git.Client pointing at it.", "docstring_tokens": ["New", "creates", "a", "LocalGit", "and", "a", "git", ".", "Client", "pointing", "at", "it", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/git/localgit/localgit.go#L42-L68", "partition": "test"}
{"repo": "256dpi/fire", "path": "coal/catalog.go", "func_name": "Visualize", "original_string": "func (c *Catalog) Visualize(title string) string {\n\t// prepare buffer\n\tvar out bytes.Buffer\n\n\t// start graph\n\tout.WriteString(\"graph G {\\n\")\n\tout.WriteString(\"  rankdir=\\\"LR\\\";\\n\")\n\tout.WriteString(\"  sep=\\\"0.3\\\";\\n\")\n\tout.WriteString(\"  ranksep=\\\"0.5\\\";\\n\")\n\tout.WriteString(\"  nodesep=\\\"0.4\\\";\\n\")\n\tout.WriteString(\"  pad=\\\"0.4,0.4\\\";\\n\")\n\tout.WriteString(\"  margin=\\\"0,0\\\";\\n\")\n\tout.WriteString(\"  labelloc=\\\"t\\\";\\n\")\n\tout.WriteString(\"  fontsize=\\\"13\\\";\\n\")\n\tout.WriteString(\"  fontname=\\\"Arial BoldMT\\\";\\n\")\n\tout.WriteString(\"  splines=\\\"spline\\\";\\n\")\n\tout.WriteString(\"  overlap=\\\"voronoi\\\";\\n\")\n\tout.WriteString(\"  outputorder=\\\"edgesfirst\\\";\\n\")\n\tout.WriteString(\"  edge[headclip=true, tailclip=false];\\n\")\n\tout.WriteString(\"  label=\\\"\" + title + \"\\\";\\n\")\n\n\t// get a sorted list of model names and lookup table\n\tvar names []string\n\tlookup := make(map[string]string)\n\tfor name, model := range c.models {\n\t\tnames = append(names, name)\n\t\tlookup[name] = model.Meta().Name\n\t}\n\tsort.Strings(names)\n\n\t// add model nodes\n\tfor _, name := range names {\n\t\t// get model\n\t\tmodel := c.models[name]\n\n\t\t// write begin of node\n\t\tout.WriteString(fmt.Sprintf(`  \"%s\" [ style=filled, fillcolor=white, label=`, lookup[name]))\n\n\t\t// write head table\n\t\tout.WriteString(fmt.Sprintf(`<<table border=\"0\" align=\"center\" cellspacing=\"0.5\" cellpadding=\"0\" width=\"134\"><tr><td align=\"center\" valign=\"bottom\" width=\"130\"><font face=\"Arial BoldMT\" point-size=\"11\">%s</font></td></tr></table>|`, lookup[name]))\n\n\t\t// write begin of tail table\n\t\tout.WriteString(fmt.Sprintf(`<table border=\"0\" align=\"left\" cellspacing=\"2\" cellpadding=\"0\" width=\"134\">`))\n\n\t\t// write attributes\n\t\tfor _, field := range model.Meta().OrderedFields {\n\t\t\tout.WriteString(fmt.Sprintf(`<tr><td align=\"left\" width=\"130\" port=\"%s\">%s<font face=\"Arial ItalicMT\" color=\"grey60\"> %s</font></td></tr>`, field.Name, field.Name, field.Type.String()))\n\t\t}\n\n\t\t// write end of tail table\n\t\tout.WriteString(fmt.Sprintf(`</table>>`))\n\n\t\t// write end of node\n\t\tout.WriteString(`, shape=Mrecord, fontsize=10, fontname=\"ArialMT\", margin=\"0.07,0.05\", penwidth=\"1.0\" ];` + \"\\n\")\n\t}\n\n\t// define temporary struct\n\ttype rel struct {\n\t\tfrom, to   string\n\t\tsrcMany    bool\n\t\tdstMany    bool\n\t\thasInverse bool\n\t}\n\n\t// prepare list\n\tlist := make(map[string]*rel)\n\tvar relNames []string\n\n\t// prepare relationships\n\tfor _, name := range names {\n\t\t// get model\n\t\tmodel := c.models[name]\n\n\t\t// add all direct relationships\n\t\tfor _, field := range model.Meta().OrderedFields {\n\t\t\tif field.RelName != \"\" && (field.ToOne || field.ToMany) {\n\t\t\t\tlist[name+\"-\"+field.RelName] = &rel{\n\t\t\t\t\tfrom:    name,\n\t\t\t\t\tto:      field.RelType,\n\t\t\t\t\tsrcMany: field.ToMany,\n\t\t\t\t}\n\n\t\t\t\trelNames = append(relNames, name+\"-\"+field.RelName)\n\t\t\t}\n\t\t}\n\t}\n\n\t// update relationships\n\tfor _, name := range names {\n\t\t// get model\n\t\tmodel := c.models[name]\n\n\t\t// add all indirect relationships\n\t\tfor _, field := range model.Meta().OrderedFields {\n\t\t\tif field.RelName != \"\" && (field.HasOne || field.HasMany) {\n\t\t\t\tr := list[field.RelType+\"-\"+field.RelInverse]\n\t\t\t\tr.dstMany = field.HasMany\n\t\t\t\tr.hasInverse = true\n\t\t\t}\n\t\t}\n\t}\n\n\t// sort relationship names\n\tsort.Strings(relNames)\n\n\t// add relationships\n\tfor _, name := range relNames {\n\t\t// get relationship\n\t\tr := list[name]\n\n\t\t// get style\n\t\tstyle := \"solid\"\n\t\tif !r.hasInverse {\n\t\t\tstyle = \"dotted\"\n\t\t}\n\n\t\t// get color\n\t\tcolor := \"black\"\n\t\tif r.srcMany {\n\t\t\tcolor = \"black:white:black\"\n\t\t}\n\n\t\t// write edge\n\t\tout.WriteString(fmt.Sprintf(`  \"%s\"--\"%s\"[ fontname=\"ArialMT\", fontsize=7, dir=both, arrowsize=\"0.9\", penwidth=\"0.9\", labelangle=32, labeldistance=\"1.8\", style=%s, color=\"%s\", arrowhead=%s, arrowtail=%s ];`, lookup[r.from], lookup[r.to], style, color, \"normal\", \"none\") + \"\\n\")\n\t}\n\n\t// end graph\n\tout.WriteString(\"}\\n\")\n\n\treturn out.String()\n}", "language": "go", "code": "func (c *Catalog) Visualize(title string) string {\n\t// prepare buffer\n\tvar out bytes.Buffer\n\n\t// start graph\n\tout.WriteString(\"graph G {\\n\")\n\tout.WriteString(\"  rankdir=\\\"LR\\\";\\n\")\n\tout.WriteString(\"  sep=\\\"0.3\\\";\\n\")\n\tout.WriteString(\"  ranksep=\\\"0.5\\\";\\n\")\n\tout.WriteString(\"  nodesep=\\\"0.4\\\";\\n\")\n\tout.WriteString(\"  pad=\\\"0.4,0.4\\\";\\n\")\n\tout.WriteString(\"  margin=\\\"0,0\\\";\\n\")\n\tout.WriteString(\"  labelloc=\\\"t\\\";\\n\")\n\tout.WriteString(\"  fontsize=\\\"13\\\";\\n\")\n\tout.WriteString(\"  fontname=\\\"Arial BoldMT\\\";\\n\")\n\tout.WriteString(\"  splines=\\\"spline\\\";\\n\")\n\tout.WriteString(\"  overlap=\\\"voronoi\\\";\\n\")\n\tout.WriteString(\"  outputorder=\\\"edgesfirst\\\";\\n\")\n\tout.WriteString(\"  edge[headclip=true, tailclip=false];\\n\")\n\tout.WriteString(\"  label=\\\"\" + title + \"\\\";\\n\")\n\n\t// get a sorted list of model names and lookup table\n\tvar names []string\n\tlookup := make(map[string]string)\n\tfor name, model := range c.models {\n\t\tnames = append(names, name)\n\t\tlookup[name] = model.Meta().Name\n\t}\n\tsort.Strings(names)\n\n\t// add model nodes\n\tfor _, name := range names {\n\t\t// get model\n\t\tmodel := c.models[name]\n\n\t\t// write begin of node\n\t\tout.WriteString(fmt.Sprintf(`  \"%s\" [ style=filled, fillcolor=white, label=`, lookup[name]))\n\n\t\t// write head table\n\t\tout.WriteString(fmt.Sprintf(`<<table border=\"0\" align=\"center\" cellspacing=\"0.5\" cellpadding=\"0\" width=\"134\"><tr><td align=\"center\" valign=\"bottom\" width=\"130\"><font face=\"Arial BoldMT\" point-size=\"11\">%s</font></td></tr></table>|`, lookup[name]))\n\n\t\t// write begin of tail table\n\t\tout.WriteString(fmt.Sprintf(`<table border=\"0\" align=\"left\" cellspacing=\"2\" cellpadding=\"0\" width=\"134\">`))\n\n\t\t// write attributes\n\t\tfor _, field := range model.Meta().OrderedFields {\n\t\t\tout.WriteString(fmt.Sprintf(`<tr><td align=\"left\" width=\"130\" port=\"%s\">%s<font face=\"Arial ItalicMT\" color=\"grey60\"> %s</font></td></tr>`, field.Name, field.Name, field.Type.String()))\n\t\t}\n\n\t\t// write end of tail table\n\t\tout.WriteString(fmt.Sprintf(`</table>>`))\n\n\t\t// write end of node\n\t\tout.WriteString(`, shape=Mrecord, fontsize=10, fontname=\"ArialMT\", margin=\"0.07,0.05\", penwidth=\"1.0\" ];` + \"\\n\")\n\t}\n\n\t// define temporary struct\n\ttype rel struct {\n\t\tfrom, to   string\n\t\tsrcMany    bool\n\t\tdstMany    bool\n\t\thasInverse bool\n\t}\n\n\t// prepare list\n\tlist := make(map[string]*rel)\n\tvar relNames []string\n\n\t// prepare relationships\n\tfor _, name := range names {\n\t\t// get model\n\t\tmodel := c.models[name]\n\n\t\t// add all direct relationships\n\t\tfor _, field := range model.Meta().OrderedFields {\n\t\t\tif field.RelName != \"\" && (field.ToOne || field.ToMany) {\n\t\t\t\tlist[name+\"-\"+field.RelName] = &rel{\n\t\t\t\t\tfrom:    name,\n\t\t\t\t\tto:      field.RelType,\n\t\t\t\t\tsrcMany: field.ToMany,\n\t\t\t\t}\n\n\t\t\t\trelNames = append(relNames, name+\"-\"+field.RelName)\n\t\t\t}\n\t\t}\n\t}\n\n\t// update relationships\n\tfor _, name := range names {\n\t\t// get model\n\t\tmodel := c.models[name]\n\n\t\t// add all indirect relationships\n\t\tfor _, field := range model.Meta().OrderedFields {\n\t\t\tif field.RelName != \"\" && (field.HasOne || field.HasMany) {\n\t\t\t\tr := list[field.RelType+\"-\"+field.RelInverse]\n\t\t\t\tr.dstMany = field.HasMany\n\t\t\t\tr.hasInverse = true\n\t\t\t}\n\t\t}\n\t}\n\n\t// sort relationship names\n\tsort.Strings(relNames)\n\n\t// add relationships\n\tfor _, name := range relNames {\n\t\t// get relationship\n\t\tr := list[name]\n\n\t\t// get style\n\t\tstyle := \"solid\"\n\t\tif !r.hasInverse {\n\t\t\tstyle = \"dotted\"\n\t\t}\n\n\t\t// get color\n\t\tcolor := \"black\"\n\t\tif r.srcMany {\n\t\t\tcolor = \"black:white:black\"\n\t\t}\n\n\t\t// write edge\n\t\tout.WriteString(fmt.Sprintf(`  \"%s\"--\"%s\"[ fontname=\"ArialMT\", fontsize=7, dir=both, arrowsize=\"0.9\", penwidth=\"0.9\", labelangle=32, labeldistance=\"1.8\", style=%s, color=\"%s\", arrowhead=%s, arrowtail=%s ];`, lookup[r.from], lookup[r.to], style, color, \"normal\", \"none\") + \"\\n\")\n\t}\n\n\t// end graph\n\tout.WriteString(\"}\\n\")\n\n\treturn out.String()\n}", "code_tokens": ["func", "(", "c", "*", "Catalog", ")", "Visualize", "(", "title", "string", ")", "string", "{", "// prepare buffer", "var", "out", "bytes", ".", "Buffer", "\n\n", "// start graph", "out", ".", "WriteString", "(", "\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\\\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\n", "\"", ")", "\n", "out", ".", "WriteString", "(", "\"", "\\\"", "\"", "+", "title", "+", "\"", "\\\"", "\\n", "\"", ")", "\n\n", "// get a sorted list of model names and lookup table", "var", "names", "[", "]", "string", "\n", "lookup", ":=", "make", "(", "map", "[", "string", "]", "string", ")", "\n", "for", "name", ",", "model", ":=", "range", "c", ".", "models", "{", "names", "=", "append", "(", "names", ",", "name", ")", "\n", "lookup", "[", "name", "]", "=", "model", ".", "Meta", "(", ")", ".", "Name", "\n", "}", "\n", "sort", ".", "Strings", "(", "names", ")", "\n\n", "// add model nodes", "for", "_", ",", "name", ":=", "range", "names", "{", "// get model", "model", ":=", "c", ".", "models", "[", "name", "]", "\n\n", "// write begin of node", "out", ".", "WriteString", "(", "fmt", ".", "Sprintf", "(", "`  \"%s\" [ style=filled, fillcolor=white, label=`", ",", "lookup", "[", "name", "]", ")", ")", "\n\n", "// write head table", "out", ".", "WriteString", "(", "fmt", ".", "Sprintf", "(", "`<<table border=\"0\" align=\"center\" cellspacing=\"0.5\" cellpadding=\"0\" width=\"134\"><tr><td align=\"center\" valign=\"bottom\" width=\"130\"><font face=\"Arial BoldMT\" point-size=\"11\">%s</font></td></tr></table>|`", ",", "lookup", "[", "name", "]", ")", ")", "\n\n", "// write begin of tail table", "out", ".", "WriteString", "(", "fmt", ".", "Sprintf", "(", "`<table border=\"0\" align=\"left\" cellspacing=\"2\" cellpadding=\"0\" width=\"134\">`", ")", ")", "\n\n", "// write attributes", "for", "_", ",", "field", ":=", "range", "model", ".", "Meta", "(", ")", ".", "OrderedFields", "{", "out", ".", "WriteString", "(", "fmt", ".", "Sprintf", "(", "`<tr><td align=\"left\" width=\"130\" port=\"%s\">%s<font face=\"Arial ItalicMT\" color=\"grey60\"> %s</font></td></tr>`", ",", "field", ".", "Name", ",", "field", ".", "Name", ",", "field", ".", "Type", ".", "String", "(", ")", ")", ")", "\n", "}", "\n\n", "// write end of tail table", "out", ".", "WriteString", "(", "fmt", ".", "Sprintf", "(", "`</table>>`", ")", ")", "\n\n", "// write end of node", "out", ".", "WriteString", "(", "`, shape=Mrecord, fontsize=10, fontname=\"ArialMT\", margin=\"0.07,0.05\", penwidth=\"1.0\" ];`", "+", "\"", "\\n", "\"", ")", "\n", "}", "\n\n", "// define temporary struct", "type", "rel", "struct", "{", "from", ",", "to", "string", "\n", "srcMany", "bool", "\n", "dstMany", "bool", "\n", "hasInverse", "bool", "\n", "}", "\n\n", "// prepare list", "list", ":=", "make", "(", "map", "[", "string", "]", "*", "rel", ")", "\n", "var", "relNames", "[", "]", "string", "\n\n", "// prepare relationships", "for", "_", ",", "name", ":=", "range", "names", "{", "// get model", "model", ":=", "c", ".", "models", "[", "name", "]", "\n\n", "// add all direct relationships", "for", "_", ",", "field", ":=", "range", "model", ".", "Meta", "(", ")", ".", "OrderedFields", "{", "if", "field", ".", "RelName", "!=", "\"", "\"", "&&", "(", "field", ".", "ToOne", "||", "field", ".", "ToMany", ")", "{", "list", "[", "name", "+", "\"", "\"", "+", "field", ".", "RelName", "]", "=", "&", "rel", "{", "from", ":", "name", ",", "to", ":", "field", ".", "RelType", ",", "srcMany", ":", "field", ".", "ToMany", ",", "}", "\n\n", "relNames", "=", "append", "(", "relNames", ",", "name", "+", "\"", "\"", "+", "field", ".", "RelName", ")", "\n", "}", "\n", "}", "\n", "}", "\n\n", "// update relationships", "for", "_", ",", "name", ":=", "range", "names", "{", "// get model", "model", ":=", "c", ".", "models", "[", "name", "]", "\n\n", "// add all indirect relationships", "for", "_", ",", "field", ":=", "range", "model", ".", "Meta", "(", ")", ".", "OrderedFields", "{", "if", "field", ".", "RelName", "!=", "\"", "\"", "&&", "(", "field", ".", "HasOne", "||", "field", ".", "HasMany", ")", "{", "r", ":=", "list", "[", "field", ".", "RelType", "+", "\"", "\"", "+", "field", ".", "RelInverse", "]", "\n", "r", ".", "dstMany", "=", "field", ".", "HasMany", "\n", "r", ".", "hasInverse", "=", "true", "\n", "}", "\n", "}", "\n", "}", "\n\n", "// sort relationship names", "sort", ".", "Strings", "(", "relNames", ")", "\n\n", "// add relationships", "for", "_", ",", "name", ":=", "range", "relNames", "{", "// get relationship", "r", ":=", "list", "[", "name", "]", "\n\n", "// get style", "style", ":=", "\"", "\"", "\n", "if", "!", "r", ".", "hasInverse", "{", "style", "=", "\"", "\"", "\n", "}", "\n\n", "// get color", "color", ":=", "\"", "\"", "\n", "if", "r", ".", "srcMany", "{", "color", "=", "\"", "\"", "\n", "}", "\n\n", "// write edge", "out", ".", "WriteString", "(", "fmt", ".", "Sprintf", "(", "`  \"%s\"--\"%s\"[ fontname=\"ArialMT\", fontsize=7, dir=both, arrowsize=\"0.9\", penwidth=\"0.9\", labelangle=32, labeldistance=\"1.8\", style=%s, color=\"%s\", arrowhead=%s, arrowtail=%s ];`", ",", "lookup", "[", "r", ".", "from", "]", ",", "lookup", "[", "r", ".", "to", "]", ",", "style", ",", "color", ",", "\"", "\"", ",", "\"", "\"", ")", "+", "\"", "\\n", "\"", ")", "\n", "}", "\n\n", "// end graph", "out", ".", "WriteString", "(", "\"", "\\n", "\"", ")", "\n\n", "return", "out", ".", "String", "(", ")", "\n", "}"], "docstring": "// Visualize emits a string in dot format which when rendered with graphviz\n// visualizes the models and their relationships.", "docstring_tokens": ["Visualize", "emits", "a", "string", "in", "dot", "format", "which", "when", "rendered", "with", "graphviz", "visualizes", "the", "models", "and", "their", "relationships", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/coal/catalog.go#L63-L193", "partition": "test"}
{"repo": "hooklift/govix", "path": "vmx.go", "func_name": "Write", "original_string": "func (vmxfile *VMXFile) Write() error {\n\tfile, err := os.Create(vmxfile.path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tdata, err := vmx.Marshal(vmxfile.model)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = file.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (vmxfile *VMXFile) Write() error {\n\tfile, err := os.Create(vmxfile.path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tdata, err := vmx.Marshal(vmxfile.model)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = file.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "vmxfile", "*", "VMXFile", ")", "Write", "(", ")", "error", "{", "file", ",", "err", ":=", "os", ".", "Create", "(", "vmxfile", ".", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "defer", "file", ".", "Close", "(", ")", "\n\n", "data", ",", "err", ":=", "vmx", ".", "Marshal", "(", "vmxfile", ".", "model", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "_", ",", "err", "=", "file", ".", "Write", "(", "data", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Write marshals and writes VMX file to disk", "docstring_tokens": ["Write", "marshals", "and", "writes", "VMX", "file", "to", "disk"], "sha": "063702285520a992b920fc1575e305dc9ffd6ffe", "url": "https://github.com/hooklift/govix/blob/063702285520a992b920fc1575e305dc9ffd6ffe/vmx.go#L46-L64", "partition": "test"}
{"repo": "hashicorp/raft", "path": "file_snapshot.go", "func_name": "writeMeta", "original_string": "func (s *FileSnapshotSink) writeMeta() error {\n\t// Open the meta file\n\tmetaPath := filepath.Join(s.dir, metaFilePath)\n\tfh, err := os.Create(metaPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fh.Close()\n\n\t// Buffer the file IO\n\tbuffered := bufio.NewWriter(fh)\n\n\t// Write out as JSON\n\tenc := json.NewEncoder(buffered)\n\tif err := enc.Encode(&s.meta); err != nil {\n\t\treturn err\n\t}\n\n\tif err = buffered.Flush(); err != nil {\n\t\treturn err\n\t}\n\n\tif err = fh.Sync(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (s *FileSnapshotSink) writeMeta() error {\n\t// Open the meta file\n\tmetaPath := filepath.Join(s.dir, metaFilePath)\n\tfh, err := os.Create(metaPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fh.Close()\n\n\t// Buffer the file IO\n\tbuffered := bufio.NewWriter(fh)\n\n\t// Write out as JSON\n\tenc := json.NewEncoder(buffered)\n\tif err := enc.Encode(&s.meta); err != nil {\n\t\treturn err\n\t}\n\n\tif err = buffered.Flush(); err != nil {\n\t\treturn err\n\t}\n\n\tif err = fh.Sync(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "s", "*", "FileSnapshotSink", ")", "writeMeta", "(", ")", "error", "{", "// Open the meta file", "metaPath", ":=", "filepath", ".", "Join", "(", "s", ".", "dir", ",", "metaFilePath", ")", "\n", "fh", ",", "err", ":=", "os", ".", "Create", "(", "metaPath", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "defer", "fh", ".", "Close", "(", ")", "\n\n", "// Buffer the file IO", "buffered", ":=", "bufio", ".", "NewWriter", "(", "fh", ")", "\n\n", "// Write out as JSON", "enc", ":=", "json", ".", "NewEncoder", "(", "buffered", ")", "\n", "if", "err", ":=", "enc", ".", "Encode", "(", "&", "s", ".", "meta", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "err", "=", "buffered", ".", "Flush", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "err", "=", "fh", ".", "Sync", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// writeMeta is used to write out the metadata we have.", "docstring_tokens": ["writeMeta", "is", "used", "to", "write", "out", "the", "metadata", "we", "have", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/file_snapshot.go#L482-L509", "partition": "test"}
{"repo": "naoina/genmai", "path": "genmai.go", "func_name": "Begin", "original_string": "func (db *DB) Begin() error {\n\ttx, err := db.db.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdb.m.Lock()\n\tdefer db.m.Unlock()\n\tdb.tx = tx\n\treturn nil\n}", "language": "go", "code": "func (db *DB) Begin() error {\n\ttx, err := db.db.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdb.m.Lock()\n\tdefer db.m.Unlock()\n\tdb.tx = tx\n\treturn nil\n}", "code_tokens": ["func", "(", "db", "*", "DB", ")", "Begin", "(", ")", "error", "{", "tx", ",", "err", ":=", "db", ".", "db", ".", "Begin", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "db", ".", "m", ".", "Lock", "(", ")", "\n", "defer", "db", ".", "m", ".", "Unlock", "(", ")", "\n", "db", ".", "tx", "=", "tx", "\n", "return", "nil", "\n", "}"], "docstring": "// Begin starts a transaction.", "docstring_tokens": ["Begin", "starts", "a", "transaction", "."], "sha": "78583835e1e41e3938e1ddfffd7101f8ad27fae0", "url": "https://github.com/naoina/genmai/blob/78583835e1e41e3938e1ddfffd7101f8ad27fae0/genmai.go#L485-L494", "partition": "test"}
{"repo": "alexflint/go-arg", "path": "parse.go", "func_name": "walkFields", "original_string": "func walkFields(v reflect.Value, visit func(field reflect.StructField, val reflect.Value, owner reflect.Type) bool) {\n\tt := v.Type()\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tval := v.Field(i)\n\t\texpand := visit(field, val, t)\n\t\tif expand && field.Type.Kind() == reflect.Struct {\n\t\t\twalkFields(val, visit)\n\t\t}\n\t}\n}", "language": "go", "code": "func walkFields(v reflect.Value, visit func(field reflect.StructField, val reflect.Value, owner reflect.Type) bool) {\n\tt := v.Type()\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tval := v.Field(i)\n\t\texpand := visit(field, val, t)\n\t\tif expand && field.Type.Kind() == reflect.Struct {\n\t\t\twalkFields(val, visit)\n\t\t}\n\t}\n}", "code_tokens": ["func", "walkFields", "(", "v", "reflect", ".", "Value", ",", "visit", "func", "(", "field", "reflect", ".", "StructField", ",", "val", "reflect", ".", "Value", ",", "owner", "reflect", ".", "Type", ")", "bool", ")", "{", "t", ":=", "v", ".", "Type", "(", ")", "\n", "for", "i", ":=", "0", ";", "i", "<", "t", ".", "NumField", "(", ")", ";", "i", "++", "{", "field", ":=", "t", ".", "Field", "(", "i", ")", "\n", "val", ":=", "v", ".", "Field", "(", "i", ")", "\n", "expand", ":=", "visit", "(", "field", ",", "val", ",", "t", ")", "\n", "if", "expand", "&&", "field", ".", "Type", ".", "Kind", "(", ")", "==", "reflect", ".", "Struct", "{", "walkFields", "(", "val", ",", "visit", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// walkFields calls a function for each field of a struct, recursively expanding struct fields.", "docstring_tokens": ["walkFields", "calls", "a", "function", "for", "each", "field", "of", "a", "struct", "recursively", "expanding", "struct", "fields", "."], "sha": "fb1ae1c3e0bd00d45333c3d51384afc05846f7a0", "url": "https://github.com/alexflint/go-arg/blob/fb1ae1c3e0bd00d45333c3d51384afc05846f7a0/parse.go#L105-L115", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "robots/issue-creator/sources/triage-filer.go", "func_name": "topJobsFailed", "original_string": "func (c *Cluster) topJobsFailed(count int) []*Job {\n\tslice := make([]*Job, len(c.jobs))\n\ti := 0\n\tfor jobName, builds := range c.jobs {\n\t\tslice[i] = &Job{Name: jobName, Builds: builds}\n\t\ti++\n\t}\n\tless := func(i, j int) bool { return len(slice[i].Builds) > len(slice[j].Builds) }\n\tsort.SliceStable(slice, less)\n\n\tif len(slice) < count {\n\t\tcount = len(slice)\n\t}\n\treturn slice[0:count]\n}", "language": "go", "code": "func (c *Cluster) topJobsFailed(count int) []*Job {\n\tslice := make([]*Job, len(c.jobs))\n\ti := 0\n\tfor jobName, builds := range c.jobs {\n\t\tslice[i] = &Job{Name: jobName, Builds: builds}\n\t\ti++\n\t}\n\tless := func(i, j int) bool { return len(slice[i].Builds) > len(slice[j].Builds) }\n\tsort.SliceStable(slice, less)\n\n\tif len(slice) < count {\n\t\tcount = len(slice)\n\t}\n\treturn slice[0:count]\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "topJobsFailed", "(", "count", "int", ")", "[", "]", "*", "Job", "{", "slice", ":=", "make", "(", "[", "]", "*", "Job", ",", "len", "(", "c", ".", "jobs", ")", ")", "\n", "i", ":=", "0", "\n", "for", "jobName", ",", "builds", ":=", "range", "c", ".", "jobs", "{", "slice", "[", "i", "]", "=", "&", "Job", "{", "Name", ":", "jobName", ",", "Builds", ":", "builds", "}", "\n", "i", "++", "\n", "}", "\n", "less", ":=", "func", "(", "i", ",", "j", "int", ")", "bool", "{", "return", "len", "(", "slice", "[", "i", "]", ".", "Builds", ")", ">", "len", "(", "slice", "[", "j", "]", ".", "Builds", ")", "}", "\n", "sort", ".", "SliceStable", "(", "slice", ",", "less", ")", "\n\n", "if", "len", "(", "slice", ")", "<", "count", "{", "count", "=", "len", "(", "slice", ")", "\n", "}", "\n", "return", "slice", "[", "0", ":", "count", "]", "\n", "}"], "docstring": "// topJobsFailed returns the top 'count' job names sorted by number of failing builds.", "docstring_tokens": ["topJobsFailed", "returns", "the", "top", "count", "job", "names", "sorted", "by", "number", "of", "failing", "builds", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/robots/issue-creator/sources/triage-filer.go#L347-L361", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/github/fakegithub/fakegithub.go", "func_name": "GetOrgProjects", "original_string": "func (f *FakeClient) GetOrgProjects(org string) ([]github.Project, error) {\n\treturn f.RepoProjects[fmt.Sprintf(\"%s/*\", org)], nil\n}", "language": "go", "code": "func (f *FakeClient) GetOrgProjects(org string) ([]github.Project, error) {\n\treturn f.RepoProjects[fmt.Sprintf(\"%s/*\", org)], nil\n}", "code_tokens": ["func", "(", "f", "*", "FakeClient", ")", "GetOrgProjects", "(", "org", "string", ")", "(", "[", "]", "github", ".", "Project", ",", "error", ")", "{", "return", "f", ".", "RepoProjects", "[", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "org", ")", "]", ",", "nil", "\n", "}"], "docstring": "// GetOrgProjects returns the list of projects under an org", "docstring_tokens": ["GetOrgProjects", "returns", "the", "list", "of", "projects", "under", "an", "org"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/fakegithub/fakegithub.go#L445-L447", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "skiplist/skiplist.go", "func_name": "Insert", "original_string": "func (s *Skiplist) Insert(itm unsafe.Pointer, cmp CompareFn,\n\tbuf *ActionBuffer, sts *Stats) (success bool) {\n\t_, success = s.Insert2(itm, cmp, nil, buf, rand.Float32, sts)\n\treturn\n}", "language": "go", "code": "func (s *Skiplist) Insert(itm unsafe.Pointer, cmp CompareFn,\n\tbuf *ActionBuffer, sts *Stats) (success bool) {\n\t_, success = s.Insert2(itm, cmp, nil, buf, rand.Float32, sts)\n\treturn\n}", "code_tokens": ["func", "(", "s", "*", "Skiplist", ")", "Insert", "(", "itm", "unsafe", ".", "Pointer", ",", "cmp", "CompareFn", ",", "buf", "*", "ActionBuffer", ",", "sts", "*", "Stats", ")", "(", "success", "bool", ")", "{", "_", ",", "success", "=", "s", ".", "Insert2", "(", "itm", ",", "cmp", ",", "nil", ",", "buf", ",", "rand", ".", "Float32", ",", "sts", ")", "\n", "return", "\n", "}"], "docstring": "// Insert adds an item into the skiplist", "docstring_tokens": ["Insert", "adds", "an", "item", "into", "the", "skiplist"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/skiplist/skiplist.go#L232-L236", "partition": "test"}
{"repo": "bluekeyes/hatpear", "path": "hatpear.go", "func_name": "Try", "original_string": "func Try(h Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\terr := h.ServeHTTP(w, r)\n\t\tStore(r, err)\n\t})\n}", "language": "go", "code": "func Try(h Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\terr := h.ServeHTTP(w, r)\n\t\tStore(r, err)\n\t})\n}", "code_tokens": ["func", "Try", "(", "h", "Handler", ")", "http", ".", "Handler", "{", "return", "http", ".", "HandlerFunc", "(", "func", "(", "w", "http", ".", "ResponseWriter", ",", "r", "*", "http", ".", "Request", ")", "{", "err", ":=", "h", ".", "ServeHTTP", "(", "w", ",", "r", ")", "\n", "Store", "(", "r", ",", "err", ")", "\n", "}", ")", "\n", "}"], "docstring": "// Try converts a handler to a standard http.Handler, storing any error in the\n// request's context.", "docstring_tokens": ["Try", "converts", "a", "handler", "to", "a", "standard", "http", ".", "Handler", "storing", "any", "error", "in", "the", "request", "s", "context", "."], "sha": "ffb42d5bb417aa8e12b3b7ff73d028b915dafa10", "url": "https://github.com/bluekeyes/hatpear/blob/ffb42d5bb417aa8e12b3b7ff73d028b915dafa10/hatpear.go#L82-L87", "partition": "test"}
{"repo": "libp2p/go-libp2p-pubsub", "path": "pubsub.go", "func_name": "Publish", "original_string": "func (p *PubSub) Publish(topic string, data []byte) error {\n\tseqno := p.nextSeqno()\n\tm := &pb.Message{\n\t\tData:     data,\n\t\tTopicIDs: []string{topic},\n\t\tFrom:     []byte(p.host.ID()),\n\t\tSeqno:    seqno,\n\t}\n\tif p.signKey != nil {\n\t\tm.From = []byte(p.signID)\n\t\terr := signMessage(p.signID, p.signKey, m)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tp.publish <- &Message{m}\n\treturn nil\n}", "language": "go", "code": "func (p *PubSub) Publish(topic string, data []byte) error {\n\tseqno := p.nextSeqno()\n\tm := &pb.Message{\n\t\tData:     data,\n\t\tTopicIDs: []string{topic},\n\t\tFrom:     []byte(p.host.ID()),\n\t\tSeqno:    seqno,\n\t}\n\tif p.signKey != nil {\n\t\tm.From = []byte(p.signID)\n\t\terr := signMessage(p.signID, p.signKey, m)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tp.publish <- &Message{m}\n\treturn nil\n}", "code_tokens": ["func", "(", "p", "*", "PubSub", ")", "Publish", "(", "topic", "string", ",", "data", "[", "]", "byte", ")", "error", "{", "seqno", ":=", "p", ".", "nextSeqno", "(", ")", "\n", "m", ":=", "&", "pb", ".", "Message", "{", "Data", ":", "data", ",", "TopicIDs", ":", "[", "]", "string", "{", "topic", "}", ",", "From", ":", "[", "]", "byte", "(", "p", ".", "host", ".", "ID", "(", ")", ")", ",", "Seqno", ":", "seqno", ",", "}", "\n", "if", "p", ".", "signKey", "!=", "nil", "{", "m", ".", "From", "=", "[", "]", "byte", "(", "p", ".", "signID", ")", "\n", "err", ":=", "signMessage", "(", "p", ".", "signID", ",", "p", ".", "signKey", ",", "m", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n", "p", ".", "publish", "<-", "&", "Message", "{", "m", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// Publish publishes data to the given topic.", "docstring_tokens": ["Publish", "publishes", "data", "to", "the", "given", "topic", "."], "sha": "9db3dbdde90f44d1c420192c5cefd60682fbdbb9", "url": "https://github.com/libp2p/go-libp2p-pubsub/blob/9db3dbdde90f44d1c420192c5cefd60682fbdbb9/pubsub.go#L833-L850", "partition": "test"}
{"repo": "glycerine/rbuf", "path": "fbuf.go", "func_name": "TwoContig", "original_string": "func (b *Float64RingBuf) TwoContig(makeCopy bool) (first []float64, second []float64) {\n\n\textent := b.Beg + b.Readable\n\tif extent <= b.N {\n\t\t// we fit contiguously in this buffer without wrapping to the other.\n\t\t// Let second stay an empty slice.\n\t\treturn b.A[b.Beg:(b.Beg + b.Readable)], second\n\t}\n\n\treturn b.A[b.Beg:b.N], b.A[0:(extent % b.N)]\n}", "language": "go", "code": "func (b *Float64RingBuf) TwoContig(makeCopy bool) (first []float64, second []float64) {\n\n\textent := b.Beg + b.Readable\n\tif extent <= b.N {\n\t\t// we fit contiguously in this buffer without wrapping to the other.\n\t\t// Let second stay an empty slice.\n\t\treturn b.A[b.Beg:(b.Beg + b.Readable)], second\n\t}\n\n\treturn b.A[b.Beg:b.N], b.A[0:(extent % b.N)]\n}", "code_tokens": ["func", "(", "b", "*", "Float64RingBuf", ")", "TwoContig", "(", "makeCopy", "bool", ")", "(", "first", "[", "]", "float64", ",", "second", "[", "]", "float64", ")", "{", "extent", ":=", "b", ".", "Beg", "+", "b", ".", "Readable", "\n", "if", "extent", "<=", "b", ".", "N", "{", "// we fit contiguously in this buffer without wrapping to the other.", "// Let second stay an empty slice.", "return", "b", ".", "A", "[", "b", ".", "Beg", ":", "(", "b", ".", "Beg", "+", "b", ".", "Readable", ")", "]", ",", "second", "\n", "}", "\n\n", "return", "b", ".", "A", "[", "b", ".", "Beg", ":", "b", ".", "N", "]", ",", "b", ".", "A", "[", "0", ":", "(", "extent", "%", "b", ".", "N", ")", "]", "\n", "}"], "docstring": "// TwoContig returns all readable float64, but in two separate slices,\n// to avoid copying. The two slices are from the same buffer, but\n// are not contiguous. Either or both may be empty slices.", "docstring_tokens": ["TwoContig", "returns", "all", "readable", "float64", "but", "in", "two", "separate", "slices", "to", "avoid", "copying", ".", "The", "two", "slices", "are", "from", "the", "same", "buffer", "but", "are", "not", "contiguous", ".", "Either", "or", "both", "may", "be", "empty", "slices", "."], "sha": "75b78581bebe959bc9a3df4c5f64e82c187d7531", "url": "https://github.com/glycerine/rbuf/blob/75b78581bebe959bc9a3df4c5f64e82c187d7531/fbuf.go#L38-L48", "partition": "test"}
{"repo": "op/go-logging", "path": "multi.go", "func_name": "MultiLogger", "original_string": "func MultiLogger(backends ...Backend) LeveledBackend {\n\tvar leveledBackends []LeveledBackend\n\tfor _, backend := range backends {\n\t\tleveledBackends = append(leveledBackends, AddModuleLevel(backend))\n\t}\n\treturn &multiLogger{leveledBackends}\n}", "language": "go", "code": "func MultiLogger(backends ...Backend) LeveledBackend {\n\tvar leveledBackends []LeveledBackend\n\tfor _, backend := range backends {\n\t\tleveledBackends = append(leveledBackends, AddModuleLevel(backend))\n\t}\n\treturn &multiLogger{leveledBackends}\n}", "code_tokens": ["func", "MultiLogger", "(", "backends", "...", "Backend", ")", "LeveledBackend", "{", "var", "leveledBackends", "[", "]", "LeveledBackend", "\n", "for", "_", ",", "backend", ":=", "range", "backends", "{", "leveledBackends", "=", "append", "(", "leveledBackends", ",", "AddModuleLevel", "(", "backend", ")", ")", "\n", "}", "\n", "return", "&", "multiLogger", "{", "leveledBackends", "}", "\n", "}"], "docstring": "// MultiLogger creates a logger which contain multiple loggers.", "docstring_tokens": ["MultiLogger", "creates", "a", "logger", "which", "contain", "multiple", "loggers", "."], "sha": "970db520ece77730c7e4724c61121037378659d9", "url": "https://github.com/op/go-logging/blob/970db520ece77730c7e4724c61121037378659d9/multi.go#L16-L22", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/containers.go", "func_name": "ContainerUpdate", "original_string": "func ContainerUpdate(tx *sql.Tx, id int, description string, architecture int, ephemeral bool,\n\texpiryDate time.Time) error {\n\tstr := fmt.Sprintf(\"UPDATE containers SET description=?, architecture=?, ephemeral=?, expiry_date=? WHERE id=?\")\n\tstmt, err := tx.Prepare(str)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tephemeralInt := 0\n\tif ephemeral {\n\t\tephemeralInt = 1\n\t}\n\n\tif expiryDate.IsZero() {\n\t\t_, err = stmt.Exec(description, architecture, ephemeralInt, \"\", id)\n\t} else {\n\t\t_, err = stmt.Exec(description, architecture, ephemeralInt, expiryDate, id)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func ContainerUpdate(tx *sql.Tx, id int, description string, architecture int, ephemeral bool,\n\texpiryDate time.Time) error {\n\tstr := fmt.Sprintf(\"UPDATE containers SET description=?, architecture=?, ephemeral=?, expiry_date=? WHERE id=?\")\n\tstmt, err := tx.Prepare(str)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tephemeralInt := 0\n\tif ephemeral {\n\t\tephemeralInt = 1\n\t}\n\n\tif expiryDate.IsZero() {\n\t\t_, err = stmt.Exec(description, architecture, ephemeralInt, \"\", id)\n\t} else {\n\t\t_, err = stmt.Exec(description, architecture, ephemeralInt, expiryDate, id)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "ContainerUpdate", "(", "tx", "*", "sql", ".", "Tx", ",", "id", "int", ",", "description", "string", ",", "architecture", "int", ",", "ephemeral", "bool", ",", "expiryDate", "time", ".", "Time", ")", "error", "{", "str", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ")", "\n", "stmt", ",", "err", ":=", "tx", ".", "Prepare", "(", "str", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "defer", "stmt", ".", "Close", "(", ")", "\n\n", "ephemeralInt", ":=", "0", "\n", "if", "ephemeral", "{", "ephemeralInt", "=", "1", "\n", "}", "\n\n", "if", "expiryDate", ".", "IsZero", "(", ")", "{", "_", ",", "err", "=", "stmt", ".", "Exec", "(", "description", ",", "architecture", ",", "ephemeralInt", ",", "\"", "\"", ",", "id", ")", "\n", "}", "else", "{", "_", ",", "err", "=", "stmt", ".", "Exec", "(", "description", ",", "architecture", ",", "ephemeralInt", ",", "expiryDate", ",", "id", ")", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// ContainerUpdate updates the description, architecture and ephemeral flag of\n// the container with the given ID.", "docstring_tokens": ["ContainerUpdate", "updates", "the", "description", "architecture", "and", "ephemeral", "flag", "of", "the", "container", "with", "the", "given", "ID", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/containers.go#L815-L839", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/logger.go", "func_name": "GetLogger", "original_string": "func GetLogger() logutil.Logger {\n\tlgMu.RLock()\n\tl := lg\n\tlgMu.RUnlock()\n\treturn l\n}", "language": "go", "code": "func GetLogger() logutil.Logger {\n\tlgMu.RLock()\n\tl := lg\n\tlgMu.RUnlock()\n\treturn l\n}", "code_tokens": ["func", "GetLogger", "(", ")", "logutil", ".", "Logger", "{", "lgMu", ".", "RLock", "(", ")", "\n", "l", ":=", "lg", "\n", "lgMu", ".", "RUnlock", "(", ")", "\n", "return", "l", "\n", "}"], "docstring": "// GetLogger returns the current logutil.Logger.", "docstring_tokens": ["GetLogger", "returns", "the", "current", "logutil", ".", "Logger", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/logger.go#L52-L57", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/deploy/assets/assets.go", "func_name": "GoogleSecret", "original_string": "func GoogleSecret(bucket string, cred string) map[string][]byte {\n\treturn map[string][]byte{\n\t\t\"google-bucket\": []byte(bucket),\n\t\t\"google-cred\":   []byte(cred),\n\t}\n}", "language": "go", "code": "func GoogleSecret(bucket string, cred string) map[string][]byte {\n\treturn map[string][]byte{\n\t\t\"google-bucket\": []byte(bucket),\n\t\t\"google-cred\":   []byte(cred),\n\t}\n}", "code_tokens": ["func", "GoogleSecret", "(", "bucket", "string", ",", "cred", "string", ")", "map", "[", "string", "]", "[", "]", "byte", "{", "return", "map", "[", "string", "]", "[", "]", "byte", "{", "\"", "\"", ":", "[", "]", "byte", "(", "bucket", ")", ",", "\"", "\"", ":", "[", "]", "byte", "(", "cred", ")", ",", "}", "\n", "}"], "docstring": "// GoogleSecret creates a google secret with a bucket name.", "docstring_tokens": ["GoogleSecret", "creates", "a", "google", "secret", "with", "a", "bucket", "name", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/deploy/assets/assets.go#L1280-L1285", "partition": "test"}
{"repo": "containers/image", "path": "pkg/sysregistriesv2/system_registries_v2.go", "func_name": "getConfigPath", "original_string": "func getConfigPath(ctx *types.SystemContext) string {\n\tconfPath := systemRegistriesConfPath\n\tif ctx != nil {\n\t\tif ctx.SystemRegistriesConfPath != \"\" {\n\t\t\tconfPath = ctx.SystemRegistriesConfPath\n\t\t} else if ctx.RootForImplicitAbsolutePaths != \"\" {\n\t\t\tconfPath = filepath.Join(ctx.RootForImplicitAbsolutePaths, systemRegistriesConfPath)\n\t\t}\n\t}\n\treturn confPath\n}", "language": "go", "code": "func getConfigPath(ctx *types.SystemContext) string {\n\tconfPath := systemRegistriesConfPath\n\tif ctx != nil {\n\t\tif ctx.SystemRegistriesConfPath != \"\" {\n\t\t\tconfPath = ctx.SystemRegistriesConfPath\n\t\t} else if ctx.RootForImplicitAbsolutePaths != \"\" {\n\t\t\tconfPath = filepath.Join(ctx.RootForImplicitAbsolutePaths, systemRegistriesConfPath)\n\t\t}\n\t}\n\treturn confPath\n}", "code_tokens": ["func", "getConfigPath", "(", "ctx", "*", "types", ".", "SystemContext", ")", "string", "{", "confPath", ":=", "systemRegistriesConfPath", "\n", "if", "ctx", "!=", "nil", "{", "if", "ctx", ".", "SystemRegistriesConfPath", "!=", "\"", "\"", "{", "confPath", "=", "ctx", ".", "SystemRegistriesConfPath", "\n", "}", "else", "if", "ctx", ".", "RootForImplicitAbsolutePaths", "!=", "\"", "\"", "{", "confPath", "=", "filepath", ".", "Join", "(", "ctx", ".", "RootForImplicitAbsolutePaths", ",", "systemRegistriesConfPath", ")", "\n", "}", "\n", "}", "\n", "return", "confPath", "\n", "}"], "docstring": "// getConfigPath returns the system-registries config path if specified.\n// Otherwise, systemRegistriesConfPath is returned.", "docstring_tokens": ["getConfigPath", "returns", "the", "system", "-", "registries", "config", "path", "if", "specified", ".", "Otherwise", "systemRegistriesConfPath", "is", "returned", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/pkg/sysregistriesv2/system_registries_v2.go#L253-L263", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "peer.go", "func_name": "Get", "original_string": "func (l *PeerList) Get(prevSelected map[string]struct{}) (*Peer, error) {\n\tpeer, err := l.GetNew(prevSelected)\n\tif err == ErrNoNewPeers {\n\t\tl.Lock()\n\t\tpeer = l.choosePeer(nil, false /* avoidHost */)\n\t\tl.Unlock()\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\tif peer == nil {\n\t\treturn nil, ErrNoPeers\n\t}\n\treturn peer, nil\n}", "language": "go", "code": "func (l *PeerList) Get(prevSelected map[string]struct{}) (*Peer, error) {\n\tpeer, err := l.GetNew(prevSelected)\n\tif err == ErrNoNewPeers {\n\t\tl.Lock()\n\t\tpeer = l.choosePeer(nil, false /* avoidHost */)\n\t\tl.Unlock()\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\tif peer == nil {\n\t\treturn nil, ErrNoPeers\n\t}\n\treturn peer, nil\n}", "code_tokens": ["func", "(", "l", "*", "PeerList", ")", "Get", "(", "prevSelected", "map", "[", "string", "]", "struct", "{", "}", ")", "(", "*", "Peer", ",", "error", ")", "{", "peer", ",", "err", ":=", "l", ".", "GetNew", "(", "prevSelected", ")", "\n", "if", "err", "==", "ErrNoNewPeers", "{", "l", ".", "Lock", "(", ")", "\n", "peer", "=", "l", ".", "choosePeer", "(", "nil", ",", "false", "/* avoidHost */", ")", "\n", "l", ".", "Unlock", "(", ")", "\n", "}", "else", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "peer", "==", "nil", "{", "return", "nil", ",", "ErrNoPeers", "\n", "}", "\n", "return", "peer", ",", "nil", "\n", "}"], "docstring": "// Get returns a peer from the peer list, or nil if none can be found,\n// will avoid previously selected peers if possible.", "docstring_tokens": ["Get", "returns", "a", "peer", "from", "the", "peer", "list", "or", "nil", "if", "none", "can", "be", "found", "will", "avoid", "previously", "selected", "peers", "if", "possible", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/peer.go#L145-L158", "partition": "test"}
{"repo": "hashicorp/raft", "path": "net_transport.go", "func_name": "newNetPipeline", "original_string": "func newNetPipeline(trans *NetworkTransport, conn *netConn) *netPipeline {\n\tn := &netPipeline{\n\t\tconn:         conn,\n\t\ttrans:        trans,\n\t\tdoneCh:       make(chan AppendFuture, rpcMaxPipeline),\n\t\tinprogressCh: make(chan *appendFuture, rpcMaxPipeline),\n\t\tshutdownCh:   make(chan struct{}),\n\t}\n\tgo n.decodeResponses()\n\treturn n\n}", "language": "go", "code": "func newNetPipeline(trans *NetworkTransport, conn *netConn) *netPipeline {\n\tn := &netPipeline{\n\t\tconn:         conn,\n\t\ttrans:        trans,\n\t\tdoneCh:       make(chan AppendFuture, rpcMaxPipeline),\n\t\tinprogressCh: make(chan *appendFuture, rpcMaxPipeline),\n\t\tshutdownCh:   make(chan struct{}),\n\t}\n\tgo n.decodeResponses()\n\treturn n\n}", "code_tokens": ["func", "newNetPipeline", "(", "trans", "*", "NetworkTransport", ",", "conn", "*", "netConn", ")", "*", "netPipeline", "{", "n", ":=", "&", "netPipeline", "{", "conn", ":", "conn", ",", "trans", ":", "trans", ",", "doneCh", ":", "make", "(", "chan", "AppendFuture", ",", "rpcMaxPipeline", ")", ",", "inprogressCh", ":", "make", "(", "chan", "*", "appendFuture", ",", "rpcMaxPipeline", ")", ",", "shutdownCh", ":", "make", "(", "chan", "struct", "{", "}", ")", ",", "}", "\n", "go", "n", ".", "decodeResponses", "(", ")", "\n", "return", "n", "\n", "}"], "docstring": "// newNetPipeline is used to construct a netPipeline from a given\n// transport and connection.", "docstring_tokens": ["newNetPipeline", "is", "used", "to", "construct", "a", "netPipeline", "from", "a", "given", "transport", "and", "connection", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/net_transport.go#L672-L682", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "Do", "original_string": "func (p *WaitForDebuggerParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandWaitForDebugger, nil, nil)\n}", "language": "go", "code": "func (p *WaitForDebuggerParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandWaitForDebugger, nil, nil)\n}", "code_tokens": ["func", "(", "p", "*", "WaitForDebuggerParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandWaitForDebugger", ",", "nil", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Page.waitForDebugger against the provided context.", "docstring_tokens": ["Do", "executes", "Page", ".", "waitForDebugger", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L1368-L1370", "partition": "test"}
{"repo": "rightscale/rsc", "path": "cm15/codegen_client.go", "func_name": "IdentityProviderLocator", "original_string": "func (api *API) IdentityProviderLocator(href string) *IdentityProviderLocator {\n\treturn &IdentityProviderLocator{Href(href), api}\n}", "language": "go", "code": "func (api *API) IdentityProviderLocator(href string) *IdentityProviderLocator {\n\treturn &IdentityProviderLocator{Href(href), api}\n}", "code_tokens": ["func", "(", "api", "*", "API", ")", "IdentityProviderLocator", "(", "href", "string", ")", "*", "IdentityProviderLocator", "{", "return", "&", "IdentityProviderLocator", "{", "Href", "(", "href", ")", ",", "api", "}", "\n", "}"], "docstring": "// IdentityProviderLocator builds a locator from the given href.", "docstring_tokens": ["IdentityProviderLocator", "builds", "a", "locator", "from", "the", "given", "href", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L3500-L3502", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "overlay/overlay.go", "func_name": "Do", "original_string": "func (p *HideHighlightParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandHideHighlight, nil, nil)\n}", "language": "go", "code": "func (p *HideHighlightParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandHideHighlight, nil, nil)\n}", "code_tokens": ["func", "(", "p", "*", "HideHighlightParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandHideHighlight", ",", "nil", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Overlay.hideHighlight against the provided context.", "docstring_tokens": ["Do", "executes", "Overlay", ".", "hideHighlight", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/overlay.go#L99-L101", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "mvcc/watcher_group.go", "func_name": "watcherSetByKey", "original_string": "func (wg *watcherGroup) watcherSetByKey(key string) watcherSet {\n\twkeys := wg.keyWatchers[key]\n\twranges := wg.ranges.Stab(adt.NewStringAffinePoint(key))\n\n\t// zero-copy cases\n\tswitch {\n\tcase len(wranges) == 0:\n\t\t// no need to merge ranges or copy; reuse single-key set\n\t\treturn wkeys\n\tcase len(wranges) == 0 && len(wkeys) == 0:\n\t\treturn nil\n\tcase len(wranges) == 1 && len(wkeys) == 0:\n\t\treturn wranges[0].Val.(watcherSet)\n\t}\n\n\t// copy case\n\tret := make(watcherSet)\n\tret.union(wg.keyWatchers[key])\n\tfor _, item := range wranges {\n\t\tret.union(item.Val.(watcherSet))\n\t}\n\treturn ret\n}", "language": "go", "code": "func (wg *watcherGroup) watcherSetByKey(key string) watcherSet {\n\twkeys := wg.keyWatchers[key]\n\twranges := wg.ranges.Stab(adt.NewStringAffinePoint(key))\n\n\t// zero-copy cases\n\tswitch {\n\tcase len(wranges) == 0:\n\t\t// no need to merge ranges or copy; reuse single-key set\n\t\treturn wkeys\n\tcase len(wranges) == 0 && len(wkeys) == 0:\n\t\treturn nil\n\tcase len(wranges) == 1 && len(wkeys) == 0:\n\t\treturn wranges[0].Val.(watcherSet)\n\t}\n\n\t// copy case\n\tret := make(watcherSet)\n\tret.union(wg.keyWatchers[key])\n\tfor _, item := range wranges {\n\t\tret.union(item.Val.(watcherSet))\n\t}\n\treturn ret\n}", "code_tokens": ["func", "(", "wg", "*", "watcherGroup", ")", "watcherSetByKey", "(", "key", "string", ")", "watcherSet", "{", "wkeys", ":=", "wg", ".", "keyWatchers", "[", "key", "]", "\n", "wranges", ":=", "wg", ".", "ranges", ".", "Stab", "(", "adt", ".", "NewStringAffinePoint", "(", "key", ")", ")", "\n\n", "// zero-copy cases", "switch", "{", "case", "len", "(", "wranges", ")", "==", "0", ":", "// no need to merge ranges or copy; reuse single-key set", "return", "wkeys", "\n", "case", "len", "(", "wranges", ")", "==", "0", "&&", "len", "(", "wkeys", ")", "==", "0", ":", "return", "nil", "\n", "case", "len", "(", "wranges", ")", "==", "1", "&&", "len", "(", "wkeys", ")", "==", "0", ":", "return", "wranges", "[", "0", "]", ".", "Val", ".", "(", "watcherSet", ")", "\n", "}", "\n\n", "// copy case", "ret", ":=", "make", "(", "watcherSet", ")", "\n", "ret", ".", "union", "(", "wg", ".", "keyWatchers", "[", "key", "]", ")", "\n", "for", "_", ",", "item", ":=", "range", "wranges", "{", "ret", ".", "union", "(", "item", ".", "Val", ".", "(", "watcherSet", ")", ")", "\n", "}", "\n", "return", "ret", "\n", "}"], "docstring": "// watcherSetByKey gets the set of watchers that receive events on the given key.", "docstring_tokens": ["watcherSetByKey", "gets", "the", "set", "of", "watchers", "that", "receive", "events", "on", "the", "given", "key", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/mvcc/watcher_group.go#L270-L292", "partition": "test"}
{"repo": "golang/appengine", "path": "datastore/query.go", "func_name": "Count", "original_string": "func (q *Query) Count(c context.Context) (int, error) {\n\t// Check that the query is well-formed.\n\tif q.err != nil {\n\t\treturn 0, q.err\n\t}\n\n\t// Run a copy of the query, with keysOnly true (if we're not a projection,\n\t// since the two are incompatible), and an adjusted offset. We also set the\n\t// limit to zero, as we don't want any actual entity data, just the number\n\t// of skipped results.\n\tnewQ := q.clone()\n\tnewQ.keysOnly = len(newQ.projection) == 0\n\tnewQ.limit = 0\n\tif q.limit < 0 {\n\t\t// If the original query was unlimited, set the new query's offset to maximum.\n\t\tnewQ.offset = math.MaxInt32\n\t} else {\n\t\tnewQ.offset = q.offset + q.limit\n\t\tif newQ.offset < 0 {\n\t\t\t// Do the best we can, in the presence of overflow.\n\t\t\tnewQ.offset = math.MaxInt32\n\t\t}\n\t}\n\treq := &pb.Query{}\n\tif err := newQ.toProto(req, internal.FullyQualifiedAppID(c)); err != nil {\n\t\treturn 0, err\n\t}\n\tres := &pb.QueryResult{}\n\tif err := internal.Call(c, \"datastore_v3\", \"RunQuery\", req, res); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// n is the count we will return. For example, suppose that our original\n\t// query had an offset of 4 and a limit of 2008: the count will be 2008,\n\t// provided that there are at least 2012 matching entities. However, the\n\t// RPCs will only skip 1000 results at a time. The RPC sequence is:\n\t//   call RunQuery with (offset, limit) = (2012, 0)  // 2012 == newQ.offset\n\t//   response has (skippedResults, moreResults) = (1000, true)\n\t//   n += 1000  // n == 1000\n\t//   call Next     with (offset, limit) = (1012, 0)  // 1012 == newQ.offset - n\n\t//   response has (skippedResults, moreResults) = (1000, true)\n\t//   n += 1000  // n == 2000\n\t//   call Next     with (offset, limit) = (12, 0)    // 12 == newQ.offset - n\n\t//   response has (skippedResults, moreResults) = (12, false)\n\t//   n += 12    // n == 2012\n\t//   // exit the loop\n\t//   n -= 4     // n == 2008\n\tvar n int32\n\tfor {\n\t\t// The QueryResult should have no actual entity data, just skipped results.\n\t\tif len(res.Result) != 0 {\n\t\t\treturn 0, errors.New(\"datastore: internal error: Count request returned too much data\")\n\t\t}\n\t\tn += res.GetSkippedResults()\n\t\tif !res.GetMoreResults() {\n\t\t\tbreak\n\t\t}\n\t\tif err := callNext(c, res, newQ.offset-n, q.count); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tn -= q.offset\n\tif n < 0 {\n\t\t// If the offset was greater than the number of matching entities,\n\t\t// return 0 instead of negative.\n\t\tn = 0\n\t}\n\treturn int(n), nil\n}", "language": "go", "code": "func (q *Query) Count(c context.Context) (int, error) {\n\t// Check that the query is well-formed.\n\tif q.err != nil {\n\t\treturn 0, q.err\n\t}\n\n\t// Run a copy of the query, with keysOnly true (if we're not a projection,\n\t// since the two are incompatible), and an adjusted offset. We also set the\n\t// limit to zero, as we don't want any actual entity data, just the number\n\t// of skipped results.\n\tnewQ := q.clone()\n\tnewQ.keysOnly = len(newQ.projection) == 0\n\tnewQ.limit = 0\n\tif q.limit < 0 {\n\t\t// If the original query was unlimited, set the new query's offset to maximum.\n\t\tnewQ.offset = math.MaxInt32\n\t} else {\n\t\tnewQ.offset = q.offset + q.limit\n\t\tif newQ.offset < 0 {\n\t\t\t// Do the best we can, in the presence of overflow.\n\t\t\tnewQ.offset = math.MaxInt32\n\t\t}\n\t}\n\treq := &pb.Query{}\n\tif err := newQ.toProto(req, internal.FullyQualifiedAppID(c)); err != nil {\n\t\treturn 0, err\n\t}\n\tres := &pb.QueryResult{}\n\tif err := internal.Call(c, \"datastore_v3\", \"RunQuery\", req, res); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// n is the count we will return. For example, suppose that our original\n\t// query had an offset of 4 and a limit of 2008: the count will be 2008,\n\t// provided that there are at least 2012 matching entities. However, the\n\t// RPCs will only skip 1000 results at a time. The RPC sequence is:\n\t//   call RunQuery with (offset, limit) = (2012, 0)  // 2012 == newQ.offset\n\t//   response has (skippedResults, moreResults) = (1000, true)\n\t//   n += 1000  // n == 1000\n\t//   call Next     with (offset, limit) = (1012, 0)  // 1012 == newQ.offset - n\n\t//   response has (skippedResults, moreResults) = (1000, true)\n\t//   n += 1000  // n == 2000\n\t//   call Next     with (offset, limit) = (12, 0)    // 12 == newQ.offset - n\n\t//   response has (skippedResults, moreResults) = (12, false)\n\t//   n += 12    // n == 2012\n\t//   // exit the loop\n\t//   n -= 4     // n == 2008\n\tvar n int32\n\tfor {\n\t\t// The QueryResult should have no actual entity data, just skipped results.\n\t\tif len(res.Result) != 0 {\n\t\t\treturn 0, errors.New(\"datastore: internal error: Count request returned too much data\")\n\t\t}\n\t\tn += res.GetSkippedResults()\n\t\tif !res.GetMoreResults() {\n\t\t\tbreak\n\t\t}\n\t\tif err := callNext(c, res, newQ.offset-n, q.count); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tn -= q.offset\n\tif n < 0 {\n\t\t// If the offset was greater than the number of matching entities,\n\t\t// return 0 instead of negative.\n\t\tn = 0\n\t}\n\treturn int(n), nil\n}", "code_tokens": ["func", "(", "q", "*", "Query", ")", "Count", "(", "c", "context", ".", "Context", ")", "(", "int", ",", "error", ")", "{", "// Check that the query is well-formed.", "if", "q", ".", "err", "!=", "nil", "{", "return", "0", ",", "q", ".", "err", "\n", "}", "\n\n", "// Run a copy of the query, with keysOnly true (if we're not a projection,", "// since the two are incompatible), and an adjusted offset. We also set the", "// limit to zero, as we don't want any actual entity data, just the number", "// of skipped results.", "newQ", ":=", "q", ".", "clone", "(", ")", "\n", "newQ", ".", "keysOnly", "=", "len", "(", "newQ", ".", "projection", ")", "==", "0", "\n", "newQ", ".", "limit", "=", "0", "\n", "if", "q", ".", "limit", "<", "0", "{", "// If the original query was unlimited, set the new query's offset to maximum.", "newQ", ".", "offset", "=", "math", ".", "MaxInt32", "\n", "}", "else", "{", "newQ", ".", "offset", "=", "q", ".", "offset", "+", "q", ".", "limit", "\n", "if", "newQ", ".", "offset", "<", "0", "{", "// Do the best we can, in the presence of overflow.", "newQ", ".", "offset", "=", "math", ".", "MaxInt32", "\n", "}", "\n", "}", "\n", "req", ":=", "&", "pb", ".", "Query", "{", "}", "\n", "if", "err", ":=", "newQ", ".", "toProto", "(", "req", ",", "internal", ".", "FullyQualifiedAppID", "(", "c", ")", ")", ";", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n", "res", ":=", "&", "pb", ".", "QueryResult", "{", "}", "\n", "if", "err", ":=", "internal", ".", "Call", "(", "c", ",", "\"", "\"", ",", "\"", "\"", ",", "req", ",", "res", ")", ";", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n\n", "// n is the count we will return. For example, suppose that our original", "// query had an offset of 4 and a limit of 2008: the count will be 2008,", "// provided that there are at least 2012 matching entities. However, the", "// RPCs will only skip 1000 results at a time. The RPC sequence is:", "//   call RunQuery with (offset, limit) = (2012, 0)  // 2012 == newQ.offset", "//   response has (skippedResults, moreResults) = (1000, true)", "//   n += 1000  // n == 1000", "//   call Next     with (offset, limit) = (1012, 0)  // 1012 == newQ.offset - n", "//   response has (skippedResults, moreResults) = (1000, true)", "//   n += 1000  // n == 2000", "//   call Next     with (offset, limit) = (12, 0)    // 12 == newQ.offset - n", "//   response has (skippedResults, moreResults) = (12, false)", "//   n += 12    // n == 2012", "//   // exit the loop", "//   n -= 4     // n == 2008", "var", "n", "int32", "\n", "for", "{", "// The QueryResult should have no actual entity data, just skipped results.", "if", "len", "(", "res", ".", "Result", ")", "!=", "0", "{", "return", "0", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "n", "+=", "res", ".", "GetSkippedResults", "(", ")", "\n", "if", "!", "res", ".", "GetMoreResults", "(", ")", "{", "break", "\n", "}", "\n", "if", "err", ":=", "callNext", "(", "c", ",", "res", ",", "newQ", ".", "offset", "-", "n", ",", "q", ".", "count", ")", ";", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n", "}", "\n", "n", "-=", "q", ".", "offset", "\n", "if", "n", "<", "0", "{", "// If the offset was greater than the number of matching entities,", "// return 0 instead of negative.", "n", "=", "0", "\n", "}", "\n", "return", "int", "(", "n", ")", ",", "nil", "\n", "}"], "docstring": "// Count returns the number of results for the query.\n//\n// The running time and number of API calls made by Count scale linearly with\n// the sum of the query's offset and limit. Unless the result count is\n// expected to be small, it is best to specify a limit; otherwise Count will\n// continue until it finishes counting or the provided context expires.", "docstring_tokens": ["Count", "returns", "the", "number", "of", "results", "for", "the", "query", ".", "The", "running", "time", "and", "number", "of", "API", "calls", "made", "by", "Count", "scale", "linearly", "with", "the", "sum", "of", "the", "query", "s", "offset", "and", "limit", ".", "Unless", "the", "result", "count", "is", "expected", "to", "be", "small", "it", "is", "best", "to", "specify", "a", "limit", ";", "otherwise", "Count", "will", "continue", "until", "it", "finishes", "counting", "or", "the", "provided", "context", "expires", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/datastore/query.go#L374-L442", "partition": "test"}
{"repo": "go-opencv/go-opencv", "path": "opencv/cxcore.go", "func_name": "AddWithMask", "original_string": "func AddWithMask(src1, src2, dst, mask *IplImage) {\n\tC.cvAdd(\n\t\tunsafe.Pointer(src1),\n\t\tunsafe.Pointer(src2),\n\t\tunsafe.Pointer(dst),\n\t\tunsafe.Pointer(mask),\n\t)\n}", "language": "go", "code": "func AddWithMask(src1, src2, dst, mask *IplImage) {\n\tC.cvAdd(\n\t\tunsafe.Pointer(src1),\n\t\tunsafe.Pointer(src2),\n\t\tunsafe.Pointer(dst),\n\t\tunsafe.Pointer(mask),\n\t)\n}", "code_tokens": ["func", "AddWithMask", "(", "src1", ",", "src2", ",", "dst", ",", "mask", "*", "IplImage", ")", "{", "C", ".", "cvAdd", "(", "unsafe", ".", "Pointer", "(", "src1", ")", ",", "unsafe", ".", "Pointer", "(", "src2", ")", ",", "unsafe", ".", "Pointer", "(", "dst", ")", ",", "unsafe", ".", "Pointer", "(", "mask", ")", ",", ")", "\n", "}"], "docstring": "// Calculates the per-element sum of two arrays with a mask.\n//   dst = src1 + src2", "docstring_tokens": ["Calculates", "the", "per", "-", "element", "sum", "of", "two", "arrays", "with", "a", "mask", ".", "dst", "=", "src1", "+", "src2"], "sha": "a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db", "url": "https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxcore.go#L657-L664", "partition": "test"}
{"repo": "sclevine/agouti", "path": "matchers/selection_matchers.go", "func_name": "HaveAttribute", "original_string": "func HaveAttribute(attribute string, value string) types.GomegaMatcher {\n\treturn &internal.HaveAttributeMatcher{ExpectedAttribute: attribute, ExpectedValue: value}\n}", "language": "go", "code": "func HaveAttribute(attribute string, value string) types.GomegaMatcher {\n\treturn &internal.HaveAttributeMatcher{ExpectedAttribute: attribute, ExpectedValue: value}\n}", "code_tokens": ["func", "HaveAttribute", "(", "attribute", "string", ",", "value", "string", ")", "types", ".", "GomegaMatcher", "{", "return", "&", "internal", ".", "HaveAttributeMatcher", "{", "ExpectedAttribute", ":", "attribute", ",", "ExpectedValue", ":", "value", "}", "\n", "}"], "docstring": "// HaveAttribute passes when the expected attribute and value are present on the element.\n// This matcher will fail if the provided selection refers to more than one element.", "docstring_tokens": ["HaveAttribute", "passes", "when", "the", "expected", "attribute", "and", "value", "are", "present", "on", "the", "element", ".", "This", "matcher", "will", "fail", "if", "the", "provided", "selection", "refers", "to", "more", "than", "one", "element", "."], "sha": "96599c91888f1b1cf2dccc7f1776ba7f511909e5", "url": "https://github.com/sclevine/agouti/blob/96599c91888f1b1cf2dccc7f1776ba7f511909e5/matchers/selection_matchers.go#L28-L30", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd.go", "func_name": "RawWebsocket", "original_string": "func (r *ProtocolLXD) RawWebsocket(path string) (*websocket.Conn, error) {\n\treturn r.websocket(path)\n}", "language": "go", "code": "func (r *ProtocolLXD) RawWebsocket(path string) (*websocket.Conn, error) {\n\treturn r.websocket(path)\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "RawWebsocket", "(", "path", "string", ")", "(", "*", "websocket", ".", "Conn", ",", "error", ")", "{", "return", "r", ".", "websocket", "(", "path", ")", "\n", "}"], "docstring": "// RawWebsocket allows directly connection to LXD API websockets\n//\n// This should only be used by internal LXD tools.", "docstring_tokens": ["RawWebsocket", "allows", "directly", "connection", "to", "LXD", "API", "websockets", "This", "should", "only", "be", "used", "by", "internal", "LXD", "tools", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd.go#L120-L122", "partition": "test"}
{"repo": "goreleaser/archive", "path": "archive.go", "func_name": "New", "original_string": "func New(file *os.File) Archive {\n\tif filepath.Ext(file.Name()) == \".zip\" {\n\t\treturn zip.New(file)\n\t}\n\treturn tar.New(file)\n}", "language": "go", "code": "func New(file *os.File) Archive {\n\tif filepath.Ext(file.Name()) == \".zip\" {\n\t\treturn zip.New(file)\n\t}\n\treturn tar.New(file)\n}", "code_tokens": ["func", "New", "(", "file", "*", "os", ".", "File", ")", "Archive", "{", "if", "filepath", ".", "Ext", "(", "file", ".", "Name", "(", ")", ")", "==", "\"", "\"", "{", "return", "zip", ".", "New", "(", "file", ")", "\n", "}", "\n", "return", "tar", ".", "New", "(", "file", ")", "\n", "}"], "docstring": "// New archive\n// If the exentions of the target file is .zip, the archive will be in the zip\n// format, otherwise, it will be a tar.gz archive.", "docstring_tokens": ["New", "archive", "If", "the", "exentions", "of", "the", "target", "file", "is", ".", "zip", "the", "archive", "will", "be", "in", "the", "zip", "format", "otherwise", "it", "will", "be", "a", "tar", ".", "gz", "archive", "."], "sha": "9c6b0c177751034bab579499b81c69993ddfe563", "url": "https://github.com/goreleaser/archive/blob/9c6b0c177751034bab579499b81c69993ddfe563/archive.go#L22-L27", "partition": "test"}
{"repo": "hooklift/govix", "path": "vm.go", "func_name": "PowerState", "original_string": "func (v *VM) PowerState() (VMPowerState, error) {\n\tvar err C.VixError = C.VIX_OK\n\tvar state C.VixPowerState = 0x0\n\n\terr = C.get_property(v.handle,\n\t\tC.VIX_PROPERTY_VM_POWER_STATE,\n\t\tunsafe.Pointer(&state))\n\n\tif C.VIX_OK != err {\n\t\treturn VMPowerState(0x0), &Error{\n\t\t\tOperation: \"vm.PowerState\",\n\t\t\tCode:      int(err & 0xFFFF),\n\t\t\tText:      C.GoString(C.Vix_GetErrorText(err, nil)),\n\t\t}\n\t}\n\n\treturn VMPowerState(state), nil\n}", "language": "go", "code": "func (v *VM) PowerState() (VMPowerState, error) {\n\tvar err C.VixError = C.VIX_OK\n\tvar state C.VixPowerState = 0x0\n\n\terr = C.get_property(v.handle,\n\t\tC.VIX_PROPERTY_VM_POWER_STATE,\n\t\tunsafe.Pointer(&state))\n\n\tif C.VIX_OK != err {\n\t\treturn VMPowerState(0x0), &Error{\n\t\t\tOperation: \"vm.PowerState\",\n\t\t\tCode:      int(err & 0xFFFF),\n\t\t\tText:      C.GoString(C.Vix_GetErrorText(err, nil)),\n\t\t}\n\t}\n\n\treturn VMPowerState(state), nil\n}", "code_tokens": ["func", "(", "v", "*", "VM", ")", "PowerState", "(", ")", "(", "VMPowerState", ",", "error", ")", "{", "var", "err", "C", ".", "VixError", "=", "C", ".", "VIX_OK", "\n", "var", "state", "C", ".", "VixPowerState", "=", "0x0", "\n\n", "err", "=", "C", ".", "get_property", "(", "v", ".", "handle", ",", "C", ".", "VIX_PROPERTY_VM_POWER_STATE", ",", "unsafe", ".", "Pointer", "(", "&", "state", ")", ")", "\n\n", "if", "C", ".", "VIX_OK", "!=", "err", "{", "return", "VMPowerState", "(", "0x0", ")", ",", "&", "Error", "{", "Operation", ":", "\"", "\"", ",", "Code", ":", "int", "(", "err", "&", "0xFFFF", ")", ",", "Text", ":", "C", ".", "GoString", "(", "C", ".", "Vix_GetErrorText", "(", "err", ",", "nil", ")", ")", ",", "}", "\n", "}", "\n\n", "return", "VMPowerState", "(", "state", ")", ",", "nil", "\n", "}"], "docstring": "// PowerState returns power state of the virtual machine.", "docstring_tokens": ["PowerState", "returns", "power", "state", "of", "the", "virtual", "machine", "."], "sha": "063702285520a992b920fc1575e305dc9ffd6ffe", "url": "https://github.com/hooklift/govix/blob/063702285520a992b920fc1575e305dc9ffd6ffe/vm.go#L186-L203", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "memory/memory.go", "func_name": "Do", "original_string": "func (p *StartSamplingParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStartSampling, p, nil)\n}", "language": "go", "code": "func (p *StartSamplingParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStartSampling, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "StartSamplingParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandStartSampling", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Memory.startSampling against the provided context.", "docstring_tokens": ["Do", "executes", "Memory", ".", "startSampling", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/memory/memory.go#L157-L159", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/hashtree/db.go", "func_name": "Copy", "original_string": "func (h *dbHashTree) Copy() (HashTree, error) {\n\tif err := h.Hash(); err != nil {\n\t\treturn nil, err\n\t}\n\tr, w := io.Pipe()\n\tvar eg errgroup.Group\n\teg.Go(func() (retErr error) {\n\t\tdefer func() {\n\t\t\tif err := w.Close(); err != nil && retErr == nil {\n\t\t\t\tretErr = err\n\t\t\t}\n\t\t}()\n\t\treturn h.Serialize(w)\n\t})\n\tvar result HashTree\n\teg.Go(func() error {\n\t\tvar err error\n\t\tresult, err = DeserializeDBHashTree(pathlib.Dir(h.Path()), r)\n\t\treturn err\n\t})\n\tif err := eg.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}", "language": "go", "code": "func (h *dbHashTree) Copy() (HashTree, error) {\n\tif err := h.Hash(); err != nil {\n\t\treturn nil, err\n\t}\n\tr, w := io.Pipe()\n\tvar eg errgroup.Group\n\teg.Go(func() (retErr error) {\n\t\tdefer func() {\n\t\t\tif err := w.Close(); err != nil && retErr == nil {\n\t\t\t\tretErr = err\n\t\t\t}\n\t\t}()\n\t\treturn h.Serialize(w)\n\t})\n\tvar result HashTree\n\teg.Go(func() error {\n\t\tvar err error\n\t\tresult, err = DeserializeDBHashTree(pathlib.Dir(h.Path()), r)\n\t\treturn err\n\t})\n\tif err := eg.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}", "code_tokens": ["func", "(", "h", "*", "dbHashTree", ")", "Copy", "(", ")", "(", "HashTree", ",", "error", ")", "{", "if", "err", ":=", "h", ".", "Hash", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "r", ",", "w", ":=", "io", ".", "Pipe", "(", ")", "\n", "var", "eg", "errgroup", ".", "Group", "\n", "eg", ".", "Go", "(", "func", "(", ")", "(", "retErr", "error", ")", "{", "defer", "func", "(", ")", "{", "if", "err", ":=", "w", ".", "Close", "(", ")", ";", "err", "!=", "nil", "&&", "retErr", "==", "nil", "{", "retErr", "=", "err", "\n", "}", "\n", "}", "(", ")", "\n", "return", "h", ".", "Serialize", "(", "w", ")", "\n", "}", ")", "\n", "var", "result", "HashTree", "\n", "eg", ".", "Go", "(", "func", "(", ")", "error", "{", "var", "err", "error", "\n", "result", ",", "err", "=", "DeserializeDBHashTree", "(", "pathlib", ".", "Dir", "(", "h", ".", "Path", "(", ")", ")", ",", "r", ")", "\n", "return", "err", "\n", "}", ")", "\n", "if", "err", ":=", "eg", ".", "Wait", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "result", ",", "nil", "\n", "}"], "docstring": "// Copy returns a copy of the hashtree.", "docstring_tokens": ["Copy", "returns", "a", "copy", "of", "the", "hashtree", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/db.go#L620-L644", "partition": "test"}
{"repo": "codegangsta/martini-contrib", "path": "cors/cors.go", "func_name": "IsOriginAllowed", "original_string": "func (o *Options) IsOriginAllowed(origin string) (allowed bool) {\n\tfor _, pattern := range o.AllowOrigins {\n\t\tallowed, _ = regexp.MatchString(pattern, origin)\n\t\tif allowed {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}", "language": "go", "code": "func (o *Options) IsOriginAllowed(origin string) (allowed bool) {\n\tfor _, pattern := range o.AllowOrigins {\n\t\tallowed, _ = regexp.MatchString(pattern, origin)\n\t\tif allowed {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "o", "*", "Options", ")", "IsOriginAllowed", "(", "origin", "string", ")", "(", "allowed", "bool", ")", "{", "for", "_", ",", "pattern", ":=", "range", "o", ".", "AllowOrigins", "{", "allowed", ",", "_", "=", "regexp", ".", "MatchString", "(", "pattern", ",", "origin", ")", "\n", "if", "allowed", "{", "return", "\n", "}", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// Looks up if the origin matches one of the patterns\n// provided in Options.AllowOrigins patterns.", "docstring_tokens": ["Looks", "up", "if", "the", "origin", "matches", "one", "of", "the", "patterns", "provided", "in", "Options", ".", "AllowOrigins", "patterns", "."], "sha": "8ce6181c2609699e4c7cd30994b76a850a9cdadc", "url": "https://github.com/codegangsta/martini-contrib/blob/8ce6181c2609699e4c7cd30994b76a850a9cdadc/cors/cors.go#L129-L137", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "render/func.go", "func_name": "Render", "original_string": "func (s funcRenderer) Render(w io.Writer, data Data) error {\n\treturn s.renderFunc(w, data)\n}", "language": "go", "code": "func (s funcRenderer) Render(w io.Writer, data Data) error {\n\treturn s.renderFunc(w, data)\n}", "code_tokens": ["func", "(", "s", "funcRenderer", ")", "Render", "(", "w", "io", ".", "Writer", ",", "data", "Data", ")", "error", "{", "return", "s", ".", "renderFunc", "(", "w", ",", "data", ")", "\n", "}"], "docstring": "// Render the provided Data to the provider Writer using the\n// RendererFunc provide.", "docstring_tokens": ["Render", "the", "provided", "Data", "to", "the", "provider", "Writer", "using", "the", "RendererFunc", "provide", "."], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/render/func.go#L22-L24", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "vm/state.go", "func_name": "Warnf", "original_string": "func (st *State) Warnf(format string, args ...interface{}) {\n\tst.warn.Write([]byte(fmt.Sprintf(format, args...)))\n}", "language": "go", "code": "func (st *State) Warnf(format string, args ...interface{}) {\n\tst.warn.Write([]byte(fmt.Sprintf(format, args...)))\n}", "code_tokens": ["func", "(", "st", "*", "State", ")", "Warnf", "(", "format", "string", ",", "args", "...", "interface", "{", "}", ")", "{", "st", ".", "warn", ".", "Write", "(", "[", "]", "byte", "(", "fmt", ".", "Sprintf", "(", "format", ",", "args", "...", ")", ")", ")", "\n", "}"], "docstring": "// Warnf is used to generate warnings during virtual machine execution", "docstring_tokens": ["Warnf", "is", "used", "to", "generate", "warnings", "during", "virtual", "machine", "execution"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/vm/state.go#L91-L93", "partition": "test"}
{"repo": "kubicorn/kubicorn", "path": "apis/cluster/cluster.go", "func_name": "SetProviderConfig", "original_string": "func (c *Cluster) SetProviderConfig(config *ControlPlaneProviderConfig) error {\n\tbytes, err := json.Marshal(config)\n\tif err != nil {\n\t\tlogger.Critical(\"Unable to marshal provider config: %v\", err)\n\t\treturn err\n\t}\n\tstr := string(bytes)\n\tc.ClusterAPI.Spec.ProviderConfig = str\n\treturn nil\n}", "language": "go", "code": "func (c *Cluster) SetProviderConfig(config *ControlPlaneProviderConfig) error {\n\tbytes, err := json.Marshal(config)\n\tif err != nil {\n\t\tlogger.Critical(\"Unable to marshal provider config: %v\", err)\n\t\treturn err\n\t}\n\tstr := string(bytes)\n\tc.ClusterAPI.Spec.ProviderConfig = str\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "SetProviderConfig", "(", "config", "*", "ControlPlaneProviderConfig", ")", "error", "{", "bytes", ",", "err", ":=", "json", ".", "Marshal", "(", "config", ")", "\n", "if", "err", "!=", "nil", "{", "logger", ".", "Critical", "(", "\"", "\"", ",", "err", ")", "\n", "return", "err", "\n", "}", "\n", "str", ":=", "string", "(", "bytes", ")", "\n", "c", ".", "ClusterAPI", ".", "Spec", ".", "ProviderConfig", "=", "str", "\n", "return", "nil", "\n", "}"], "docstring": "// SetProviderConfig is a convenience method that will attempt\n// to set a provider config on a particular cluster. Just like\n// it's counterpart ProviderConfig this makes working with the legacy API much easier.", "docstring_tokens": ["SetProviderConfig", "is", "a", "convenience", "method", "that", "will", "attempt", "to", "set", "a", "provider", "config", "on", "a", "particular", "cluster", ".", "Just", "like", "it", "s", "counterpart", "ProviderConfig", "this", "makes", "working", "with", "the", "legacy", "API", "much", "easier", "."], "sha": "c4a4b80994b4333709c0f8164faabd801866b986", "url": "https://github.com/kubicorn/kubicorn/blob/c4a4b80994b4333709c0f8164faabd801866b986/apis/cluster/cluster.go#L90-L99", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "internal/version/version.go", "func_name": "Compare", "original_string": "func (x Version) Compare(y Version) int {\n\tn := len(x)\n\tif len(y) < n {\n\t\tn = len(y)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tcmp := x[i] - y[i]\n\t\tif cmp != 0 {\n\t\t\treturn cmp\n\t\t}\n\t}\n\treturn len(x) - len(y)\n}", "language": "go", "code": "func (x Version) Compare(y Version) int {\n\tn := len(x)\n\tif len(y) < n {\n\t\tn = len(y)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tcmp := x[i] - y[i]\n\t\tif cmp != 0 {\n\t\t\treturn cmp\n\t\t}\n\t}\n\treturn len(x) - len(y)\n}", "code_tokens": ["func", "(", "x", "Version", ")", "Compare", "(", "y", "Version", ")", "int", "{", "n", ":=", "len", "(", "x", ")", "\n", "if", "len", "(", "y", ")", "<", "n", "{", "n", "=", "len", "(", "y", ")", "\n", "}", "\n", "for", "i", ":=", "0", ";", "i", "<", "n", ";", "i", "++", "{", "cmp", ":=", "x", "[", "i", "]", "-", "y", "[", "i", "]", "\n", "if", "cmp", "!=", "0", "{", "return", "cmp", "\n", "}", "\n", "}", "\n", "return", "len", "(", "x", ")", "-", "len", "(", "y", ")", "\n", "}"], "docstring": "// Compare returns an integer comparing two versions lexicographically.", "docstring_tokens": ["Compare", "returns", "an", "integer", "comparing", "two", "versions", "lexicographically", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/internal/version/version.go#L37-L49", "partition": "test"}
{"repo": "malice-plugins/go-plugin-utils", "path": "utils/utils.go", "func_name": "RunCommand", "original_string": "func RunCommand(ctx context.Context, cmd string, args ...string) (string, error) {\n\n\tvar c *exec.Cmd\n\n\tif ctx != nil {\n\t\tc = exec.CommandContext(ctx, cmd, args...)\n\t} else {\n\t\tc = exec.Command(cmd, args...)\n\t}\n\n\toutput, err := c.Output()\n\tif err != nil {\n\t\treturn string(output), err\n\t}\n\n\t// check for exec context timeout\n\tif ctx != nil {\n\t\tif ctx.Err() == context.DeadlineExceeded {\n\t\t\treturn \"\", fmt.Errorf(\"command %s timed out\", cmd)\n\t\t}\n\t}\n\n\treturn string(output), nil\n}", "language": "go", "code": "func RunCommand(ctx context.Context, cmd string, args ...string) (string, error) {\n\n\tvar c *exec.Cmd\n\n\tif ctx != nil {\n\t\tc = exec.CommandContext(ctx, cmd, args...)\n\t} else {\n\t\tc = exec.Command(cmd, args...)\n\t}\n\n\toutput, err := c.Output()\n\tif err != nil {\n\t\treturn string(output), err\n\t}\n\n\t// check for exec context timeout\n\tif ctx != nil {\n\t\tif ctx.Err() == context.DeadlineExceeded {\n\t\t\treturn \"\", fmt.Errorf(\"command %s timed out\", cmd)\n\t\t}\n\t}\n\n\treturn string(output), nil\n}", "code_tokens": ["func", "RunCommand", "(", "ctx", "context", ".", "Context", ",", "cmd", "string", ",", "args", "...", "string", ")", "(", "string", ",", "error", ")", "{", "var", "c", "*", "exec", ".", "Cmd", "\n\n", "if", "ctx", "!=", "nil", "{", "c", "=", "exec", ".", "CommandContext", "(", "ctx", ",", "cmd", ",", "args", "...", ")", "\n", "}", "else", "{", "c", "=", "exec", ".", "Command", "(", "cmd", ",", "args", "...", ")", "\n", "}", "\n\n", "output", ",", "err", ":=", "c", ".", "Output", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "string", "(", "output", ")", ",", "err", "\n", "}", "\n\n", "// check for exec context timeout", "if", "ctx", "!=", "nil", "{", "if", "ctx", ".", "Err", "(", ")", "==", "context", ".", "DeadlineExceeded", "{", "return", "\"", "\"", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "cmd", ")", "\n", "}", "\n", "}", "\n\n", "return", "string", "(", "output", ")", ",", "nil", "\n", "}"], "docstring": "// RunCommand runs cmd on file", "docstring_tokens": ["RunCommand", "runs", "cmd", "on", "file"], "sha": "9ee76663c3b0a531b8c529f03f12a5a84ff9b61b", "url": "https://github.com/malice-plugins/go-plugin-utils/blob/9ee76663c3b0a531b8c529f03f12a5a84ff9b61b/utils/utils.go#L100-L123", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "status.go", "func_name": "makeUnicastRouteStatusSlice", "original_string": "func makeUnicastRouteStatusSlice(r *routes) []unicastRouteStatus {\n\tr.RLock()\n\tdefer r.RUnlock()\n\n\tvar slice []unicastRouteStatus\n\tfor dest, via := range r.unicast {\n\t\tslice = append(slice, unicastRouteStatus{dest.String(), via.String()})\n\t}\n\treturn slice\n}", "language": "go", "code": "func makeUnicastRouteStatusSlice(r *routes) []unicastRouteStatus {\n\tr.RLock()\n\tdefer r.RUnlock()\n\n\tvar slice []unicastRouteStatus\n\tfor dest, via := range r.unicast {\n\t\tslice = append(slice, unicastRouteStatus{dest.String(), via.String()})\n\t}\n\treturn slice\n}", "code_tokens": ["func", "makeUnicastRouteStatusSlice", "(", "r", "*", "routes", ")", "[", "]", "unicastRouteStatus", "{", "r", ".", "RLock", "(", ")", "\n", "defer", "r", ".", "RUnlock", "(", ")", "\n\n", "var", "slice", "[", "]", "unicastRouteStatus", "\n", "for", "dest", ",", "via", ":=", "range", "r", ".", "unicast", "{", "slice", "=", "append", "(", "slice", ",", "unicastRouteStatus", "{", "dest", ".", "String", "(", ")", ",", "via", ".", "String", "(", ")", "}", ")", "\n", "}", "\n", "return", "slice", "\n", "}"], "docstring": "// makeUnicastRouteStatusSlice takes a snapshot of the unicast routes in routes.", "docstring_tokens": ["makeUnicastRouteStatusSlice", "takes", "a", "snapshot", "of", "the", "unicast", "routes", "in", "routes", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/status.go#L116-L125", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/transport/listener_tls.go", "func_name": "acceptLoop", "original_string": "func (l *tlsListener) acceptLoop() {\n\tvar wg sync.WaitGroup\n\tvar pendingMu sync.Mutex\n\n\tpending := make(map[net.Conn]struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer func() {\n\t\tcancel()\n\t\tpendingMu.Lock()\n\t\tfor c := range pending {\n\t\t\tc.Close()\n\t\t}\n\t\tpendingMu.Unlock()\n\t\twg.Wait()\n\t\tclose(l.donec)\n\t}()\n\n\tfor {\n\t\tconn, err := l.Listener.Accept()\n\t\tif err != nil {\n\t\t\tl.err = err\n\t\t\treturn\n\t\t}\n\n\t\tpendingMu.Lock()\n\t\tpending[conn] = struct{}{}\n\t\tpendingMu.Unlock()\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tif conn != nil {\n\t\t\t\t\tconn.Close()\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}()\n\n\t\t\ttlsConn := conn.(*tls.Conn)\n\t\t\therr := tlsConn.Handshake()\n\t\t\tpendingMu.Lock()\n\t\t\tdelete(pending, conn)\n\t\t\tpendingMu.Unlock()\n\n\t\t\tif herr != nil {\n\t\t\t\tl.handshakeFailure(tlsConn, herr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := l.check(ctx, tlsConn); err != nil {\n\t\t\t\tl.handshakeFailure(tlsConn, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase l.connc <- tlsConn:\n\t\t\t\tconn = nil\n\t\t\tcase <-ctx.Done():\n\t\t\t}\n\t\t}()\n\t}\n}", "language": "go", "code": "func (l *tlsListener) acceptLoop() {\n\tvar wg sync.WaitGroup\n\tvar pendingMu sync.Mutex\n\n\tpending := make(map[net.Conn]struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer func() {\n\t\tcancel()\n\t\tpendingMu.Lock()\n\t\tfor c := range pending {\n\t\t\tc.Close()\n\t\t}\n\t\tpendingMu.Unlock()\n\t\twg.Wait()\n\t\tclose(l.donec)\n\t}()\n\n\tfor {\n\t\tconn, err := l.Listener.Accept()\n\t\tif err != nil {\n\t\t\tl.err = err\n\t\t\treturn\n\t\t}\n\n\t\tpendingMu.Lock()\n\t\tpending[conn] = struct{}{}\n\t\tpendingMu.Unlock()\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tif conn != nil {\n\t\t\t\t\tconn.Close()\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}()\n\n\t\t\ttlsConn := conn.(*tls.Conn)\n\t\t\therr := tlsConn.Handshake()\n\t\t\tpendingMu.Lock()\n\t\t\tdelete(pending, conn)\n\t\t\tpendingMu.Unlock()\n\n\t\t\tif herr != nil {\n\t\t\t\tl.handshakeFailure(tlsConn, herr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := l.check(ctx, tlsConn); err != nil {\n\t\t\t\tl.handshakeFailure(tlsConn, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase l.connc <- tlsConn:\n\t\t\t\tconn = nil\n\t\t\tcase <-ctx.Done():\n\t\t\t}\n\t\t}()\n\t}\n}", "code_tokens": ["func", "(", "l", "*", "tlsListener", ")", "acceptLoop", "(", ")", "{", "var", "wg", "sync", ".", "WaitGroup", "\n", "var", "pendingMu", "sync", ".", "Mutex", "\n\n", "pending", ":=", "make", "(", "map", "[", "net", ".", "Conn", "]", "struct", "{", "}", ")", "\n", "ctx", ",", "cancel", ":=", "context", ".", "WithCancel", "(", "context", ".", "Background", "(", ")", ")", "\n", "defer", "func", "(", ")", "{", "cancel", "(", ")", "\n", "pendingMu", ".", "Lock", "(", ")", "\n", "for", "c", ":=", "range", "pending", "{", "c", ".", "Close", "(", ")", "\n", "}", "\n", "pendingMu", ".", "Unlock", "(", ")", "\n", "wg", ".", "Wait", "(", ")", "\n", "close", "(", "l", ".", "donec", ")", "\n", "}", "(", ")", "\n\n", "for", "{", "conn", ",", "err", ":=", "l", ".", "Listener", ".", "Accept", "(", ")", "\n", "if", "err", "!=", "nil", "{", "l", ".", "err", "=", "err", "\n", "return", "\n", "}", "\n\n", "pendingMu", ".", "Lock", "(", ")", "\n", "pending", "[", "conn", "]", "=", "struct", "{", "}", "{", "}", "\n", "pendingMu", ".", "Unlock", "(", ")", "\n\n", "wg", ".", "Add", "(", "1", ")", "\n", "go", "func", "(", ")", "{", "defer", "func", "(", ")", "{", "if", "conn", "!=", "nil", "{", "conn", ".", "Close", "(", ")", "\n", "}", "\n", "wg", ".", "Done", "(", ")", "\n", "}", "(", ")", "\n\n", "tlsConn", ":=", "conn", ".", "(", "*", "tls", ".", "Conn", ")", "\n", "herr", ":=", "tlsConn", ".", "Handshake", "(", ")", "\n", "pendingMu", ".", "Lock", "(", ")", "\n", "delete", "(", "pending", ",", "conn", ")", "\n", "pendingMu", ".", "Unlock", "(", ")", "\n\n", "if", "herr", "!=", "nil", "{", "l", ".", "handshakeFailure", "(", "tlsConn", ",", "herr", ")", "\n", "return", "\n", "}", "\n", "if", "err", ":=", "l", ".", "check", "(", "ctx", ",", "tlsConn", ")", ";", "err", "!=", "nil", "{", "l", ".", "handshakeFailure", "(", "tlsConn", ",", "err", ")", "\n", "return", "\n", "}", "\n\n", "select", "{", "case", "l", ".", "connc", "<-", "tlsConn", ":", "conn", "=", "nil", "\n", "case", "<-", "ctx", ".", "Done", "(", ")", ":", "}", "\n", "}", "(", ")", "\n", "}", "\n", "}"], "docstring": "// acceptLoop launches each TLS handshake in a separate goroutine\n// to prevent a hanging TLS connection from blocking other connections.", "docstring_tokens": ["acceptLoop", "launches", "each", "TLS", "handshake", "in", "a", "separate", "goroutine", "to", "prevent", "a", "hanging", "TLS", "connection", "from", "blocking", "other", "connections", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/transport/listener_tls.go#L108-L167", "partition": "test"}
{"repo": "btcsuite/btclog", "path": "log.go", "func_name": "Warn", "original_string": "func (l *slog) Warn(args ...interface{}) {\n\tlvl := l.Level()\n\tif lvl <= LevelWarn {\n\t\tl.b.print(\"WRN\", l.tag, args...)\n\t}\n}", "language": "go", "code": "func (l *slog) Warn(args ...interface{}) {\n\tlvl := l.Level()\n\tif lvl <= LevelWarn {\n\t\tl.b.print(\"WRN\", l.tag, args...)\n\t}\n}", "code_tokens": ["func", "(", "l", "*", "slog", ")", "Warn", "(", "args", "...", "interface", "{", "}", ")", "{", "lvl", ":=", "l", ".", "Level", "(", ")", "\n", "if", "lvl", "<=", "LevelWarn", "{", "l", ".", "b", ".", "print", "(", "\"", "\"", ",", "l", ".", "tag", ",", "args", "...", ")", "\n", "}", "\n", "}"], "docstring": "// Warn formats message using the default formats for its operands, prepends\n// the prefix as necessary, and writes to log with LevelWarn.\n//\n// This is part of the Logger interface implementation.", "docstring_tokens": ["Warn", "formats", "message", "using", "the", "default", "formats", "for", "its", "operands", "prepends", "the", "prefix", "as", "necessary", "and", "writes", "to", "log", "with", "LevelWarn", ".", "This", "is", "part", "of", "the", "Logger", "interface", "implementation", "."], "sha": "84c8d2346e9fc8c7b947e243b9c24e6df9fd206a", "url": "https://github.com/btcsuite/btclog/blob/84c8d2346e9fc8c7b947e243b9c24e6df9fd206a/log.go#L399-L404", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "ValidEnum", "original_string": "func (e BucketEntryType) ValidEnum(v int32) bool {\n\t_, ok := bucketEntryTypeMap[v]\n\treturn ok\n}", "language": "go", "code": "func (e BucketEntryType) ValidEnum(v int32) bool {\n\t_, ok := bucketEntryTypeMap[v]\n\treturn ok\n}", "code_tokens": ["func", "(", "e", "BucketEntryType", ")", "ValidEnum", "(", "v", "int32", ")", "bool", "{", "_", ",", "ok", ":=", "bucketEntryTypeMap", "[", "v", "]", "\n", "return", "ok", "\n", "}"], "docstring": "// ValidEnum validates a proposed value for this enum.  Implements\n// the Enum interface for BucketEntryType", "docstring_tokens": ["ValidEnum", "validates", "a", "proposed", "value", "for", "this", "enum", ".", "Implements", "the", "Enum", "interface", "for", "BucketEntryType"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L5187-L5190", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/endpoints/socket.go", "func_name": "socketUnixSetOwnership", "original_string": "func socketUnixSetOwnership(path string, group string) error {\n\tvar gid int\n\tvar err error\n\n\tif group != \"\" {\n\t\tgid, err = shared.GroupId(group)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot get group ID of '%s': %v\", group, err)\n\t\t}\n\t} else {\n\t\tgid = os.Getgid()\n\t}\n\n\terr = os.Chown(path, os.Getuid(), gid)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"cannot change ownership on local socket: %v\", err)\n\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func socketUnixSetOwnership(path string, group string) error {\n\tvar gid int\n\tvar err error\n\n\tif group != \"\" {\n\t\tgid, err = shared.GroupId(group)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot get group ID of '%s': %v\", group, err)\n\t\t}\n\t} else {\n\t\tgid = os.Getgid()\n\t}\n\n\terr = os.Chown(path, os.Getuid(), gid)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"cannot change ownership on local socket: %v\", err)\n\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "socketUnixSetOwnership", "(", "path", "string", ",", "group", "string", ")", "error", "{", "var", "gid", "int", "\n", "var", "err", "error", "\n\n", "if", "group", "!=", "\"", "\"", "{", "gid", ",", "err", "=", "shared", ".", "GroupId", "(", "group", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "group", ",", "err", ")", "\n", "}", "\n", "}", "else", "{", "gid", "=", "os", ".", "Getgid", "(", ")", "\n", "}", "\n\n", "err", "=", "os", ".", "Chown", "(", "path", ",", "os", ".", "Getuid", "(", ")", ",", "gid", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Change the ownership of the given unix socket file,", "docstring_tokens": ["Change", "the", "ownership", "of", "the", "given", "unix", "socket", "file"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/endpoints/socket.go#L87-L107", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "network/network.go", "func_name": "Do", "original_string": "func (p *EmulateNetworkConditionsParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandEmulateNetworkConditions, p, nil)\n}", "language": "go", "code": "func (p *EmulateNetworkConditionsParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandEmulateNetworkConditions, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "EmulateNetworkConditionsParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandEmulateNetworkConditions", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Network.emulateNetworkConditions against the provided context.", "docstring_tokens": ["Do", "executes", "Network", ".", "emulateNetworkConditions", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/network.go#L237-L239", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "status.go", "func_name": "NewStatus", "original_string": "func NewStatus(router *Router) *Status {\n\treturn &Status{\n\t\tProtocol:           Protocol,\n\t\tProtocolMinVersion: int(router.ProtocolMinVersion),\n\t\tProtocolMaxVersion: ProtocolMaxVersion,\n\t\tEncryption:         router.usingPassword(),\n\t\tPeerDiscovery:      router.PeerDiscovery,\n\t\tName:               router.Ourself.Name.String(),\n\t\tNickName:           router.Ourself.NickName,\n\t\tPort:               router.Port,\n\t\tPeers:              makePeerStatusSlice(router.Peers),\n\t\tUnicastRoutes:      makeUnicastRouteStatusSlice(router.Routes),\n\t\tBroadcastRoutes:    makeBroadcastRouteStatusSlice(router.Routes),\n\t\tConnections:        makeLocalConnectionStatusSlice(router.ConnectionMaker),\n\t\tTerminationCount:   router.ConnectionMaker.terminationCount,\n\t\tTargets:            router.ConnectionMaker.Targets(false),\n\t\tOverlayDiagnostics: router.Overlay.Diagnostics(),\n\t\tTrustedSubnets:     makeTrustedSubnetsSlice(router.TrustedSubnets),\n\t}\n}", "language": "go", "code": "func NewStatus(router *Router) *Status {\n\treturn &Status{\n\t\tProtocol:           Protocol,\n\t\tProtocolMinVersion: int(router.ProtocolMinVersion),\n\t\tProtocolMaxVersion: ProtocolMaxVersion,\n\t\tEncryption:         router.usingPassword(),\n\t\tPeerDiscovery:      router.PeerDiscovery,\n\t\tName:               router.Ourself.Name.String(),\n\t\tNickName:           router.Ourself.NickName,\n\t\tPort:               router.Port,\n\t\tPeers:              makePeerStatusSlice(router.Peers),\n\t\tUnicastRoutes:      makeUnicastRouteStatusSlice(router.Routes),\n\t\tBroadcastRoutes:    makeBroadcastRouteStatusSlice(router.Routes),\n\t\tConnections:        makeLocalConnectionStatusSlice(router.ConnectionMaker),\n\t\tTerminationCount:   router.ConnectionMaker.terminationCount,\n\t\tTargets:            router.ConnectionMaker.Targets(false),\n\t\tOverlayDiagnostics: router.Overlay.Diagnostics(),\n\t\tTrustedSubnets:     makeTrustedSubnetsSlice(router.TrustedSubnets),\n\t}\n}", "code_tokens": ["func", "NewStatus", "(", "router", "*", "Router", ")", "*", "Status", "{", "return", "&", "Status", "{", "Protocol", ":", "Protocol", ",", "ProtocolMinVersion", ":", "int", "(", "router", ".", "ProtocolMinVersion", ")", ",", "ProtocolMaxVersion", ":", "ProtocolMaxVersion", ",", "Encryption", ":", "router", ".", "usingPassword", "(", ")", ",", "PeerDiscovery", ":", "router", ".", "PeerDiscovery", ",", "Name", ":", "router", ".", "Ourself", ".", "Name", ".", "String", "(", ")", ",", "NickName", ":", "router", ".", "Ourself", ".", "NickName", ",", "Port", ":", "router", ".", "Port", ",", "Peers", ":", "makePeerStatusSlice", "(", "router", ".", "Peers", ")", ",", "UnicastRoutes", ":", "makeUnicastRouteStatusSlice", "(", "router", ".", "Routes", ")", ",", "BroadcastRoutes", ":", "makeBroadcastRouteStatusSlice", "(", "router", ".", "Routes", ")", ",", "Connections", ":", "makeLocalConnectionStatusSlice", "(", "router", ".", "ConnectionMaker", ")", ",", "TerminationCount", ":", "router", ".", "ConnectionMaker", ".", "terminationCount", ",", "Targets", ":", "router", ".", "ConnectionMaker", ".", "Targets", "(", "false", ")", ",", "OverlayDiagnostics", ":", "router", ".", "Overlay", ".", "Diagnostics", "(", ")", ",", "TrustedSubnets", ":", "makeTrustedSubnetsSlice", "(", "router", ".", "TrustedSubnets", ")", ",", "}", "\n", "}"], "docstring": "// NewStatus returns a Status object, taken as a snapshot from the router.", "docstring_tokens": ["NewStatus", "returns", "a", "Status", "object", "taken", "as", "a", "snapshot", "from", "the", "router", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/status.go#L30-L49", "partition": "test"}
{"repo": "geoffgarside/ber", "path": "ber.go", "func_name": "parseBitString", "original_string": "func parseBitString(bytes []byte) (ret asn1.BitString, err error) {\n\tif len(bytes) == 0 {\n\t\terr = asn1.SyntaxError{Msg: \"zero length BIT STRING\"}\n\t\treturn\n\t}\n\tpaddingBits := int(bytes[0])\n\tif paddingBits > 7 ||\n\t\tlen(bytes) == 1 && paddingBits > 0 ||\n\t\tbytes[len(bytes)-1]&((1<<bytes[0])-1) != 0 {\n\t\terr = asn1.SyntaxError{Msg: \"invalid padding bits in BIT STRING\"}\n\t\treturn\n\t}\n\tret.BitLength = (len(bytes)-1)*8 - paddingBits\n\tret.Bytes = bytes[1:]\n\treturn\n}", "language": "go", "code": "func parseBitString(bytes []byte) (ret asn1.BitString, err error) {\n\tif len(bytes) == 0 {\n\t\terr = asn1.SyntaxError{Msg: \"zero length BIT STRING\"}\n\t\treturn\n\t}\n\tpaddingBits := int(bytes[0])\n\tif paddingBits > 7 ||\n\t\tlen(bytes) == 1 && paddingBits > 0 ||\n\t\tbytes[len(bytes)-1]&((1<<bytes[0])-1) != 0 {\n\t\terr = asn1.SyntaxError{Msg: \"invalid padding bits in BIT STRING\"}\n\t\treturn\n\t}\n\tret.BitLength = (len(bytes)-1)*8 - paddingBits\n\tret.Bytes = bytes[1:]\n\treturn\n}", "code_tokens": ["func", "parseBitString", "(", "bytes", "[", "]", "byte", ")", "(", "ret", "asn1", ".", "BitString", ",", "err", "error", ")", "{", "if", "len", "(", "bytes", ")", "==", "0", "{", "err", "=", "asn1", ".", "SyntaxError", "{", "Msg", ":", "\"", "\"", "}", "\n", "return", "\n", "}", "\n", "paddingBits", ":=", "int", "(", "bytes", "[", "0", "]", ")", "\n", "if", "paddingBits", ">", "7", "||", "len", "(", "bytes", ")", "==", "1", "&&", "paddingBits", ">", "0", "||", "bytes", "[", "len", "(", "bytes", ")", "-", "1", "]", "&", "(", "(", "1", "<<", "bytes", "[", "0", "]", ")", "-", "1", ")", "!=", "0", "{", "err", "=", "asn1", ".", "SyntaxError", "{", "Msg", ":", "\"", "\"", "}", "\n", "return", "\n", "}", "\n", "ret", ".", "BitLength", "=", "(", "len", "(", "bytes", ")", "-", "1", ")", "*", "8", "-", "paddingBits", "\n", "ret", ".", "Bytes", "=", "bytes", "[", "1", ":", "]", "\n", "return", "\n", "}"], "docstring": "// BIT STRING\n// parseBitString parses an ASN.1 bit string from the given byte slice and returns it.", "docstring_tokens": ["BIT", "STRING", "parseBitString", "parses", "an", "ASN", ".", "1", "bit", "string", "from", "the", "given", "byte", "slice", "and", "returns", "it", "."], "sha": "27a1aff36ce64dbe5d93c08cc5f161983134ddc5", "url": "https://github.com/geoffgarside/ber/blob/27a1aff36ce64dbe5d93c08cc5f161983134ddc5/ber.go#L138-L153", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "grpc/ttnctx/context.go", "func_name": "ServiceInfoFromMetadata", "original_string": "func ServiceInfoFromMetadata(md metadata.MD) (serviceName, serviceVersion, netAddress string, err error) {\n\tserviceNameL, ok := md[\"service-name\"]\n\tif ok && len(serviceNameL) > 0 {\n\t\tserviceName = serviceNameL[0]\n\t}\n\tserviceVersionL, ok := md[\"service-version\"]\n\tif ok && len(serviceVersionL) > 0 {\n\t\tserviceVersion = serviceVersionL[0]\n\t}\n\tnetAddressL, ok := md[\"net-address\"]\n\tif ok && len(netAddressL) > 0 {\n\t\tnetAddress = netAddressL[0]\n\t}\n\treturn\n}", "language": "go", "code": "func ServiceInfoFromMetadata(md metadata.MD) (serviceName, serviceVersion, netAddress string, err error) {\n\tserviceNameL, ok := md[\"service-name\"]\n\tif ok && len(serviceNameL) > 0 {\n\t\tserviceName = serviceNameL[0]\n\t}\n\tserviceVersionL, ok := md[\"service-version\"]\n\tif ok && len(serviceVersionL) > 0 {\n\t\tserviceVersion = serviceVersionL[0]\n\t}\n\tnetAddressL, ok := md[\"net-address\"]\n\tif ok && len(netAddressL) > 0 {\n\t\tnetAddress = netAddressL[0]\n\t}\n\treturn\n}", "code_tokens": ["func", "ServiceInfoFromMetadata", "(", "md", "metadata", ".", "MD", ")", "(", "serviceName", ",", "serviceVersion", ",", "netAddress", "string", ",", "err", "error", ")", "{", "serviceNameL", ",", "ok", ":=", "md", "[", "\"", "\"", "]", "\n", "if", "ok", "&&", "len", "(", "serviceNameL", ")", ">", "0", "{", "serviceName", "=", "serviceNameL", "[", "0", "]", "\n", "}", "\n", "serviceVersionL", ",", "ok", ":=", "md", "[", "\"", "\"", "]", "\n", "if", "ok", "&&", "len", "(", "serviceVersionL", ")", ">", "0", "{", "serviceVersion", "=", "serviceVersionL", "[", "0", "]", "\n", "}", "\n", "netAddressL", ",", "ok", ":=", "md", "[", "\"", "\"", "]", "\n", "if", "ok", "&&", "len", "(", "netAddressL", ")", ">", "0", "{", "netAddress", "=", "netAddressL", "[", "0", "]", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// ServiceInfoFromMetadata gets the service information from the metadata or returns empty strings", "docstring_tokens": ["ServiceInfoFromMetadata", "gets", "the", "service", "information", "from", "the", "metadata", "or", "returns", "empty", "strings"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/grpc/ttnctx/context.go#L93-L107", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "relay.go", "func_name": "NewRelayer", "original_string": "func NewRelayer(ch *Channel, conn *Connection) *Relayer {\n\tr := &Relayer{\n\t\trelayHost:    ch.RelayHost(),\n\t\tmaxTimeout:   ch.relayMaxTimeout,\n\t\tlocalHandler: ch.relayLocal,\n\t\toutbound:     newRelayItems(conn.log.WithFields(LogField{\"relayItems\", \"outbound\"})),\n\t\tinbound:      newRelayItems(conn.log.WithFields(LogField{\"relayItems\", \"inbound\"})),\n\t\tpeers:        ch.RootPeers(),\n\t\tconn:         conn,\n\t\trelayConn: &relay.Conn{\n\t\t\tRemoteAddr:        conn.conn.RemoteAddr().String(),\n\t\t\tRemoteProcessName: conn.RemotePeerInfo().ProcessName,\n\t\t\tIsOutbound:        conn.connDirection == outbound,\n\t\t},\n\t\tlogger: conn.log,\n\t}\n\tr.timeouts = newRelayTimerPool(r.timeoutRelayItem, ch.relayTimerVerify)\n\treturn r\n}", "language": "go", "code": "func NewRelayer(ch *Channel, conn *Connection) *Relayer {\n\tr := &Relayer{\n\t\trelayHost:    ch.RelayHost(),\n\t\tmaxTimeout:   ch.relayMaxTimeout,\n\t\tlocalHandler: ch.relayLocal,\n\t\toutbound:     newRelayItems(conn.log.WithFields(LogField{\"relayItems\", \"outbound\"})),\n\t\tinbound:      newRelayItems(conn.log.WithFields(LogField{\"relayItems\", \"inbound\"})),\n\t\tpeers:        ch.RootPeers(),\n\t\tconn:         conn,\n\t\trelayConn: &relay.Conn{\n\t\t\tRemoteAddr:        conn.conn.RemoteAddr().String(),\n\t\t\tRemoteProcessName: conn.RemotePeerInfo().ProcessName,\n\t\t\tIsOutbound:        conn.connDirection == outbound,\n\t\t},\n\t\tlogger: conn.log,\n\t}\n\tr.timeouts = newRelayTimerPool(r.timeoutRelayItem, ch.relayTimerVerify)\n\treturn r\n}", "code_tokens": ["func", "NewRelayer", "(", "ch", "*", "Channel", ",", "conn", "*", "Connection", ")", "*", "Relayer", "{", "r", ":=", "&", "Relayer", "{", "relayHost", ":", "ch", ".", "RelayHost", "(", ")", ",", "maxTimeout", ":", "ch", ".", "relayMaxTimeout", ",", "localHandler", ":", "ch", ".", "relayLocal", ",", "outbound", ":", "newRelayItems", "(", "conn", ".", "log", ".", "WithFields", "(", "LogField", "{", "\"", "\"", ",", "\"", "\"", "}", ")", ")", ",", "inbound", ":", "newRelayItems", "(", "conn", ".", "log", ".", "WithFields", "(", "LogField", "{", "\"", "\"", ",", "\"", "\"", "}", ")", ")", ",", "peers", ":", "ch", ".", "RootPeers", "(", ")", ",", "conn", ":", "conn", ",", "relayConn", ":", "&", "relay", ".", "Conn", "{", "RemoteAddr", ":", "conn", ".", "conn", ".", "RemoteAddr", "(", ")", ".", "String", "(", ")", ",", "RemoteProcessName", ":", "conn", ".", "RemotePeerInfo", "(", ")", ".", "ProcessName", ",", "IsOutbound", ":", "conn", ".", "connDirection", "==", "outbound", ",", "}", ",", "logger", ":", "conn", ".", "log", ",", "}", "\n", "r", ".", "timeouts", "=", "newRelayTimerPool", "(", "r", ".", "timeoutRelayItem", ",", "ch", ".", "relayTimerVerify", ")", "\n", "return", "r", "\n", "}"], "docstring": "// NewRelayer constructs a Relayer.", "docstring_tokens": ["NewRelayer", "constructs", "a", "Relayer", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/relay.go#L202-L220", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/dog/dog.go", "func_name": "FormatURL", "original_string": "func FormatURL(dogURL string) (string, error) {\n\tif dogURL == \"\" {\n\t\treturn \"\", errors.New(\"empty url\")\n\t}\n\tsrc, err := url.ParseRequestURI(dogURL)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"invalid url %s: %v\", dogURL, err)\n\t}\n\treturn fmt.Sprintf(\"[![dog image](%s)](%s)\", src, src), nil\n}", "language": "go", "code": "func FormatURL(dogURL string) (string, error) {\n\tif dogURL == \"\" {\n\t\treturn \"\", errors.New(\"empty url\")\n\t}\n\tsrc, err := url.ParseRequestURI(dogURL)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"invalid url %s: %v\", dogURL, err)\n\t}\n\treturn fmt.Sprintf(\"[![dog image](%s)](%s)\", src, src), nil\n}", "code_tokens": ["func", "FormatURL", "(", "dogURL", "string", ")", "(", "string", ",", "error", ")", "{", "if", "dogURL", "==", "\"", "\"", "{", "return", "\"", "\"", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "src", ",", "err", ":=", "url", ".", "ParseRequestURI", "(", "dogURL", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "dogURL", ",", "err", ")", "\n", "}", "\n", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "src", ",", "src", ")", ",", "nil", "\n", "}"], "docstring": "// FormatURL will return the GH markdown to show the image for a specific dogURL.", "docstring_tokens": ["FormatURL", "will", "return", "the", "GH", "markdown", "to", "show", "the", "image", "for", "a", "specific", "dogURL", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/dog/dog.go#L87-L96", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "errors/type.go", "func_name": "fromString", "original_string": "func fromString(str string) (Type, error) {\n\tenum := strings.ToLower(str)\n\tswitch enum {\n\tcase \"unknown\":\n\t\treturn Unknown, nil\n\tcase \"internal\":\n\t\treturn Internal, nil\n\tcase \"invalid argument\":\n\t\treturn InvalidArgument, nil\n\tcase \"out of range\":\n\t\treturn OutOfRange, nil\n\tcase \"not found\":\n\t\treturn NotFound, nil\n\tcase \"conflict\":\n\t\treturn Conflict, nil\n\tcase \"already exists\":\n\t\treturn AlreadyExists, nil\n\tcase \"unauthorized\":\n\t\treturn Unauthorized, nil\n\tcase \"permission denied\":\n\t\treturn PermissionDenied, nil\n\tcase \"timeout\":\n\t\treturn Timeout, nil\n\tcase \"not implemented\":\n\t\treturn NotImplemented, nil\n\tcase \"temporarily unavailable\":\n\t\treturn TemporarilyUnavailable, nil\n\tcase \"permanently unavailable\":\n\t\treturn PermanentlyUnavailable, nil\n\tcase \"canceled\":\n\t\treturn Canceled, nil\n\tcase \"resource exhausted\":\n\t\treturn ResourceExhausted, nil\n\tdefault:\n\t\treturn Unknown, fmt.Errorf(\"Invalid error type\")\n\t}\n}", "language": "go", "code": "func fromString(str string) (Type, error) {\n\tenum := strings.ToLower(str)\n\tswitch enum {\n\tcase \"unknown\":\n\t\treturn Unknown, nil\n\tcase \"internal\":\n\t\treturn Internal, nil\n\tcase \"invalid argument\":\n\t\treturn InvalidArgument, nil\n\tcase \"out of range\":\n\t\treturn OutOfRange, nil\n\tcase \"not found\":\n\t\treturn NotFound, nil\n\tcase \"conflict\":\n\t\treturn Conflict, nil\n\tcase \"already exists\":\n\t\treturn AlreadyExists, nil\n\tcase \"unauthorized\":\n\t\treturn Unauthorized, nil\n\tcase \"permission denied\":\n\t\treturn PermissionDenied, nil\n\tcase \"timeout\":\n\t\treturn Timeout, nil\n\tcase \"not implemented\":\n\t\treturn NotImplemented, nil\n\tcase \"temporarily unavailable\":\n\t\treturn TemporarilyUnavailable, nil\n\tcase \"permanently unavailable\":\n\t\treturn PermanentlyUnavailable, nil\n\tcase \"canceled\":\n\t\treturn Canceled, nil\n\tcase \"resource exhausted\":\n\t\treturn ResourceExhausted, nil\n\tdefault:\n\t\treturn Unknown, fmt.Errorf(\"Invalid error type\")\n\t}\n}", "code_tokens": ["func", "fromString", "(", "str", "string", ")", "(", "Type", ",", "error", ")", "{", "enum", ":=", "strings", ".", "ToLower", "(", "str", ")", "\n", "switch", "enum", "{", "case", "\"", "\"", ":", "return", "Unknown", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "Internal", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "InvalidArgument", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "OutOfRange", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "NotFound", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "Conflict", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "AlreadyExists", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "Unauthorized", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "PermissionDenied", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "Timeout", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "NotImplemented", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "TemporarilyUnavailable", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "PermanentlyUnavailable", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "Canceled", ",", "nil", "\n", "case", "\"", "\"", ":", "return", "ResourceExhausted", ",", "nil", "\n", "default", ":", "return", "Unknown", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "}"], "docstring": "// fromString parses a string into an error type. If the type is invalid, the\n// Unknown type will be returned as well as an error.", "docstring_tokens": ["fromString", "parses", "a", "string", "into", "an", "error", "type", ".", "If", "the", "type", "is", "invalid", "the", "Unknown", "type", "will", "be", "returned", "as", "well", "as", "an", "error", "."], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/errors/type.go#L129-L165", "partition": "test"}
{"repo": "go-audio/transforms", "path": "quantize.go", "func_name": "Quantize", "original_string": "func Quantize(buf *audio.FloatBuffer, bitDepth int) {\n\tif buf == nil {\n\t\treturn\n\t}\n\tmax := math.Pow(2, float64(bitDepth)) - 1\n\n\tbufLen := len(buf.Data)\n\tfor i := 0; i < bufLen; i++ {\n\t\tbuf.Data[i] = round((buf.Data[i]+1)*max)/max - 1.0\n\t}\n}", "language": "go", "code": "func Quantize(buf *audio.FloatBuffer, bitDepth int) {\n\tif buf == nil {\n\t\treturn\n\t}\n\tmax := math.Pow(2, float64(bitDepth)) - 1\n\n\tbufLen := len(buf.Data)\n\tfor i := 0; i < bufLen; i++ {\n\t\tbuf.Data[i] = round((buf.Data[i]+1)*max)/max - 1.0\n\t}\n}", "code_tokens": ["func", "Quantize", "(", "buf", "*", "audio", ".", "FloatBuffer", ",", "bitDepth", "int", ")", "{", "if", "buf", "==", "nil", "{", "return", "\n", "}", "\n", "max", ":=", "math", ".", "Pow", "(", "2", ",", "float64", "(", "bitDepth", ")", ")", "-", "1", "\n\n", "bufLen", ":=", "len", "(", "buf", ".", "Data", ")", "\n", "for", "i", ":=", "0", ";", "i", "<", "bufLen", ";", "i", "++", "{", "buf", ".", "Data", "[", "i", "]", "=", "round", "(", "(", "buf", ".", "Data", "[", "i", "]", "+", "1", ")", "*", "max", ")", "/", "max", "-", "1.0", "\n", "}", "\n", "}"], "docstring": "// Quantize quantizes the audio signal to match the target bitDepth", "docstring_tokens": ["Quantize", "quantizes", "the", "audio", "signal", "to", "match", "the", "target", "bitDepth"], "sha": "51830ccc35a5ce4be9d09b1d1f3f82dad376c240", "url": "https://github.com/go-audio/transforms/blob/51830ccc35a5ce4be9d09b1d1f3f82dad376c240/quantize.go#L10-L20", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/pjutil/tot.go", "func_name": "PostsubmitToJobSpec", "original_string": "func PostsubmitToJobSpec(post config.Postsubmit) *downwardapi.JobSpec {\n\treturn &downwardapi.JobSpec{\n\t\tType: prowapi.PostsubmitJob,\n\t\tJob:  post.Name,\n\t}\n}", "language": "go", "code": "func PostsubmitToJobSpec(post config.Postsubmit) *downwardapi.JobSpec {\n\treturn &downwardapi.JobSpec{\n\t\tType: prowapi.PostsubmitJob,\n\t\tJob:  post.Name,\n\t}\n}", "code_tokens": ["func", "PostsubmitToJobSpec", "(", "post", "config", ".", "Postsubmit", ")", "*", "downwardapi", ".", "JobSpec", "{", "return", "&", "downwardapi", ".", "JobSpec", "{", "Type", ":", "prowapi", ".", "PostsubmitJob", ",", "Job", ":", "post", ".", "Name", ",", "}", "\n", "}"], "docstring": "// PostsubmitToJobSpec generates a downwardapi.JobSpec out of a Postsubmit.\n// Useful for figuring out GCS paths when parsing jobs out\n// of a prow config.", "docstring_tokens": ["PostsubmitToJobSpec", "generates", "a", "downwardapi", ".", "JobSpec", "out", "of", "a", "Postsubmit", ".", "Useful", "for", "figuring", "out", "GCS", "paths", "when", "parsing", "jobs", "out", "of", "a", "prow", "config", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pjutil/tot.go#L61-L66", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "iterator.go", "func_name": "Valid", "original_string": "func (it *Iterator) Valid() bool {\n\tif it.item == nil {\n\t\treturn false\n\t}\n\treturn bytes.HasPrefix(it.item.key, it.opt.Prefix)\n}", "language": "go", "code": "func (it *Iterator) Valid() bool {\n\tif it.item == nil {\n\t\treturn false\n\t}\n\treturn bytes.HasPrefix(it.item.key, it.opt.Prefix)\n}", "code_tokens": ["func", "(", "it", "*", "Iterator", ")", "Valid", "(", ")", "bool", "{", "if", "it", ".", "item", "==", "nil", "{", "return", "false", "\n", "}", "\n", "return", "bytes", ".", "HasPrefix", "(", "it", ".", "item", ".", "key", ",", "it", ".", "opt", ".", "Prefix", ")", "\n", "}"], "docstring": "// Valid returns false when iteration is done.", "docstring_tokens": ["Valid", "returns", "false", "when", "iteration", "is", "done", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/iterator.go#L456-L461", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/schema/schema.go", "func_name": "formatSQL", "original_string": "func formatSQL(statement string) string {\n\tlines := strings.Split(statement, \"\\n\")\n\tfor i, line := range lines {\n\t\tif strings.Contains(line, \"UNIQUE\") {\n\t\t\t// Let UNIQUE(x, y) constraints alone.\n\t\t\tcontinue\n\t\t}\n\t\tlines[i] = strings.Replace(line, \", \", \",\\n    \", -1)\n\t}\n\treturn strings.Join(lines, \"\\n\")\n}", "language": "go", "code": "func formatSQL(statement string) string {\n\tlines := strings.Split(statement, \"\\n\")\n\tfor i, line := range lines {\n\t\tif strings.Contains(line, \"UNIQUE\") {\n\t\t\t// Let UNIQUE(x, y) constraints alone.\n\t\t\tcontinue\n\t\t}\n\t\tlines[i] = strings.Replace(line, \", \", \",\\n    \", -1)\n\t}\n\treturn strings.Join(lines, \"\\n\")\n}", "code_tokens": ["func", "formatSQL", "(", "statement", "string", ")", "string", "{", "lines", ":=", "strings", ".", "Split", "(", "statement", ",", "\"", "\\n", "\"", ")", "\n", "for", "i", ",", "line", ":=", "range", "lines", "{", "if", "strings", ".", "Contains", "(", "line", ",", "\"", "\"", ")", "{", "// Let UNIQUE(x, y) constraints alone.", "continue", "\n", "}", "\n", "lines", "[", "i", "]", "=", "strings", ".", "Replace", "(", "line", ",", "\"", "\"", ",", "\"", "\\n", "\"", ",", "-", "1", ")", "\n", "}", "\n", "return", "strings", ".", "Join", "(", "lines", ",", "\"", "\\n", "\"", ")", "\n", "}"], "docstring": "// Format the given SQL statement in a human-readable way.\n//\n// In particular make sure that each column definition in a CREATE TABLE clause\n// is in its own row, since SQLite dumps occasionally stuff more than one\n// column in the same line.", "docstring_tokens": ["Format", "the", "given", "SQL", "statement", "in", "a", "human", "-", "readable", "way", ".", "In", "particular", "make", "sure", "that", "each", "column", "definition", "in", "a", "CREATE", "TABLE", "clause", "is", "in", "its", "own", "row", "since", "SQLite", "dumps", "occasionally", "stuff", "more", "than", "one", "column", "in", "the", "same", "line", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/schema/schema.go#L418-L428", "partition": "test"}
{"repo": "olorin/nagiosplugin", "path": "range.go", "func_name": "CheckUint64", "original_string": "func (r *Range) CheckUint64(val uint64) bool {\n\treturn r.Check(float64(val))\n}", "language": "go", "code": "func (r *Range) CheckUint64(val uint64) bool {\n\treturn r.Check(float64(val))\n}", "code_tokens": ["func", "(", "r", "*", "Range", ")", "CheckUint64", "(", "val", "uint64", ")", "bool", "{", "return", "r", ".", "Check", "(", "float64", "(", "val", ")", ")", "\n", "}"], "docstring": "// CheckUint64 is a convenience method which does an unchecked type\n// conversion from an uint64 to a float64.", "docstring_tokens": ["CheckUint64", "is", "a", "convenience", "method", "which", "does", "an", "unchecked", "type", "conversion", "from", "an", "uint64", "to", "a", "float64", "."], "sha": "893f9702af4ea1e2dc4cd6528cbdcdb3dc7ca064", "url": "https://github.com/olorin/nagiosplugin/blob/893f9702af4ea1e2dc4cd6528cbdcdb3dc7ca064/range.go#L91-L93", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "MustDontHave", "original_string": "func (u StellarMessage) MustDontHave() DontHave {\n\tval, ok := u.GetDontHave()\n\n\tif !ok {\n\t\tpanic(\"arm DontHave is not set\")\n\t}\n\n\treturn val\n}", "language": "go", "code": "func (u StellarMessage) MustDontHave() DontHave {\n\tval, ok := u.GetDontHave()\n\n\tif !ok {\n\t\tpanic(\"arm DontHave is not set\")\n\t}\n\n\treturn val\n}", "code_tokens": ["func", "(", "u", "StellarMessage", ")", "MustDontHave", "(", ")", "DontHave", "{", "val", ",", "ok", ":=", "u", ".", "GetDontHave", "(", ")", "\n\n", "if", "!", "ok", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "val", "\n", "}"], "docstring": "// MustDontHave retrieves the DontHave value from the union,\n// panicing if the value is not set.", "docstring_tokens": ["MustDontHave", "retrieves", "the", "DontHave", "value", "from", "the", "union", "panicing", "if", "the", "value", "is", "not", "set", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6548-L6556", "partition": "test"}
{"repo": "containers/image", "path": "manifest/docker_schema1.go", "func_name": "Schema1FromComponents", "original_string": "func Schema1FromComponents(ref reference.Named, fsLayers []Schema1FSLayers, history []Schema1History, architecture string) (*Schema1, error) {\n\tvar name, tag string\n\tif ref != nil { // Well, what to do if it _is_ nil? Most consumers actually don't use these fields nowadays, so we might as well try not supplying them.\n\t\tname = reference.Path(ref)\n\t\tif tagged, ok := ref.(reference.NamedTagged); ok {\n\t\t\ttag = tagged.Tag()\n\t\t}\n\t}\n\ts1 := Schema1{\n\t\tName:          name,\n\t\tTag:           tag,\n\t\tArchitecture:  architecture,\n\t\tFSLayers:      fsLayers,\n\t\tHistory:       history,\n\t\tSchemaVersion: 1,\n\t}\n\tif err := s1.initialize(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &s1, nil\n}", "language": "go", "code": "func Schema1FromComponents(ref reference.Named, fsLayers []Schema1FSLayers, history []Schema1History, architecture string) (*Schema1, error) {\n\tvar name, tag string\n\tif ref != nil { // Well, what to do if it _is_ nil? Most consumers actually don't use these fields nowadays, so we might as well try not supplying them.\n\t\tname = reference.Path(ref)\n\t\tif tagged, ok := ref.(reference.NamedTagged); ok {\n\t\t\ttag = tagged.Tag()\n\t\t}\n\t}\n\ts1 := Schema1{\n\t\tName:          name,\n\t\tTag:           tag,\n\t\tArchitecture:  architecture,\n\t\tFSLayers:      fsLayers,\n\t\tHistory:       history,\n\t\tSchemaVersion: 1,\n\t}\n\tif err := s1.initialize(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &s1, nil\n}", "code_tokens": ["func", "Schema1FromComponents", "(", "ref", "reference", ".", "Named", ",", "fsLayers", "[", "]", "Schema1FSLayers", ",", "history", "[", "]", "Schema1History", ",", "architecture", "string", ")", "(", "*", "Schema1", ",", "error", ")", "{", "var", "name", ",", "tag", "string", "\n", "if", "ref", "!=", "nil", "{", "// Well, what to do if it _is_ nil? Most consumers actually don't use these fields nowadays, so we might as well try not supplying them.", "name", "=", "reference", ".", "Path", "(", "ref", ")", "\n", "if", "tagged", ",", "ok", ":=", "ref", ".", "(", "reference", ".", "NamedTagged", ")", ";", "ok", "{", "tag", "=", "tagged", ".", "Tag", "(", ")", "\n", "}", "\n", "}", "\n", "s1", ":=", "Schema1", "{", "Name", ":", "name", ",", "Tag", ":", "tag", ",", "Architecture", ":", "architecture", ",", "FSLayers", ":", "fsLayers", ",", "History", ":", "history", ",", "SchemaVersion", ":", "1", ",", "}", "\n", "if", "err", ":=", "s1", ".", "initialize", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "&", "s1", ",", "nil", "\n", "}"], "docstring": "// Schema1FromComponents creates an Schema1 manifest instance from the supplied data.", "docstring_tokens": ["Schema1FromComponents", "creates", "an", "Schema1", "manifest", "instance", "from", "the", "supplied", "data", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/manifest/docker_schema1.go#L73-L93", "partition": "test"}
{"repo": "go-bongo/bongo", "path": "resultSet.go", "func_name": "Paginate", "original_string": "func (r *ResultSet) Paginate(perPage, page int) (*PaginationInfo, error) {\n\n\tinfo := new(PaginationInfo)\n\n\t// Get count on a different session to avoid blocking\n\tsess := r.Collection.Connection.Session.Copy()\n\n\tcount, err := sess.DB(r.Collection.Database).C(r.Collection.Name).Find(r.Params).Count()\n\tsess.Close()\n\n\tif err != nil {\n\t\treturn info, err\n\t}\n\n\t// Calculate how many pages\n\ttotalPages := int(math.Ceil(float64(count) / float64(perPage)))\n\n\tif page < 1 {\n\t\tpage = 1\n\t} else if page > totalPages {\n\t\tpage = totalPages\n\t}\n\n\tskip := (page - 1) * perPage\n\n\tr.Query.Skip(skip).Limit(perPage)\n\n\tinfo.TotalPages = totalPages\n\tinfo.PerPage = perPage\n\tinfo.Current = page\n\tinfo.TotalRecords = count\n\n\tif info.Current < info.TotalPages {\n\t\tinfo.RecordsOnPage = info.PerPage\n\t} else {\n\n\t\tinfo.RecordsOnPage = int(math.Mod(float64(count), float64(perPage)))\n\n\t\tif info.RecordsOnPage == 0 && count > 0 {\n\t\t\tinfo.RecordsOnPage = perPage\n\t\t}\n\n\t}\n\n\treturn info, nil\n}", "language": "go", "code": "func (r *ResultSet) Paginate(perPage, page int) (*PaginationInfo, error) {\n\n\tinfo := new(PaginationInfo)\n\n\t// Get count on a different session to avoid blocking\n\tsess := r.Collection.Connection.Session.Copy()\n\n\tcount, err := sess.DB(r.Collection.Database).C(r.Collection.Name).Find(r.Params).Count()\n\tsess.Close()\n\n\tif err != nil {\n\t\treturn info, err\n\t}\n\n\t// Calculate how many pages\n\ttotalPages := int(math.Ceil(float64(count) / float64(perPage)))\n\n\tif page < 1 {\n\t\tpage = 1\n\t} else if page > totalPages {\n\t\tpage = totalPages\n\t}\n\n\tskip := (page - 1) * perPage\n\n\tr.Query.Skip(skip).Limit(perPage)\n\n\tinfo.TotalPages = totalPages\n\tinfo.PerPage = perPage\n\tinfo.Current = page\n\tinfo.TotalRecords = count\n\n\tif info.Current < info.TotalPages {\n\t\tinfo.RecordsOnPage = info.PerPage\n\t} else {\n\n\t\tinfo.RecordsOnPage = int(math.Mod(float64(count), float64(perPage)))\n\n\t\tif info.RecordsOnPage == 0 && count > 0 {\n\t\t\tinfo.RecordsOnPage = perPage\n\t\t}\n\n\t}\n\n\treturn info, nil\n}", "code_tokens": ["func", "(", "r", "*", "ResultSet", ")", "Paginate", "(", "perPage", ",", "page", "int", ")", "(", "*", "PaginationInfo", ",", "error", ")", "{", "info", ":=", "new", "(", "PaginationInfo", ")", "\n\n", "// Get count on a different session to avoid blocking", "sess", ":=", "r", ".", "Collection", ".", "Connection", ".", "Session", ".", "Copy", "(", ")", "\n\n", "count", ",", "err", ":=", "sess", ".", "DB", "(", "r", ".", "Collection", ".", "Database", ")", ".", "C", "(", "r", ".", "Collection", ".", "Name", ")", ".", "Find", "(", "r", ".", "Params", ")", ".", "Count", "(", ")", "\n", "sess", ".", "Close", "(", ")", "\n\n", "if", "err", "!=", "nil", "{", "return", "info", ",", "err", "\n", "}", "\n\n", "// Calculate how many pages", "totalPages", ":=", "int", "(", "math", ".", "Ceil", "(", "float64", "(", "count", ")", "/", "float64", "(", "perPage", ")", ")", ")", "\n\n", "if", "page", "<", "1", "{", "page", "=", "1", "\n", "}", "else", "if", "page", ">", "totalPages", "{", "page", "=", "totalPages", "\n", "}", "\n\n", "skip", ":=", "(", "page", "-", "1", ")", "*", "perPage", "\n\n", "r", ".", "Query", ".", "Skip", "(", "skip", ")", ".", "Limit", "(", "perPage", ")", "\n\n", "info", ".", "TotalPages", "=", "totalPages", "\n", "info", ".", "PerPage", "=", "perPage", "\n", "info", ".", "Current", "=", "page", "\n", "info", ".", "TotalRecords", "=", "count", "\n\n", "if", "info", ".", "Current", "<", "info", ".", "TotalPages", "{", "info", ".", "RecordsOnPage", "=", "info", ".", "PerPage", "\n", "}", "else", "{", "info", ".", "RecordsOnPage", "=", "int", "(", "math", ".", "Mod", "(", "float64", "(", "count", ")", ",", "float64", "(", "perPage", ")", ")", ")", "\n\n", "if", "info", ".", "RecordsOnPage", "==", "0", "&&", "count", ">", "0", "{", "info", ".", "RecordsOnPage", "=", "perPage", "\n", "}", "\n\n", "}", "\n\n", "return", "info", ",", "nil", "\n", "}"], "docstring": "// Set skip + limit on the current query and generates a PaginationInfo struct with info for your front end", "docstring_tokens": ["Set", "skip", "+", "limit", "on", "the", "current", "query", "and", "generates", "a", "PaginationInfo", "struct", "with", "info", "for", "your", "front", "end"], "sha": "761759e31d8fed917377aa7085db01d218ce50d8", "url": "https://github.com/go-bongo/bongo/blob/761759e31d8fed917377aa7085db01d218ce50d8/resultSet.go#L70-L115", "partition": "test"}
{"repo": "jhillyerd/enmime", "path": "envelope.go", "func_name": "GetHeader", "original_string": "func (e *Envelope) GetHeader(name string) string {\n\tif e.header == nil {\n\t\treturn \"\"\n\t}\n\treturn decodeHeader(e.header.Get(name))\n}", "language": "go", "code": "func (e *Envelope) GetHeader(name string) string {\n\tif e.header == nil {\n\t\treturn \"\"\n\t}\n\treturn decodeHeader(e.header.Get(name))\n}", "code_tokens": ["func", "(", "e", "*", "Envelope", ")", "GetHeader", "(", "name", "string", ")", "string", "{", "if", "e", ".", "header", "==", "nil", "{", "return", "\"", "\"", "\n", "}", "\n", "return", "decodeHeader", "(", "e", ".", "header", ".", "Get", "(", "name", ")", ")", "\n", "}"], "docstring": "// GetHeader processes the specified header for RFC 2047 encoded words and returns the result as a\n// UTF-8 string", "docstring_tokens": ["GetHeader", "processes", "the", "specified", "header", "for", "RFC", "2047", "encoded", "words", "and", "returns", "the", "result", "as", "a", "UTF", "-", "8", "string"], "sha": "874cc30e023f36bd1df525716196887b0f04851b", "url": "https://github.com/jhillyerd/enmime/blob/874cc30e023f36bd1df525716196887b0f04851b/envelope.go#L44-L49", "partition": "test"}
{"repo": "xwb1989/sqlparser", "path": "ast.go", "func_name": "Append", "original_string": "func Append(buf *bytes.Buffer, node SQLNode) {\n\ttbuf := &TrackedBuffer{\n\t\tBuffer: buf,\n\t}\n\tnode.Format(tbuf)\n}", "language": "go", "code": "func Append(buf *bytes.Buffer, node SQLNode) {\n\ttbuf := &TrackedBuffer{\n\t\tBuffer: buf,\n\t}\n\tnode.Format(tbuf)\n}", "code_tokens": ["func", "Append", "(", "buf", "*", "bytes", ".", "Buffer", ",", "node", "SQLNode", ")", "{", "tbuf", ":=", "&", "TrackedBuffer", "{", "Buffer", ":", "buf", ",", "}", "\n", "node", ".", "Format", "(", "tbuf", ")", "\n", "}"], "docstring": "// Append appends the SQLNode to the buffer.", "docstring_tokens": ["Append", "appends", "the", "SQLNode", "to", "the", "buffer", "."], "sha": "120387863bf27d04bc07db8015110a6e96d0146c", "url": "https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/ast.go#L197-L202", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdctl/ctlv3/command/lease_command.go", "func_name": "NewLeaseGrantCommand", "original_string": "func NewLeaseGrantCommand() *cobra.Command {\n\tlc := &cobra.Command{\n\t\tUse:   \"grant <ttl>\",\n\t\tShort: \"Creates leases\",\n\n\t\tRun: leaseGrantCommandFunc,\n\t}\n\n\treturn lc\n}", "language": "go", "code": "func NewLeaseGrantCommand() *cobra.Command {\n\tlc := &cobra.Command{\n\t\tUse:   \"grant <ttl>\",\n\t\tShort: \"Creates leases\",\n\n\t\tRun: leaseGrantCommandFunc,\n\t}\n\n\treturn lc\n}", "code_tokens": ["func", "NewLeaseGrantCommand", "(", ")", "*", "cobra", ".", "Command", "{", "lc", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Run", ":", "leaseGrantCommandFunc", ",", "}", "\n\n", "return", "lc", "\n", "}"], "docstring": "// NewLeaseGrantCommand returns the cobra command for \"lease grant\".", "docstring_tokens": ["NewLeaseGrantCommand", "returns", "the", "cobra", "command", "for", "lease", "grant", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv3/command/lease_command.go#L44-L53", "partition": "test"}
{"repo": "256dpi/fire", "path": "group.go", "func_name": "NewGroup", "original_string": "func NewGroup() *Group {\n\treturn &Group{\n\t\tcontrollers: make(map[string]*Controller),\n\t\tactions:     make(map[string]*GroupAction),\n\t}\n}", "language": "go", "code": "func NewGroup() *Group {\n\treturn &Group{\n\t\tcontrollers: make(map[string]*Controller),\n\t\tactions:     make(map[string]*GroupAction),\n\t}\n}", "code_tokens": ["func", "NewGroup", "(", ")", "*", "Group", "{", "return", "&", "Group", "{", "controllers", ":", "make", "(", "map", "[", "string", "]", "*", "Controller", ")", ",", "actions", ":", "make", "(", "map", "[", "string", "]", "*", "GroupAction", ")", ",", "}", "\n", "}"], "docstring": "// NewGroup creates and returns a new group.", "docstring_tokens": ["NewGroup", "creates", "and", "returns", "a", "new", "group", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/group.go#L35-L40", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/v2store/node.go", "func_name": "Remove", "original_string": "func (n *node) Remove(dir, recursive bool, callback func(path string)) *v2error.Error {\n\tif !n.IsDir() { // key-value pair\n\t\t_, name := path.Split(n.Path)\n\n\t\t// find its parent and remove the node from the map\n\t\tif n.Parent != nil && n.Parent.Children[name] == n {\n\t\t\tdelete(n.Parent.Children, name)\n\t\t}\n\n\t\tif callback != nil {\n\t\t\tcallback(n.Path)\n\t\t}\n\n\t\tif !n.IsPermanent() {\n\t\t\tn.store.ttlKeyHeap.remove(n)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tif !dir {\n\t\t// cannot delete a directory without dir set to true\n\t\treturn v2error.NewError(v2error.EcodeNotFile, n.Path, n.store.CurrentIndex)\n\t}\n\n\tif len(n.Children) != 0 && !recursive {\n\t\t// cannot delete a directory if it is not empty and the operation\n\t\t// is not recursive\n\t\treturn v2error.NewError(v2error.EcodeDirNotEmpty, n.Path, n.store.CurrentIndex)\n\t}\n\n\tfor _, child := range n.Children { // delete all children\n\t\tchild.Remove(true, true, callback)\n\t}\n\n\t// delete self\n\t_, name := path.Split(n.Path)\n\tif n.Parent != nil && n.Parent.Children[name] == n {\n\t\tdelete(n.Parent.Children, name)\n\n\t\tif callback != nil {\n\t\t\tcallback(n.Path)\n\t\t}\n\n\t\tif !n.IsPermanent() {\n\t\t\tn.store.ttlKeyHeap.remove(n)\n\t\t}\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (n *node) Remove(dir, recursive bool, callback func(path string)) *v2error.Error {\n\tif !n.IsDir() { // key-value pair\n\t\t_, name := path.Split(n.Path)\n\n\t\t// find its parent and remove the node from the map\n\t\tif n.Parent != nil && n.Parent.Children[name] == n {\n\t\t\tdelete(n.Parent.Children, name)\n\t\t}\n\n\t\tif callback != nil {\n\t\t\tcallback(n.Path)\n\t\t}\n\n\t\tif !n.IsPermanent() {\n\t\t\tn.store.ttlKeyHeap.remove(n)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tif !dir {\n\t\t// cannot delete a directory without dir set to true\n\t\treturn v2error.NewError(v2error.EcodeNotFile, n.Path, n.store.CurrentIndex)\n\t}\n\n\tif len(n.Children) != 0 && !recursive {\n\t\t// cannot delete a directory if it is not empty and the operation\n\t\t// is not recursive\n\t\treturn v2error.NewError(v2error.EcodeDirNotEmpty, n.Path, n.store.CurrentIndex)\n\t}\n\n\tfor _, child := range n.Children { // delete all children\n\t\tchild.Remove(true, true, callback)\n\t}\n\n\t// delete self\n\t_, name := path.Split(n.Path)\n\tif n.Parent != nil && n.Parent.Children[name] == n {\n\t\tdelete(n.Parent.Children, name)\n\n\t\tif callback != nil {\n\t\t\tcallback(n.Path)\n\t\t}\n\n\t\tif !n.IsPermanent() {\n\t\t\tn.store.ttlKeyHeap.remove(n)\n\t\t}\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "n", "*", "node", ")", "Remove", "(", "dir", ",", "recursive", "bool", ",", "callback", "func", "(", "path", "string", ")", ")", "*", "v2error", ".", "Error", "{", "if", "!", "n", ".", "IsDir", "(", ")", "{", "// key-value pair", "_", ",", "name", ":=", "path", ".", "Split", "(", "n", ".", "Path", ")", "\n\n", "// find its parent and remove the node from the map", "if", "n", ".", "Parent", "!=", "nil", "&&", "n", ".", "Parent", ".", "Children", "[", "name", "]", "==", "n", "{", "delete", "(", "n", ".", "Parent", ".", "Children", ",", "name", ")", "\n", "}", "\n\n", "if", "callback", "!=", "nil", "{", "callback", "(", "n", ".", "Path", ")", "\n", "}", "\n\n", "if", "!", "n", ".", "IsPermanent", "(", ")", "{", "n", ".", "store", ".", "ttlKeyHeap", ".", "remove", "(", "n", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}", "\n\n", "if", "!", "dir", "{", "// cannot delete a directory without dir set to true", "return", "v2error", ".", "NewError", "(", "v2error", ".", "EcodeNotFile", ",", "n", ".", "Path", ",", "n", ".", "store", ".", "CurrentIndex", ")", "\n", "}", "\n\n", "if", "len", "(", "n", ".", "Children", ")", "!=", "0", "&&", "!", "recursive", "{", "// cannot delete a directory if it is not empty and the operation", "// is not recursive", "return", "v2error", ".", "NewError", "(", "v2error", ".", "EcodeDirNotEmpty", ",", "n", ".", "Path", ",", "n", ".", "store", ".", "CurrentIndex", ")", "\n", "}", "\n\n", "for", "_", ",", "child", ":=", "range", "n", ".", "Children", "{", "// delete all children", "child", ".", "Remove", "(", "true", ",", "true", ",", "callback", ")", "\n", "}", "\n\n", "// delete self", "_", ",", "name", ":=", "path", ".", "Split", "(", "n", ".", "Path", ")", "\n", "if", "n", ".", "Parent", "!=", "nil", "&&", "n", ".", "Parent", ".", "Children", "[", "name", "]", "==", "n", "{", "delete", "(", "n", ".", "Parent", ".", "Children", ",", "name", ")", "\n\n", "if", "callback", "!=", "nil", "{", "callback", "(", "n", ".", "Path", ")", "\n", "}", "\n\n", "if", "!", "n", ".", "IsPermanent", "(", ")", "{", "n", ".", "store", ".", "ttlKeyHeap", ".", "remove", "(", "n", ")", "\n", "}", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Remove function remove the node.", "docstring_tokens": ["Remove", "function", "remove", "the", "node", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2store/node.go#L206-L256", "partition": "test"}
{"repo": "rightscale/rsc", "path": "config.go", "func_name": "LoadConfig", "original_string": "func LoadConfig(path string) (*ClientConfig, error) {\n\tcontent, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar config ClientConfig\n\terr = json.Unmarshal(content, &config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.Password, err = Decrypt(config.Password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.RefreshToken, err = Decrypt(config.RefreshToken)\n\treturn &config, err\n}", "language": "go", "code": "func LoadConfig(path string) (*ClientConfig, error) {\n\tcontent, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar config ClientConfig\n\terr = json.Unmarshal(content, &config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.Password, err = Decrypt(config.Password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.RefreshToken, err = Decrypt(config.RefreshToken)\n\treturn &config, err\n}", "code_tokens": ["func", "LoadConfig", "(", "path", "string", ")", "(", "*", "ClientConfig", ",", "error", ")", "{", "content", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "var", "config", "ClientConfig", "\n", "err", "=", "json", ".", "Unmarshal", "(", "content", ",", "&", "config", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "config", ".", "Password", ",", "err", "=", "Decrypt", "(", "config", ".", "Password", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "config", ".", "RefreshToken", ",", "err", "=", "Decrypt", "(", "config", ".", "RefreshToken", ")", "\n", "return", "&", "config", ",", "err", "\n", "}"], "docstring": "// LoadConfig loads the client configuration from disk", "docstring_tokens": ["LoadConfig", "loads", "the", "client", "configuration", "from", "disk"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/config.go#L20-L36", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nitro.go", "func_name": "SetKeyComparator", "original_string": "func (cfg *Config) SetKeyComparator(cmp KeyCompare) {\n\tcfg.keyCmp = cmp\n\tcfg.insCmp = newInsertCompare(cmp)\n\tcfg.iterCmp = newIterCompare(cmp)\n\tcfg.existCmp = newExistCompare(cmp)\n}", "language": "go", "code": "func (cfg *Config) SetKeyComparator(cmp KeyCompare) {\n\tcfg.keyCmp = cmp\n\tcfg.insCmp = newInsertCompare(cmp)\n\tcfg.iterCmp = newIterCompare(cmp)\n\tcfg.existCmp = newExistCompare(cmp)\n}", "code_tokens": ["func", "(", "cfg", "*", "Config", ")", "SetKeyComparator", "(", "cmp", "KeyCompare", ")", "{", "cfg", ".", "keyCmp", "=", "cmp", "\n", "cfg", ".", "insCmp", "=", "newInsertCompare", "(", "cmp", ")", "\n", "cfg", ".", "iterCmp", "=", "newIterCompare", "(", "cmp", ")", "\n", "cfg", ".", "existCmp", "=", "newExistCompare", "(", "cmp", ")", "\n", "}"], "docstring": "// SetKeyComparator provides key comparator for the Nitro item data", "docstring_tokens": ["SetKeyComparator", "provides", "key", "comparator", "for", "the", "Nitro", "item", "data"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nitro.go#L300-L305", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "provision/kubernetes/pkg/client/clientset/versioned/typed/tsuru/v1/app.go", "func_name": "newApps", "original_string": "func newApps(c *TsuruV1Client, namespace string) *apps {\n\treturn &apps{\n\t\tclient: c.RESTClient(),\n\t\tns:     namespace,\n\t}\n}", "language": "go", "code": "func newApps(c *TsuruV1Client, namespace string) *apps {\n\treturn &apps{\n\t\tclient: c.RESTClient(),\n\t\tns:     namespace,\n\t}\n}", "code_tokens": ["func", "newApps", "(", "c", "*", "TsuruV1Client", ",", "namespace", "string", ")", "*", "apps", "{", "return", "&", "apps", "{", "client", ":", "c", ".", "RESTClient", "(", ")", ",", "ns", ":", "namespace", ",", "}", "\n", "}"], "docstring": "// newApps returns a Apps", "docstring_tokens": ["newApps", "returns", "a", "Apps"], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/kubernetes/pkg/client/clientset/versioned/typed/tsuru/v1/app.go#L44-L49", "partition": "test"}
{"repo": "guregu/null", "path": "float.go", "func_name": "UnmarshalText", "original_string": "func (f *Float) UnmarshalText(text []byte) error {\n\tstr := string(text)\n\tif str == \"\" || str == \"null\" {\n\t\tf.Valid = false\n\t\treturn nil\n\t}\n\tvar err error\n\tf.Float64, err = strconv.ParseFloat(string(text), 64)\n\tf.Valid = err == nil\n\treturn err\n}", "language": "go", "code": "func (f *Float) UnmarshalText(text []byte) error {\n\tstr := string(text)\n\tif str == \"\" || str == \"null\" {\n\t\tf.Valid = false\n\t\treturn nil\n\t}\n\tvar err error\n\tf.Float64, err = strconv.ParseFloat(string(text), 64)\n\tf.Valid = err == nil\n\treturn err\n}", "code_tokens": ["func", "(", "f", "*", "Float", ")", "UnmarshalText", "(", "text", "[", "]", "byte", ")", "error", "{", "str", ":=", "string", "(", "text", ")", "\n", "if", "str", "==", "\"", "\"", "||", "str", "==", "\"", "\"", "{", "f", ".", "Valid", "=", "false", "\n", "return", "nil", "\n", "}", "\n", "var", "err", "error", "\n", "f", ".", "Float64", ",", "err", "=", "strconv", ".", "ParseFloat", "(", "string", "(", "text", ")", ",", "64", ")", "\n", "f", ".", "Valid", "=", "err", "==", "nil", "\n", "return", "err", "\n", "}"], "docstring": "// UnmarshalText implements encoding.TextUnmarshaler.\n// It will unmarshal to a null Float if the input is a blank or not an integer.\n// It will return an error if the input is not an integer, blank, or \"null\".", "docstring_tokens": ["UnmarshalText", "implements", "encoding", ".", "TextUnmarshaler", ".", "It", "will", "unmarshal", "to", "a", "null", "Float", "if", "the", "input", "is", "a", "blank", "or", "not", "an", "integer", ".", "It", "will", "return", "an", "error", "if", "the", "input", "is", "not", "an", "integer", "blank", "or", "null", "."], "sha": "80515d440932108546bcade467bb7d6968e812e2", "url": "https://github.com/guregu/null/blob/80515d440932108546bcade467bb7d6968e812e2/float.go#L85-L95", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "rule/rule.go", "func_name": "PrivateAttrKeys", "original_string": "func (r *Rule) PrivateAttrKeys() []string {\n\tkeys := make([]string, 0, len(r.private))\n\tfor k := range r.private {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}", "language": "go", "code": "func (r *Rule) PrivateAttrKeys() []string {\n\tkeys := make([]string, 0, len(r.private))\n\tfor k := range r.private {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}", "code_tokens": ["func", "(", "r", "*", "Rule", ")", "PrivateAttrKeys", "(", ")", "[", "]", "string", "{", "keys", ":=", "make", "(", "[", "]", "string", ",", "0", ",", "len", "(", "r", ".", "private", ")", ")", "\n", "for", "k", ":=", "range", "r", ".", "private", "{", "keys", "=", "append", "(", "keys", ",", "k", ")", "\n", "}", "\n", "sort", ".", "Strings", "(", "keys", ")", "\n", "return", "keys", "\n", "}"], "docstring": "// PrivateAttrKeys returns a sorted list of private attribute names.", "docstring_tokens": ["PrivateAttrKeys", "returns", "a", "sorted", "list", "of", "private", "attribute", "names", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/rule/rule.go#L715-L722", "partition": "test"}
{"repo": "qor/render", "path": "assetfs/filesystem.go", "func_name": "Asset", "original_string": "func (fs *AssetFileSystem) Asset(name string) ([]byte, error) {\n\tfor _, pth := range fs.paths {\n\t\tif _, err := os.Stat(filepath.Join(pth, name)); err == nil {\n\t\t\treturn ioutil.ReadFile(filepath.Join(pth, name))\n\t\t}\n\t}\n\treturn []byte{}, fmt.Errorf(\"%v not found\", name)\n}", "language": "go", "code": "func (fs *AssetFileSystem) Asset(name string) ([]byte, error) {\n\tfor _, pth := range fs.paths {\n\t\tif _, err := os.Stat(filepath.Join(pth, name)); err == nil {\n\t\t\treturn ioutil.ReadFile(filepath.Join(pth, name))\n\t\t}\n\t}\n\treturn []byte{}, fmt.Errorf(\"%v not found\", name)\n}", "code_tokens": ["func", "(", "fs", "*", "AssetFileSystem", ")", "Asset", "(", "name", "string", ")", "(", "[", "]", "byte", ",", "error", ")", "{", "for", "_", ",", "pth", ":=", "range", "fs", ".", "paths", "{", "if", "_", ",", "err", ":=", "os", ".", "Stat", "(", "filepath", ".", "Join", "(", "pth", ",", "name", ")", ")", ";", "err", "==", "nil", "{", "return", "ioutil", ".", "ReadFile", "(", "filepath", ".", "Join", "(", "pth", ",", "name", ")", ")", "\n", "}", "\n", "}", "\n", "return", "[", "]", "byte", "{", "}", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "name", ")", "\n", "}"], "docstring": "// Asset get content with name from assetfs", "docstring_tokens": ["Asset", "get", "content", "with", "name", "from", "assetfs"], "sha": "63566e46f01b134ae9882a59a06518e82a903231", "url": "https://github.com/qor/render/blob/63566e46f01b134ae9882a59a06518e82a903231/assetfs/filesystem.go#L55-L62", "partition": "test"}
{"repo": "256dpi/fire", "path": "coal/store.go", "func_name": "C", "original_string": "func (s *SubStore) C(model Model) *mgo.Collection {\n\treturn s.DB().C(C(model))\n}", "language": "go", "code": "func (s *SubStore) C(model Model) *mgo.Collection {\n\treturn s.DB().C(C(model))\n}", "code_tokens": ["func", "(", "s", "*", "SubStore", ")", "C", "(", "model", "Model", ")", "*", "mgo", ".", "Collection", "{", "return", "s", ".", "DB", "(", ")", ".", "C", "(", "C", "(", "model", ")", ")", "\n", "}"], "docstring": "// C will return the collection associated to the passed model.", "docstring_tokens": ["C", "will", "return", "the", "collection", "associated", "to", "the", "passed", "model", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/coal/store.go#L68-L70", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "ValidEnum", "original_string": "func (e OperationResultCode) ValidEnum(v int32) bool {\n\t_, ok := operationResultCodeMap[v]\n\treturn ok\n}", "language": "go", "code": "func (e OperationResultCode) ValidEnum(v int32) bool {\n\t_, ok := operationResultCodeMap[v]\n\treturn ok\n}", "code_tokens": ["func", "(", "e", "OperationResultCode", ")", "ValidEnum", "(", "v", "int32", ")", "bool", "{", "_", ",", "ok", ":=", "operationResultCodeMap", "[", "v", "]", "\n", "return", "ok", "\n", "}"], "docstring": "// ValidEnum validates a proposed value for this enum.  Implements\n// the Enum interface for OperationResultCode", "docstring_tokens": ["ValidEnum", "validates", "a", "proposed", "value", "for", "this", "enum", ".", "Implements", "the", "Enum", "interface", "for", "OperationResultCode"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L3800-L3803", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/trigger/trigger.go", "func_name": "skipRequested", "original_string": "func skipRequested(c Client, pr *github.PullRequest, skippedJobs []config.Presubmit) error {\n\tvar errors []error\n\tfor _, job := range skippedJobs {\n\t\tif job.SkipReport {\n\t\t\tcontinue\n\t\t}\n\t\tc.Logger.Infof(\"Skipping %s build.\", job.Name)\n\t\tif err := c.GitHubClient.CreateStatus(pr.Base.Repo.Owner.Login, pr.Base.Repo.Name, pr.Head.SHA, skippedStatusFor(job.Context)); err != nil {\n\t\t\terrors = append(errors, err)\n\t\t}\n\t}\n\treturn errorutil.NewAggregate(errors...)\n}", "language": "go", "code": "func skipRequested(c Client, pr *github.PullRequest, skippedJobs []config.Presubmit) error {\n\tvar errors []error\n\tfor _, job := range skippedJobs {\n\t\tif job.SkipReport {\n\t\t\tcontinue\n\t\t}\n\t\tc.Logger.Infof(\"Skipping %s build.\", job.Name)\n\t\tif err := c.GitHubClient.CreateStatus(pr.Base.Repo.Owner.Login, pr.Base.Repo.Name, pr.Head.SHA, skippedStatusFor(job.Context)); err != nil {\n\t\t\terrors = append(errors, err)\n\t\t}\n\t}\n\treturn errorutil.NewAggregate(errors...)\n}", "code_tokens": ["func", "skipRequested", "(", "c", "Client", ",", "pr", "*", "github", ".", "PullRequest", ",", "skippedJobs", "[", "]", "config", ".", "Presubmit", ")", "error", "{", "var", "errors", "[", "]", "error", "\n", "for", "_", ",", "job", ":=", "range", "skippedJobs", "{", "if", "job", ".", "SkipReport", "{", "continue", "\n", "}", "\n", "c", ".", "Logger", ".", "Infof", "(", "\"", "\"", ",", "job", ".", "Name", ")", "\n", "if", "err", ":=", "c", ".", "GitHubClient", ".", "CreateStatus", "(", "pr", ".", "Base", ".", "Repo", ".", "Owner", ".", "Login", ",", "pr", ".", "Base", ".", "Repo", ".", "Name", ",", "pr", ".", "Head", ".", "SHA", ",", "skippedStatusFor", "(", "job", ".", "Context", ")", ")", ";", "err", "!=", "nil", "{", "errors", "=", "append", "(", "errors", ",", "err", ")", "\n", "}", "\n", "}", "\n", "return", "errorutil", ".", "NewAggregate", "(", "errors", "...", ")", "\n", "}"], "docstring": "// skipRequested posts skipped statuses for the config.Presubmits that are requested", "docstring_tokens": ["skipRequested", "posts", "skipped", "statuses", "for", "the", "config", ".", "Presubmits", "that", "are", "requested"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/trigger/trigger.go#L250-L262", "partition": "test"}
{"repo": "janos/web", "path": "servers/grpc/grpc.go", "func_name": "Shutdown", "original_string": "func (s *Server) Shutdown(ctx context.Context) (err error) {\n\ts.Server.GracefulStop()\n\treturn\n}", "language": "go", "code": "func (s *Server) Shutdown(ctx context.Context) (err error) {\n\ts.Server.GracefulStop()\n\treturn\n}", "code_tokens": ["func", "(", "s", "*", "Server", ")", "Shutdown", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "s", ".", "Server", ".", "GracefulStop", "(", ")", "\n", "return", "\n", "}"], "docstring": "// Shutdown executes grpc.Server.GracefulStop method.", "docstring_tokens": ["Shutdown", "executes", "grpc", ".", "Server", ".", "GracefulStop", "method", "."], "sha": "0fb0203103deb84424510a8d5166ac00700f2b0e", "url": "https://github.com/janos/web/blob/0fb0203103deb84424510a8d5166ac00700f2b0e/servers/grpc/grpc.go#L46-L49", "partition": "test"}
{"repo": "mgutz/str", "path": "funcsPZ.go", "func_name": "PadLeftF", "original_string": "func PadLeftF(c string, n int) func(string) string {\n\treturn func(s string) string {\n\t\treturn PadLeft(s, c, n)\n\t}\n}", "language": "go", "code": "func PadLeftF(c string, n int) func(string) string {\n\treturn func(s string) string {\n\t\treturn PadLeft(s, c, n)\n\t}\n}", "code_tokens": ["func", "PadLeftF", "(", "c", "string", ",", "n", "int", ")", "func", "(", "string", ")", "string", "{", "return", "func", "(", "s", "string", ")", "string", "{", "return", "PadLeft", "(", "s", ",", "c", ",", "n", ")", "\n", "}", "\n", "}"], "docstring": "// PadLeftF is the filter form of PadLeft.", "docstring_tokens": ["PadLeftF", "is", "the", "filter", "form", "of", "PadLeft", "."], "sha": "968bf66e3da857419e4f6e71b2d5c9ae95682dc4", "url": "https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsPZ.go#L45-L49", "partition": "test"}
{"repo": "google/go-cmp", "path": "cmp/cmpopts/equate.go", "func_name": "EquateNaNs", "original_string": "func EquateNaNs() cmp.Option {\n\treturn cmp.Options{\n\t\tcmp.FilterValues(areNaNsF64s, cmp.Comparer(equateAlways)),\n\t\tcmp.FilterValues(areNaNsF32s, cmp.Comparer(equateAlways)),\n\t}\n}", "language": "go", "code": "func EquateNaNs() cmp.Option {\n\treturn cmp.Options{\n\t\tcmp.FilterValues(areNaNsF64s, cmp.Comparer(equateAlways)),\n\t\tcmp.FilterValues(areNaNsF32s, cmp.Comparer(equateAlways)),\n\t}\n}", "code_tokens": ["func", "EquateNaNs", "(", ")", "cmp", ".", "Option", "{", "return", "cmp", ".", "Options", "{", "cmp", ".", "FilterValues", "(", "areNaNsF64s", ",", "cmp", ".", "Comparer", "(", "equateAlways", ")", ")", ",", "cmp", ".", "FilterValues", "(", "areNaNsF32s", ",", "cmp", ".", "Comparer", "(", "equateAlways", ")", ")", ",", "}", "\n", "}"], "docstring": "// EquateNaNs returns a Comparer option that determines float32 and float64\n// NaN values to be equal.\n//\n// EquateNaNs can be used in conjunction with EquateApprox.", "docstring_tokens": ["EquateNaNs", "returns", "a", "Comparer", "option", "that", "determines", "float32", "and", "float64", "NaN", "values", "to", "be", "equal", ".", "EquateNaNs", "can", "be", "used", "in", "conjunction", "with", "EquateApprox", "."], "sha": "6f77996f0c42f7b84e5a2b252227263f93432e9b", "url": "https://github.com/google/go-cmp/blob/6f77996f0c42f7b84e5a2b252227263f93432e9b/cmp/cmpopts/equate.go#L77-L82", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "draw2dpdf/gc.go", "func_name": "Clear", "original_string": "func (gc *GraphicContext) Clear() {\n\twidth, height := gc.pdf.GetPageSize()\n\tclearRect(gc, 0, 0, width, height)\n}", "language": "go", "code": "func (gc *GraphicContext) Clear() {\n\twidth, height := gc.pdf.GetPageSize()\n\tclearRect(gc, 0, 0, width, height)\n}", "code_tokens": ["func", "(", "gc", "*", "GraphicContext", ")", "Clear", "(", ")", "{", "width", ",", "height", ":=", "gc", ".", "pdf", ".", "GetPageSize", "(", ")", "\n", "clearRect", "(", "gc", ",", "0", ",", "0", ",", "width", ",", "height", ")", "\n", "}"], "docstring": "// Clear draws a white rectangle over the whole page", "docstring_tokens": ["Clear", "draws", "a", "white", "rectangle", "over", "the", "whole", "page"], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dpdf/gc.go#L111-L114", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "relay_messages.go", "func_name": "SetTTL", "original_string": "func (f lazyCallReq) SetTTL(d time.Duration) {\n\tttl := uint32(d / time.Millisecond)\n\tbinary.BigEndian.PutUint32(f.Payload[_ttlIndex:_ttlIndex+_ttlLen], ttl)\n}", "language": "go", "code": "func (f lazyCallReq) SetTTL(d time.Duration) {\n\tttl := uint32(d / time.Millisecond)\n\tbinary.BigEndian.PutUint32(f.Payload[_ttlIndex:_ttlIndex+_ttlLen], ttl)\n}", "code_tokens": ["func", "(", "f", "lazyCallReq", ")", "SetTTL", "(", "d", "time", ".", "Duration", ")", "{", "ttl", ":=", "uint32", "(", "d", "/", "time", ".", "Millisecond", ")", "\n", "binary", ".", "BigEndian", ".", "PutUint32", "(", "f", ".", "Payload", "[", "_ttlIndex", ":", "_ttlIndex", "+", "_ttlLen", "]", ",", "ttl", ")", "\n", "}"], "docstring": "// SetTTL overwrites the frame's TTL.", "docstring_tokens": ["SetTTL", "overwrites", "the", "frame", "s", "TTL", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/relay_messages.go#L171-L174", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/pipeline/controller.go", "func_name": "makePipelineGitResource", "original_string": "func makePipelineGitResource(pj prowjobv1.ProwJob) *pipelinev1alpha1.PipelineResource {\n\tvar revision string\n\tif pj.Spec.Refs != nil {\n\t\tif len(pj.Spec.Refs.Pulls) > 0 {\n\t\t\trevision = pj.Spec.Refs.Pulls[0].SHA\n\t\t} else {\n\t\t\trevision = pj.Spec.Refs.BaseSHA\n\t\t}\n\t}\n\tpr := pipelinev1alpha1.PipelineResource{\n\t\tObjectMeta: pipelineMeta(pj),\n\t\tSpec: pipelinev1alpha1.PipelineResourceSpec{\n\t\t\tType: pipelinev1alpha1.PipelineResourceTypeGit,\n\t\t\tParams: []pipelinev1alpha1.Param{\n\t\t\t\t{\n\t\t\t\t\tName:  \"url\",\n\t\t\t\t\tValue: sourceURL(pj),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"revision\",\n\t\t\t\t\tValue: revision,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\treturn &pr\n}", "language": "go", "code": "func makePipelineGitResource(pj prowjobv1.ProwJob) *pipelinev1alpha1.PipelineResource {\n\tvar revision string\n\tif pj.Spec.Refs != nil {\n\t\tif len(pj.Spec.Refs.Pulls) > 0 {\n\t\t\trevision = pj.Spec.Refs.Pulls[0].SHA\n\t\t} else {\n\t\t\trevision = pj.Spec.Refs.BaseSHA\n\t\t}\n\t}\n\tpr := pipelinev1alpha1.PipelineResource{\n\t\tObjectMeta: pipelineMeta(pj),\n\t\tSpec: pipelinev1alpha1.PipelineResourceSpec{\n\t\t\tType: pipelinev1alpha1.PipelineResourceTypeGit,\n\t\t\tParams: []pipelinev1alpha1.Param{\n\t\t\t\t{\n\t\t\t\t\tName:  \"url\",\n\t\t\t\t\tValue: sourceURL(pj),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"revision\",\n\t\t\t\t\tValue: revision,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\treturn &pr\n}", "code_tokens": ["func", "makePipelineGitResource", "(", "pj", "prowjobv1", ".", "ProwJob", ")", "*", "pipelinev1alpha1", ".", "PipelineResource", "{", "var", "revision", "string", "\n", "if", "pj", ".", "Spec", ".", "Refs", "!=", "nil", "{", "if", "len", "(", "pj", ".", "Spec", ".", "Refs", ".", "Pulls", ")", ">", "0", "{", "revision", "=", "pj", ".", "Spec", ".", "Refs", ".", "Pulls", "[", "0", "]", ".", "SHA", "\n", "}", "else", "{", "revision", "=", "pj", ".", "Spec", ".", "Refs", ".", "BaseSHA", "\n", "}", "\n", "}", "\n", "pr", ":=", "pipelinev1alpha1", ".", "PipelineResource", "{", "ObjectMeta", ":", "pipelineMeta", "(", "pj", ")", ",", "Spec", ":", "pipelinev1alpha1", ".", "PipelineResourceSpec", "{", "Type", ":", "pipelinev1alpha1", ".", "PipelineResourceTypeGit", ",", "Params", ":", "[", "]", "pipelinev1alpha1", ".", "Param", "{", "{", "Name", ":", "\"", "\"", ",", "Value", ":", "sourceURL", "(", "pj", ")", ",", "}", ",", "{", "Name", ":", "\"", "\"", ",", "Value", ":", "revision", ",", "}", ",", "}", ",", "}", ",", "}", "\n", "return", "&", "pr", "\n", "}"], "docstring": "// makePipelineGitResource creates a pipeline git resource from prow job", "docstring_tokens": ["makePipelineGitResource", "creates", "a", "pipeline", "git", "resource", "from", "prow", "job"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/pipeline/controller.go#L561-L587", "partition": "test"}
{"repo": "256dpi/fire", "path": "flame/models.go", "func_name": "HashSecret", "original_string": "func (a *Application) HashSecret() error {\n\t// check length\n\tif len(a.Secret) == 0 {\n\t\treturn nil\n\t}\n\n\t// generate hash from password\n\thash, err := bcrypt.GenerateFromPassword([]byte(a.Secret), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// save hash\n\ta.SecretHash = hash\n\n\t// clear password\n\ta.Secret = \"\"\n\n\treturn nil\n}", "language": "go", "code": "func (a *Application) HashSecret() error {\n\t// check length\n\tif len(a.Secret) == 0 {\n\t\treturn nil\n\t}\n\n\t// generate hash from password\n\thash, err := bcrypt.GenerateFromPassword([]byte(a.Secret), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// save hash\n\ta.SecretHash = hash\n\n\t// clear password\n\ta.Secret = \"\"\n\n\treturn nil\n}", "code_tokens": ["func", "(", "a", "*", "Application", ")", "HashSecret", "(", ")", "error", "{", "// check length", "if", "len", "(", "a", ".", "Secret", ")", "==", "0", "{", "return", "nil", "\n", "}", "\n\n", "// generate hash from password", "hash", ",", "err", ":=", "bcrypt", ".", "GenerateFromPassword", "(", "[", "]", "byte", "(", "a", ".", "Secret", ")", ",", "bcrypt", ".", "DefaultCost", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "// save hash", "a", ".", "SecretHash", "=", "hash", "\n\n", "// clear password", "a", ".", "Secret", "=", "\"", "\"", "\n\n", "return", "nil", "\n", "}"], "docstring": "// HashSecret will hash Secret and set SecretHash.", "docstring_tokens": ["HashSecret", "will", "hash", "Secret", "and", "set", "SecretHash", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/flame/models.go#L167-L186", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/jenkins/jenkins.go", "func_name": "measure", "original_string": "func (c *Client) measure(method, path string, code int, start time.Time) {\n\tif c.metrics == nil {\n\t\treturn\n\t}\n\tc.metrics.RequestLatency.WithLabelValues(method, path).Observe(time.Since(start).Seconds())\n\tc.metrics.Requests.WithLabelValues(method, path, fmt.Sprintf(\"%d\", code)).Inc()\n}", "language": "go", "code": "func (c *Client) measure(method, path string, code int, start time.Time) {\n\tif c.metrics == nil {\n\t\treturn\n\t}\n\tc.metrics.RequestLatency.WithLabelValues(method, path).Observe(time.Since(start).Seconds())\n\tc.metrics.Requests.WithLabelValues(method, path, fmt.Sprintf(\"%d\", code)).Inc()\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "measure", "(", "method", ",", "path", "string", ",", "code", "int", ",", "start", "time", ".", "Time", ")", "{", "if", "c", ".", "metrics", "==", "nil", "{", "return", "\n", "}", "\n", "c", ".", "metrics", ".", "RequestLatency", ".", "WithLabelValues", "(", "method", ",", "path", ")", ".", "Observe", "(", "time", ".", "Since", "(", "start", ")", ".", "Seconds", "(", ")", ")", "\n", "c", ".", "metrics", ".", "Requests", ".", "WithLabelValues", "(", "method", ",", "path", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "code", ")", ")", ".", "Inc", "(", ")", "\n", "}"], "docstring": "// measure records metrics about the provided method, path, and code.\n// start needs to be recorded before doing the request.", "docstring_tokens": ["measure", "records", "metrics", "about", "the", "provided", "method", "path", "and", "code", ".", "start", "needs", "to", "be", "recorded", "before", "doing", "the", "request", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/jenkins/jenkins.go#L318-L324", "partition": "test"}
{"repo": "blacksails/cgp", "path": "account.go", "func_name": "Email", "original_string": "func (a Account) Email() string {\n\treturn fmt.Sprintf(\"%s@%s\", a.Name, a.Domain.Name)\n}", "language": "go", "code": "func (a Account) Email() string {\n\treturn fmt.Sprintf(\"%s@%s\", a.Name, a.Domain.Name)\n}", "code_tokens": ["func", "(", "a", "Account", ")", "Email", "(", ")", "string", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "a", ".", "Name", ",", "a", ".", "Domain", ".", "Name", ")", "\n", "}"], "docstring": "// Email returns the primary email of the account", "docstring_tokens": ["Email", "returns", "the", "primary", "email", "of", "the", "account"], "sha": "570ac705cf2d7a9235d911d00b6f976ab3386c2f", "url": "https://github.com/blacksails/cgp/blob/570ac705cf2d7a9235d911d00b6f976ab3386c2f/account.go#L30-L32", "partition": "test"}
{"repo": "pivotal-pez/pezdispenser", "path": "service/available_inventory.go", "func_name": "GetAvailableInventory", "original_string": "func GetAvailableInventory(taskCollection integrations.Collection) (inventory map[string]skurepo.SkuBuilder) {\n\tinventory = skurepo.GetRegistry()\n\n\tonceLoadInventoryPoller.Do(func() {\n\t\tstartTaskPollingForRegisteredSkus(taskCollection)\n\t})\n\treturn\n}", "language": "go", "code": "func GetAvailableInventory(taskCollection integrations.Collection) (inventory map[string]skurepo.SkuBuilder) {\n\tinventory = skurepo.GetRegistry()\n\n\tonceLoadInventoryPoller.Do(func() {\n\t\tstartTaskPollingForRegisteredSkus(taskCollection)\n\t})\n\treturn\n}", "code_tokens": ["func", "GetAvailableInventory", "(", "taskCollection", "integrations", ".", "Collection", ")", "(", "inventory", "map", "[", "string", "]", "skurepo", ".", "SkuBuilder", ")", "{", "inventory", "=", "skurepo", ".", "GetRegistry", "(", ")", "\n\n", "onceLoadInventoryPoller", ".", "Do", "(", "func", "(", ")", "{", "startTaskPollingForRegisteredSkus", "(", "taskCollection", ")", "\n", "}", ")", "\n", "return", "\n", "}"], "docstring": "//GetAvailableInventory - this should return available inventory and start a long task poller", "docstring_tokens": ["GetAvailableInventory", "-", "this", "should", "return", "available", "inventory", "and", "start", "a", "long", "task", "poller"], "sha": "768e2777520868857916b66cfd4cfb7149383ca5", "url": "https://github.com/pivotal-pez/pezdispenser/blob/768e2777520868857916b66cfd4cfb7149383ca5/service/available_inventory.go#L21-L28", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "errors.go", "func_name": "GetContextError", "original_string": "func GetContextError(err error) error {\n\tif err == context.DeadlineExceeded {\n\t\treturn ErrTimeout\n\t}\n\tif err == context.Canceled {\n\t\treturn ErrRequestCancelled\n\t}\n\treturn err\n}", "language": "go", "code": "func GetContextError(err error) error {\n\tif err == context.DeadlineExceeded {\n\t\treturn ErrTimeout\n\t}\n\tif err == context.Canceled {\n\t\treturn ErrRequestCancelled\n\t}\n\treturn err\n}", "code_tokens": ["func", "GetContextError", "(", "err", "error", ")", "error", "{", "if", "err", "==", "context", ".", "DeadlineExceeded", "{", "return", "ErrTimeout", "\n", "}", "\n", "if", "err", "==", "context", ".", "Canceled", "{", "return", "ErrRequestCancelled", "\n", "}", "\n", "return", "err", "\n", "}"], "docstring": "// GetContextError converts the context error to a tchannel error.", "docstring_tokens": ["GetContextError", "converts", "the", "context", "error", "to", "a", "tchannel", "error", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/errors.go#L195-L203", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pfs.go", "func_name": "NewCommit", "original_string": "func NewCommit(repoName string, commitID string) *pfs.Commit {\n\treturn &pfs.Commit{\n\t\tRepo: NewRepo(repoName),\n\t\tID:   commitID,\n\t}\n}", "language": "go", "code": "func NewCommit(repoName string, commitID string) *pfs.Commit {\n\treturn &pfs.Commit{\n\t\tRepo: NewRepo(repoName),\n\t\tID:   commitID,\n\t}\n}", "code_tokens": ["func", "NewCommit", "(", "repoName", "string", ",", "commitID", "string", ")", "*", "pfs", ".", "Commit", "{", "return", "&", "pfs", ".", "Commit", "{", "Repo", ":", "NewRepo", "(", "repoName", ")", ",", "ID", ":", "commitID", ",", "}", "\n", "}"], "docstring": "// NewCommit creates a pfs.Commit.", "docstring_tokens": ["NewCommit", "creates", "a", "pfs", ".", "Commit", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L30-L35", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/retry_interceptor.go", "func_name": "withAuthRetry", "original_string": "func withAuthRetry(retryAuth bool) retryOption {\n\treturn retryOption{applyFunc: func(o *options) {\n\t\to.retryAuth = retryAuth\n\t}}\n}", "language": "go", "code": "func withAuthRetry(retryAuth bool) retryOption {\n\treturn retryOption{applyFunc: func(o *options) {\n\t\to.retryAuth = retryAuth\n\t}}\n}", "code_tokens": ["func", "withAuthRetry", "(", "retryAuth", "bool", ")", "retryOption", "{", "return", "retryOption", "{", "applyFunc", ":", "func", "(", "o", "*", "options", ")", "{", "o", ".", "retryAuth", "=", "retryAuth", "\n", "}", "}", "\n", "}"], "docstring": "// withAuthRetry sets enables authentication retries.", "docstring_tokens": ["withAuthRetry", "sets", "enables", "authentication", "retries", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/retry_interceptor.go#L332-L336", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "skiplist/merger.go", "func_name": "Next", "original_string": "func (mit *MergeIterator) Next() {\n\tmit.curr = nil\n\tif mit.h.Len() == 0 {\n\t\treturn\n\t}\n\n\to := heap.Pop(&mit.h)\n\thi := o.(heapItem)\n\tmit.curr = hi.n\n\thi.iter.Next()\n\tif hi.iter.Valid() {\n\t\thi.n = hi.iter.GetNode()\n\t\theap.Push(&mit.h, hi)\n\t}\n}", "language": "go", "code": "func (mit *MergeIterator) Next() {\n\tmit.curr = nil\n\tif mit.h.Len() == 0 {\n\t\treturn\n\t}\n\n\to := heap.Pop(&mit.h)\n\thi := o.(heapItem)\n\tmit.curr = hi.n\n\thi.iter.Next()\n\tif hi.iter.Valid() {\n\t\thi.n = hi.iter.GetNode()\n\t\theap.Push(&mit.h, hi)\n\t}\n}", "code_tokens": ["func", "(", "mit", "*", "MergeIterator", ")", "Next", "(", ")", "{", "mit", ".", "curr", "=", "nil", "\n", "if", "mit", ".", "h", ".", "Len", "(", ")", "==", "0", "{", "return", "\n", "}", "\n\n", "o", ":=", "heap", ".", "Pop", "(", "&", "mit", ".", "h", ")", "\n", "hi", ":=", "o", ".", "(", "heapItem", ")", "\n", "mit", ".", "curr", "=", "hi", ".", "n", "\n", "hi", ".", "iter", ".", "Next", "(", ")", "\n", "if", "hi", ".", "iter", ".", "Valid", "(", ")", "{", "hi", ".", "n", "=", "hi", ".", "iter", ".", "GetNode", "(", ")", "\n", "heap", ".", "Push", "(", "&", "mit", ".", "h", ",", "hi", ")", "\n", "}", "\n", "}"], "docstring": "// Next moves cursor to the next item", "docstring_tokens": ["Next", "moves", "cursor", "to", "the", "next", "item"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/skiplist/merger.go#L72-L86", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "network/network.go", "func_name": "WithPath", "original_string": "func (p SetCookieParams) WithPath(path string) *SetCookieParams {\n\tp.Path = path\n\treturn &p\n}", "language": "go", "code": "func (p SetCookieParams) WithPath(path string) *SetCookieParams {\n\tp.Path = path\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "SetCookieParams", ")", "WithPath", "(", "path", "string", ")", "*", "SetCookieParams", "{", "p", ".", "Path", "=", "path", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithPath cookie path.", "docstring_tokens": ["WithPath", "cookie", "path", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/network.go#L775-L778", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/branchprotector/request.go", "func_name": "makeRequest", "original_string": "func makeRequest(policy branchprotection.Policy) github.BranchProtectionRequest {\n\treturn github.BranchProtectionRequest{\n\t\tEnforceAdmins:              makeAdmins(policy.Admins),\n\t\tRequiredPullRequestReviews: makeReviews(policy.RequiredPullRequestReviews),\n\t\tRequiredStatusChecks:       makeChecks(policy.RequiredStatusChecks),\n\t\tRestrictions:               makeRestrictions(policy.Restrictions),\n\t}\n\n}", "language": "go", "code": "func makeRequest(policy branchprotection.Policy) github.BranchProtectionRequest {\n\treturn github.BranchProtectionRequest{\n\t\tEnforceAdmins:              makeAdmins(policy.Admins),\n\t\tRequiredPullRequestReviews: makeReviews(policy.RequiredPullRequestReviews),\n\t\tRequiredStatusChecks:       makeChecks(policy.RequiredStatusChecks),\n\t\tRestrictions:               makeRestrictions(policy.Restrictions),\n\t}\n\n}", "code_tokens": ["func", "makeRequest", "(", "policy", "branchprotection", ".", "Policy", ")", "github", ".", "BranchProtectionRequest", "{", "return", "github", ".", "BranchProtectionRequest", "{", "EnforceAdmins", ":", "makeAdmins", "(", "policy", ".", "Admins", ")", ",", "RequiredPullRequestReviews", ":", "makeReviews", "(", "policy", ".", "RequiredPullRequestReviews", ")", ",", "RequiredStatusChecks", ":", "makeChecks", "(", "policy", ".", "RequiredStatusChecks", ")", ",", "Restrictions", ":", "makeRestrictions", "(", "policy", ".", "Restrictions", ")", ",", "}", "\n\n", "}"], "docstring": "// makeRequest renders a branch protection policy into the corresponding GitHub api request.", "docstring_tokens": ["makeRequest", "renders", "a", "branch", "protection", "policy", "into", "the", "corresponding", "GitHub", "api", "request", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/branchprotector/request.go#L28-L36", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "profiler/profiler.go", "func_name": "Do", "original_string": "func (p *StartPreciseCoverageParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStartPreciseCoverage, p, nil)\n}", "language": "go", "code": "func (p *StartPreciseCoverageParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStartPreciseCoverage, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "StartPreciseCoverageParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandStartPreciseCoverage", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Profiler.startPreciseCoverage against the provided context.", "docstring_tokens": ["Do", "executes", "Profiler", ".", "startPreciseCoverage", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/profiler/profiler.go#L149-L151", "partition": "test"}
{"repo": "ant0ine/go-json-rest", "path": "rest/trie/impl.go", "func_name": "FindRoutesAndPathMatched", "original_string": "func (t *Trie) FindRoutesAndPathMatched(httpMethod, path string) ([]*Match, bool) {\n\tcontext := newFindContext()\n\tpathMatched := false\n\tmatches := []*Match{}\n\tcontext.matchFunc = func(httpMethod, path string, node *node) {\n\t\tpathMatched = true\n\t\tif node.HttpMethodToRoute[httpMethod] != nil {\n\t\t\t// path and method match, found a route !\n\t\t\tmatches = append(\n\t\t\t\tmatches,\n\t\t\t\t&Match{\n\t\t\t\t\tRoute:  node.HttpMethodToRoute[httpMethod],\n\t\t\t\t\tParams: context.paramsAsMap(),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\tt.root.find(httpMethod, path, context)\n\treturn matches, pathMatched\n}", "language": "go", "code": "func (t *Trie) FindRoutesAndPathMatched(httpMethod, path string) ([]*Match, bool) {\n\tcontext := newFindContext()\n\tpathMatched := false\n\tmatches := []*Match{}\n\tcontext.matchFunc = func(httpMethod, path string, node *node) {\n\t\tpathMatched = true\n\t\tif node.HttpMethodToRoute[httpMethod] != nil {\n\t\t\t// path and method match, found a route !\n\t\t\tmatches = append(\n\t\t\t\tmatches,\n\t\t\t\t&Match{\n\t\t\t\t\tRoute:  node.HttpMethodToRoute[httpMethod],\n\t\t\t\t\tParams: context.paramsAsMap(),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\tt.root.find(httpMethod, path, context)\n\treturn matches, pathMatched\n}", "code_tokens": ["func", "(", "t", "*", "Trie", ")", "FindRoutesAndPathMatched", "(", "httpMethod", ",", "path", "string", ")", "(", "[", "]", "*", "Match", ",", "bool", ")", "{", "context", ":=", "newFindContext", "(", ")", "\n", "pathMatched", ":=", "false", "\n", "matches", ":=", "[", "]", "*", "Match", "{", "}", "\n", "context", ".", "matchFunc", "=", "func", "(", "httpMethod", ",", "path", "string", ",", "node", "*", "node", ")", "{", "pathMatched", "=", "true", "\n", "if", "node", ".", "HttpMethodToRoute", "[", "httpMethod", "]", "!=", "nil", "{", "// path and method match, found a route !", "matches", "=", "append", "(", "matches", ",", "&", "Match", "{", "Route", ":", "node", ".", "HttpMethodToRoute", "[", "httpMethod", "]", ",", "Params", ":", "context", ".", "paramsAsMap", "(", ")", ",", "}", ",", ")", "\n", "}", "\n", "}", "\n", "t", ".", "root", ".", "find", "(", "httpMethod", ",", "path", ",", "context", ")", "\n", "return", "matches", ",", "pathMatched", "\n", "}"], "docstring": "// Same as FindRoutes, but return in addition a boolean indicating if the path was matched.\n// Useful to return 405", "docstring_tokens": ["Same", "as", "FindRoutes", "but", "return", "in", "addition", "a", "boolean", "indicating", "if", "the", "path", "was", "matched", ".", "Useful", "to", "return", "405"], "sha": "ebb33769ae013bd5f518a8bac348c310dea768b8", "url": "https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/trie/impl.go#L387-L406", "partition": "test"}
{"repo": "go-bongo/bongo", "path": "collection.go", "func_name": "Find", "original_string": "func (c *Collection) Find(query interface{}) *ResultSet {\n\tcol := c.Collection()\n\n\t// Count for testing\n\tq := col.Find(query)\n\n\tresultset := new(ResultSet)\n\n\tresultset.Query = q\n\tresultset.Params = query\n\tresultset.Collection = c\n\n\treturn resultset\n}", "language": "go", "code": "func (c *Collection) Find(query interface{}) *ResultSet {\n\tcol := c.Collection()\n\n\t// Count for testing\n\tq := col.Find(query)\n\n\tresultset := new(ResultSet)\n\n\tresultset.Query = q\n\tresultset.Params = query\n\tresultset.Collection = c\n\n\treturn resultset\n}", "code_tokens": ["func", "(", "c", "*", "Collection", ")", "Find", "(", "query", "interface", "{", "}", ")", "*", "ResultSet", "{", "col", ":=", "c", ".", "Collection", "(", ")", "\n\n", "// Count for testing", "q", ":=", "col", ".", "Find", "(", "query", ")", "\n\n", "resultset", ":=", "new", "(", "ResultSet", ")", "\n\n", "resultset", ".", "Query", "=", "q", "\n", "resultset", ".", "Params", "=", "query", "\n", "resultset", ".", "Collection", "=", "c", "\n\n", "return", "resultset", "\n", "}"], "docstring": "// This doesn't actually do any DB interaction, it just creates the result set so we can\n// start looping through on the iterator", "docstring_tokens": ["This", "doesn", "t", "actually", "do", "any", "DB", "interaction", "it", "just", "creates", "the", "result", "set", "so", "we", "can", "start", "looping", "through", "on", "the", "iterator"], "sha": "761759e31d8fed917377aa7085db01d218ce50d8", "url": "https://github.com/go-bongo/bongo/blob/761759e31d8fed917377aa7085db01d218ce50d8/collection.go#L212-L225", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "profiler/profiler.go", "func_name": "WithDetailed", "original_string": "func (p StartPreciseCoverageParams) WithDetailed(detailed bool) *StartPreciseCoverageParams {\n\tp.Detailed = detailed\n\treturn &p\n}", "language": "go", "code": "func (p StartPreciseCoverageParams) WithDetailed(detailed bool) *StartPreciseCoverageParams {\n\tp.Detailed = detailed\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "StartPreciseCoverageParams", ")", "WithDetailed", "(", "detailed", "bool", ")", "*", "StartPreciseCoverageParams", "{", "p", ".", "Detailed", "=", "detailed", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithDetailed collect block-based coverage.", "docstring_tokens": ["WithDetailed", "collect", "block", "-", "based", "coverage", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/profiler/profiler.go#L143-L146", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "migration/migration.go", "func_name": "Register", "original_string": "func Register(name string, fn MigrateFunc) error {\n\treturn register(name, false, fn)\n}", "language": "go", "code": "func Register(name string, fn MigrateFunc) error {\n\treturn register(name, false, fn)\n}", "code_tokens": ["func", "Register", "(", "name", "string", ",", "fn", "MigrateFunc", ")", "error", "{", "return", "register", "(", "name", ",", "false", ",", "fn", ")", "\n", "}"], "docstring": "// Register register a new migration for later execution with the Run\n// functions.", "docstring_tokens": ["Register", "register", "a", "new", "migration", "for", "later", "execution", "with", "the", "Run", "functions", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/migration/migration.go#L65-L67", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "typed/buffer.go", "func_name": "ReadUint64", "original_string": "func (r *ReadBuffer) ReadUint64() uint64 {\n\tif b := r.ReadBytes(8); b != nil {\n\t\treturn binary.BigEndian.Uint64(b)\n\t}\n\n\treturn 0\n}", "language": "go", "code": "func (r *ReadBuffer) ReadUint64() uint64 {\n\tif b := r.ReadBytes(8); b != nil {\n\t\treturn binary.BigEndian.Uint64(b)\n\t}\n\n\treturn 0\n}", "code_tokens": ["func", "(", "r", "*", "ReadBuffer", ")", "ReadUint64", "(", ")", "uint64", "{", "if", "b", ":=", "r", ".", "ReadBytes", "(", "8", ")", ";", "b", "!=", "nil", "{", "return", "binary", ".", "BigEndian", ".", "Uint64", "(", "b", ")", "\n", "}", "\n\n", "return", "0", "\n", "}"], "docstring": "// ReadUint64 returns the next value in the buffer as a uint64", "docstring_tokens": ["ReadUint64", "returns", "the", "next", "value", "in", "the", "buffer", "as", "a", "uint64"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/typed/buffer.go#L127-L133", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/ledger_key.go", "func_name": "SetOffer", "original_string": "func (key *LedgerKey) SetOffer(account AccountId, id uint64) error {\n\tdata := LedgerKeyOffer{account, Uint64(id)}\n\tnkey, err := NewLedgerKey(LedgerEntryTypeOffer, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t*key = nkey\n\treturn nil\n}", "language": "go", "code": "func (key *LedgerKey) SetOffer(account AccountId, id uint64) error {\n\tdata := LedgerKeyOffer{account, Uint64(id)}\n\tnkey, err := NewLedgerKey(LedgerEntryTypeOffer, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t*key = nkey\n\treturn nil\n}", "code_tokens": ["func", "(", "key", "*", "LedgerKey", ")", "SetOffer", "(", "account", "AccountId", ",", "id", "uint64", ")", "error", "{", "data", ":=", "LedgerKeyOffer", "{", "account", ",", "Uint64", "(", "id", ")", "}", "\n", "nkey", ",", "err", ":=", "NewLedgerKey", "(", "LedgerEntryTypeOffer", ",", "data", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "*", "key", "=", "nkey", "\n", "return", "nil", "\n", "}"], "docstring": "// SetOffer mutates `key` such that it represents the identity of the\n// data entry owned by `account` and for offer `id`.", "docstring_tokens": ["SetOffer", "mutates", "key", "such", "that", "it", "represents", "the", "identity", "of", "the", "data", "entry", "owned", "by", "account", "and", "for", "offer", "id", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/ledger_key.go#L65-L74", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/plugins.go", "func_name": "ReviewCommentEventHandlers", "original_string": "func (pa *ConfigAgent) ReviewCommentEventHandlers(owner, repo string) map[string]ReviewCommentEventHandler {\n\tpa.mut.Lock()\n\tdefer pa.mut.Unlock()\n\n\ths := map[string]ReviewCommentEventHandler{}\n\tfor _, p := range pa.getPlugins(owner, repo) {\n\t\tif h, ok := reviewCommentEventHandlers[p]; ok {\n\t\t\ths[p] = h\n\t\t}\n\t}\n\n\treturn hs\n}", "language": "go", "code": "func (pa *ConfigAgent) ReviewCommentEventHandlers(owner, repo string) map[string]ReviewCommentEventHandler {\n\tpa.mut.Lock()\n\tdefer pa.mut.Unlock()\n\n\ths := map[string]ReviewCommentEventHandler{}\n\tfor _, p := range pa.getPlugins(owner, repo) {\n\t\tif h, ok := reviewCommentEventHandlers[p]; ok {\n\t\t\ths[p] = h\n\t\t}\n\t}\n\n\treturn hs\n}", "code_tokens": ["func", "(", "pa", "*", "ConfigAgent", ")", "ReviewCommentEventHandlers", "(", "owner", ",", "repo", "string", ")", "map", "[", "string", "]", "ReviewCommentEventHandler", "{", "pa", ".", "mut", ".", "Lock", "(", ")", "\n", "defer", "pa", ".", "mut", ".", "Unlock", "(", ")", "\n\n", "hs", ":=", "map", "[", "string", "]", "ReviewCommentEventHandler", "{", "}", "\n", "for", "_", ",", "p", ":=", "range", "pa", ".", "getPlugins", "(", "owner", ",", "repo", ")", "{", "if", "h", ",", "ok", ":=", "reviewCommentEventHandlers", "[", "p", "]", ";", "ok", "{", "hs", "[", "p", "]", "=", "h", "\n", "}", "\n", "}", "\n\n", "return", "hs", "\n", "}"], "docstring": "// ReviewCommentEventHandlers returns a map of plugin names to handlers for the repo.", "docstring_tokens": ["ReviewCommentEventHandlers", "returns", "a", "map", "of", "plugin", "names", "to", "handlers", "for", "the", "repo", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/plugins.go#L333-L345", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/profiles.go", "func_name": "ProfileGet", "original_string": "func (c *Cluster) ProfileGet(project, name string) (int64, *api.Profile, error) {\n\tvar result *api.Profile\n\tvar id int64\n\n\terr := c.Transaction(func(tx *ClusterTx) error {\n\t\tenabled, err := tx.ProjectHasProfiles(project)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"Check if project has profiles\")\n\t\t}\n\t\tif !enabled {\n\t\t\tproject = \"default\"\n\t\t}\n\n\t\tprofile, err := tx.ProfileGet(project, name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresult = ProfileToAPI(profile)\n\t\tid = int64(profile.ID)\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\treturn id, result, nil\n}", "language": "go", "code": "func (c *Cluster) ProfileGet(project, name string) (int64, *api.Profile, error) {\n\tvar result *api.Profile\n\tvar id int64\n\n\terr := c.Transaction(func(tx *ClusterTx) error {\n\t\tenabled, err := tx.ProjectHasProfiles(project)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"Check if project has profiles\")\n\t\t}\n\t\tif !enabled {\n\t\t\tproject = \"default\"\n\t\t}\n\n\t\tprofile, err := tx.ProfileGet(project, name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresult = ProfileToAPI(profile)\n\t\tid = int64(profile.ID)\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\treturn id, result, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "ProfileGet", "(", "project", ",", "name", "string", ")", "(", "int64", ",", "*", "api", ".", "Profile", ",", "error", ")", "{", "var", "result", "*", "api", ".", "Profile", "\n", "var", "id", "int64", "\n\n", "err", ":=", "c", ".", "Transaction", "(", "func", "(", "tx", "*", "ClusterTx", ")", "error", "{", "enabled", ",", "err", ":=", "tx", ".", "ProjectHasProfiles", "(", "project", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "if", "!", "enabled", "{", "project", "=", "\"", "\"", "\n", "}", "\n\n", "profile", ",", "err", ":=", "tx", ".", "ProfileGet", "(", "project", ",", "name", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "result", "=", "ProfileToAPI", "(", "profile", ")", "\n", "id", "=", "int64", "(", "profile", ".", "ID", ")", "\n\n", "return", "nil", "\n", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "-", "1", ",", "nil", ",", "err", "\n", "}", "\n\n", "return", "id", ",", "result", ",", "nil", "\n", "}"], "docstring": "// ProfileGet returns the profile with the given name.", "docstring_tokens": ["ProfileGet", "returns", "the", "profile", "with", "the", "given", "name", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/profiles.go#L121-L149", "partition": "test"}
{"repo": "libp2p/go-libp2p-pubsub", "path": "pubsub.go", "func_name": "handleAddSubscription", "original_string": "func (p *PubSub) handleAddSubscription(req *addSubReq) {\n\tsub := req.sub\n\tsubs := p.myTopics[sub.topic]\n\n\t// announce we want this topic\n\tif len(subs) == 0 {\n\t\tp.announce(sub.topic, true)\n\t\tp.rt.Join(sub.topic)\n\t}\n\n\t// make new if not there\n\tif subs == nil {\n\t\tp.myTopics[sub.topic] = make(map[*Subscription]struct{})\n\t\tsubs = p.myTopics[sub.topic]\n\t}\n\n\tsub.ch = make(chan *Message, 32)\n\tsub.cancelCh = p.cancelCh\n\n\tp.myTopics[sub.topic][sub] = struct{}{}\n\n\treq.resp <- sub\n}", "language": "go", "code": "func (p *PubSub) handleAddSubscription(req *addSubReq) {\n\tsub := req.sub\n\tsubs := p.myTopics[sub.topic]\n\n\t// announce we want this topic\n\tif len(subs) == 0 {\n\t\tp.announce(sub.topic, true)\n\t\tp.rt.Join(sub.topic)\n\t}\n\n\t// make new if not there\n\tif subs == nil {\n\t\tp.myTopics[sub.topic] = make(map[*Subscription]struct{})\n\t\tsubs = p.myTopics[sub.topic]\n\t}\n\n\tsub.ch = make(chan *Message, 32)\n\tsub.cancelCh = p.cancelCh\n\n\tp.myTopics[sub.topic][sub] = struct{}{}\n\n\treq.resp <- sub\n}", "code_tokens": ["func", "(", "p", "*", "PubSub", ")", "handleAddSubscription", "(", "req", "*", "addSubReq", ")", "{", "sub", ":=", "req", ".", "sub", "\n", "subs", ":=", "p", ".", "myTopics", "[", "sub", ".", "topic", "]", "\n\n", "// announce we want this topic", "if", "len", "(", "subs", ")", "==", "0", "{", "p", ".", "announce", "(", "sub", ".", "topic", ",", "true", ")", "\n", "p", ".", "rt", ".", "Join", "(", "sub", ".", "topic", ")", "\n", "}", "\n\n", "// make new if not there", "if", "subs", "==", "nil", "{", "p", ".", "myTopics", "[", "sub", ".", "topic", "]", "=", "make", "(", "map", "[", "*", "Subscription", "]", "struct", "{", "}", ")", "\n", "subs", "=", "p", ".", "myTopics", "[", "sub", ".", "topic", "]", "\n", "}", "\n\n", "sub", ".", "ch", "=", "make", "(", "chan", "*", "Message", ",", "32", ")", "\n", "sub", ".", "cancelCh", "=", "p", ".", "cancelCh", "\n\n", "p", ".", "myTopics", "[", "sub", ".", "topic", "]", "[", "sub", "]", "=", "struct", "{", "}", "{", "}", "\n\n", "req", ".", "resp", "<-", "sub", "\n", "}"], "docstring": "// handleAddSubscription adds a Subscription for a particular topic. If it is\n// the first Subscription for the topic, it will announce that this node\n// subscribes to the topic.\n// Only called from processLoop.", "docstring_tokens": ["handleAddSubscription", "adds", "a", "Subscription", "for", "a", "particular", "topic", ".", "If", "it", "is", "the", "first", "Subscription", "for", "the", "topic", "it", "will", "announce", "that", "this", "node", "subscribes", "to", "the", "topic", ".", "Only", "called", "from", "processLoop", "."], "sha": "9db3dbdde90f44d1c420192c5cefd60682fbdbb9", "url": "https://github.com/libp2p/go-libp2p-pubsub/blob/9db3dbdde90f44d1c420192c5cefd60682fbdbb9/pubsub.go#L449-L471", "partition": "test"}
{"repo": "golang/appengine", "path": "user/user.go", "func_name": "LoginURLFederated", "original_string": "func LoginURLFederated(c context.Context, dest, identity string) (string, error) {\n\treq := &pb.CreateLoginURLRequest{\n\t\tDestinationUrl: proto.String(dest),\n\t}\n\tif identity != \"\" {\n\t\treq.FederatedIdentity = proto.String(identity)\n\t}\n\tres := &pb.CreateLoginURLResponse{}\n\tif err := internal.Call(c, \"user\", \"CreateLoginURL\", req, res); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn *res.LoginUrl, nil\n}", "language": "go", "code": "func LoginURLFederated(c context.Context, dest, identity string) (string, error) {\n\treq := &pb.CreateLoginURLRequest{\n\t\tDestinationUrl: proto.String(dest),\n\t}\n\tif identity != \"\" {\n\t\treq.FederatedIdentity = proto.String(identity)\n\t}\n\tres := &pb.CreateLoginURLResponse{}\n\tif err := internal.Call(c, \"user\", \"CreateLoginURL\", req, res); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn *res.LoginUrl, nil\n}", "code_tokens": ["func", "LoginURLFederated", "(", "c", "context", ".", "Context", ",", "dest", ",", "identity", "string", ")", "(", "string", ",", "error", ")", "{", "req", ":=", "&", "pb", ".", "CreateLoginURLRequest", "{", "DestinationUrl", ":", "proto", ".", "String", "(", "dest", ")", ",", "}", "\n", "if", "identity", "!=", "\"", "\"", "{", "req", ".", "FederatedIdentity", "=", "proto", ".", "String", "(", "identity", ")", "\n", "}", "\n", "res", ":=", "&", "pb", ".", "CreateLoginURLResponse", "{", "}", "\n", "if", "err", ":=", "internal", ".", "Call", "(", "c", ",", "\"", "\"", ",", "\"", "\"", ",", "req", ",", "res", ")", ";", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n", "return", "*", "res", ".", "LoginUrl", ",", "nil", "\n", "}"], "docstring": "// LoginURLFederated is like LoginURL but accepts a user's OpenID identifier.", "docstring_tokens": ["LoginURLFederated", "is", "like", "LoginURL", "but", "accepts", "a", "user", "s", "OpenID", "identifier", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/user/user.go#L55-L67", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/pretty/pretty.go", "func_name": "Duration", "original_string": "func Duration(d *types.Duration) string {\n\tduration, _ := types.DurationFromProto(d)\n\treturn units.HumanDuration(duration)\n}", "language": "go", "code": "func Duration(d *types.Duration) string {\n\tduration, _ := types.DurationFromProto(d)\n\treturn units.HumanDuration(duration)\n}", "code_tokens": ["func", "Duration", "(", "d", "*", "types", ".", "Duration", ")", "string", "{", "duration", ",", "_", ":=", "types", ".", "DurationFromProto", "(", "d", ")", "\n", "return", "units", ".", "HumanDuration", "(", "duration", ")", "\n", "}"], "docstring": "// Duration pretty prints a duration in a human readable way.", "docstring_tokens": ["Duration", "pretty", "prints", "a", "duration", "in", "a", "human", "readable", "way", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/pretty/pretty.go#L38-L41", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/retry_interceptor.go", "func_name": "withRetryPolicy", "original_string": "func withRetryPolicy(rp retryPolicy) retryOption {\n\treturn retryOption{applyFunc: func(o *options) {\n\t\to.retryPolicy = rp\n\t}}\n}", "language": "go", "code": "func withRetryPolicy(rp retryPolicy) retryOption {\n\treturn retryOption{applyFunc: func(o *options) {\n\t\to.retryPolicy = rp\n\t}}\n}", "code_tokens": ["func", "withRetryPolicy", "(", "rp", "retryPolicy", ")", "retryOption", "{", "return", "retryOption", "{", "applyFunc", ":", "func", "(", "o", "*", "options", ")", "{", "o", ".", "retryPolicy", "=", "rp", "\n", "}", "}", "\n", "}"], "docstring": "// withRetryPolicy sets the retry policy of this call.", "docstring_tokens": ["withRetryPolicy", "sets", "the", "retry", "policy", "of", "this", "call", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/retry_interceptor.go#L325-L329", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/daemon.go", "func_name": "setupExternalAuthentication", "original_string": "func (d *Daemon) setupExternalAuthentication(authEndpoint string, authPubkey string, expiry int64, domains string) error {\n\t// Parse the list of domains\n\tauthDomains := []string{}\n\tfor _, domain := range strings.Split(domains, \",\") {\n\t\tif domain == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tauthDomains = append(authDomains, strings.TrimSpace(domain))\n\t}\n\n\t// Allow disable external authentication\n\tif authEndpoint == \"\" {\n\t\td.externalAuth = nil\n\t\treturn nil\n\t}\n\n\t// Setup the candid client\n\tidmClient, err := candidclient.New(candidclient.NewParams{\n\t\tBaseURL: authEndpoint,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tidmClientWrapper := &IdentityClientWrapper{\n\t\tclient:       idmClient,\n\t\tValidDomains: authDomains,\n\t}\n\n\t// Generate an internal private key\n\tkey, err := bakery.GenerateKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpkCache := bakery.NewThirdPartyStore()\n\tpkLocator := httpbakery.NewThirdPartyLocator(nil, pkCache)\n\tif authPubkey != \"\" {\n\t\t// Parse the public key\n\t\tpkKey := bakery.Key{}\n\t\terr := pkKey.UnmarshalText([]byte(authPubkey))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Add the key information\n\t\tpkCache.AddInfo(authEndpoint, bakery.ThirdPartyInfo{\n\t\t\tPublicKey: bakery.PublicKey{Key: pkKey},\n\t\t\tVersion:   3,\n\t\t})\n\n\t\t// Allow http URLs if we have a public key set\n\t\tif strings.HasPrefix(authEndpoint, \"http://\") {\n\t\t\tpkLocator.AllowInsecure()\n\t\t}\n\t}\n\n\t// Setup the bakery\n\tbakery := identchecker.NewBakery(identchecker.BakeryParams{\n\t\tKey:            key,\n\t\tLocation:       authEndpoint,\n\t\tLocator:        pkLocator,\n\t\tChecker:        httpbakery.NewChecker(),\n\t\tIdentityClient: idmClientWrapper,\n\t\tAuthorizer: identchecker.ACLAuthorizer{\n\t\t\tGetACL: func(ctx context.Context, op bakery.Op) ([]string, bool, error) {\n\t\t\t\treturn []string{identchecker.Everyone}, false, nil\n\t\t\t},\n\t\t},\n\t})\n\n\t// Store our settings\n\td.externalAuth = &externalAuth{\n\t\tendpoint: authEndpoint,\n\t\texpiry:   expiry,\n\t\tbakery:   bakery,\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (d *Daemon) setupExternalAuthentication(authEndpoint string, authPubkey string, expiry int64, domains string) error {\n\t// Parse the list of domains\n\tauthDomains := []string{}\n\tfor _, domain := range strings.Split(domains, \",\") {\n\t\tif domain == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tauthDomains = append(authDomains, strings.TrimSpace(domain))\n\t}\n\n\t// Allow disable external authentication\n\tif authEndpoint == \"\" {\n\t\td.externalAuth = nil\n\t\treturn nil\n\t}\n\n\t// Setup the candid client\n\tidmClient, err := candidclient.New(candidclient.NewParams{\n\t\tBaseURL: authEndpoint,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tidmClientWrapper := &IdentityClientWrapper{\n\t\tclient:       idmClient,\n\t\tValidDomains: authDomains,\n\t}\n\n\t// Generate an internal private key\n\tkey, err := bakery.GenerateKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpkCache := bakery.NewThirdPartyStore()\n\tpkLocator := httpbakery.NewThirdPartyLocator(nil, pkCache)\n\tif authPubkey != \"\" {\n\t\t// Parse the public key\n\t\tpkKey := bakery.Key{}\n\t\terr := pkKey.UnmarshalText([]byte(authPubkey))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Add the key information\n\t\tpkCache.AddInfo(authEndpoint, bakery.ThirdPartyInfo{\n\t\t\tPublicKey: bakery.PublicKey{Key: pkKey},\n\t\t\tVersion:   3,\n\t\t})\n\n\t\t// Allow http URLs if we have a public key set\n\t\tif strings.HasPrefix(authEndpoint, \"http://\") {\n\t\t\tpkLocator.AllowInsecure()\n\t\t}\n\t}\n\n\t// Setup the bakery\n\tbakery := identchecker.NewBakery(identchecker.BakeryParams{\n\t\tKey:            key,\n\t\tLocation:       authEndpoint,\n\t\tLocator:        pkLocator,\n\t\tChecker:        httpbakery.NewChecker(),\n\t\tIdentityClient: idmClientWrapper,\n\t\tAuthorizer: identchecker.ACLAuthorizer{\n\t\t\tGetACL: func(ctx context.Context, op bakery.Op) ([]string, bool, error) {\n\t\t\t\treturn []string{identchecker.Everyone}, false, nil\n\t\t\t},\n\t\t},\n\t})\n\n\t// Store our settings\n\td.externalAuth = &externalAuth{\n\t\tendpoint: authEndpoint,\n\t\texpiry:   expiry,\n\t\tbakery:   bakery,\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "d", "*", "Daemon", ")", "setupExternalAuthentication", "(", "authEndpoint", "string", ",", "authPubkey", "string", ",", "expiry", "int64", ",", "domains", "string", ")", "error", "{", "// Parse the list of domains", "authDomains", ":=", "[", "]", "string", "{", "}", "\n", "for", "_", ",", "domain", ":=", "range", "strings", ".", "Split", "(", "domains", ",", "\"", "\"", ")", "{", "if", "domain", "==", "\"", "\"", "{", "continue", "\n", "}", "\n\n", "authDomains", "=", "append", "(", "authDomains", ",", "strings", ".", "TrimSpace", "(", "domain", ")", ")", "\n", "}", "\n\n", "// Allow disable external authentication", "if", "authEndpoint", "==", "\"", "\"", "{", "d", ".", "externalAuth", "=", "nil", "\n", "return", "nil", "\n", "}", "\n\n", "// Setup the candid client", "idmClient", ",", "err", ":=", "candidclient", ".", "New", "(", "candidclient", ".", "NewParams", "{", "BaseURL", ":", "authEndpoint", ",", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "idmClientWrapper", ":=", "&", "IdentityClientWrapper", "{", "client", ":", "idmClient", ",", "ValidDomains", ":", "authDomains", ",", "}", "\n\n", "// Generate an internal private key", "key", ",", "err", ":=", "bakery", ".", "GenerateKey", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "pkCache", ":=", "bakery", ".", "NewThirdPartyStore", "(", ")", "\n", "pkLocator", ":=", "httpbakery", ".", "NewThirdPartyLocator", "(", "nil", ",", "pkCache", ")", "\n", "if", "authPubkey", "!=", "\"", "\"", "{", "// Parse the public key", "pkKey", ":=", "bakery", ".", "Key", "{", "}", "\n", "err", ":=", "pkKey", ".", "UnmarshalText", "(", "[", "]", "byte", "(", "authPubkey", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "// Add the key information", "pkCache", ".", "AddInfo", "(", "authEndpoint", ",", "bakery", ".", "ThirdPartyInfo", "{", "PublicKey", ":", "bakery", ".", "PublicKey", "{", "Key", ":", "pkKey", "}", ",", "Version", ":", "3", ",", "}", ")", "\n\n", "// Allow http URLs if we have a public key set", "if", "strings", ".", "HasPrefix", "(", "authEndpoint", ",", "\"", "\"", ")", "{", "pkLocator", ".", "AllowInsecure", "(", ")", "\n", "}", "\n", "}", "\n\n", "// Setup the bakery", "bakery", ":=", "identchecker", ".", "NewBakery", "(", "identchecker", ".", "BakeryParams", "{", "Key", ":", "key", ",", "Location", ":", "authEndpoint", ",", "Locator", ":", "pkLocator", ",", "Checker", ":", "httpbakery", ".", "NewChecker", "(", ")", ",", "IdentityClient", ":", "idmClientWrapper", ",", "Authorizer", ":", "identchecker", ".", "ACLAuthorizer", "{", "GetACL", ":", "func", "(", "ctx", "context", ".", "Context", ",", "op", "bakery", ".", "Op", ")", "(", "[", "]", "string", ",", "bool", ",", "error", ")", "{", "return", "[", "]", "string", "{", "identchecker", ".", "Everyone", "}", ",", "false", ",", "nil", "\n", "}", ",", "}", ",", "}", ")", "\n\n", "// Store our settings", "d", ".", "externalAuth", "=", "&", "externalAuth", "{", "endpoint", ":", "authEndpoint", ",", "expiry", ":", "expiry", ",", "bakery", ":", "bakery", ",", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Setup external authentication", "docstring_tokens": ["Setup", "external", "authentication"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/daemon.go#L1084-L1164", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "samples/linecapjoin/linecapjoin.go", "func_name": "Main", "original_string": "func Main(gc draw2d.GraphicContext, ext string) (string, error) {\n\t// Draw the line\n\tconst offset = 75.0\n\tx := 35.0\n\tcaps := []draw2d.LineCap{draw2d.ButtCap, draw2d.SquareCap, draw2d.RoundCap}\n\tjoins := []draw2d.LineJoin{draw2d.BevelJoin, draw2d.MiterJoin, draw2d.RoundJoin}\n\tfor i := range caps {\n\t\tDraw(gc, caps[i], joins[i], x, 50, x, 160, offset)\n\t\tx += offset\n\t}\n\n\t// Return the output filename\n\treturn samples.Output(\"linecapjoin\", ext), nil\n}", "language": "go", "code": "func Main(gc draw2d.GraphicContext, ext string) (string, error) {\n\t// Draw the line\n\tconst offset = 75.0\n\tx := 35.0\n\tcaps := []draw2d.LineCap{draw2d.ButtCap, draw2d.SquareCap, draw2d.RoundCap}\n\tjoins := []draw2d.LineJoin{draw2d.BevelJoin, draw2d.MiterJoin, draw2d.RoundJoin}\n\tfor i := range caps {\n\t\tDraw(gc, caps[i], joins[i], x, 50, x, 160, offset)\n\t\tx += offset\n\t}\n\n\t// Return the output filename\n\treturn samples.Output(\"linecapjoin\", ext), nil\n}", "code_tokens": ["func", "Main", "(", "gc", "draw2d", ".", "GraphicContext", ",", "ext", "string", ")", "(", "string", ",", "error", ")", "{", "// Draw the line", "const", "offset", "=", "75.0", "\n", "x", ":=", "35.0", "\n", "caps", ":=", "[", "]", "draw2d", ".", "LineCap", "{", "draw2d", ".", "ButtCap", ",", "draw2d", ".", "SquareCap", ",", "draw2d", ".", "RoundCap", "}", "\n", "joins", ":=", "[", "]", "draw2d", ".", "LineJoin", "{", "draw2d", ".", "BevelJoin", ",", "draw2d", ".", "MiterJoin", ",", "draw2d", ".", "RoundJoin", "}", "\n", "for", "i", ":=", "range", "caps", "{", "Draw", "(", "gc", ",", "caps", "[", "i", "]", ",", "joins", "[", "i", "]", ",", "x", ",", "50", ",", "x", ",", "160", ",", "offset", ")", "\n", "x", "+=", "offset", "\n", "}", "\n\n", "// Return the output filename", "return", "samples", ".", "Output", "(", "\"", "\"", ",", "ext", ")", ",", "nil", "\n", "}"], "docstring": "// Main draws the different line caps and joins.\n// This should only be used during testing.", "docstring_tokens": ["Main", "draws", "the", "different", "line", "caps", "and", "joins", ".", "This", "should", "only", "be", "used", "during", "testing", "."], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/samples/linecapjoin/linecapjoin.go#L16-L29", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "cookies.go", "func_name": "Get", "original_string": "func (c *Cookies) Get(name string) (string, error) {\n\tck, err := c.req.Cookie(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn ck.Value, nil\n}", "language": "go", "code": "func (c *Cookies) Get(name string) (string, error) {\n\tck, err := c.req.Cookie(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn ck.Value, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cookies", ")", "Get", "(", "name", "string", ")", "(", "string", ",", "error", ")", "{", "ck", ",", "err", ":=", "c", ".", "req", ".", "Cookie", "(", "name", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n\n", "return", "ck", ".", "Value", ",", "nil", "\n", "}"], "docstring": "// Get returns the value of the cookie with the given name. Returns http.ErrNoCookie if there's no cookie with that name in the request.", "docstring_tokens": ["Get", "returns", "the", "value", "of", "the", "cookie", "with", "the", "given", "name", ".", "Returns", "http", ".", "ErrNoCookie", "if", "there", "s", "no", "cookie", "with", "that", "name", "in", "the", "request", "."], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/cookies.go#L15-L22", "partition": "test"}
{"repo": "kpango/glg", "path": "glg.go", "func_name": "Fatalf", "original_string": "func (g *Glg) Fatalf(format string, val ...interface{}) {\n\terr := g.out(FATAL, format, val...)\n\tif err != nil {\n\t\terr = g.Error(err.Error())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\texit(1)\n}", "language": "go", "code": "func (g *Glg) Fatalf(format string, val ...interface{}) {\n\terr := g.out(FATAL, format, val...)\n\tif err != nil {\n\t\terr = g.Error(err.Error())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\texit(1)\n}", "code_tokens": ["func", "(", "g", "*", "Glg", ")", "Fatalf", "(", "format", "string", ",", "val", "...", "interface", "{", "}", ")", "{", "err", ":=", "g", ".", "out", "(", "FATAL", ",", "format", ",", "val", "...", ")", "\n", "if", "err", "!=", "nil", "{", "err", "=", "g", ".", "Error", "(", "err", ".", "Error", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "panic", "(", "err", ")", "\n", "}", "\n", "}", "\n", "exit", "(", "1", ")", "\n", "}"], "docstring": "// Fatalf outputs formatted Failed log and exit program", "docstring_tokens": ["Fatalf", "outputs", "formatted", "Failed", "log", "and", "exit", "program"], "sha": "68d2670cb2dbff047331daad841149a82ac37796", "url": "https://github.com/kpango/glg/blob/68d2670cb2dbff047331daad841149a82ac37796/glg.go#L1063-L1072", "partition": "test"}
{"repo": "siddontang/go-log", "path": "log/logger.go", "func_name": "Debugln", "original_string": "func (l *Logger) Debugln(args ...interface{}) {\n\tl.Output(2, LevelDebug, fmt.Sprintln(args...))\n}", "language": "go", "code": "func (l *Logger) Debugln(args ...interface{}) {\n\tl.Output(2, LevelDebug, fmt.Sprintln(args...))\n}", "code_tokens": ["func", "(", "l", "*", "Logger", ")", "Debugln", "(", "args", "...", "interface", "{", "}", ")", "{", "l", ".", "Output", "(", "2", ",", "LevelDebug", ",", "fmt", ".", "Sprintln", "(", "args", "...", ")", ")", "\n", "}"], "docstring": "// Debugln records the log with debug level", "docstring_tokens": ["Debugln", "records", "the", "log", "with", "debug", "level"], "sha": "1e957dd83bed18c84716181da7b80d4af48eaefe", "url": "https://github.com/siddontang/go-log/blob/1e957dd83bed18c84716181da7b80d4af48eaefe/log/logger.go#L311-L313", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "router.go", "func_name": "OnGossipBroadcast", "original_string": "func (router *Router) OnGossipBroadcast(_ PeerName, update []byte) (GossipData, error) {\n\torigUpdate, _, err := router.applyTopologyUpdate(update)\n\tif err != nil || len(origUpdate) == 0 {\n\t\treturn nil, err\n\t}\n\treturn &topologyGossipData{peers: router.Peers, update: origUpdate}, nil\n}", "language": "go", "code": "func (router *Router) OnGossipBroadcast(_ PeerName, update []byte) (GossipData, error) {\n\torigUpdate, _, err := router.applyTopologyUpdate(update)\n\tif err != nil || len(origUpdate) == 0 {\n\t\treturn nil, err\n\t}\n\treturn &topologyGossipData{peers: router.Peers, update: origUpdate}, nil\n}", "code_tokens": ["func", "(", "router", "*", "Router", ")", "OnGossipBroadcast", "(", "_", "PeerName", ",", "update", "[", "]", "byte", ")", "(", "GossipData", ",", "error", ")", "{", "origUpdate", ",", "_", ",", "err", ":=", "router", ".", "applyTopologyUpdate", "(", "update", ")", "\n", "if", "err", "!=", "nil", "||", "len", "(", "origUpdate", ")", "==", "0", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "&", "topologyGossipData", "{", "peers", ":", "router", ".", "Peers", ",", "update", ":", "origUpdate", "}", ",", "nil", "\n", "}"], "docstring": "// OnGossipBroadcast receives broadcasts of TopologyGossipData.\n// It returns the received update unchanged.", "docstring_tokens": ["OnGossipBroadcast", "receives", "broadcasts", "of", "TopologyGossipData", ".", "It", "returns", "the", "received", "update", "unchanged", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/router.go#L240-L246", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "storage/storage.go", "func_name": "Do", "original_string": "func (p *UntrackCacheStorageForOriginParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandUntrackCacheStorageForOrigin, p, nil)\n}", "language": "go", "code": "func (p *UntrackCacheStorageForOriginParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandUntrackCacheStorageForOrigin, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "UntrackCacheStorageForOriginParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandUntrackCacheStorageForOrigin", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Storage.untrackCacheStorageForOrigin against the provided context.", "docstring_tokens": ["Do", "executes", "Storage", ".", "untrackCacheStorageForOrigin", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/storage/storage.go#L149-L151", "partition": "test"}
{"repo": "ipfs/go-ipfs-api", "path": "add.go", "func_name": "AddDir", "original_string": "func (s *Shell) AddDir(dir string) (string, error) {\n\tstat, err := os.Lstat(dir)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tsf, err := files.NewSerialFile(dir, false, stat)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tslf := files.NewSliceDirectory([]files.DirEntry{files.FileEntry(filepath.Base(dir), sf)})\n\treader := files.NewMultiFileReader(slf, true)\n\n\tresp, err := s.Request(\"add\").\n\t\tOption(\"recursive\", true).\n\t\tBody(reader).\n\t\tSend(context.Background())\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\n\tdefer resp.Close()\n\n\tif resp.Error != nil {\n\t\treturn \"\", resp.Error\n\t}\n\n\tdec := json.NewDecoder(resp.Output)\n\tvar final string\n\tfor {\n\t\tvar out object\n\t\terr = dec.Decode(&out)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t\tfinal = out.Hash\n\t}\n\n\tif final == \"\" {\n\t\treturn \"\", errors.New(\"no results received\")\n\t}\n\n\treturn final, nil\n}", "language": "go", "code": "func (s *Shell) AddDir(dir string) (string, error) {\n\tstat, err := os.Lstat(dir)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tsf, err := files.NewSerialFile(dir, false, stat)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tslf := files.NewSliceDirectory([]files.DirEntry{files.FileEntry(filepath.Base(dir), sf)})\n\treader := files.NewMultiFileReader(slf, true)\n\n\tresp, err := s.Request(\"add\").\n\t\tOption(\"recursive\", true).\n\t\tBody(reader).\n\t\tSend(context.Background())\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\n\tdefer resp.Close()\n\n\tif resp.Error != nil {\n\t\treturn \"\", resp.Error\n\t}\n\n\tdec := json.NewDecoder(resp.Output)\n\tvar final string\n\tfor {\n\t\tvar out object\n\t\terr = dec.Decode(&out)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t\tfinal = out.Hash\n\t}\n\n\tif final == \"\" {\n\t\treturn \"\", errors.New(\"no results received\")\n\t}\n\n\treturn final, nil\n}", "code_tokens": ["func", "(", "s", "*", "Shell", ")", "AddDir", "(", "dir", "string", ")", "(", "string", ",", "error", ")", "{", "stat", ",", "err", ":=", "os", ".", "Lstat", "(", "dir", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n\n", "sf", ",", "err", ":=", "files", ".", "NewSerialFile", "(", "dir", ",", "false", ",", "stat", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n", "slf", ":=", "files", ".", "NewSliceDirectory", "(", "[", "]", "files", ".", "DirEntry", "{", "files", ".", "FileEntry", "(", "filepath", ".", "Base", "(", "dir", ")", ",", "sf", ")", "}", ")", "\n", "reader", ":=", "files", ".", "NewMultiFileReader", "(", "slf", ",", "true", ")", "\n\n", "resp", ",", "err", ":=", "s", ".", "Request", "(", "\"", "\"", ")", ".", "Option", "(", "\"", "\"", ",", "true", ")", ".", "Body", "(", "reader", ")", ".", "Send", "(", "context", ".", "Background", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "nil", "\n", "}", "\n\n", "defer", "resp", ".", "Close", "(", ")", "\n\n", "if", "resp", ".", "Error", "!=", "nil", "{", "return", "\"", "\"", ",", "resp", ".", "Error", "\n", "}", "\n\n", "dec", ":=", "json", ".", "NewDecoder", "(", "resp", ".", "Output", ")", "\n", "var", "final", "string", "\n", "for", "{", "var", "out", "object", "\n", "err", "=", "dec", ".", "Decode", "(", "&", "out", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", "==", "io", ".", "EOF", "{", "break", "\n", "}", "\n", "return", "\"", "\"", ",", "err", "\n", "}", "\n", "final", "=", "out", ".", "Hash", "\n", "}", "\n\n", "if", "final", "==", "\"", "\"", "{", "return", "\"", "\"", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "final", ",", "nil", "\n", "}"], "docstring": "// AddDir adds a directory recursively with all of the files under it", "docstring_tokens": ["AddDir", "adds", "a", "directory", "recursively", "with", "all", "of", "the", "files", "under", "it"], "sha": "a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32", "url": "https://github.com/ipfs/go-ipfs-api/blob/a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32/add.go#L83-L129", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "overlay/overlay.go", "func_name": "Do", "original_string": "func (p *SetShowViewportSizeOnResizeParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetShowViewportSizeOnResize, p, nil)\n}", "language": "go", "code": "func (p *SetShowViewportSizeOnResizeParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetShowViewportSizeOnResize, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetShowViewportSizeOnResizeParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetShowViewportSizeOnResize", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Overlay.setShowViewportSizeOnResize against the provided context.", "docstring_tokens": ["Do", "executes", "Overlay", ".", "setShowViewportSizeOnResize", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/overlay.go#L496-L498", "partition": "test"}
{"repo": "guregu/null", "path": "zero/int.go", "func_name": "NewInt", "original_string": "func NewInt(i int64, valid bool) Int {\n\treturn Int{\n\t\tNullInt64: sql.NullInt64{\n\t\t\tInt64: i,\n\t\t\tValid: valid,\n\t\t},\n\t}\n}", "language": "go", "code": "func NewInt(i int64, valid bool) Int {\n\treturn Int{\n\t\tNullInt64: sql.NullInt64{\n\t\t\tInt64: i,\n\t\t\tValid: valid,\n\t\t},\n\t}\n}", "code_tokens": ["func", "NewInt", "(", "i", "int64", ",", "valid", "bool", ")", "Int", "{", "return", "Int", "{", "NullInt64", ":", "sql", ".", "NullInt64", "{", "Int64", ":", "i", ",", "Valid", ":", "valid", ",", "}", ",", "}", "\n", "}"], "docstring": "// NewInt creates a new Int", "docstring_tokens": ["NewInt", "creates", "a", "new", "Int"], "sha": "80515d440932108546bcade467bb7d6968e812e2", "url": "https://github.com/guregu/null/blob/80515d440932108546bcade467bb7d6968e812e2/zero/int.go#L19-L26", "partition": "test"}
{"repo": "siddontang/go-log", "path": "log/logger.go", "func_name": "New", "original_string": "func New(handler Handler, flag int) *Logger {\n\tvar l = new(Logger)\n\n\tl.level = LevelInfo\n\tl.handler = handler\n\n\tl.flag = flag\n\n\tl.bufs = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn make([]byte, 0, 1024)\n\t\t},\n\t}\n\n\treturn l\n}", "language": "go", "code": "func New(handler Handler, flag int) *Logger {\n\tvar l = new(Logger)\n\n\tl.level = LevelInfo\n\tl.handler = handler\n\n\tl.flag = flag\n\n\tl.bufs = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn make([]byte, 0, 1024)\n\t\t},\n\t}\n\n\treturn l\n}", "code_tokens": ["func", "New", "(", "handler", "Handler", ",", "flag", "int", ")", "*", "Logger", "{", "var", "l", "=", "new", "(", "Logger", ")", "\n\n", "l", ".", "level", "=", "LevelInfo", "\n", "l", ".", "handler", "=", "handler", "\n\n", "l", ".", "flag", "=", "flag", "\n\n", "l", ".", "bufs", "=", "sync", ".", "Pool", "{", "New", ":", "func", "(", ")", "interface", "{", "}", "{", "return", "make", "(", "[", "]", "byte", ",", "0", ",", "1024", ")", "\n", "}", ",", "}", "\n\n", "return", "l", "\n", "}"], "docstring": "// New creates a logger with specified handler and flag", "docstring_tokens": ["New", "creates", "a", "logger", "with", "specified", "handler", "and", "flag"], "sha": "1e957dd83bed18c84716181da7b80d4af48eaefe", "url": "https://github.com/siddontang/go-log/blob/1e957dd83bed18c84716181da7b80d4af48eaefe/log/logger.go#L76-L91", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/approve/approvers/owners.go", "func_name": "GetShuffledApprovers", "original_string": "func (o Owners) GetShuffledApprovers() []string {\n\tapproversList := o.GetAllPotentialApprovers()\n\torder := rand.New(rand.NewSource(o.seed)).Perm(len(approversList))\n\tpeople := make([]string, 0, len(approversList))\n\tfor _, i := range order {\n\t\tpeople = append(people, approversList[i])\n\t}\n\treturn people\n}", "language": "go", "code": "func (o Owners) GetShuffledApprovers() []string {\n\tapproversList := o.GetAllPotentialApprovers()\n\torder := rand.New(rand.NewSource(o.seed)).Perm(len(approversList))\n\tpeople := make([]string, 0, len(approversList))\n\tfor _, i := range order {\n\t\tpeople = append(people, approversList[i])\n\t}\n\treturn people\n}", "code_tokens": ["func", "(", "o", "Owners", ")", "GetShuffledApprovers", "(", ")", "[", "]", "string", "{", "approversList", ":=", "o", ".", "GetAllPotentialApprovers", "(", ")", "\n", "order", ":=", "rand", ".", "New", "(", "rand", ".", "NewSource", "(", "o", ".", "seed", ")", ")", ".", "Perm", "(", "len", "(", "approversList", ")", ")", "\n", "people", ":=", "make", "(", "[", "]", "string", ",", "0", ",", "len", "(", "approversList", ")", ")", "\n", "for", "_", ",", "i", ":=", "range", "order", "{", "people", "=", "append", "(", "people", ",", "approversList", "[", "i", "]", ")", "\n", "}", "\n", "return", "people", "\n", "}"], "docstring": "// GetShuffledApprovers shuffles the potential approvers so that we don't\n// always suggest the same people.", "docstring_tokens": ["GetShuffledApprovers", "shuffles", "the", "potential", "approvers", "so", "that", "we", "don", "t", "always", "suggest", "the", "same", "people", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/approve/approvers/owners.go#L185-L193", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/plugins.go", "func_name": "RegisterIssueCommentHandler", "original_string": "func RegisterIssueCommentHandler(name string, fn IssueCommentHandler, help HelpProvider) {\n\tpluginHelp[name] = help\n\tissueCommentHandlers[name] = fn\n}", "language": "go", "code": "func RegisterIssueCommentHandler(name string, fn IssueCommentHandler, help HelpProvider) {\n\tpluginHelp[name] = help\n\tissueCommentHandlers[name] = fn\n}", "code_tokens": ["func", "RegisterIssueCommentHandler", "(", "name", "string", ",", "fn", "IssueCommentHandler", ",", "help", "HelpProvider", ")", "{", "pluginHelp", "[", "name", "]", "=", "help", "\n", "issueCommentHandlers", "[", "name", "]", "=", "fn", "\n", "}"], "docstring": "// RegisterIssueCommentHandler registers a plugin's github.IssueCommentEvent handler.", "docstring_tokens": ["RegisterIssueCommentHandler", "registers", "a", "plugin", "s", "github", ".", "IssueCommentEvent", "handler", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/plugins.go#L74-L77", "partition": "test"}
{"repo": "ipfs/go-ipfs-api", "path": "options/dag.go", "func_name": "Hash", "original_string": "func (dagOpts) Hash(hash string) DagPutOption {\n\treturn func(opts *DagPutSettings) error {\n\t\topts.Hash = hash\n\t\treturn nil\n\t}\n}", "language": "go", "code": "func (dagOpts) Hash(hash string) DagPutOption {\n\treturn func(opts *DagPutSettings) error {\n\t\topts.Hash = hash\n\t\treturn nil\n\t}\n}", "code_tokens": ["func", "(", "dagOpts", ")", "Hash", "(", "hash", "string", ")", "DagPutOption", "{", "return", "func", "(", "opts", "*", "DagPutSettings", ")", "error", "{", "opts", ".", "Hash", "=", "hash", "\n", "return", "nil", "\n", "}", "\n", "}"], "docstring": "// Hash is an option for Dag.Put which specifies the hash function to use", "docstring_tokens": ["Hash", "is", "an", "option", "for", "Dag", ".", "Put", "which", "specifies", "the", "hash", "function", "to", "use"], "sha": "a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32", "url": "https://github.com/ipfs/go-ipfs-api/blob/a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32/options/dag.go#L64-L69", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "typed/buffer.go", "func_name": "DeferBytes", "original_string": "func (w *WriteBuffer) DeferBytes(n int) BytesRef {\n\treturn BytesRef(w.deferred(n))\n}", "language": "go", "code": "func (w *WriteBuffer) DeferBytes(n int) BytesRef {\n\treturn BytesRef(w.deferred(n))\n}", "code_tokens": ["func", "(", "w", "*", "WriteBuffer", ")", "DeferBytes", "(", "n", "int", ")", "BytesRef", "{", "return", "BytesRef", "(", "w", ".", "deferred", "(", "n", ")", ")", "\n", "}"], "docstring": "// DeferBytes reserves space in the buffer for a fixed sequence of bytes, and\n// returns a reference that can be used to update those bytes", "docstring_tokens": ["DeferBytes", "reserves", "space", "in", "the", "buffer", "for", "a", "fixed", "sequence", "of", "bytes", "and", "returns", "a", "reference", "that", "can", "be", "used", "to", "update", "those", "bytes"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/typed/buffer.go#L314-L316", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/types/set.go", "func_name": "Equals", "original_string": "func (us *unsafeSet) Equals(other Set) bool {\n\tv1 := sort.StringSlice(us.Values())\n\tv2 := sort.StringSlice(other.Values())\n\tv1.Sort()\n\tv2.Sort()\n\treturn reflect.DeepEqual(v1, v2)\n}", "language": "go", "code": "func (us *unsafeSet) Equals(other Set) bool {\n\tv1 := sort.StringSlice(us.Values())\n\tv2 := sort.StringSlice(other.Values())\n\tv1.Sort()\n\tv2.Sort()\n\treturn reflect.DeepEqual(v1, v2)\n}", "code_tokens": ["func", "(", "us", "*", "unsafeSet", ")", "Equals", "(", "other", "Set", ")", "bool", "{", "v1", ":=", "sort", ".", "StringSlice", "(", "us", ".", "Values", "(", ")", ")", "\n", "v2", ":=", "sort", ".", "StringSlice", "(", "other", ".", "Values", "(", ")", ")", "\n", "v1", ".", "Sort", "(", ")", "\n", "v2", ".", "Sort", "(", ")", "\n", "return", "reflect", ".", "DeepEqual", "(", "v1", ",", "v2", ")", "\n", "}"], "docstring": "// Equals returns whether the contents of two sets are identical", "docstring_tokens": ["Equals", "returns", "whether", "the", "contents", "of", "two", "sets", "are", "identical"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/types/set.go#L78-L84", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "raft/storage.go", "func_name": "ApplySnapshot", "original_string": "func (ms *MemoryStorage) ApplySnapshot(snap pb.Snapshot) error {\n\tms.Lock()\n\tdefer ms.Unlock()\n\n\t//handle check for old snapshot being applied\n\tmsIndex := ms.snapshot.Metadata.Index\n\tsnapIndex := snap.Metadata.Index\n\tif msIndex >= snapIndex {\n\t\treturn ErrSnapOutOfDate\n\t}\n\n\tms.snapshot = snap\n\tms.ents = []pb.Entry{{Term: snap.Metadata.Term, Index: snap.Metadata.Index}}\n\treturn nil\n}", "language": "go", "code": "func (ms *MemoryStorage) ApplySnapshot(snap pb.Snapshot) error {\n\tms.Lock()\n\tdefer ms.Unlock()\n\n\t//handle check for old snapshot being applied\n\tmsIndex := ms.snapshot.Metadata.Index\n\tsnapIndex := snap.Metadata.Index\n\tif msIndex >= snapIndex {\n\t\treturn ErrSnapOutOfDate\n\t}\n\n\tms.snapshot = snap\n\tms.ents = []pb.Entry{{Term: snap.Metadata.Term, Index: snap.Metadata.Index}}\n\treturn nil\n}", "code_tokens": ["func", "(", "ms", "*", "MemoryStorage", ")", "ApplySnapshot", "(", "snap", "pb", ".", "Snapshot", ")", "error", "{", "ms", ".", "Lock", "(", ")", "\n", "defer", "ms", ".", "Unlock", "(", ")", "\n\n", "//handle check for old snapshot being applied", "msIndex", ":=", "ms", ".", "snapshot", ".", "Metadata", ".", "Index", "\n", "snapIndex", ":=", "snap", ".", "Metadata", ".", "Index", "\n", "if", "msIndex", ">=", "snapIndex", "{", "return", "ErrSnapOutOfDate", "\n", "}", "\n\n", "ms", ".", "snapshot", "=", "snap", "\n", "ms", ".", "ents", "=", "[", "]", "pb", ".", "Entry", "{", "{", "Term", ":", "snap", ".", "Metadata", ".", "Term", ",", "Index", ":", "snap", ".", "Metadata", ".", "Index", "}", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// ApplySnapshot overwrites the contents of this Storage object with\n// those of the given snapshot.", "docstring_tokens": ["ApplySnapshot", "overwrites", "the", "contents", "of", "this", "Storage", "object", "with", "those", "of", "the", "given", "snapshot", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/storage.go#L172-L186", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_profiles.go", "func_name": "CreateProfile", "original_string": "func (r *ProtocolLXD) CreateProfile(profile api.ProfilesPost) error {\n\t// Send the request\n\t_, _, err := r.query(\"POST\", \"/profiles\", profile, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (r *ProtocolLXD) CreateProfile(profile api.ProfilesPost) error {\n\t// Send the request\n\t_, _, err := r.query(\"POST\", \"/profiles\", profile, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "CreateProfile", "(", "profile", "api", ".", "ProfilesPost", ")", "error", "{", "// Send the request", "_", ",", "_", ",", "err", ":=", "r", ".", "query", "(", "\"", "\"", ",", "\"", "\"", ",", "profile", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// CreateProfile defines a new container profile", "docstring_tokens": ["CreateProfile", "defines", "a", "new", "container", "profile"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_profiles.go#L60-L68", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "builder/builder.go", "func_name": "get", "original_string": "func get(name string) (Builder, error) {\n\tb, ok := builders[name]\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"unknown builder: %q\", name)\n\t}\n\treturn b, nil\n}", "language": "go", "code": "func get(name string) (Builder, error) {\n\tb, ok := builders[name]\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"unknown builder: %q\", name)\n\t}\n\treturn b, nil\n}", "code_tokens": ["func", "get", "(", "name", "string", ")", "(", "Builder", ",", "error", ")", "{", "b", ",", "ok", ":=", "builders", "[", "name", "]", "\n", "if", "!", "ok", "{", "return", "nil", ",", "errors", ".", "Errorf", "(", "\"", "\"", ",", "name", ")", "\n", "}", "\n", "return", "b", ",", "nil", "\n", "}"], "docstring": "// get gets the named builder from the registry.", "docstring_tokens": ["get", "gets", "the", "named", "builder", "from", "the", "registry", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/builder/builder.go#L68-L74", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "_metcd/ctrl.go", "func_name": "makeRaftPeer", "original_string": "func makeRaftPeer(addr net.Addr) raft.Peer {\n\treturn raft.Peer{\n\t\tID:      uint64(addr.(meshconn.MeshAddr).PeerUID),\n\t\tContext: nil, // TODO(pb): ??\n\t}\n}", "language": "go", "code": "func makeRaftPeer(addr net.Addr) raft.Peer {\n\treturn raft.Peer{\n\t\tID:      uint64(addr.(meshconn.MeshAddr).PeerUID),\n\t\tContext: nil, // TODO(pb): ??\n\t}\n}", "code_tokens": ["func", "makeRaftPeer", "(", "addr", "net", ".", "Addr", ")", "raft", ".", "Peer", "{", "return", "raft", ".", "Peer", "{", "ID", ":", "uint64", "(", "addr", ".", "(", "meshconn", ".", "MeshAddr", ")", ".", "PeerUID", ")", ",", "Context", ":", "nil", ",", "// TODO(pb): ??", "}", "\n", "}"], "docstring": "// makeRaftPeer converts a net.Addr into a raft.Peer.\n// All peers must perform the Addr-to-Peer mapping in the same way.\n//\n// The etcd Raft implementation tracks the committed entry for each node ID,\n// and panics if it discovers a node has lost previously committed entries.\n// In effect, it assumes commitment implies durability. But our storage is\n// explicitly non-durable. So, whenever a node restarts, we need to give it\n// a brand new ID. That is the peer UID.", "docstring_tokens": ["makeRaftPeer", "converts", "a", "net", ".", "Addr", "into", "a", "raft", ".", "Peer", ".", "All", "peers", "must", "perform", "the", "Addr", "-", "to", "-", "Peer", "mapping", "in", "the", "same", "way", ".", "The", "etcd", "Raft", "implementation", "tracks", "the", "committed", "entry", "for", "each", "node", "ID", "and", "panics", "if", "it", "discovers", "a", "node", "has", "lost", "previously", "committed", "entries", ".", "In", "effect", "it", "assumes", "commitment", "implies", "durability", ".", "But", "our", "storage", "is", "explicitly", "non", "-", "durable", ".", "So", "whenever", "a", "node", "restarts", "we", "need", "to", "give", "it", "a", "brand", "new", "ID", ".", "That", "is", "the", "peer", "UID", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/_metcd/ctrl.go#L314-L319", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "velodrome/transform/plugins/states.go", "func_name": "ReceiveEvent", "original_string": "func (i *InactiveState) ReceiveEvent(eventName, label string, t time.Time) (State, bool) {\n\tif i.entry.Match(eventName, label) {\n\t\treturn &ActiveState{\n\t\t\tstartTime: t,\n\t\t\texit:      i.entry.Opposite(),\n\t\t}, true\n\t}\n\treturn i, false\n}", "language": "go", "code": "func (i *InactiveState) ReceiveEvent(eventName, label string, t time.Time) (State, bool) {\n\tif i.entry.Match(eventName, label) {\n\t\treturn &ActiveState{\n\t\t\tstartTime: t,\n\t\t\texit:      i.entry.Opposite(),\n\t\t}, true\n\t}\n\treturn i, false\n}", "code_tokens": ["func", "(", "i", "*", "InactiveState", ")", "ReceiveEvent", "(", "eventName", ",", "label", "string", ",", "t", "time", ".", "Time", ")", "(", "State", ",", "bool", ")", "{", "if", "i", ".", "entry", ".", "Match", "(", "eventName", ",", "label", ")", "{", "return", "&", "ActiveState", "{", "startTime", ":", "t", ",", "exit", ":", "i", ".", "entry", ".", "Opposite", "(", ")", ",", "}", ",", "true", "\n", "}", "\n", "return", "i", ",", "false", "\n", "}"], "docstring": "// ReceiveEvent checks if the event matches the entry criteria\n// Returns a new ActiveState or self, and true if it changed.", "docstring_tokens": ["ReceiveEvent", "checks", "if", "the", "event", "matches", "the", "entry", "criteria", "Returns", "a", "new", "ActiveState", "or", "self", "and", "true", "if", "it", "changed", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/transform/plugins/states.go#L83-L91", "partition": "test"}
{"repo": "rightscale/rsc", "path": "displayer.go", "func_name": "Output", "original_string": "func (d *Displayer) Output() string {\n\toutput := d.RawOutput\n\tif output == nil {\n\t\treturn \"\"\n\t}\n\tif outputStr, ok := d.RawOutput.(string); ok {\n\t\tsuffix := \"\"\n\t\tif d.prettify {\n\t\t\tsuffix = \"\\n\"\n\t\t}\n\t\treturn outputStr + suffix\n\t}\n\tvar out string\n\tvar err error\n\tif d.prettify {\n\t\tvar b []byte\n\t\tb, err = json.MarshalIndent(output, \"\", \"    \")\n\t\tif err == nil {\n\t\t\tout = string(b) + \"\\n\"\n\t\t}\n\t} else {\n\t\tvar b []byte\n\t\tb, err = json.Marshal(output)\n\t\tout = string(b)\n\t}\n\tif err != nil {\n\t\tfm := \"%v\"\n\t\tif d.prettify {\n\t\t\tfm += \"\\n\"\n\t\t}\n\t\treturn fmt.Sprintf(fm, output)\n\t}\n\treturn out\n}", "language": "go", "code": "func (d *Displayer) Output() string {\n\toutput := d.RawOutput\n\tif output == nil {\n\t\treturn \"\"\n\t}\n\tif outputStr, ok := d.RawOutput.(string); ok {\n\t\tsuffix := \"\"\n\t\tif d.prettify {\n\t\t\tsuffix = \"\\n\"\n\t\t}\n\t\treturn outputStr + suffix\n\t}\n\tvar out string\n\tvar err error\n\tif d.prettify {\n\t\tvar b []byte\n\t\tb, err = json.MarshalIndent(output, \"\", \"    \")\n\t\tif err == nil {\n\t\t\tout = string(b) + \"\\n\"\n\t\t}\n\t} else {\n\t\tvar b []byte\n\t\tb, err = json.Marshal(output)\n\t\tout = string(b)\n\t}\n\tif err != nil {\n\t\tfm := \"%v\"\n\t\tif d.prettify {\n\t\t\tfm += \"\\n\"\n\t\t}\n\t\treturn fmt.Sprintf(fm, output)\n\t}\n\treturn out\n}", "code_tokens": ["func", "(", "d", "*", "Displayer", ")", "Output", "(", ")", "string", "{", "output", ":=", "d", ".", "RawOutput", "\n", "if", "output", "==", "nil", "{", "return", "\"", "\"", "\n", "}", "\n", "if", "outputStr", ",", "ok", ":=", "d", ".", "RawOutput", ".", "(", "string", ")", ";", "ok", "{", "suffix", ":=", "\"", "\"", "\n", "if", "d", ".", "prettify", "{", "suffix", "=", "\"", "\\n", "\"", "\n", "}", "\n", "return", "outputStr", "+", "suffix", "\n", "}", "\n", "var", "out", "string", "\n", "var", "err", "error", "\n", "if", "d", ".", "prettify", "{", "var", "b", "[", "]", "byte", "\n", "b", ",", "err", "=", "json", ".", "MarshalIndent", "(", "output", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "if", "err", "==", "nil", "{", "out", "=", "string", "(", "b", ")", "+", "\"", "\\n", "\"", "\n", "}", "\n", "}", "else", "{", "var", "b", "[", "]", "byte", "\n", "b", ",", "err", "=", "json", ".", "Marshal", "(", "output", ")", "\n", "out", "=", "string", "(", "b", ")", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "fm", ":=", "\"", "\"", "\n", "if", "d", ".", "prettify", "{", "fm", "+=", "\"", "\\n", "\"", "\n", "}", "\n", "return", "fmt", ".", "Sprintf", "(", "fm", ",", "output", ")", "\n", "}", "\n", "return", "out", "\n", "}"], "docstring": "// Output returns the current output.", "docstring_tokens": ["Output", "returns", "the", "current", "output", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/displayer.go#L107-L140", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "errors/cause.go", "func_name": "Cause", "original_string": "func Cause(err Error) error {\n\tattributes := err.Attributes()\n\tif attributes == nil {\n\t\treturn nil\n\t}\n\n\tcause, ok := attributes[causeKey]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tswitch v := cause.(type) {\n\tcase error:\n\t\treturn v\n\tcase string:\n\t\treturn errors.New(v)\n\tdefault:\n\t\treturn nil\n\t}\n}", "language": "go", "code": "func Cause(err Error) error {\n\tattributes := err.Attributes()\n\tif attributes == nil {\n\t\treturn nil\n\t}\n\n\tcause, ok := attributes[causeKey]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tswitch v := cause.(type) {\n\tcase error:\n\t\treturn v\n\tcase string:\n\t\treturn errors.New(v)\n\tdefault:\n\t\treturn nil\n\t}\n}", "code_tokens": ["func", "Cause", "(", "err", "Error", ")", "error", "{", "attributes", ":=", "err", ".", "Attributes", "(", ")", "\n", "if", "attributes", "==", "nil", "{", "return", "nil", "\n", "}", "\n\n", "cause", ",", "ok", ":=", "attributes", "[", "causeKey", "]", "\n", "if", "!", "ok", "{", "return", "nil", "\n", "}", "\n\n", "switch", "v", ":=", "cause", ".", "(", "type", ")", "{", "case", "error", ":", "return", "v", "\n", "case", "string", ":", "return", "errors", ".", "New", "(", "v", ")", "\n", "default", ":", "return", "nil", "\n", "}", "\n", "}"], "docstring": "// Cause returns the cause of an error", "docstring_tokens": ["Cause", "returns", "the", "cause", "of", "an", "error"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/errors/cause.go#L16-L35", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "build/transaction.go", "func_name": "MutateTransaction", "original_string": "func (m MemoID) MutateTransaction(o *TransactionBuilder) (err error) {\n\to.TX.Memo, err = xdr.NewMemo(xdr.MemoTypeMemoId, xdr.Uint64(m.Value))\n\treturn\n}", "language": "go", "code": "func (m MemoID) MutateTransaction(o *TransactionBuilder) (err error) {\n\to.TX.Memo, err = xdr.NewMemo(xdr.MemoTypeMemoId, xdr.Uint64(m.Value))\n\treturn\n}", "code_tokens": ["func", "(", "m", "MemoID", ")", "MutateTransaction", "(", "o", "*", "TransactionBuilder", ")", "(", "err", "error", ")", "{", "o", ".", "TX", ".", "Memo", ",", "err", "=", "xdr", ".", "NewMemo", "(", "xdr", ".", "MemoTypeMemoId", ",", "xdr", ".", "Uint64", "(", "m", ".", "Value", ")", ")", "\n", "return", "\n", "}"], "docstring": "// MutateTransaction for MemoID sets the memo.", "docstring_tokens": ["MutateTransaction", "for", "MemoID", "sets", "the", "memo", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/transaction.go#L235-L238", "partition": "test"}
{"repo": "gravitational/roundtrip", "path": "client.go", "func_name": "rewind", "original_string": "func (r *fileBuffer) rewind() {\n\tr.Reader = io.MultiReader(r.cache, r.File.Reader)\n}", "language": "go", "code": "func (r *fileBuffer) rewind() {\n\tr.Reader = io.MultiReader(r.cache, r.File.Reader)\n}", "code_tokens": ["func", "(", "r", "*", "fileBuffer", ")", "rewind", "(", ")", "{", "r", ".", "Reader", "=", "io", ".", "MultiReader", "(", "r", ".", "cache", ",", "r", ".", "File", ".", "Reader", ")", "\n", "}"], "docstring": "// rewind resets this fileBuffer to read from the beginning", "docstring_tokens": ["rewind", "resets", "this", "fileBuffer", "to", "read", "from", "the", "beginning"], "sha": "e1e0cd6b05a6bb1791b262e63160038828fd7b3a", "url": "https://github.com/gravitational/roundtrip/blob/e1e0cd6b05a6bb1791b262e63160038828fd7b3a/client.go#L659-L661", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/kube/dry_run_client.go", "func_name": "Patch", "original_string": "func (c *dryRunProwJobClient) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *prowapi.ProwJob, err error) {\n\treturn nil, nil\n}", "language": "go", "code": "func (c *dryRunProwJobClient) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *prowapi.ProwJob, err error) {\n\treturn nil, nil\n}", "code_tokens": ["func", "(", "c", "*", "dryRunProwJobClient", ")", "Patch", "(", "name", "string", ",", "pt", "types", ".", "PatchType", ",", "data", "[", "]", "byte", ",", "subresources", "...", "string", ")", "(", "result", "*", "prowapi", ".", "ProwJob", ",", "err", "error", ")", "{", "return", "nil", ",", "nil", "\n", "}"], "docstring": "// Patch does nothing on a dry-run client", "docstring_tokens": ["Patch", "does", "nothing", "on", "a", "dry", "-", "run", "client"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/kube/dry_run_client.go#L177-L179", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/images.go", "func_name": "ImageAliasRename", "original_string": "func (c *Cluster) ImageAliasRename(id int, name string) error {\n\terr := exec(c.db, \"UPDATE images_aliases SET name=? WHERE id=?\", name, id)\n\treturn err\n}", "language": "go", "code": "func (c *Cluster) ImageAliasRename(id int, name string) error {\n\terr := exec(c.db, \"UPDATE images_aliases SET name=? WHERE id=?\", name, id)\n\treturn err\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "ImageAliasRename", "(", "id", "int", ",", "name", "string", ")", "error", "{", "err", ":=", "exec", "(", "c", ".", "db", ",", "\"", "\"", ",", "name", ",", "id", ")", "\n", "return", "err", "\n", "}"], "docstring": "// ImageAliasRename renames the alias with the given ID.", "docstring_tokens": ["ImageAliasRename", "renames", "the", "alias", "with", "the", "given", "ID", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/images.go#L634-L637", "partition": "test"}
{"repo": "go-opencv/go-opencv", "path": "opencv/cxcore.go", "func_name": "SubScalar", "original_string": "func SubScalar(src *IplImage, value Scalar, dst *IplImage) {\n\tSubScalarWithMask(src, value, dst, nil)\n}", "language": "go", "code": "func SubScalar(src *IplImage, value Scalar, dst *IplImage) {\n\tSubScalarWithMask(src, value, dst, nil)\n}", "code_tokens": ["func", "SubScalar", "(", "src", "*", "IplImage", ",", "value", "Scalar", ",", "dst", "*", "IplImage", ")", "{", "SubScalarWithMask", "(", "src", ",", "value", ",", "dst", ",", "nil", ")", "\n", "}"], "docstring": "// Calculates the per-element difference between an array and a scalar.\n//   dst = src - value", "docstring_tokens": ["Calculates", "the", "per", "-", "element", "difference", "between", "an", "array", "and", "a", "scalar", ".", "dst", "=", "src", "-", "value"], "sha": "a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db", "url": "https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxcore.go#L702-L704", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "robots/issue-creator/sources/flakyjob-reporter.go", "func_name": "Issues", "original_string": "func (fjr *FlakyJobReporter) Issues(c *creator.IssueCreator) ([]creator.Issue, error) {\n\tfjr.creator = c\n\tjson, err := ReadHTTP(fjr.flakyJobDataURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tflakyJobs, err := fjr.parseFlakyJobs(json)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcount := fjr.syncCount\n\tif len(flakyJobs) < count {\n\t\tcount = len(flakyJobs)\n\t}\n\tissues := make([]creator.Issue, 0, count)\n\tfor _, fj := range flakyJobs[0:count] {\n\t\tissues = append(issues, fj)\n\t}\n\n\treturn issues, nil\n}", "language": "go", "code": "func (fjr *FlakyJobReporter) Issues(c *creator.IssueCreator) ([]creator.Issue, error) {\n\tfjr.creator = c\n\tjson, err := ReadHTTP(fjr.flakyJobDataURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tflakyJobs, err := fjr.parseFlakyJobs(json)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcount := fjr.syncCount\n\tif len(flakyJobs) < count {\n\t\tcount = len(flakyJobs)\n\t}\n\tissues := make([]creator.Issue, 0, count)\n\tfor _, fj := range flakyJobs[0:count] {\n\t\tissues = append(issues, fj)\n\t}\n\n\treturn issues, nil\n}", "code_tokens": ["func", "(", "fjr", "*", "FlakyJobReporter", ")", "Issues", "(", "c", "*", "creator", ".", "IssueCreator", ")", "(", "[", "]", "creator", ".", "Issue", ",", "error", ")", "{", "fjr", ".", "creator", "=", "c", "\n", "json", ",", "err", ":=", "ReadHTTP", "(", "fjr", ".", "flakyJobDataURL", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "flakyJobs", ",", "err", ":=", "fjr", ".", "parseFlakyJobs", "(", "json", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "count", ":=", "fjr", ".", "syncCount", "\n", "if", "len", "(", "flakyJobs", ")", "<", "count", "{", "count", "=", "len", "(", "flakyJobs", ")", "\n", "}", "\n", "issues", ":=", "make", "(", "[", "]", "creator", ".", "Issue", ",", "0", ",", "count", ")", "\n", "for", "_", ",", "fj", ":=", "range", "flakyJobs", "[", "0", ":", "count", "]", "{", "issues", "=", "append", "(", "issues", ",", "fj", ")", "\n", "}", "\n\n", "return", "issues", ",", "nil", "\n", "}"], "docstring": "// Issues is the main work method of FlakyJobReporter. It fetches and parses flaky job data,\n// then syncs the top issues to github with the IssueCreator.", "docstring_tokens": ["Issues", "is", "the", "main", "work", "method", "of", "FlakyJobReporter", ".", "It", "fetches", "and", "parses", "flaky", "job", "data", "then", "syncs", "the", "top", "issues", "to", "github", "with", "the", "IssueCreator", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/robots/issue-creator/sources/flakyjob-reporter.go#L76-L98", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_networks.go", "func_name": "GetNetworkState", "original_string": "func (r *ProtocolLXD) GetNetworkState(name string) (*api.NetworkState, error) {\n\tif !r.HasExtension(\"network_state\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"network_state\\\" API extension\")\n\t}\n\n\tstate := api.NetworkState{}\n\n\t// Fetch the raw value\n\t_, err := r.queryStruct(\"GET\", fmt.Sprintf(\"/networks/%s/state\", url.QueryEscape(name)), nil, \"\", &state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &state, nil\n}", "language": "go", "code": "func (r *ProtocolLXD) GetNetworkState(name string) (*api.NetworkState, error) {\n\tif !r.HasExtension(\"network_state\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"network_state\\\" API extension\")\n\t}\n\n\tstate := api.NetworkState{}\n\n\t// Fetch the raw value\n\t_, err := r.queryStruct(\"GET\", fmt.Sprintf(\"/networks/%s/state\", url.QueryEscape(name)), nil, \"\", &state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &state, nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "GetNetworkState", "(", "name", "string", ")", "(", "*", "api", ".", "NetworkState", ",", "error", ")", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "state", ":=", "api", ".", "NetworkState", "{", "}", "\n\n", "// Fetch the raw value", "_", ",", "err", ":=", "r", ".", "queryStruct", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "name", ")", ")", ",", "nil", ",", "\"", "\"", ",", "&", "state", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "&", "state", ",", "nil", "\n", "}"], "docstring": "// GetNetworkState returns metrics and information on the running network", "docstring_tokens": ["GetNetworkState", "returns", "metrics", "and", "information", "on", "the", "running", "network"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_networks.go#L87-L101", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "input/input.go", "func_name": "Do", "original_string": "func (p *SynthesizeTapGestureParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSynthesizeTapGesture, p, nil)\n}", "language": "go", "code": "func (p *SynthesizeTapGestureParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSynthesizeTapGesture, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SynthesizeTapGestureParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSynthesizeTapGesture", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Input.synthesizeTapGesture against the provided context.", "docstring_tokens": ["Do", "executes", "Input", ".", "synthesizeTapGesture", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L579-L581", "partition": "test"}
{"repo": "ChrisTrenkamp/goxpath", "path": "goxpath.go", "func_name": "MustParse", "original_string": "func MustParse(xp string) XPathExec {\n\tret, err := Parse(xp)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn ret\n}", "language": "go", "code": "func MustParse(xp string) XPathExec {\n\tret, err := Parse(xp)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn ret\n}", "code_tokens": ["func", "MustParse", "(", "xp", "string", ")", "XPathExec", "{", "ret", ",", "err", ":=", "Parse", "(", "xp", ")", "\n", "if", "err", "!=", "nil", "{", "panic", "(", "err", ")", "\n", "}", "\n", "return", "ret", "\n", "}"], "docstring": "//MustParse is like Parse, but panics instead of returning an error.", "docstring_tokens": ["MustParse", "is", "like", "Parse", "but", "panics", "instead", "of", "returning", "an", "error", "."], "sha": "c385f95c6022e7756e91beac5f5510872f7dcb7d", "url": "https://github.com/ChrisTrenkamp/goxpath/blob/c385f95c6022e7756e91beac5f5510872f7dcb7d/goxpath.go#L34-L40", "partition": "test"}
{"repo": "mattn/go-xmpp", "path": "xmpp.go", "func_name": "SendOrg", "original_string": "func (c *Client) SendOrg(org string) (n int, err error) {\n\treturn fmt.Fprint(c.conn, org)\n}", "language": "go", "code": "func (c *Client) SendOrg(org string) (n int, err error) {\n\treturn fmt.Fprint(c.conn, org)\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "SendOrg", "(", "org", "string", ")", "(", "n", "int", ",", "err", "error", ")", "{", "return", "fmt", ".", "Fprint", "(", "c", ".", "conn", ",", "org", ")", "\n", "}"], "docstring": "// SendOrg sends the original text without being wrapped in an XMPP message stanza.", "docstring_tokens": ["SendOrg", "sends", "the", "original", "text", "without", "being", "wrapped", "in", "an", "XMPP", "message", "stanza", "."], "sha": "6093f50721ed2204a87a81109ca5a466a5bec6c1", "url": "https://github.com/mattn/go-xmpp/blob/6093f50721ed2204a87a81109ca5a466a5bec6c1/xmpp.go#L673-L675", "partition": "test"}
{"repo": "sclevine/agouti", "path": "page.go", "func_name": "EnterPopupText", "original_string": "func (p *Page) EnterPopupText(text string) error {\n\tif err := p.session.SetAlertText(text); err != nil {\n\t\treturn fmt.Errorf(\"failed to enter popup text: %s\", err)\n\t}\n\treturn nil\n}", "language": "go", "code": "func (p *Page) EnterPopupText(text string) error {\n\tif err := p.session.SetAlertText(text); err != nil {\n\t\treturn fmt.Errorf(\"failed to enter popup text: %s\", err)\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "p", "*", "Page", ")", "EnterPopupText", "(", "text", "string", ")", "error", "{", "if", "err", ":=", "p", ".", "session", ".", "SetAlertText", "(", "text", ")", ";", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// EnterPopupText enters text into an open prompt popup.", "docstring_tokens": ["EnterPopupText", "enters", "text", "into", "an", "open", "prompt", "popup", "."], "sha": "96599c91888f1b1cf2dccc7f1776ba7f511909e5", "url": "https://github.com/sclevine/agouti/blob/96599c91888f1b1cf2dccc7f1776ba7f511909e5/page.go#L292-L297", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/pipeline/controller.go", "func_name": "prowJobStatus", "original_string": "func prowJobStatus(ps pipelinev1alpha1.PipelineRunStatus) (prowjobv1.ProwJobState, string) {\n\tstarted := ps.StartTime\n\tfinished := ps.CompletionTime\n\tpcond := ps.GetCondition(duckv1alpha1.ConditionSucceeded)\n\tif pcond == nil {\n\t\tif !finished.IsZero() {\n\t\t\treturn prowjobv1.ErrorState, descMissingCondition\n\t\t}\n\t\treturn prowjobv1.TriggeredState, descScheduling\n\t}\n\tcond := *pcond\n\tswitch {\n\tcase cond.Status == untypedcorev1.ConditionTrue:\n\t\treturn prowjobv1.SuccessState, description(cond, descSucceeded)\n\tcase cond.Status == untypedcorev1.ConditionFalse:\n\t\treturn prowjobv1.FailureState, description(cond, descFailed)\n\tcase started.IsZero():\n\t\treturn prowjobv1.TriggeredState, description(cond, descInitializing)\n\tcase cond.Status == untypedcorev1.ConditionUnknown, finished.IsZero():\n\t\treturn prowjobv1.PendingState, description(cond, descRunning)\n\t}\n\n\tlogrus.Warnf(\"Unknown condition %#v\", cond)\n\treturn prowjobv1.ErrorState, description(cond, descUnknown) // shouldn't happen\n}", "language": "go", "code": "func prowJobStatus(ps pipelinev1alpha1.PipelineRunStatus) (prowjobv1.ProwJobState, string) {\n\tstarted := ps.StartTime\n\tfinished := ps.CompletionTime\n\tpcond := ps.GetCondition(duckv1alpha1.ConditionSucceeded)\n\tif pcond == nil {\n\t\tif !finished.IsZero() {\n\t\t\treturn prowjobv1.ErrorState, descMissingCondition\n\t\t}\n\t\treturn prowjobv1.TriggeredState, descScheduling\n\t}\n\tcond := *pcond\n\tswitch {\n\tcase cond.Status == untypedcorev1.ConditionTrue:\n\t\treturn prowjobv1.SuccessState, description(cond, descSucceeded)\n\tcase cond.Status == untypedcorev1.ConditionFalse:\n\t\treturn prowjobv1.FailureState, description(cond, descFailed)\n\tcase started.IsZero():\n\t\treturn prowjobv1.TriggeredState, description(cond, descInitializing)\n\tcase cond.Status == untypedcorev1.ConditionUnknown, finished.IsZero():\n\t\treturn prowjobv1.PendingState, description(cond, descRunning)\n\t}\n\n\tlogrus.Warnf(\"Unknown condition %#v\", cond)\n\treturn prowjobv1.ErrorState, description(cond, descUnknown) // shouldn't happen\n}", "code_tokens": ["func", "prowJobStatus", "(", "ps", "pipelinev1alpha1", ".", "PipelineRunStatus", ")", "(", "prowjobv1", ".", "ProwJobState", ",", "string", ")", "{", "started", ":=", "ps", ".", "StartTime", "\n", "finished", ":=", "ps", ".", "CompletionTime", "\n", "pcond", ":=", "ps", ".", "GetCondition", "(", "duckv1alpha1", ".", "ConditionSucceeded", ")", "\n", "if", "pcond", "==", "nil", "{", "if", "!", "finished", ".", "IsZero", "(", ")", "{", "return", "prowjobv1", ".", "ErrorState", ",", "descMissingCondition", "\n", "}", "\n", "return", "prowjobv1", ".", "TriggeredState", ",", "descScheduling", "\n", "}", "\n", "cond", ":=", "*", "pcond", "\n", "switch", "{", "case", "cond", ".", "Status", "==", "untypedcorev1", ".", "ConditionTrue", ":", "return", "prowjobv1", ".", "SuccessState", ",", "description", "(", "cond", ",", "descSucceeded", ")", "\n", "case", "cond", ".", "Status", "==", "untypedcorev1", ".", "ConditionFalse", ":", "return", "prowjobv1", ".", "FailureState", ",", "description", "(", "cond", ",", "descFailed", ")", "\n", "case", "started", ".", "IsZero", "(", ")", ":", "return", "prowjobv1", ".", "TriggeredState", ",", "description", "(", "cond", ",", "descInitializing", ")", "\n", "case", "cond", ".", "Status", "==", "untypedcorev1", ".", "ConditionUnknown", ",", "finished", ".", "IsZero", "(", ")", ":", "return", "prowjobv1", ".", "PendingState", ",", "description", "(", "cond", ",", "descRunning", ")", "\n", "}", "\n\n", "logrus", ".", "Warnf", "(", "\"", "\"", ",", "cond", ")", "\n", "return", "prowjobv1", ".", "ErrorState", ",", "description", "(", "cond", ",", "descUnknown", ")", "// shouldn't happen", "\n", "}"], "docstring": "// prowJobStatus returns the desired state and description based on the pipeline status", "docstring_tokens": ["prowJobStatus", "returns", "the", "desired", "state", "and", "description", "based", "on", "the", "pipeline", "status"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/pipeline/controller.go#L497-L521", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "strkey/main.go", "func_name": "MustEncode", "original_string": "func MustEncode(version VersionByte, src []byte) string {\n\te, err := Encode(version, src)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn e\n}", "language": "go", "code": "func MustEncode(version VersionByte, src []byte) string {\n\te, err := Encode(version, src)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn e\n}", "code_tokens": ["func", "MustEncode", "(", "version", "VersionByte", ",", "src", "[", "]", "byte", ")", "string", "{", "e", ",", "err", ":=", "Encode", "(", "version", ",", "src", ")", "\n", "if", "err", "!=", "nil", "{", "panic", "(", "err", ")", "\n", "}", "\n", "return", "e", "\n", "}"], "docstring": "// MustEncode is like Encode, but panics on error", "docstring_tokens": ["MustEncode", "is", "like", "Encode", "but", "panics", "on", "error"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/strkey/main.go#L102-L108", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/apis/prowjobs/v1/zz_generated.deepcopy.go", "func_name": "DeepCopy", "original_string": "func (in *JenkinsSpec) DeepCopy() *JenkinsSpec {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(JenkinsSpec)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "language": "go", "code": "func (in *JenkinsSpec) DeepCopy() *JenkinsSpec {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(JenkinsSpec)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "code_tokens": ["func", "(", "in", "*", "JenkinsSpec", ")", "DeepCopy", "(", ")", "*", "JenkinsSpec", "{", "if", "in", "==", "nil", "{", "return", "nil", "\n", "}", "\n", "out", ":=", "new", "(", "JenkinsSpec", ")", "\n", "in", ".", "DeepCopyInto", "(", "out", ")", "\n", "return", "out", "\n", "}"], "docstring": "// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new JenkinsSpec.", "docstring_tokens": ["DeepCopy", "is", "an", "autogenerated", "deepcopy", "function", "copying", "the", "receiver", "creating", "a", "new", "JenkinsSpec", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/apis/prowjobs/v1/zz_generated.deepcopy.go#L112-L119", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/util/sys.go", "func_name": "GetArchitectures", "original_string": "func GetArchitectures() ([]int, error) {\n\tarchitectures := []int{}\n\n\tarchitectureName, err := osarch.ArchitectureGetLocal()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tarchitecture, err := osarch.ArchitectureId(architectureName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tarchitectures = append(architectures, architecture)\n\n\tpersonalities, err := osarch.ArchitecturePersonalities(architecture)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, personality := range personalities {\n\t\tarchitectures = append(architectures, personality)\n\t}\n\treturn architectures, nil\n}", "language": "go", "code": "func GetArchitectures() ([]int, error) {\n\tarchitectures := []int{}\n\n\tarchitectureName, err := osarch.ArchitectureGetLocal()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tarchitecture, err := osarch.ArchitectureId(architectureName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tarchitectures = append(architectures, architecture)\n\n\tpersonalities, err := osarch.ArchitecturePersonalities(architecture)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, personality := range personalities {\n\t\tarchitectures = append(architectures, personality)\n\t}\n\treturn architectures, nil\n}", "code_tokens": ["func", "GetArchitectures", "(", ")", "(", "[", "]", "int", ",", "error", ")", "{", "architectures", ":=", "[", "]", "int", "{", "}", "\n\n", "architectureName", ",", "err", ":=", "osarch", ".", "ArchitectureGetLocal", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "architecture", ",", "err", ":=", "osarch", ".", "ArchitectureId", "(", "architectureName", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "architectures", "=", "append", "(", "architectures", ",", "architecture", ")", "\n\n", "personalities", ",", "err", ":=", "osarch", ".", "ArchitecturePersonalities", "(", "architecture", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "for", "_", ",", "personality", ":=", "range", "personalities", "{", "architectures", "=", "append", "(", "architectures", ",", "personality", ")", "\n", "}", "\n", "return", "architectures", ",", "nil", "\n", "}"], "docstring": "// GetArchitectures returns the list of supported architectures.", "docstring_tokens": ["GetArchitectures", "returns", "the", "list", "of", "supported", "architectures", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/util/sys.go#L18-L40", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/apis/prowjobs/v1/zz_generated.deepcopy.go", "func_name": "DeepCopy", "original_string": "func (in *ProwJob) DeepCopy() *ProwJob {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ProwJob)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "language": "go", "code": "func (in *ProwJob) DeepCopy() *ProwJob {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ProwJob)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "code_tokens": ["func", "(", "in", "*", "ProwJob", ")", "DeepCopy", "(", ")", "*", "ProwJob", "{", "if", "in", "==", "nil", "{", "return", "nil", "\n", "}", "\n", "out", ":=", "new", "(", "ProwJob", ")", "\n", "in", ".", "DeepCopyInto", "(", "out", ")", "\n", "return", "out", "\n", "}"], "docstring": "// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProwJob.", "docstring_tokens": ["DeepCopy", "is", "an", "autogenerated", "deepcopy", "function", "copying", "the", "receiver", "creating", "a", "new", "ProwJob", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/apis/prowjobs/v1/zz_generated.deepcopy.go#L132-L139", "partition": "test"}
{"repo": "naoina/genmai", "path": "genmai.go", "func_name": "Or", "original_string": "func (c *Condition) Or(cond interface{}, args ...interface{}) *Condition {\n\treturn c.appendQueryByCondOrExpr(\"Or\", 100, Or, cond, args...)\n}", "language": "go", "code": "func (c *Condition) Or(cond interface{}, args ...interface{}) *Condition {\n\treturn c.appendQueryByCondOrExpr(\"Or\", 100, Or, cond, args...)\n}", "code_tokens": ["func", "(", "c", "*", "Condition", ")", "Or", "(", "cond", "interface", "{", "}", ",", "args", "...", "interface", "{", "}", ")", "*", "Condition", "{", "return", "c", ".", "appendQueryByCondOrExpr", "(", "\"", "\"", ",", "100", ",", "Or", ",", "cond", ",", "args", "...", ")", "\n", "}"], "docstring": "// Or adds \"OR\" operator to the Condition and returns it for method chain.", "docstring_tokens": ["Or", "adds", "OR", "operator", "to", "the", "Condition", "and", "returns", "it", "for", "method", "chain", "."], "sha": "78583835e1e41e3938e1ddfffd7101f8ad27fae0", "url": "https://github.com/naoina/genmai/blob/78583835e1e41e3938e1ddfffd7101f8ad27fae0/genmai.go#L1144-L1146", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "draw2dgl/gc.go", "func_name": "Paint", "original_string": "func (p *Painter) Paint(ss []raster.Span, done bool) {\n\t//gl.Begin(gl.LINES)\n\tsslen := len(ss)\n\tclenrequired := sslen * 8\n\tvlenrequired := sslen * 4\n\tif clenrequired >= (cap(p.colors) - len(p.colors)) {\n\t\tp.Flush()\n\n\t\tif clenrequired >= cap(p.colors) {\n\t\t\tp.vertices = make([]int32, 0, vlenrequired+(vlenrequired/2))\n\t\t\tp.colors = make([]uint8, 0, clenrequired+(clenrequired/2))\n\t\t}\n\t}\n\tvi := len(p.vertices)\n\tci := len(p.colors)\n\tp.vertices = p.vertices[0 : vi+vlenrequired]\n\tp.colors = p.colors[0 : ci+clenrequired]\n\tvar (\n\t\tcolors   []uint8\n\t\tvertices []int32\n\t)\n\tfor _, s := range ss {\n\t\ta := uint8((s.Alpha * p.ca / M16) >> 8)\n\n\t\tcolors = p.colors[ci:]\n\t\tcolors[0] = p.cr\n\t\tcolors[1] = p.cg\n\t\tcolors[2] = p.cb\n\t\tcolors[3] = a\n\t\tcolors[4] = p.cr\n\t\tcolors[5] = p.cg\n\t\tcolors[6] = p.cb\n\t\tcolors[7] = a\n\t\tci += 8\n\t\tvertices = p.vertices[vi:]\n\t\tvertices[0] = int32(s.X0)\n\t\tvertices[1] = int32(s.Y)\n\t\tvertices[2] = int32(s.X1)\n\t\tvertices[3] = int32(s.Y)\n\t\tvi += 4\n\t}\n}", "language": "go", "code": "func (p *Painter) Paint(ss []raster.Span, done bool) {\n\t//gl.Begin(gl.LINES)\n\tsslen := len(ss)\n\tclenrequired := sslen * 8\n\tvlenrequired := sslen * 4\n\tif clenrequired >= (cap(p.colors) - len(p.colors)) {\n\t\tp.Flush()\n\n\t\tif clenrequired >= cap(p.colors) {\n\t\t\tp.vertices = make([]int32, 0, vlenrequired+(vlenrequired/2))\n\t\t\tp.colors = make([]uint8, 0, clenrequired+(clenrequired/2))\n\t\t}\n\t}\n\tvi := len(p.vertices)\n\tci := len(p.colors)\n\tp.vertices = p.vertices[0 : vi+vlenrequired]\n\tp.colors = p.colors[0 : ci+clenrequired]\n\tvar (\n\t\tcolors   []uint8\n\t\tvertices []int32\n\t)\n\tfor _, s := range ss {\n\t\ta := uint8((s.Alpha * p.ca / M16) >> 8)\n\n\t\tcolors = p.colors[ci:]\n\t\tcolors[0] = p.cr\n\t\tcolors[1] = p.cg\n\t\tcolors[2] = p.cb\n\t\tcolors[3] = a\n\t\tcolors[4] = p.cr\n\t\tcolors[5] = p.cg\n\t\tcolors[6] = p.cb\n\t\tcolors[7] = a\n\t\tci += 8\n\t\tvertices = p.vertices[vi:]\n\t\tvertices[0] = int32(s.X0)\n\t\tvertices[1] = int32(s.Y)\n\t\tvertices[2] = int32(s.X1)\n\t\tvertices[3] = int32(s.Y)\n\t\tvi += 4\n\t}\n}", "code_tokens": ["func", "(", "p", "*", "Painter", ")", "Paint", "(", "ss", "[", "]", "raster", ".", "Span", ",", "done", "bool", ")", "{", "//gl.Begin(gl.LINES)", "sslen", ":=", "len", "(", "ss", ")", "\n", "clenrequired", ":=", "sslen", "*", "8", "\n", "vlenrequired", ":=", "sslen", "*", "4", "\n", "if", "clenrequired", ">=", "(", "cap", "(", "p", ".", "colors", ")", "-", "len", "(", "p", ".", "colors", ")", ")", "{", "p", ".", "Flush", "(", ")", "\n\n", "if", "clenrequired", ">=", "cap", "(", "p", ".", "colors", ")", "{", "p", ".", "vertices", "=", "make", "(", "[", "]", "int32", ",", "0", ",", "vlenrequired", "+", "(", "vlenrequired", "/", "2", ")", ")", "\n", "p", ".", "colors", "=", "make", "(", "[", "]", "uint8", ",", "0", ",", "clenrequired", "+", "(", "clenrequired", "/", "2", ")", ")", "\n", "}", "\n", "}", "\n", "vi", ":=", "len", "(", "p", ".", "vertices", ")", "\n", "ci", ":=", "len", "(", "p", ".", "colors", ")", "\n", "p", ".", "vertices", "=", "p", ".", "vertices", "[", "0", ":", "vi", "+", "vlenrequired", "]", "\n", "p", ".", "colors", "=", "p", ".", "colors", "[", "0", ":", "ci", "+", "clenrequired", "]", "\n", "var", "(", "colors", "[", "]", "uint8", "\n", "vertices", "[", "]", "int32", "\n", ")", "\n", "for", "_", ",", "s", ":=", "range", "ss", "{", "a", ":=", "uint8", "(", "(", "s", ".", "Alpha", "*", "p", ".", "ca", "/", "M16", ")", ">>", "8", ")", "\n\n", "colors", "=", "p", ".", "colors", "[", "ci", ":", "]", "\n", "colors", "[", "0", "]", "=", "p", ".", "cr", "\n", "colors", "[", "1", "]", "=", "p", ".", "cg", "\n", "colors", "[", "2", "]", "=", "p", ".", "cb", "\n", "colors", "[", "3", "]", "=", "a", "\n", "colors", "[", "4", "]", "=", "p", ".", "cr", "\n", "colors", "[", "5", "]", "=", "p", ".", "cg", "\n", "colors", "[", "6", "]", "=", "p", ".", "cb", "\n", "colors", "[", "7", "]", "=", "a", "\n", "ci", "+=", "8", "\n", "vertices", "=", "p", ".", "vertices", "[", "vi", ":", "]", "\n", "vertices", "[", "0", "]", "=", "int32", "(", "s", ".", "X0", ")", "\n", "vertices", "[", "1", "]", "=", "int32", "(", "s", ".", "Y", ")", "\n", "vertices", "[", "2", "]", "=", "int32", "(", "s", ".", "X1", ")", "\n", "vertices", "[", "3", "]", "=", "int32", "(", "s", ".", "Y", ")", "\n", "vi", "+=", "4", "\n", "}", "\n", "}"], "docstring": "// Paint satisfies the Painter interface by painting ss onto an image.RGBA.", "docstring_tokens": ["Paint", "satisfies", "the", "Painter", "interface", "by", "painting", "ss", "onto", "an", "image", ".", "RGBA", "."], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dgl/gc.go#L39-L80", "partition": "test"}
{"repo": "alexflint/go-arg", "path": "parse.go", "func_name": "isBoolean", "original_string": "func isBoolean(t reflect.Type) bool {\n\tswitch {\n\tcase t.Implements(textUnmarshalerType):\n\t\treturn false\n\tcase t.Kind() == reflect.Bool:\n\t\treturn true\n\tcase t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Bool:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}", "language": "go", "code": "func isBoolean(t reflect.Type) bool {\n\tswitch {\n\tcase t.Implements(textUnmarshalerType):\n\t\treturn false\n\tcase t.Kind() == reflect.Bool:\n\t\treturn true\n\tcase t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Bool:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}", "code_tokens": ["func", "isBoolean", "(", "t", "reflect", ".", "Type", ")", "bool", "{", "switch", "{", "case", "t", ".", "Implements", "(", "textUnmarshalerType", ")", ":", "return", "false", "\n", "case", "t", ".", "Kind", "(", ")", "==", "reflect", ".", "Bool", ":", "return", "true", "\n", "case", "t", ".", "Kind", "(", ")", "==", "reflect", ".", "Ptr", "&&", "t", ".", "Elem", "(", ")", ".", "Kind", "(", ")", "==", "reflect", ".", "Bool", ":", "return", "true", "\n", "default", ":", "return", "false", "\n", "}", "\n", "}"], "docstring": "// isBoolean returns true if the type can be parsed from a single string", "docstring_tokens": ["isBoolean", "returns", "true", "if", "the", "type", "can", "be", "parsed", "from", "a", "single", "string"], "sha": "fb1ae1c3e0bd00d45333c3d51384afc05846f7a0", "url": "https://github.com/alexflint/go-arg/blob/fb1ae1c3e0bd00d45333c3d51384afc05846f7a0/parse.go#L520-L531", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "raft/log.go", "func_name": "newLog", "original_string": "func newLog(storage Storage, logger Logger) *raftLog {\n\treturn newLogWithSize(storage, logger, noLimit)\n}", "language": "go", "code": "func newLog(storage Storage, logger Logger) *raftLog {\n\treturn newLogWithSize(storage, logger, noLimit)\n}", "code_tokens": ["func", "newLog", "(", "storage", "Storage", ",", "logger", "Logger", ")", "*", "raftLog", "{", "return", "newLogWithSize", "(", "storage", ",", "logger", ",", "noLimit", ")", "\n", "}"], "docstring": "// newLog returns log using the given storage and default options. It\n// recovers the log to the state that it just commits and applies the\n// latest snapshot.", "docstring_tokens": ["newLog", "returns", "log", "using", "the", "given", "storage", "and", "default", "options", ".", "It", "recovers", "the", "log", "to", "the", "state", "that", "it", "just", "commits", "and", "applies", "the", "latest", "snapshot", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/log.go#L50-L52", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pkg/grpcutil/stream.go", "func_name": "ChunkReader", "original_string": "func ChunkReader(r io.Reader, f func([]byte) error) (int, error) {\n\tvar total int\n\tbuf := GetBuffer()\n\tdefer PutBuffer(buf)\n\tfor {\n\t\tn, err := r.Read(buf)\n\t\tif n == 0 && err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn total, nil\n\t\t\t}\n\t\t\treturn total, err\n\t\t}\n\t\tif err := f(buf[:n]); err != nil {\n\t\t\treturn total, err\n\t\t}\n\t\ttotal += n\n\t}\n}", "language": "go", "code": "func ChunkReader(r io.Reader, f func([]byte) error) (int, error) {\n\tvar total int\n\tbuf := GetBuffer()\n\tdefer PutBuffer(buf)\n\tfor {\n\t\tn, err := r.Read(buf)\n\t\tif n == 0 && err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn total, nil\n\t\t\t}\n\t\t\treturn total, err\n\t\t}\n\t\tif err := f(buf[:n]); err != nil {\n\t\t\treturn total, err\n\t\t}\n\t\ttotal += n\n\t}\n}", "code_tokens": ["func", "ChunkReader", "(", "r", "io", ".", "Reader", ",", "f", "func", "(", "[", "]", "byte", ")", "error", ")", "(", "int", ",", "error", ")", "{", "var", "total", "int", "\n", "buf", ":=", "GetBuffer", "(", ")", "\n", "defer", "PutBuffer", "(", "buf", ")", "\n", "for", "{", "n", ",", "err", ":=", "r", ".", "Read", "(", "buf", ")", "\n", "if", "n", "==", "0", "&&", "err", "!=", "nil", "{", "if", "err", "==", "io", ".", "EOF", "{", "return", "total", ",", "nil", "\n", "}", "\n", "return", "total", ",", "err", "\n", "}", "\n", "if", "err", ":=", "f", "(", "buf", "[", ":", "n", "]", ")", ";", "err", "!=", "nil", "{", "return", "total", ",", "err", "\n", "}", "\n", "total", "+=", "n", "\n", "}", "\n", "}"], "docstring": "// ChunkReader splits a reader into reasonably sized chunks for the purpose\n// of transmitting the chunks over gRPC. For each chunk, it calls the given\n// function.", "docstring_tokens": ["ChunkReader", "splits", "a", "reader", "into", "reasonably", "sized", "chunks", "for", "the", "purpose", "of", "transmitting", "the", "chunks", "over", "gRPC", ".", "For", "each", "chunk", "it", "calls", "the", "given", "function", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pkg/grpcutil/stream.go#L33-L50", "partition": "test"}
{"repo": "rightscale/rsc", "path": "cm15/codegen_client.go", "func_name": "BackupLocator", "original_string": "func (api *API) BackupLocator(href string) *BackupLocator {\n\treturn &BackupLocator{Href(href), api}\n}", "language": "go", "code": "func (api *API) BackupLocator(href string) *BackupLocator {\n\treturn &BackupLocator{Href(href), api}\n}", "code_tokens": ["func", "(", "api", "*", "API", ")", "BackupLocator", "(", "href", "string", ")", "*", "BackupLocator", "{", "return", "&", "BackupLocator", "{", "Href", "(", "href", ")", ",", "api", "}", "\n", "}"], "docstring": "// BackupLocator builds a locator from the given href.", "docstring_tokens": ["BackupLocator", "builds", "a", "locator", "from", "the", "given", "href", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L1206-L1208", "partition": "test"}
{"repo": "containers/image", "path": "oci/archive/oci_dest.go", "func_name": "tarDirectory", "original_string": "func tarDirectory(src, dst string) error {\n\t// input is a stream of bytes from the archive of the directory at path\n\tinput, err := archive.Tar(src, archive.Uncompressed)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error retrieving stream of bytes from %q\", src)\n\t}\n\n\t// creates the tar file\n\toutFile, err := os.Create(dst)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error creating tar file %q\", dst)\n\t}\n\tdefer outFile.Close()\n\n\t// copies the contents of the directory to the tar file\n\t// TODO: This can take quite some time, and should ideally be cancellable using a context.Context.\n\t_, err = io.Copy(outFile, input)\n\n\treturn err\n}", "language": "go", "code": "func tarDirectory(src, dst string) error {\n\t// input is a stream of bytes from the archive of the directory at path\n\tinput, err := archive.Tar(src, archive.Uncompressed)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error retrieving stream of bytes from %q\", src)\n\t}\n\n\t// creates the tar file\n\toutFile, err := os.Create(dst)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error creating tar file %q\", dst)\n\t}\n\tdefer outFile.Close()\n\n\t// copies the contents of the directory to the tar file\n\t// TODO: This can take quite some time, and should ideally be cancellable using a context.Context.\n\t_, err = io.Copy(outFile, input)\n\n\treturn err\n}", "code_tokens": ["func", "tarDirectory", "(", "src", ",", "dst", "string", ")", "error", "{", "// input is a stream of bytes from the archive of the directory at path", "input", ",", "err", ":=", "archive", ".", "Tar", "(", "src", ",", "archive", ".", "Uncompressed", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ",", "src", ")", "\n", "}", "\n\n", "// creates the tar file", "outFile", ",", "err", ":=", "os", ".", "Create", "(", "dst", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ",", "dst", ")", "\n", "}", "\n", "defer", "outFile", ".", "Close", "(", ")", "\n\n", "// copies the contents of the directory to the tar file", "// TODO: This can take quite some time, and should ideally be cancellable using a context.Context.", "_", ",", "err", "=", "io", ".", "Copy", "(", "outFile", ",", "input", ")", "\n\n", "return", "err", "\n", "}"], "docstring": "// tar converts the directory at src and saves it to dst", "docstring_tokens": ["tar", "converts", "the", "directory", "at", "src", "and", "saves", "it", "to", "dst"], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/oci/archive/oci_dest.go#L132-L151", "partition": "test"}
{"repo": "pantheon-systems/go-certauth", "path": "certauth.go", "func_name": "ValidateOU", "original_string": "func (a *Auth) ValidateOU(verifiedCert *x509.Certificate) error {\n\tvar failed []string\n\n\tfor _, ou := range a.opt.AllowedOUs {\n\t\tfor _, clientOU := range verifiedCert.Subject.OrganizationalUnit {\n\t\t\tif ou == clientOU {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tfailed = append(failed, clientOU)\n\t\t}\n\t}\n\treturn fmt.Errorf(\"cert failed OU validation for %v, Allowed: %v\", failed, a.opt.AllowedOUs)\n}", "language": "go", "code": "func (a *Auth) ValidateOU(verifiedCert *x509.Certificate) error {\n\tvar failed []string\n\n\tfor _, ou := range a.opt.AllowedOUs {\n\t\tfor _, clientOU := range verifiedCert.Subject.OrganizationalUnit {\n\t\t\tif ou == clientOU {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tfailed = append(failed, clientOU)\n\t\t}\n\t}\n\treturn fmt.Errorf(\"cert failed OU validation for %v, Allowed: %v\", failed, a.opt.AllowedOUs)\n}", "code_tokens": ["func", "(", "a", "*", "Auth", ")", "ValidateOU", "(", "verifiedCert", "*", "x509", ".", "Certificate", ")", "error", "{", "var", "failed", "[", "]", "string", "\n\n", "for", "_", ",", "ou", ":=", "range", "a", ".", "opt", ".", "AllowedOUs", "{", "for", "_", ",", "clientOU", ":=", "range", "verifiedCert", ".", "Subject", ".", "OrganizationalUnit", "{", "if", "ou", "==", "clientOU", "{", "return", "nil", "\n", "}", "\n", "failed", "=", "append", "(", "failed", ",", "clientOU", ")", "\n", "}", "\n", "}", "\n", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "failed", ",", "a", ".", "opt", ".", "AllowedOUs", ")", "\n", "}"], "docstring": "// ValidateOU checks the OU of a verified peer cert and raises 403 if the OU doesn't match any OU in the AllowedOUs list.", "docstring_tokens": ["ValidateOU", "checks", "the", "OU", "of", "a", "verified", "peer", "cert", "and", "raises", "403", "if", "the", "OU", "doesn", "t", "match", "any", "OU", "in", "the", "AllowedOUs", "list", "."], "sha": "8764720d23a5034dd9fab090815b7859463c68f6", "url": "https://github.com/pantheon-systems/go-certauth/blob/8764720d23a5034dd9fab090815b7859463c68f6/certauth.go#L178-L190", "partition": "test"}
{"repo": "mrd0ll4r/tbotapi", "path": "outgoing.go", "func_name": "querystring", "original_string": "func (op *OutgoingPhoto) querystring() querystring {\n\ttoReturn := map[string]string(op.getBaseQueryString())\n\n\tif op.Caption != \"\" {\n\t\ttoReturn[\"caption\"] = op.Caption\n\t}\n\n\treturn querystring(toReturn)\n}", "language": "go", "code": "func (op *OutgoingPhoto) querystring() querystring {\n\ttoReturn := map[string]string(op.getBaseQueryString())\n\n\tif op.Caption != \"\" {\n\t\ttoReturn[\"caption\"] = op.Caption\n\t}\n\n\treturn querystring(toReturn)\n}", "code_tokens": ["func", "(", "op", "*", "OutgoingPhoto", ")", "querystring", "(", ")", "querystring", "{", "toReturn", ":=", "map", "[", "string", "]", "string", "(", "op", ".", "getBaseQueryString", "(", ")", ")", "\n\n", "if", "op", ".", "Caption", "!=", "\"", "\"", "{", "toReturn", "[", "\"", "\"", "]", "=", "op", ".", "Caption", "\n", "}", "\n\n", "return", "querystring", "(", "toReturn", ")", "\n", "}"], "docstring": "// querystring implements querystringer to represent the photo.", "docstring_tokens": ["querystring", "implements", "querystringer", "to", "represent", "the", "photo", "."], "sha": "edc257282178bb5cebbfcc41260ec04c1ec7ac19", "url": "https://github.com/mrd0ll4r/tbotapi/blob/edc257282178bb5cebbfcc41260ec04c1ec7ac19/outgoing.go#L304-L312", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "config/config.go", "func_name": "Clone", "original_string": "func (c *Config) Clone() *Config {\n\tcc := *c\n\tcc.Exts = make(map[string]interface{})\n\tfor k, v := range c.Exts {\n\t\tcc.Exts[k] = v\n\t}\n\tcc.KindMap = make(map[string]MappedKind)\n\tfor k, v := range c.KindMap {\n\t\tcc.KindMap[k] = v\n\t}\n\treturn &cc\n}", "language": "go", "code": "func (c *Config) Clone() *Config {\n\tcc := *c\n\tcc.Exts = make(map[string]interface{})\n\tfor k, v := range c.Exts {\n\t\tcc.Exts[k] = v\n\t}\n\tcc.KindMap = make(map[string]MappedKind)\n\tfor k, v := range c.KindMap {\n\t\tcc.KindMap[k] = v\n\t}\n\treturn &cc\n}", "code_tokens": ["func", "(", "c", "*", "Config", ")", "Clone", "(", ")", "*", "Config", "{", "cc", ":=", "*", "c", "\n", "cc", ".", "Exts", "=", "make", "(", "map", "[", "string", "]", "interface", "{", "}", ")", "\n", "for", "k", ",", "v", ":=", "range", "c", ".", "Exts", "{", "cc", ".", "Exts", "[", "k", "]", "=", "v", "\n", "}", "\n", "cc", ".", "KindMap", "=", "make", "(", "map", "[", "string", "]", "MappedKind", ")", "\n", "for", "k", ",", "v", ":=", "range", "c", ".", "KindMap", "{", "cc", ".", "KindMap", "[", "k", "]", "=", "v", "\n", "}", "\n", "return", "&", "cc", "\n", "}"], "docstring": "// Clone creates a copy of the configuration for use in a subdirectory.\n// Note that the Exts map is copied, but its contents are not.\n// Configurer.Configure should do this, if needed.", "docstring_tokens": ["Clone", "creates", "a", "copy", "of", "the", "configuration", "for", "use", "in", "a", "subdirectory", ".", "Note", "that", "the", "Exts", "map", "is", "copied", "but", "its", "contents", "are", "not", ".", "Configurer", ".", "Configure", "should", "do", "this", "if", "needed", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/config/config.go#L105-L116", "partition": "test"}
{"repo": "gokyle/fswatch", "path": "watcher.go", "func_name": "Watching", "original_string": "func (w *Watcher) Watching() (paths []string) {\n\tpaths = make([]string, 0)\n\tfor path, _ := range w.paths {\n\t\tpaths = append(paths, path)\n\t}\n\treturn\n}", "language": "go", "code": "func (w *Watcher) Watching() (paths []string) {\n\tpaths = make([]string, 0)\n\tfor path, _ := range w.paths {\n\t\tpaths = append(paths, path)\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "w", "*", "Watcher", ")", "Watching", "(", ")", "(", "paths", "[", "]", "string", ")", "{", "paths", "=", "make", "(", "[", "]", "string", ",", "0", ")", "\n", "for", "path", ",", "_", ":=", "range", "w", ".", "paths", "{", "paths", "=", "append", "(", "paths", ",", "path", ")", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// Watching returns a list of the files being watched.", "docstring_tokens": ["Watching", "returns", "a", "list", "of", "the", "files", "being", "watched", "."], "sha": "1dbdf8320a690537582afe0f45c947f501adeaad", "url": "https://github.com/gokyle/fswatch/blob/1dbdf8320a690537582afe0f45c947f501adeaad/watcher.go#L231-L237", "partition": "test"}
{"repo": "rightscale/rsc", "path": "httpclient/http.go", "func_name": "doImp", "original_string": "func (d *dumpClient) doImp(req *http.Request, hidden bool, ctx context.Context) (*http.Response, error) {\n\tif req.URL.Scheme == \"\" {\n\t\tif d.isInsecure() {\n\t\t\treq.URL.Scheme = \"http\"\n\t\t} else {\n\t\t\treq.URL.Scheme = \"https\"\n\t\t}\n\t}\n\n\t//set user-agent if one is not provided.\n\tua := req.Header.Get(\"User-Agent\")\n\tif ua == \"\" {\n\t\treq.Header.Set(\"User-Agent\", UA)\n\t}\n\n\tvar reqBody []byte\n\tstartedAt := time.Now()\n\n\t// prefer the X-Request-Id header as request token for logging, if present.\n\tid := req.Header.Get(requestIdHeader)\n\tif id == \"\" {\n\t\tid = ShortToken()\n\t}\n\tlog.Info(\"started\", \"id\", id, req.Method, req.URL.String())\n\tdf := d.dumpFormat()\n\thide := (df == NoDump) || (hidden && !df.IsVerbose())\n\tif !hide {\n\t\tstartedAt = time.Now()\n\t\treqBody = d.dumpRequest(req)\n\t}\n\tvar resp *http.Response\n\tvar err error\n\tif ctx == nil {\n\t\tresp, err = d.Client.Do(req)\n\t} else {\n\t\tresp, err = ctxhttpDo(ctx, d.getClientWithoutTimeout(), req)\n\t}\n\tif urlError, ok := err.(*url.Error); ok {\n\t\tif urlError.Err.Error() == noRedirectError {\n\t\t\terr = nil\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !hide {\n\t\td.dumpResponse(resp, req, reqBody)\n\t}\n\tlog.Info(\"completed\", \"id\", id, \"status\", resp.Status, \"time\", time.Since(startedAt).String())\n\n\treturn resp, nil\n}", "language": "go", "code": "func (d *dumpClient) doImp(req *http.Request, hidden bool, ctx context.Context) (*http.Response, error) {\n\tif req.URL.Scheme == \"\" {\n\t\tif d.isInsecure() {\n\t\t\treq.URL.Scheme = \"http\"\n\t\t} else {\n\t\t\treq.URL.Scheme = \"https\"\n\t\t}\n\t}\n\n\t//set user-agent if one is not provided.\n\tua := req.Header.Get(\"User-Agent\")\n\tif ua == \"\" {\n\t\treq.Header.Set(\"User-Agent\", UA)\n\t}\n\n\tvar reqBody []byte\n\tstartedAt := time.Now()\n\n\t// prefer the X-Request-Id header as request token for logging, if present.\n\tid := req.Header.Get(requestIdHeader)\n\tif id == \"\" {\n\t\tid = ShortToken()\n\t}\n\tlog.Info(\"started\", \"id\", id, req.Method, req.URL.String())\n\tdf := d.dumpFormat()\n\thide := (df == NoDump) || (hidden && !df.IsVerbose())\n\tif !hide {\n\t\tstartedAt = time.Now()\n\t\treqBody = d.dumpRequest(req)\n\t}\n\tvar resp *http.Response\n\tvar err error\n\tif ctx == nil {\n\t\tresp, err = d.Client.Do(req)\n\t} else {\n\t\tresp, err = ctxhttpDo(ctx, d.getClientWithoutTimeout(), req)\n\t}\n\tif urlError, ok := err.(*url.Error); ok {\n\t\tif urlError.Err.Error() == noRedirectError {\n\t\t\terr = nil\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !hide {\n\t\td.dumpResponse(resp, req, reqBody)\n\t}\n\tlog.Info(\"completed\", \"id\", id, \"status\", resp.Status, \"time\", time.Since(startedAt).String())\n\n\treturn resp, nil\n}", "code_tokens": ["func", "(", "d", "*", "dumpClient", ")", "doImp", "(", "req", "*", "http", ".", "Request", ",", "hidden", "bool", ",", "ctx", "context", ".", "Context", ")", "(", "*", "http", ".", "Response", ",", "error", ")", "{", "if", "req", ".", "URL", ".", "Scheme", "==", "\"", "\"", "{", "if", "d", ".", "isInsecure", "(", ")", "{", "req", ".", "URL", ".", "Scheme", "=", "\"", "\"", "\n", "}", "else", "{", "req", ".", "URL", ".", "Scheme", "=", "\"", "\"", "\n", "}", "\n", "}", "\n\n", "//set user-agent if one is not provided.", "ua", ":=", "req", ".", "Header", ".", "Get", "(", "\"", "\"", ")", "\n", "if", "ua", "==", "\"", "\"", "{", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "UA", ")", "\n", "}", "\n\n", "var", "reqBody", "[", "]", "byte", "\n", "startedAt", ":=", "time", ".", "Now", "(", ")", "\n\n", "// prefer the X-Request-Id header as request token for logging, if present.", "id", ":=", "req", ".", "Header", ".", "Get", "(", "requestIdHeader", ")", "\n", "if", "id", "==", "\"", "\"", "{", "id", "=", "ShortToken", "(", ")", "\n", "}", "\n", "log", ".", "Info", "(", "\"", "\"", ",", "\"", "\"", ",", "id", ",", "req", ".", "Method", ",", "req", ".", "URL", ".", "String", "(", ")", ")", "\n", "df", ":=", "d", ".", "dumpFormat", "(", ")", "\n", "hide", ":=", "(", "df", "==", "NoDump", ")", "||", "(", "hidden", "&&", "!", "df", ".", "IsVerbose", "(", ")", ")", "\n", "if", "!", "hide", "{", "startedAt", "=", "time", ".", "Now", "(", ")", "\n", "reqBody", "=", "d", ".", "dumpRequest", "(", "req", ")", "\n", "}", "\n", "var", "resp", "*", "http", ".", "Response", "\n", "var", "err", "error", "\n", "if", "ctx", "==", "nil", "{", "resp", ",", "err", "=", "d", ".", "Client", ".", "Do", "(", "req", ")", "\n", "}", "else", "{", "resp", ",", "err", "=", "ctxhttpDo", "(", "ctx", ",", "d", ".", "getClientWithoutTimeout", "(", ")", ",", "req", ")", "\n", "}", "\n", "if", "urlError", ",", "ok", ":=", "err", ".", "(", "*", "url", ".", "Error", ")", ";", "ok", "{", "if", "urlError", ".", "Err", ".", "Error", "(", ")", "==", "noRedirectError", "{", "err", "=", "nil", "\n", "}", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "!", "hide", "{", "d", ".", "dumpResponse", "(", "resp", ",", "req", ",", "reqBody", ")", "\n", "}", "\n", "log", ".", "Info", "(", "\"", "\"", ",", "\"", "\"", ",", "id", ",", "\"", "\"", ",", "resp", ".", "Status", ",", "\"", "\"", ",", "time", ".", "Since", "(", "startedAt", ")", ".", "String", "(", ")", ")", "\n\n", "return", "resp", ",", "nil", "\n", "}"], "docstring": "// doImp actually performs the HTTP request logging according to the various settings.", "docstring_tokens": ["doImp", "actually", "performs", "the", "HTTP", "request", "logging", "according", "to", "the", "various", "settings", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/httpclient/http.go#L272-L323", "partition": "test"}
{"repo": "segmentio/objconv", "path": "codec.go", "func_name": "NewEncoder", "original_string": "func (c Codec) NewEncoder(w io.Writer) *Encoder {\n\treturn NewEncoder(c.NewEmitter(w))\n}", "language": "go", "code": "func (c Codec) NewEncoder(w io.Writer) *Encoder {\n\treturn NewEncoder(c.NewEmitter(w))\n}", "code_tokens": ["func", "(", "c", "Codec", ")", "NewEncoder", "(", "w", "io", ".", "Writer", ")", "*", "Encoder", "{", "return", "NewEncoder", "(", "c", ".", "NewEmitter", "(", "w", ")", ")", "\n", "}"], "docstring": "// NewEncoder returns a new encoder that outputs to w.", "docstring_tokens": ["NewEncoder", "returns", "a", "new", "encoder", "that", "outputs", "to", "w", "."], "sha": "7a1d7b8e6f3551b30751e6b2ea6bae500883870e", "url": "https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/codec.go#L15-L17", "partition": "test"}
{"repo": "jinzhu/now", "path": "now.go", "func_name": "BeginningOfHour", "original_string": "func (now *Now) BeginningOfHour() time.Time {\n\ty, m, d := now.Date()\n\treturn time.Date(y, m, d, now.Time.Hour(), 0, 0, 0, now.Time.Location())\n}", "language": "go", "code": "func (now *Now) BeginningOfHour() time.Time {\n\ty, m, d := now.Date()\n\treturn time.Date(y, m, d, now.Time.Hour(), 0, 0, 0, now.Time.Location())\n}", "code_tokens": ["func", "(", "now", "*", "Now", ")", "BeginningOfHour", "(", ")", "time", ".", "Time", "{", "y", ",", "m", ",", "d", ":=", "now", ".", "Date", "(", ")", "\n", "return", "time", ".", "Date", "(", "y", ",", "m", ",", "d", ",", "now", ".", "Time", ".", "Hour", "(", ")", ",", "0", ",", "0", ",", "0", ",", "now", ".", "Time", ".", "Location", "(", ")", ")", "\n", "}"], "docstring": "// BeginningOfHour beginning of hour", "docstring_tokens": ["BeginningOfHour", "beginning", "of", "hour"], "sha": "8ec929ed50c3ac25ce77ba4486e1f277c552c591", "url": "https://github.com/jinzhu/now/blob/8ec929ed50c3ac25ce77ba4486e1f277c552c591/now.go#L15-L18", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "memory/memory.go", "func_name": "Do", "original_string": "func (p *StopSamplingParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStopSampling, nil, nil)\n}", "language": "go", "code": "func (p *StopSamplingParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStopSampling, nil, nil)\n}", "code_tokens": ["func", "(", "p", "*", "StopSamplingParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandStopSampling", ",", "nil", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Memory.stopSampling against the provided context.", "docstring_tokens": ["Do", "executes", "Memory", ".", "stopSampling", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/memory/memory.go#L172-L174", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewChangeTrustResult", "original_string": "func NewChangeTrustResult(code ChangeTrustResultCode, value interface{}) (result ChangeTrustResult, err error) {\n\tresult.Code = code\n\tswitch ChangeTrustResultCode(code) {\n\tcase ChangeTrustResultCodeChangeTrustSuccess:\n\t\t// void\n\tdefault:\n\t\t// void\n\t}\n\treturn\n}", "language": "go", "code": "func NewChangeTrustResult(code ChangeTrustResultCode, value interface{}) (result ChangeTrustResult, err error) {\n\tresult.Code = code\n\tswitch ChangeTrustResultCode(code) {\n\tcase ChangeTrustResultCodeChangeTrustSuccess:\n\t\t// void\n\tdefault:\n\t\t// void\n\t}\n\treturn\n}", "code_tokens": ["func", "NewChangeTrustResult", "(", "code", "ChangeTrustResultCode", ",", "value", "interface", "{", "}", ")", "(", "result", "ChangeTrustResult", ",", "err", "error", ")", "{", "result", ".", "Code", "=", "code", "\n", "switch", "ChangeTrustResultCode", "(", "code", ")", "{", "case", "ChangeTrustResultCodeChangeTrustSuccess", ":", "// void", "default", ":", "// void", "}", "\n", "return", "\n", "}"], "docstring": "// NewChangeTrustResult creates a new  ChangeTrustResult.", "docstring_tokens": ["NewChangeTrustResult", "creates", "a", "new", "ChangeTrustResult", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L3348-L3357", "partition": "test"}
{"repo": "urandom/handler", "path": "security/nonce.go", "func_name": "Age", "original_string": "func Age(age time.Duration) Option {\n\treturn Option{func(o *options) {\n\t\to.age = age\n\t}}\n}", "language": "go", "code": "func Age(age time.Duration) Option {\n\treturn Option{func(o *options) {\n\t\to.age = age\n\t}}\n}", "code_tokens": ["func", "Age", "(", "age", "time", ".", "Duration", ")", "Option", "{", "return", "Option", "{", "func", "(", "o", "*", "options", ")", "{", "o", ".", "age", "=", "age", "\n", "}", "}", "\n", "}"], "docstring": "// Age sets the maximum time duration a nonce can be valid", "docstring_tokens": ["Age", "sets", "the", "maximum", "time", "duration", "a", "nonce", "can", "be", "valid"], "sha": "61508044a5569d1609521d81e81f6737567fd104", "url": "https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/security/nonce.go#L78-L82", "partition": "test"}
{"repo": "r3labs/sse", "path": "stream.go", "func_name": "newStream", "original_string": "func newStream(bufsize int, replay bool) *Stream {\n\treturn &Stream{\n\t\tAutoReplay:  replay,\n\t\tsubscribers: make([]*Subscriber, 0),\n\t\tregister:    make(chan *Subscriber),\n\t\tderegister:  make(chan *Subscriber),\n\t\tevent:       make(chan *Event, bufsize),\n\t\tquit:        make(chan bool),\n\t\tEventlog:    make(EventLog, 0),\n\t}\n}", "language": "go", "code": "func newStream(bufsize int, replay bool) *Stream {\n\treturn &Stream{\n\t\tAutoReplay:  replay,\n\t\tsubscribers: make([]*Subscriber, 0),\n\t\tregister:    make(chan *Subscriber),\n\t\tderegister:  make(chan *Subscriber),\n\t\tevent:       make(chan *Event, bufsize),\n\t\tquit:        make(chan bool),\n\t\tEventlog:    make(EventLog, 0),\n\t}\n}", "code_tokens": ["func", "newStream", "(", "bufsize", "int", ",", "replay", "bool", ")", "*", "Stream", "{", "return", "&", "Stream", "{", "AutoReplay", ":", "replay", ",", "subscribers", ":", "make", "(", "[", "]", "*", "Subscriber", ",", "0", ")", ",", "register", ":", "make", "(", "chan", "*", "Subscriber", ")", ",", "deregister", ":", "make", "(", "chan", "*", "Subscriber", ")", ",", "event", ":", "make", "(", "chan", "*", "Event", ",", "bufsize", ")", ",", "quit", ":", "make", "(", "chan", "bool", ")", ",", "Eventlog", ":", "make", "(", "EventLog", ",", "0", ")", ",", "}", "\n", "}"], "docstring": "// newStream returns a new stream", "docstring_tokens": ["newStream", "returns", "a", "new", "stream"], "sha": "2f90368216802092e9ed520c43e974e11d50438d", "url": "https://github.com/r3labs/sse/blob/2f90368216802092e9ed520c43e974e11d50438d/stream.go#L27-L37", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/cmd/ask.go", "func_name": "readAnswer", "original_string": "func readAnswer(defaultAnswer string) string {\n\tanswer, _ := stdin.ReadString('\\n')\n\tanswer = strings.TrimSuffix(answer, \"\\n\")\n\tanswer = strings.TrimSpace(answer)\n\tif answer == \"\" {\n\t\tanswer = defaultAnswer\n\t}\n\n\treturn answer\n}", "language": "go", "code": "func readAnswer(defaultAnswer string) string {\n\tanswer, _ := stdin.ReadString('\\n')\n\tanswer = strings.TrimSuffix(answer, \"\\n\")\n\tanswer = strings.TrimSpace(answer)\n\tif answer == \"\" {\n\t\tanswer = defaultAnswer\n\t}\n\n\treturn answer\n}", "code_tokens": ["func", "readAnswer", "(", "defaultAnswer", "string", ")", "string", "{", "answer", ",", "_", ":=", "stdin", ".", "ReadString", "(", "'\\n'", ")", "\n", "answer", "=", "strings", ".", "TrimSuffix", "(", "answer", ",", "\"", "\\n", "\"", ")", "\n", "answer", "=", "strings", ".", "TrimSpace", "(", "answer", ")", "\n", "if", "answer", "==", "\"", "\"", "{", "answer", "=", "defaultAnswer", "\n", "}", "\n\n", "return", "answer", "\n", "}"], "docstring": "// Read the user's answer from the input stream, trimming newline and providing a default.", "docstring_tokens": ["Read", "the", "user", "s", "answer", "from", "the", "input", "stream", "trimming", "newline", "and", "providing", "a", "default", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/cmd/ask.go#L127-L136", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/pfsdb/pfsdb.go", "func_name": "Commits", "original_string": "func Commits(etcdClient *etcd.Client, etcdPrefix string, repo string) col.Collection {\n\treturn col.NewCollection(\n\t\tetcdClient,\n\t\tpath.Join(etcdPrefix, commitsPrefix, repo),\n\t\t[]*col.Index{ProvenanceIndex},\n\t\t&pfs.CommitInfo{},\n\t\tnil,\n\t\tnil,\n\t)\n}", "language": "go", "code": "func Commits(etcdClient *etcd.Client, etcdPrefix string, repo string) col.Collection {\n\treturn col.NewCollection(\n\t\tetcdClient,\n\t\tpath.Join(etcdPrefix, commitsPrefix, repo),\n\t\t[]*col.Index{ProvenanceIndex},\n\t\t&pfs.CommitInfo{},\n\t\tnil,\n\t\tnil,\n\t)\n}", "code_tokens": ["func", "Commits", "(", "etcdClient", "*", "etcd", ".", "Client", ",", "etcdPrefix", "string", ",", "repo", "string", ")", "col", ".", "Collection", "{", "return", "col", ".", "NewCollection", "(", "etcdClient", ",", "path", ".", "Join", "(", "etcdPrefix", ",", "commitsPrefix", ",", "repo", ")", ",", "[", "]", "*", "col", ".", "Index", "{", "ProvenanceIndex", "}", ",", "&", "pfs", ".", "CommitInfo", "{", "}", ",", "nil", ",", "nil", ",", ")", "\n", "}"], "docstring": "// Commits returns a collection of commits", "docstring_tokens": ["Commits", "returns", "a", "collection", "of", "commits"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/pfsdb/pfsdb.go#L52-L61", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "iterator.go", "func_name": "Close", "original_string": "func (it *Iterator) Close() {\n\tit.snap.Close()\n\tit.snap.db.store.FreeBuf(it.buf)\n\tit.iter.Close()\n}", "language": "go", "code": "func (it *Iterator) Close() {\n\tit.snap.Close()\n\tit.snap.db.store.FreeBuf(it.buf)\n\tit.iter.Close()\n}", "code_tokens": ["func", "(", "it", "*", "Iterator", ")", "Close", "(", ")", "{", "it", ".", "snap", ".", "Close", "(", ")", "\n", "it", ".", "snap", ".", "db", ".", "store", ".", "FreeBuf", "(", "it", ".", "buf", ")", "\n", "it", ".", "iter", ".", "Close", "(", ")", "\n", "}"], "docstring": "// Close executes destructor for iterator", "docstring_tokens": ["Close", "executes", "destructor", "for", "iterator"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/iterator.go#L100-L104", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/github/client.go", "func_name": "Throttle", "original_string": "func (c *Client) Throttle(hourlyTokens, burst int) {\n\tc.log(\"Throttle\", hourlyTokens, burst)\n\tc.throttle.lock.Lock()\n\tdefer c.throttle.lock.Unlock()\n\tpreviouslyThrottled := c.throttle.ticker != nil\n\tif hourlyTokens <= 0 || burst <= 0 { // Disable throttle\n\t\tif previouslyThrottled { // Unwrap clients if necessary\n\t\t\tc.client = c.throttle.http\n\t\t\tc.gqlc = c.throttle.graph\n\t\t\tc.throttle.ticker.Stop()\n\t\t\tc.throttle.ticker = nil\n\t\t}\n\t\treturn\n\t}\n\trate := time.Hour / time.Duration(hourlyTokens)\n\tticker := time.NewTicker(rate)\n\tthrottle := make(chan time.Time, burst)\n\tfor i := 0; i < burst; i++ { // Fill up the channel\n\t\tthrottle <- time.Now()\n\t}\n\tgo func() {\n\t\t// Refill the channel\n\t\tfor t := range ticker.C {\n\t\t\tselect {\n\t\t\tcase throttle <- t:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tif !previouslyThrottled { // Wrap clients if we haven't already\n\t\tc.throttle.http = c.client\n\t\tc.throttle.graph = c.gqlc\n\t\tc.client = &c.throttle\n\t\tc.gqlc = &c.throttle\n\t}\n\tc.throttle.ticker = ticker\n\tc.throttle.throttle = throttle\n}", "language": "go", "code": "func (c *Client) Throttle(hourlyTokens, burst int) {\n\tc.log(\"Throttle\", hourlyTokens, burst)\n\tc.throttle.lock.Lock()\n\tdefer c.throttle.lock.Unlock()\n\tpreviouslyThrottled := c.throttle.ticker != nil\n\tif hourlyTokens <= 0 || burst <= 0 { // Disable throttle\n\t\tif previouslyThrottled { // Unwrap clients if necessary\n\t\t\tc.client = c.throttle.http\n\t\t\tc.gqlc = c.throttle.graph\n\t\t\tc.throttle.ticker.Stop()\n\t\t\tc.throttle.ticker = nil\n\t\t}\n\t\treturn\n\t}\n\trate := time.Hour / time.Duration(hourlyTokens)\n\tticker := time.NewTicker(rate)\n\tthrottle := make(chan time.Time, burst)\n\tfor i := 0; i < burst; i++ { // Fill up the channel\n\t\tthrottle <- time.Now()\n\t}\n\tgo func() {\n\t\t// Refill the channel\n\t\tfor t := range ticker.C {\n\t\t\tselect {\n\t\t\tcase throttle <- t:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tif !previouslyThrottled { // Wrap clients if we haven't already\n\t\tc.throttle.http = c.client\n\t\tc.throttle.graph = c.gqlc\n\t\tc.client = &c.throttle\n\t\tc.gqlc = &c.throttle\n\t}\n\tc.throttle.ticker = ticker\n\tc.throttle.throttle = throttle\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "Throttle", "(", "hourlyTokens", ",", "burst", "int", ")", "{", "c", ".", "log", "(", "\"", "\"", ",", "hourlyTokens", ",", "burst", ")", "\n", "c", ".", "throttle", ".", "lock", ".", "Lock", "(", ")", "\n", "defer", "c", ".", "throttle", ".", "lock", ".", "Unlock", "(", ")", "\n", "previouslyThrottled", ":=", "c", ".", "throttle", ".", "ticker", "!=", "nil", "\n", "if", "hourlyTokens", "<=", "0", "||", "burst", "<=", "0", "{", "// Disable throttle", "if", "previouslyThrottled", "{", "// Unwrap clients if necessary", "c", ".", "client", "=", "c", ".", "throttle", ".", "http", "\n", "c", ".", "gqlc", "=", "c", ".", "throttle", ".", "graph", "\n", "c", ".", "throttle", ".", "ticker", ".", "Stop", "(", ")", "\n", "c", ".", "throttle", ".", "ticker", "=", "nil", "\n", "}", "\n", "return", "\n", "}", "\n", "rate", ":=", "time", ".", "Hour", "/", "time", ".", "Duration", "(", "hourlyTokens", ")", "\n", "ticker", ":=", "time", ".", "NewTicker", "(", "rate", ")", "\n", "throttle", ":=", "make", "(", "chan", "time", ".", "Time", ",", "burst", ")", "\n", "for", "i", ":=", "0", ";", "i", "<", "burst", ";", "i", "++", "{", "// Fill up the channel", "throttle", "<-", "time", ".", "Now", "(", ")", "\n", "}", "\n", "go", "func", "(", ")", "{", "// Refill the channel", "for", "t", ":=", "range", "ticker", ".", "C", "{", "select", "{", "case", "throttle", "<-", "t", ":", "default", ":", "}", "\n", "}", "\n", "}", "(", ")", "\n", "if", "!", "previouslyThrottled", "{", "// Wrap clients if we haven't already", "c", ".", "throttle", ".", "http", "=", "c", ".", "client", "\n", "c", ".", "throttle", ".", "graph", "=", "c", ".", "gqlc", "\n", "c", ".", "client", "=", "&", "c", ".", "throttle", "\n", "c", ".", "gqlc", "=", "&", "c", ".", "throttle", "\n", "}", "\n", "c", ".", "throttle", ".", "ticker", "=", "ticker", "\n", "c", ".", "throttle", ".", "throttle", "=", "throttle", "\n", "}"], "docstring": "// Throttle client to a rate of at most hourlyTokens requests per hour,\n// allowing burst tokens.", "docstring_tokens": ["Throttle", "client", "to", "a", "rate", "of", "at", "most", "hourlyTokens", "requests", "per", "hour", "allowing", "burst", "tokens", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/github/client.go#L187-L224", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewAccountEntryExt", "original_string": "func NewAccountEntryExt(v int32, value interface{}) (result AccountEntryExt, err error) {\n\tresult.V = v\n\tswitch int32(v) {\n\tcase 0:\n\t\t// void\n\t}\n\treturn\n}", "language": "go", "code": "func NewAccountEntryExt(v int32, value interface{}) (result AccountEntryExt, err error) {\n\tresult.V = v\n\tswitch int32(v) {\n\tcase 0:\n\t\t// void\n\t}\n\treturn\n}", "code_tokens": ["func", "NewAccountEntryExt", "(", "v", "int32", ",", "value", "interface", "{", "}", ")", "(", "result", "AccountEntryExt", ",", "err", "error", ")", "{", "result", ".", "V", "=", "v", "\n", "switch", "int32", "(", "v", ")", "{", "case", "0", ":", "// void", "}", "\n", "return", "\n", "}"], "docstring": "// NewAccountEntryExt creates a new  AccountEntryExt.", "docstring_tokens": ["NewAccountEntryExt", "creates", "a", "new", "AccountEntryExt", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L699-L706", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "peer_heap.go", "func_name": "addPeer", "original_string": "func (ph *peerHeap) addPeer(peerScore *peerScore) {\n\tph.pushPeer(peerScore)\n\n\t// Pick a random element, and swap the order with that peerScore.\n\tr := ph.rng.Intn(ph.Len())\n\tph.swapOrder(peerScore.index, r)\n}", "language": "go", "code": "func (ph *peerHeap) addPeer(peerScore *peerScore) {\n\tph.pushPeer(peerScore)\n\n\t// Pick a random element, and swap the order with that peerScore.\n\tr := ph.rng.Intn(ph.Len())\n\tph.swapOrder(peerScore.index, r)\n}", "code_tokens": ["func", "(", "ph", "*", "peerHeap", ")", "addPeer", "(", "peerScore", "*", "peerScore", ")", "{", "ph", ".", "pushPeer", "(", "peerScore", ")", "\n\n", "// Pick a random element, and swap the order with that peerScore.", "r", ":=", "ph", ".", "rng", ".", "Intn", "(", "ph", ".", "Len", "(", ")", ")", "\n", "ph", ".", "swapOrder", "(", "peerScore", ".", "index", ",", "r", ")", "\n", "}"], "docstring": "// AddPeer adds a peer to the peer heap.", "docstring_tokens": ["AddPeer", "adds", "a", "peer", "to", "the", "peer", "heap", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/peer_heap.go#L111-L117", "partition": "test"}
{"repo": "armon/go-radix", "path": "radix.go", "func_name": "Get", "original_string": "func (t *Tree) Get(s string) (interface{}, bool) {\n\tn := t.root\n\tsearch := s\n\tfor {\n\t\t// Check for key exhaution\n\t\tif len(search) == 0 {\n\t\t\tif n.isLeaf() {\n\t\t\t\treturn n.leaf.val, true\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Look for an edge\n\t\tn = n.getEdge(search[0])\n\t\tif n == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Consume the search prefix\n\t\tif strings.HasPrefix(search, n.prefix) {\n\t\t\tsearch = search[len(n.prefix):]\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil, false\n}", "language": "go", "code": "func (t *Tree) Get(s string) (interface{}, bool) {\n\tn := t.root\n\tsearch := s\n\tfor {\n\t\t// Check for key exhaution\n\t\tif len(search) == 0 {\n\t\t\tif n.isLeaf() {\n\t\t\t\treturn n.leaf.val, true\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Look for an edge\n\t\tn = n.getEdge(search[0])\n\t\tif n == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// Consume the search prefix\n\t\tif strings.HasPrefix(search, n.prefix) {\n\t\t\tsearch = search[len(n.prefix):]\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil, false\n}", "code_tokens": ["func", "(", "t", "*", "Tree", ")", "Get", "(", "s", "string", ")", "(", "interface", "{", "}", ",", "bool", ")", "{", "n", ":=", "t", ".", "root", "\n", "search", ":=", "s", "\n", "for", "{", "// Check for key exhaution", "if", "len", "(", "search", ")", "==", "0", "{", "if", "n", ".", "isLeaf", "(", ")", "{", "return", "n", ".", "leaf", ".", "val", ",", "true", "\n", "}", "\n", "break", "\n", "}", "\n\n", "// Look for an edge", "n", "=", "n", ".", "getEdge", "(", "search", "[", "0", "]", ")", "\n", "if", "n", "==", "nil", "{", "break", "\n", "}", "\n\n", "// Consume the search prefix", "if", "strings", ".", "HasPrefix", "(", "search", ",", "n", ".", "prefix", ")", "{", "search", "=", "search", "[", "len", "(", "n", ".", "prefix", ")", ":", "]", "\n", "}", "else", "{", "break", "\n", "}", "\n", "}", "\n", "return", "nil", ",", "false", "\n", "}"], "docstring": "// Get is used to lookup a specific key, returning\n// the value and if it was found", "docstring_tokens": ["Get", "is", "used", "to", "lookup", "a", "specific", "key", "returning", "the", "value", "and", "if", "it", "was", "found"], "sha": "1a2de0c21c94309923825da3df33a4381872c795", "url": "https://github.com/armon/go-radix/blob/1a2de0c21c94309923825da3df33a4381872c795/radix.go#L349-L375", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/mergecommitblocker/mergecommitblocker.go", "func_name": "helpProvider", "original_string": "func helpProvider(config *plugins.Configuration, enabledRepos []string) (*pluginhelp.PluginHelp, error) {\n\t// Only the Description field is specified because this plugin is not triggered with commands and is not configurable.\n\treturn &pluginhelp.PluginHelp{\n\t\tDescription: fmt.Sprintf(\"The merge commit blocker plugin adds the %s label to pull requests that contain merge commits\", labels.MergeCommits),\n\t}, nil\n}", "language": "go", "code": "func helpProvider(config *plugins.Configuration, enabledRepos []string) (*pluginhelp.PluginHelp, error) {\n\t// Only the Description field is specified because this plugin is not triggered with commands and is not configurable.\n\treturn &pluginhelp.PluginHelp{\n\t\tDescription: fmt.Sprintf(\"The merge commit blocker plugin adds the %s label to pull requests that contain merge commits\", labels.MergeCommits),\n\t}, nil\n}", "code_tokens": ["func", "helpProvider", "(", "config", "*", "plugins", ".", "Configuration", ",", "enabledRepos", "[", "]", "string", ")", "(", "*", "pluginhelp", ".", "PluginHelp", ",", "error", ")", "{", "// Only the Description field is specified because this plugin is not triggered with commands and is not configurable.", "return", "&", "pluginhelp", ".", "PluginHelp", "{", "Description", ":", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "labels", ".", "MergeCommits", ")", ",", "}", ",", "nil", "\n", "}"], "docstring": "// helpProvider provides information on the plugin", "docstring_tokens": ["helpProvider", "provides", "information", "on", "the", "plugin"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/mergecommitblocker/mergecommitblocker.go#L48-L53", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/raft.go", "func_name": "tick", "original_string": "func (r *raftNode) tick() {\n\tr.tickMu.Lock()\n\tr.Tick()\n\tr.tickMu.Unlock()\n}", "language": "go", "code": "func (r *raftNode) tick() {\n\tr.tickMu.Lock()\n\tr.Tick()\n\tr.tickMu.Unlock()\n}", "code_tokens": ["func", "(", "r", "*", "raftNode", ")", "tick", "(", ")", "{", "r", ".", "tickMu", ".", "Lock", "(", ")", "\n", "r", ".", "Tick", "(", ")", "\n", "r", ".", "tickMu", ".", "Unlock", "(", ")", "\n", "}"], "docstring": "// raft.Node does not have locks in Raft package", "docstring_tokens": ["raft", ".", "Node", "does", "not", "have", "locks", "in", "Raft", "package"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/raft.go#L150-L154", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/pod-utils/downwardapi/jobspec.go", "func_name": "EnvForSpec", "original_string": "func EnvForSpec(spec JobSpec) (map[string]string, error) {\n\tenv := map[string]string{\n\t\tjobNameEnv:   spec.Job,\n\t\tbuildIDEnv:   spec.BuildID,\n\t\tprowJobIDEnv: spec.ProwJobID,\n\t\tjobTypeEnv:   string(spec.Type),\n\t}\n\n\t// for backwards compatibility, we provide the build ID\n\t// in both $BUILD_ID and $BUILD_NUMBER for Prow agents\n\t// and in both $buildId and $BUILD_NUMBER for Jenkins\n\tif spec.agent == prowapi.KubernetesAgent {\n\t\tenv[prowBuildIDEnv] = spec.BuildID\n\t}\n\n\traw, err := json.Marshal(spec)\n\tif err != nil {\n\t\treturn env, fmt.Errorf(\"failed to marshal job spec: %v\", err)\n\t}\n\tenv[JobSpecEnv] = string(raw)\n\n\tif spec.Type == prowapi.PeriodicJob {\n\t\treturn env, nil\n\t}\n\n\tenv[repoOwnerEnv] = spec.Refs.Org\n\tenv[repoNameEnv] = spec.Refs.Repo\n\tenv[pullBaseRefEnv] = spec.Refs.BaseRef\n\tenv[pullBaseShaEnv] = spec.Refs.BaseSHA\n\tenv[pullRefsEnv] = spec.Refs.String()\n\n\tif spec.Type == prowapi.PostsubmitJob || spec.Type == prowapi.BatchJob {\n\t\treturn env, nil\n\t}\n\n\tenv[pullNumberEnv] = strconv.Itoa(spec.Refs.Pulls[0].Number)\n\tenv[pullPullShaEnv] = spec.Refs.Pulls[0].SHA\n\treturn env, nil\n}", "language": "go", "code": "func EnvForSpec(spec JobSpec) (map[string]string, error) {\n\tenv := map[string]string{\n\t\tjobNameEnv:   spec.Job,\n\t\tbuildIDEnv:   spec.BuildID,\n\t\tprowJobIDEnv: spec.ProwJobID,\n\t\tjobTypeEnv:   string(spec.Type),\n\t}\n\n\t// for backwards compatibility, we provide the build ID\n\t// in both $BUILD_ID and $BUILD_NUMBER for Prow agents\n\t// and in both $buildId and $BUILD_NUMBER for Jenkins\n\tif spec.agent == prowapi.KubernetesAgent {\n\t\tenv[prowBuildIDEnv] = spec.BuildID\n\t}\n\n\traw, err := json.Marshal(spec)\n\tif err != nil {\n\t\treturn env, fmt.Errorf(\"failed to marshal job spec: %v\", err)\n\t}\n\tenv[JobSpecEnv] = string(raw)\n\n\tif spec.Type == prowapi.PeriodicJob {\n\t\treturn env, nil\n\t}\n\n\tenv[repoOwnerEnv] = spec.Refs.Org\n\tenv[repoNameEnv] = spec.Refs.Repo\n\tenv[pullBaseRefEnv] = spec.Refs.BaseRef\n\tenv[pullBaseShaEnv] = spec.Refs.BaseSHA\n\tenv[pullRefsEnv] = spec.Refs.String()\n\n\tif spec.Type == prowapi.PostsubmitJob || spec.Type == prowapi.BatchJob {\n\t\treturn env, nil\n\t}\n\n\tenv[pullNumberEnv] = strconv.Itoa(spec.Refs.Pulls[0].Number)\n\tenv[pullPullShaEnv] = spec.Refs.Pulls[0].SHA\n\treturn env, nil\n}", "code_tokens": ["func", "EnvForSpec", "(", "spec", "JobSpec", ")", "(", "map", "[", "string", "]", "string", ",", "error", ")", "{", "env", ":=", "map", "[", "string", "]", "string", "{", "jobNameEnv", ":", "spec", ".", "Job", ",", "buildIDEnv", ":", "spec", ".", "BuildID", ",", "prowJobIDEnv", ":", "spec", ".", "ProwJobID", ",", "jobTypeEnv", ":", "string", "(", "spec", ".", "Type", ")", ",", "}", "\n\n", "// for backwards compatibility, we provide the build ID", "// in both $BUILD_ID and $BUILD_NUMBER for Prow agents", "// and in both $buildId and $BUILD_NUMBER for Jenkins", "if", "spec", ".", "agent", "==", "prowapi", ".", "KubernetesAgent", "{", "env", "[", "prowBuildIDEnv", "]", "=", "spec", ".", "BuildID", "\n", "}", "\n\n", "raw", ",", "err", ":=", "json", ".", "Marshal", "(", "spec", ")", "\n", "if", "err", "!=", "nil", "{", "return", "env", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "env", "[", "JobSpecEnv", "]", "=", "string", "(", "raw", ")", "\n\n", "if", "spec", ".", "Type", "==", "prowapi", ".", "PeriodicJob", "{", "return", "env", ",", "nil", "\n", "}", "\n\n", "env", "[", "repoOwnerEnv", "]", "=", "spec", ".", "Refs", ".", "Org", "\n", "env", "[", "repoNameEnv", "]", "=", "spec", ".", "Refs", ".", "Repo", "\n", "env", "[", "pullBaseRefEnv", "]", "=", "spec", ".", "Refs", ".", "BaseRef", "\n", "env", "[", "pullBaseShaEnv", "]", "=", "spec", ".", "Refs", ".", "BaseSHA", "\n", "env", "[", "pullRefsEnv", "]", "=", "spec", ".", "Refs", ".", "String", "(", ")", "\n\n", "if", "spec", ".", "Type", "==", "prowapi", ".", "PostsubmitJob", "||", "spec", ".", "Type", "==", "prowapi", ".", "BatchJob", "{", "return", "env", ",", "nil", "\n", "}", "\n\n", "env", "[", "pullNumberEnv", "]", "=", "strconv", ".", "Itoa", "(", "spec", ".", "Refs", ".", "Pulls", "[", "0", "]", ".", "Number", ")", "\n", "env", "[", "pullPullShaEnv", "]", "=", "spec", ".", "Refs", ".", "Pulls", "[", "0", "]", ".", "SHA", "\n", "return", "env", ",", "nil", "\n", "}"], "docstring": "// EnvForSpec returns a mapping of environment variables\n// to their values that should be available for a job spec", "docstring_tokens": ["EnvForSpec", "returns", "a", "mapping", "of", "environment", "variables", "to", "their", "values", "that", "should", "be", "available", "for", "a", "job", "spec"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pod-utils/downwardapi/jobspec.go#L100-L138", "partition": "test"}
{"repo": "nwaples/rardecode", "path": "filters.go", "func_name": "getV3Filter", "original_string": "func getV3Filter(code []byte) (v3Filter, error) {\n\t// check if filter is a known standard filter\n\tc := crc32.ChecksumIEEE(code)\n\tfor _, f := range standardV3Filters {\n\t\tif f.crc == c && f.len == len(code) {\n\t\t\treturn f.f, nil\n\t\t}\n\t}\n\n\t// create new vm filter\n\tf := new(vmFilter)\n\tr := newRarBitReader(bytes.NewReader(code[1:])) // skip first xor byte check\n\n\t// read static data\n\tn, err := r.readBits(1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif n > 0 {\n\t\tm, err := r.readUint32()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tf.static = make([]byte, m+1)\n\t\terr = r.readFull(f.static)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tf.code, err = readCommands(r)\n\tif err == io.EOF {\n\t\terr = nil\n\t}\n\n\treturn f.execute, err\n}", "language": "go", "code": "func getV3Filter(code []byte) (v3Filter, error) {\n\t// check if filter is a known standard filter\n\tc := crc32.ChecksumIEEE(code)\n\tfor _, f := range standardV3Filters {\n\t\tif f.crc == c && f.len == len(code) {\n\t\t\treturn f.f, nil\n\t\t}\n\t}\n\n\t// create new vm filter\n\tf := new(vmFilter)\n\tr := newRarBitReader(bytes.NewReader(code[1:])) // skip first xor byte check\n\n\t// read static data\n\tn, err := r.readBits(1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif n > 0 {\n\t\tm, err := r.readUint32()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tf.static = make([]byte, m+1)\n\t\terr = r.readFull(f.static)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tf.code, err = readCommands(r)\n\tif err == io.EOF {\n\t\terr = nil\n\t}\n\n\treturn f.execute, err\n}", "code_tokens": ["func", "getV3Filter", "(", "code", "[", "]", "byte", ")", "(", "v3Filter", ",", "error", ")", "{", "// check if filter is a known standard filter", "c", ":=", "crc32", ".", "ChecksumIEEE", "(", "code", ")", "\n", "for", "_", ",", "f", ":=", "range", "standardV3Filters", "{", "if", "f", ".", "crc", "==", "c", "&&", "f", ".", "len", "==", "len", "(", "code", ")", "{", "return", "f", ".", "f", ",", "nil", "\n", "}", "\n", "}", "\n\n", "// create new vm filter", "f", ":=", "new", "(", "vmFilter", ")", "\n", "r", ":=", "newRarBitReader", "(", "bytes", ".", "NewReader", "(", "code", "[", "1", ":", "]", ")", ")", "// skip first xor byte check", "\n\n", "// read static data", "n", ",", "err", ":=", "r", ".", "readBits", "(", "1", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "n", ">", "0", "{", "m", ",", "err", ":=", "r", ".", "readUint32", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "f", ".", "static", "=", "make", "(", "[", "]", "byte", ",", "m", "+", "1", ")", "\n", "err", "=", "r", ".", "readFull", "(", "f", ".", "static", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "}", "\n\n", "f", ".", "code", ",", "err", "=", "readCommands", "(", "r", ")", "\n", "if", "err", "==", "io", ".", "EOF", "{", "err", "=", "nil", "\n", "}", "\n\n", "return", "f", ".", "execute", ",", "err", "\n", "}"], "docstring": "// getV3Filter returns a V3 filter function from a code byte slice.", "docstring_tokens": ["getV3Filter", "returns", "a", "V3", "filter", "function", "from", "a", "code", "byte", "slice", "."], "sha": "197ef08ef68c4454ae5970a9c2692d6056ceb8d7", "url": "https://github.com/nwaples/rardecode/blob/197ef08ef68c4454ae5970a9c2692d6056ceb8d7/filters.go#L380-L416", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "_metcd/etcd_store.go", "func_name": "applyCompare", "original_string": "func applyCompare(kv mvcc.KV, c *etcdserverpb.Compare) (int64, bool) {\n\tckvs, rev, err := kv.Range(c.Key, nil, 1, 0)\n\tif err != nil {\n\t\tif err == mvcc.ErrTxnIDMismatch {\n\t\t\tpanic(\"unexpected txn ID mismatch error\")\n\t\t}\n\t\treturn rev, false\n\t}\n\tvar ckv mvccpb.KeyValue\n\tif len(ckvs) != 0 {\n\t\tckv = ckvs[0]\n\t} else {\n\t\t// Use the zero value of ckv normally. However...\n\t\tif c.Target == etcdserverpb.Compare_VALUE {\n\t\t\t// Always fail if we're comparing a value on a key that doesn't exist.\n\t\t\t// We can treat non-existence as the empty set explicitly, such that\n\t\t\t// even a key with a value of length 0 bytes is still a real key\n\t\t\t// that was written that way\n\t\t\treturn rev, false\n\t\t}\n\t}\n\n\t// -1 is less, 0 is equal, 1 is greater\n\tvar result int\n\tswitch c.Target {\n\tcase etcdserverpb.Compare_VALUE:\n\t\ttv, _ := c.TargetUnion.(*etcdserverpb.Compare_Value)\n\t\tif tv != nil {\n\t\t\tresult = bytes.Compare(ckv.Value, tv.Value)\n\t\t}\n\tcase etcdserverpb.Compare_CREATE:\n\t\ttv, _ := c.TargetUnion.(*etcdserverpb.Compare_CreateRevision)\n\t\tif tv != nil {\n\t\t\tresult = compareInt64(ckv.CreateRevision, tv.CreateRevision)\n\t\t}\n\n\tcase etcdserverpb.Compare_MOD:\n\t\ttv, _ := c.TargetUnion.(*etcdserverpb.Compare_ModRevision)\n\t\tif tv != nil {\n\t\t\tresult = compareInt64(ckv.ModRevision, tv.ModRevision)\n\t\t}\n\tcase etcdserverpb.Compare_VERSION:\n\t\ttv, _ := c.TargetUnion.(*etcdserverpb.Compare_Version)\n\t\tif tv != nil {\n\t\t\tresult = compareInt64(ckv.Version, tv.Version)\n\t\t}\n\t}\n\n\tswitch c.Result {\n\tcase etcdserverpb.Compare_EQUAL:\n\t\tif result != 0 {\n\t\t\treturn rev, false\n\t\t}\n\tcase etcdserverpb.Compare_GREATER:\n\t\tif result != 1 {\n\t\t\treturn rev, false\n\t\t}\n\tcase etcdserverpb.Compare_LESS:\n\t\tif result != -1 {\n\t\t\treturn rev, false\n\t\t}\n\t}\n\treturn rev, true\n}", "language": "go", "code": "func applyCompare(kv mvcc.KV, c *etcdserverpb.Compare) (int64, bool) {\n\tckvs, rev, err := kv.Range(c.Key, nil, 1, 0)\n\tif err != nil {\n\t\tif err == mvcc.ErrTxnIDMismatch {\n\t\t\tpanic(\"unexpected txn ID mismatch error\")\n\t\t}\n\t\treturn rev, false\n\t}\n\tvar ckv mvccpb.KeyValue\n\tif len(ckvs) != 0 {\n\t\tckv = ckvs[0]\n\t} else {\n\t\t// Use the zero value of ckv normally. However...\n\t\tif c.Target == etcdserverpb.Compare_VALUE {\n\t\t\t// Always fail if we're comparing a value on a key that doesn't exist.\n\t\t\t// We can treat non-existence as the empty set explicitly, such that\n\t\t\t// even a key with a value of length 0 bytes is still a real key\n\t\t\t// that was written that way\n\t\t\treturn rev, false\n\t\t}\n\t}\n\n\t// -1 is less, 0 is equal, 1 is greater\n\tvar result int\n\tswitch c.Target {\n\tcase etcdserverpb.Compare_VALUE:\n\t\ttv, _ := c.TargetUnion.(*etcdserverpb.Compare_Value)\n\t\tif tv != nil {\n\t\t\tresult = bytes.Compare(ckv.Value, tv.Value)\n\t\t}\n\tcase etcdserverpb.Compare_CREATE:\n\t\ttv, _ := c.TargetUnion.(*etcdserverpb.Compare_CreateRevision)\n\t\tif tv != nil {\n\t\t\tresult = compareInt64(ckv.CreateRevision, tv.CreateRevision)\n\t\t}\n\n\tcase etcdserverpb.Compare_MOD:\n\t\ttv, _ := c.TargetUnion.(*etcdserverpb.Compare_ModRevision)\n\t\tif tv != nil {\n\t\t\tresult = compareInt64(ckv.ModRevision, tv.ModRevision)\n\t\t}\n\tcase etcdserverpb.Compare_VERSION:\n\t\ttv, _ := c.TargetUnion.(*etcdserverpb.Compare_Version)\n\t\tif tv != nil {\n\t\t\tresult = compareInt64(ckv.Version, tv.Version)\n\t\t}\n\t}\n\n\tswitch c.Result {\n\tcase etcdserverpb.Compare_EQUAL:\n\t\tif result != 0 {\n\t\t\treturn rev, false\n\t\t}\n\tcase etcdserverpb.Compare_GREATER:\n\t\tif result != 1 {\n\t\t\treturn rev, false\n\t\t}\n\tcase etcdserverpb.Compare_LESS:\n\t\tif result != -1 {\n\t\t\treturn rev, false\n\t\t}\n\t}\n\treturn rev, true\n}", "code_tokens": ["func", "applyCompare", "(", "kv", "mvcc", ".", "KV", ",", "c", "*", "etcdserverpb", ".", "Compare", ")", "(", "int64", ",", "bool", ")", "{", "ckvs", ",", "rev", ",", "err", ":=", "kv", ".", "Range", "(", "c", ".", "Key", ",", "nil", ",", "1", ",", "0", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", "==", "mvcc", ".", "ErrTxnIDMismatch", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "rev", ",", "false", "\n", "}", "\n", "var", "ckv", "mvccpb", ".", "KeyValue", "\n", "if", "len", "(", "ckvs", ")", "!=", "0", "{", "ckv", "=", "ckvs", "[", "0", "]", "\n", "}", "else", "{", "// Use the zero value of ckv normally. However...", "if", "c", ".", "Target", "==", "etcdserverpb", ".", "Compare_VALUE", "{", "// Always fail if we're comparing a value on a key that doesn't exist.", "// We can treat non-existence as the empty set explicitly, such that", "// even a key with a value of length 0 bytes is still a real key", "// that was written that way", "return", "rev", ",", "false", "\n", "}", "\n", "}", "\n\n", "// -1 is less, 0 is equal, 1 is greater", "var", "result", "int", "\n", "switch", "c", ".", "Target", "{", "case", "etcdserverpb", ".", "Compare_VALUE", ":", "tv", ",", "_", ":=", "c", ".", "TargetUnion", ".", "(", "*", "etcdserverpb", ".", "Compare_Value", ")", "\n", "if", "tv", "!=", "nil", "{", "result", "=", "bytes", ".", "Compare", "(", "ckv", ".", "Value", ",", "tv", ".", "Value", ")", "\n", "}", "\n", "case", "etcdserverpb", ".", "Compare_CREATE", ":", "tv", ",", "_", ":=", "c", ".", "TargetUnion", ".", "(", "*", "etcdserverpb", ".", "Compare_CreateRevision", ")", "\n", "if", "tv", "!=", "nil", "{", "result", "=", "compareInt64", "(", "ckv", ".", "CreateRevision", ",", "tv", ".", "CreateRevision", ")", "\n", "}", "\n\n", "case", "etcdserverpb", ".", "Compare_MOD", ":", "tv", ",", "_", ":=", "c", ".", "TargetUnion", ".", "(", "*", "etcdserverpb", ".", "Compare_ModRevision", ")", "\n", "if", "tv", "!=", "nil", "{", "result", "=", "compareInt64", "(", "ckv", ".", "ModRevision", ",", "tv", ".", "ModRevision", ")", "\n", "}", "\n", "case", "etcdserverpb", ".", "Compare_VERSION", ":", "tv", ",", "_", ":=", "c", ".", "TargetUnion", ".", "(", "*", "etcdserverpb", ".", "Compare_Version", ")", "\n", "if", "tv", "!=", "nil", "{", "result", "=", "compareInt64", "(", "ckv", ".", "Version", ",", "tv", ".", "Version", ")", "\n", "}", "\n", "}", "\n\n", "switch", "c", ".", "Result", "{", "case", "etcdserverpb", ".", "Compare_EQUAL", ":", "if", "result", "!=", "0", "{", "return", "rev", ",", "false", "\n", "}", "\n", "case", "etcdserverpb", ".", "Compare_GREATER", ":", "if", "result", "!=", "1", "{", "return", "rev", ",", "false", "\n", "}", "\n", "case", "etcdserverpb", ".", "Compare_LESS", ":", "if", "result", "!=", "-", "1", "{", "return", "rev", ",", "false", "\n", "}", "\n", "}", "\n", "return", "rev", ",", "true", "\n", "}"], "docstring": "// applyCompare applies the compare request.\n// It returns the revision at which the comparison happens. If the comparison\n// succeeds, the it returns true. Otherwise it returns false.", "docstring_tokens": ["applyCompare", "applies", "the", "compare", "request", ".", "It", "returns", "the", "revision", "at", "which", "the", "comparison", "happens", ".", "If", "the", "comparison", "succeeds", "the", "it", "returns", "true", ".", "Otherwise", "it", "returns", "false", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/_metcd/etcd_store.go#L712-L775", "partition": "test"}
{"repo": "kr/s3", "path": "sign.go", "func_name": "Sign", "original_string": "func (s *Service) Sign(r *http.Request, k Keys) {\n\tif k.SecurityToken != \"\" {\n\t\tr.Header.Set(\"X-Amz-Security-Token\", k.SecurityToken)\n\t}\n\th := hmac.New(sha1.New, []byte(k.SecretKey))\n\ts.writeSigData(h, r)\n\tsig := make([]byte, base64.StdEncoding.EncodedLen(h.Size()))\n\tbase64.StdEncoding.Encode(sig, h.Sum(nil))\n\tr.Header.Set(\"Authorization\", \"AWS \"+k.AccessKey+\":\"+string(sig))\n}", "language": "go", "code": "func (s *Service) Sign(r *http.Request, k Keys) {\n\tif k.SecurityToken != \"\" {\n\t\tr.Header.Set(\"X-Amz-Security-Token\", k.SecurityToken)\n\t}\n\th := hmac.New(sha1.New, []byte(k.SecretKey))\n\ts.writeSigData(h, r)\n\tsig := make([]byte, base64.StdEncoding.EncodedLen(h.Size()))\n\tbase64.StdEncoding.Encode(sig, h.Sum(nil))\n\tr.Header.Set(\"Authorization\", \"AWS \"+k.AccessKey+\":\"+string(sig))\n}", "code_tokens": ["func", "(", "s", "*", "Service", ")", "Sign", "(", "r", "*", "http", ".", "Request", ",", "k", "Keys", ")", "{", "if", "k", ".", "SecurityToken", "!=", "\"", "\"", "{", "r", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "k", ".", "SecurityToken", ")", "\n", "}", "\n", "h", ":=", "hmac", ".", "New", "(", "sha1", ".", "New", ",", "[", "]", "byte", "(", "k", ".", "SecretKey", ")", ")", "\n", "s", ".", "writeSigData", "(", "h", ",", "r", ")", "\n", "sig", ":=", "make", "(", "[", "]", "byte", ",", "base64", ".", "StdEncoding", ".", "EncodedLen", "(", "h", ".", "Size", "(", ")", ")", ")", "\n", "base64", ".", "StdEncoding", ".", "Encode", "(", "sig", ",", "h", ".", "Sum", "(", "nil", ")", ")", "\n", "r", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", "+", "k", ".", "AccessKey", "+", "\"", "\"", "+", "string", "(", "sig", ")", ")", "\n", "}"], "docstring": "// Sign signs an HTTP request with the given S3 keys for use on service s.", "docstring_tokens": ["Sign", "signs", "an", "HTTP", "request", "with", "the", "given", "S3", "keys", "for", "use", "on", "service", "s", "."], "sha": "c070c8f9a8f0032d48f0d2a77d4e382788bd8a1d", "url": "https://github.com/kr/s3/blob/c070c8f9a8f0032d48f0d2a77d4e382788bd8a1d/sign.go#L98-L107", "partition": "test"}
{"repo": "fcavani/text", "path": "validation.go", "func_name": "CheckPassword", "original_string": "func CheckPassword(pass string, min, max int) error {\n\tif len(pass) < min || len(pass) > max {\n\t\treturn e.New(ErrInvalidPassLength)\n\t}\n\tfor _, r := range pass {\n\t\tif !unicode.IsGraphic(r) {\n\t\t\treturn e.New(ErrInvalidPassChar)\n\t\t}\n\t}\n\treturn nil\n}", "language": "go", "code": "func CheckPassword(pass string, min, max int) error {\n\tif len(pass) < min || len(pass) > max {\n\t\treturn e.New(ErrInvalidPassLength)\n\t}\n\tfor _, r := range pass {\n\t\tif !unicode.IsGraphic(r) {\n\t\t\treturn e.New(ErrInvalidPassChar)\n\t\t}\n\t}\n\treturn nil\n}", "code_tokens": ["func", "CheckPassword", "(", "pass", "string", ",", "min", ",", "max", "int", ")", "error", "{", "if", "len", "(", "pass", ")", "<", "min", "||", "len", "(", "pass", ")", ">", "max", "{", "return", "e", ".", "New", "(", "ErrInvalidPassLength", ")", "\n", "}", "\n", "for", "_", ",", "r", ":=", "range", "pass", "{", "if", "!", "unicode", ".", "IsGraphic", "(", "r", ")", "{", "return", "e", ".", "New", "(", "ErrInvalidPassChar", ")", "\n", "}", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// Check the user password. Graphics character are allowed. See unicode.IsGraphic.", "docstring_tokens": ["Check", "the", "user", "password", ".", "Graphics", "character", "are", "allowed", ".", "See", "unicode", ".", "IsGraphic", "."], "sha": "023e76809b57fc8cfc80c855ba59537720821cb5", "url": "https://github.com/fcavani/text/blob/023e76809b57fc8cfc80c855ba59537720821cb5/validation.go#L84-L94", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/gcsupload/options.go", "func_name": "Validate", "original_string": "func (o *Options) Validate() error {\n\tif o.gcsPath.String() != \"\" {\n\t\to.Bucket = o.gcsPath.Bucket()\n\t\to.PathPrefix = o.gcsPath.Object()\n\t}\n\n\tif !o.DryRun {\n\t\tif o.Bucket == \"\" {\n\t\t\treturn errors.New(\"GCS upload was requested no GCS bucket was provided\")\n\t\t}\n\n\t\tif o.GcsCredentialsFile == \"\" {\n\t\t\treturn errors.New(\"GCS upload was requested but no GCS credentials file was provided\")\n\t\t}\n\t}\n\n\treturn o.GCSConfiguration.Validate()\n}", "language": "go", "code": "func (o *Options) Validate() error {\n\tif o.gcsPath.String() != \"\" {\n\t\to.Bucket = o.gcsPath.Bucket()\n\t\to.PathPrefix = o.gcsPath.Object()\n\t}\n\n\tif !o.DryRun {\n\t\tif o.Bucket == \"\" {\n\t\t\treturn errors.New(\"GCS upload was requested no GCS bucket was provided\")\n\t\t}\n\n\t\tif o.GcsCredentialsFile == \"\" {\n\t\t\treturn errors.New(\"GCS upload was requested but no GCS credentials file was provided\")\n\t\t}\n\t}\n\n\treturn o.GCSConfiguration.Validate()\n}", "code_tokens": ["func", "(", "o", "*", "Options", ")", "Validate", "(", ")", "error", "{", "if", "o", ".", "gcsPath", ".", "String", "(", ")", "!=", "\"", "\"", "{", "o", ".", "Bucket", "=", "o", ".", "gcsPath", ".", "Bucket", "(", ")", "\n", "o", ".", "PathPrefix", "=", "o", ".", "gcsPath", ".", "Object", "(", ")", "\n", "}", "\n\n", "if", "!", "o", ".", "DryRun", "{", "if", "o", ".", "Bucket", "==", "\"", "\"", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n\n", "if", "o", ".", "GcsCredentialsFile", "==", "\"", "\"", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "}", "\n\n", "return", "o", ".", "GCSConfiguration", ".", "Validate", "(", ")", "\n", "}"], "docstring": "// Validate ensures that the set of options are\n// self-consistent and valid.", "docstring_tokens": ["Validate", "ensures", "that", "the", "set", "of", "options", "are", "self", "-", "consistent", "and", "valid", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/gcsupload/options.go#L59-L76", "partition": "test"}
{"repo": "VividCortex/ewma", "path": "ewma.go", "func_name": "Set", "original_string": "func (e *VariableEWMA) Set(value float64) {\n\te.value = value\n\tif e.count <= WARMUP_SAMPLES {\n\t\te.count = WARMUP_SAMPLES + 1\n\t}\n}", "language": "go", "code": "func (e *VariableEWMA) Set(value float64) {\n\te.value = value\n\tif e.count <= WARMUP_SAMPLES {\n\t\te.count = WARMUP_SAMPLES + 1\n\t}\n}", "code_tokens": ["func", "(", "e", "*", "VariableEWMA", ")", "Set", "(", "value", "float64", ")", "{", "e", ".", "value", "=", "value", "\n", "if", "e", ".", "count", "<=", "WARMUP_SAMPLES", "{", "e", ".", "count", "=", "WARMUP_SAMPLES", "+", "1", "\n", "}", "\n", "}"], "docstring": "// Set sets the EWMA's value.", "docstring_tokens": ["Set", "sets", "the", "EWMA", "s", "value", "."], "sha": "43880d236f695d39c62cf7aa4ebd4508c258e6c0", "url": "https://github.com/VividCortex/ewma/blob/43880d236f695d39c62cf7aa4ebd4508c258e6c0/ewma.go#L121-L126", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "table/iterator.go", "func_name": "Next", "original_string": "func (s *ConcatIterator) Next() {\n\ts.cur.Next()\n\tif s.cur.Valid() {\n\t\t// Nothing to do. Just stay with the current table.\n\t\treturn\n\t}\n\tfor { // In case there are empty tables.\n\t\tif !s.reversed {\n\t\t\ts.setIdx(s.idx + 1)\n\t\t} else {\n\t\t\ts.setIdx(s.idx - 1)\n\t\t}\n\t\tif s.cur == nil {\n\t\t\t// End of list. Valid will become false.\n\t\t\treturn\n\t\t}\n\t\ts.cur.Rewind()\n\t\tif s.cur.Valid() {\n\t\t\tbreak\n\t\t}\n\t}\n}", "language": "go", "code": "func (s *ConcatIterator) Next() {\n\ts.cur.Next()\n\tif s.cur.Valid() {\n\t\t// Nothing to do. Just stay with the current table.\n\t\treturn\n\t}\n\tfor { // In case there are empty tables.\n\t\tif !s.reversed {\n\t\t\ts.setIdx(s.idx + 1)\n\t\t} else {\n\t\t\ts.setIdx(s.idx - 1)\n\t\t}\n\t\tif s.cur == nil {\n\t\t\t// End of list. Valid will become false.\n\t\t\treturn\n\t\t}\n\t\ts.cur.Rewind()\n\t\tif s.cur.Valid() {\n\t\t\tbreak\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "ConcatIterator", ")", "Next", "(", ")", "{", "s", ".", "cur", ".", "Next", "(", ")", "\n", "if", "s", ".", "cur", ".", "Valid", "(", ")", "{", "// Nothing to do. Just stay with the current table.", "return", "\n", "}", "\n", "for", "{", "// In case there are empty tables.", "if", "!", "s", ".", "reversed", "{", "s", ".", "setIdx", "(", "s", ".", "idx", "+", "1", ")", "\n", "}", "else", "{", "s", ".", "setIdx", "(", "s", ".", "idx", "-", "1", ")", "\n", "}", "\n", "if", "s", ".", "cur", "==", "nil", "{", "// End of list. Valid will become false.", "return", "\n", "}", "\n", "s", ".", "cur", ".", "Rewind", "(", ")", "\n", "if", "s", ".", "cur", ".", "Valid", "(", ")", "{", "break", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// Next advances our concat iterator.", "docstring_tokens": ["Next", "advances", "our", "concat", "iterator", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/table/iterator.go#L508-L529", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "reqres.go", "func_name": "arg2Reader", "original_string": "func (r *reqResReader) arg2Reader() (ArgReader, error) {\n\treturn r.argReader(false /* last */, reqResReaderPreArg2, reqResReaderPreArg3)\n}", "language": "go", "code": "func (r *reqResReader) arg2Reader() (ArgReader, error) {\n\treturn r.argReader(false /* last */, reqResReaderPreArg2, reqResReaderPreArg3)\n}", "code_tokens": ["func", "(", "r", "*", "reqResReader", ")", "arg2Reader", "(", ")", "(", "ArgReader", ",", "error", ")", "{", "return", "r", ".", "argReader", "(", "false", "/* last */", ",", "reqResReaderPreArg2", ",", "reqResReaderPreArg3", ")", "\n", "}"], "docstring": "// arg2Reader returns an ArgReader to read arg2.", "docstring_tokens": ["arg2Reader", "returns", "an", "ArgReader", "to", "read", "arg2", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/reqres.go#L200-L202", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "repository/repository.go", "func_name": "Register", "original_string": "func Register(name string, manager RepositoryManager) {\n\tif managers == nil {\n\t\tmanagers = make(map[string]RepositoryManager)\n\t}\n\tmanagers[name] = manager\n}", "language": "go", "code": "func Register(name string, manager RepositoryManager) {\n\tif managers == nil {\n\t\tmanagers = make(map[string]RepositoryManager)\n\t}\n\tmanagers[name] = manager\n}", "code_tokens": ["func", "Register", "(", "name", "string", ",", "manager", "RepositoryManager", ")", "{", "if", "managers", "==", "nil", "{", "managers", "=", "make", "(", "map", "[", "string", "]", "RepositoryManager", ")", "\n", "}", "\n", "managers", "[", "name", "]", "=", "manager", "\n", "}"], "docstring": "// Register registers a new repository manager, that can be later configured\n// and used.", "docstring_tokens": ["Register", "registers", "a", "new", "repository", "manager", "that", "can", "be", "later", "configured", "and", "used", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/repository/repository.go#L81-L86", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/flagutil/kubernetes_cluster_clients.go", "func_name": "ProwJobClient", "original_string": "func (o *ExperimentalKubernetesOptions) ProwJobClient(namespace string, dryRun bool) (prowJobClient prowv1.ProwJobInterface, err error) {\n\tif err := o.resolve(dryRun); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif o.dryRun {\n\t\treturn kube.NewDryRunProwJobClient(o.DeckURI), nil\n\t}\n\n\treturn o.prowJobClientset.ProwV1().ProwJobs(namespace), nil\n}", "language": "go", "code": "func (o *ExperimentalKubernetesOptions) ProwJobClient(namespace string, dryRun bool) (prowJobClient prowv1.ProwJobInterface, err error) {\n\tif err := o.resolve(dryRun); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif o.dryRun {\n\t\treturn kube.NewDryRunProwJobClient(o.DeckURI), nil\n\t}\n\n\treturn o.prowJobClientset.ProwV1().ProwJobs(namespace), nil\n}", "code_tokens": ["func", "(", "o", "*", "ExperimentalKubernetesOptions", ")", "ProwJobClient", "(", "namespace", "string", ",", "dryRun", "bool", ")", "(", "prowJobClient", "prowv1", ".", "ProwJobInterface", ",", "err", "error", ")", "{", "if", "err", ":=", "o", ".", "resolve", "(", "dryRun", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "if", "o", ".", "dryRun", "{", "return", "kube", ".", "NewDryRunProwJobClient", "(", "o", ".", "DeckURI", ")", ",", "nil", "\n", "}", "\n\n", "return", "o", ".", "prowJobClientset", ".", "ProwV1", "(", ")", ".", "ProwJobs", "(", "namespace", ")", ",", "nil", "\n", "}"], "docstring": "// ProwJobClient returns a ProwJob client.", "docstring_tokens": ["ProwJobClient", "returns", "a", "ProwJob", "client", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/flagutil/kubernetes_cluster_clients.go#L133-L143", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "MustUpdated", "original_string": "func (u LedgerEntryChange) MustUpdated() LedgerEntry {\n\tval, ok := u.GetUpdated()\n\n\tif !ok {\n\t\tpanic(\"arm Updated is not set\")\n\t}\n\n\treturn val\n}", "language": "go", "code": "func (u LedgerEntryChange) MustUpdated() LedgerEntry {\n\tval, ok := u.GetUpdated()\n\n\tif !ok {\n\t\tpanic(\"arm Updated is not set\")\n\t}\n\n\treturn val\n}", "code_tokens": ["func", "(", "u", "LedgerEntryChange", ")", "MustUpdated", "(", ")", "LedgerEntry", "{", "val", ",", "ok", ":=", "u", ".", "GetUpdated", "(", ")", "\n\n", "if", "!", "ok", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "val", "\n", "}"], "docstring": "// MustUpdated retrieves the Updated value from the union,\n// panicing if the value is not set.", "docstring_tokens": ["MustUpdated", "retrieves", "the", "Updated", "value", "from", "the", "union", "panicing", "if", "the", "value", "is", "not", "set", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L5769-L5777", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/admin.go", "func_name": "ExtractPipeline", "original_string": "func (c APIClient) ExtractPipeline(pipelineName string) (*pps.CreatePipelineRequest, error) {\n\top, err := c.AdminAPIClient.ExtractPipeline(c.Ctx(), &admin.ExtractPipelineRequest{Pipeline: NewPipeline(pipelineName)})\n\tif err != nil {\n\t\treturn nil, grpcutil.ScrubGRPC(err)\n\t}\n\tif op.Op1_9 == nil || op.Op1_9.Pipeline == nil {\n\t\treturn nil, fmt.Errorf(\"malformed response is missing pipeline\")\n\t}\n\treturn op.Op1_9.Pipeline, nil\n}", "language": "go", "code": "func (c APIClient) ExtractPipeline(pipelineName string) (*pps.CreatePipelineRequest, error) {\n\top, err := c.AdminAPIClient.ExtractPipeline(c.Ctx(), &admin.ExtractPipelineRequest{Pipeline: NewPipeline(pipelineName)})\n\tif err != nil {\n\t\treturn nil, grpcutil.ScrubGRPC(err)\n\t}\n\tif op.Op1_9 == nil || op.Op1_9.Pipeline == nil {\n\t\treturn nil, fmt.Errorf(\"malformed response is missing pipeline\")\n\t}\n\treturn op.Op1_9.Pipeline, nil\n}", "code_tokens": ["func", "(", "c", "APIClient", ")", "ExtractPipeline", "(", "pipelineName", "string", ")", "(", "*", "pps", ".", "CreatePipelineRequest", ",", "error", ")", "{", "op", ",", "err", ":=", "c", ".", "AdminAPIClient", ".", "ExtractPipeline", "(", "c", ".", "Ctx", "(", ")", ",", "&", "admin", ".", "ExtractPipelineRequest", "{", "Pipeline", ":", "NewPipeline", "(", "pipelineName", ")", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}", "\n", "if", "op", ".", "Op1_9", "==", "nil", "||", "op", ".", "Op1_9", ".", "Pipeline", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "op", ".", "Op1_9", ".", "Pipeline", ",", "nil", "\n", "}"], "docstring": "// ExtractPipeline extracts a single pipeline.", "docstring_tokens": ["ExtractPipeline", "extracts", "a", "single", "pipeline", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/admin.go#L82-L91", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/flags/strings.go", "func_name": "Set", "original_string": "func (ss *StringsValue) Set(s string) error {\n\t*ss = strings.Split(s, \",\")\n\treturn nil\n}", "language": "go", "code": "func (ss *StringsValue) Set(s string) error {\n\t*ss = strings.Split(s, \",\")\n\treturn nil\n}", "code_tokens": ["func", "(", "ss", "*", "StringsValue", ")", "Set", "(", "s", "string", ")", "error", "{", "*", "ss", "=", "strings", ".", "Split", "(", "s", ",", "\"", "\"", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// Set parses a command line set of strings, separated by comma.\n// Implements \"flag.Value\" interface.", "docstring_tokens": ["Set", "parses", "a", "command", "line", "set", "of", "strings", "separated", "by", "comma", ".", "Implements", "flag", ".", "Value", "interface", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/flags/strings.go#L28-L31", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pfs.go", "func_name": "Close", "original_string": "func (c *putFileClient) Close() error {\n\t_, err := c.c.CloseAndRecv()\n\treturn grpcutil.ScrubGRPC(err)\n}", "language": "go", "code": "func (c *putFileClient) Close() error {\n\t_, err := c.c.CloseAndRecv()\n\treturn grpcutil.ScrubGRPC(err)\n}", "code_tokens": ["func", "(", "c", "*", "putFileClient", ")", "Close", "(", ")", "error", "{", "_", ",", "err", ":=", "c", ".", "c", ".", "CloseAndRecv", "(", ")", "\n", "return", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}"], "docstring": "// Close must be called after you're done using a putFileClient.\n// Further requests will throw errors.", "docstring_tokens": ["Close", "must", "be", "called", "after", "you", "re", "done", "using", "a", "putFileClient", ".", "Further", "requests", "will", "throw", "errors", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L947-L950", "partition": "test"}
{"repo": "golang/appengine", "path": "appengine.go", "func_name": "WithAPICallFunc", "original_string": "func WithAPICallFunc(ctx context.Context, f APICallFunc) context.Context {\n\treturn internal.WithCallOverride(ctx, internal.CallOverrideFunc(f))\n}", "language": "go", "code": "func WithAPICallFunc(ctx context.Context, f APICallFunc) context.Context {\n\treturn internal.WithCallOverride(ctx, internal.CallOverrideFunc(f))\n}", "code_tokens": ["func", "WithAPICallFunc", "(", "ctx", "context", ".", "Context", ",", "f", "APICallFunc", ")", "context", ".", "Context", "{", "return", "internal", ".", "WithCallOverride", "(", "ctx", ",", "internal", ".", "CallOverrideFunc", "(", "f", ")", ")", "\n", "}"], "docstring": "// WithAPICallFunc returns a copy of the parent context\n// that will cause API calls to invoke f instead of their normal operation.\n//\n// This is intended for advanced users only.", "docstring_tokens": ["WithAPICallFunc", "returns", "a", "copy", "of", "the", "parent", "context", "that", "will", "cause", "API", "calls", "to", "invoke", "f", "instead", "of", "their", "normal", "operation", ".", "This", "is", "intended", "for", "advanced", "users", "only", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/appengine.go#L125-L127", "partition": "test"}
{"repo": "ipfs/go-ipfs-api", "path": "shell.go", "func_name": "List", "original_string": "func (s *Shell) List(path string) ([]*LsLink, error) {\n\tvar out struct{ Objects []LsObject }\n\terr := s.Request(\"ls\", path).Exec(context.Background(), &out)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(out.Objects) != 1 {\n\t\treturn nil, errors.New(\"bad response from server\")\n\t}\n\treturn out.Objects[0].Links, nil\n}", "language": "go", "code": "func (s *Shell) List(path string) ([]*LsLink, error) {\n\tvar out struct{ Objects []LsObject }\n\terr := s.Request(\"ls\", path).Exec(context.Background(), &out)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(out.Objects) != 1 {\n\t\treturn nil, errors.New(\"bad response from server\")\n\t}\n\treturn out.Objects[0].Links, nil\n}", "code_tokens": ["func", "(", "s", "*", "Shell", ")", "List", "(", "path", "string", ")", "(", "[", "]", "*", "LsLink", ",", "error", ")", "{", "var", "out", "struct", "{", "Objects", "[", "]", "LsObject", "}", "\n", "err", ":=", "s", ".", "Request", "(", "\"", "\"", ",", "path", ")", ".", "Exec", "(", "context", ".", "Background", "(", ")", ",", "&", "out", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "len", "(", "out", ".", "Objects", ")", "!=", "1", "{", "return", "nil", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "out", ".", "Objects", "[", "0", "]", ".", "Links", ",", "nil", "\n", "}"], "docstring": "// List entries at the given path", "docstring_tokens": ["List", "entries", "at", "the", "given", "path"], "sha": "a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32", "url": "https://github.com/ipfs/go-ipfs-api/blob/a1b28da48b3763f67654ec4cfcba5fcbfb3dfb32/shell.go#L150-L160", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "genny/actions/actions.go", "func_name": "New", "original_string": "func New(opts *Options) (*genny.Generator, error) {\n\tg := genny.New()\n\n\tif err := opts.Validate(); err != nil {\n\t\treturn g, err\n\t}\n\n\tg.RunFn(construct(opts))\n\treturn g, nil\n}", "language": "go", "code": "func New(opts *Options) (*genny.Generator, error) {\n\tg := genny.New()\n\n\tif err := opts.Validate(); err != nil {\n\t\treturn g, err\n\t}\n\n\tg.RunFn(construct(opts))\n\treturn g, nil\n}", "code_tokens": ["func", "New", "(", "opts", "*", "Options", ")", "(", "*", "genny", ".", "Generator", ",", "error", ")", "{", "g", ":=", "genny", ".", "New", "(", ")", "\n\n", "if", "err", ":=", "opts", ".", "Validate", "(", ")", ";", "err", "!=", "nil", "{", "return", "g", ",", "err", "\n", "}", "\n\n", "g", ".", "RunFn", "(", "construct", "(", "opts", ")", ")", "\n", "return", "g", ",", "nil", "\n", "}"], "docstring": "// New returns a new generator for build actions on a Buffalo app", "docstring_tokens": ["New", "returns", "a", "new", "generator", "for", "build", "actions", "on", "a", "Buffalo", "app"], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/genny/actions/actions.go#L16-L25", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/hashtree/db.go", "func_name": "Serialize", "original_string": "func (h *dbHashTree) Serialize(_w io.Writer) error {\n\tw := pbutil.NewWriter(_w)\n\treturn h.View(func(tx *bolt.Tx) error {\n\t\tfor _, bucket := range buckets {\n\t\t\tb := tx.Bucket(b(bucket))\n\t\t\tif _, err := w.Write(\n\t\t\t\t&BucketHeader{\n\t\t\t\t\tBucket: bucket,\n\t\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := b.ForEach(func(k, v []byte) error {\n\t\t\t\tif _, err := w.WriteBytes(k); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t_, err := w.WriteBytes(v)\n\t\t\t\treturn err\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := w.WriteBytes(SentinelByte); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}", "language": "go", "code": "func (h *dbHashTree) Serialize(_w io.Writer) error {\n\tw := pbutil.NewWriter(_w)\n\treturn h.View(func(tx *bolt.Tx) error {\n\t\tfor _, bucket := range buckets {\n\t\t\tb := tx.Bucket(b(bucket))\n\t\t\tif _, err := w.Write(\n\t\t\t\t&BucketHeader{\n\t\t\t\t\tBucket: bucket,\n\t\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := b.ForEach(func(k, v []byte) error {\n\t\t\t\tif _, err := w.WriteBytes(k); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t_, err := w.WriteBytes(v)\n\t\t\t\treturn err\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := w.WriteBytes(SentinelByte); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}", "code_tokens": ["func", "(", "h", "*", "dbHashTree", ")", "Serialize", "(", "_w", "io", ".", "Writer", ")", "error", "{", "w", ":=", "pbutil", ".", "NewWriter", "(", "_w", ")", "\n", "return", "h", ".", "View", "(", "func", "(", "tx", "*", "bolt", ".", "Tx", ")", "error", "{", "for", "_", ",", "bucket", ":=", "range", "buckets", "{", "b", ":=", "tx", ".", "Bucket", "(", "b", "(", "bucket", ")", ")", "\n", "if", "_", ",", "err", ":=", "w", ".", "Write", "(", "&", "BucketHeader", "{", "Bucket", ":", "bucket", ",", "}", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "err", ":=", "b", ".", "ForEach", "(", "func", "(", "k", ",", "v", "[", "]", "byte", ")", "error", "{", "if", "_", ",", "err", ":=", "w", ".", "WriteBytes", "(", "k", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "_", ",", "err", ":=", "w", ".", "WriteBytes", "(", "v", ")", "\n", "return", "err", "\n", "}", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "_", ",", "err", ":=", "w", ".", "WriteBytes", "(", "SentinelByte", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n", "return", "nil", "\n", "}", ")", "\n", "}"], "docstring": "// Serialize serializes a binary version of the hashtree.", "docstring_tokens": ["Serialize", "serializes", "a", "binary", "version", "of", "the", "hashtree", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/db.go#L502-L528", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pfs.go", "func_name": "TagObject", "original_string": "func (c APIClient) TagObject(hash string, tags ...string) error {\n\tvar _tags []*pfs.Tag\n\tfor _, tag := range tags {\n\t\t_tags = append(_tags, &pfs.Tag{Name: tag})\n\t}\n\tif _, err := c.ObjectAPIClient.TagObject(\n\t\tc.Ctx(),\n\t\t&pfs.TagObjectRequest{\n\t\t\tObject: &pfs.Object{Hash: hash},\n\t\t\tTags:   _tags,\n\t\t},\n\t); err != nil {\n\t\treturn grpcutil.ScrubGRPC(err)\n\t}\n\treturn nil\n}", "language": "go", "code": "func (c APIClient) TagObject(hash string, tags ...string) error {\n\tvar _tags []*pfs.Tag\n\tfor _, tag := range tags {\n\t\t_tags = append(_tags, &pfs.Tag{Name: tag})\n\t}\n\tif _, err := c.ObjectAPIClient.TagObject(\n\t\tc.Ctx(),\n\t\t&pfs.TagObjectRequest{\n\t\t\tObject: &pfs.Object{Hash: hash},\n\t\t\tTags:   _tags,\n\t\t},\n\t); err != nil {\n\t\treturn grpcutil.ScrubGRPC(err)\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "APIClient", ")", "TagObject", "(", "hash", "string", ",", "tags", "...", "string", ")", "error", "{", "var", "_tags", "[", "]", "*", "pfs", ".", "Tag", "\n", "for", "_", ",", "tag", ":=", "range", "tags", "{", "_tags", "=", "append", "(", "_tags", ",", "&", "pfs", ".", "Tag", "{", "Name", ":", "tag", "}", ")", "\n", "}", "\n", "if", "_", ",", "err", ":=", "c", ".", "ObjectAPIClient", ".", "TagObject", "(", "c", ".", "Ctx", "(", ")", ",", "&", "pfs", ".", "TagObjectRequest", "{", "Object", ":", "&", "pfs", ".", "Object", "{", "Hash", ":", "hash", "}", ",", "Tags", ":", "_tags", ",", "}", ",", ")", ";", "err", "!=", "nil", "{", "return", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// TagObject applies a tag to an existing object.", "docstring_tokens": ["TagObject", "applies", "a", "tag", "to", "an", "existing", "object", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L679-L694", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/spyglass/spyglass.go", "func_name": "Lenses", "original_string": "func (s *Spyglass) Lenses(matchCache map[string][]string) []lenses.Lens {\n\tls := []lenses.Lens{}\n\tfor lensName, matches := range matchCache {\n\t\tif len(matches) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tlens, err := lenses.GetLens(lensName)\n\t\tif err != nil {\n\t\t\tlogrus.WithField(\"lensName\", lens).WithError(err).Error(\"Could not find artifact lens\")\n\t\t} else {\n\t\t\tls = append(ls, lens)\n\t\t}\n\t}\n\t// Make sure lenses are rendered in order by ascending priority\n\tsort.Slice(ls, func(i, j int) bool {\n\t\ticonf := ls[i].Config()\n\t\tjconf := ls[j].Config()\n\t\tiname := iconf.Name\n\t\tjname := jconf.Name\n\t\tpi := iconf.Priority\n\t\tpj := jconf.Priority\n\t\tif pi == pj {\n\t\t\treturn iname < jname\n\t\t}\n\t\treturn pi < pj\n\t})\n\treturn ls\n}", "language": "go", "code": "func (s *Spyglass) Lenses(matchCache map[string][]string) []lenses.Lens {\n\tls := []lenses.Lens{}\n\tfor lensName, matches := range matchCache {\n\t\tif len(matches) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tlens, err := lenses.GetLens(lensName)\n\t\tif err != nil {\n\t\t\tlogrus.WithField(\"lensName\", lens).WithError(err).Error(\"Could not find artifact lens\")\n\t\t} else {\n\t\t\tls = append(ls, lens)\n\t\t}\n\t}\n\t// Make sure lenses are rendered in order by ascending priority\n\tsort.Slice(ls, func(i, j int) bool {\n\t\ticonf := ls[i].Config()\n\t\tjconf := ls[j].Config()\n\t\tiname := iconf.Name\n\t\tjname := jconf.Name\n\t\tpi := iconf.Priority\n\t\tpj := jconf.Priority\n\t\tif pi == pj {\n\t\t\treturn iname < jname\n\t\t}\n\t\treturn pi < pj\n\t})\n\treturn ls\n}", "code_tokens": ["func", "(", "s", "*", "Spyglass", ")", "Lenses", "(", "matchCache", "map", "[", "string", "]", "[", "]", "string", ")", "[", "]", "lenses", ".", "Lens", "{", "ls", ":=", "[", "]", "lenses", ".", "Lens", "{", "}", "\n", "for", "lensName", ",", "matches", ":=", "range", "matchCache", "{", "if", "len", "(", "matches", ")", "==", "0", "{", "continue", "\n", "}", "\n", "lens", ",", "err", ":=", "lenses", ".", "GetLens", "(", "lensName", ")", "\n", "if", "err", "!=", "nil", "{", "logrus", ".", "WithField", "(", "\"", "\"", ",", "lens", ")", ".", "WithError", "(", "err", ")", ".", "Error", "(", "\"", "\"", ")", "\n", "}", "else", "{", "ls", "=", "append", "(", "ls", ",", "lens", ")", "\n", "}", "\n", "}", "\n", "// Make sure lenses are rendered in order by ascending priority", "sort", ".", "Slice", "(", "ls", ",", "func", "(", "i", ",", "j", "int", ")", "bool", "{", "iconf", ":=", "ls", "[", "i", "]", ".", "Config", "(", ")", "\n", "jconf", ":=", "ls", "[", "j", "]", ".", "Config", "(", ")", "\n", "iname", ":=", "iconf", ".", "Name", "\n", "jname", ":=", "jconf", ".", "Name", "\n", "pi", ":=", "iconf", ".", "Priority", "\n", "pj", ":=", "jconf", ".", "Priority", "\n", "if", "pi", "==", "pj", "{", "return", "iname", "<", "jname", "\n", "}", "\n", "return", "pi", "<", "pj", "\n", "}", ")", "\n", "return", "ls", "\n", "}"], "docstring": "// Lenses gets all views of all artifact files matching each regexp with a registered lens", "docstring_tokens": ["Lenses", "gets", "all", "views", "of", "all", "artifact", "files", "matching", "each", "regexp", "with", "a", "registered", "lens"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/spyglass/spyglass.go#L98-L125", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "thrift/context.go", "func_name": "WithHeaders", "original_string": "func WithHeaders(ctx context.Context, headers map[string]string) Context {\n\treturn tchannel.WrapWithHeaders(ctx, headers)\n}", "language": "go", "code": "func WithHeaders(ctx context.Context, headers map[string]string) Context {\n\treturn tchannel.WrapWithHeaders(ctx, headers)\n}", "code_tokens": ["func", "WithHeaders", "(", "ctx", "context", ".", "Context", ",", "headers", "map", "[", "string", "]", "string", ")", "Context", "{", "return", "tchannel", ".", "WrapWithHeaders", "(", "ctx", ",", "headers", ")", "\n", "}"], "docstring": "// WithHeaders returns a Context that can be used to make a call with request headers.", "docstring_tokens": ["WithHeaders", "returns", "a", "Context", "that", "can", "be", "used", "to", "make", "a", "call", "with", "request", "headers", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/thrift/context.go#L45-L47", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "GetIpv6", "original_string": "func (u PeerAddressIp) GetIpv6() (result [16]byte, ok bool) {\n\tarmName, _ := u.ArmForSwitch(int32(u.Type))\n\n\tif armName == \"Ipv6\" {\n\t\tresult = *u.Ipv6\n\t\tok = true\n\t}\n\n\treturn\n}", "language": "go", "code": "func (u PeerAddressIp) GetIpv6() (result [16]byte, ok bool) {\n\tarmName, _ := u.ArmForSwitch(int32(u.Type))\n\n\tif armName == \"Ipv6\" {\n\t\tresult = *u.Ipv6\n\t\tok = true\n\t}\n\n\treturn\n}", "code_tokens": ["func", "(", "u", "PeerAddressIp", ")", "GetIpv6", "(", ")", "(", "result", "[", "16", "]", "byte", ",", "ok", "bool", ")", "{", "armName", ",", "_", ":=", "u", ".", "ArmForSwitch", "(", "int32", "(", "u", ".", "Type", ")", ")", "\n\n", "if", "armName", "==", "\"", "\"", "{", "result", "=", "*", "u", ".", "Ipv6", "\n", "ok", "=", "true", "\n", "}", "\n\n", "return", "\n", "}"], "docstring": "// GetIpv6 retrieves the Ipv6 value from the union,\n// returning ok if the union's switch indicated the value is valid.", "docstring_tokens": ["GetIpv6", "retrieves", "the", "Ipv6", "value", "from", "the", "union", "returning", "ok", "if", "the", "union", "s", "switch", "indicated", "the", "value", "is", "valid", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6166-L6175", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_cluster.go", "func_name": "UpdateCluster", "original_string": "func (r *ProtocolLXD) UpdateCluster(cluster api.ClusterPut, ETag string) (Operation, error) {\n\tif !r.HasExtension(\"clustering\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"clustering\\\" API extension\")\n\t}\n\n\tif cluster.ServerAddress != \"\" || cluster.ClusterPassword != \"\" || len(cluster.MemberConfig) > 0 {\n\t\tif !r.HasExtension(\"clustering_join\") {\n\t\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"clustering_join\\\" API extension\")\n\t\t}\n\t}\n\n\top, _, err := r.queryOperation(\"PUT\", \"/cluster\", cluster, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "language": "go", "code": "func (r *ProtocolLXD) UpdateCluster(cluster api.ClusterPut, ETag string) (Operation, error) {\n\tif !r.HasExtension(\"clustering\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"clustering\\\" API extension\")\n\t}\n\n\tif cluster.ServerAddress != \"\" || cluster.ClusterPassword != \"\" || len(cluster.MemberConfig) > 0 {\n\t\tif !r.HasExtension(\"clustering_join\") {\n\t\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"clustering_join\\\" API extension\")\n\t\t}\n\t}\n\n\top, _, err := r.queryOperation(\"PUT\", \"/cluster\", cluster, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "UpdateCluster", "(", "cluster", "api", ".", "ClusterPut", ",", "ETag", "string", ")", "(", "Operation", ",", "error", ")", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "if", "cluster", ".", "ServerAddress", "!=", "\"", "\"", "||", "cluster", ".", "ClusterPassword", "!=", "\"", "\"", "||", "len", "(", "cluster", ".", "MemberConfig", ")", ">", "0", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n", "}", "\n\n", "op", ",", "_", ",", "err", ":=", "r", ".", "queryOperation", "(", "\"", "\"", ",", "\"", "\"", ",", "cluster", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "op", ",", "nil", "\n", "}"], "docstring": "// UpdateCluster requests to bootstrap a new cluster or join an existing one.", "docstring_tokens": ["UpdateCluster", "requests", "to", "bootstrap", "a", "new", "cluster", "or", "join", "an", "existing", "one", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_cluster.go#L27-L44", "partition": "test"}
{"repo": "libp2p/go-libp2p-pubsub", "path": "pubsub.go", "func_name": "GetTopics", "original_string": "func (p *PubSub) GetTopics() []string {\n\tout := make(chan []string, 1)\n\tp.getTopics <- &topicReq{resp: out}\n\treturn <-out\n}", "language": "go", "code": "func (p *PubSub) GetTopics() []string {\n\tout := make(chan []string, 1)\n\tp.getTopics <- &topicReq{resp: out}\n\treturn <-out\n}", "code_tokens": ["func", "(", "p", "*", "PubSub", ")", "GetTopics", "(", ")", "[", "]", "string", "{", "out", ":=", "make", "(", "chan", "[", "]", "string", ",", "1", ")", "\n", "p", ".", "getTopics", "<-", "&", "topicReq", "{", "resp", ":", "out", "}", "\n", "return", "<-", "out", "\n", "}"], "docstring": "// GetTopics returns the topics this node is subscribed to.", "docstring_tokens": ["GetTopics", "returns", "the", "topics", "this", "node", "is", "subscribed", "to", "."], "sha": "9db3dbdde90f44d1c420192c5cefd60682fbdbb9", "url": "https://github.com/libp2p/go-libp2p-pubsub/blob/9db3dbdde90f44d1c420192c5cefd60682fbdbb9/pubsub.go#L826-L830", "partition": "test"}
{"repo": "guregu/null", "path": "time.go", "func_name": "MarshalJSON", "original_string": "func (t Time) MarshalJSON() ([]byte, error) {\n\tif !t.Valid {\n\t\treturn []byte(\"null\"), nil\n\t}\n\treturn t.Time.MarshalJSON()\n}", "language": "go", "code": "func (t Time) MarshalJSON() ([]byte, error) {\n\tif !t.Valid {\n\t\treturn []byte(\"null\"), nil\n\t}\n\treturn t.Time.MarshalJSON()\n}", "code_tokens": ["func", "(", "t", "Time", ")", "MarshalJSON", "(", ")", "(", "[", "]", "byte", ",", "error", ")", "{", "if", "!", "t", ".", "Valid", "{", "return", "[", "]", "byte", "(", "\"", "\"", ")", ",", "nil", "\n", "}", "\n", "return", "t", ".", "Time", ".", "MarshalJSON", "(", ")", "\n", "}"], "docstring": "// MarshalJSON implements json.Marshaler.\n// It will encode null if this time is null.", "docstring_tokens": ["MarshalJSON", "implements", "json", ".", "Marshaler", ".", "It", "will", "encode", "null", "if", "this", "time", "is", "null", "."], "sha": "80515d440932108546bcade467bb7d6968e812e2", "url": "https://github.com/guregu/null/blob/80515d440932108546bcade467bb7d6968e812e2/time.go#L73-L78", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/pjutil/pjutil.go", "func_name": "BatchSpec", "original_string": "func BatchSpec(p config.Presubmit, refs prowapi.Refs) prowapi.ProwJobSpec {\n\tpjs := specFromJobBase(p.JobBase)\n\tpjs.Type = prowapi.BatchJob\n\tpjs.Context = p.Context\n\tpjs.Refs = completePrimaryRefs(refs, p.JobBase)\n\n\treturn pjs\n}", "language": "go", "code": "func BatchSpec(p config.Presubmit, refs prowapi.Refs) prowapi.ProwJobSpec {\n\tpjs := specFromJobBase(p.JobBase)\n\tpjs.Type = prowapi.BatchJob\n\tpjs.Context = p.Context\n\tpjs.Refs = completePrimaryRefs(refs, p.JobBase)\n\n\treturn pjs\n}", "code_tokens": ["func", "BatchSpec", "(", "p", "config", ".", "Presubmit", ",", "refs", "prowapi", ".", "Refs", ")", "prowapi", ".", "ProwJobSpec", "{", "pjs", ":=", "specFromJobBase", "(", "p", ".", "JobBase", ")", "\n", "pjs", ".", "Type", "=", "prowapi", ".", "BatchJob", "\n", "pjs", ".", "Context", "=", "p", ".", "Context", "\n", "pjs", ".", "Refs", "=", "completePrimaryRefs", "(", "refs", ",", "p", ".", "JobBase", ")", "\n\n", "return", "pjs", "\n", "}"], "docstring": "// BatchSpec initializes a ProwJobSpec for a given batch job and ref spec.", "docstring_tokens": ["BatchSpec", "initializes", "a", "ProwJobSpec", "for", "a", "given", "batch", "job", "and", "ref", "spec", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pjutil/pjutil.go#L150-L157", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/jenkins/jenkins.go", "func_name": "GetSkipMetrics", "original_string": "func (c *Client) GetSkipMetrics(path string) ([]byte, error) {\n\tresp, err := c.request(http.MethodGet, path, nil, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn readResp(resp)\n}", "language": "go", "code": "func (c *Client) GetSkipMetrics(path string) ([]byte, error) {\n\tresp, err := c.request(http.MethodGet, path, nil, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn readResp(resp)\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "GetSkipMetrics", "(", "path", "string", ")", "(", "[", "]", "byte", ",", "error", ")", "{", "resp", ",", "err", ":=", "c", ".", "request", "(", "http", ".", "MethodGet", ",", "path", ",", "nil", ",", "false", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "readResp", "(", "resp", ")", "\n", "}"], "docstring": "// GetSkipMetrics fetches the data found in the provided path. It returns the\n// content of the response or any errors that occurred during the request or\n// http errors. Metrics will not be gathered for this request.", "docstring_tokens": ["GetSkipMetrics", "fetches", "the", "data", "found", "in", "the", "provided", "path", ".", "It", "returns", "the", "content", "of", "the", "response", "or", "any", "errors", "that", "occurred", "during", "the", "request", "or", "http", "errors", ".", "Metrics", "will", "not", "be", "gathered", "for", "this", "request", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/jenkins/jenkins.go#L329-L335", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "emulation/emulation.go", "func_name": "Do", "original_string": "func (p *SetDocumentCookieDisabledParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetDocumentCookieDisabled, p, nil)\n}", "language": "go", "code": "func (p *SetDocumentCookieDisabledParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetDocumentCookieDisabled, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetDocumentCookieDisabledParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetDocumentCookieDisabled", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Emulation.setDocumentCookieDisabled against the provided context.", "docstring_tokens": ["Do", "executes", "Emulation", ".", "setDocumentCookieDisabled", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/emulation/emulation.go#L313-L315", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "stream.go", "func_name": "ToList", "original_string": "func (st *Stream) ToList(key []byte, itr *Iterator) (*pb.KVList, error) {\n\tlist := &pb.KVList{}\n\tfor ; itr.Valid(); itr.Next() {\n\t\titem := itr.Item()\n\t\tif item.IsDeletedOrExpired() {\n\t\t\tbreak\n\t\t}\n\t\tif !bytes.Equal(key, item.Key()) {\n\t\t\t// Break out on the first encounter with another key.\n\t\t\tbreak\n\t\t}\n\n\t\tvalCopy, err := item.ValueCopy(nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkv := &pb.KV{\n\t\t\tKey:       item.KeyCopy(nil),\n\t\t\tValue:     valCopy,\n\t\t\tUserMeta:  []byte{item.UserMeta()},\n\t\t\tVersion:   item.Version(),\n\t\t\tExpiresAt: item.ExpiresAt(),\n\t\t}\n\t\tlist.Kv = append(list.Kv, kv)\n\t\tif st.db.opt.NumVersionsToKeep == 1 {\n\t\t\tbreak\n\t\t}\n\n\t\tif item.DiscardEarlierVersions() {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn list, nil\n}", "language": "go", "code": "func (st *Stream) ToList(key []byte, itr *Iterator) (*pb.KVList, error) {\n\tlist := &pb.KVList{}\n\tfor ; itr.Valid(); itr.Next() {\n\t\titem := itr.Item()\n\t\tif item.IsDeletedOrExpired() {\n\t\t\tbreak\n\t\t}\n\t\tif !bytes.Equal(key, item.Key()) {\n\t\t\t// Break out on the first encounter with another key.\n\t\t\tbreak\n\t\t}\n\n\t\tvalCopy, err := item.ValueCopy(nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkv := &pb.KV{\n\t\t\tKey:       item.KeyCopy(nil),\n\t\t\tValue:     valCopy,\n\t\t\tUserMeta:  []byte{item.UserMeta()},\n\t\t\tVersion:   item.Version(),\n\t\t\tExpiresAt: item.ExpiresAt(),\n\t\t}\n\t\tlist.Kv = append(list.Kv, kv)\n\t\tif st.db.opt.NumVersionsToKeep == 1 {\n\t\t\tbreak\n\t\t}\n\n\t\tif item.DiscardEarlierVersions() {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn list, nil\n}", "code_tokens": ["func", "(", "st", "*", "Stream", ")", "ToList", "(", "key", "[", "]", "byte", ",", "itr", "*", "Iterator", ")", "(", "*", "pb", ".", "KVList", ",", "error", ")", "{", "list", ":=", "&", "pb", ".", "KVList", "{", "}", "\n", "for", ";", "itr", ".", "Valid", "(", ")", ";", "itr", ".", "Next", "(", ")", "{", "item", ":=", "itr", ".", "Item", "(", ")", "\n", "if", "item", ".", "IsDeletedOrExpired", "(", ")", "{", "break", "\n", "}", "\n", "if", "!", "bytes", ".", "Equal", "(", "key", ",", "item", ".", "Key", "(", ")", ")", "{", "// Break out on the first encounter with another key.", "break", "\n", "}", "\n\n", "valCopy", ",", "err", ":=", "item", ".", "ValueCopy", "(", "nil", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "kv", ":=", "&", "pb", ".", "KV", "{", "Key", ":", "item", ".", "KeyCopy", "(", "nil", ")", ",", "Value", ":", "valCopy", ",", "UserMeta", ":", "[", "]", "byte", "{", "item", ".", "UserMeta", "(", ")", "}", ",", "Version", ":", "item", ".", "Version", "(", ")", ",", "ExpiresAt", ":", "item", ".", "ExpiresAt", "(", ")", ",", "}", "\n", "list", ".", "Kv", "=", "append", "(", "list", ".", "Kv", ",", "kv", ")", "\n", "if", "st", ".", "db", ".", "opt", ".", "NumVersionsToKeep", "==", "1", "{", "break", "\n", "}", "\n\n", "if", "item", ".", "DiscardEarlierVersions", "(", ")", "{", "break", "\n", "}", "\n", "}", "\n", "return", "list", ",", "nil", "\n", "}"], "docstring": "// ToList is a default implementation of KeyToList. It picks up all valid versions of the key,\n// skipping over deleted or expired keys.", "docstring_tokens": ["ToList", "is", "a", "default", "implementation", "of", "KeyToList", ".", "It", "picks", "up", "all", "valid", "versions", "of", "the", "key", "skipping", "over", "deleted", "or", "expired", "keys", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/stream.go#L77-L110", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "build/transaction.go", "func_name": "Sign", "original_string": "func (b *TransactionBuilder) Sign(signers ...string) (result TransactionEnvelopeBuilder) {\n\tresult.Mutate(b)\n\n\tfor _, s := range signers {\n\t\tresult.Mutate(Sign{s})\n\t}\n\n\treturn\n}", "language": "go", "code": "func (b *TransactionBuilder) Sign(signers ...string) (result TransactionEnvelopeBuilder) {\n\tresult.Mutate(b)\n\n\tfor _, s := range signers {\n\t\tresult.Mutate(Sign{s})\n\t}\n\n\treturn\n}", "code_tokens": ["func", "(", "b", "*", "TransactionBuilder", ")", "Sign", "(", "signers", "...", "string", ")", "(", "result", "TransactionEnvelopeBuilder", ")", "{", "result", ".", "Mutate", "(", "b", ")", "\n\n", "for", "_", ",", "s", ":=", "range", "signers", "{", "result", ".", "Mutate", "(", "Sign", "{", "s", "}", ")", "\n", "}", "\n\n", "return", "\n", "}"], "docstring": "// Sign returns an new TransactionEnvelopeBuilder using this builder's\n// transaction as the basis and with signatures of that transaction from the\n// provided Signers.", "docstring_tokens": ["Sign", "returns", "an", "new", "TransactionEnvelopeBuilder", "using", "this", "builder", "s", "transaction", "as", "the", "basis", "and", "with", "signatures", "of", "that", "transaction", "from", "the", "provided", "Signers", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/transaction.go#L86-L94", "partition": "test"}
{"repo": "mgutz/str", "path": "funcsPZ.go", "func_name": "Reverse", "original_string": "func Reverse(s string) string {\n\tcs := make([]rune, utf8.RuneCountInString(s))\n\ti := len(cs)\n\tfor _, c := range s {\n\t\ti--\n\t\tcs[i] = c\n\t}\n\treturn string(cs)\n}", "language": "go", "code": "func Reverse(s string) string {\n\tcs := make([]rune, utf8.RuneCountInString(s))\n\ti := len(cs)\n\tfor _, c := range s {\n\t\ti--\n\t\tcs[i] = c\n\t}\n\treturn string(cs)\n}", "code_tokens": ["func", "Reverse", "(", "s", "string", ")", "string", "{", "cs", ":=", "make", "(", "[", "]", "rune", ",", "utf8", ".", "RuneCountInString", "(", "s", ")", ")", "\n", "i", ":=", "len", "(", "cs", ")", "\n", "for", "_", ",", "c", ":=", "range", "s", "{", "i", "--", "\n", "cs", "[", "i", "]", "=", "c", "\n", "}", "\n", "return", "string", "(", "cs", ")", "\n", "}"], "docstring": "// Reverse a string", "docstring_tokens": ["Reverse", "a", "string"], "sha": "968bf66e3da857419e4f6e71b2d5c9ae95682dc4", "url": "https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsPZ.go#L104-L112", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "router.go", "func_name": "Gossip", "original_string": "func (router *Router) Gossip() GossipData {\n\treturn &topologyGossipData{peers: router.Peers, update: router.Peers.names()}\n}", "language": "go", "code": "func (router *Router) Gossip() GossipData {\n\treturn &topologyGossipData{peers: router.Peers, update: router.Peers.names()}\n}", "code_tokens": ["func", "(", "router", "*", "Router", ")", "Gossip", "(", ")", "GossipData", "{", "return", "&", "topologyGossipData", "{", "peers", ":", "router", ".", "Peers", ",", "update", ":", "router", ".", "Peers", ".", "names", "(", ")", "}", "\n", "}"], "docstring": "// Gossip yields the current topology as GossipData.", "docstring_tokens": ["Gossip", "yields", "the", "current", "topology", "as", "GossipData", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/router.go#L249-L251", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "Do", "original_string": "func (p *SetBypassCSPParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetBypassCSP, p, nil)\n}", "language": "go", "code": "func (p *SetBypassCSPParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetBypassCSP, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetBypassCSPParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetBypassCSP", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Page.setBypassCSP against the provided context.", "docstring_tokens": ["Do", "executes", "Page", ".", "setBypassCSP", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L991-L993", "partition": "test"}
{"repo": "go-opencv/go-opencv", "path": "opencv/cxcore.go", "func_name": "Merge", "original_string": "func Merge(imgBlue, imgGreen, imgRed, imgAlpha, dst *IplImage) {\n\tC.cvMerge(\n\t\tunsafe.Pointer(imgBlue),\n\t\tunsafe.Pointer(imgGreen),\n\t\tunsafe.Pointer(imgRed),\n\t\tunsafe.Pointer(imgAlpha),\n\t\tunsafe.Pointer(dst),\n\t)\n}", "language": "go", "code": "func Merge(imgBlue, imgGreen, imgRed, imgAlpha, dst *IplImage) {\n\tC.cvMerge(\n\t\tunsafe.Pointer(imgBlue),\n\t\tunsafe.Pointer(imgGreen),\n\t\tunsafe.Pointer(imgRed),\n\t\tunsafe.Pointer(imgAlpha),\n\t\tunsafe.Pointer(dst),\n\t)\n}", "code_tokens": ["func", "Merge", "(", "imgBlue", ",", "imgGreen", ",", "imgRed", ",", "imgAlpha", ",", "dst", "*", "IplImage", ")", "{", "C", ".", "cvMerge", "(", "unsafe", ".", "Pointer", "(", "imgBlue", ")", ",", "unsafe", ".", "Pointer", "(", "imgGreen", ")", ",", "unsafe", ".", "Pointer", "(", "imgRed", ")", ",", "unsafe", ".", "Pointer", "(", "imgAlpha", ")", ",", "unsafe", ".", "Pointer", "(", "dst", ")", ",", ")", "\n", "}"], "docstring": "// Merge creates one multichannel array out of several single-channel ones.", "docstring_tokens": ["Merge", "creates", "one", "multichannel", "array", "out", "of", "several", "single", "-", "channel", "ones", "."], "sha": "a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db", "url": "https://github.com/go-opencv/go-opencv/blob/a4fe8ec027ccc9eb8b7d0797db7c76e61083f1db/opencv/cxcore.go#L58-L66", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "mex.go", "func_name": "recvPeerFrame", "original_string": "func (mex *messageExchange) recvPeerFrame() (*Frame, error) {\n\t// We have to check frames/errors in a very specific order here:\n\t// 1. Timeouts/cancellation (mex.ctx errors)\n\t// 2. Any pending frames (non-blocking select over mex.recvCh)\n\t// 3. Other mex errors (mex.errCh)\n\t// Which is why we check the context error only (instead of mex.checkError)e\n\t// In the mex.errCh case, we do a non-blocking read from recvCh to prioritize it.\n\tif err := mex.ctx.Err(); err != nil {\n\t\treturn nil, GetContextError(err)\n\t}\n\n\tselect {\n\tcase frame := <-mex.recvCh:\n\t\tif err := mex.checkFrame(frame); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn frame, nil\n\tcase <-mex.ctx.Done():\n\t\treturn nil, GetContextError(mex.ctx.Err())\n\tcase <-mex.errCh.c:\n\t\t// Select will randomly choose a case, but we want to prioritize\n\t\t// receiving a frame over errCh. Try a non-blocking read.\n\t\tselect {\n\t\tcase frame := <-mex.recvCh:\n\t\t\tif err := mex.checkFrame(frame); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn frame, nil\n\t\tdefault:\n\t\t}\n\t\treturn nil, mex.errCh.err\n\t}\n}", "language": "go", "code": "func (mex *messageExchange) recvPeerFrame() (*Frame, error) {\n\t// We have to check frames/errors in a very specific order here:\n\t// 1. Timeouts/cancellation (mex.ctx errors)\n\t// 2. Any pending frames (non-blocking select over mex.recvCh)\n\t// 3. Other mex errors (mex.errCh)\n\t// Which is why we check the context error only (instead of mex.checkError)e\n\t// In the mex.errCh case, we do a non-blocking read from recvCh to prioritize it.\n\tif err := mex.ctx.Err(); err != nil {\n\t\treturn nil, GetContextError(err)\n\t}\n\n\tselect {\n\tcase frame := <-mex.recvCh:\n\t\tif err := mex.checkFrame(frame); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn frame, nil\n\tcase <-mex.ctx.Done():\n\t\treturn nil, GetContextError(mex.ctx.Err())\n\tcase <-mex.errCh.c:\n\t\t// Select will randomly choose a case, but we want to prioritize\n\t\t// receiving a frame over errCh. Try a non-blocking read.\n\t\tselect {\n\t\tcase frame := <-mex.recvCh:\n\t\t\tif err := mex.checkFrame(frame); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn frame, nil\n\t\tdefault:\n\t\t}\n\t\treturn nil, mex.errCh.err\n\t}\n}", "code_tokens": ["func", "(", "mex", "*", "messageExchange", ")", "recvPeerFrame", "(", ")", "(", "*", "Frame", ",", "error", ")", "{", "// We have to check frames/errors in a very specific order here:", "// 1. Timeouts/cancellation (mex.ctx errors)", "// 2. Any pending frames (non-blocking select over mex.recvCh)", "// 3. Other mex errors (mex.errCh)", "// Which is why we check the context error only (instead of mex.checkError)e", "// In the mex.errCh case, we do a non-blocking read from recvCh to prioritize it.", "if", "err", ":=", "mex", ".", "ctx", ".", "Err", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "GetContextError", "(", "err", ")", "\n", "}", "\n\n", "select", "{", "case", "frame", ":=", "<-", "mex", ".", "recvCh", ":", "if", "err", ":=", "mex", ".", "checkFrame", "(", "frame", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "frame", ",", "nil", "\n", "case", "<-", "mex", ".", "ctx", ".", "Done", "(", ")", ":", "return", "nil", ",", "GetContextError", "(", "mex", ".", "ctx", ".", "Err", "(", ")", ")", "\n", "case", "<-", "mex", ".", "errCh", ".", "c", ":", "// Select will randomly choose a case, but we want to prioritize", "// receiving a frame over errCh. Try a non-blocking read.", "select", "{", "case", "frame", ":=", "<-", "mex", ".", "recvCh", ":", "if", "err", ":=", "mex", ".", "checkFrame", "(", "frame", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "frame", ",", "nil", "\n", "default", ":", "}", "\n", "return", "nil", ",", "mex", ".", "errCh", ".", "err", "\n", "}", "\n", "}"], "docstring": "// recvPeerFrame waits for a new frame from the peer, or until the context\n// expires or is cancelled", "docstring_tokens": ["recvPeerFrame", "waits", "for", "a", "new", "frame", "from", "the", "peer", "or", "until", "the", "context", "expires", "or", "is", "cancelled"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/mex.go#L159-L191", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/admin.go", "func_name": "ExtractAll", "original_string": "func (c APIClient) ExtractAll(objects bool) ([]*admin.Op, error) {\n\tvar result []*admin.Op\n\tif err := c.Extract(objects, func(op *admin.Op) error {\n\t\tresult = append(result, op)\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}", "language": "go", "code": "func (c APIClient) ExtractAll(objects bool) ([]*admin.Op, error) {\n\tvar result []*admin.Op\n\tif err := c.Extract(objects, func(op *admin.Op) error {\n\t\tresult = append(result, op)\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}", "code_tokens": ["func", "(", "c", "APIClient", ")", "ExtractAll", "(", "objects", "bool", ")", "(", "[", "]", "*", "admin", ".", "Op", ",", "error", ")", "{", "var", "result", "[", "]", "*", "admin", ".", "Op", "\n", "if", "err", ":=", "c", ".", "Extract", "(", "objects", ",", "func", "(", "op", "*", "admin", ".", "Op", ")", "error", "{", "result", "=", "append", "(", "result", ",", "op", ")", "\n", "return", "nil", "\n", "}", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "result", ",", "nil", "\n", "}"], "docstring": "// ExtractAll cluster state as a slice of operations.", "docstring_tokens": ["ExtractAll", "cluster", "state", "as", "a", "slice", "of", "operations", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/admin.go#L45-L54", "partition": "test"}
{"repo": "urandom/handler", "path": "auth/jwt.go", "func_name": "Issuer", "original_string": "func Issuer(issuer string) TokenOpt {\n\treturn TokenOpt{func(o *options) {\n\t\to.issuer = issuer\n\t}}\n}", "language": "go", "code": "func Issuer(issuer string) TokenOpt {\n\treturn TokenOpt{func(o *options) {\n\t\to.issuer = issuer\n\t}}\n}", "code_tokens": ["func", "Issuer", "(", "issuer", "string", ")", "TokenOpt", "{", "return", "TokenOpt", "{", "func", "(", "o", "*", "options", ")", "{", "o", ".", "issuer", "=", "issuer", "\n", "}", "}", "\n", "}"], "docstring": "// Issuer sets the issuer in the standart claims object.", "docstring_tokens": ["Issuer", "sets", "the", "issuer", "in", "the", "standart", "claims", "object", "."], "sha": "61508044a5569d1609521d81e81f6737567fd104", "url": "https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/auth/jwt.go#L85-L89", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/hashtree/db.go", "func_name": "GetHashTreeTag", "original_string": "func GetHashTreeTag(pachClient *client.APIClient, storageRoot string, treeRef *pfs.Tag) (HashTree, error) {\n\treturn getHashTree(storageRoot, func(w io.Writer) error {\n\t\treturn pachClient.GetTag(treeRef.Name, w)\n\t})\n}", "language": "go", "code": "func GetHashTreeTag(pachClient *client.APIClient, storageRoot string, treeRef *pfs.Tag) (HashTree, error) {\n\treturn getHashTree(storageRoot, func(w io.Writer) error {\n\t\treturn pachClient.GetTag(treeRef.Name, w)\n\t})\n}", "code_tokens": ["func", "GetHashTreeTag", "(", "pachClient", "*", "client", ".", "APIClient", ",", "storageRoot", "string", ",", "treeRef", "*", "pfs", ".", "Tag", ")", "(", "HashTree", ",", "error", ")", "{", "return", "getHashTree", "(", "storageRoot", ",", "func", "(", "w", "io", ".", "Writer", ")", "error", "{", "return", "pachClient", ".", "GetTag", "(", "treeRef", ".", "Name", ",", "w", ")", "\n", "}", ")", "\n", "}"], "docstring": "// GetHashTreeTag is a convenience function to deserialize a HashTree from an tagged object in the object store.", "docstring_tokens": ["GetHashTreeTag", "is", "a", "convenience", "function", "to", "deserialize", "a", "HashTree", "from", "an", "tagged", "object", "in", "the", "object", "store", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/db.go#L1497-L1501", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/checkconfig/main.go", "func_name": "union", "original_string": "func (c *orgRepoConfig) union(c2 *orgRepoConfig) *orgRepoConfig {\n\tres := &orgRepoConfig{\n\t\torgExceptions: make(map[string]sets.String),\n\t\trepos:         sets.NewString(),\n\t}\n\n\tfor org, excepts1 := range c.orgExceptions {\n\t\t// keep only items in both blacklists that are not in the\n\t\t// explicit repo whitelists for the other configuration;\n\t\t// we know from how the orgRepoConfigs are constructed that\n\t\t// a org blacklist won't intersect it's own repo whitelist\n\t\tpruned := excepts1.Difference(c2.repos)\n\t\tif excepts2, ok := c2.orgExceptions[org]; ok {\n\t\t\tres.orgExceptions[org] = pruned.Intersection(excepts2.Difference(c.repos))\n\t\t} else {\n\t\t\tres.orgExceptions[org] = pruned\n\t\t}\n\t}\n\n\tfor org, excepts2 := range c2.orgExceptions {\n\t\t// update any blacklists not previously updated\n\t\tif _, exists := res.orgExceptions[org]; !exists {\n\t\t\tres.orgExceptions[org] = excepts2.Difference(c.repos)\n\t\t}\n\t}\n\n\t// we need to prune out repos in the whitelists which are\n\t// covered by an org already; we know from above that no\n\t// org blacklist in the result will contain a repo whitelist\n\tfor _, repo := range c.repos.Union(c2.repos).UnsortedList() {\n\t\tparts := strings.SplitN(repo, \"/\", 2)\n\t\tif len(parts) != 2 {\n\t\t\tlogrus.Warnf(\"org/repo %q is formatted incorrectly\", repo)\n\t\t\tcontinue\n\t\t}\n\t\tif _, exists := res.orgExceptions[parts[0]]; !exists {\n\t\t\tres.repos.Insert(repo)\n\t\t}\n\t}\n\treturn res\n}", "language": "go", "code": "func (c *orgRepoConfig) union(c2 *orgRepoConfig) *orgRepoConfig {\n\tres := &orgRepoConfig{\n\t\torgExceptions: make(map[string]sets.String),\n\t\trepos:         sets.NewString(),\n\t}\n\n\tfor org, excepts1 := range c.orgExceptions {\n\t\t// keep only items in both blacklists that are not in the\n\t\t// explicit repo whitelists for the other configuration;\n\t\t// we know from how the orgRepoConfigs are constructed that\n\t\t// a org blacklist won't intersect it's own repo whitelist\n\t\tpruned := excepts1.Difference(c2.repos)\n\t\tif excepts2, ok := c2.orgExceptions[org]; ok {\n\t\t\tres.orgExceptions[org] = pruned.Intersection(excepts2.Difference(c.repos))\n\t\t} else {\n\t\t\tres.orgExceptions[org] = pruned\n\t\t}\n\t}\n\n\tfor org, excepts2 := range c2.orgExceptions {\n\t\t// update any blacklists not previously updated\n\t\tif _, exists := res.orgExceptions[org]; !exists {\n\t\t\tres.orgExceptions[org] = excepts2.Difference(c.repos)\n\t\t}\n\t}\n\n\t// we need to prune out repos in the whitelists which are\n\t// covered by an org already; we know from above that no\n\t// org blacklist in the result will contain a repo whitelist\n\tfor _, repo := range c.repos.Union(c2.repos).UnsortedList() {\n\t\tparts := strings.SplitN(repo, \"/\", 2)\n\t\tif len(parts) != 2 {\n\t\t\tlogrus.Warnf(\"org/repo %q is formatted incorrectly\", repo)\n\t\t\tcontinue\n\t\t}\n\t\tif _, exists := res.orgExceptions[parts[0]]; !exists {\n\t\t\tres.repos.Insert(repo)\n\t\t}\n\t}\n\treturn res\n}", "code_tokens": ["func", "(", "c", "*", "orgRepoConfig", ")", "union", "(", "c2", "*", "orgRepoConfig", ")", "*", "orgRepoConfig", "{", "res", ":=", "&", "orgRepoConfig", "{", "orgExceptions", ":", "make", "(", "map", "[", "string", "]", "sets", ".", "String", ")", ",", "repos", ":", "sets", ".", "NewString", "(", ")", ",", "}", "\n\n", "for", "org", ",", "excepts1", ":=", "range", "c", ".", "orgExceptions", "{", "// keep only items in both blacklists that are not in the", "// explicit repo whitelists for the other configuration;", "// we know from how the orgRepoConfigs are constructed that", "// a org blacklist won't intersect it's own repo whitelist", "pruned", ":=", "excepts1", ".", "Difference", "(", "c2", ".", "repos", ")", "\n", "if", "excepts2", ",", "ok", ":=", "c2", ".", "orgExceptions", "[", "org", "]", ";", "ok", "{", "res", ".", "orgExceptions", "[", "org", "]", "=", "pruned", ".", "Intersection", "(", "excepts2", ".", "Difference", "(", "c", ".", "repos", ")", ")", "\n", "}", "else", "{", "res", ".", "orgExceptions", "[", "org", "]", "=", "pruned", "\n", "}", "\n", "}", "\n\n", "for", "org", ",", "excepts2", ":=", "range", "c2", ".", "orgExceptions", "{", "// update any blacklists not previously updated", "if", "_", ",", "exists", ":=", "res", ".", "orgExceptions", "[", "org", "]", ";", "!", "exists", "{", "res", ".", "orgExceptions", "[", "org", "]", "=", "excepts2", ".", "Difference", "(", "c", ".", "repos", ")", "\n", "}", "\n", "}", "\n\n", "// we need to prune out repos in the whitelists which are", "// covered by an org already; we know from above that no", "// org blacklist in the result will contain a repo whitelist", "for", "_", ",", "repo", ":=", "range", "c", ".", "repos", ".", "Union", "(", "c2", ".", "repos", ")", ".", "UnsortedList", "(", ")", "{", "parts", ":=", "strings", ".", "SplitN", "(", "repo", ",", "\"", "\"", ",", "2", ")", "\n", "if", "len", "(", "parts", ")", "!=", "2", "{", "logrus", ".", "Warnf", "(", "\"", "\"", ",", "repo", ")", "\n", "continue", "\n", "}", "\n", "if", "_", ",", "exists", ":=", "res", ".", "orgExceptions", "[", "parts", "[", "0", "]", "]", ";", "!", "exists", "{", "res", ".", "repos", ".", "Insert", "(", "repo", ")", "\n", "}", "\n", "}", "\n", "return", "res", "\n", "}"], "docstring": "// union returns a new orgRepoConfig that represents the set union of the\n// repos specified by the receiver and the parameter orgRepoConfigs", "docstring_tokens": ["union", "returns", "a", "new", "orgRepoConfig", "that", "represents", "the", "set", "union", "of", "the", "repos", "specified", "by", "the", "receiver", "and", "the", "parameter", "orgRepoConfigs"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/checkconfig/main.go#L653-L693", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/operations.go", "func_name": "Description", "original_string": "func (t OperationType) Description() string {\n\tswitch t {\n\tcase OperationClusterBootstrap:\n\t\treturn \"Creating bootstrap node\"\n\tcase OperationClusterJoin:\n\t\treturn \"Joining cluster\"\n\tcase OperationBackupCreate:\n\t\treturn \"Backing up container\"\n\tcase OperationBackupRename:\n\t\treturn \"Renaming container backup\"\n\tcase OperationBackupRestore:\n\t\treturn \"Restoring backup\"\n\tcase OperationBackupRemove:\n\t\treturn \"Removing container backup\"\n\tcase OperationConsoleShow:\n\t\treturn \"Showing console\"\n\tcase OperationContainerCreate:\n\t\treturn \"Creating container\"\n\tcase OperationContainerUpdate:\n\t\treturn \"Updating container\"\n\tcase OperationContainerRename:\n\t\treturn \"Renaming container\"\n\tcase OperationContainerMigrate:\n\t\treturn \"Migrating container\"\n\tcase OperationContainerLiveMigrate:\n\t\treturn \"Live-migrating container\"\n\tcase OperationContainerFreeze:\n\t\treturn \"Freezing container\"\n\tcase OperationContainerUnfreeze:\n\t\treturn \"Unfreezing container\"\n\tcase OperationContainerDelete:\n\t\treturn \"Deleting container\"\n\tcase OperationContainerStart:\n\t\treturn \"Starting container\"\n\tcase OperationContainerStop:\n\t\treturn \"Stopping container\"\n\tcase OperationContainerRestart:\n\t\treturn \"Restarting container\"\n\tcase OperationCommandExec:\n\t\treturn \"Executing command\"\n\tcase OperationSnapshotCreate:\n\t\treturn \"Snapshotting container\"\n\tcase OperationSnapshotRename:\n\t\treturn \"Renaming snapshot\"\n\tcase OperationSnapshotRestore:\n\t\treturn \"Restoring snapshot\"\n\tcase OperationSnapshotTransfer:\n\t\treturn \"Transferring snapshot\"\n\tcase OperationSnapshotUpdate:\n\t\treturn \"Updating snapshot\"\n\tcase OperationSnapshotDelete:\n\t\treturn \"Deleting snapshot\"\n\tcase OperationImageDownload:\n\t\treturn \"Downloading image\"\n\tcase OperationImageDelete:\n\t\treturn \"Deleting image\"\n\tcase OperationImageToken:\n\t\treturn \"Image download token\"\n\tcase OperationImageRefresh:\n\t\treturn \"Refreshing image\"\n\tcase OperationVolumeCopy:\n\t\treturn \"Copying storage volume\"\n\tcase OperationVolumeCreate:\n\t\treturn \"Creating storage volume\"\n\tcase OperationVolumeMigrate:\n\t\treturn \"Migrating storage volume\"\n\tcase OperationVolumeMove:\n\t\treturn \"Moving storage volume\"\n\tcase OperationVolumeSnapshotCreate:\n\t\treturn \"Creating storage volume snapshot\"\n\tcase OperationVolumeSnapshotDelete:\n\t\treturn \"Deleting storage volume snapshot\"\n\tcase OperationVolumeSnapshotUpdate:\n\t\treturn \"Updating storage volume snapshot\"\n\tcase OperationProjectRename:\n\t\treturn \"Renaming project\"\n\tcase OperationImagesExpire:\n\t\treturn \"Cleaning up expired images\"\n\tcase OperationImagesPruneLeftover:\n\t\treturn \"Pruning leftover image files\"\n\tcase OperationImagesUpdate:\n\t\treturn \"Updating images\"\n\tcase OperationImagesSynchronize:\n\t\treturn \"Synchronizing images\"\n\tcase OperationLogsExpire:\n\t\treturn \"Expiring log files\"\n\tcase OperationInstanceTypesUpdate:\n\t\treturn \"Updating instance types\"\n\tcase OperationBackupsExpire:\n\t\treturn \"Cleaning up expired backups\"\n\tcase OperationSnapshotsExpire:\n\t\treturn \"Cleaning up expired snapshots\"\n\tdefault:\n\t\treturn \"Executing operation\"\n\t}\n}", "language": "go", "code": "func (t OperationType) Description() string {\n\tswitch t {\n\tcase OperationClusterBootstrap:\n\t\treturn \"Creating bootstrap node\"\n\tcase OperationClusterJoin:\n\t\treturn \"Joining cluster\"\n\tcase OperationBackupCreate:\n\t\treturn \"Backing up container\"\n\tcase OperationBackupRename:\n\t\treturn \"Renaming container backup\"\n\tcase OperationBackupRestore:\n\t\treturn \"Restoring backup\"\n\tcase OperationBackupRemove:\n\t\treturn \"Removing container backup\"\n\tcase OperationConsoleShow:\n\t\treturn \"Showing console\"\n\tcase OperationContainerCreate:\n\t\treturn \"Creating container\"\n\tcase OperationContainerUpdate:\n\t\treturn \"Updating container\"\n\tcase OperationContainerRename:\n\t\treturn \"Renaming container\"\n\tcase OperationContainerMigrate:\n\t\treturn \"Migrating container\"\n\tcase OperationContainerLiveMigrate:\n\t\treturn \"Live-migrating container\"\n\tcase OperationContainerFreeze:\n\t\treturn \"Freezing container\"\n\tcase OperationContainerUnfreeze:\n\t\treturn \"Unfreezing container\"\n\tcase OperationContainerDelete:\n\t\treturn \"Deleting container\"\n\tcase OperationContainerStart:\n\t\treturn \"Starting container\"\n\tcase OperationContainerStop:\n\t\treturn \"Stopping container\"\n\tcase OperationContainerRestart:\n\t\treturn \"Restarting container\"\n\tcase OperationCommandExec:\n\t\treturn \"Executing command\"\n\tcase OperationSnapshotCreate:\n\t\treturn \"Snapshotting container\"\n\tcase OperationSnapshotRename:\n\t\treturn \"Renaming snapshot\"\n\tcase OperationSnapshotRestore:\n\t\treturn \"Restoring snapshot\"\n\tcase OperationSnapshotTransfer:\n\t\treturn \"Transferring snapshot\"\n\tcase OperationSnapshotUpdate:\n\t\treturn \"Updating snapshot\"\n\tcase OperationSnapshotDelete:\n\t\treturn \"Deleting snapshot\"\n\tcase OperationImageDownload:\n\t\treturn \"Downloading image\"\n\tcase OperationImageDelete:\n\t\treturn \"Deleting image\"\n\tcase OperationImageToken:\n\t\treturn \"Image download token\"\n\tcase OperationImageRefresh:\n\t\treturn \"Refreshing image\"\n\tcase OperationVolumeCopy:\n\t\treturn \"Copying storage volume\"\n\tcase OperationVolumeCreate:\n\t\treturn \"Creating storage volume\"\n\tcase OperationVolumeMigrate:\n\t\treturn \"Migrating storage volume\"\n\tcase OperationVolumeMove:\n\t\treturn \"Moving storage volume\"\n\tcase OperationVolumeSnapshotCreate:\n\t\treturn \"Creating storage volume snapshot\"\n\tcase OperationVolumeSnapshotDelete:\n\t\treturn \"Deleting storage volume snapshot\"\n\tcase OperationVolumeSnapshotUpdate:\n\t\treturn \"Updating storage volume snapshot\"\n\tcase OperationProjectRename:\n\t\treturn \"Renaming project\"\n\tcase OperationImagesExpire:\n\t\treturn \"Cleaning up expired images\"\n\tcase OperationImagesPruneLeftover:\n\t\treturn \"Pruning leftover image files\"\n\tcase OperationImagesUpdate:\n\t\treturn \"Updating images\"\n\tcase OperationImagesSynchronize:\n\t\treturn \"Synchronizing images\"\n\tcase OperationLogsExpire:\n\t\treturn \"Expiring log files\"\n\tcase OperationInstanceTypesUpdate:\n\t\treturn \"Updating instance types\"\n\tcase OperationBackupsExpire:\n\t\treturn \"Cleaning up expired backups\"\n\tcase OperationSnapshotsExpire:\n\t\treturn \"Cleaning up expired snapshots\"\n\tdefault:\n\t\treturn \"Executing operation\"\n\t}\n}", "code_tokens": ["func", "(", "t", "OperationType", ")", "Description", "(", ")", "string", "{", "switch", "t", "{", "case", "OperationClusterBootstrap", ":", "return", "\"", "\"", "\n", "case", "OperationClusterJoin", ":", "return", "\"", "\"", "\n", "case", "OperationBackupCreate", ":", "return", "\"", "\"", "\n", "case", "OperationBackupRename", ":", "return", "\"", "\"", "\n", "case", "OperationBackupRestore", ":", "return", "\"", "\"", "\n", "case", "OperationBackupRemove", ":", "return", "\"", "\"", "\n", "case", "OperationConsoleShow", ":", "return", "\"", "\"", "\n", "case", "OperationContainerCreate", ":", "return", "\"", "\"", "\n", "case", "OperationContainerUpdate", ":", "return", "\"", "\"", "\n", "case", "OperationContainerRename", ":", "return", "\"", "\"", "\n", "case", "OperationContainerMigrate", ":", "return", "\"", "\"", "\n", "case", "OperationContainerLiveMigrate", ":", "return", "\"", "\"", "\n", "case", "OperationContainerFreeze", ":", "return", "\"", "\"", "\n", "case", "OperationContainerUnfreeze", ":", "return", "\"", "\"", "\n", "case", "OperationContainerDelete", ":", "return", "\"", "\"", "\n", "case", "OperationContainerStart", ":", "return", "\"", "\"", "\n", "case", "OperationContainerStop", ":", "return", "\"", "\"", "\n", "case", "OperationContainerRestart", ":", "return", "\"", "\"", "\n", "case", "OperationCommandExec", ":", "return", "\"", "\"", "\n", "case", "OperationSnapshotCreate", ":", "return", "\"", "\"", "\n", "case", "OperationSnapshotRename", ":", "return", "\"", "\"", "\n", "case", "OperationSnapshotRestore", ":", "return", "\"", "\"", "\n", "case", "OperationSnapshotTransfer", ":", "return", "\"", "\"", "\n", "case", "OperationSnapshotUpdate", ":", "return", "\"", "\"", "\n", "case", "OperationSnapshotDelete", ":", "return", "\"", "\"", "\n", "case", "OperationImageDownload", ":", "return", "\"", "\"", "\n", "case", "OperationImageDelete", ":", "return", "\"", "\"", "\n", "case", "OperationImageToken", ":", "return", "\"", "\"", "\n", "case", "OperationImageRefresh", ":", "return", "\"", "\"", "\n", "case", "OperationVolumeCopy", ":", "return", "\"", "\"", "\n", "case", "OperationVolumeCreate", ":", "return", "\"", "\"", "\n", "case", "OperationVolumeMigrate", ":", "return", "\"", "\"", "\n", "case", "OperationVolumeMove", ":", "return", "\"", "\"", "\n", "case", "OperationVolumeSnapshotCreate", ":", "return", "\"", "\"", "\n", "case", "OperationVolumeSnapshotDelete", ":", "return", "\"", "\"", "\n", "case", "OperationVolumeSnapshotUpdate", ":", "return", "\"", "\"", "\n", "case", "OperationProjectRename", ":", "return", "\"", "\"", "\n", "case", "OperationImagesExpire", ":", "return", "\"", "\"", "\n", "case", "OperationImagesPruneLeftover", ":", "return", "\"", "\"", "\n", "case", "OperationImagesUpdate", ":", "return", "\"", "\"", "\n", "case", "OperationImagesSynchronize", ":", "return", "\"", "\"", "\n", "case", "OperationLogsExpire", ":", "return", "\"", "\"", "\n", "case", "OperationInstanceTypesUpdate", ":", "return", "\"", "\"", "\n", "case", "OperationBackupsExpire", ":", "return", "\"", "\"", "\n", "case", "OperationSnapshotsExpire", ":", "return", "\"", "\"", "\n", "default", ":", "return", "\"", "\"", "\n", "}", "\n", "}"], "docstring": "// Description return a human-readable description of the operation type.", "docstring_tokens": ["Description", "return", "a", "human", "-", "readable", "description", "of", "the", "operation", "type", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/operations.go#L68-L163", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "merge.go", "func_name": "GetMergeOperator", "original_string": "func (db *DB) GetMergeOperator(key []byte,\n\tf MergeFunc, dur time.Duration) *MergeOperator {\n\top := &MergeOperator{\n\t\tf:      f,\n\t\tdb:     db,\n\t\tkey:    key,\n\t\tcloser: y.NewCloser(1),\n\t}\n\n\tgo op.runCompactions(dur)\n\treturn op\n}", "language": "go", "code": "func (db *DB) GetMergeOperator(key []byte,\n\tf MergeFunc, dur time.Duration) *MergeOperator {\n\top := &MergeOperator{\n\t\tf:      f,\n\t\tdb:     db,\n\t\tkey:    key,\n\t\tcloser: y.NewCloser(1),\n\t}\n\n\tgo op.runCompactions(dur)\n\treturn op\n}", "code_tokens": ["func", "(", "db", "*", "DB", ")", "GetMergeOperator", "(", "key", "[", "]", "byte", ",", "f", "MergeFunc", ",", "dur", "time", ".", "Duration", ")", "*", "MergeOperator", "{", "op", ":=", "&", "MergeOperator", "{", "f", ":", "f", ",", "db", ":", "db", ",", "key", ":", "key", ",", "closer", ":", "y", ".", "NewCloser", "(", "1", ")", ",", "}", "\n\n", "go", "op", ".", "runCompactions", "(", "dur", ")", "\n", "return", "op", "\n", "}"], "docstring": "// GetMergeOperator creates a new MergeOperator for a given key and returns a\n// pointer to it. It also fires off a goroutine that performs a compaction using\n// the merge function that runs periodically, as specified by dur.", "docstring_tokens": ["GetMergeOperator", "creates", "a", "new", "MergeOperator", "for", "a", "given", "key", "and", "returns", "a", "pointer", "to", "it", ".", "It", "also", "fires", "off", "a", "goroutine", "that", "performs", "a", "compaction", "using", "the", "merge", "function", "that", "runs", "periodically", "as", "specified", "by", "dur", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/merge.go#L48-L59", "partition": "test"}
{"repo": "golang/appengine", "path": "blobstore/blobstore.go", "func_name": "UploadURL", "original_string": "func UploadURL(c context.Context, successPath string, opts *UploadURLOptions) (*url.URL, error) {\n\treq := &blobpb.CreateUploadURLRequest{\n\t\tSuccessPath: proto.String(successPath),\n\t}\n\tif opts != nil {\n\t\tif n := opts.MaxUploadBytes; n != 0 {\n\t\t\treq.MaxUploadSizeBytes = &n\n\t\t}\n\t\tif n := opts.MaxUploadBytesPerBlob; n != 0 {\n\t\t\treq.MaxUploadSizePerBlobBytes = &n\n\t\t}\n\t\tif s := opts.StorageBucket; s != \"\" {\n\t\t\treq.GsBucketName = &s\n\t\t}\n\t}\n\tres := &blobpb.CreateUploadURLResponse{}\n\tif err := internal.Call(c, \"blobstore\", \"CreateUploadURL\", req, res); err != nil {\n\t\treturn nil, err\n\t}\n\treturn url.Parse(*res.Url)\n}", "language": "go", "code": "func UploadURL(c context.Context, successPath string, opts *UploadURLOptions) (*url.URL, error) {\n\treq := &blobpb.CreateUploadURLRequest{\n\t\tSuccessPath: proto.String(successPath),\n\t}\n\tif opts != nil {\n\t\tif n := opts.MaxUploadBytes; n != 0 {\n\t\t\treq.MaxUploadSizeBytes = &n\n\t\t}\n\t\tif n := opts.MaxUploadBytesPerBlob; n != 0 {\n\t\t\treq.MaxUploadSizePerBlobBytes = &n\n\t\t}\n\t\tif s := opts.StorageBucket; s != \"\" {\n\t\t\treq.GsBucketName = &s\n\t\t}\n\t}\n\tres := &blobpb.CreateUploadURLResponse{}\n\tif err := internal.Call(c, \"blobstore\", \"CreateUploadURL\", req, res); err != nil {\n\t\treturn nil, err\n\t}\n\treturn url.Parse(*res.Url)\n}", "code_tokens": ["func", "UploadURL", "(", "c", "context", ".", "Context", ",", "successPath", "string", ",", "opts", "*", "UploadURLOptions", ")", "(", "*", "url", ".", "URL", ",", "error", ")", "{", "req", ":=", "&", "blobpb", ".", "CreateUploadURLRequest", "{", "SuccessPath", ":", "proto", ".", "String", "(", "successPath", ")", ",", "}", "\n", "if", "opts", "!=", "nil", "{", "if", "n", ":=", "opts", ".", "MaxUploadBytes", ";", "n", "!=", "0", "{", "req", ".", "MaxUploadSizeBytes", "=", "&", "n", "\n", "}", "\n", "if", "n", ":=", "opts", ".", "MaxUploadBytesPerBlob", ";", "n", "!=", "0", "{", "req", ".", "MaxUploadSizePerBlobBytes", "=", "&", "n", "\n", "}", "\n", "if", "s", ":=", "opts", ".", "StorageBucket", ";", "s", "!=", "\"", "\"", "{", "req", ".", "GsBucketName", "=", "&", "s", "\n", "}", "\n", "}", "\n", "res", ":=", "&", "blobpb", ".", "CreateUploadURLResponse", "{", "}", "\n", "if", "err", ":=", "internal", ".", "Call", "(", "c", ",", "\"", "\"", ",", "\"", "\"", ",", "req", ",", "res", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "url", ".", "Parse", "(", "*", "res", ".", "Url", ")", "\n", "}"], "docstring": "// UploadURL creates an upload URL for the form that the user will\n// fill out, passing the application path to load when the POST of the\n// form is completed. These URLs expire and should not be reused. The\n// opts parameter may be nil.", "docstring_tokens": ["UploadURL", "creates", "an", "upload", "URL", "for", "the", "form", "that", "the", "user", "will", "fill", "out", "passing", "the", "application", "path", "to", "load", "when", "the", "POST", "of", "the", "form", "is", "completed", ".", "These", "URLs", "expire", "and", "should", "not", "be", "reused", ".", "The", "opts", "parameter", "may", "be", "nil", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/blobstore/blobstore.go#L101-L121", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "typed/buffer.go", "func_name": "NewReadBufferWithSize", "original_string": "func NewReadBufferWithSize(size int) *ReadBuffer {\n\treturn &ReadBuffer{buffer: make([]byte, size), remaining: nil}\n}", "language": "go", "code": "func NewReadBufferWithSize(size int) *ReadBuffer {\n\treturn &ReadBuffer{buffer: make([]byte, size), remaining: nil}\n}", "code_tokens": ["func", "NewReadBufferWithSize", "(", "size", "int", ")", "*", "ReadBuffer", "{", "return", "&", "ReadBuffer", "{", "buffer", ":", "make", "(", "[", "]", "byte", ",", "size", ")", ",", "remaining", ":", "nil", "}", "\n", "}"], "docstring": "// NewReadBufferWithSize returns a ReadBuffer with a given capacity", "docstring_tokens": ["NewReadBufferWithSize", "returns", "a", "ReadBuffer", "with", "a", "given", "capacity"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/typed/buffer.go#L56-L58", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_networks.go", "func_name": "UpdateNetwork", "original_string": "func (r *ProtocolLXD) UpdateNetwork(name string, network api.NetworkPut, ETag string) error {\n\tif !r.HasExtension(\"network\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"network\\\" API extension\")\n\t}\n\n\t// Send the request\n\t_, _, err := r.query(\"PUT\", fmt.Sprintf(\"/networks/%s\", url.QueryEscape(name)), network, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (r *ProtocolLXD) UpdateNetwork(name string, network api.NetworkPut, ETag string) error {\n\tif !r.HasExtension(\"network\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"network\\\" API extension\")\n\t}\n\n\t// Send the request\n\t_, _, err := r.query(\"PUT\", fmt.Sprintf(\"/networks/%s\", url.QueryEscape(name)), network, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "UpdateNetwork", "(", "name", "string", ",", "network", "api", ".", "NetworkPut", ",", "ETag", "string", ")", "error", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "// Send the request", "_", ",", "_", ",", "err", ":=", "r", ".", "query", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "name", ")", ")", ",", "network", ",", "ETag", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// UpdateNetwork updates the network to match the provided Network struct", "docstring_tokens": ["UpdateNetwork", "updates", "the", "network", "to", "match", "the", "provided", "Network", "struct"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_networks.go#L119-L131", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/container_post.go", "func_name": "internalClusterContainerMovedPost", "original_string": "func internalClusterContainerMovedPost(d *Daemon, r *http.Request) Response {\n\tproject := projectParam(r)\n\tcontainerName := mux.Vars(r)[\"name\"]\n\terr := containerPostCreateContainerMountPoint(d, project, containerName)\n\tif err != nil {\n\t\treturn SmartError(err)\n\t}\n\treturn EmptySyncResponse\n}", "language": "go", "code": "func internalClusterContainerMovedPost(d *Daemon, r *http.Request) Response {\n\tproject := projectParam(r)\n\tcontainerName := mux.Vars(r)[\"name\"]\n\terr := containerPostCreateContainerMountPoint(d, project, containerName)\n\tif err != nil {\n\t\treturn SmartError(err)\n\t}\n\treturn EmptySyncResponse\n}", "code_tokens": ["func", "internalClusterContainerMovedPost", "(", "d", "*", "Daemon", ",", "r", "*", "http", ".", "Request", ")", "Response", "{", "project", ":=", "projectParam", "(", "r", ")", "\n", "containerName", ":=", "mux", ".", "Vars", "(", "r", ")", "[", "\"", "\"", "]", "\n", "err", ":=", "containerPostCreateContainerMountPoint", "(", "d", ",", "project", ",", "containerName", ")", "\n", "if", "err", "!=", "nil", "{", "return", "SmartError", "(", "err", ")", "\n", "}", "\n", "return", "EmptySyncResponse", "\n", "}"], "docstring": "// Notification that a container was moved.\n//\n// At the moment it's used for ceph-based containers, where the target node needs\n// to create the appropriate mount points.", "docstring_tokens": ["Notification", "that", "a", "container", "was", "moved", ".", "At", "the", "moment", "it", "s", "used", "for", "ceph", "-", "based", "containers", "where", "the", "target", "node", "needs", "to", "create", "the", "appropriate", "mount", "points", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/container_post.go#L505-L513", "partition": "test"}
{"repo": "enaml-ops/enaml", "path": "generators/generate.go", "func_name": "CreateNewRecord", "original_string": "func CreateNewRecord(property string, yaml enaml.JobManifestProperty) (record Record) {\n\telementArray := strings.Split(property, \".\")\n\trecord = Record{\n\t\tLength: len(elementArray),\n\t\tOrig:   property,\n\t\tSlice:  elementArray,\n\t\tYaml:   yaml,\n\t}\n\treturn\n}", "language": "go", "code": "func CreateNewRecord(property string, yaml enaml.JobManifestProperty) (record Record) {\n\telementArray := strings.Split(property, \".\")\n\trecord = Record{\n\t\tLength: len(elementArray),\n\t\tOrig:   property,\n\t\tSlice:  elementArray,\n\t\tYaml:   yaml,\n\t}\n\treturn\n}", "code_tokens": ["func", "CreateNewRecord", "(", "property", "string", ",", "yaml", "enaml", ".", "JobManifestProperty", ")", "(", "record", "Record", ")", "{", "elementArray", ":=", "strings", ".", "Split", "(", "property", ",", "\"", "\"", ")", "\n", "record", "=", "Record", "{", "Length", ":", "len", "(", "elementArray", ")", ",", "Orig", ":", "property", ",", "Slice", ":", "elementArray", ",", "Yaml", ":", "yaml", ",", "}", "\n", "return", "\n", "}"], "docstring": "//CreateNewRecord - creates a record from a given period delimited property and enaml.JobManifestProperty", "docstring_tokens": ["CreateNewRecord", "-", "creates", "a", "record", "from", "a", "given", "period", "delimited", "property", "and", "enaml", ".", "JobManifestProperty"], "sha": "4f847ee10b41afca41fe09fa839cb2f6ade06fb5", "url": "https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/generators/generate.go#L115-L124", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdctl/ctlv3/command/get_command.go", "func_name": "NewGetCommand", "original_string": "func NewGetCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"get [options] <key> [range_end]\",\n\t\tShort: \"Gets the key or a range of keys\",\n\t\tRun:   getCommandFunc,\n\t}\n\n\tcmd.Flags().StringVar(&getConsistency, \"consistency\", \"l\", \"Linearizable(l) or Serializable(s)\")\n\tcmd.Flags().StringVar(&getSortOrder, \"order\", \"\", \"Order of results; ASCEND or DESCEND (ASCEND by default)\")\n\tcmd.Flags().StringVar(&getSortTarget, \"sort-by\", \"\", \"Sort target; CREATE, KEY, MODIFY, VALUE, or VERSION\")\n\tcmd.Flags().Int64Var(&getLimit, \"limit\", 0, \"Maximum number of results\")\n\tcmd.Flags().BoolVar(&getPrefix, \"prefix\", false, \"Get keys with matching prefix\")\n\tcmd.Flags().BoolVar(&getFromKey, \"from-key\", false, \"Get keys that are greater than or equal to the given key using byte compare\")\n\tcmd.Flags().Int64Var(&getRev, \"rev\", 0, \"Specify the kv revision\")\n\tcmd.Flags().BoolVar(&getKeysOnly, \"keys-only\", false, \"Get only the keys\")\n\tcmd.Flags().BoolVar(&printValueOnly, \"print-value-only\", false, `Only write values when using the \"simple\" output format`)\n\treturn cmd\n}", "language": "go", "code": "func NewGetCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"get [options] <key> [range_end]\",\n\t\tShort: \"Gets the key or a range of keys\",\n\t\tRun:   getCommandFunc,\n\t}\n\n\tcmd.Flags().StringVar(&getConsistency, \"consistency\", \"l\", \"Linearizable(l) or Serializable(s)\")\n\tcmd.Flags().StringVar(&getSortOrder, \"order\", \"\", \"Order of results; ASCEND or DESCEND (ASCEND by default)\")\n\tcmd.Flags().StringVar(&getSortTarget, \"sort-by\", \"\", \"Sort target; CREATE, KEY, MODIFY, VALUE, or VERSION\")\n\tcmd.Flags().Int64Var(&getLimit, \"limit\", 0, \"Maximum number of results\")\n\tcmd.Flags().BoolVar(&getPrefix, \"prefix\", false, \"Get keys with matching prefix\")\n\tcmd.Flags().BoolVar(&getFromKey, \"from-key\", false, \"Get keys that are greater than or equal to the given key using byte compare\")\n\tcmd.Flags().Int64Var(&getRev, \"rev\", 0, \"Specify the kv revision\")\n\tcmd.Flags().BoolVar(&getKeysOnly, \"keys-only\", false, \"Get only the keys\")\n\tcmd.Flags().BoolVar(&printValueOnly, \"print-value-only\", false, `Only write values when using the \"simple\" output format`)\n\treturn cmd\n}", "code_tokens": ["func", "NewGetCommand", "(", ")", "*", "cobra", ".", "Command", "{", "cmd", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Run", ":", "getCommandFunc", ",", "}", "\n\n", "cmd", ".", "Flags", "(", ")", ".", "StringVar", "(", "&", "getConsistency", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "cmd", ".", "Flags", "(", ")", ".", "StringVar", "(", "&", "getSortOrder", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "cmd", ".", "Flags", "(", ")", ".", "StringVar", "(", "&", "getSortTarget", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "cmd", ".", "Flags", "(", ")", ".", "Int64Var", "(", "&", "getLimit", ",", "\"", "\"", ",", "0", ",", "\"", "\"", ")", "\n", "cmd", ".", "Flags", "(", ")", ".", "BoolVar", "(", "&", "getPrefix", ",", "\"", "\"", ",", "false", ",", "\"", "\"", ")", "\n", "cmd", ".", "Flags", "(", ")", ".", "BoolVar", "(", "&", "getFromKey", ",", "\"", "\"", ",", "false", ",", "\"", "\"", ")", "\n", "cmd", ".", "Flags", "(", ")", ".", "Int64Var", "(", "&", "getRev", ",", "\"", "\"", ",", "0", ",", "\"", "\"", ")", "\n", "cmd", ".", "Flags", "(", ")", ".", "BoolVar", "(", "&", "getKeysOnly", ",", "\"", "\"", ",", "false", ",", "\"", "\"", ")", "\n", "cmd", ".", "Flags", "(", ")", ".", "BoolVar", "(", "&", "printValueOnly", ",", "\"", "\"", ",", "false", ",", "`Only write values when using the \"simple\" output format`", ")", "\n", "return", "cmd", "\n", "}"], "docstring": "// NewGetCommand returns the cobra command for \"get\".", "docstring_tokens": ["NewGetCommand", "returns", "the", "cobra", "command", "for", "get", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv3/command/get_command.go#L38-L55", "partition": "test"}
{"repo": "golang/appengine", "path": "namespace.go", "func_name": "Namespace", "original_string": "func Namespace(c context.Context, namespace string) (context.Context, error) {\n\tif !validNamespace.MatchString(namespace) {\n\t\treturn nil, fmt.Errorf(\"appengine: namespace %q does not match /%s/\", namespace, validNamespace)\n\t}\n\treturn internal.NamespacedContext(c, namespace), nil\n}", "language": "go", "code": "func Namespace(c context.Context, namespace string) (context.Context, error) {\n\tif !validNamespace.MatchString(namespace) {\n\t\treturn nil, fmt.Errorf(\"appengine: namespace %q does not match /%s/\", namespace, validNamespace)\n\t}\n\treturn internal.NamespacedContext(c, namespace), nil\n}", "code_tokens": ["func", "Namespace", "(", "c", "context", ".", "Context", ",", "namespace", "string", ")", "(", "context", ".", "Context", ",", "error", ")", "{", "if", "!", "validNamespace", ".", "MatchString", "(", "namespace", ")", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "namespace", ",", "validNamespace", ")", "\n", "}", "\n", "return", "internal", ".", "NamespacedContext", "(", "c", ",", "namespace", ")", ",", "nil", "\n", "}"], "docstring": "// Namespace returns a replacement context that operates within the given namespace.", "docstring_tokens": ["Namespace", "returns", "a", "replacement", "context", "that", "operates", "within", "the", "given", "namespace", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/namespace.go#L17-L22", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_certificates.go", "func_name": "UpdateCertificate", "original_string": "func (r *ProtocolLXD) UpdateCertificate(fingerprint string, certificate api.CertificatePut, ETag string) error {\n\tif !r.HasExtension(\"certificate_update\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"certificate_update\\\" API extension\")\n\t}\n\n\t// Send the request\n\t_, _, err := r.query(\"PUT\", fmt.Sprintf(\"/certificates/%s\", url.QueryEscape(fingerprint)), certificate, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (r *ProtocolLXD) UpdateCertificate(fingerprint string, certificate api.CertificatePut, ETag string) error {\n\tif !r.HasExtension(\"certificate_update\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"certificate_update\\\" API extension\")\n\t}\n\n\t// Send the request\n\t_, _, err := r.query(\"PUT\", fmt.Sprintf(\"/certificates/%s\", url.QueryEscape(fingerprint)), certificate, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "UpdateCertificate", "(", "fingerprint", "string", ",", "certificate", "api", ".", "CertificatePut", ",", "ETag", "string", ")", "error", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "// Send the request", "_", ",", "_", ",", "err", ":=", "r", ".", "query", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "fingerprint", ")", ")", ",", "certificate", ",", "ETag", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// UpdateCertificate updates the certificate definition", "docstring_tokens": ["UpdateCertificate", "updates", "the", "certificate", "definition"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_certificates.go#L71-L83", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/approve/approvers/owners.go", "func_name": "temporaryUnapprovedFiles", "original_string": "func (o Owners) temporaryUnapprovedFiles(approvers sets.String) sets.String {\n\tap := NewApprovers(o)\n\tfor approver := range approvers {\n\t\tap.AddApprover(approver, \"\", false)\n\t}\n\treturn ap.UnapprovedFiles()\n}", "language": "go", "code": "func (o Owners) temporaryUnapprovedFiles(approvers sets.String) sets.String {\n\tap := NewApprovers(o)\n\tfor approver := range approvers {\n\t\tap.AddApprover(approver, \"\", false)\n\t}\n\treturn ap.UnapprovedFiles()\n}", "code_tokens": ["func", "(", "o", "Owners", ")", "temporaryUnapprovedFiles", "(", "approvers", "sets", ".", "String", ")", "sets", ".", "String", "{", "ap", ":=", "NewApprovers", "(", "o", ")", "\n", "for", "approver", ":=", "range", "approvers", "{", "ap", ".", "AddApprover", "(", "approver", ",", "\"", "\"", ",", "false", ")", "\n", "}", "\n", "return", "ap", ".", "UnapprovedFiles", "(", ")", "\n", "}"], "docstring": "// temporaryUnapprovedFiles returns the list of files that wouldn't be\n// approved by the given set of approvers.", "docstring_tokens": ["temporaryUnapprovedFiles", "returns", "the", "list", "of", "files", "that", "wouldn", "t", "be", "approved", "by", "the", "given", "set", "of", "approvers", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/approve/approvers/owners.go#L130-L136", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "table/builder.go", "func_name": "NewTableBuilder", "original_string": "func NewTableBuilder() *Builder {\n\treturn &Builder{\n\t\tkeyBuf:     newBuffer(1 << 20),\n\t\tbuf:        newBuffer(1 << 20),\n\t\tprevOffset: math.MaxUint32, // Used for the first element!\n\t}\n}", "language": "go", "code": "func NewTableBuilder() *Builder {\n\treturn &Builder{\n\t\tkeyBuf:     newBuffer(1 << 20),\n\t\tbuf:        newBuffer(1 << 20),\n\t\tprevOffset: math.MaxUint32, // Used for the first element!\n\t}\n}", "code_tokens": ["func", "NewTableBuilder", "(", ")", "*", "Builder", "{", "return", "&", "Builder", "{", "keyBuf", ":", "newBuffer", "(", "1", "<<", "20", ")", ",", "buf", ":", "newBuffer", "(", "1", "<<", "20", ")", ",", "prevOffset", ":", "math", ".", "MaxUint32", ",", "// Used for the first element!", "}", "\n", "}"], "docstring": "// NewTableBuilder makes a new TableBuilder.", "docstring_tokens": ["NewTableBuilder", "makes", "a", "new", "TableBuilder", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/table/builder.go#L86-L92", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "velodrome/token-counter/token-counter.go", "func_name": "CreateTokenHandlers", "original_string": "func CreateTokenHandlers(tokenFiles []string, influxdb *InfluxDB) ([]TokenHandler, error) {\n\ttokens := []TokenHandler{}\n\tfor _, tokenFile := range tokenFiles {\n\t\tf, err := os.Open(tokenFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Can't open token-file (%s): %s\", tokenFile, err)\n\t\t}\n\t\ttoken, err := CreateTokenHandler(f, influxdb)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Failed to create token (%s): %s\", tokenFile, err)\n\t\t}\n\t\ttokens = append(tokens, *token)\n\t}\n\treturn tokens, nil\n}", "language": "go", "code": "func CreateTokenHandlers(tokenFiles []string, influxdb *InfluxDB) ([]TokenHandler, error) {\n\ttokens := []TokenHandler{}\n\tfor _, tokenFile := range tokenFiles {\n\t\tf, err := os.Open(tokenFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Can't open token-file (%s): %s\", tokenFile, err)\n\t\t}\n\t\ttoken, err := CreateTokenHandler(f, influxdb)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Failed to create token (%s): %s\", tokenFile, err)\n\t\t}\n\t\ttokens = append(tokens, *token)\n\t}\n\treturn tokens, nil\n}", "code_tokens": ["func", "CreateTokenHandlers", "(", "tokenFiles", "[", "]", "string", ",", "influxdb", "*", "InfluxDB", ")", "(", "[", "]", "TokenHandler", ",", "error", ")", "{", "tokens", ":=", "[", "]", "TokenHandler", "{", "}", "\n", "for", "_", ",", "tokenFile", ":=", "range", "tokenFiles", "{", "f", ",", "err", ":=", "os", ".", "Open", "(", "tokenFile", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "tokenFile", ",", "err", ")", "\n", "}", "\n", "token", ",", "err", ":=", "CreateTokenHandler", "(", "f", ",", "influxdb", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "tokenFile", ",", "err", ")", "\n", "}", "\n", "tokens", "=", "append", "(", "tokens", ",", "*", "token", ")", "\n", "}", "\n", "return", "tokens", ",", "nil", "\n", "}"], "docstring": "// CreateTokenHandlers goes through the list of token files, and create handlers", "docstring_tokens": ["CreateTokenHandlers", "goes", "through", "the", "list", "of", "token", "files", "and", "create", "handlers"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/token-counter/token-counter.go#L97-L111", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "context.go", "func_name": "GetBodyJSON", "original_string": "func (ctx *Context) GetBodyJSON() {\n\tvar reqJSON map[string]interface{}\n\tbody, _ := ioutil.ReadAll(ctx.Request.Body)\n\tdefer ctx.Request.Body.Close()\n\tcType := ctx.Request.Header.Get(\"Content-Type\")\n\ta := strings.Split(cType, \";\")\n\tif a[0] == \"application/x-www-form-urlencoded\" {\n\t\treqJSON = make(map[string]interface{})\n\t\treqStr := string(body)\n\t\treqArr := strings.Split(reqStr, \"&\")\n\t\tfor _, v := range reqArr {\n\t\t\tparam := strings.Split(v, \"=\")\n\t\t\treqJSON[param[0]], _ = url.QueryUnescape(param[1])\n\t\t}\n\t} else {\n\t\tjson.Unmarshal(body, &reqJSON)\n\t}\n\tctx.BodyJSON = reqJSON\n}", "language": "go", "code": "func (ctx *Context) GetBodyJSON() {\n\tvar reqJSON map[string]interface{}\n\tbody, _ := ioutil.ReadAll(ctx.Request.Body)\n\tdefer ctx.Request.Body.Close()\n\tcType := ctx.Request.Header.Get(\"Content-Type\")\n\ta := strings.Split(cType, \";\")\n\tif a[0] == \"application/x-www-form-urlencoded\" {\n\t\treqJSON = make(map[string]interface{})\n\t\treqStr := string(body)\n\t\treqArr := strings.Split(reqStr, \"&\")\n\t\tfor _, v := range reqArr {\n\t\t\tparam := strings.Split(v, \"=\")\n\t\t\treqJSON[param[0]], _ = url.QueryUnescape(param[1])\n\t\t}\n\t} else {\n\t\tjson.Unmarshal(body, &reqJSON)\n\t}\n\tctx.BodyJSON = reqJSON\n}", "code_tokens": ["func", "(", "ctx", "*", "Context", ")", "GetBodyJSON", "(", ")", "{", "var", "reqJSON", "map", "[", "string", "]", "interface", "{", "}", "\n", "body", ",", "_", ":=", "ioutil", ".", "ReadAll", "(", "ctx", ".", "Request", ".", "Body", ")", "\n", "defer", "ctx", ".", "Request", ".", "Body", ".", "Close", "(", ")", "\n", "cType", ":=", "ctx", ".", "Request", ".", "Header", ".", "Get", "(", "\"", "\"", ")", "\n", "a", ":=", "strings", ".", "Split", "(", "cType", ",", "\"", "\"", ")", "\n", "if", "a", "[", "0", "]", "==", "\"", "\"", "{", "reqJSON", "=", "make", "(", "map", "[", "string", "]", "interface", "{", "}", ")", "\n", "reqStr", ":=", "string", "(", "body", ")", "\n", "reqArr", ":=", "strings", ".", "Split", "(", "reqStr", ",", "\"", "\"", ")", "\n", "for", "_", ",", "v", ":=", "range", "reqArr", "{", "param", ":=", "strings", ".", "Split", "(", "v", ",", "\"", "\"", ")", "\n", "reqJSON", "[", "param", "[", "0", "]", "]", ",", "_", "=", "url", ".", "QueryUnescape", "(", "param", "[", "1", "]", ")", "\n", "}", "\n", "}", "else", "{", "json", ".", "Unmarshal", "(", "body", ",", "&", "reqJSON", ")", "\n", "}", "\n", "ctx", ".", "BodyJSON", "=", "reqJSON", "\n", "}"], "docstring": "// GetBodyJSON return a json from body", "docstring_tokens": ["GetBodyJSON", "return", "a", "json", "from", "body"], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/context.go#L186-L204", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/namespace/watch.go", "func_name": "NewWatcher", "original_string": "func NewWatcher(w clientv3.Watcher, prefix string) clientv3.Watcher {\n\treturn &watcherPrefix{Watcher: w, pfx: prefix, stopc: make(chan struct{})}\n}", "language": "go", "code": "func NewWatcher(w clientv3.Watcher, prefix string) clientv3.Watcher {\n\treturn &watcherPrefix{Watcher: w, pfx: prefix, stopc: make(chan struct{})}\n}", "code_tokens": ["func", "NewWatcher", "(", "w", "clientv3", ".", "Watcher", ",", "prefix", "string", ")", "clientv3", ".", "Watcher", "{", "return", "&", "watcherPrefix", "{", "Watcher", ":", "w", ",", "pfx", ":", "prefix", ",", "stopc", ":", "make", "(", "chan", "struct", "{", "}", ")", "}", "\n", "}"], "docstring": "// NewWatcher wraps a Watcher instance so that all Watch requests\n// are prefixed with a given string and all Watch responses have\n// the prefix removed.", "docstring_tokens": ["NewWatcher", "wraps", "a", "Watcher", "instance", "so", "that", "all", "Watch", "requests", "are", "prefixed", "with", "a", "given", "string", "and", "all", "Watch", "responses", "have", "the", "prefix", "removed", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/namespace/watch.go#L36-L38", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/config.go", "func_name": "VerifyBootstrap", "original_string": "func (c *ServerConfig) VerifyBootstrap() error {\n\tif err := c.hasLocalMember(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.advertiseMatchesCluster(); err != nil {\n\t\treturn err\n\t}\n\tif checkDuplicateURL(c.InitialPeerURLsMap) {\n\t\treturn fmt.Errorf(\"initial cluster %s has duplicate url\", c.InitialPeerURLsMap)\n\t}\n\tif c.InitialPeerURLsMap.String() == \"\" && c.DiscoveryURL == \"\" {\n\t\treturn fmt.Errorf(\"initial cluster unset and no discovery URL found\")\n\t}\n\treturn nil\n}", "language": "go", "code": "func (c *ServerConfig) VerifyBootstrap() error {\n\tif err := c.hasLocalMember(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.advertiseMatchesCluster(); err != nil {\n\t\treturn err\n\t}\n\tif checkDuplicateURL(c.InitialPeerURLsMap) {\n\t\treturn fmt.Errorf(\"initial cluster %s has duplicate url\", c.InitialPeerURLsMap)\n\t}\n\tif c.InitialPeerURLsMap.String() == \"\" && c.DiscoveryURL == \"\" {\n\t\treturn fmt.Errorf(\"initial cluster unset and no discovery URL found\")\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "ServerConfig", ")", "VerifyBootstrap", "(", ")", "error", "{", "if", "err", ":=", "c", ".", "hasLocalMember", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "err", ":=", "c", ".", "advertiseMatchesCluster", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "checkDuplicateURL", "(", "c", ".", "InitialPeerURLsMap", ")", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "c", ".", "InitialPeerURLsMap", ")", "\n", "}", "\n", "if", "c", ".", "InitialPeerURLsMap", ".", "String", "(", ")", "==", "\"", "\"", "&&", "c", ".", "DiscoveryURL", "==", "\"", "\"", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// VerifyBootstrap sanity-checks the initial config for bootstrap case\n// and returns an error for things that should never happen.", "docstring_tokens": ["VerifyBootstrap", "sanity", "-", "checks", "the", "initial", "config", "for", "bootstrap", "case", "and", "returns", "an", "error", "for", "things", "that", "should", "never", "happen", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/config.go#L161-L175", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/images.go", "func_name": "ImageLastAccessUpdate", "original_string": "func (c *Cluster) ImageLastAccessUpdate(fingerprint string, date time.Time) error {\n\tstmt := `UPDATE images SET last_use_date=? WHERE fingerprint=?`\n\terr := exec(c.db, stmt, date, fingerprint)\n\treturn err\n}", "language": "go", "code": "func (c *Cluster) ImageLastAccessUpdate(fingerprint string, date time.Time) error {\n\tstmt := `UPDATE images SET last_use_date=? WHERE fingerprint=?`\n\terr := exec(c.db, stmt, date, fingerprint)\n\treturn err\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "ImageLastAccessUpdate", "(", "fingerprint", "string", ",", "date", "time", ".", "Time", ")", "error", "{", "stmt", ":=", "`UPDATE images SET last_use_date=? WHERE fingerprint=?`", "\n", "err", ":=", "exec", "(", "c", ".", "db", ",", "stmt", ",", "date", ",", "fingerprint", ")", "\n", "return", "err", "\n", "}"], "docstring": "// ImageLastAccessUpdate updates the last_use_date field of the image with the\n// given fingerprint.", "docstring_tokens": ["ImageLastAccessUpdate", "updates", "the", "last_use_date", "field", "of", "the", "image", "with", "the", "given", "fingerprint", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/images.go#L702-L706", "partition": "test"}
{"repo": "kjk/lzmadec", "path": "lzmadec.go", "func_name": "GetFileReader", "original_string": "func (a *Archive) GetFileReader(name string) (io.ReadCloser, error) {\n\tfound := false\n\tfor _, e := range a.Entries {\n\t\tif e.Path == name {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\treturn nil, errors.New(\"file not in the archive\")\n\t}\n\n\tparams := []string{\"x\", \"-so\"}\n\tif a.password != nil {\n\t\tparams = append(params, fmt.Sprintf(\"-p%s\", *a.password))\n\t}\n\tparams = append(params, a.Path, name)\n\n\tcmd := exec.Command(\"7z\", params...)\n\tstdout, err := cmd.StdoutPipe()\n\trc := &readCloser{\n\t\trc:  stdout,\n\t\tcmd: cmd,\n\t}\n\terr = cmd.Start()\n\tif err != nil {\n\t\tstdout.Close()\n\t\treturn nil, err\n\t}\n\treturn rc, nil\n}", "language": "go", "code": "func (a *Archive) GetFileReader(name string) (io.ReadCloser, error) {\n\tfound := false\n\tfor _, e := range a.Entries {\n\t\tif e.Path == name {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\treturn nil, errors.New(\"file not in the archive\")\n\t}\n\n\tparams := []string{\"x\", \"-so\"}\n\tif a.password != nil {\n\t\tparams = append(params, fmt.Sprintf(\"-p%s\", *a.password))\n\t}\n\tparams = append(params, a.Path, name)\n\n\tcmd := exec.Command(\"7z\", params...)\n\tstdout, err := cmd.StdoutPipe()\n\trc := &readCloser{\n\t\trc:  stdout,\n\t\tcmd: cmd,\n\t}\n\terr = cmd.Start()\n\tif err != nil {\n\t\tstdout.Close()\n\t\treturn nil, err\n\t}\n\treturn rc, nil\n}", "code_tokens": ["func", "(", "a", "*", "Archive", ")", "GetFileReader", "(", "name", "string", ")", "(", "io", ".", "ReadCloser", ",", "error", ")", "{", "found", ":=", "false", "\n", "for", "_", ",", "e", ":=", "range", "a", ".", "Entries", "{", "if", "e", ".", "Path", "==", "name", "{", "found", "=", "true", "\n", "break", "\n", "}", "\n", "}", "\n", "if", "!", "found", "{", "return", "nil", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n\n", "params", ":=", "[", "]", "string", "{", "\"", "\"", ",", "\"", "\"", "}", "\n", "if", "a", ".", "password", "!=", "nil", "{", "params", "=", "append", "(", "params", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "*", "a", ".", "password", ")", ")", "\n", "}", "\n", "params", "=", "append", "(", "params", ",", "a", ".", "Path", ",", "name", ")", "\n\n", "cmd", ":=", "exec", ".", "Command", "(", "\"", "\"", ",", "params", "...", ")", "\n", "stdout", ",", "err", ":=", "cmd", ".", "StdoutPipe", "(", ")", "\n", "rc", ":=", "&", "readCloser", "{", "rc", ":", "stdout", ",", "cmd", ":", "cmd", ",", "}", "\n", "err", "=", "cmd", ".", "Start", "(", ")", "\n", "if", "err", "!=", "nil", "{", "stdout", ".", "Close", "(", ")", "\n", "return", "nil", ",", "err", "\n", "}", "\n", "return", "rc", ",", "nil", "\n", "}"], "docstring": "// GetFileReader returns a reader for reading a given file", "docstring_tokens": ["GetFileReader", "returns", "a", "reader", "for", "reading", "a", "given", "file"], "sha": "4c61f00ce86f6f11ed9630fa16b771889b08147b", "url": "https://github.com/kjk/lzmadec/blob/4c61f00ce86f6f11ed9630fa16b771889b08147b/lzmadec.go#L238-L268", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/logging/log.go", "func_name": "AddContext", "original_string": "func AddContext(logger logger.Logger, ctx log.Ctx) logger.Logger {\n\tlog15logger, ok := logger.(log.Logger)\n\tif !ok {\n\t\tlogger.Error(\"couldn't downcast logger to add context\", log.Ctx{\"logger\": log15logger, \"ctx\": ctx})\n\t\treturn logger\n\t}\n\n\treturn log15logger.New(ctx)\n}", "language": "go", "code": "func AddContext(logger logger.Logger, ctx log.Ctx) logger.Logger {\n\tlog15logger, ok := logger.(log.Logger)\n\tif !ok {\n\t\tlogger.Error(\"couldn't downcast logger to add context\", log.Ctx{\"logger\": log15logger, \"ctx\": ctx})\n\t\treturn logger\n\t}\n\n\treturn log15logger.New(ctx)\n}", "code_tokens": ["func", "AddContext", "(", "logger", "logger", ".", "Logger", ",", "ctx", "log", ".", "Ctx", ")", "logger", ".", "Logger", "{", "log15logger", ",", "ok", ":=", "logger", ".", "(", "log", ".", "Logger", ")", "\n", "if", "!", "ok", "{", "logger", ".", "Error", "(", "\"", "\"", ",", "log", ".", "Ctx", "{", "\"", "\"", ":", "log15logger", ",", "\"", "\"", ":", "ctx", "}", ")", "\n", "return", "logger", "\n", "}", "\n\n", "return", "log15logger", ".", "New", "(", "ctx", ")", "\n", "}"], "docstring": "// AddContext will return a copy of the logger with extra context added", "docstring_tokens": ["AddContext", "will", "return", "a", "copy", "of", "the", "logger", "with", "extra", "context", "added"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/logging/log.go#L108-L116", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/hashtree/db.go", "func_name": "GetHashTreeObject", "original_string": "func GetHashTreeObject(pachClient *client.APIClient, storageRoot string, treeRef *pfs.Object) (HashTree, error) {\n\treturn getHashTree(storageRoot, func(w io.Writer) error {\n\t\treturn pachClient.GetObject(treeRef.Hash, w)\n\t})\n}", "language": "go", "code": "func GetHashTreeObject(pachClient *client.APIClient, storageRoot string, treeRef *pfs.Object) (HashTree, error) {\n\treturn getHashTree(storageRoot, func(w io.Writer) error {\n\t\treturn pachClient.GetObject(treeRef.Hash, w)\n\t})\n}", "code_tokens": ["func", "GetHashTreeObject", "(", "pachClient", "*", "client", ".", "APIClient", ",", "storageRoot", "string", ",", "treeRef", "*", "pfs", ".", "Object", ")", "(", "HashTree", ",", "error", ")", "{", "return", "getHashTree", "(", "storageRoot", ",", "func", "(", "w", "io", ".", "Writer", ")", "error", "{", "return", "pachClient", ".", "GetObject", "(", "treeRef", ".", "Hash", ",", "w", ")", "\n", "}", ")", "\n", "}"], "docstring": "// GetHashTreeObject is a convenience function to deserialize a HashTree from an object in the object store.", "docstring_tokens": ["GetHashTreeObject", "is", "a", "convenience", "function", "to", "deserialize", "a", "HashTree", "from", "an", "object", "in", "the", "object", "store", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/db.go#L1490-L1494", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pfs.go", "func_name": "BlockCommit", "original_string": "func (c APIClient) BlockCommit(repoName string, commitID string) (*pfs.CommitInfo, error) {\n\treturn c.inspectCommit(repoName, commitID, pfs.CommitState_FINISHED)\n}", "language": "go", "code": "func (c APIClient) BlockCommit(repoName string, commitID string) (*pfs.CommitInfo, error) {\n\treturn c.inspectCommit(repoName, commitID, pfs.CommitState_FINISHED)\n}", "code_tokens": ["func", "(", "c", "APIClient", ")", "BlockCommit", "(", "repoName", "string", ",", "commitID", "string", ")", "(", "*", "pfs", ".", "CommitInfo", ",", "error", ")", "{", "return", "c", ".", "inspectCommit", "(", "repoName", ",", "commitID", ",", "pfs", ".", "CommitState_FINISHED", ")", "\n", "}"], "docstring": "// BlockCommit returns info about a specific Commit, but blocks until that\n// commit has been finished.", "docstring_tokens": ["BlockCommit", "returns", "info", "about", "a", "specific", "Commit", "but", "blocks", "until", "that", "commit", "has", "been", "finished", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L234-L236", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "draw2dgl/gc.go", "func_name": "recalc", "original_string": "func (gc *GraphicContext) recalc() {\n\tgc.Current.Scale = gc.Current.FontSize * float64(gc.DPI) * (64.0 / 72.0)\n}", "language": "go", "code": "func (gc *GraphicContext) recalc() {\n\tgc.Current.Scale = gc.Current.FontSize * float64(gc.DPI) * (64.0 / 72.0)\n}", "code_tokens": ["func", "(", "gc", "*", "GraphicContext", ")", "recalc", "(", ")", "{", "gc", ".", "Current", ".", "Scale", "=", "gc", ".", "Current", ".", "FontSize", "*", "float64", "(", "gc", ".", "DPI", ")", "*", "(", "64.0", "/", "72.0", ")", "\n", "}"], "docstring": "// recalc recalculates scale and bounds values from the font size, screen\n// resolution and font metrics, and invalidates the glyph cache.", "docstring_tokens": ["recalc", "recalculates", "scale", "and", "bounds", "values", "from", "the", "font", "size", "screen", "resolution", "and", "font", "metrics", "and", "invalidates", "the", "glyph", "cache", "."], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dgl/gc.go#L297-L299", "partition": "test"}
{"repo": "256dpi/fire", "path": "context.go", "func_name": "String", "original_string": "func (o Operation) String() string {\n\tswitch o {\n\tcase List:\n\t\treturn \"List\"\n\tcase Find:\n\t\treturn \"Find\"\n\tcase Create:\n\t\treturn \"Create\"\n\tcase Update:\n\t\treturn \"Update\"\n\tcase Delete:\n\t\treturn \"Delete\"\n\tcase CollectionAction:\n\t\treturn \"CollectionAction\"\n\tcase ResourceAction:\n\t\treturn \"ResourceAction\"\n\t}\n\n\treturn \"\"\n}", "language": "go", "code": "func (o Operation) String() string {\n\tswitch o {\n\tcase List:\n\t\treturn \"List\"\n\tcase Find:\n\t\treturn \"Find\"\n\tcase Create:\n\t\treturn \"Create\"\n\tcase Update:\n\t\treturn \"Update\"\n\tcase Delete:\n\t\treturn \"Delete\"\n\tcase CollectionAction:\n\t\treturn \"CollectionAction\"\n\tcase ResourceAction:\n\t\treturn \"ResourceAction\"\n\t}\n\n\treturn \"\"\n}", "code_tokens": ["func", "(", "o", "Operation", ")", "String", "(", ")", "string", "{", "switch", "o", "{", "case", "List", ":", "return", "\"", "\"", "\n", "case", "Find", ":", "return", "\"", "\"", "\n", "case", "Create", ":", "return", "\"", "\"", "\n", "case", "Update", ":", "return", "\"", "\"", "\n", "case", "Delete", ":", "return", "\"", "\"", "\n", "case", "CollectionAction", ":", "return", "\"", "\"", "\n", "case", "ResourceAction", ":", "return", "\"", "\"", "\n", "}", "\n\n", "return", "\"", "\"", "\n", "}"], "docstring": "// String returns the name of the operation.", "docstring_tokens": ["String", "returns", "the", "name", "of", "the", "operation", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/context.go#L73-L92", "partition": "test"}
{"repo": "rightscale/rsc", "path": "gen/api15gen/api_analyzer.go", "func_name": "NewAPIAnalyzer", "original_string": "func NewAPIAnalyzer(resources map[string]interface{}, attributeTypes map[string]string) *APIAnalyzer {\n\treturn &APIAnalyzer{\n\t\trawResources:   resources,\n\t\tattributeTypes: attributeTypes,\n\t\trawTypes:       make(map[string][]*gen.ObjectDataType),\n\t}\n}", "language": "go", "code": "func NewAPIAnalyzer(resources map[string]interface{}, attributeTypes map[string]string) *APIAnalyzer {\n\treturn &APIAnalyzer{\n\t\trawResources:   resources,\n\t\tattributeTypes: attributeTypes,\n\t\trawTypes:       make(map[string][]*gen.ObjectDataType),\n\t}\n}", "code_tokens": ["func", "NewAPIAnalyzer", "(", "resources", "map", "[", "string", "]", "interface", "{", "}", ",", "attributeTypes", "map", "[", "string", "]", "string", ")", "*", "APIAnalyzer", "{", "return", "&", "APIAnalyzer", "{", "rawResources", ":", "resources", ",", "attributeTypes", ":", "attributeTypes", ",", "rawTypes", ":", "make", "(", "map", "[", "string", "]", "[", "]", "*", "gen", ".", "ObjectDataType", ")", ",", "}", "\n", "}"], "docstring": "// NewAPIAnalyzer is the factory method for the API analyzer", "docstring_tokens": ["NewAPIAnalyzer", "is", "the", "factory", "method", "for", "the", "API", "analyzer"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/api15gen/api_analyzer.go#L39-L45", "partition": "test"}
{"repo": "golang/appengine", "path": "user/user_vm.go", "func_name": "Current", "original_string": "func Current(c context.Context) *User {\n\th := internal.IncomingHeaders(c)\n\tu := &User{\n\t\tEmail:             h.Get(\"X-AppEngine-User-Email\"),\n\t\tAuthDomain:        h.Get(\"X-AppEngine-Auth-Domain\"),\n\t\tID:                h.Get(\"X-AppEngine-User-Id\"),\n\t\tAdmin:             h.Get(\"X-AppEngine-User-Is-Admin\") == \"1\",\n\t\tFederatedIdentity: h.Get(\"X-AppEngine-Federated-Identity\"),\n\t\tFederatedProvider: h.Get(\"X-AppEngine-Federated-Provider\"),\n\t}\n\tif u.Email == \"\" && u.FederatedIdentity == \"\" {\n\t\treturn nil\n\t}\n\treturn u\n}", "language": "go", "code": "func Current(c context.Context) *User {\n\th := internal.IncomingHeaders(c)\n\tu := &User{\n\t\tEmail:             h.Get(\"X-AppEngine-User-Email\"),\n\t\tAuthDomain:        h.Get(\"X-AppEngine-Auth-Domain\"),\n\t\tID:                h.Get(\"X-AppEngine-User-Id\"),\n\t\tAdmin:             h.Get(\"X-AppEngine-User-Is-Admin\") == \"1\",\n\t\tFederatedIdentity: h.Get(\"X-AppEngine-Federated-Identity\"),\n\t\tFederatedProvider: h.Get(\"X-AppEngine-Federated-Provider\"),\n\t}\n\tif u.Email == \"\" && u.FederatedIdentity == \"\" {\n\t\treturn nil\n\t}\n\treturn u\n}", "code_tokens": ["func", "Current", "(", "c", "context", ".", "Context", ")", "*", "User", "{", "h", ":=", "internal", ".", "IncomingHeaders", "(", "c", ")", "\n", "u", ":=", "&", "User", "{", "Email", ":", "h", ".", "Get", "(", "\"", "\"", ")", ",", "AuthDomain", ":", "h", ".", "Get", "(", "\"", "\"", ")", ",", "ID", ":", "h", ".", "Get", "(", "\"", "\"", ")", ",", "Admin", ":", "h", ".", "Get", "(", "\"", "\"", ")", "==", "\"", "\"", ",", "FederatedIdentity", ":", "h", ".", "Get", "(", "\"", "\"", ")", ",", "FederatedProvider", ":", "h", ".", "Get", "(", "\"", "\"", ")", ",", "}", "\n", "if", "u", ".", "Email", "==", "\"", "\"", "&&", "u", ".", "FederatedIdentity", "==", "\"", "\"", "{", "return", "nil", "\n", "}", "\n", "return", "u", "\n", "}"], "docstring": "// Current returns the currently logged-in user,\n// or nil if the user is not signed in.", "docstring_tokens": ["Current", "returns", "the", "currently", "logged", "-", "in", "user", "or", "nil", "if", "the", "user", "is", "not", "signed", "in", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/user/user_vm.go#L17-L31", "partition": "test"}
{"repo": "olorin/nagiosplugin", "path": "check.go", "func_name": "String", "original_string": "func (c Check) String() string {\n\tvalue := fmt.Sprintf(\"%v: %s\", c.status, c.exitInfoText())\n\tvalue += RenderPerfdata(c.perfdata)\n\treturn value\n}", "language": "go", "code": "func (c Check) String() string {\n\tvalue := fmt.Sprintf(\"%v: %s\", c.status, c.exitInfoText())\n\tvalue += RenderPerfdata(c.perfdata)\n\treturn value\n}", "code_tokens": ["func", "(", "c", "Check", ")", "String", "(", ")", "string", "{", "value", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "c", ".", "status", ",", "c", ".", "exitInfoText", "(", ")", ")", "\n", "value", "+=", "RenderPerfdata", "(", "c", ".", "perfdata", ")", "\n", "return", "value", "\n", "}"], "docstring": "// String representation of the check results, suitable for output and\n// parsing by Nagios.", "docstring_tokens": ["String", "representation", "of", "the", "check", "results", "suitable", "for", "output", "and", "parsing", "by", "Nagios", "."], "sha": "893f9702af4ea1e2dc4cd6528cbdcdb3dc7ca064", "url": "https://github.com/olorin/nagiosplugin/blob/893f9702af4ea1e2dc4cd6528cbdcdb3dc7ca064/check.go#L125-L129", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "cmd/client.go", "func_name": "StreamJSONResponse", "original_string": "func StreamJSONResponse(w io.Writer, response *http.Response) error {\n\tif response == nil {\n\t\treturn errors.New(\"response cannot be nil\")\n\t}\n\tdefer response.Body.Close()\n\tvar err error\n\toutput := tsuruio.NewStreamWriter(w, nil)\n\tfor n := int64(1); n > 0 && err == nil; n, err = io.Copy(output, response.Body) {\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tunparsed := output.Remaining()\n\tif len(unparsed) > 0 {\n\t\treturn errors.Errorf(\"unparsed message error: %s\", string(unparsed))\n\t}\n\treturn nil\n}", "language": "go", "code": "func StreamJSONResponse(w io.Writer, response *http.Response) error {\n\tif response == nil {\n\t\treturn errors.New(\"response cannot be nil\")\n\t}\n\tdefer response.Body.Close()\n\tvar err error\n\toutput := tsuruio.NewStreamWriter(w, nil)\n\tfor n := int64(1); n > 0 && err == nil; n, err = io.Copy(output, response.Body) {\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tunparsed := output.Remaining()\n\tif len(unparsed) > 0 {\n\t\treturn errors.Errorf(\"unparsed message error: %s\", string(unparsed))\n\t}\n\treturn nil\n}", "code_tokens": ["func", "StreamJSONResponse", "(", "w", "io", ".", "Writer", ",", "response", "*", "http", ".", "Response", ")", "error", "{", "if", "response", "==", "nil", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "defer", "response", ".", "Body", ".", "Close", "(", ")", "\n", "var", "err", "error", "\n", "output", ":=", "tsuruio", ".", "NewStreamWriter", "(", "w", ",", "nil", ")", "\n", "for", "n", ":=", "int64", "(", "1", ")", ";", "n", ">", "0", "&&", "err", "==", "nil", ";", "n", ",", "err", "=", "io", ".", "Copy", "(", "output", ",", "response", ".", "Body", ")", "{", "}", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "unparsed", ":=", "output", ".", "Remaining", "(", ")", "\n", "if", "len", "(", "unparsed", ")", ">", "0", "{", "return", "errors", ".", "Errorf", "(", "\"", "\"", ",", "string", "(", "unparsed", ")", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// StreamJSONResponse supports the JSON streaming format from the tsuru API.", "docstring_tokens": ["StreamJSONResponse", "supports", "the", "JSON", "streaming", "format", "from", "the", "tsuru", "API", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/cmd/client.go#L133-L150", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nitro.go", "func_name": "Close", "original_string": "func (m *Nitro) Close() {\n\t// Wait until all snapshot iterators have finished\n\tfor s := m.snapshots.GetStats(); int(s.NodeCount) != 0; s = m.snapshots.GetStats() {\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\n\tm.hasShutdown = true\n\n\t// Acquire gc chan ownership\n\t// This will make sure that no other goroutine will write to gcchan\n\tfor !atomic.CompareAndSwapInt32(&m.isGCRunning, 0, 1) {\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\tclose(m.gcchan)\n\n\tbuf := dbInstances.MakeBuf()\n\tdefer dbInstances.FreeBuf(buf)\n\tdbInstances.Delete(unsafe.Pointer(m), CompareNitro, buf, &dbInstances.Stats)\n\n\tif m.useMemoryMgmt {\n\t\tbuf := m.snapshots.MakeBuf()\n\t\tdefer m.snapshots.FreeBuf(buf)\n\n\t\tm.shutdownWg1.Wait()\n\t\tclose(m.freechan)\n\t\tm.shutdownWg2.Wait()\n\n\t\t// Manually free up all nodes\n\t\titer := m.store.NewIterator(m.iterCmp, buf)\n\t\tdefer iter.Close()\n\t\tvar lastNode *skiplist.Node\n\n\t\titer.SeekFirst()\n\t\tif iter.Valid() {\n\t\t\tlastNode = iter.GetNode()\n\t\t\titer.Next()\n\t\t}\n\n\t\tfor lastNode != nil {\n\t\t\tm.freeItem((*Item)(lastNode.Item()))\n\t\t\tm.store.FreeNode(lastNode, &m.store.Stats)\n\t\t\tlastNode = nil\n\n\t\t\tif iter.Valid() {\n\t\t\t\tlastNode = iter.GetNode()\n\t\t\t\titer.Next()\n\t\t\t}\n\t\t}\n\t}\n}", "language": "go", "code": "func (m *Nitro) Close() {\n\t// Wait until all snapshot iterators have finished\n\tfor s := m.snapshots.GetStats(); int(s.NodeCount) != 0; s = m.snapshots.GetStats() {\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\n\tm.hasShutdown = true\n\n\t// Acquire gc chan ownership\n\t// This will make sure that no other goroutine will write to gcchan\n\tfor !atomic.CompareAndSwapInt32(&m.isGCRunning, 0, 1) {\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\tclose(m.gcchan)\n\n\tbuf := dbInstances.MakeBuf()\n\tdefer dbInstances.FreeBuf(buf)\n\tdbInstances.Delete(unsafe.Pointer(m), CompareNitro, buf, &dbInstances.Stats)\n\n\tif m.useMemoryMgmt {\n\t\tbuf := m.snapshots.MakeBuf()\n\t\tdefer m.snapshots.FreeBuf(buf)\n\n\t\tm.shutdownWg1.Wait()\n\t\tclose(m.freechan)\n\t\tm.shutdownWg2.Wait()\n\n\t\t// Manually free up all nodes\n\t\titer := m.store.NewIterator(m.iterCmp, buf)\n\t\tdefer iter.Close()\n\t\tvar lastNode *skiplist.Node\n\n\t\titer.SeekFirst()\n\t\tif iter.Valid() {\n\t\t\tlastNode = iter.GetNode()\n\t\t\titer.Next()\n\t\t}\n\n\t\tfor lastNode != nil {\n\t\t\tm.freeItem((*Item)(lastNode.Item()))\n\t\t\tm.store.FreeNode(lastNode, &m.store.Stats)\n\t\t\tlastNode = nil\n\n\t\t\tif iter.Valid() {\n\t\t\t\tlastNode = iter.GetNode()\n\t\t\t\titer.Next()\n\t\t\t}\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "m", "*", "Nitro", ")", "Close", "(", ")", "{", "// Wait until all snapshot iterators have finished", "for", "s", ":=", "m", ".", "snapshots", ".", "GetStats", "(", ")", ";", "int", "(", "s", ".", "NodeCount", ")", "!=", "0", ";", "s", "=", "m", ".", "snapshots", ".", "GetStats", "(", ")", "{", "time", ".", "Sleep", "(", "time", ".", "Millisecond", ")", "\n", "}", "\n\n", "m", ".", "hasShutdown", "=", "true", "\n\n", "// Acquire gc chan ownership", "// This will make sure that no other goroutine will write to gcchan", "for", "!", "atomic", ".", "CompareAndSwapInt32", "(", "&", "m", ".", "isGCRunning", ",", "0", ",", "1", ")", "{", "time", ".", "Sleep", "(", "time", ".", "Millisecond", ")", "\n", "}", "\n", "close", "(", "m", ".", "gcchan", ")", "\n\n", "buf", ":=", "dbInstances", ".", "MakeBuf", "(", ")", "\n", "defer", "dbInstances", ".", "FreeBuf", "(", "buf", ")", "\n", "dbInstances", ".", "Delete", "(", "unsafe", ".", "Pointer", "(", "m", ")", ",", "CompareNitro", ",", "buf", ",", "&", "dbInstances", ".", "Stats", ")", "\n\n", "if", "m", ".", "useMemoryMgmt", "{", "buf", ":=", "m", ".", "snapshots", ".", "MakeBuf", "(", ")", "\n", "defer", "m", ".", "snapshots", ".", "FreeBuf", "(", "buf", ")", "\n\n", "m", ".", "shutdownWg1", ".", "Wait", "(", ")", "\n", "close", "(", "m", ".", "freechan", ")", "\n", "m", ".", "shutdownWg2", ".", "Wait", "(", ")", "\n\n", "// Manually free up all nodes", "iter", ":=", "m", ".", "store", ".", "NewIterator", "(", "m", ".", "iterCmp", ",", "buf", ")", "\n", "defer", "iter", ".", "Close", "(", ")", "\n", "var", "lastNode", "*", "skiplist", ".", "Node", "\n\n", "iter", ".", "SeekFirst", "(", ")", "\n", "if", "iter", ".", "Valid", "(", ")", "{", "lastNode", "=", "iter", ".", "GetNode", "(", ")", "\n", "iter", ".", "Next", "(", ")", "\n", "}", "\n\n", "for", "lastNode", "!=", "nil", "{", "m", ".", "freeItem", "(", "(", "*", "Item", ")", "(", "lastNode", ".", "Item", "(", ")", ")", ")", "\n", "m", ".", "store", ".", "FreeNode", "(", "lastNode", ",", "&", "m", ".", "store", ".", "Stats", ")", "\n", "lastNode", "=", "nil", "\n\n", "if", "iter", ".", "Valid", "(", ")", "{", "lastNode", "=", "iter", ".", "GetNode", "(", ")", "\n", "iter", ".", "Next", "(", ")", "\n", "}", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// Close shuts down the nitro instance", "docstring_tokens": ["Close", "shuts", "down", "the", "nitro", "instance"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nitro.go#L416-L465", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "rule/rule.go", "func_name": "Remove", "original_string": "func (l *Load) Remove(sym string) {\n\tif _, ok := l.symbols[sym]; ok {\n\t\tdelete(l.symbols, sym)\n\t\tl.updated = true\n\t}\n}", "language": "go", "code": "func (l *Load) Remove(sym string) {\n\tif _, ok := l.symbols[sym]; ok {\n\t\tdelete(l.symbols, sym)\n\t\tl.updated = true\n\t}\n}", "code_tokens": ["func", "(", "l", "*", "Load", ")", "Remove", "(", "sym", "string", ")", "{", "if", "_", ",", "ok", ":=", "l", ".", "symbols", "[", "sym", "]", ";", "ok", "{", "delete", "(", "l", ".", "symbols", ",", "sym", ")", "\n", "l", ".", "updated", "=", "true", "\n", "}", "\n", "}"], "docstring": "// Remove deletes a symbol from the load statement. This has no effect if\n// the symbol is not loaded.", "docstring_tokens": ["Remove", "deletes", "a", "symbol", "from", "the", "load", "statement", ".", "This", "has", "no", "effect", "if", "the", "symbol", "is", "not", "loaded", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/rule/rule.go#L486-L491", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "runtime/runtime.go", "func_name": "WithObjectID", "original_string": "func (p CallFunctionOnParams) WithObjectID(objectID RemoteObjectID) *CallFunctionOnParams {\n\tp.ObjectID = objectID\n\treturn &p\n}", "language": "go", "code": "func (p CallFunctionOnParams) WithObjectID(objectID RemoteObjectID) *CallFunctionOnParams {\n\tp.ObjectID = objectID\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "CallFunctionOnParams", ")", "WithObjectID", "(", "objectID", "RemoteObjectID", ")", "*", "CallFunctionOnParams", "{", "p", ".", "ObjectID", "=", "objectID", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithObjectID identifier of the object to call function on. Either objectId\n// or executionContextId should be specified.", "docstring_tokens": ["WithObjectID", "identifier", "of", "the", "object", "to", "call", "function", "on", ".", "Either", "objectId", "or", "executionContextId", "should", "be", "specified", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/runtime/runtime.go#L106-L109", "partition": "test"}
{"repo": "ChrisTrenkamp/goxpath", "path": "tree/tree.go", "func_name": "GetAttribute", "original_string": "func GetAttribute(n Elem, local, space string) (xml.Attr, bool) {\n\tattrs := n.GetAttrs()\n\tfor _, i := range attrs {\n\t\tattr := i.GetToken().(xml.Attr)\n\t\tif local == attr.Name.Local && space == attr.Name.Space {\n\t\t\treturn attr, true\n\t\t}\n\t}\n\treturn xml.Attr{}, false\n}", "language": "go", "code": "func GetAttribute(n Elem, local, space string) (xml.Attr, bool) {\n\tattrs := n.GetAttrs()\n\tfor _, i := range attrs {\n\t\tattr := i.GetToken().(xml.Attr)\n\t\tif local == attr.Name.Local && space == attr.Name.Space {\n\t\t\treturn attr, true\n\t\t}\n\t}\n\treturn xml.Attr{}, false\n}", "code_tokens": ["func", "GetAttribute", "(", "n", "Elem", ",", "local", ",", "space", "string", ")", "(", "xml", ".", "Attr", ",", "bool", ")", "{", "attrs", ":=", "n", ".", "GetAttrs", "(", ")", "\n", "for", "_", ",", "i", ":=", "range", "attrs", "{", "attr", ":=", "i", ".", "GetToken", "(", ")", ".", "(", "xml", ".", "Attr", ")", "\n", "if", "local", "==", "attr", ".", "Name", ".", "Local", "&&", "space", "==", "attr", ".", "Name", ".", "Space", "{", "return", "attr", ",", "true", "\n", "}", "\n", "}", "\n", "return", "xml", ".", "Attr", "{", "}", ",", "false", "\n", "}"], "docstring": "//GetAttribute is a convenience function for getting the specified attribute from an element.\n//false is returned if the attribute is not found.", "docstring_tokens": ["GetAttribute", "is", "a", "convenience", "function", "for", "getting", "the", "specified", "attribute", "from", "an", "element", ".", "false", "is", "returned", "if", "the", "attribute", "is", "not", "found", "."], "sha": "c385f95c6022e7756e91beac5f5510872f7dcb7d", "url": "https://github.com/ChrisTrenkamp/goxpath/blob/c385f95c6022e7756e91beac5f5510872f7dcb7d/tree/tree.go#L157-L166", "partition": "test"}
{"repo": "pivotal-pez/pezdispenser", "path": "fakes/fake.go", "func_name": "Auth", "original_string": "func (s *FakeVCDClient) Auth(username, password string) (err error) {\n\treturn s.ErrAuthFake\n}", "language": "go", "code": "func (s *FakeVCDClient) Auth(username, password string) (err error) {\n\treturn s.ErrAuthFake\n}", "code_tokens": ["func", "(", "s", "*", "FakeVCDClient", ")", "Auth", "(", "username", ",", "password", "string", ")", "(", "err", "error", ")", "{", "return", "s", ".", "ErrAuthFake", "\n", "}"], "docstring": "//Auth - fake out making an auth call", "docstring_tokens": ["Auth", "-", "fake", "out", "making", "an", "auth", "call"], "sha": "768e2777520868857916b66cfd4cfb7149383ca5", "url": "https://github.com/pivotal-pez/pezdispenser/blob/768e2777520868857916b66cfd4cfb7149383ca5/fakes/fake.go#L130-L132", "partition": "test"}
{"repo": "justinfx/gofileseq", "path": "sequence.go", "func_name": "FrameRangePadded", "original_string": "func (s *FileSequence) FrameRangePadded() string {\n\tif s.frameSet == nil {\n\t\treturn \"\"\n\t}\n\treturn s.frameSet.FrameRangePadded(s.zfill)\n}", "language": "go", "code": "func (s *FileSequence) FrameRangePadded() string {\n\tif s.frameSet == nil {\n\t\treturn \"\"\n\t}\n\treturn s.frameSet.FrameRangePadded(s.zfill)\n}", "code_tokens": ["func", "(", "s", "*", "FileSequence", ")", "FrameRangePadded", "(", ")", "string", "{", "if", "s", ".", "frameSet", "==", "nil", "{", "return", "\"", "\"", "\n", "}", "\n", "return", "s", ".", "frameSet", ".", "FrameRangePadded", "(", "s", ".", "zfill", ")", "\n", "}"], "docstring": "// FrameRangePadded returns the string frame range component,\n// parsed from the sequence, and padded out by the pad characters.\n// If no frame range was parsed, then this method will return an empty string.", "docstring_tokens": ["FrameRangePadded", "returns", "the", "string", "frame", "range", "component", "parsed", "from", "the", "sequence", "and", "padded", "out", "by", "the", "pad", "characters", ".", "If", "no", "frame", "range", "was", "parsed", "then", "this", "method", "will", "return", "an", "empty", "string", "."], "sha": "2555f296b4493d1825f5f6fab4aa0ff51a8306cd", "url": "https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/sequence.go#L306-L311", "partition": "test"}
{"repo": "xwb1989/sqlparser", "path": "token.go", "func_name": "skipStatement", "original_string": "func (tkn *Tokenizer) skipStatement() {\n\tch := tkn.lastChar\n\tfor ch != ';' && ch != eofChar {\n\t\ttkn.next()\n\t\tch = tkn.lastChar\n\t}\n}", "language": "go", "code": "func (tkn *Tokenizer) skipStatement() {\n\tch := tkn.lastChar\n\tfor ch != ';' && ch != eofChar {\n\t\ttkn.next()\n\t\tch = tkn.lastChar\n\t}\n}", "code_tokens": ["func", "(", "tkn", "*", "Tokenizer", ")", "skipStatement", "(", ")", "{", "ch", ":=", "tkn", ".", "lastChar", "\n", "for", "ch", "!=", "';'", "&&", "ch", "!=", "eofChar", "{", "tkn", ".", "next", "(", ")", "\n", "ch", "=", "tkn", ".", "lastChar", "\n", "}", "\n", "}"], "docstring": "// skipStatement scans until the EOF, or end of statement is encountered.", "docstring_tokens": ["skipStatement", "scans", "until", "the", "EOF", "or", "end", "of", "statement", "is", "encountered", "."], "sha": "120387863bf27d04bc07db8015110a6e96d0146c", "url": "https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/token.go#L609-L615", "partition": "test"}
{"repo": "ChrisTrenkamp/goxpath", "path": "parser/parser.go", "func_name": "Parse", "original_string": "func Parse(xp string) (*Node, error) {\n\tvar err error\n\tc := lexer.Lex(xp)\n\tn := &Node{}\n\tp := &parseStack{cur: n}\n\n\tfor next := range c {\n\t\tif next.Typ != lexer.XItemError {\n\t\t\tparseMap[next.Typ](p, next)\n\t\t} else if err == nil {\n\t\t\terr = fmt.Errorf(next.Val)\n\t\t}\n\t}\n\n\treturn n, err\n}", "language": "go", "code": "func Parse(xp string) (*Node, error) {\n\tvar err error\n\tc := lexer.Lex(xp)\n\tn := &Node{}\n\tp := &parseStack{cur: n}\n\n\tfor next := range c {\n\t\tif next.Typ != lexer.XItemError {\n\t\t\tparseMap[next.Typ](p, next)\n\t\t} else if err == nil {\n\t\t\terr = fmt.Errorf(next.Val)\n\t\t}\n\t}\n\n\treturn n, err\n}", "code_tokens": ["func", "Parse", "(", "xp", "string", ")", "(", "*", "Node", ",", "error", ")", "{", "var", "err", "error", "\n", "c", ":=", "lexer", ".", "Lex", "(", "xp", ")", "\n", "n", ":=", "&", "Node", "{", "}", "\n", "p", ":=", "&", "parseStack", "{", "cur", ":", "n", "}", "\n\n", "for", "next", ":=", "range", "c", "{", "if", "next", ".", "Typ", "!=", "lexer", ".", "XItemError", "{", "parseMap", "[", "next", ".", "Typ", "]", "(", "p", ",", "next", ")", "\n", "}", "else", "if", "err", "==", "nil", "{", "err", "=", "fmt", ".", "Errorf", "(", "next", ".", "Val", ")", "\n", "}", "\n", "}", "\n\n", "return", "n", ",", "err", "\n", "}"], "docstring": "//Parse creates an AST tree for XPath expressions.", "docstring_tokens": ["Parse", "creates", "an", "AST", "tree", "for", "XPath", "expressions", "."], "sha": "c385f95c6022e7756e91beac5f5510872f7dcb7d", "url": "https://github.com/ChrisTrenkamp/goxpath/blob/c385f95c6022e7756e91beac5f5510872f7dcb7d/parser/parser.go#L89-L104", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "build/change_trust.go", "func_name": "MutateChangeTrust", "original_string": "func (m Limit) MutateChangeTrust(o *xdr.ChangeTrustOp) (err error) {\n\to.Limit, err = amount.Parse(string(m))\n\treturn\n}", "language": "go", "code": "func (m Limit) MutateChangeTrust(o *xdr.ChangeTrustOp) (err error) {\n\to.Limit, err = amount.Parse(string(m))\n\treturn\n}", "code_tokens": ["func", "(", "m", "Limit", ")", "MutateChangeTrust", "(", "o", "*", "xdr", ".", "ChangeTrustOp", ")", "(", "err", "error", ")", "{", "o", ".", "Limit", ",", "err", "=", "amount", ".", "Parse", "(", "string", "(", "m", ")", ")", "\n", "return", "\n", "}"], "docstring": "// MutateChangeTrust for Limit sets the ChangeTrustOp's Limit field", "docstring_tokens": ["MutateChangeTrust", "for", "Limit", "sets", "the", "ChangeTrustOp", "s", "Limit", "field"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/change_trust.go#L61-L64", "partition": "test"}
{"repo": "drone/drone-plugin-go", "path": "plugin/param.go", "func_name": "Param", "original_string": "func (p ParamSet) Param(name string, value interface{}) {\n\tp.params[name] = value\n}", "language": "go", "code": "func (p ParamSet) Param(name string, value interface{}) {\n\tp.params[name] = value\n}", "code_tokens": ["func", "(", "p", "ParamSet", ")", "Param", "(", "name", "string", ",", "value", "interface", "{", "}", ")", "{", "p", ".", "params", "[", "name", "]", "=", "value", "\n", "}"], "docstring": "// Param defines a parameter with the specified name.", "docstring_tokens": ["Param", "defines", "a", "parameter", "with", "the", "specified", "name", "."], "sha": "d6109f644c5935c22620081b4c234bb2263743c7", "url": "https://github.com/drone/drone-plugin-go/blob/d6109f644c5935c22620081b4c234bb2263743c7/plugin/param.go#L70-L72", "partition": "test"}
{"repo": "guregu/null", "path": "zero/int.go", "func_name": "SetValid", "original_string": "func (i *Int) SetValid(n int64) {\n\ti.Int64 = n\n\ti.Valid = true\n}", "language": "go", "code": "func (i *Int) SetValid(n int64) {\n\ti.Int64 = n\n\ti.Valid = true\n}", "code_tokens": ["func", "(", "i", "*", "Int", ")", "SetValid", "(", "n", "int64", ")", "{", "i", ".", "Int64", "=", "n", "\n", "i", ".", "Valid", "=", "true", "\n", "}"], "docstring": "// SetValid changes this Int's value and also sets it to be non-null.", "docstring_tokens": ["SetValid", "changes", "this", "Int", "s", "value", "and", "also", "sets", "it", "to", "be", "non", "-", "null", "."], "sha": "80515d440932108546bcade467bb7d6968e812e2", "url": "https://github.com/guregu/null/blob/80515d440932108546bcade467bb7d6968e812e2/zero/int.go#L111-L114", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "db.go", "func_name": "writeLevel0Table", "original_string": "func writeLevel0Table(ft flushTask, f io.Writer) error {\n\titer := ft.mt.NewIterator()\n\tdefer iter.Close()\n\tb := table.NewTableBuilder()\n\tdefer b.Close()\n\tfor iter.SeekToFirst(); iter.Valid(); iter.Next() {\n\t\tif len(ft.dropPrefix) > 0 && bytes.HasPrefix(iter.Key(), ft.dropPrefix) {\n\t\t\tcontinue\n\t\t}\n\t\tif err := b.Add(iter.Key(), iter.Value()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := f.Write(b.Finish())\n\treturn err\n}", "language": "go", "code": "func writeLevel0Table(ft flushTask, f io.Writer) error {\n\titer := ft.mt.NewIterator()\n\tdefer iter.Close()\n\tb := table.NewTableBuilder()\n\tdefer b.Close()\n\tfor iter.SeekToFirst(); iter.Valid(); iter.Next() {\n\t\tif len(ft.dropPrefix) > 0 && bytes.HasPrefix(iter.Key(), ft.dropPrefix) {\n\t\t\tcontinue\n\t\t}\n\t\tif err := b.Add(iter.Key(), iter.Value()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := f.Write(b.Finish())\n\treturn err\n}", "code_tokens": ["func", "writeLevel0Table", "(", "ft", "flushTask", ",", "f", "io", ".", "Writer", ")", "error", "{", "iter", ":=", "ft", ".", "mt", ".", "NewIterator", "(", ")", "\n", "defer", "iter", ".", "Close", "(", ")", "\n", "b", ":=", "table", ".", "NewTableBuilder", "(", ")", "\n", "defer", "b", ".", "Close", "(", ")", "\n", "for", "iter", ".", "SeekToFirst", "(", ")", ";", "iter", ".", "Valid", "(", ")", ";", "iter", ".", "Next", "(", ")", "{", "if", "len", "(", "ft", ".", "dropPrefix", ")", ">", "0", "&&", "bytes", ".", "HasPrefix", "(", "iter", ".", "Key", "(", ")", ",", "ft", ".", "dropPrefix", ")", "{", "continue", "\n", "}", "\n", "if", "err", ":=", "b", ".", "Add", "(", "iter", ".", "Key", "(", ")", ",", "iter", ".", "Value", "(", ")", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n", "_", ",", "err", ":=", "f", ".", "Write", "(", "b", ".", "Finish", "(", ")", ")", "\n", "return", "err", "\n", "}"], "docstring": "// WriteLevel0Table flushes memtable.", "docstring_tokens": ["WriteLevel0Table", "flushes", "memtable", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/db.go#L796-L811", "partition": "test"}
{"repo": "containers/image", "path": "directory/directory_dest.go", "func_name": "isDirEmpty", "original_string": "func isDirEmpty(path string) (bool, error) {\n\tfiles, err := ioutil.ReadDir(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn len(files) == 0, nil\n}", "language": "go", "code": "func isDirEmpty(path string) (bool, error) {\n\tfiles, err := ioutil.ReadDir(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn len(files) == 0, nil\n}", "code_tokens": ["func", "isDirEmpty", "(", "path", "string", ")", "(", "bool", ",", "error", ")", "{", "files", ",", "err", ":=", "ioutil", ".", "ReadDir", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "false", ",", "err", "\n", "}", "\n", "return", "len", "(", "files", ")", "==", "0", ",", "nil", "\n", "}"], "docstring": "// returns true if directory is empty", "docstring_tokens": ["returns", "true", "if", "directory", "is", "empty"], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/directory/directory_dest.go#L239-L245", "partition": "test"}
{"repo": "mgutz/str", "path": "funcsAO.go", "func_name": "Iif", "original_string": "func Iif(condition bool, truthy string, falsey string) string {\n\tif condition {\n\t\treturn truthy\n\t}\n\treturn falsey\n}", "language": "go", "code": "func Iif(condition bool, truthy string, falsey string) string {\n\tif condition {\n\t\treturn truthy\n\t}\n\treturn falsey\n}", "code_tokens": ["func", "Iif", "(", "condition", "bool", ",", "truthy", "string", ",", "falsey", "string", ")", "string", "{", "if", "condition", "{", "return", "truthy", "\n", "}", "\n", "return", "falsey", "\n", "}"], "docstring": "// Iif is short for immediate if. If condition is true return truthy else falsey.", "docstring_tokens": ["Iif", "is", "short", "for", "immediate", "if", ".", "If", "condition", "is", "true", "return", "truthy", "else", "falsey", "."], "sha": "968bf66e3da857419e4f6e71b2d5c9ae95682dc4", "url": "https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsAO.go#L227-L232", "partition": "test"}
{"repo": "segmentio/objconv", "path": "decode.go", "func_name": "NewDecoder", "original_string": "func NewDecoder(p Parser) *Decoder {\n\tif p == nil {\n\t\tpanic(\"objconv: the parser is nil\")\n\t}\n\treturn &Decoder{Parser: p}\n}", "language": "go", "code": "func NewDecoder(p Parser) *Decoder {\n\tif p == nil {\n\t\tpanic(\"objconv: the parser is nil\")\n\t}\n\treturn &Decoder{Parser: p}\n}", "code_tokens": ["func", "NewDecoder", "(", "p", "Parser", ")", "*", "Decoder", "{", "if", "p", "==", "nil", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "&", "Decoder", "{", "Parser", ":", "p", "}", "\n", "}"], "docstring": "// NewDecoder returns a decoder object that uses p, will panic if p is nil.", "docstring_tokens": ["NewDecoder", "returns", "a", "decoder", "object", "that", "uses", "p", "will", "panic", "if", "p", "is", "nil", "."], "sha": "7a1d7b8e6f3551b30751e6b2ea6bae500883870e", "url": "https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/decode.go#L31-L36", "partition": "test"}
{"repo": "rlmcpherson/s3gof3r", "path": "gof3r/options.go", "func_name": "ACL", "original_string": "func ACL(h http.Header, acl string) http.Header {\n\tif acl != \"\" {\n\t\th.Set(\"x-amz-acl\", acl)\n\t}\n\treturn h\n}", "language": "go", "code": "func ACL(h http.Header, acl string) http.Header {\n\tif acl != \"\" {\n\t\th.Set(\"x-amz-acl\", acl)\n\t}\n\treturn h\n}", "code_tokens": ["func", "ACL", "(", "h", "http", ".", "Header", ",", "acl", "string", ")", "http", ".", "Header", "{", "if", "acl", "!=", "\"", "\"", "{", "h", ".", "Set", "(", "\"", "\"", ",", "acl", ")", "\n", "}", "\n", "return", "h", "\n", "}"], "docstring": "// add canned acl to http.Header", "docstring_tokens": ["add", "canned", "acl", "to", "http", ".", "Header"], "sha": "864ae0bf7cf2e20c0002b7ea17f4d84fec1abc14", "url": "https://github.com/rlmcpherson/s3gof3r/blob/864ae0bf7cf2e20c0002b7ea17f4d84fec1abc14/gof3r/options.go#L117-L122", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/obj/obj.go", "func_name": "NewGoogleClientFromEnv", "original_string": "func NewGoogleClientFromEnv() (Client, error) {\n\tbucket, ok := os.LookupEnv(GoogleBucketEnvVar)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"%s not found\", GoogleBucketEnvVar)\n\t}\n\tcreds, ok := os.LookupEnv(GoogleCredEnvVar)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"%s not found\", GoogleCredEnvVar)\n\t}\n\topts := []option.ClientOption{option.WithCredentialsJSON([]byte(creds))}\n\treturn NewGoogleClient(bucket, opts)\n}", "language": "go", "code": "func NewGoogleClientFromEnv() (Client, error) {\n\tbucket, ok := os.LookupEnv(GoogleBucketEnvVar)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"%s not found\", GoogleBucketEnvVar)\n\t}\n\tcreds, ok := os.LookupEnv(GoogleCredEnvVar)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"%s not found\", GoogleCredEnvVar)\n\t}\n\topts := []option.ClientOption{option.WithCredentialsJSON([]byte(creds))}\n\treturn NewGoogleClient(bucket, opts)\n}", "code_tokens": ["func", "NewGoogleClientFromEnv", "(", ")", "(", "Client", ",", "error", ")", "{", "bucket", ",", "ok", ":=", "os", ".", "LookupEnv", "(", "GoogleBucketEnvVar", ")", "\n", "if", "!", "ok", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "GoogleBucketEnvVar", ")", "\n", "}", "\n", "creds", ",", "ok", ":=", "os", ".", "LookupEnv", "(", "GoogleCredEnvVar", ")", "\n", "if", "!", "ok", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "GoogleCredEnvVar", ")", "\n", "}", "\n", "opts", ":=", "[", "]", "option", ".", "ClientOption", "{", "option", ".", "WithCredentialsJSON", "(", "[", "]", "byte", "(", "creds", ")", ")", "}", "\n", "return", "NewGoogleClient", "(", "bucket", ",", "opts", ")", "\n", "}"], "docstring": "// NewGoogleClientFromEnv creates a Google client based on environment variables.", "docstring_tokens": ["NewGoogleClientFromEnv", "creates", "a", "Google", "client", "based", "on", "environment", "variables", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/obj/obj.go#L205-L216", "partition": "test"}
{"repo": "pivotal-pez/pezdispenser", "path": "service/lease.go", "func_name": "Procurement", "original_string": "func (s *Lease) Procurement() (skuTask *taskmanager.Task) {\n\n\tif skuConstructor, ok := s.availableSkus[s.Sku]; ok {\n\t\tleaseMap := structs.Map(s)\n\t\tsku := skuConstructor.New(s.taskManager, leaseMap)\n\t\tGLogger.Println(\"here is my sku: \", sku)\n\t\tskuTask = sku.Procurement()\n\t\ttt := skuTask.Read(func(t *taskmanager.Task) interface{} {\n\t\t\ttt := *t\n\t\t\treturn tt\n\t\t})\n\t\tGLogger.Println(\"here is my task after procurement: \", tt)\n\t\ts.Task = skuTask.GetRedactedVersion()\n\n\t} else {\n\t\tGLogger.Println(\"No Sku Match: \", s.Sku, s.availableSkus)\n\t\ts.Task.Status = TaskStatusUnavailable\n\t}\n\treturn\n}", "language": "go", "code": "func (s *Lease) Procurement() (skuTask *taskmanager.Task) {\n\n\tif skuConstructor, ok := s.availableSkus[s.Sku]; ok {\n\t\tleaseMap := structs.Map(s)\n\t\tsku := skuConstructor.New(s.taskManager, leaseMap)\n\t\tGLogger.Println(\"here is my sku: \", sku)\n\t\tskuTask = sku.Procurement()\n\t\ttt := skuTask.Read(func(t *taskmanager.Task) interface{} {\n\t\t\ttt := *t\n\t\t\treturn tt\n\t\t})\n\t\tGLogger.Println(\"here is my task after procurement: \", tt)\n\t\ts.Task = skuTask.GetRedactedVersion()\n\n\t} else {\n\t\tGLogger.Println(\"No Sku Match: \", s.Sku, s.availableSkus)\n\t\ts.Task.Status = TaskStatusUnavailable\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "s", "*", "Lease", ")", "Procurement", "(", ")", "(", "skuTask", "*", "taskmanager", ".", "Task", ")", "{", "if", "skuConstructor", ",", "ok", ":=", "s", ".", "availableSkus", "[", "s", ".", "Sku", "]", ";", "ok", "{", "leaseMap", ":=", "structs", ".", "Map", "(", "s", ")", "\n", "sku", ":=", "skuConstructor", ".", "New", "(", "s", ".", "taskManager", ",", "leaseMap", ")", "\n", "GLogger", ".", "Println", "(", "\"", "\"", ",", "sku", ")", "\n", "skuTask", "=", "sku", ".", "Procurement", "(", ")", "\n", "tt", ":=", "skuTask", ".", "Read", "(", "func", "(", "t", "*", "taskmanager", ".", "Task", ")", "interface", "{", "}", "{", "tt", ":=", "*", "t", "\n", "return", "tt", "\n", "}", ")", "\n", "GLogger", ".", "Println", "(", "\"", "\"", ",", "tt", ")", "\n", "s", ".", "Task", "=", "skuTask", ".", "GetRedactedVersion", "(", ")", "\n\n", "}", "else", "{", "GLogger", ".", "Println", "(", "\"", "\"", ",", "s", ".", "Sku", ",", "s", ".", "availableSkus", ")", "\n", "s", ".", "Task", ".", "Status", "=", "TaskStatusUnavailable", "\n", "}", "\n", "return", "\n", "}"], "docstring": "//Procurement - method to issue a procurement request for the given lease item.", "docstring_tokens": ["Procurement", "-", "method", "to", "issue", "a", "procurement", "request", "for", "the", "given", "lease", "item", "."], "sha": "768e2777520868857916b66cfd4cfb7149383ca5", "url": "https://github.com/pivotal-pez/pezdispenser/blob/768e2777520868857916b66cfd4cfb7149383ca5/service/lease.go#L85-L104", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/deploy/cmds/cmds.go", "func_name": "containsEmpty", "original_string": "func containsEmpty(vals []string) bool {\n\tfor _, val := range vals {\n\t\tif val == \"\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "language": "go", "code": "func containsEmpty(vals []string) bool {\n\tfor _, val := range vals {\n\t\tif val == \"\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "code_tokens": ["func", "containsEmpty", "(", "vals", "[", "]", "string", ")", "bool", "{", "for", "_", ",", "val", ":=", "range", "vals", "{", "if", "val", "==", "\"", "\"", "{", "return", "true", "\n", "}", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// containsEmpty is a helper function used for validation (particularly for\n// validating that creds arguments aren't empty", "docstring_tokens": ["containsEmpty", "is", "a", "helper", "function", "used", "for", "validation", "(", "particularly", "for", "validating", "that", "creds", "arguments", "aren", "t", "empty"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/deploy/cmds/cmds.go#L139-L146", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/branchprotector/protect.go", "func_name": "UpdateBranch", "original_string": "func (p *protector) UpdateBranch(orgName, repo string, branchName string, branch config.Branch, protected bool) error {\n\tbp, err := p.cfg.GetPolicy(orgName, repo, branchName, branch)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"get policy: %v\", err)\n\t}\n\tif bp == nil || bp.Protect == nil {\n\t\treturn nil\n\t}\n\tif !protected && !*bp.Protect {\n\t\tlogrus.Infof(\"%s/%s=%s: already unprotected\", orgName, repo, branchName)\n\t\treturn nil\n\t}\n\tvar req *github.BranchProtectionRequest\n\tif *bp.Protect {\n\t\tr := makeRequest(*bp)\n\t\treq = &r\n\t}\n\tp.updates <- requirements{\n\t\tOrg:     orgName,\n\t\tRepo:    repo,\n\t\tBranch:  branchName,\n\t\tRequest: req,\n\t}\n\treturn nil\n}", "language": "go", "code": "func (p *protector) UpdateBranch(orgName, repo string, branchName string, branch config.Branch, protected bool) error {\n\tbp, err := p.cfg.GetPolicy(orgName, repo, branchName, branch)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"get policy: %v\", err)\n\t}\n\tif bp == nil || bp.Protect == nil {\n\t\treturn nil\n\t}\n\tif !protected && !*bp.Protect {\n\t\tlogrus.Infof(\"%s/%s=%s: already unprotected\", orgName, repo, branchName)\n\t\treturn nil\n\t}\n\tvar req *github.BranchProtectionRequest\n\tif *bp.Protect {\n\t\tr := makeRequest(*bp)\n\t\treq = &r\n\t}\n\tp.updates <- requirements{\n\t\tOrg:     orgName,\n\t\tRepo:    repo,\n\t\tBranch:  branchName,\n\t\tRequest: req,\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "p", "*", "protector", ")", "UpdateBranch", "(", "orgName", ",", "repo", "string", ",", "branchName", "string", ",", "branch", "config", ".", "Branch", ",", "protected", "bool", ")", "error", "{", "bp", ",", "err", ":=", "p", ".", "cfg", ".", "GetPolicy", "(", "orgName", ",", "repo", ",", "branchName", ",", "branch", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "if", "bp", "==", "nil", "||", "bp", ".", "Protect", "==", "nil", "{", "return", "nil", "\n", "}", "\n", "if", "!", "protected", "&&", "!", "*", "bp", ".", "Protect", "{", "logrus", ".", "Infof", "(", "\"", "\"", ",", "orgName", ",", "repo", ",", "branchName", ")", "\n", "return", "nil", "\n", "}", "\n", "var", "req", "*", "github", ".", "BranchProtectionRequest", "\n", "if", "*", "bp", ".", "Protect", "{", "r", ":=", "makeRequest", "(", "*", "bp", ")", "\n", "req", "=", "&", "r", "\n", "}", "\n", "p", ".", "updates", "<-", "requirements", "{", "Org", ":", "orgName", ",", "Repo", ":", "repo", ",", "Branch", ":", "branchName", ",", "Request", ":", "req", ",", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// UpdateBranch updates the branch with the specified configuration", "docstring_tokens": ["UpdateBranch", "updates", "the", "branch", "with", "the", "specified", "configuration"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/branchprotector/protect.go#L267-L291", "partition": "test"}
{"repo": "jpillora/overseer", "path": "fetcher/fetcher_http.go", "func_name": "Fetch", "original_string": "func (h *HTTP) Fetch() (io.Reader, error) {\n\t//delay fetches after first\n\tif h.delay {\n\t\ttime.Sleep(h.Interval)\n\t}\n\th.delay = true\n\t//status check using HEAD\n\tresp, err := http.Head(h.URL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"HEAD request failed (%s)\", err)\n\t}\n\tresp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HEAD request failed (status code %d)\", resp.StatusCode)\n\t}\n\t//if all headers match, skip update\n\tmatches, total := 0, 0\n\tfor _, header := range h.CheckHeaders {\n\t\tif curr := resp.Header.Get(header); curr != \"\" {\n\t\t\tif last, ok := h.lasts[header]; ok && last == curr {\n\t\t\t\tmatches++\n\t\t\t}\n\t\t\th.lasts[header] = curr\n\t\t\ttotal++\n\t\t}\n\t}\n\tif matches == total {\n\t\treturn nil, nil //skip, file match\n\t}\n\t//binary fetch using GET\n\tresp, err = http.Get(h.URL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"GET request failed (%s)\", err)\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"GET request failed (status code %d)\", resp.StatusCode)\n\t}\n\t//extract gz files\n\tif strings.HasSuffix(h.URL, \".gz\") && resp.Header.Get(\"Content-Encoding\") != \"gzip\" {\n\t\treturn gzip.NewReader(resp.Body)\n\t}\n\t//success!\n\treturn resp.Body, nil\n}", "language": "go", "code": "func (h *HTTP) Fetch() (io.Reader, error) {\n\t//delay fetches after first\n\tif h.delay {\n\t\ttime.Sleep(h.Interval)\n\t}\n\th.delay = true\n\t//status check using HEAD\n\tresp, err := http.Head(h.URL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"HEAD request failed (%s)\", err)\n\t}\n\tresp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"HEAD request failed (status code %d)\", resp.StatusCode)\n\t}\n\t//if all headers match, skip update\n\tmatches, total := 0, 0\n\tfor _, header := range h.CheckHeaders {\n\t\tif curr := resp.Header.Get(header); curr != \"\" {\n\t\t\tif last, ok := h.lasts[header]; ok && last == curr {\n\t\t\t\tmatches++\n\t\t\t}\n\t\t\th.lasts[header] = curr\n\t\t\ttotal++\n\t\t}\n\t}\n\tif matches == total {\n\t\treturn nil, nil //skip, file match\n\t}\n\t//binary fetch using GET\n\tresp, err = http.Get(h.URL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"GET request failed (%s)\", err)\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"GET request failed (status code %d)\", resp.StatusCode)\n\t}\n\t//extract gz files\n\tif strings.HasSuffix(h.URL, \".gz\") && resp.Header.Get(\"Content-Encoding\") != \"gzip\" {\n\t\treturn gzip.NewReader(resp.Body)\n\t}\n\t//success!\n\treturn resp.Body, nil\n}", "code_tokens": ["func", "(", "h", "*", "HTTP", ")", "Fetch", "(", ")", "(", "io", ".", "Reader", ",", "error", ")", "{", "//delay fetches after first", "if", "h", ".", "delay", "{", "time", ".", "Sleep", "(", "h", ".", "Interval", ")", "\n", "}", "\n", "h", ".", "delay", "=", "true", "\n", "//status check using HEAD", "resp", ",", "err", ":=", "http", ".", "Head", "(", "h", ".", "URL", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "resp", ".", "Body", ".", "Close", "(", ")", "\n", "if", "resp", ".", "StatusCode", "!=", "http", ".", "StatusOK", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "resp", ".", "StatusCode", ")", "\n", "}", "\n", "//if all headers match, skip update", "matches", ",", "total", ":=", "0", ",", "0", "\n", "for", "_", ",", "header", ":=", "range", "h", ".", "CheckHeaders", "{", "if", "curr", ":=", "resp", ".", "Header", ".", "Get", "(", "header", ")", ";", "curr", "!=", "\"", "\"", "{", "if", "last", ",", "ok", ":=", "h", ".", "lasts", "[", "header", "]", ";", "ok", "&&", "last", "==", "curr", "{", "matches", "++", "\n", "}", "\n", "h", ".", "lasts", "[", "header", "]", "=", "curr", "\n", "total", "++", "\n", "}", "\n", "}", "\n", "if", "matches", "==", "total", "{", "return", "nil", ",", "nil", "//skip, file match", "\n", "}", "\n", "//binary fetch using GET", "resp", ",", "err", "=", "http", ".", "Get", "(", "h", ".", "URL", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "if", "resp", ".", "StatusCode", "!=", "http", ".", "StatusOK", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "resp", ".", "StatusCode", ")", "\n", "}", "\n", "//extract gz files", "if", "strings", ".", "HasSuffix", "(", "h", ".", "URL", ",", "\"", "\"", ")", "&&", "resp", ".", "Header", ".", "Get", "(", "\"", "\"", ")", "!=", "\"", "\"", "{", "return", "gzip", ".", "NewReader", "(", "resp", ".", "Body", ")", "\n", "}", "\n", "//success!", "return", "resp", ".", "Body", ",", "nil", "\n", "}"], "docstring": "// Fetch the binary from the provided URL", "docstring_tokens": ["Fetch", "the", "binary", "from", "the", "provided", "URL"], "sha": "ce9055846616cf7e1ab91bb8a0bcbb1d7fa3d11a", "url": "https://github.com/jpillora/overseer/blob/ce9055846616cf7e1ab91bb8a0bcbb1d7fa3d11a/fetcher/fetcher_http.go#L45-L88", "partition": "test"}
{"repo": "ianschenck/envflag", "path": "envflag.go", "func_name": "Bool", "original_string": "func Bool(name string, value bool, usage string) *bool {\n\treturn EnvironmentFlags.Bool(name, value, usage)\n}", "language": "go", "code": "func Bool(name string, value bool, usage string) *bool {\n\treturn EnvironmentFlags.Bool(name, value, usage)\n}", "code_tokens": ["func", "Bool", "(", "name", "string", ",", "value", "bool", ",", "usage", "string", ")", "*", "bool", "{", "return", "EnvironmentFlags", ".", "Bool", "(", "name", ",", "value", ",", "usage", ")", "\n", "}"], "docstring": "// Bool defines a bool flag with specified name, default value, and\n// usage string.  The return value is the address of a bool variable\n// that stores the value of the flag.", "docstring_tokens": ["Bool", "defines", "a", "bool", "flag", "with", "specified", "name", "default", "value", "and", "usage", "string", ".", "The", "return", "value", "is", "the", "address", "of", "a", "bool", "variable", "that", "stores", "the", "value", "of", "the", "flag", "."], "sha": "9111d830d133f952887a936367fb0211c3134f0d", "url": "https://github.com/ianschenck/envflag/blob/9111d830d133f952887a936367fb0211c3134f0d/envflag.go#L60-L62", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/v2store/node.go", "func_name": "Compare", "original_string": "func (n *node) Compare(prevValue string, prevIndex uint64) (ok bool, which int) {\n\tindexMatch := prevIndex == 0 || n.ModifiedIndex == prevIndex\n\tvalueMatch := prevValue == \"\" || n.Value == prevValue\n\tok = valueMatch && indexMatch\n\tswitch {\n\tcase valueMatch && indexMatch:\n\t\twhich = CompareMatch\n\tcase indexMatch && !valueMatch:\n\t\twhich = CompareValueNotMatch\n\tcase valueMatch && !indexMatch:\n\t\twhich = CompareIndexNotMatch\n\tdefault:\n\t\twhich = CompareNotMatch\n\t}\n\treturn ok, which\n}", "language": "go", "code": "func (n *node) Compare(prevValue string, prevIndex uint64) (ok bool, which int) {\n\tindexMatch := prevIndex == 0 || n.ModifiedIndex == prevIndex\n\tvalueMatch := prevValue == \"\" || n.Value == prevValue\n\tok = valueMatch && indexMatch\n\tswitch {\n\tcase valueMatch && indexMatch:\n\t\twhich = CompareMatch\n\tcase indexMatch && !valueMatch:\n\t\twhich = CompareValueNotMatch\n\tcase valueMatch && !indexMatch:\n\t\twhich = CompareIndexNotMatch\n\tdefault:\n\t\twhich = CompareNotMatch\n\t}\n\treturn ok, which\n}", "code_tokens": ["func", "(", "n", "*", "node", ")", "Compare", "(", "prevValue", "string", ",", "prevIndex", "uint64", ")", "(", "ok", "bool", ",", "which", "int", ")", "{", "indexMatch", ":=", "prevIndex", "==", "0", "||", "n", ".", "ModifiedIndex", "==", "prevIndex", "\n", "valueMatch", ":=", "prevValue", "==", "\"", "\"", "||", "n", ".", "Value", "==", "prevValue", "\n", "ok", "=", "valueMatch", "&&", "indexMatch", "\n", "switch", "{", "case", "valueMatch", "&&", "indexMatch", ":", "which", "=", "CompareMatch", "\n", "case", "indexMatch", "&&", "!", "valueMatch", ":", "which", "=", "CompareValueNotMatch", "\n", "case", "valueMatch", "&&", "!", "indexMatch", ":", "which", "=", "CompareIndexNotMatch", "\n", "default", ":", "which", "=", "CompareNotMatch", "\n", "}", "\n", "return", "ok", ",", "which", "\n", "}"], "docstring": "// Compare function compares node index and value with provided ones.\n// second result value explains result and equals to one of Compare.. constants", "docstring_tokens": ["Compare", "function", "compares", "node", "index", "and", "value", "with", "provided", "ones", ".", "second", "result", "value", "explains", "result", "and", "equals", "to", "one", "of", "Compare", "..", "constants"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2store/node.go#L340-L355", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "language/proto/generate.go", "func_name": "generateProto", "original_string": "func generateProto(pc *ProtoConfig, rel string, pkg *Package, shouldSetVisibility bool) *rule.Rule {\n\tvar name string\n\tif pc.Mode == DefaultMode {\n\t\tname = RuleName(goPackageName(pkg), pc.GoPrefix, rel)\n\t} else {\n\t\tname = RuleName(pkg.Options[pc.groupOption], pkg.Name, rel)\n\t}\n\tr := rule.NewRule(\"proto_library\", name)\n\tsrcs := make([]string, 0, len(pkg.Files))\n\tfor f := range pkg.Files {\n\t\tsrcs = append(srcs, f)\n\t}\n\tsort.Strings(srcs)\n\tif len(srcs) > 0 {\n\t\tr.SetAttr(\"srcs\", srcs)\n\t}\n\tr.SetPrivateAttr(PackageKey, *pkg)\n\timports := make([]string, 0, len(pkg.Imports))\n\tfor i := range pkg.Imports {\n\t\timports = append(imports, i)\n\t}\n\tsort.Strings(imports)\n\t// NOTE: This attribute should not be used outside this extension. It's still\n\t// convenient for testing though.\n\tr.SetPrivateAttr(config.GazelleImportsKey, imports)\n\tfor k, v := range pkg.Options {\n\t\tr.SetPrivateAttr(k, v)\n\t}\n\tif shouldSetVisibility {\n\t\tvis := rule.CheckInternalVisibility(rel, \"//visibility:public\")\n\t\tr.SetAttr(\"visibility\", []string{vis})\n\t}\n\tif pc.stripImportPrefix != \"\" {\n\t\tr.SetAttr(\"strip_import_prefix\", pc.stripImportPrefix)\n\t}\n\tif pc.importPrefix != \"\" {\n\t\tr.SetAttr(\"import_prefix\", pc.importPrefix)\n\t}\n\treturn r\n}", "language": "go", "code": "func generateProto(pc *ProtoConfig, rel string, pkg *Package, shouldSetVisibility bool) *rule.Rule {\n\tvar name string\n\tif pc.Mode == DefaultMode {\n\t\tname = RuleName(goPackageName(pkg), pc.GoPrefix, rel)\n\t} else {\n\t\tname = RuleName(pkg.Options[pc.groupOption], pkg.Name, rel)\n\t}\n\tr := rule.NewRule(\"proto_library\", name)\n\tsrcs := make([]string, 0, len(pkg.Files))\n\tfor f := range pkg.Files {\n\t\tsrcs = append(srcs, f)\n\t}\n\tsort.Strings(srcs)\n\tif len(srcs) > 0 {\n\t\tr.SetAttr(\"srcs\", srcs)\n\t}\n\tr.SetPrivateAttr(PackageKey, *pkg)\n\timports := make([]string, 0, len(pkg.Imports))\n\tfor i := range pkg.Imports {\n\t\timports = append(imports, i)\n\t}\n\tsort.Strings(imports)\n\t// NOTE: This attribute should not be used outside this extension. It's still\n\t// convenient for testing though.\n\tr.SetPrivateAttr(config.GazelleImportsKey, imports)\n\tfor k, v := range pkg.Options {\n\t\tr.SetPrivateAttr(k, v)\n\t}\n\tif shouldSetVisibility {\n\t\tvis := rule.CheckInternalVisibility(rel, \"//visibility:public\")\n\t\tr.SetAttr(\"visibility\", []string{vis})\n\t}\n\tif pc.stripImportPrefix != \"\" {\n\t\tr.SetAttr(\"strip_import_prefix\", pc.stripImportPrefix)\n\t}\n\tif pc.importPrefix != \"\" {\n\t\tr.SetAttr(\"import_prefix\", pc.importPrefix)\n\t}\n\treturn r\n}", "code_tokens": ["func", "generateProto", "(", "pc", "*", "ProtoConfig", ",", "rel", "string", ",", "pkg", "*", "Package", ",", "shouldSetVisibility", "bool", ")", "*", "rule", ".", "Rule", "{", "var", "name", "string", "\n", "if", "pc", ".", "Mode", "==", "DefaultMode", "{", "name", "=", "RuleName", "(", "goPackageName", "(", "pkg", ")", ",", "pc", ".", "GoPrefix", ",", "rel", ")", "\n", "}", "else", "{", "name", "=", "RuleName", "(", "pkg", ".", "Options", "[", "pc", ".", "groupOption", "]", ",", "pkg", ".", "Name", ",", "rel", ")", "\n", "}", "\n", "r", ":=", "rule", ".", "NewRule", "(", "\"", "\"", ",", "name", ")", "\n", "srcs", ":=", "make", "(", "[", "]", "string", ",", "0", ",", "len", "(", "pkg", ".", "Files", ")", ")", "\n", "for", "f", ":=", "range", "pkg", ".", "Files", "{", "srcs", "=", "append", "(", "srcs", ",", "f", ")", "\n", "}", "\n", "sort", ".", "Strings", "(", "srcs", ")", "\n", "if", "len", "(", "srcs", ")", ">", "0", "{", "r", ".", "SetAttr", "(", "\"", "\"", ",", "srcs", ")", "\n", "}", "\n", "r", ".", "SetPrivateAttr", "(", "PackageKey", ",", "*", "pkg", ")", "\n", "imports", ":=", "make", "(", "[", "]", "string", ",", "0", ",", "len", "(", "pkg", ".", "Imports", ")", ")", "\n", "for", "i", ":=", "range", "pkg", ".", "Imports", "{", "imports", "=", "append", "(", "imports", ",", "i", ")", "\n", "}", "\n", "sort", ".", "Strings", "(", "imports", ")", "\n", "// NOTE: This attribute should not be used outside this extension. It's still", "// convenient for testing though.", "r", ".", "SetPrivateAttr", "(", "config", ".", "GazelleImportsKey", ",", "imports", ")", "\n", "for", "k", ",", "v", ":=", "range", "pkg", ".", "Options", "{", "r", ".", "SetPrivateAttr", "(", "k", ",", "v", ")", "\n", "}", "\n", "if", "shouldSetVisibility", "{", "vis", ":=", "rule", ".", "CheckInternalVisibility", "(", "rel", ",", "\"", "\"", ")", "\n", "r", ".", "SetAttr", "(", "\"", "\"", ",", "[", "]", "string", "{", "vis", "}", ")", "\n", "}", "\n", "if", "pc", ".", "stripImportPrefix", "!=", "\"", "\"", "{", "r", ".", "SetAttr", "(", "\"", "\"", ",", "pc", ".", "stripImportPrefix", ")", "\n", "}", "\n", "if", "pc", ".", "importPrefix", "!=", "\"", "\"", "{", "r", ".", "SetAttr", "(", "\"", "\"", ",", "pc", ".", "importPrefix", ")", "\n", "}", "\n", "return", "r", "\n", "}"], "docstring": "// generateProto creates a new proto_library rule for a package. The rule may\n// be empty if there are no sources.", "docstring_tokens": ["generateProto", "creates", "a", "new", "proto_library", "rule", "for", "a", "package", ".", "The", "rule", "may", "be", "empty", "if", "there", "are", "no", "sources", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/language/proto/generate.go#L191-L230", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/git/git.go", "func_name": "Checkout", "original_string": "func (r *Repo) Checkout(commitlike string) error {\n\tr.logger.Infof(\"Checkout %s.\", commitlike)\n\tco := r.gitCommand(\"checkout\", commitlike)\n\tif b, err := co.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"error checking out %s: %v. output: %s\", commitlike, err, string(b))\n\t}\n\treturn nil\n}", "language": "go", "code": "func (r *Repo) Checkout(commitlike string) error {\n\tr.logger.Infof(\"Checkout %s.\", commitlike)\n\tco := r.gitCommand(\"checkout\", commitlike)\n\tif b, err := co.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"error checking out %s: %v. output: %s\", commitlike, err, string(b))\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "r", "*", "Repo", ")", "Checkout", "(", "commitlike", "string", ")", "error", "{", "r", ".", "logger", ".", "Infof", "(", "\"", "\"", ",", "commitlike", ")", "\n", "co", ":=", "r", ".", "gitCommand", "(", "\"", "\"", ",", "commitlike", ")", "\n", "if", "b", ",", "err", ":=", "co", ".", "CombinedOutput", "(", ")", ";", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "commitlike", ",", "err", ",", "string", "(", "b", ")", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// Checkout runs git checkout.", "docstring_tokens": ["Checkout", "runs", "git", "checkout", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/git/git.go#L215-L222", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "builder/builder.go", "func_name": "GetForProvisioner", "original_string": "func GetForProvisioner(p provision.Provisioner) (Builder, error) {\n\tbuilder, err := get(p.GetName())\n\tif err != nil {\n\t\tif _, ok := p.(provision.BuilderDeployDockerClient); ok {\n\t\t\treturn get(\"docker\")\n\t\t} else if _, ok := p.(provision.BuilderDeployKubeClient); ok {\n\t\t\treturn get(\"kubernetes\")\n\t\t}\n\t}\n\treturn builder, err\n}", "language": "go", "code": "func GetForProvisioner(p provision.Provisioner) (Builder, error) {\n\tbuilder, err := get(p.GetName())\n\tif err != nil {\n\t\tif _, ok := p.(provision.BuilderDeployDockerClient); ok {\n\t\t\treturn get(\"docker\")\n\t\t} else if _, ok := p.(provision.BuilderDeployKubeClient); ok {\n\t\t\treturn get(\"kubernetes\")\n\t\t}\n\t}\n\treturn builder, err\n}", "code_tokens": ["func", "GetForProvisioner", "(", "p", "provision", ".", "Provisioner", ")", "(", "Builder", ",", "error", ")", "{", "builder", ",", "err", ":=", "get", "(", "p", ".", "GetName", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "if", "_", ",", "ok", ":=", "p", ".", "(", "provision", ".", "BuilderDeployDockerClient", ")", ";", "ok", "{", "return", "get", "(", "\"", "\"", ")", "\n", "}", "else", "if", "_", ",", "ok", ":=", "p", ".", "(", "provision", ".", "BuilderDeployKubeClient", ")", ";", "ok", "{", "return", "get", "(", "\"", "\"", ")", "\n", "}", "\n", "}", "\n", "return", "builder", ",", "err", "\n", "}"], "docstring": "// GetForProvisioner gets the builder required by the provisioner.", "docstring_tokens": ["GetForProvisioner", "gets", "the", "builder", "required", "by", "the", "provisioner", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/builder/builder.go#L55-L65", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_projects.go", "func_name": "UpdateProject", "original_string": "func (r *ProtocolLXD) UpdateProject(name string, project api.ProjectPut, ETag string) error {\n\tif !r.HasExtension(\"projects\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"projects\\\" API extension\")\n\t}\n\n\t// Send the request\n\t_, _, err := r.query(\"PUT\", fmt.Sprintf(\"/projects/%s\", url.QueryEscape(name)), project, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (r *ProtocolLXD) UpdateProject(name string, project api.ProjectPut, ETag string) error {\n\tif !r.HasExtension(\"projects\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"projects\\\" API extension\")\n\t}\n\n\t// Send the request\n\t_, _, err := r.query(\"PUT\", fmt.Sprintf(\"/projects/%s\", url.QueryEscape(name)), project, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "UpdateProject", "(", "name", "string", ",", "project", "api", ".", "ProjectPut", ",", "ETag", "string", ")", "error", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "// Send the request", "_", ",", "_", ",", "err", ":=", "r", ".", "query", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "name", ")", ")", ",", "project", ",", "ETag", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// UpdateProject updates the project to match the provided Project struct", "docstring_tokens": ["UpdateProject", "updates", "the", "project", "to", "match", "the", "provided", "Project", "struct"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_projects.go#L87-L99", "partition": "test"}
{"repo": "hashicorp/raft", "path": "net_transport.go", "func_name": "getConnFromAddressProvider", "original_string": "func (n *NetworkTransport) getConnFromAddressProvider(id ServerID, target ServerAddress) (*netConn, error) {\n\taddress := n.getProviderAddressOrFallback(id, target)\n\treturn n.getConn(address)\n}", "language": "go", "code": "func (n *NetworkTransport) getConnFromAddressProvider(id ServerID, target ServerAddress) (*netConn, error) {\n\taddress := n.getProviderAddressOrFallback(id, target)\n\treturn n.getConn(address)\n}", "code_tokens": ["func", "(", "n", "*", "NetworkTransport", ")", "getConnFromAddressProvider", "(", "id", "ServerID", ",", "target", "ServerAddress", ")", "(", "*", "netConn", ",", "error", ")", "{", "address", ":=", "n", ".", "getProviderAddressOrFallback", "(", "id", ",", "target", ")", "\n", "return", "n", ".", "getConn", "(", "address", ")", "\n", "}"], "docstring": "// getConnFromAddressProvider returns a connection from the server address provider if available, or defaults to a connection using the target server address", "docstring_tokens": ["getConnFromAddressProvider", "returns", "a", "connection", "from", "the", "server", "address", "provider", "if", "available", "or", "defaults", "to", "a", "connection", "using", "the", "target", "server", "address"], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/net_transport.go#L303-L306", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "hc/healthchecker.go", "func_name": "Check", "original_string": "func Check(names ...string) []Result {\n\tresults := make([]Result, 0, len(checkers))\n\tnameSet := set.FromSlice(names)\n\tisAll := nameSet.Includes(\"all\")\n\tfor _, checker := range checkers {\n\t\tif !isAll && !nameSet.Includes(checker.name) {\n\t\t\tcontinue\n\t\t}\n\t\tstartTime := time.Now()\n\t\tif err := checker.check(); err != nil && err != ErrDisabledComponent {\n\t\t\tresults = append(results, Result{\n\t\t\t\tName:     checker.name,\n\t\t\t\tStatus:   \"fail - \" + err.Error(),\n\t\t\t\tDuration: time.Since(startTime),\n\t\t\t})\n\t\t} else if err == nil {\n\t\t\tresults = append(results, Result{\n\t\t\t\tName:     checker.name,\n\t\t\t\tStatus:   HealthCheckOK,\n\t\t\t\tDuration: time.Since(startTime),\n\t\t\t})\n\t\t}\n\t}\n\treturn results\n}", "language": "go", "code": "func Check(names ...string) []Result {\n\tresults := make([]Result, 0, len(checkers))\n\tnameSet := set.FromSlice(names)\n\tisAll := nameSet.Includes(\"all\")\n\tfor _, checker := range checkers {\n\t\tif !isAll && !nameSet.Includes(checker.name) {\n\t\t\tcontinue\n\t\t}\n\t\tstartTime := time.Now()\n\t\tif err := checker.check(); err != nil && err != ErrDisabledComponent {\n\t\t\tresults = append(results, Result{\n\t\t\t\tName:     checker.name,\n\t\t\t\tStatus:   \"fail - \" + err.Error(),\n\t\t\t\tDuration: time.Since(startTime),\n\t\t\t})\n\t\t} else if err == nil {\n\t\t\tresults = append(results, Result{\n\t\t\t\tName:     checker.name,\n\t\t\t\tStatus:   HealthCheckOK,\n\t\t\t\tDuration: time.Since(startTime),\n\t\t\t})\n\t\t}\n\t}\n\treturn results\n}", "code_tokens": ["func", "Check", "(", "names", "...", "string", ")", "[", "]", "Result", "{", "results", ":=", "make", "(", "[", "]", "Result", ",", "0", ",", "len", "(", "checkers", ")", ")", "\n", "nameSet", ":=", "set", ".", "FromSlice", "(", "names", ")", "\n", "isAll", ":=", "nameSet", ".", "Includes", "(", "\"", "\"", ")", "\n", "for", "_", ",", "checker", ":=", "range", "checkers", "{", "if", "!", "isAll", "&&", "!", "nameSet", ".", "Includes", "(", "checker", ".", "name", ")", "{", "continue", "\n", "}", "\n", "startTime", ":=", "time", ".", "Now", "(", ")", "\n", "if", "err", ":=", "checker", ".", "check", "(", ")", ";", "err", "!=", "nil", "&&", "err", "!=", "ErrDisabledComponent", "{", "results", "=", "append", "(", "results", ",", "Result", "{", "Name", ":", "checker", ".", "name", ",", "Status", ":", "\"", "\"", "+", "err", ".", "Error", "(", ")", ",", "Duration", ":", "time", ".", "Since", "(", "startTime", ")", ",", "}", ")", "\n", "}", "else", "if", "err", "==", "nil", "{", "results", "=", "append", "(", "results", ",", "Result", "{", "Name", ":", "checker", ".", "name", ",", "Status", ":", "HealthCheckOK", ",", "Duration", ":", "time", ".", "Since", "(", "startTime", ")", ",", "}", ")", "\n", "}", "\n", "}", "\n", "return", "results", "\n", "}"], "docstring": "// Check check the status of registered checkers matching names and return a\n// list of results.", "docstring_tokens": ["Check", "check", "the", "status", "of", "registered", "checkers", "matching", "names", "and", "return", "a", "list", "of", "results", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/hc/healthchecker.go#L47-L71", "partition": "test"}
{"repo": "rightscale/rsc", "path": "cm15/codegen_client.go", "func_name": "PlacementGroupLocator", "original_string": "func (api *API) PlacementGroupLocator(href string) *PlacementGroupLocator {\n\treturn &PlacementGroupLocator{Href(href), api}\n}", "language": "go", "code": "func (api *API) PlacementGroupLocator(href string) *PlacementGroupLocator {\n\treturn &PlacementGroupLocator{Href(href), api}\n}", "code_tokens": ["func", "(", "api", "*", "API", ")", "PlacementGroupLocator", "(", "href", "string", ")", "*", "PlacementGroupLocator", "{", "return", "&", "PlacementGroupLocator", "{", "Href", "(", "href", ")", ",", "api", "}", "\n", "}"], "docstring": "// PlacementGroupLocator builds a locator from the given href.", "docstring_tokens": ["PlacementGroupLocator", "builds", "a", "locator", "from", "the", "given", "href", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L7441-L7443", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "emulation/emulation.go", "func_name": "WithScale", "original_string": "func (p SetDeviceMetricsOverrideParams) WithScale(scale float64) *SetDeviceMetricsOverrideParams {\n\tp.Scale = scale\n\treturn &p\n}", "language": "go", "code": "func (p SetDeviceMetricsOverrideParams) WithScale(scale float64) *SetDeviceMetricsOverrideParams {\n\tp.Scale = scale\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "SetDeviceMetricsOverrideParams", ")", "WithScale", "(", "scale", "float64", ")", "*", "SetDeviceMetricsOverrideParams", "{", "p", ".", "Scale", "=", "scale", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithScale scale to apply to resulting view image.", "docstring_tokens": ["WithScale", "scale", "to", "apply", "to", "resulting", "view", "image", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/emulation/emulation.go#L214-L217", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/build/controller.go", "func_name": "defaultArguments", "original_string": "func defaultArguments(t *buildv1alpha1.TemplateInstantiationSpec, rawEnv map[string]string) {\n\tkeys := sets.String{}\n\tfor _, arg := range t.Arguments {\n\t\tkeys.Insert(arg.Name)\n\t}\n\tfor _, k := range sets.StringKeySet(rawEnv).List() { // deterministic ordering\n\t\tif keys.Has(k) {\n\t\t\tcontinue\n\t\t}\n\t\tt.Arguments = append(t.Arguments, buildv1alpha1.ArgumentSpec{Name: k, Value: rawEnv[k]})\n\t}\n}", "language": "go", "code": "func defaultArguments(t *buildv1alpha1.TemplateInstantiationSpec, rawEnv map[string]string) {\n\tkeys := sets.String{}\n\tfor _, arg := range t.Arguments {\n\t\tkeys.Insert(arg.Name)\n\t}\n\tfor _, k := range sets.StringKeySet(rawEnv).List() { // deterministic ordering\n\t\tif keys.Has(k) {\n\t\t\tcontinue\n\t\t}\n\t\tt.Arguments = append(t.Arguments, buildv1alpha1.ArgumentSpec{Name: k, Value: rawEnv[k]})\n\t}\n}", "code_tokens": ["func", "defaultArguments", "(", "t", "*", "buildv1alpha1", ".", "TemplateInstantiationSpec", ",", "rawEnv", "map", "[", "string", "]", "string", ")", "{", "keys", ":=", "sets", ".", "String", "{", "}", "\n", "for", "_", ",", "arg", ":=", "range", "t", ".", "Arguments", "{", "keys", ".", "Insert", "(", "arg", ".", "Name", ")", "\n", "}", "\n", "for", "_", ",", "k", ":=", "range", "sets", ".", "StringKeySet", "(", "rawEnv", ")", ".", "List", "(", ")", "{", "// deterministic ordering", "if", "keys", ".", "Has", "(", "k", ")", "{", "continue", "\n", "}", "\n", "t", ".", "Arguments", "=", "append", "(", "t", ".", "Arguments", ",", "buildv1alpha1", ".", "ArgumentSpec", "{", "Name", ":", "k", ",", "Value", ":", "rawEnv", "[", "k", "]", "}", ")", "\n", "}", "\n", "}"], "docstring": "// defaultArguments will append each arg to the template, except where the argument name is already defined.", "docstring_tokens": ["defaultArguments", "will", "append", "each", "arg", "to", "the", "template", "except", "where", "the", "argument", "name", "is", "already", "defined", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/build/controller.go#L579-L590", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "_metcd/etcd_store.go", "func_name": "Txn", "original_string": "func (s *etcdStore) Txn(ctx context.Context, req *etcdserverpb.TxnRequest) (*etcdserverpb.TxnResponse, error) {\n\tireq := etcdserverpb.InternalRaftRequest{ID: <-s.idgen, Txn: req}\n\tmsgc, errc, err := s.proposeInternalRaftRequest(ireq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\ts.cancelInternalRaftRequest(ireq)\n\t\treturn nil, ctx.Err()\n\tcase msg := <-msgc:\n\t\treturn msg.(*etcdserverpb.TxnResponse), nil\n\tcase err := <-errc:\n\t\treturn nil, err\n\tcase <-s.quitc:\n\t\treturn nil, errStopped\n\t}\n}", "language": "go", "code": "func (s *etcdStore) Txn(ctx context.Context, req *etcdserverpb.TxnRequest) (*etcdserverpb.TxnResponse, error) {\n\tireq := etcdserverpb.InternalRaftRequest{ID: <-s.idgen, Txn: req}\n\tmsgc, errc, err := s.proposeInternalRaftRequest(ireq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\ts.cancelInternalRaftRequest(ireq)\n\t\treturn nil, ctx.Err()\n\tcase msg := <-msgc:\n\t\treturn msg.(*etcdserverpb.TxnResponse), nil\n\tcase err := <-errc:\n\t\treturn nil, err\n\tcase <-s.quitc:\n\t\treturn nil, errStopped\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "etcdStore", ")", "Txn", "(", "ctx", "context", ".", "Context", ",", "req", "*", "etcdserverpb", ".", "TxnRequest", ")", "(", "*", "etcdserverpb", ".", "TxnResponse", ",", "error", ")", "{", "ireq", ":=", "etcdserverpb", ".", "InternalRaftRequest", "{", "ID", ":", "<-", "s", ".", "idgen", ",", "Txn", ":", "req", "}", "\n", "msgc", ",", "errc", ",", "err", ":=", "s", ".", "proposeInternalRaftRequest", "(", "ireq", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "select", "{", "case", "<-", "ctx", ".", "Done", "(", ")", ":", "s", ".", "cancelInternalRaftRequest", "(", "ireq", ")", "\n", "return", "nil", ",", "ctx", ".", "Err", "(", ")", "\n", "case", "msg", ":=", "<-", "msgc", ":", "return", "msg", ".", "(", "*", "etcdserverpb", ".", "TxnResponse", ")", ",", "nil", "\n", "case", "err", ":=", "<-", "errc", ":", "return", "nil", ",", "err", "\n", "case", "<-", "s", ".", "quitc", ":", "return", "nil", ",", "errStopped", "\n", "}", "\n", "}"], "docstring": "// Txn implements gRPC KVServer.\n// Txn processes all the requests in one transaction.\n// A txn request increases the revision of the store,\n// and generates events with the same revision in the event history.\n// It is not allowed to modify the same key several times within one txn.", "docstring_tokens": ["Txn", "implements", "gRPC", "KVServer", ".", "Txn", "processes", "all", "the", "requests", "in", "one", "transaction", ".", "A", "txn", "request", "increases", "the", "revision", "of", "the", "store", "and", "generates", "events", "with", "the", "same", "revision", "in", "the", "event", "history", ".", "It", "is", "not", "allowed", "to", "modify", "the", "same", "key", "several", "times", "within", "one", "txn", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/_metcd/etcd_store.go#L164-L181", "partition": "test"}
{"repo": "golang/debug", "path": "internal/core/read.go", "func_name": "ReadInt64", "original_string": "func (p *Process) ReadInt64(a Address) int64 {\n\treturn int64(p.ReadUint64(a))\n}", "language": "go", "code": "func (p *Process) ReadInt64(a Address) int64 {\n\treturn int64(p.ReadUint64(a))\n}", "code_tokens": ["func", "(", "p", "*", "Process", ")", "ReadInt64", "(", "a", "Address", ")", "int64", "{", "return", "int64", "(", "p", ".", "ReadUint64", "(", "a", ")", ")", "\n", "}"], "docstring": "// ReadInt64 returns an int64 read from address a of the inferior.", "docstring_tokens": ["ReadInt64", "returns", "an", "int64", "read", "from", "address", "a", "of", "the", "inferior", "."], "sha": "19561fee47cf8cd0400d1b094c5898002f97cf90", "url": "https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/core/read.go#L111-L113", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/cluster/raft.go", "func_name": "Shutdown", "original_string": "func (i *raftInstance) Shutdown() error {\n\tlogger.Debug(\"Stop raft instance\")\n\n\t// Invoke raft APIs asynchronously to allow for a timeout.\n\ttimeout := 10 * time.Second\n\n\terrCh := make(chan error)\n\ttimer := time.After(timeout)\n\tgo func() {\n\t\terrCh <- i.raft.Shutdown().Error()\n\t}()\n\tselect {\n\tcase err := <-errCh:\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to shutdown raft\")\n\t\t}\n\tcase <-timer:\n\t\tlogger.Debug(\"Timeout waiting for raft to shutdown\")\n\t\treturn fmt.Errorf(\"raft did not shutdown within %s\", timeout)\n\n\t}\n\terr := i.logs.Close()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to close boltdb logs store\")\n\t}\n\treturn nil\n}", "language": "go", "code": "func (i *raftInstance) Shutdown() error {\n\tlogger.Debug(\"Stop raft instance\")\n\n\t// Invoke raft APIs asynchronously to allow for a timeout.\n\ttimeout := 10 * time.Second\n\n\terrCh := make(chan error)\n\ttimer := time.After(timeout)\n\tgo func() {\n\t\terrCh <- i.raft.Shutdown().Error()\n\t}()\n\tselect {\n\tcase err := <-errCh:\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to shutdown raft\")\n\t\t}\n\tcase <-timer:\n\t\tlogger.Debug(\"Timeout waiting for raft to shutdown\")\n\t\treturn fmt.Errorf(\"raft did not shutdown within %s\", timeout)\n\n\t}\n\terr := i.logs.Close()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to close boltdb logs store\")\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "i", "*", "raftInstance", ")", "Shutdown", "(", ")", "error", "{", "logger", ".", "Debug", "(", "\"", "\"", ")", "\n\n", "// Invoke raft APIs asynchronously to allow for a timeout.", "timeout", ":=", "10", "*", "time", ".", "Second", "\n\n", "errCh", ":=", "make", "(", "chan", "error", ")", "\n", "timer", ":=", "time", ".", "After", "(", "timeout", ")", "\n", "go", "func", "(", ")", "{", "errCh", "<-", "i", ".", "raft", ".", "Shutdown", "(", ")", ".", "Error", "(", ")", "\n", "}", "(", ")", "\n", "select", "{", "case", "err", ":=", "<-", "errCh", ":", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "case", "<-", "timer", ":", "logger", ".", "Debug", "(", "\"", "\"", ")", "\n", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "timeout", ")", "\n\n", "}", "\n", "err", ":=", "i", ".", "logs", ".", "Close", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// Shutdown raft and any raft-related resource we have instantiated.", "docstring_tokens": ["Shutdown", "raft", "and", "any", "raft", "-", "related", "resource", "we", "have", "instantiated", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/raft.go#L273-L299", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/spyglass/lenses/junit/lens.go", "func_name": "Callback", "original_string": "func (lens Lens) Callback(artifacts []lenses.Artifact, resourceDir string, data string) string {\n\treturn \"\"\n}", "language": "go", "code": "func (lens Lens) Callback(artifacts []lenses.Artifact, resourceDir string, data string) string {\n\treturn \"\"\n}", "code_tokens": ["func", "(", "lens", "Lens", ")", "Callback", "(", "artifacts", "[", "]", "lenses", ".", "Artifact", ",", "resourceDir", "string", ",", "data", "string", ")", "string", "{", "return", "\"", "\"", "\n", "}"], "docstring": "// Callback does nothing.", "docstring_tokens": ["Callback", "does", "nothing", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/spyglass/lenses/junit/lens.go#L70-L72", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/v3rpc/watch.go", "func_name": "NewWatchServer", "original_string": "func NewWatchServer(s *etcdserver.EtcdServer) pb.WatchServer {\n\treturn &watchServer{\n\t\tlg: s.Cfg.Logger,\n\n\t\tclusterID: int64(s.Cluster().ID()),\n\t\tmemberID:  int64(s.ID()),\n\n\t\tmaxRequestBytes: int(s.Cfg.MaxRequestBytes + grpcOverheadBytes),\n\n\t\tsg:        s,\n\t\twatchable: s.Watchable(),\n\t\tag:        s,\n\t}\n}", "language": "go", "code": "func NewWatchServer(s *etcdserver.EtcdServer) pb.WatchServer {\n\treturn &watchServer{\n\t\tlg: s.Cfg.Logger,\n\n\t\tclusterID: int64(s.Cluster().ID()),\n\t\tmemberID:  int64(s.ID()),\n\n\t\tmaxRequestBytes: int(s.Cfg.MaxRequestBytes + grpcOverheadBytes),\n\n\t\tsg:        s,\n\t\twatchable: s.Watchable(),\n\t\tag:        s,\n\t}\n}", "code_tokens": ["func", "NewWatchServer", "(", "s", "*", "etcdserver", ".", "EtcdServer", ")", "pb", ".", "WatchServer", "{", "return", "&", "watchServer", "{", "lg", ":", "s", ".", "Cfg", ".", "Logger", ",", "clusterID", ":", "int64", "(", "s", ".", "Cluster", "(", ")", ".", "ID", "(", ")", ")", ",", "memberID", ":", "int64", "(", "s", ".", "ID", "(", ")", ")", ",", "maxRequestBytes", ":", "int", "(", "s", ".", "Cfg", ".", "MaxRequestBytes", "+", "grpcOverheadBytes", ")", ",", "sg", ":", "s", ",", "watchable", ":", "s", ".", "Watchable", "(", ")", ",", "ag", ":", "s", ",", "}", "\n", "}"], "docstring": "// NewWatchServer returns a new watch server.", "docstring_tokens": ["NewWatchServer", "returns", "a", "new", "watch", "server", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v3rpc/watch.go#L48-L61", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "domdebugger/domdebugger.go", "func_name": "Do", "original_string": "func (p *SetDOMBreakpointParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetDOMBreakpoint, p, nil)\n}", "language": "go", "code": "func (p *SetDOMBreakpointParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetDOMBreakpoint, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetDOMBreakpointParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetDOMBreakpoint", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes DOMDebugger.setDOMBreakpoint against the provided context.", "docstring_tokens": ["Do", "executes", "DOMDebugger", ".", "setDOMBreakpoint", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/domdebugger/domdebugger.go#L199-L201", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/jenkins/jenkins.go", "func_name": "LaunchBuild", "original_string": "func (c *Client) LaunchBuild(spec *prowapi.ProwJobSpec, params url.Values) error {\n\tvar path string\n\n\tif params != nil {\n\t\tpath = getBuildWithParametersPath(spec)\n\t} else {\n\t\tpath = getBuildPath(spec)\n\t}\n\n\tc.logger.Debugf(\"getBuildPath/getBuildWithParametersPath: %s\", path)\n\n\tresp, err := c.request(http.MethodPost, path, params, true)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 201 {\n\t\treturn fmt.Errorf(\"response not 201: %s\", resp.Status)\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *Client) LaunchBuild(spec *prowapi.ProwJobSpec, params url.Values) error {\n\tvar path string\n\n\tif params != nil {\n\t\tpath = getBuildWithParametersPath(spec)\n\t} else {\n\t\tpath = getBuildPath(spec)\n\t}\n\n\tc.logger.Debugf(\"getBuildPath/getBuildWithParametersPath: %s\", path)\n\n\tresp, err := c.request(http.MethodPost, path, params, true)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 201 {\n\t\treturn fmt.Errorf(\"response not 201: %s\", resp.Status)\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "LaunchBuild", "(", "spec", "*", "prowapi", ".", "ProwJobSpec", ",", "params", "url", ".", "Values", ")", "error", "{", "var", "path", "string", "\n\n", "if", "params", "!=", "nil", "{", "path", "=", "getBuildWithParametersPath", "(", "spec", ")", "\n", "}", "else", "{", "path", "=", "getBuildPath", "(", "spec", ")", "\n", "}", "\n\n", "c", ".", "logger", ".", "Debugf", "(", "\"", "\"", ",", "path", ")", "\n\n", "resp", ",", "err", ":=", "c", ".", "request", "(", "http", ".", "MethodPost", ",", "path", ",", "params", ",", "true", ")", "\n\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "defer", "resp", ".", "Body", ".", "Close", "(", ")", "\n\n", "if", "resp", ".", "StatusCode", "!=", "201", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "resp", ".", "Status", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// LaunchBuild launches a regular or parameterized Jenkins build, depending on\n// whether or not we have `params` to POST", "docstring_tokens": ["LaunchBuild", "launches", "a", "regular", "or", "parameterized", "Jenkins", "build", "depending", "on", "whether", "or", "not", "we", "have", "params", "to", "POST"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/jenkins/jenkins.go#L569-L593", "partition": "test"}
{"repo": "guregu/null", "path": "bool.go", "func_name": "MarshalJSON", "original_string": "func (b Bool) MarshalJSON() ([]byte, error) {\n\tif !b.Valid {\n\t\treturn []byte(\"null\"), nil\n\t}\n\tif !b.Bool {\n\t\treturn []byte(\"false\"), nil\n\t}\n\treturn []byte(\"true\"), nil\n}", "language": "go", "code": "func (b Bool) MarshalJSON() ([]byte, error) {\n\tif !b.Valid {\n\t\treturn []byte(\"null\"), nil\n\t}\n\tif !b.Bool {\n\t\treturn []byte(\"false\"), nil\n\t}\n\treturn []byte(\"true\"), nil\n}", "code_tokens": ["func", "(", "b", "Bool", ")", "MarshalJSON", "(", ")", "(", "[", "]", "byte", ",", "error", ")", "{", "if", "!", "b", ".", "Valid", "{", "return", "[", "]", "byte", "(", "\"", "\"", ")", ",", "nil", "\n", "}", "\n", "if", "!", "b", ".", "Bool", "{", "return", "[", "]", "byte", "(", "\"", "\"", ")", ",", "nil", "\n", "}", "\n", "return", "[", "]", "byte", "(", "\"", "\"", ")", ",", "nil", "\n", "}"], "docstring": "// MarshalJSON implements json.Marshaler.\n// It will encode null if this Bool is null.", "docstring_tokens": ["MarshalJSON", "implements", "json", ".", "Marshaler", ".", "It", "will", "encode", "null", "if", "this", "Bool", "is", "null", "."], "sha": "80515d440932108546bcade467bb7d6968e812e2", "url": "https://github.com/guregu/null/blob/80515d440932108546bcade467bb7d6968e812e2/bool.go#L94-L102", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "functional/agent/server.go", "func_name": "StartServe", "original_string": "func (srv *Server) StartServe() error {\n\tvar err error\n\tsrv.ln, err = net.Listen(srv.network, srv.address)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar opts []grpc.ServerOption\n\topts = append(opts, grpc.MaxRecvMsgSize(int(maxRequestBytes+grpcOverheadBytes)))\n\topts = append(opts, grpc.MaxSendMsgSize(maxSendBytes))\n\topts = append(opts, grpc.MaxConcurrentStreams(maxStreams))\n\tsrv.grpcServer = grpc.NewServer(opts...)\n\n\trpcpb.RegisterTransportServer(srv.grpcServer, srv)\n\n\tsrv.lg.Info(\n\t\t\"gRPC server started\",\n\t\tzap.String(\"address\", srv.address),\n\t\tzap.String(\"listener-address\", srv.ln.Addr().String()),\n\t)\n\terr = srv.grpcServer.Serve(srv.ln)\n\tif err != nil && strings.Contains(err.Error(), \"use of closed network connection\") {\n\t\tsrv.lg.Info(\n\t\t\t\"gRPC server is shut down\",\n\t\t\tzap.String(\"address\", srv.address),\n\t\t\tzap.Error(err),\n\t\t)\n\t} else {\n\t\tsrv.lg.Warn(\n\t\t\t\"gRPC server returned with error\",\n\t\t\tzap.String(\"address\", srv.address),\n\t\t\tzap.Error(err),\n\t\t)\n\t}\n\treturn err\n}", "language": "go", "code": "func (srv *Server) StartServe() error {\n\tvar err error\n\tsrv.ln, err = net.Listen(srv.network, srv.address)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar opts []grpc.ServerOption\n\topts = append(opts, grpc.MaxRecvMsgSize(int(maxRequestBytes+grpcOverheadBytes)))\n\topts = append(opts, grpc.MaxSendMsgSize(maxSendBytes))\n\topts = append(opts, grpc.MaxConcurrentStreams(maxStreams))\n\tsrv.grpcServer = grpc.NewServer(opts...)\n\n\trpcpb.RegisterTransportServer(srv.grpcServer, srv)\n\n\tsrv.lg.Info(\n\t\t\"gRPC server started\",\n\t\tzap.String(\"address\", srv.address),\n\t\tzap.String(\"listener-address\", srv.ln.Addr().String()),\n\t)\n\terr = srv.grpcServer.Serve(srv.ln)\n\tif err != nil && strings.Contains(err.Error(), \"use of closed network connection\") {\n\t\tsrv.lg.Info(\n\t\t\t\"gRPC server is shut down\",\n\t\t\tzap.String(\"address\", srv.address),\n\t\t\tzap.Error(err),\n\t\t)\n\t} else {\n\t\tsrv.lg.Warn(\n\t\t\t\"gRPC server returned with error\",\n\t\t\tzap.String(\"address\", srv.address),\n\t\t\tzap.Error(err),\n\t\t)\n\t}\n\treturn err\n}", "code_tokens": ["func", "(", "srv", "*", "Server", ")", "StartServe", "(", ")", "error", "{", "var", "err", "error", "\n", "srv", ".", "ln", ",", "err", "=", "net", ".", "Listen", "(", "srv", ".", "network", ",", "srv", ".", "address", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "var", "opts", "[", "]", "grpc", ".", "ServerOption", "\n", "opts", "=", "append", "(", "opts", ",", "grpc", ".", "MaxRecvMsgSize", "(", "int", "(", "maxRequestBytes", "+", "grpcOverheadBytes", ")", ")", ")", "\n", "opts", "=", "append", "(", "opts", ",", "grpc", ".", "MaxSendMsgSize", "(", "maxSendBytes", ")", ")", "\n", "opts", "=", "append", "(", "opts", ",", "grpc", ".", "MaxConcurrentStreams", "(", "maxStreams", ")", ")", "\n", "srv", ".", "grpcServer", "=", "grpc", ".", "NewServer", "(", "opts", "...", ")", "\n\n", "rpcpb", ".", "RegisterTransportServer", "(", "srv", ".", "grpcServer", ",", "srv", ")", "\n\n", "srv", ".", "lg", ".", "Info", "(", "\"", "\"", ",", "zap", ".", "String", "(", "\"", "\"", ",", "srv", ".", "address", ")", ",", "zap", ".", "String", "(", "\"", "\"", ",", "srv", ".", "ln", ".", "Addr", "(", ")", ".", "String", "(", ")", ")", ",", ")", "\n", "err", "=", "srv", ".", "grpcServer", ".", "Serve", "(", "srv", ".", "ln", ")", "\n", "if", "err", "!=", "nil", "&&", "strings", ".", "Contains", "(", "err", ".", "Error", "(", ")", ",", "\"", "\"", ")", "{", "srv", ".", "lg", ".", "Info", "(", "\"", "\"", ",", "zap", ".", "String", "(", "\"", "\"", ",", "srv", ".", "address", ")", ",", "zap", ".", "Error", "(", "err", ")", ",", ")", "\n", "}", "else", "{", "srv", ".", "lg", ".", "Warn", "(", "\"", "\"", ",", "zap", ".", "String", "(", "\"", "\"", ",", "srv", ".", "address", ")", ",", "zap", ".", "Error", "(", "err", ")", ",", ")", "\n", "}", "\n", "return", "err", "\n", "}"], "docstring": "// StartServe starts serving agent server.", "docstring_tokens": ["StartServe", "starts", "serving", "agent", "server", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/functional/agent/server.go#L84-L119", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/deploy/assets/assets.go", "func_name": "WriteCustomAssets", "original_string": "func WriteCustomAssets(encoder Encoder, opts *AssetOpts, args []string, objectStoreBackend string,\n\tpersistentDiskBackend string, secure, isS3V2 bool) error {\n\tswitch objectStoreBackend {\n\tcase \"s3\":\n\t\tif len(args) != s3CustomArgs {\n\t\t\treturn fmt.Errorf(\"Expected %d arguments for disk+s3 backend\", s3CustomArgs)\n\t\t}\n\t\tvolumeSize, err := strconv.Atoi(args[1])\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"volume size needs to be an integer; instead got %v\", args[1])\n\t\t}\n\t\tswitch persistentDiskBackend {\n\t\tcase \"aws\":\n\t\t\tif err := WriteAssets(encoder, opts, minioBackend, amazonBackend, volumeSize, \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"google\":\n\t\t\tif err := WriteAssets(encoder, opts, minioBackend, googleBackend, volumeSize, \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"azure\":\n\t\t\tif err := WriteAssets(encoder, opts, minioBackend, microsoftBackend, volumeSize, \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"Did not recognize the choice of persistent-disk\")\n\t\t}\n\t\treturn WriteSecret(encoder, MinioSecret(args[2], args[3], args[4], args[5], secure, isS3V2), opts)\n\tdefault:\n\t\treturn fmt.Errorf(\"Did not recognize the choice of object-store\")\n\t}\n}", "language": "go", "code": "func WriteCustomAssets(encoder Encoder, opts *AssetOpts, args []string, objectStoreBackend string,\n\tpersistentDiskBackend string, secure, isS3V2 bool) error {\n\tswitch objectStoreBackend {\n\tcase \"s3\":\n\t\tif len(args) != s3CustomArgs {\n\t\t\treturn fmt.Errorf(\"Expected %d arguments for disk+s3 backend\", s3CustomArgs)\n\t\t}\n\t\tvolumeSize, err := strconv.Atoi(args[1])\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"volume size needs to be an integer; instead got %v\", args[1])\n\t\t}\n\t\tswitch persistentDiskBackend {\n\t\tcase \"aws\":\n\t\t\tif err := WriteAssets(encoder, opts, minioBackend, amazonBackend, volumeSize, \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"google\":\n\t\t\tif err := WriteAssets(encoder, opts, minioBackend, googleBackend, volumeSize, \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"azure\":\n\t\t\tif err := WriteAssets(encoder, opts, minioBackend, microsoftBackend, volumeSize, \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"Did not recognize the choice of persistent-disk\")\n\t\t}\n\t\treturn WriteSecret(encoder, MinioSecret(args[2], args[3], args[4], args[5], secure, isS3V2), opts)\n\tdefault:\n\t\treturn fmt.Errorf(\"Did not recognize the choice of object-store\")\n\t}\n}", "code_tokens": ["func", "WriteCustomAssets", "(", "encoder", "Encoder", ",", "opts", "*", "AssetOpts", ",", "args", "[", "]", "string", ",", "objectStoreBackend", "string", ",", "persistentDiskBackend", "string", ",", "secure", ",", "isS3V2", "bool", ")", "error", "{", "switch", "objectStoreBackend", "{", "case", "\"", "\"", ":", "if", "len", "(", "args", ")", "!=", "s3CustomArgs", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "s3CustomArgs", ")", "\n", "}", "\n", "volumeSize", ",", "err", ":=", "strconv", ".", "Atoi", "(", "args", "[", "1", "]", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "args", "[", "1", "]", ")", "\n", "}", "\n", "switch", "persistentDiskBackend", "{", "case", "\"", "\"", ":", "if", "err", ":=", "WriteAssets", "(", "encoder", ",", "opts", ",", "minioBackend", ",", "amazonBackend", ",", "volumeSize", ",", "\"", "\"", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "case", "\"", "\"", ":", "if", "err", ":=", "WriteAssets", "(", "encoder", ",", "opts", ",", "minioBackend", ",", "googleBackend", ",", "volumeSize", ",", "\"", "\"", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "case", "\"", "\"", ":", "if", "err", ":=", "WriteAssets", "(", "encoder", ",", "opts", ",", "minioBackend", ",", "microsoftBackend", ",", "volumeSize", ",", "\"", "\"", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "default", ":", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "WriteSecret", "(", "encoder", ",", "MinioSecret", "(", "args", "[", "2", "]", ",", "args", "[", "3", "]", ",", "args", "[", "4", "]", ",", "args", "[", "5", "]", ",", "secure", ",", "isS3V2", ")", ",", "opts", ")", "\n", "default", ":", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "}"], "docstring": "// WriteCustomAssets writes assets to a custom combination of object-store and persistent disk.", "docstring_tokens": ["WriteCustomAssets", "writes", "assets", "to", "a", "custom", "combination", "of", "object", "-", "store", "and", "persistent", "disk", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/deploy/assets/assets.go#L1474-L1505", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "token_bucket.go", "func_name": "newTokenBucket", "original_string": "func newTokenBucket(capacity int64, tokenInterval time.Duration) *tokenBucket {\n\ttb := tokenBucket{\n\t\tcapacity:       capacity,\n\t\ttokenInterval:  tokenInterval,\n\t\trefillDuration: tokenInterval * time.Duration(capacity)}\n\n\ttb.earliestUnspentToken = tb.capacityToken()\n\n\treturn &tb\n}", "language": "go", "code": "func newTokenBucket(capacity int64, tokenInterval time.Duration) *tokenBucket {\n\ttb := tokenBucket{\n\t\tcapacity:       capacity,\n\t\ttokenInterval:  tokenInterval,\n\t\trefillDuration: tokenInterval * time.Duration(capacity)}\n\n\ttb.earliestUnspentToken = tb.capacityToken()\n\n\treturn &tb\n}", "code_tokens": ["func", "newTokenBucket", "(", "capacity", "int64", ",", "tokenInterval", "time", ".", "Duration", ")", "*", "tokenBucket", "{", "tb", ":=", "tokenBucket", "{", "capacity", ":", "capacity", ",", "tokenInterval", ":", "tokenInterval", ",", "refillDuration", ":", "tokenInterval", "*", "time", ".", "Duration", "(", "capacity", ")", "}", "\n\n", "tb", ".", "earliestUnspentToken", "=", "tb", ".", "capacityToken", "(", ")", "\n\n", "return", "&", "tb", "\n", "}"], "docstring": "// newTokenBucket returns a bucket containing capacity tokens, refilled at a\n// rate of one token per tokenInterval.", "docstring_tokens": ["newTokenBucket", "returns", "a", "bucket", "containing", "capacity", "tokens", "refilled", "at", "a", "rate", "of", "one", "token", "per", "tokenInterval", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/token_bucket.go#L18-L27", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "skl/arena.go", "func_name": "getKey", "original_string": "func (s *Arena) getKey(offset uint32, size uint16) []byte {\n\treturn s.buf[offset : offset+uint32(size)]\n}", "language": "go", "code": "func (s *Arena) getKey(offset uint32, size uint16) []byte {\n\treturn s.buf[offset : offset+uint32(size)]\n}", "code_tokens": ["func", "(", "s", "*", "Arena", ")", "getKey", "(", "offset", "uint32", ",", "size", "uint16", ")", "[", "]", "byte", "{", "return", "s", ".", "buf", "[", "offset", ":", "offset", "+", "uint32", "(", "size", ")", "]", "\n", "}"], "docstring": "// getKey returns byte slice at offset.", "docstring_tokens": ["getKey", "returns", "byte", "slice", "at", "offset", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/skl/arena.go#L117-L119", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/config.go", "func_name": "TriggerFor", "original_string": "func (c *Configuration) TriggerFor(org, repo string) Trigger {\n\tfor _, tr := range c.Triggers {\n\t\tfor _, r := range tr.Repos {\n\t\t\tif r == org || r == fmt.Sprintf(\"%s/%s\", org, repo) {\n\t\t\t\treturn tr\n\t\t\t}\n\t\t}\n\t}\n\treturn Trigger{}\n}", "language": "go", "code": "func (c *Configuration) TriggerFor(org, repo string) Trigger {\n\tfor _, tr := range c.Triggers {\n\t\tfor _, r := range tr.Repos {\n\t\t\tif r == org || r == fmt.Sprintf(\"%s/%s\", org, repo) {\n\t\t\t\treturn tr\n\t\t\t}\n\t\t}\n\t}\n\treturn Trigger{}\n}", "code_tokens": ["func", "(", "c", "*", "Configuration", ")", "TriggerFor", "(", "org", ",", "repo", "string", ")", "Trigger", "{", "for", "_", ",", "tr", ":=", "range", "c", ".", "Triggers", "{", "for", "_", ",", "r", ":=", "range", "tr", ".", "Repos", "{", "if", "r", "==", "org", "||", "r", "==", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "org", ",", "repo", ")", "{", "return", "tr", "\n", "}", "\n", "}", "\n", "}", "\n", "return", "Trigger", "{", "}", "\n", "}"], "docstring": "// TriggerFor finds the Trigger for a repo, if one exists\n// a trigger can be listed for the repo itself or for the\n// owning organization", "docstring_tokens": ["TriggerFor", "finds", "the", "Trigger", "for", "a", "repo", "if", "one", "exists", "a", "trigger", "can", "be", "listed", "for", "the", "repo", "itself", "or", "for", "the", "owning", "organization"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/config.go#L607-L616", "partition": "test"}
{"repo": "hashicorp/raft", "path": "state.go", "func_name": "getLastEntry", "original_string": "func (r *raftState) getLastEntry() (uint64, uint64) {\n\tr.lastLock.Lock()\n\tdefer r.lastLock.Unlock()\n\tif r.lastLogIndex >= r.lastSnapshotIndex {\n\t\treturn r.lastLogIndex, r.lastLogTerm\n\t}\n\treturn r.lastSnapshotIndex, r.lastSnapshotTerm\n}", "language": "go", "code": "func (r *raftState) getLastEntry() (uint64, uint64) {\n\tr.lastLock.Lock()\n\tdefer r.lastLock.Unlock()\n\tif r.lastLogIndex >= r.lastSnapshotIndex {\n\t\treturn r.lastLogIndex, r.lastLogTerm\n\t}\n\treturn r.lastSnapshotIndex, r.lastSnapshotTerm\n}", "code_tokens": ["func", "(", "r", "*", "raftState", ")", "getLastEntry", "(", ")", "(", "uint64", ",", "uint64", ")", "{", "r", ".", "lastLock", ".", "Lock", "(", ")", "\n", "defer", "r", ".", "lastLock", ".", "Unlock", "(", ")", "\n", "if", "r", ".", "lastLogIndex", ">=", "r", ".", "lastSnapshotIndex", "{", "return", "r", ".", "lastLogIndex", ",", "r", ".", "lastLogTerm", "\n", "}", "\n", "return", "r", ".", "lastSnapshotIndex", ",", "r", ".", "lastSnapshotTerm", "\n", "}"], "docstring": "// getLastEntry returns the last index and term in stable storage.\n// Either from the last log or from the last snapshot.", "docstring_tokens": ["getLastEntry", "returns", "the", "last", "index", "and", "term", "in", "stable", "storage", ".", "Either", "from", "the", "last", "log", "or", "from", "the", "last", "snapshot", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/state.go#L164-L171", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "accessibility/accessibility.go", "func_name": "WithBackendNodeID", "original_string": "func (p GetPartialAXTreeParams) WithBackendNodeID(backendNodeID cdp.BackendNodeID) *GetPartialAXTreeParams {\n\tp.BackendNodeID = backendNodeID\n\treturn &p\n}", "language": "go", "code": "func (p GetPartialAXTreeParams) WithBackendNodeID(backendNodeID cdp.BackendNodeID) *GetPartialAXTreeParams {\n\tp.BackendNodeID = backendNodeID\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "GetPartialAXTreeParams", ")", "WithBackendNodeID", "(", "backendNodeID", "cdp", ".", "BackendNodeID", ")", "*", "GetPartialAXTreeParams", "{", "p", ".", "BackendNodeID", "=", "backendNodeID", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithBackendNodeID identifier of the backend node to get the partial\n// accessibility tree for.", "docstring_tokens": ["WithBackendNodeID", "identifier", "of", "the", "backend", "node", "to", "get", "the", "partial", "accessibility", "tree", "for", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/accessibility/accessibility.go#L78-L81", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "grpc/rpclog/fields.go", "func_name": "FieldsFromIncomingContext", "original_string": "func FieldsFromIncomingContext(ctx context.Context) ttnlog.Fields {\n\tfields := make(fieldMap)\n\tif peer, ok := peer.FromContext(ctx); ok {\n\t\tfields.addFromPeer(peer)\n\t}\n\tif md, ok := metadata.FromIncomingContext(ctx); ok {\n\t\tfields.addFromMD(md)\n\t}\n\treturn fields.LogFields()\n}", "language": "go", "code": "func FieldsFromIncomingContext(ctx context.Context) ttnlog.Fields {\n\tfields := make(fieldMap)\n\tif peer, ok := peer.FromContext(ctx); ok {\n\t\tfields.addFromPeer(peer)\n\t}\n\tif md, ok := metadata.FromIncomingContext(ctx); ok {\n\t\tfields.addFromMD(md)\n\t}\n\treturn fields.LogFields()\n}", "code_tokens": ["func", "FieldsFromIncomingContext", "(", "ctx", "context", ".", "Context", ")", "ttnlog", ".", "Fields", "{", "fields", ":=", "make", "(", "fieldMap", ")", "\n", "if", "peer", ",", "ok", ":=", "peer", ".", "FromContext", "(", "ctx", ")", ";", "ok", "{", "fields", ".", "addFromPeer", "(", "peer", ")", "\n", "}", "\n", "if", "md", ",", "ok", ":=", "metadata", ".", "FromIncomingContext", "(", "ctx", ")", ";", "ok", "{", "fields", ".", "addFromMD", "(", "md", ")", "\n", "}", "\n", "return", "fields", ".", "LogFields", "(", ")", "\n", "}"], "docstring": "// FieldsFromIncomingContext returns peer information and MDLogFields from the given context", "docstring_tokens": ["FieldsFromIncomingContext", "returns", "peer", "information", "and", "MDLogFields", "from", "the", "given", "context"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/grpc/rpclog/fields.go#L68-L77", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/storage_pools.go", "func_name": "StoragePoolVolumeGetType", "original_string": "func (c *Cluster) StoragePoolVolumeGetType(project string, volumeName string, volumeType int, poolID, nodeID int64) (int64, *api.StorageVolume, error) {\n\t// Custom volumes are \"global\", i.e. they are associated with the\n\t// default project.\n\tif volumeType == StoragePoolVolumeTypeCustom {\n\t\tproject = \"default\"\n\t}\n\n\tvolumeID, err := c.StoragePoolVolumeGetTypeID(project, volumeName, volumeType, poolID, nodeID)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tvolumeNode, err := c.StorageVolumeNodeGet(volumeID)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tvolumeConfig, err := c.StorageVolumeConfigGet(volumeID)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tvolumeDescription, err := c.StorageVolumeDescriptionGet(volumeID)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tvolumeTypeName, err := StoragePoolVolumeTypeToName(volumeType)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tstorageVolume := api.StorageVolume{\n\t\tType: volumeTypeName,\n\t}\n\tstorageVolume.Name = volumeName\n\tstorageVolume.Description = volumeDescription\n\tstorageVolume.Config = volumeConfig\n\tstorageVolume.Location = volumeNode\n\n\treturn volumeID, &storageVolume, nil\n}", "language": "go", "code": "func (c *Cluster) StoragePoolVolumeGetType(project string, volumeName string, volumeType int, poolID, nodeID int64) (int64, *api.StorageVolume, error) {\n\t// Custom volumes are \"global\", i.e. they are associated with the\n\t// default project.\n\tif volumeType == StoragePoolVolumeTypeCustom {\n\t\tproject = \"default\"\n\t}\n\n\tvolumeID, err := c.StoragePoolVolumeGetTypeID(project, volumeName, volumeType, poolID, nodeID)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tvolumeNode, err := c.StorageVolumeNodeGet(volumeID)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tvolumeConfig, err := c.StorageVolumeConfigGet(volumeID)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tvolumeDescription, err := c.StorageVolumeDescriptionGet(volumeID)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tvolumeTypeName, err := StoragePoolVolumeTypeToName(volumeType)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\tstorageVolume := api.StorageVolume{\n\t\tType: volumeTypeName,\n\t}\n\tstorageVolume.Name = volumeName\n\tstorageVolume.Description = volumeDescription\n\tstorageVolume.Config = volumeConfig\n\tstorageVolume.Location = volumeNode\n\n\treturn volumeID, &storageVolume, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "StoragePoolVolumeGetType", "(", "project", "string", ",", "volumeName", "string", ",", "volumeType", "int", ",", "poolID", ",", "nodeID", "int64", ")", "(", "int64", ",", "*", "api", ".", "StorageVolume", ",", "error", ")", "{", "// Custom volumes are \"global\", i.e. they are associated with the", "// default project.", "if", "volumeType", "==", "StoragePoolVolumeTypeCustom", "{", "project", "=", "\"", "\"", "\n", "}", "\n\n", "volumeID", ",", "err", ":=", "c", ".", "StoragePoolVolumeGetTypeID", "(", "project", ",", "volumeName", ",", "volumeType", ",", "poolID", ",", "nodeID", ")", "\n", "if", "err", "!=", "nil", "{", "return", "-", "1", ",", "nil", ",", "err", "\n", "}", "\n\n", "volumeNode", ",", "err", ":=", "c", ".", "StorageVolumeNodeGet", "(", "volumeID", ")", "\n", "if", "err", "!=", "nil", "{", "return", "-", "1", ",", "nil", ",", "err", "\n", "}", "\n\n", "volumeConfig", ",", "err", ":=", "c", ".", "StorageVolumeConfigGet", "(", "volumeID", ")", "\n", "if", "err", "!=", "nil", "{", "return", "-", "1", ",", "nil", ",", "err", "\n", "}", "\n\n", "volumeDescription", ",", "err", ":=", "c", ".", "StorageVolumeDescriptionGet", "(", "volumeID", ")", "\n", "if", "err", "!=", "nil", "{", "return", "-", "1", ",", "nil", ",", "err", "\n", "}", "\n\n", "volumeTypeName", ",", "err", ":=", "StoragePoolVolumeTypeToName", "(", "volumeType", ")", "\n", "if", "err", "!=", "nil", "{", "return", "-", "1", ",", "nil", ",", "err", "\n", "}", "\n\n", "storageVolume", ":=", "api", ".", "StorageVolume", "{", "Type", ":", "volumeTypeName", ",", "}", "\n", "storageVolume", ".", "Name", "=", "volumeName", "\n", "storageVolume", ".", "Description", "=", "volumeDescription", "\n", "storageVolume", ".", "Config", "=", "volumeConfig", "\n", "storageVolume", ".", "Location", "=", "volumeNode", "\n\n", "return", "volumeID", ",", "&", "storageVolume", ",", "nil", "\n", "}"], "docstring": "// StoragePoolVolumeGetType returns a single storage volume attached to a\n// given storage pool of a given type, on the node with the given ID.", "docstring_tokens": ["StoragePoolVolumeGetType", "returns", "a", "single", "storage", "volume", "attached", "to", "a", "given", "storage", "pool", "of", "a", "given", "type", "on", "the", "node", "with", "the", "given", "ID", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/storage_pools.go#L808-L849", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "WithFormat", "original_string": "func (p StartScreencastParams) WithFormat(format ScreencastFormat) *StartScreencastParams {\n\tp.Format = format\n\treturn &p\n}", "language": "go", "code": "func (p StartScreencastParams) WithFormat(format ScreencastFormat) *StartScreencastParams {\n\tp.Format = format\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "StartScreencastParams", ")", "WithFormat", "(", "format", "ScreencastFormat", ")", "*", "StartScreencastParams", "{", "p", ".", "Format", "=", "format", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithFormat image compression format.", "docstring_tokens": ["WithFormat", "image", "compression", "format", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L1138-L1141", "partition": "test"}
{"repo": "qor/render", "path": "render.go", "func_name": "RegisterFuncMap", "original_string": "func (render *Render) RegisterFuncMap(name string, fc interface{}) {\n\tif render.funcMaps == nil {\n\t\trender.funcMaps = template.FuncMap{}\n\t}\n\trender.funcMaps[name] = fc\n}", "language": "go", "code": "func (render *Render) RegisterFuncMap(name string, fc interface{}) {\n\tif render.funcMaps == nil {\n\t\trender.funcMaps = template.FuncMap{}\n\t}\n\trender.funcMaps[name] = fc\n}", "code_tokens": ["func", "(", "render", "*", "Render", ")", "RegisterFuncMap", "(", "name", "string", ",", "fc", "interface", "{", "}", ")", "{", "if", "render", ".", "funcMaps", "==", "nil", "{", "render", ".", "funcMaps", "=", "template", ".", "FuncMap", "{", "}", "\n", "}", "\n", "render", ".", "funcMaps", "[", "name", "]", "=", "fc", "\n", "}"], "docstring": "// RegisterFuncMap register FuncMap for render.", "docstring_tokens": ["RegisterFuncMap", "register", "FuncMap", "for", "render", "."], "sha": "63566e46f01b134ae9882a59a06518e82a903231", "url": "https://github.com/qor/render/blob/63566e46f01b134ae9882a59a06518e82a903231/render.go#L134-L139", "partition": "test"}
{"repo": "segmentio/objconv", "path": "decode.go", "func_name": "DecodeMap", "original_string": "func (d Decoder) DecodeMap(f func(Decoder, Decoder) error) (err error) {\n\tvar typ Type\n\n\tif d.off != 0 {\n\t\tif d.off, err = 0, d.Parser.ParseMapValue(d.off-1); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif typ, err = d.Parser.ParseType(); err != nil {\n\t\treturn\n\t}\n\n\terr = d.decodeMapImpl(typ, f)\n\treturn\n}", "language": "go", "code": "func (d Decoder) DecodeMap(f func(Decoder, Decoder) error) (err error) {\n\tvar typ Type\n\n\tif d.off != 0 {\n\t\tif d.off, err = 0, d.Parser.ParseMapValue(d.off-1); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif typ, err = d.Parser.ParseType(); err != nil {\n\t\treturn\n\t}\n\n\terr = d.decodeMapImpl(typ, f)\n\treturn\n}", "code_tokens": ["func", "(", "d", "Decoder", ")", "DecodeMap", "(", "f", "func", "(", "Decoder", ",", "Decoder", ")", "error", ")", "(", "err", "error", ")", "{", "var", "typ", "Type", "\n\n", "if", "d", ".", "off", "!=", "0", "{", "if", "d", ".", "off", ",", "err", "=", "0", ",", "d", ".", "Parser", ".", "ParseMapValue", "(", "d", ".", "off", "-", "1", ")", ";", "err", "!=", "nil", "{", "return", "\n", "}", "\n", "}", "\n\n", "if", "typ", ",", "err", "=", "d", ".", "Parser", ".", "ParseType", "(", ")", ";", "err", "!=", "nil", "{", "return", "\n", "}", "\n\n", "err", "=", "d", ".", "decodeMapImpl", "(", "typ", ",", "f", ")", "\n", "return", "\n", "}"], "docstring": "// DecodeMap provides the implementation of the algorithm for decoding maps,\n// where f is called to decode each pair of key and value.\n//\n// The function f is expected to decode two values from the map, the first one\n// being the key and the second the associated value. The first decoder must be\n// used to decode the key, the second one for the value.", "docstring_tokens": ["DecodeMap", "provides", "the", "implementation", "of", "the", "algorithm", "for", "decoding", "maps", "where", "f", "is", "called", "to", "decode", "each", "pair", "of", "key", "and", "value", ".", "The", "function", "f", "is", "expected", "to", "decode", "two", "values", "from", "the", "map", "the", "first", "one", "being", "the", "key", "and", "the", "second", "the", "associated", "value", ".", "The", "first", "decoder", "must", "be", "used", "to", "decode", "the", "key", "the", "second", "one", "for", "the", "value", "."], "sha": "7a1d7b8e6f3551b30751e6b2ea6bae500883870e", "url": "https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/decode.go#L1197-L1212", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "integration/cluster.go", "func_name": "NewCluster", "original_string": "func NewCluster(t testing.TB, size int) *cluster {\n\treturn newCluster(t, &ClusterConfig{Size: size})\n}", "language": "go", "code": "func NewCluster(t testing.TB, size int) *cluster {\n\treturn newCluster(t, &ClusterConfig{Size: size})\n}", "code_tokens": ["func", "NewCluster", "(", "t", "testing", ".", "TB", ",", "size", "int", ")", "*", "cluster", "{", "return", "newCluster", "(", "t", ",", "&", "ClusterConfig", "{", "Size", ":", "size", "}", ")", "\n", "}"], "docstring": "// NewCluster returns an unlaunched cluster of the given size which has been\n// set to use static bootstrap.", "docstring_tokens": ["NewCluster", "returns", "an", "unlaunched", "cluster", "of", "the", "given", "size", "which", "has", "been", "set", "to", "use", "static", "bootstrap", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/integration/cluster.go#L208-L210", "partition": "test"}
{"repo": "google/go-cmp", "path": "cmp/internal/diff/diff.go", "func_name": "stats", "original_string": "func (es EditScript) stats() (s struct{ NI, NX, NY, NM int }) {\n\tfor _, e := range es {\n\t\tswitch e {\n\t\tcase Identity:\n\t\t\ts.NI++\n\t\tcase UniqueX:\n\t\t\ts.NX++\n\t\tcase UniqueY:\n\t\t\ts.NY++\n\t\tcase Modified:\n\t\t\ts.NM++\n\t\tdefault:\n\t\t\tpanic(\"invalid edit-type\")\n\t\t}\n\t}\n\treturn\n}", "language": "go", "code": "func (es EditScript) stats() (s struct{ NI, NX, NY, NM int }) {\n\tfor _, e := range es {\n\t\tswitch e {\n\t\tcase Identity:\n\t\t\ts.NI++\n\t\tcase UniqueX:\n\t\t\ts.NX++\n\t\tcase UniqueY:\n\t\t\ts.NY++\n\t\tcase Modified:\n\t\t\ts.NM++\n\t\tdefault:\n\t\t\tpanic(\"invalid edit-type\")\n\t\t}\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "es", "EditScript", ")", "stats", "(", ")", "(", "s", "struct", "{", "NI", ",", "NX", ",", "NY", ",", "NM", "int", "}", ")", "{", "for", "_", ",", "e", ":=", "range", "es", "{", "switch", "e", "{", "case", "Identity", ":", "s", ".", "NI", "++", "\n", "case", "UniqueX", ":", "s", ".", "NX", "++", "\n", "case", "UniqueY", ":", "s", ".", "NY", "++", "\n", "case", "Modified", ":", "s", ".", "NM", "++", "\n", "default", ":", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// stats returns a histogram of the number of each type of edit operation.", "docstring_tokens": ["stats", "returns", "a", "histogram", "of", "the", "number", "of", "each", "type", "of", "edit", "operation", "."], "sha": "6f77996f0c42f7b84e5a2b252227263f93432e9b", "url": "https://github.com/google/go-cmp/blob/6f77996f0c42f7b84e5a2b252227263f93432e9b/cmp/internal/diff/diff.go#L55-L71", "partition": "test"}
{"repo": "ant0ine/go-json-rest", "path": "rest/router.go", "func_name": "MakeRouter", "original_string": "func MakeRouter(routes ...*Route) (App, error) {\n\tr := &router{\n\t\tRoutes: routes,\n\t}\n\terr := r.start()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn r, nil\n}", "language": "go", "code": "func MakeRouter(routes ...*Route) (App, error) {\n\tr := &router{\n\t\tRoutes: routes,\n\t}\n\terr := r.start()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn r, nil\n}", "code_tokens": ["func", "MakeRouter", "(", "routes", "...", "*", "Route", ")", "(", "App", ",", "error", ")", "{", "r", ":=", "&", "router", "{", "Routes", ":", "routes", ",", "}", "\n", "err", ":=", "r", ".", "start", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "r", ",", "nil", "\n", "}"], "docstring": "// MakeRouter returns the router app. Given a set of Routes, it dispatches the request to the\n// HandlerFunc of the first route that matches. The order of the Routes matters.", "docstring_tokens": ["MakeRouter", "returns", "the", "router", "app", ".", "Given", "a", "set", "of", "Routes", "it", "dispatches", "the", "request", "to", "the", "HandlerFunc", "of", "the", "first", "route", "that", "matches", ".", "The", "order", "of", "the", "Routes", "matters", "."], "sha": "ebb33769ae013bd5f518a8bac348c310dea768b8", "url": "https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/router.go#L21-L30", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "label_sync/main.go", "func_name": "loadLabels", "original_string": "func loadLabels(gc client, org string, repos []string) (*RepoLabels, error) {\n\trepoChan := make(chan string, len(repos))\n\tfor _, repo := range repos {\n\t\trepoChan <- repo\n\t}\n\tclose(repoChan)\n\n\twg := sync.WaitGroup{}\n\twg.Add(maxConcurrentWorkers)\n\tlabels := make(chan RepoLabels, len(repos))\n\terrChan := make(chan error, len(repos))\n\tfor i := 0; i < maxConcurrentWorkers; i++ {\n\t\tgo func(repositories <-chan string) {\n\t\t\tdefer wg.Done()\n\t\t\tfor repository := range repositories {\n\t\t\t\tlogrus.WithField(\"org\", org).WithField(\"repo\", repository).Info(\"Listing labels for repo\")\n\t\t\t\trepoLabels, err := gc.GetRepoLabels(org, repository)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.WithField(\"org\", org).WithField(\"repo\", repository).Error(\"Failed listing labels for repo\")\n\t\t\t\t\terrChan <- err\n\t\t\t\t}\n\t\t\t\tlabels <- RepoLabels{repository: repoLabels}\n\t\t\t}\n\t\t}(repoChan)\n\t}\n\n\twg.Wait()\n\tclose(labels)\n\tclose(errChan)\n\n\trl := RepoLabels{}\n\tfor data := range labels {\n\t\tfor repo, repoLabels := range data {\n\t\t\trl[repo] = repoLabels\n\t\t}\n\t}\n\n\tvar overallErr error\n\tif len(errChan) > 0 {\n\t\tvar listErrs []error\n\t\tfor listErr := range errChan {\n\t\t\tlistErrs = append(listErrs, listErr)\n\t\t}\n\t\toverallErr = fmt.Errorf(\"failed to list labels: %v\", listErrs)\n\t}\n\n\treturn &rl, overallErr\n}", "language": "go", "code": "func loadLabels(gc client, org string, repos []string) (*RepoLabels, error) {\n\trepoChan := make(chan string, len(repos))\n\tfor _, repo := range repos {\n\t\trepoChan <- repo\n\t}\n\tclose(repoChan)\n\n\twg := sync.WaitGroup{}\n\twg.Add(maxConcurrentWorkers)\n\tlabels := make(chan RepoLabels, len(repos))\n\terrChan := make(chan error, len(repos))\n\tfor i := 0; i < maxConcurrentWorkers; i++ {\n\t\tgo func(repositories <-chan string) {\n\t\t\tdefer wg.Done()\n\t\t\tfor repository := range repositories {\n\t\t\t\tlogrus.WithField(\"org\", org).WithField(\"repo\", repository).Info(\"Listing labels for repo\")\n\t\t\t\trepoLabels, err := gc.GetRepoLabels(org, repository)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.WithField(\"org\", org).WithField(\"repo\", repository).Error(\"Failed listing labels for repo\")\n\t\t\t\t\terrChan <- err\n\t\t\t\t}\n\t\t\t\tlabels <- RepoLabels{repository: repoLabels}\n\t\t\t}\n\t\t}(repoChan)\n\t}\n\n\twg.Wait()\n\tclose(labels)\n\tclose(errChan)\n\n\trl := RepoLabels{}\n\tfor data := range labels {\n\t\tfor repo, repoLabels := range data {\n\t\t\trl[repo] = repoLabels\n\t\t}\n\t}\n\n\tvar overallErr error\n\tif len(errChan) > 0 {\n\t\tvar listErrs []error\n\t\tfor listErr := range errChan {\n\t\t\tlistErrs = append(listErrs, listErr)\n\t\t}\n\t\toverallErr = fmt.Errorf(\"failed to list labels: %v\", listErrs)\n\t}\n\n\treturn &rl, overallErr\n}", "code_tokens": ["func", "loadLabels", "(", "gc", "client", ",", "org", "string", ",", "repos", "[", "]", "string", ")", "(", "*", "RepoLabels", ",", "error", ")", "{", "repoChan", ":=", "make", "(", "chan", "string", ",", "len", "(", "repos", ")", ")", "\n", "for", "_", ",", "repo", ":=", "range", "repos", "{", "repoChan", "<-", "repo", "\n", "}", "\n", "close", "(", "repoChan", ")", "\n\n", "wg", ":=", "sync", ".", "WaitGroup", "{", "}", "\n", "wg", ".", "Add", "(", "maxConcurrentWorkers", ")", "\n", "labels", ":=", "make", "(", "chan", "RepoLabels", ",", "len", "(", "repos", ")", ")", "\n", "errChan", ":=", "make", "(", "chan", "error", ",", "len", "(", "repos", ")", ")", "\n", "for", "i", ":=", "0", ";", "i", "<", "maxConcurrentWorkers", ";", "i", "++", "{", "go", "func", "(", "repositories", "<-", "chan", "string", ")", "{", "defer", "wg", ".", "Done", "(", ")", "\n", "for", "repository", ":=", "range", "repositories", "{", "logrus", ".", "WithField", "(", "\"", "\"", ",", "org", ")", ".", "WithField", "(", "\"", "\"", ",", "repository", ")", ".", "Info", "(", "\"", "\"", ")", "\n", "repoLabels", ",", "err", ":=", "gc", ".", "GetRepoLabels", "(", "org", ",", "repository", ")", "\n", "if", "err", "!=", "nil", "{", "logrus", ".", "WithField", "(", "\"", "\"", ",", "org", ")", ".", "WithField", "(", "\"", "\"", ",", "repository", ")", ".", "Error", "(", "\"", "\"", ")", "\n", "errChan", "<-", "err", "\n", "}", "\n", "labels", "<-", "RepoLabels", "{", "repository", ":", "repoLabels", "}", "\n", "}", "\n", "}", "(", "repoChan", ")", "\n", "}", "\n\n", "wg", ".", "Wait", "(", ")", "\n", "close", "(", "labels", ")", "\n", "close", "(", "errChan", ")", "\n\n", "rl", ":=", "RepoLabels", "{", "}", "\n", "for", "data", ":=", "range", "labels", "{", "for", "repo", ",", "repoLabels", ":=", "range", "data", "{", "rl", "[", "repo", "]", "=", "repoLabels", "\n", "}", "\n", "}", "\n\n", "var", "overallErr", "error", "\n", "if", "len", "(", "errChan", ")", ">", "0", "{", "var", "listErrs", "[", "]", "error", "\n", "for", "listErr", ":=", "range", "errChan", "{", "listErrs", "=", "append", "(", "listErrs", ",", "listErr", ")", "\n", "}", "\n", "overallErr", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "listErrs", ")", "\n", "}", "\n\n", "return", "&", "rl", ",", "overallErr", "\n", "}"], "docstring": "// loadLabels returns what labels exist in github", "docstring_tokens": ["loadLabels", "returns", "what", "labels", "exist", "in", "github"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/label_sync/main.go#L340-L387", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "hyperbahn/client.go", "func_name": "Advertise", "original_string": "func (c *Client) Advertise(otherServices ...tchannel.Registrar) error {\n\tc.getServiceNames(otherServices)\n\n\tif err := c.initialAdvertise(); err != nil {\n\t\treturn err\n\t}\n\n\tc.opts.Handler.On(Advertised)\n\tgo c.advertiseLoop()\n\treturn nil\n}", "language": "go", "code": "func (c *Client) Advertise(otherServices ...tchannel.Registrar) error {\n\tc.getServiceNames(otherServices)\n\n\tif err := c.initialAdvertise(); err != nil {\n\t\treturn err\n\t}\n\n\tc.opts.Handler.On(Advertised)\n\tgo c.advertiseLoop()\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "Advertise", "(", "otherServices", "...", "tchannel", ".", "Registrar", ")", "error", "{", "c", ".", "getServiceNames", "(", "otherServices", ")", "\n\n", "if", "err", ":=", "c", ".", "initialAdvertise", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "c", ".", "opts", ".", "Handler", ".", "On", "(", "Advertised", ")", "\n", "go", "c", ".", "advertiseLoop", "(", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// Advertise advertises the service with Hyperbahn, and returns any errors on initial advertisement.\n// Advertise can register multiple services hosted on the same endpoint.\n// If the advertisement succeeds, a goroutine is started to re-advertise periodically.", "docstring_tokens": ["Advertise", "advertises", "the", "service", "with", "Hyperbahn", "and", "returns", "any", "errors", "on", "initial", "advertisement", ".", "Advertise", "can", "register", "multiple", "services", "hosted", "on", "the", "same", "endpoint", ".", "If", "the", "advertisement", "succeeds", "a", "goroutine", "is", "started", "to", "re", "-", "advertise", "periodically", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/hyperbahn/client.go#L175-L185", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "Do", "original_string": "func (p *SetProduceCompilationCacheParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetProduceCompilationCache, p, nil)\n}", "language": "go", "code": "func (p *SetProduceCompilationCacheParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetProduceCompilationCache, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetProduceCompilationCacheParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetProduceCompilationCache", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Page.setProduceCompilationCache against the provided context.", "docstring_tokens": ["Do", "executes", "Page", ".", "setProduceCompilationCache", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L1280-L1282", "partition": "test"}
{"repo": "knq/sdhook", "path": "opts.go", "func_name": "ProjectID", "original_string": "func ProjectID(projectID string) Option {\n\treturn func(sh *StackdriverHook) error {\n\t\tsh.projectID = projectID\n\t\treturn nil\n\t}\n}", "language": "go", "code": "func ProjectID(projectID string) Option {\n\treturn func(sh *StackdriverHook) error {\n\t\tsh.projectID = projectID\n\t\treturn nil\n\t}\n}", "code_tokens": ["func", "ProjectID", "(", "projectID", "string", ")", "Option", "{", "return", "func", "(", "sh", "*", "StackdriverHook", ")", "error", "{", "sh", ".", "projectID", "=", "projectID", "\n", "return", "nil", "\n", "}", "\n", "}"], "docstring": "// ProjectID is an option that sets the project ID which is needed for the log\n// name.", "docstring_tokens": ["ProjectID", "is", "an", "option", "that", "sets", "the", "project", "ID", "which", "is", "needed", "for", "the", "log", "name", "."], "sha": "41b9ccbff0b5fa5a56fbdccf2eb8653e7afe8d4b", "url": "https://github.com/knq/sdhook/blob/41b9ccbff0b5fa5a56fbdccf2eb8653e7afe8d4b/opts.go#L36-L41", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/logger/format.go", "func_name": "Pretty", "original_string": "func Pretty(input interface{}) string {\n\tpretty, err := json.MarshalIndent(input, \"\\t\", \"\\t\")\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"%v\", input)\n\t}\n\n\treturn fmt.Sprintf(\"\\n\\t%s\", pretty)\n}", "language": "go", "code": "func Pretty(input interface{}) string {\n\tpretty, err := json.MarshalIndent(input, \"\\t\", \"\\t\")\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"%v\", input)\n\t}\n\n\treturn fmt.Sprintf(\"\\n\\t%s\", pretty)\n}", "code_tokens": ["func", "Pretty", "(", "input", "interface", "{", "}", ")", "string", "{", "pretty", ",", "err", ":=", "json", ".", "MarshalIndent", "(", "input", ",", "\"", "\\t", "\"", ",", "\"", "\\t", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "input", ")", "\n", "}", "\n\n", "return", "fmt", ".", "Sprintf", "(", "\"", "\\n", "\\t", "\"", ",", "pretty", ")", "\n", "}"], "docstring": "// Pretty will attempt to convert any Go structure into a string suitable for logging", "docstring_tokens": ["Pretty", "will", "attempt", "to", "convert", "any", "Go", "structure", "into", "a", "string", "suitable", "for", "logging"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/logger/format.go#L10-L17", "partition": "test"}
{"repo": "kljensen/snowball", "path": "snowballword/snowballword.go", "func_name": "resetR1R2", "original_string": "func (w *SnowballWord) resetR1R2() {\n\trsLen := len(w.RS)\n\tif w.R1start > rsLen {\n\t\tw.R1start = rsLen\n\t}\n\tif w.R2start > rsLen {\n\t\tw.R2start = rsLen\n\t}\n\tif w.RVstart > rsLen {\n\t\tw.RVstart = rsLen\n\t}\n}", "language": "go", "code": "func (w *SnowballWord) resetR1R2() {\n\trsLen := len(w.RS)\n\tif w.R1start > rsLen {\n\t\tw.R1start = rsLen\n\t}\n\tif w.R2start > rsLen {\n\t\tw.R2start = rsLen\n\t}\n\tif w.RVstart > rsLen {\n\t\tw.RVstart = rsLen\n\t}\n}", "code_tokens": ["func", "(", "w", "*", "SnowballWord", ")", "resetR1R2", "(", ")", "{", "rsLen", ":=", "len", "(", "w", ".", "RS", ")", "\n", "if", "w", ".", "R1start", ">", "rsLen", "{", "w", ".", "R1start", "=", "rsLen", "\n", "}", "\n", "if", "w", ".", "R2start", ">", "rsLen", "{", "w", ".", "R2start", "=", "rsLen", "\n", "}", "\n", "if", "w", ".", "RVstart", ">", "rsLen", "{", "w", ".", "RVstart", "=", "rsLen", "\n", "}", "\n", "}"], "docstring": "// Resets R1start and R2start to ensure they\n// are within bounds of the current rune slice.", "docstring_tokens": ["Resets", "R1start", "and", "R2start", "to", "ensure", "they", "are", "within", "bounds", "of", "the", "current", "rune", "slice", "."], "sha": "115fa8f6419dcfb9ec4653997b1c6803a5eff962", "url": "https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/snowballword/snowballword.go#L93-L104", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "gopherage/pkg/cov/junit/calculation/coverage.go", "func_name": "Ratio", "original_string": "func (c *Coverage) Ratio() float32 {\n\tif c.NumAllStmts == 0 {\n\t\treturn 1\n\t}\n\treturn float32(c.NumCoveredStmts) / float32(c.NumAllStmts)\n}", "language": "go", "code": "func (c *Coverage) Ratio() float32 {\n\tif c.NumAllStmts == 0 {\n\t\treturn 1\n\t}\n\treturn float32(c.NumCoveredStmts) / float32(c.NumAllStmts)\n}", "code_tokens": ["func", "(", "c", "*", "Coverage", ")", "Ratio", "(", ")", "float32", "{", "if", "c", ".", "NumAllStmts", "==", "0", "{", "return", "1", "\n", "}", "\n", "return", "float32", "(", "c", ".", "NumCoveredStmts", ")", "/", "float32", "(", "c", ".", "NumAllStmts", ")", "\n", "}"], "docstring": "// Ratio returns the percentage of statements that are covered", "docstring_tokens": ["Ratio", "returns", "the", "percentage", "of", "statements", "that", "are", "covered"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/gopherage/pkg/cov/junit/calculation/coverage.go#L27-L32", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/pipeline/main.go", "func_name": "newPipelineConfig", "original_string": "func newPipelineConfig(cfg rest.Config, stop chan struct{}) (*pipelineConfig, error) {\n\tbc, err := pipelineset.NewForConfig(&cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Ensure the pipeline CRD is deployed\n\t// TODO(fejta): probably a better way to do this\n\tif _, err := bc.TektonV1alpha1().PipelineRuns(\"\").List(metav1.ListOptions{Limit: 1}); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Assume watches receive updates, but resync every 30m in case something wonky happens\n\tbif := pipelineinfo.NewSharedInformerFactory(bc, 30*time.Minute)\n\tbif.Tekton().V1alpha1().PipelineRuns().Lister()\n\tgo bif.Start(stop)\n\treturn &pipelineConfig{\n\t\tclient:   bc,\n\t\tinformer: bif.Tekton().V1alpha1().PipelineRuns(),\n\t}, nil\n}", "language": "go", "code": "func newPipelineConfig(cfg rest.Config, stop chan struct{}) (*pipelineConfig, error) {\n\tbc, err := pipelineset.NewForConfig(&cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Ensure the pipeline CRD is deployed\n\t// TODO(fejta): probably a better way to do this\n\tif _, err := bc.TektonV1alpha1().PipelineRuns(\"\").List(metav1.ListOptions{Limit: 1}); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Assume watches receive updates, but resync every 30m in case something wonky happens\n\tbif := pipelineinfo.NewSharedInformerFactory(bc, 30*time.Minute)\n\tbif.Tekton().V1alpha1().PipelineRuns().Lister()\n\tgo bif.Start(stop)\n\treturn &pipelineConfig{\n\t\tclient:   bc,\n\t\tinformer: bif.Tekton().V1alpha1().PipelineRuns(),\n\t}, nil\n}", "code_tokens": ["func", "newPipelineConfig", "(", "cfg", "rest", ".", "Config", ",", "stop", "chan", "struct", "{", "}", ")", "(", "*", "pipelineConfig", ",", "error", ")", "{", "bc", ",", "err", ":=", "pipelineset", ".", "NewForConfig", "(", "&", "cfg", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "// Ensure the pipeline CRD is deployed", "// TODO(fejta): probably a better way to do this", "if", "_", ",", "err", ":=", "bc", ".", "TektonV1alpha1", "(", ")", ".", "PipelineRuns", "(", "\"", "\"", ")", ".", "List", "(", "metav1", ".", "ListOptions", "{", "Limit", ":", "1", "}", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "// Assume watches receive updates, but resync every 30m in case something wonky happens", "bif", ":=", "pipelineinfo", ".", "NewSharedInformerFactory", "(", "bc", ",", "30", "*", "time", ".", "Minute", ")", "\n", "bif", ".", "Tekton", "(", ")", ".", "V1alpha1", "(", ")", ".", "PipelineRuns", "(", ")", ".", "Lister", "(", ")", "\n", "go", "bif", ".", "Start", "(", "stop", ")", "\n", "return", "&", "pipelineConfig", "{", "client", ":", "bc", ",", "informer", ":", "bif", ".", "Tekton", "(", ")", ".", "V1alpha1", "(", ")", ".", "PipelineRuns", "(", ")", ",", "}", ",", "nil", "\n", "}"], "docstring": "// newPipelineConfig returns a client and informer capable of mutating and monitoring the specified config.", "docstring_tokens": ["newPipelineConfig", "returns", "a", "client", "and", "informer", "capable", "of", "mutating", "and", "monitoring", "the", "specified", "config", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/pipeline/main.go#L105-L125", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_containers.go", "func_name": "GetContainerSnapshots", "original_string": "func (r *ProtocolLXD) GetContainerSnapshots(containerName string) ([]api.ContainerSnapshot, error) {\n\tsnapshots := []api.ContainerSnapshot{}\n\n\t// Fetch the raw value\n\t_, err := r.queryStruct(\"GET\", fmt.Sprintf(\"/containers/%s/snapshots?recursion=1\", url.QueryEscape(containerName)), nil, \"\", &snapshots)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn snapshots, nil\n}", "language": "go", "code": "func (r *ProtocolLXD) GetContainerSnapshots(containerName string) ([]api.ContainerSnapshot, error) {\n\tsnapshots := []api.ContainerSnapshot{}\n\n\t// Fetch the raw value\n\t_, err := r.queryStruct(\"GET\", fmt.Sprintf(\"/containers/%s/snapshots?recursion=1\", url.QueryEscape(containerName)), nil, \"\", &snapshots)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn snapshots, nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "GetContainerSnapshots", "(", "containerName", "string", ")", "(", "[", "]", "api", ".", "ContainerSnapshot", ",", "error", ")", "{", "snapshots", ":=", "[", "]", "api", ".", "ContainerSnapshot", "{", "}", "\n\n", "// Fetch the raw value", "_", ",", "err", ":=", "r", ".", "queryStruct", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "containerName", ")", ")", ",", "nil", ",", "\"", "\"", ",", "&", "snapshots", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "snapshots", ",", "nil", "\n", "}"], "docstring": "// GetContainerSnapshots returns a list of snapshots for the container", "docstring_tokens": ["GetContainerSnapshots", "returns", "a", "list", "of", "snapshots", "for", "the", "container"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_containers.go#L1016-L1026", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "velodrome/fetcher/client.go", "func_name": "getGitHubClient", "original_string": "func (client *Client) getGitHubClient() (*github.Client, error) {\n\tif client.githubClient != nil {\n\t\treturn client.githubClient, nil\n\t}\n\ttoken := client.Token\n\tif len(token) == 0 && len(client.TokenFile) != 0 {\n\t\tdata, err := ioutil.ReadFile(client.TokenFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttoken = strings.TrimSpace(string(data))\n\t}\n\n\tif len(token) > 0 {\n\t\tts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})\n\t\ttc := oauth2.NewClient(oauth2.NoContext, ts)\n\t\tclient.githubClient = github.NewClient(tc)\n\t} else {\n\t\tclient.githubClient = github.NewClient(nil)\n\t}\n\treturn client.githubClient, nil\n}", "language": "go", "code": "func (client *Client) getGitHubClient() (*github.Client, error) {\n\tif client.githubClient != nil {\n\t\treturn client.githubClient, nil\n\t}\n\ttoken := client.Token\n\tif len(token) == 0 && len(client.TokenFile) != 0 {\n\t\tdata, err := ioutil.ReadFile(client.TokenFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttoken = strings.TrimSpace(string(data))\n\t}\n\n\tif len(token) > 0 {\n\t\tts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})\n\t\ttc := oauth2.NewClient(oauth2.NoContext, ts)\n\t\tclient.githubClient = github.NewClient(tc)\n\t} else {\n\t\tclient.githubClient = github.NewClient(nil)\n\t}\n\treturn client.githubClient, nil\n}", "code_tokens": ["func", "(", "client", "*", "Client", ")", "getGitHubClient", "(", ")", "(", "*", "github", ".", "Client", ",", "error", ")", "{", "if", "client", ".", "githubClient", "!=", "nil", "{", "return", "client", ".", "githubClient", ",", "nil", "\n", "}", "\n", "token", ":=", "client", ".", "Token", "\n", "if", "len", "(", "token", ")", "==", "0", "&&", "len", "(", "client", ".", "TokenFile", ")", "!=", "0", "{", "data", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "client", ".", "TokenFile", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "token", "=", "strings", ".", "TrimSpace", "(", "string", "(", "data", ")", ")", "\n", "}", "\n\n", "if", "len", "(", "token", ")", ">", "0", "{", "ts", ":=", "oauth2", ".", "StaticTokenSource", "(", "&", "oauth2", ".", "Token", "{", "AccessToken", ":", "token", "}", ")", "\n", "tc", ":=", "oauth2", ".", "NewClient", "(", "oauth2", ".", "NoContext", ",", "ts", ")", "\n", "client", ".", "githubClient", "=", "github", ".", "NewClient", "(", "tc", ")", "\n", "}", "else", "{", "client", ".", "githubClient", "=", "github", ".", "NewClient", "(", "nil", ")", "\n", "}", "\n", "return", "client", ".", "githubClient", ",", "nil", "\n", "}"], "docstring": "// getGitHubClient create the github client that we use to communicate with github", "docstring_tokens": ["getGitHubClient", "create", "the", "github", "client", "that", "we", "use", "to", "communicate", "with", "github"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/fetcher/client.go#L75-L96", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "context.go", "func_name": "Fail", "original_string": "func (ctx *Context) Fail(err error) {\n\tif err == nil {\n\t\tlog.WithFields(log.Fields{\"path\": ctx.Request.URL.Path}).Warnln(\"Context.Fail: err is nil\")\n\t\tctx.ResponseWriter.WriteHeader(http.StatusInternalServerError)\n\t\tctx.ResponseWriter.Write(nil)\n\t\treturn\n\t}\n\n\tif ctx.written == true {\n\t\tlog.WithFields(log.Fields{\"path\": ctx.Request.URL.Path}).Warnln(\"Context.Fail: request has been writed\")\n\t\treturn\n\t}\n\n\terrno := 0\n\terrCore, ok := err.(ICoreError)\n\tif ok == true {\n\t\terrno = errCore.GetErrno()\n\t}\n\tctx.written = true\n\tif Production == false {\n\t\tlog.WithFields(log.Fields{\"path\": ctx.Request.URL.Path}).Warnln(err.Error())\n\t} else if _, ok := err.(*ServerError); ok == true {\n\t\tlog.WithFields(log.Fields{\"path\": ctx.Request.URL.Path}).Warnln(err.Error())\n\t}\n\n\tvar json = jsoniter.ConfigCompatibleWithStandardLibrary\n\tb, _ := json.Marshal(&ResFormat{Ok: false, Message: err.Error(), Errno: errno})\n\n\tcoreErr, ok := err.(ICoreError)\n\tif ok == true {\n\t\tctx.ResponseWriter.WriteHeader(coreErr.GetHTTPCode())\n\t} else {\n\t\tctx.ResponseWriter.WriteHeader(http.StatusInternalServerError)\n\t}\n\tctx.ResponseWriter.Write(b)\n}", "language": "go", "code": "func (ctx *Context) Fail(err error) {\n\tif err == nil {\n\t\tlog.WithFields(log.Fields{\"path\": ctx.Request.URL.Path}).Warnln(\"Context.Fail: err is nil\")\n\t\tctx.ResponseWriter.WriteHeader(http.StatusInternalServerError)\n\t\tctx.ResponseWriter.Write(nil)\n\t\treturn\n\t}\n\n\tif ctx.written == true {\n\t\tlog.WithFields(log.Fields{\"path\": ctx.Request.URL.Path}).Warnln(\"Context.Fail: request has been writed\")\n\t\treturn\n\t}\n\n\terrno := 0\n\terrCore, ok := err.(ICoreError)\n\tif ok == true {\n\t\terrno = errCore.GetErrno()\n\t}\n\tctx.written = true\n\tif Production == false {\n\t\tlog.WithFields(log.Fields{\"path\": ctx.Request.URL.Path}).Warnln(err.Error())\n\t} else if _, ok := err.(*ServerError); ok == true {\n\t\tlog.WithFields(log.Fields{\"path\": ctx.Request.URL.Path}).Warnln(err.Error())\n\t}\n\n\tvar json = jsoniter.ConfigCompatibleWithStandardLibrary\n\tb, _ := json.Marshal(&ResFormat{Ok: false, Message: err.Error(), Errno: errno})\n\n\tcoreErr, ok := err.(ICoreError)\n\tif ok == true {\n\t\tctx.ResponseWriter.WriteHeader(coreErr.GetHTTPCode())\n\t} else {\n\t\tctx.ResponseWriter.WriteHeader(http.StatusInternalServerError)\n\t}\n\tctx.ResponseWriter.Write(b)\n}", "code_tokens": ["func", "(", "ctx", "*", "Context", ")", "Fail", "(", "err", "error", ")", "{", "if", "err", "==", "nil", "{", "log", ".", "WithFields", "(", "log", ".", "Fields", "{", "\"", "\"", ":", "ctx", ".", "Request", ".", "URL", ".", "Path", "}", ")", ".", "Warnln", "(", "\"", "\"", ")", "\n", "ctx", ".", "ResponseWriter", ".", "WriteHeader", "(", "http", ".", "StatusInternalServerError", ")", "\n", "ctx", ".", "ResponseWriter", ".", "Write", "(", "nil", ")", "\n", "return", "\n", "}", "\n\n", "if", "ctx", ".", "written", "==", "true", "{", "log", ".", "WithFields", "(", "log", ".", "Fields", "{", "\"", "\"", ":", "ctx", ".", "Request", ".", "URL", ".", "Path", "}", ")", ".", "Warnln", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n\n", "errno", ":=", "0", "\n", "errCore", ",", "ok", ":=", "err", ".", "(", "ICoreError", ")", "\n", "if", "ok", "==", "true", "{", "errno", "=", "errCore", ".", "GetErrno", "(", ")", "\n", "}", "\n", "ctx", ".", "written", "=", "true", "\n", "if", "Production", "==", "false", "{", "log", ".", "WithFields", "(", "log", ".", "Fields", "{", "\"", "\"", ":", "ctx", ".", "Request", ".", "URL", ".", "Path", "}", ")", ".", "Warnln", "(", "err", ".", "Error", "(", ")", ")", "\n", "}", "else", "if", "_", ",", "ok", ":=", "err", ".", "(", "*", "ServerError", ")", ";", "ok", "==", "true", "{", "log", ".", "WithFields", "(", "log", ".", "Fields", "{", "\"", "\"", ":", "ctx", ".", "Request", ".", "URL", ".", "Path", "}", ")", ".", "Warnln", "(", "err", ".", "Error", "(", ")", ")", "\n", "}", "\n\n", "var", "json", "=", "jsoniter", ".", "ConfigCompatibleWithStandardLibrary", "\n", "b", ",", "_", ":=", "json", ".", "Marshal", "(", "&", "ResFormat", "{", "Ok", ":", "false", ",", "Message", ":", "err", ".", "Error", "(", ")", ",", "Errno", ":", "errno", "}", ")", "\n\n", "coreErr", ",", "ok", ":=", "err", ".", "(", "ICoreError", ")", "\n", "if", "ok", "==", "true", "{", "ctx", ".", "ResponseWriter", ".", "WriteHeader", "(", "coreErr", ".", "GetHTTPCode", "(", ")", ")", "\n", "}", "else", "{", "ctx", ".", "ResponseWriter", ".", "WriteHeader", "(", "http", ".", "StatusInternalServerError", ")", "\n", "}", "\n", "ctx", ".", "ResponseWriter", ".", "Write", "(", "b", ")", "\n", "}"], "docstring": "// Fail Response fail", "docstring_tokens": ["Fail", "Response", "fail"], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/context.go#L65-L100", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/projects.mapper.go", "func_name": "ProjectDelete", "original_string": "func (c *ClusterTx) ProjectDelete(name string) error {\n\tstmt := c.stmt(projectDelete)\n\tresult, err := stmt.Exec(name)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Delete project\")\n\t}\n\n\tn, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Fetch affected rows\")\n\t}\n\tif n != 1 {\n\t\treturn fmt.Errorf(\"Query deleted %d rows instead of 1\", n)\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *ClusterTx) ProjectDelete(name string) error {\n\tstmt := c.stmt(projectDelete)\n\tresult, err := stmt.Exec(name)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Delete project\")\n\t}\n\n\tn, err := result.RowsAffected()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Fetch affected rows\")\n\t}\n\tif n != 1 {\n\t\treturn fmt.Errorf(\"Query deleted %d rows instead of 1\", n)\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "ClusterTx", ")", "ProjectDelete", "(", "name", "string", ")", "error", "{", "stmt", ":=", "c", ".", "stmt", "(", "projectDelete", ")", "\n", "result", ",", "err", ":=", "stmt", ".", "Exec", "(", "name", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n\n", "n", ",", "err", ":=", "result", ".", "RowsAffected", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "if", "n", "!=", "1", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "n", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// ProjectDelete deletes the project matching the given key parameters.", "docstring_tokens": ["ProjectDelete", "deletes", "the", "project", "matching", "the", "given", "key", "parameters", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/projects.mapper.go#L434-L450", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "queue/schedule.go", "func_name": "before", "original_string": "func before(i, j ScheduleItem) bool {\n\tiEnd := i.Time().UnixNano() + i.Duration().Nanoseconds()\n\tjStart := j.Time().UnixNano()\n\tif i, ok := i.(ScheduleItemWithTimestamp); ok {\n\t\tif j, ok := j.(ScheduleItemWithTimestamp); ok {\n\t\t\tiEnd = i.Timestamp() + i.Duration().Nanoseconds()\n\t\t\tjStart = j.Timestamp()\n\t\t}\n\t}\n\treturn iEnd < jStart\n}", "language": "go", "code": "func before(i, j ScheduleItem) bool {\n\tiEnd := i.Time().UnixNano() + i.Duration().Nanoseconds()\n\tjStart := j.Time().UnixNano()\n\tif i, ok := i.(ScheduleItemWithTimestamp); ok {\n\t\tif j, ok := j.(ScheduleItemWithTimestamp); ok {\n\t\t\tiEnd = i.Timestamp() + i.Duration().Nanoseconds()\n\t\t\tjStart = j.Timestamp()\n\t\t}\n\t}\n\treturn iEnd < jStart\n}", "code_tokens": ["func", "before", "(", "i", ",", "j", "ScheduleItem", ")", "bool", "{", "iEnd", ":=", "i", ".", "Time", "(", ")", ".", "UnixNano", "(", ")", "+", "i", ".", "Duration", "(", ")", ".", "Nanoseconds", "(", ")", "\n", "jStart", ":=", "j", ".", "Time", "(", ")", ".", "UnixNano", "(", ")", "\n", "if", "i", ",", "ok", ":=", "i", ".", "(", "ScheduleItemWithTimestamp", ")", ";", "ok", "{", "if", "j", ",", "ok", ":=", "j", ".", "(", "ScheduleItemWithTimestamp", ")", ";", "ok", "{", "iEnd", "=", "i", ".", "Timestamp", "(", ")", "+", "i", ".", "Duration", "(", ")", ".", "Nanoseconds", "(", ")", "\n", "jStart", "=", "j", ".", "Timestamp", "(", ")", "\n", "}", "\n", "}", "\n", "return", "iEnd", "<", "jStart", "\n", "}"], "docstring": "// returns true if i before j", "docstring_tokens": ["returns", "true", "if", "i", "before", "j"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/queue/schedule.go#L67-L77", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdctl/ctlv2/command/backup_command.go", "func_name": "saveDB", "original_string": "func saveDB(destDB, srcDB string, idx uint64, v3 bool) {\n\t// open src db to safely copy db state\n\tif v3 {\n\t\tvar src *bolt.DB\n\t\tch := make(chan *bolt.DB, 1)\n\t\tgo func() {\n\t\t\tdb, err := bolt.Open(srcDB, 0444, &bolt.Options{ReadOnly: true})\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tch <- db\n\t\t}()\n\t\tselect {\n\t\tcase src = <-ch:\n\t\tcase <-time.After(time.Second):\n\t\t\tlog.Println(\"waiting to acquire lock on\", srcDB)\n\t\t\tsrc = <-ch\n\t\t}\n\t\tdefer src.Close()\n\n\t\ttx, err := src.Begin(false)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// copy srcDB to destDB\n\t\tdest, err := os.Create(destDB)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif _, err := tx.WriteTo(dest); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdest.Close()\n\t\tif err := tx.Rollback(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\tdb, err := bolt.Open(destDB, 0644, &bolt.Options{})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// remove membership information; should be clobbered by --force-new-cluster\n\tfor _, bucket := range []string{\"members\", \"members_removed\", \"cluster\"} {\n\t\ttx.DeleteBucket([]byte(bucket))\n\t}\n\n\t// update consistent index to match hard state\n\tif !v3 {\n\t\tidxBytes := make([]byte, 8)\n\t\tbinary.BigEndian.PutUint64(idxBytes, idx)\n\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"meta\"))\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tb.Put([]byte(\"consistent_index\"), idxBytes)\n\t}\n\n\tif err := tx.Commit(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}", "language": "go", "code": "func saveDB(destDB, srcDB string, idx uint64, v3 bool) {\n\t// open src db to safely copy db state\n\tif v3 {\n\t\tvar src *bolt.DB\n\t\tch := make(chan *bolt.DB, 1)\n\t\tgo func() {\n\t\t\tdb, err := bolt.Open(srcDB, 0444, &bolt.Options{ReadOnly: true})\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tch <- db\n\t\t}()\n\t\tselect {\n\t\tcase src = <-ch:\n\t\tcase <-time.After(time.Second):\n\t\t\tlog.Println(\"waiting to acquire lock on\", srcDB)\n\t\t\tsrc = <-ch\n\t\t}\n\t\tdefer src.Close()\n\n\t\ttx, err := src.Begin(false)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// copy srcDB to destDB\n\t\tdest, err := os.Create(destDB)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif _, err := tx.WriteTo(dest); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdest.Close()\n\t\tif err := tx.Rollback(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\tdb, err := bolt.Open(destDB, 0644, &bolt.Options{})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// remove membership information; should be clobbered by --force-new-cluster\n\tfor _, bucket := range []string{\"members\", \"members_removed\", \"cluster\"} {\n\t\ttx.DeleteBucket([]byte(bucket))\n\t}\n\n\t// update consistent index to match hard state\n\tif !v3 {\n\t\tidxBytes := make([]byte, 8)\n\t\tbinary.BigEndian.PutUint64(idxBytes, idx)\n\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"meta\"))\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tb.Put([]byte(\"consistent_index\"), idxBytes)\n\t}\n\n\tif err := tx.Commit(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}", "code_tokens": ["func", "saveDB", "(", "destDB", ",", "srcDB", "string", ",", "idx", "uint64", ",", "v3", "bool", ")", "{", "// open src db to safely copy db state", "if", "v3", "{", "var", "src", "*", "bolt", ".", "DB", "\n", "ch", ":=", "make", "(", "chan", "*", "bolt", ".", "DB", ",", "1", ")", "\n", "go", "func", "(", ")", "{", "db", ",", "err", ":=", "bolt", ".", "Open", "(", "srcDB", ",", "0444", ",", "&", "bolt", ".", "Options", "{", "ReadOnly", ":", "true", "}", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "ch", "<-", "db", "\n", "}", "(", ")", "\n", "select", "{", "case", "src", "=", "<-", "ch", ":", "case", "<-", "time", ".", "After", "(", "time", ".", "Second", ")", ":", "log", ".", "Println", "(", "\"", "\"", ",", "srcDB", ")", "\n", "src", "=", "<-", "ch", "\n", "}", "\n", "defer", "src", ".", "Close", "(", ")", "\n\n", "tx", ",", "err", ":=", "src", ".", "Begin", "(", "false", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n\n", "// copy srcDB to destDB", "dest", ",", "err", ":=", "os", ".", "Create", "(", "destDB", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "if", "_", ",", "err", ":=", "tx", ".", "WriteTo", "(", "dest", ")", ";", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "dest", ".", "Close", "(", ")", "\n", "if", "err", ":=", "tx", ".", "Rollback", "(", ")", ";", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "}", "\n\n", "db", ",", "err", ":=", "bolt", ".", "Open", "(", "destDB", ",", "0644", ",", "&", "bolt", ".", "Options", "{", "}", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "tx", ",", "err", ":=", "db", ".", "Begin", "(", "true", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n\n", "// remove membership information; should be clobbered by --force-new-cluster", "for", "_", ",", "bucket", ":=", "range", "[", "]", "string", "{", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", "}", "{", "tx", ".", "DeleteBucket", "(", "[", "]", "byte", "(", "bucket", ")", ")", "\n", "}", "\n\n", "// update consistent index to match hard state", "if", "!", "v3", "{", "idxBytes", ":=", "make", "(", "[", "]", "byte", ",", "8", ")", "\n", "binary", ".", "BigEndian", ".", "PutUint64", "(", "idxBytes", ",", "idx", ")", "\n", "b", ",", "err", ":=", "tx", ".", "CreateBucketIfNotExists", "(", "[", "]", "byte", "(", "\"", "\"", ")", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "b", ".", "Put", "(", "[", "]", "byte", "(", "\"", "\"", ")", ",", "idxBytes", ")", "\n", "}", "\n\n", "if", "err", ":=", "tx", ".", "Commit", "(", ")", ";", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "if", "err", ":=", "db", ".", "Close", "(", ")", ";", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "}"], "docstring": "// saveDB copies the v3 backend and strips cluster information.", "docstring_tokens": ["saveDB", "copies", "the", "v3", "backend", "and", "strips", "cluster", "information", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv2/command/backup_command.go#L187-L257", "partition": "test"}
{"repo": "akutz/gotil", "path": "gotil.go", "func_name": "ReadFileToString", "original_string": "func ReadFileToString(path string) (string, error) {\n\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tscanner.Scan()\n\n\treturn scanner.Text(), nil\n}", "language": "go", "code": "func ReadFileToString(path string) (string, error) {\n\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tscanner.Scan()\n\n\treturn scanner.Text(), nil\n}", "code_tokens": ["func", "ReadFileToString", "(", "path", "string", ")", "(", "string", ",", "error", ")", "{", "f", ",", "err", ":=", "os", ".", "Open", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n", "defer", "f", ".", "Close", "(", ")", "\n\n", "scanner", ":=", "bufio", ".", "NewScanner", "(", "f", ")", "\n", "scanner", ".", "Scan", "(", ")", "\n\n", "return", "scanner", ".", "Text", "(", ")", ",", "nil", "\n", "}"], "docstring": "// ReadFileToString reads the file at the provided path to a string.", "docstring_tokens": ["ReadFileToString", "reads", "the", "file", "at", "the", "provided", "path", "to", "a", "string", "."], "sha": "6fa2e80bd3ac40f15788cfc3d12ebba49a0add92", "url": "https://github.com/akutz/gotil/blob/6fa2e80bd3ac40f15788cfc3d12ebba49a0add92/gotil.go#L80-L92", "partition": "test"}
{"repo": "janos/web", "path": "templates/templates.go", "func_name": "WithTemplateFromFiles", "original_string": "func WithTemplateFromFiles(name string, files ...string) Option {\n\treturn func(o *Options) { o.files[name] = files }\n}", "language": "go", "code": "func WithTemplateFromFiles(name string, files ...string) Option {\n\treturn func(o *Options) { o.files[name] = files }\n}", "code_tokens": ["func", "WithTemplateFromFiles", "(", "name", "string", ",", "files", "...", "string", ")", "Option", "{", "return", "func", "(", "o", "*", "Options", ")", "{", "o", ".", "files", "[", "name", "]", "=", "files", "}", "\n", "}"], "docstring": "// WithTemplateFromFiles adds a template parsed from files.", "docstring_tokens": ["WithTemplateFromFiles", "adds", "a", "template", "parsed", "from", "files", "."], "sha": "0fb0203103deb84424510a8d5166ac00700f2b0e", "url": "https://github.com/janos/web/blob/0fb0203103deb84424510a8d5166ac00700f2b0e/templates/templates.go#L87-L89", "partition": "test"}
{"repo": "hashicorp/raft", "path": "log_cache.go", "func_name": "NewLogCache", "original_string": "func NewLogCache(capacity int, store LogStore) (*LogCache, error) {\n\tif capacity <= 0 {\n\t\treturn nil, fmt.Errorf(\"capacity must be positive\")\n\t}\n\tc := &LogCache{\n\t\tstore: store,\n\t\tcache: make([]*Log, capacity),\n\t}\n\treturn c, nil\n}", "language": "go", "code": "func NewLogCache(capacity int, store LogStore) (*LogCache, error) {\n\tif capacity <= 0 {\n\t\treturn nil, fmt.Errorf(\"capacity must be positive\")\n\t}\n\tc := &LogCache{\n\t\tstore: store,\n\t\tcache: make([]*Log, capacity),\n\t}\n\treturn c, nil\n}", "code_tokens": ["func", "NewLogCache", "(", "capacity", "int", ",", "store", "LogStore", ")", "(", "*", "LogCache", ",", "error", ")", "{", "if", "capacity", "<=", "0", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "c", ":=", "&", "LogCache", "{", "store", ":", "store", ",", "cache", ":", "make", "(", "[", "]", "*", "Log", ",", "capacity", ")", ",", "}", "\n", "return", "c", ",", "nil", "\n", "}"], "docstring": "// NewLogCache is used to create a new LogCache with the\n// given capacity and backend store.", "docstring_tokens": ["NewLogCache", "is", "used", "to", "create", "a", "new", "LogCache", "with", "the", "given", "capacity", "and", "backend", "store", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/log_cache.go#L22-L31", "partition": "test"}
{"repo": "kubicorn/kubicorn", "path": "cmd/apply.go", "func_name": "ApplyCmd", "original_string": "func ApplyCmd() *cobra.Command {\n\tvar ao = &cli.ApplyOptions{}\n\tvar applyCmd = &cobra.Command{\n\t\tUse:   \"apply <NAME>\",\n\t\tShort: \"Apply a cluster resource to a cloud\",\n\t\tLong: `Use this command to apply an API model in a cloud.\n\n\tThis command will attempt to find an API model in a defined state store, and then apply any changes needed directly to a cloud.\n\tThe apply will run once, and ultimately time out if something goes wrong.`,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tswitch len(args) {\n\t\t\tcase 0:\n\t\t\t\tao.Name = viper.GetString(keyKubicornName)\n\t\t\tcase 1:\n\t\t\t\tao.Name = args[0]\n\t\t\tdefault:\n\t\t\t\tlogger.Critical(\"Too many arguments.\")\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\n\t\t\tif err := runApply(ao); err != nil {\n\t\t\t\tlogger.Critical(err.Error())\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t},\n\t}\n\n\tfs := applyCmd.Flags()\n\n\tbindCommonStateStoreFlags(&ao.StateStoreOptions, fs)\n\tbindCommonAwsFlags(&ao.AwsOptions, fs)\n\n\tfs.StringArrayVarP(&ao.Set, keyKubicornSet, \"e\", viper.GetStringSlice(keyKubicornSet), descSet)\n\tfs.StringVar(&ao.AwsProfile, keyAwsProfile, viper.GetString(keyAwsProfile), descAwsProfile)\n\tfs.StringVar(&ao.GitRemote, keyGitConfig, viper.GetString(keyGitConfig), descGitConfig)\n\n\treturn applyCmd\n}", "language": "go", "code": "func ApplyCmd() *cobra.Command {\n\tvar ao = &cli.ApplyOptions{}\n\tvar applyCmd = &cobra.Command{\n\t\tUse:   \"apply <NAME>\",\n\t\tShort: \"Apply a cluster resource to a cloud\",\n\t\tLong: `Use this command to apply an API model in a cloud.\n\n\tThis command will attempt to find an API model in a defined state store, and then apply any changes needed directly to a cloud.\n\tThe apply will run once, and ultimately time out if something goes wrong.`,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tswitch len(args) {\n\t\t\tcase 0:\n\t\t\t\tao.Name = viper.GetString(keyKubicornName)\n\t\t\tcase 1:\n\t\t\t\tao.Name = args[0]\n\t\t\tdefault:\n\t\t\t\tlogger.Critical(\"Too many arguments.\")\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\n\t\t\tif err := runApply(ao); err != nil {\n\t\t\t\tlogger.Critical(err.Error())\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t},\n\t}\n\n\tfs := applyCmd.Flags()\n\n\tbindCommonStateStoreFlags(&ao.StateStoreOptions, fs)\n\tbindCommonAwsFlags(&ao.AwsOptions, fs)\n\n\tfs.StringArrayVarP(&ao.Set, keyKubicornSet, \"e\", viper.GetStringSlice(keyKubicornSet), descSet)\n\tfs.StringVar(&ao.AwsProfile, keyAwsProfile, viper.GetString(keyAwsProfile), descAwsProfile)\n\tfs.StringVar(&ao.GitRemote, keyGitConfig, viper.GetString(keyGitConfig), descGitConfig)\n\n\treturn applyCmd\n}", "code_tokens": ["func", "ApplyCmd", "(", ")", "*", "cobra", ".", "Command", "{", "var", "ao", "=", "&", "cli", ".", "ApplyOptions", "{", "}", "\n", "var", "applyCmd", "=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Long", ":", "`Use this command to apply an API model in a cloud.\n\n\tThis command will attempt to find an API model in a defined state store, and then apply any changes needed directly to a cloud.\n\tThe apply will run once, and ultimately time out if something goes wrong.`", ",", "Run", ":", "func", "(", "cmd", "*", "cobra", ".", "Command", ",", "args", "[", "]", "string", ")", "{", "switch", "len", "(", "args", ")", "{", "case", "0", ":", "ao", ".", "Name", "=", "viper", ".", "GetString", "(", "keyKubicornName", ")", "\n", "case", "1", ":", "ao", ".", "Name", "=", "args", "[", "0", "]", "\n", "default", ":", "logger", ".", "Critical", "(", "\"", "\"", ")", "\n", "os", ".", "Exit", "(", "1", ")", "\n", "}", "\n\n", "if", "err", ":=", "runApply", "(", "ao", ")", ";", "err", "!=", "nil", "{", "logger", ".", "Critical", "(", "err", ".", "Error", "(", ")", ")", "\n", "os", ".", "Exit", "(", "1", ")", "\n", "}", "\n", "}", ",", "}", "\n\n", "fs", ":=", "applyCmd", ".", "Flags", "(", ")", "\n\n", "bindCommonStateStoreFlags", "(", "&", "ao", ".", "StateStoreOptions", ",", "fs", ")", "\n", "bindCommonAwsFlags", "(", "&", "ao", ".", "AwsOptions", ",", "fs", ")", "\n\n", "fs", ".", "StringArrayVarP", "(", "&", "ao", ".", "Set", ",", "keyKubicornSet", ",", "\"", "\"", ",", "viper", ".", "GetStringSlice", "(", "keyKubicornSet", ")", ",", "descSet", ")", "\n", "fs", ".", "StringVar", "(", "&", "ao", ".", "AwsProfile", ",", "keyAwsProfile", ",", "viper", ".", "GetString", "(", "keyAwsProfile", ")", ",", "descAwsProfile", ")", "\n", "fs", ".", "StringVar", "(", "&", "ao", ".", "GitRemote", ",", "keyGitConfig", ",", "viper", ".", "GetString", "(", "keyGitConfig", ")", ",", "descGitConfig", ")", "\n\n", "return", "applyCmd", "\n", "}"], "docstring": "// ApplyCmd represents the apply command", "docstring_tokens": ["ApplyCmd", "represents", "the", "apply", "command"], "sha": "c4a4b80994b4333709c0f8164faabd801866b986", "url": "https://github.com/kubicorn/kubicorn/blob/c4a4b80994b4333709c0f8164faabd801866b986/cmd/apply.go#L39-L76", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "greenhouse/diskcache/cache.go", "func_name": "NewCache", "original_string": "func NewCache(diskRoot string) *Cache {\n\treturn &Cache{\n\t\tdiskRoot: strings.TrimSuffix(diskRoot, string(os.PathListSeparator)),\n\t}\n}", "language": "go", "code": "func NewCache(diskRoot string) *Cache {\n\treturn &Cache{\n\t\tdiskRoot: strings.TrimSuffix(diskRoot, string(os.PathListSeparator)),\n\t}\n}", "code_tokens": ["func", "NewCache", "(", "diskRoot", "string", ")", "*", "Cache", "{", "return", "&", "Cache", "{", "diskRoot", ":", "strings", ".", "TrimSuffix", "(", "diskRoot", ",", "string", "(", "os", ".", "PathListSeparator", ")", ")", ",", "}", "\n", "}"], "docstring": "// NewCache returns a new Cache given the root directory that should be used\n// on disk for cache storage", "docstring_tokens": ["NewCache", "returns", "a", "new", "Cache", "given", "the", "root", "directory", "that", "should", "be", "used", "on", "disk", "for", "cache", "storage"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/greenhouse/diskcache/cache.go#L47-L51", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/external-plugins/needs-rebase/plugin/plugin.go", "func_name": "HandleEvent", "original_string": "func HandleEvent(log *logrus.Entry, ghc githubClient, pre *github.PullRequestEvent) error {\n\tif pre.Action != github.PullRequestActionOpened && pre.Action != github.PullRequestActionSynchronize && pre.Action != github.PullRequestActionReopened {\n\t\treturn nil\n\t}\n\n\t// Before checking mergeability wait a few seconds to give github a chance to calculate it.\n\t// This initial delay prevents us from always wasting the first API token.\n\tsleep(time.Second * 5)\n\n\torg := pre.Repo.Owner.Login\n\trepo := pre.Repo.Name\n\tnumber := pre.Number\n\tsha := pre.PullRequest.Head.SHA\n\n\tmergeable, err := ghc.IsMergeable(org, repo, number, sha)\n\tif err != nil {\n\t\treturn err\n\t}\n\tissueLabels, err := ghc.GetIssueLabels(org, repo, number)\n\tif err != nil {\n\t\treturn err\n\t}\n\thasLabel := github.HasLabel(labels.NeedsRebase, issueLabels)\n\n\treturn takeAction(log, ghc, org, repo, number, pre.PullRequest.User.Login, hasLabel, mergeable)\n}", "language": "go", "code": "func HandleEvent(log *logrus.Entry, ghc githubClient, pre *github.PullRequestEvent) error {\n\tif pre.Action != github.PullRequestActionOpened && pre.Action != github.PullRequestActionSynchronize && pre.Action != github.PullRequestActionReopened {\n\t\treturn nil\n\t}\n\n\t// Before checking mergeability wait a few seconds to give github a chance to calculate it.\n\t// This initial delay prevents us from always wasting the first API token.\n\tsleep(time.Second * 5)\n\n\torg := pre.Repo.Owner.Login\n\trepo := pre.Repo.Name\n\tnumber := pre.Number\n\tsha := pre.PullRequest.Head.SHA\n\n\tmergeable, err := ghc.IsMergeable(org, repo, number, sha)\n\tif err != nil {\n\t\treturn err\n\t}\n\tissueLabels, err := ghc.GetIssueLabels(org, repo, number)\n\tif err != nil {\n\t\treturn err\n\t}\n\thasLabel := github.HasLabel(labels.NeedsRebase, issueLabels)\n\n\treturn takeAction(log, ghc, org, repo, number, pre.PullRequest.User.Login, hasLabel, mergeable)\n}", "code_tokens": ["func", "HandleEvent", "(", "log", "*", "logrus", ".", "Entry", ",", "ghc", "githubClient", ",", "pre", "*", "github", ".", "PullRequestEvent", ")", "error", "{", "if", "pre", ".", "Action", "!=", "github", ".", "PullRequestActionOpened", "&&", "pre", ".", "Action", "!=", "github", ".", "PullRequestActionSynchronize", "&&", "pre", ".", "Action", "!=", "github", ".", "PullRequestActionReopened", "{", "return", "nil", "\n", "}", "\n\n", "// Before checking mergeability wait a few seconds to give github a chance to calculate it.", "// This initial delay prevents us from always wasting the first API token.", "sleep", "(", "time", ".", "Second", "*", "5", ")", "\n\n", "org", ":=", "pre", ".", "Repo", ".", "Owner", ".", "Login", "\n", "repo", ":=", "pre", ".", "Repo", ".", "Name", "\n", "number", ":=", "pre", ".", "Number", "\n", "sha", ":=", "pre", ".", "PullRequest", ".", "Head", ".", "SHA", "\n\n", "mergeable", ",", "err", ":=", "ghc", ".", "IsMergeable", "(", "org", ",", "repo", ",", "number", ",", "sha", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "issueLabels", ",", "err", ":=", "ghc", ".", "GetIssueLabels", "(", "org", ",", "repo", ",", "number", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "hasLabel", ":=", "github", ".", "HasLabel", "(", "labels", ".", "NeedsRebase", ",", "issueLabels", ")", "\n\n", "return", "takeAction", "(", "log", ",", "ghc", ",", "org", ",", "repo", ",", "number", ",", "pre", ".", "PullRequest", ".", "User", ".", "Login", ",", "hasLabel", ",", "mergeable", ")", "\n", "}"], "docstring": "// HandleEvent handles a GitHub PR event to determine if the \"needs-rebase\"\n// label needs to be added or removed. It depends on GitHub mergeability check\n// to decide the need for a rebase.", "docstring_tokens": ["HandleEvent", "handles", "a", "GitHub", "PR", "event", "to", "determine", "if", "the", "needs", "-", "rebase", "label", "needs", "to", "be", "added", "or", "removed", ".", "It", "depends", "on", "GitHub", "mergeability", "check", "to", "decide", "the", "need", "for", "a", "rebase", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/external-plugins/needs-rebase/plugin/plugin.go#L71-L96", "partition": "test"}
{"repo": "256dpi/fire", "path": "body_limiter.go", "func_name": "LimitBody", "original_string": "func LimitBody(w http.ResponseWriter, r *http.Request, n int64) {\n\t// get original body from existing limiter\n\tif bl, ok := r.Body.(*BodyLimiter); ok {\n\t\tr.Body = bl.Original\n\t}\n\n\t// set new limiter\n\tr.Body = NewBodyLimiter(w, r, n)\n}", "language": "go", "code": "func LimitBody(w http.ResponseWriter, r *http.Request, n int64) {\n\t// get original body from existing limiter\n\tif bl, ok := r.Body.(*BodyLimiter); ok {\n\t\tr.Body = bl.Original\n\t}\n\n\t// set new limiter\n\tr.Body = NewBodyLimiter(w, r, n)\n}", "code_tokens": ["func", "LimitBody", "(", "w", "http", ".", "ResponseWriter", ",", "r", "*", "http", ".", "Request", ",", "n", "int64", ")", "{", "// get original body from existing limiter", "if", "bl", ",", "ok", ":=", "r", ".", "Body", ".", "(", "*", "BodyLimiter", ")", ";", "ok", "{", "r", ".", "Body", "=", "bl", ".", "Original", "\n", "}", "\n\n", "// set new limiter", "r", ".", "Body", "=", "NewBodyLimiter", "(", "w", ",", "r", ",", "n", ")", "\n", "}"], "docstring": "// LimitBody will limit reading from the body of the supplied request to the\n// specified amount of bytes. Earlier calls to LimitBody will be overwritten\n// which essentially allows callers to increase the limit from a default limit.", "docstring_tokens": ["LimitBody", "will", "limit", "reading", "from", "the", "body", "of", "the", "supplied", "request", "to", "the", "specified", "amount", "of", "bytes", ".", "Earlier", "calls", "to", "LimitBody", "will", "be", "overwritten", "which", "essentially", "allows", "callers", "to", "increase", "the", "limit", "from", "a", "default", "limit", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/body_limiter.go#L27-L35", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "rule/rule.go", "func_name": "AttrString", "original_string": "func (r *Rule) AttrString(key string) string {\n\tattr, ok := r.attrs[key]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tstr, ok := attr.RHS.(*bzl.StringExpr)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn str.Value\n}", "language": "go", "code": "func (r *Rule) AttrString(key string) string {\n\tattr, ok := r.attrs[key]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tstr, ok := attr.RHS.(*bzl.StringExpr)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn str.Value\n}", "code_tokens": ["func", "(", "r", "*", "Rule", ")", "AttrString", "(", "key", "string", ")", "string", "{", "attr", ",", "ok", ":=", "r", ".", "attrs", "[", "key", "]", "\n", "if", "!", "ok", "{", "return", "\"", "\"", "\n", "}", "\n", "str", ",", "ok", ":=", "attr", ".", "RHS", ".", "(", "*", "bzl", ".", "StringExpr", ")", "\n", "if", "!", "ok", "{", "return", "\"", "\"", "\n", "}", "\n", "return", "str", ".", "Value", "\n", "}"], "docstring": "// AttrString returns the value of the named attribute if it is a scalar string.\n// \"\" is returned if the attribute is not set or is not a string.", "docstring_tokens": ["AttrString", "returns", "the", "value", "of", "the", "named", "attribute", "if", "it", "is", "a", "scalar", "string", ".", "is", "returned", "if", "the", "attribute", "is", "not", "set", "or", "is", "not", "a", "string", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/rule/rule.go#L659-L669", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/auth/cmds/cmds.go", "func_name": "GetAuthTokenCmd", "original_string": "func GetAuthTokenCmd(noMetrics, noPortForwarding *bool) *cobra.Command {\n\tvar quiet bool\n\tgetAuthToken := &cobra.Command{\n\t\tUse:   \"{{alias}} <username>\",\n\t\tShort: \"Get an auth token that authenticates the holder as \\\"username\\\"\",\n\t\tLong: \"Get an auth token that authenticates the holder as \\\"username\\\"; \" +\n\t\t\t\"this can only be called by cluster admins\",\n\t\tRun: cmdutil.RunFixedArgs(1, func(args []string) error {\n\t\t\tsubject := args[0]\n\t\t\tc, err := client.NewOnUserMachine(!*noMetrics, !*noPortForwarding, \"user\")\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not connect: %v\", err)\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tresp, err := c.GetAuthToken(c.Ctx(), &auth.GetAuthTokenRequest{\n\t\t\t\tSubject: subject,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn grpcutil.ScrubGRPC(err)\n\t\t\t}\n\t\t\tif quiet {\n\t\t\t\tfmt.Println(resp.Token)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"New credentials:\\n  Subject: %s\\n  Token: %s\\n\", resp.Subject, resp.Token)\n\t\t\t}\n\t\t\treturn nil\n\t\t}),\n\t}\n\tgetAuthToken.PersistentFlags().BoolVarP(&quiet, \"quiet\", \"q\", false, \"if \"+\n\t\t\"set, only print the resulting token (if successful). This is useful for \"+\n\t\t\"scripting, as the output can be piped to use-auth-token\")\n\treturn cmdutil.CreateAlias(getAuthToken, \"auth get-auth-token\")\n}", "language": "go", "code": "func GetAuthTokenCmd(noMetrics, noPortForwarding *bool) *cobra.Command {\n\tvar quiet bool\n\tgetAuthToken := &cobra.Command{\n\t\tUse:   \"{{alias}} <username>\",\n\t\tShort: \"Get an auth token that authenticates the holder as \\\"username\\\"\",\n\t\tLong: \"Get an auth token that authenticates the holder as \\\"username\\\"; \" +\n\t\t\t\"this can only be called by cluster admins\",\n\t\tRun: cmdutil.RunFixedArgs(1, func(args []string) error {\n\t\t\tsubject := args[0]\n\t\t\tc, err := client.NewOnUserMachine(!*noMetrics, !*noPortForwarding, \"user\")\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not connect: %v\", err)\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tresp, err := c.GetAuthToken(c.Ctx(), &auth.GetAuthTokenRequest{\n\t\t\t\tSubject: subject,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn grpcutil.ScrubGRPC(err)\n\t\t\t}\n\t\t\tif quiet {\n\t\t\t\tfmt.Println(resp.Token)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"New credentials:\\n  Subject: %s\\n  Token: %s\\n\", resp.Subject, resp.Token)\n\t\t\t}\n\t\t\treturn nil\n\t\t}),\n\t}\n\tgetAuthToken.PersistentFlags().BoolVarP(&quiet, \"quiet\", \"q\", false, \"if \"+\n\t\t\"set, only print the resulting token (if successful). This is useful for \"+\n\t\t\"scripting, as the output can be piped to use-auth-token\")\n\treturn cmdutil.CreateAlias(getAuthToken, \"auth get-auth-token\")\n}", "code_tokens": ["func", "GetAuthTokenCmd", "(", "noMetrics", ",", "noPortForwarding", "*", "bool", ")", "*", "cobra", ".", "Command", "{", "var", "quiet", "bool", "\n", "getAuthToken", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\\\"", "\\\"", "\"", ",", "Long", ":", "\"", "\\\"", "\\\"", "\"", "+", "\"", "\"", ",", "Run", ":", "cmdutil", ".", "RunFixedArgs", "(", "1", ",", "func", "(", "args", "[", "]", "string", ")", "error", "{", "subject", ":=", "args", "[", "0", "]", "\n", "c", ",", "err", ":=", "client", ".", "NewOnUserMachine", "(", "!", "*", "noMetrics", ",", "!", "*", "noPortForwarding", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "defer", "c", ".", "Close", "(", ")", "\n", "resp", ",", "err", ":=", "c", ".", "GetAuthToken", "(", "c", ".", "Ctx", "(", ")", ",", "&", "auth", ".", "GetAuthTokenRequest", "{", "Subject", ":", "subject", ",", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}", "\n", "if", "quiet", "{", "fmt", ".", "Println", "(", "resp", ".", "Token", ")", "\n", "}", "else", "{", "fmt", ".", "Printf", "(", "\"", "\\n", "\\n", "\\n", "\"", ",", "resp", ".", "Subject", ",", "resp", ".", "Token", ")", "\n", "}", "\n", "return", "nil", "\n", "}", ")", ",", "}", "\n", "getAuthToken", ".", "PersistentFlags", "(", ")", ".", "BoolVarP", "(", "&", "quiet", ",", "\"", "\"", ",", "\"", "\"", ",", "false", ",", "\"", "\"", "+", "\"", "\"", "+", "\"", "\"", ")", "\n", "return", "cmdutil", ".", "CreateAlias", "(", "getAuthToken", ",", "\"", "\"", ")", "\n", "}"], "docstring": "// GetAuthTokenCmd returns a cobra command that lets a user get a pachyderm\n// token on behalf of themselves or another user", "docstring_tokens": ["GetAuthTokenCmd", "returns", "a", "cobra", "command", "that", "lets", "a", "user", "get", "a", "pachyderm", "token", "on", "behalf", "of", "themselves", "or", "another", "user"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/auth/cmds/cmds.go#L436-L468", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/kube/dry_run_client.go", "func_name": "Watch", "original_string": "func (c *dryRunProwJobClient) Watch(opts metav1.ListOptions) (watch.Interface, error) {\n\treturn nil, nil\n}", "language": "go", "code": "func (c *dryRunProwJobClient) Watch(opts metav1.ListOptions) (watch.Interface, error) {\n\treturn nil, nil\n}", "code_tokens": ["func", "(", "c", "*", "dryRunProwJobClient", ")", "Watch", "(", "opts", "metav1", ".", "ListOptions", ")", "(", "watch", ".", "Interface", ",", "error", ")", "{", "return", "nil", ",", "nil", "\n", "}"], "docstring": "// Watch does nothing on a dry-run client", "docstring_tokens": ["Watch", "does", "nothing", "on", "a", "dry", "-", "run", "client"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/kube/dry_run_client.go#L172-L174", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/ledger_key.go", "func_name": "Equals", "original_string": "func (key *LedgerKey) Equals(other LedgerKey) bool {\n\tif key.Type != other.Type {\n\t\treturn false\n\t}\n\n\tswitch key.Type {\n\tcase LedgerEntryTypeAccount:\n\t\tl := key.MustAccount()\n\t\tr := other.MustAccount()\n\t\treturn l.AccountId.Equals(r.AccountId)\n\tcase LedgerEntryTypeData:\n\t\tl := key.MustData()\n\t\tr := other.MustData()\n\t\treturn l.AccountId.Equals(r.AccountId) && l.DataName == r.DataName\n\tcase LedgerEntryTypeOffer:\n\t\tl := key.MustOffer()\n\t\tr := other.MustOffer()\n\t\treturn l.SellerId.Equals(r.SellerId) && l.OfferId == r.OfferId\n\tcase LedgerEntryTypeTrustline:\n\t\tl := key.MustTrustLine()\n\t\tr := other.MustTrustLine()\n\t\treturn l.AccountId.Equals(r.AccountId) && l.Asset.Equals(r.Asset)\n\tdefault:\n\t\tpanic(fmt.Errorf(\"Unknown ledger key type: %v\", key.Type))\n\t}\n}", "language": "go", "code": "func (key *LedgerKey) Equals(other LedgerKey) bool {\n\tif key.Type != other.Type {\n\t\treturn false\n\t}\n\n\tswitch key.Type {\n\tcase LedgerEntryTypeAccount:\n\t\tl := key.MustAccount()\n\t\tr := other.MustAccount()\n\t\treturn l.AccountId.Equals(r.AccountId)\n\tcase LedgerEntryTypeData:\n\t\tl := key.MustData()\n\t\tr := other.MustData()\n\t\treturn l.AccountId.Equals(r.AccountId) && l.DataName == r.DataName\n\tcase LedgerEntryTypeOffer:\n\t\tl := key.MustOffer()\n\t\tr := other.MustOffer()\n\t\treturn l.SellerId.Equals(r.SellerId) && l.OfferId == r.OfferId\n\tcase LedgerEntryTypeTrustline:\n\t\tl := key.MustTrustLine()\n\t\tr := other.MustTrustLine()\n\t\treturn l.AccountId.Equals(r.AccountId) && l.Asset.Equals(r.Asset)\n\tdefault:\n\t\tpanic(fmt.Errorf(\"Unknown ledger key type: %v\", key.Type))\n\t}\n}", "code_tokens": ["func", "(", "key", "*", "LedgerKey", ")", "Equals", "(", "other", "LedgerKey", ")", "bool", "{", "if", "key", ".", "Type", "!=", "other", ".", "Type", "{", "return", "false", "\n", "}", "\n\n", "switch", "key", ".", "Type", "{", "case", "LedgerEntryTypeAccount", ":", "l", ":=", "key", ".", "MustAccount", "(", ")", "\n", "r", ":=", "other", ".", "MustAccount", "(", ")", "\n", "return", "l", ".", "AccountId", ".", "Equals", "(", "r", ".", "AccountId", ")", "\n", "case", "LedgerEntryTypeData", ":", "l", ":=", "key", ".", "MustData", "(", ")", "\n", "r", ":=", "other", ".", "MustData", "(", ")", "\n", "return", "l", ".", "AccountId", ".", "Equals", "(", "r", ".", "AccountId", ")", "&&", "l", ".", "DataName", "==", "r", ".", "DataName", "\n", "case", "LedgerEntryTypeOffer", ":", "l", ":=", "key", ".", "MustOffer", "(", ")", "\n", "r", ":=", "other", ".", "MustOffer", "(", ")", "\n", "return", "l", ".", "SellerId", ".", "Equals", "(", "r", ".", "SellerId", ")", "&&", "l", ".", "OfferId", "==", "r", ".", "OfferId", "\n", "case", "LedgerEntryTypeTrustline", ":", "l", ":=", "key", ".", "MustTrustLine", "(", ")", "\n", "r", ":=", "other", ".", "MustTrustLine", "(", ")", "\n", "return", "l", ".", "AccountId", ".", "Equals", "(", "r", ".", "AccountId", ")", "&&", "l", ".", "Asset", ".", "Equals", "(", "r", ".", "Asset", ")", "\n", "default", ":", "panic", "(", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "key", ".", "Type", ")", ")", "\n", "}", "\n", "}"], "docstring": "// Equals returns true if `other` is equivalent to `key`", "docstring_tokens": ["Equals", "returns", "true", "if", "other", "is", "equivalent", "to", "key"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/ledger_key.go#L11-L36", "partition": "test"}
{"repo": "rightscale/rsc", "path": "displayer.go", "func_name": "ApplySingleExtract", "original_string": "func (d *Displayer) ApplySingleExtract(extract string) error {\n\tif err := d.ApplyExtract(extract, true); err != nil {\n\t\treturn err\n\t}\n\toutputs := d.RawOutput.([]interface{})\n\tif len(outputs) != 1 {\n\t\td.RawOutput = nil\n\t\treturn fmt.Errorf(\"JSON selector '%s' returned %d instead of one value\",\n\t\t\textract, len(outputs))\n\t}\n\tif len(outputs) == 0 {\n\t\td.RawOutput = \"\"\n\t} else {\n\t\tswitch v := outputs[0].(type) {\n\t\tcase nil:\n\t\t\td.RawOutput = \"\"\n\t\tcase float64, bool:\n\t\t\td.RawOutput = fmt.Sprint(v)\n\t\tcase string:\n\t\t\td.RawOutput = v\n\t\tdefault:\n\t\t\td.RawOutput = v\n\t\t}\n\t\td.RawOutput = outputs[0]\n\t}\n\treturn nil\n}", "language": "go", "code": "func (d *Displayer) ApplySingleExtract(extract string) error {\n\tif err := d.ApplyExtract(extract, true); err != nil {\n\t\treturn err\n\t}\n\toutputs := d.RawOutput.([]interface{})\n\tif len(outputs) != 1 {\n\t\td.RawOutput = nil\n\t\treturn fmt.Errorf(\"JSON selector '%s' returned %d instead of one value\",\n\t\t\textract, len(outputs))\n\t}\n\tif len(outputs) == 0 {\n\t\td.RawOutput = \"\"\n\t} else {\n\t\tswitch v := outputs[0].(type) {\n\t\tcase nil:\n\t\t\td.RawOutput = \"\"\n\t\tcase float64, bool:\n\t\t\td.RawOutput = fmt.Sprint(v)\n\t\tcase string:\n\t\t\td.RawOutput = v\n\t\tdefault:\n\t\t\td.RawOutput = v\n\t\t}\n\t\td.RawOutput = outputs[0]\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "d", "*", "Displayer", ")", "ApplySingleExtract", "(", "extract", "string", ")", "error", "{", "if", "err", ":=", "d", ".", "ApplyExtract", "(", "extract", ",", "true", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "outputs", ":=", "d", ".", "RawOutput", ".", "(", "[", "]", "interface", "{", "}", ")", "\n", "if", "len", "(", "outputs", ")", "!=", "1", "{", "d", ".", "RawOutput", "=", "nil", "\n", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "extract", ",", "len", "(", "outputs", ")", ")", "\n", "}", "\n", "if", "len", "(", "outputs", ")", "==", "0", "{", "d", ".", "RawOutput", "=", "\"", "\"", "\n", "}", "else", "{", "switch", "v", ":=", "outputs", "[", "0", "]", ".", "(", "type", ")", "{", "case", "nil", ":", "d", ".", "RawOutput", "=", "\"", "\"", "\n", "case", "float64", ",", "bool", ":", "d", ".", "RawOutput", "=", "fmt", ".", "Sprint", "(", "v", ")", "\n", "case", "string", ":", "d", ".", "RawOutput", "=", "v", "\n", "default", ":", "d", ".", "RawOutput", "=", "v", "\n", "}", "\n", "d", ".", "RawOutput", "=", "outputs", "[", "0", "]", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// ApplySingleExtract applies the given JSON selector and returns the results.\n// It's an error if the selector yields more than one value.", "docstring_tokens": ["ApplySingleExtract", "applies", "the", "given", "JSON", "selector", "and", "returns", "the", "results", ".", "It", "s", "an", "error", "if", "the", "selector", "yields", "more", "than", "one", "value", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/displayer.go#L40-L66", "partition": "test"}
{"repo": "apuigsech/seekret", "path": "models/exception.go", "func_name": "SetRule", "original_string": "func (x *Exception) SetRule(rule string) error {\n\truleRegexp, err := regexp.Compile(\"(?i)\" + rule)\n\tif err != nil {\n\t\treturn err\n\t}\n\tx.Rule = ruleRegexp\n\treturn nil\n}", "language": "go", "code": "func (x *Exception) SetRule(rule string) error {\n\truleRegexp, err := regexp.Compile(\"(?i)\" + rule)\n\tif err != nil {\n\t\treturn err\n\t}\n\tx.Rule = ruleRegexp\n\treturn nil\n}", "code_tokens": ["func", "(", "x", "*", "Exception", ")", "SetRule", "(", "rule", "string", ")", "error", "{", "ruleRegexp", ",", "err", ":=", "regexp", ".", "Compile", "(", "\"", "\"", "+", "rule", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "x", ".", "Rule", "=", "ruleRegexp", "\n", "return", "nil", "\n", "}"], "docstring": "// SetRule sets the regular expresion that should match the name of the rule.", "docstring_tokens": ["SetRule", "sets", "the", "regular", "expresion", "that", "should", "match", "the", "name", "of", "the", "rule", "."], "sha": "9b1f7ea1b3fd5bd29d93cf62102cb66e54428a49", "url": "https://github.com/apuigsech/seekret/blob/9b1f7ea1b3fd5bd29d93cf62102cb66e54428a49/models/exception.go#L40-L47", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/flagutil/github.go", "func_name": "GitClient", "original_string": "func (o *GitHubOptions) GitClient(secretAgent *secret.Agent, dryRun bool) (client *git.Client, err error) {\n\tclient, err = git.NewClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We must capture the value of client here to prevent issues related\n\t// to the use of named return values when an error is encountered.\n\t// Without this, we risk a nil pointer dereference.\n\tdefer func(client *git.Client) {\n\t\tif err != nil {\n\t\t\tclient.Clean()\n\t\t}\n\t}(client)\n\n\t// Get the bot's name in order to set credentials for the Git client.\n\tgithubClient, err := o.GitHubClient(secretAgent, dryRun)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting GitHub client: %v\", err)\n\t}\n\tbotName, err := githubClient.BotName()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting bot name: %v\", err)\n\t}\n\tclient.SetCredentials(botName, secretAgent.GetTokenGenerator(o.TokenPath))\n\n\treturn client, nil\n}", "language": "go", "code": "func (o *GitHubOptions) GitClient(secretAgent *secret.Agent, dryRun bool) (client *git.Client, err error) {\n\tclient, err = git.NewClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// We must capture the value of client here to prevent issues related\n\t// to the use of named return values when an error is encountered.\n\t// Without this, we risk a nil pointer dereference.\n\tdefer func(client *git.Client) {\n\t\tif err != nil {\n\t\t\tclient.Clean()\n\t\t}\n\t}(client)\n\n\t// Get the bot's name in order to set credentials for the Git client.\n\tgithubClient, err := o.GitHubClient(secretAgent, dryRun)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting GitHub client: %v\", err)\n\t}\n\tbotName, err := githubClient.BotName()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting bot name: %v\", err)\n\t}\n\tclient.SetCredentials(botName, secretAgent.GetTokenGenerator(o.TokenPath))\n\n\treturn client, nil\n}", "code_tokens": ["func", "(", "o", "*", "GitHubOptions", ")", "GitClient", "(", "secretAgent", "*", "secret", ".", "Agent", ",", "dryRun", "bool", ")", "(", "client", "*", "git", ".", "Client", ",", "err", "error", ")", "{", "client", ",", "err", "=", "git", ".", "NewClient", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "// We must capture the value of client here to prevent issues related", "// to the use of named return values when an error is encountered.", "// Without this, we risk a nil pointer dereference.", "defer", "func", "(", "client", "*", "git", ".", "Client", ")", "{", "if", "err", "!=", "nil", "{", "client", ".", "Clean", "(", ")", "\n", "}", "\n", "}", "(", "client", ")", "\n\n", "// Get the bot's name in order to set credentials for the Git client.", "githubClient", ",", "err", ":=", "o", ".", "GitHubClient", "(", "secretAgent", ",", "dryRun", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "botName", ",", "err", ":=", "githubClient", ".", "BotName", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "client", ".", "SetCredentials", "(", "botName", ",", "secretAgent", ".", "GetTokenGenerator", "(", "o", ".", "TokenPath", ")", ")", "\n\n", "return", "client", ",", "nil", "\n", "}"], "docstring": "// GitClient returns a Git client.", "docstring_tokens": ["GitClient", "returns", "a", "Git", "client", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/flagutil/github.go#L119-L146", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_storage_volumes.go", "func_name": "DeleteStoragePoolVolume", "original_string": "func (r *ProtocolLXD) DeleteStoragePoolVolume(pool string, volType string, name string) error {\n\tif !r.HasExtension(\"storage\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"storage\\\" API extension\")\n\t}\n\n\t// Send the request\n\tpath := fmt.Sprintf(\"/storage-pools/%s/volumes/%s/%s\", url.QueryEscape(pool), url.QueryEscape(volType), url.QueryEscape(name))\n\t_, _, err := r.query(\"DELETE\", path, nil, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (r *ProtocolLXD) DeleteStoragePoolVolume(pool string, volType string, name string) error {\n\tif !r.HasExtension(\"storage\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"storage\\\" API extension\")\n\t}\n\n\t// Send the request\n\tpath := fmt.Sprintf(\"/storage-pools/%s/volumes/%s/%s\", url.QueryEscape(pool), url.QueryEscape(volType), url.QueryEscape(name))\n\t_, _, err := r.query(\"DELETE\", path, nil, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "DeleteStoragePoolVolume", "(", "pool", "string", ",", "volType", "string", ",", "name", "string", ")", "error", "{", "if", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "// Send the request", "path", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "pool", ")", ",", "url", ".", "QueryEscape", "(", "volType", ")", ",", "url", ".", "QueryEscape", "(", "name", ")", ")", "\n", "_", ",", "_", ",", "err", ":=", "r", ".", "query", "(", "\"", "\"", ",", "path", ",", "nil", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// DeleteStoragePoolVolume deletes a storage pool", "docstring_tokens": ["DeleteStoragePoolVolume", "deletes", "a", "storage", "pool"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_storage_volumes.go#L578-L591", "partition": "test"}
{"repo": "sclevine/agouti", "path": "selection_frames.go", "func_name": "SwitchToFrame", "original_string": "func (s *Selection) SwitchToFrame() error {\n\tselectedElement, err := s.elements.GetExactlyOne()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to select element from %s: %s\", s, err)\n\t}\n\n\tif err := s.session.Frame(selectedElement.(*api.Element)); err != nil {\n\t\treturn fmt.Errorf(\"failed to switch to frame referred to by %s: %s\", s, err)\n\t}\n\treturn nil\n}", "language": "go", "code": "func (s *Selection) SwitchToFrame() error {\n\tselectedElement, err := s.elements.GetExactlyOne()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to select element from %s: %s\", s, err)\n\t}\n\n\tif err := s.session.Frame(selectedElement.(*api.Element)); err != nil {\n\t\treturn fmt.Errorf(\"failed to switch to frame referred to by %s: %s\", s, err)\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "s", "*", "Selection", ")", "SwitchToFrame", "(", ")", "error", "{", "selectedElement", ",", "err", ":=", "s", ".", "elements", ".", "GetExactlyOne", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "s", ",", "err", ")", "\n", "}", "\n\n", "if", "err", ":=", "s", ".", "session", ".", "Frame", "(", "selectedElement", ".", "(", "*", "api", ".", "Element", ")", ")", ";", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "s", ",", "err", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// SwitchToFrame focuses on the frame specified by the selection. All new and\n// existing selections will refer to the new frame. All further Page methods\n// will apply to this frame as well.", "docstring_tokens": ["SwitchToFrame", "focuses", "on", "the", "frame", "specified", "by", "the", "selection", ".", "All", "new", "and", "existing", "selections", "will", "refer", "to", "the", "new", "frame", ".", "All", "further", "Page", "methods", "will", "apply", "to", "this", "frame", "as", "well", "."], "sha": "96599c91888f1b1cf2dccc7f1776ba7f511909e5", "url": "https://github.com/sclevine/agouti/blob/96599c91888f1b1cf2dccc7f1776ba7f511909e5/selection_frames.go#L12-L22", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/compact_op.go", "func_name": "OpCompact", "original_string": "func OpCompact(rev int64, opts ...CompactOption) CompactOp {\n\tret := CompactOp{revision: rev}\n\tret.applyCompactOpts(opts)\n\treturn ret\n}", "language": "go", "code": "func OpCompact(rev int64, opts ...CompactOption) CompactOp {\n\tret := CompactOp{revision: rev}\n\tret.applyCompactOpts(opts)\n\treturn ret\n}", "code_tokens": ["func", "OpCompact", "(", "rev", "int64", ",", "opts", "...", "CompactOption", ")", "CompactOp", "{", "ret", ":=", "CompactOp", "{", "revision", ":", "rev", "}", "\n", "ret", ".", "applyCompactOpts", "(", "opts", ")", "\n", "return", "ret", "\n", "}"], "docstring": "// OpCompact wraps slice CompactOption to create a CompactOp.", "docstring_tokens": ["OpCompact", "wraps", "slice", "CompactOption", "to", "create", "a", "CompactOp", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/compact_op.go#L37-L41", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "emulation/emulation.go", "func_name": "Do", "original_string": "func (p *SetUserAgentOverrideParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetUserAgentOverride, p, nil)\n}", "language": "go", "code": "func (p *SetUserAgentOverrideParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetUserAgentOverride, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetUserAgentOverrideParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetUserAgentOverride", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Emulation.setUserAgentOverride against the provided context.", "docstring_tokens": ["Do", "executes", "Emulation", ".", "setUserAgentOverride", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/emulation/emulation.go#L593-L595", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "network/network.go", "func_name": "WithExpires", "original_string": "func (p SetCookieParams) WithExpires(expires *cdp.TimeSinceEpoch) *SetCookieParams {\n\tp.Expires = expires\n\treturn &p\n}", "language": "go", "code": "func (p SetCookieParams) WithExpires(expires *cdp.TimeSinceEpoch) *SetCookieParams {\n\tp.Expires = expires\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "SetCookieParams", ")", "WithExpires", "(", "expires", "*", "cdp", ".", "TimeSinceEpoch", ")", "*", "SetCookieParams", "{", "p", ".", "Expires", "=", "expires", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithExpires cookie expiration date, session cookie if not set.", "docstring_tokens": ["WithExpires", "cookie", "expiration", "date", "session", "cookie", "if", "not", "set", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/network/network.go#L799-L802", "partition": "test"}
{"repo": "bcurren/go-ssdp", "path": "ssdp.go", "func_name": "Search", "original_string": "func Search(st string, mx time.Duration) ([]SearchResponse, error) {\n\tconn, err := listenForSearchResponses()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tsearchBytes, broadcastAddr := buildSearchRequest(st, mx)\n\t// Write search bytes on the wire so all devices can respond\n\t_, err = conn.WriteTo(searchBytes, broadcastAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn readSearchResponses(conn, mx)\n}", "language": "go", "code": "func Search(st string, mx time.Duration) ([]SearchResponse, error) {\n\tconn, err := listenForSearchResponses()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\tsearchBytes, broadcastAddr := buildSearchRequest(st, mx)\n\t// Write search bytes on the wire so all devices can respond\n\t_, err = conn.WriteTo(searchBytes, broadcastAddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn readSearchResponses(conn, mx)\n}", "code_tokens": ["func", "Search", "(", "st", "string", ",", "mx", "time", ".", "Duration", ")", "(", "[", "]", "SearchResponse", ",", "error", ")", "{", "conn", ",", "err", ":=", "listenForSearchResponses", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "defer", "conn", ".", "Close", "(", ")", "\n\n", "searchBytes", ",", "broadcastAddr", ":=", "buildSearchRequest", "(", "st", ",", "mx", ")", "\n", "// Write search bytes on the wire so all devices can respond", "_", ",", "err", "=", "conn", ".", "WriteTo", "(", "searchBytes", ",", "broadcastAddr", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "readSearchResponses", "(", "conn", ",", "mx", ")", "\n", "}"], "docstring": "// Search the network for SSDP devices using the given search string and duration\n// to discover new devices. This function will return an array of SearchReponses\n// discovered.", "docstring_tokens": ["Search", "the", "network", "for", "SSDP", "devices", "using", "the", "given", "search", "string", "and", "duration", "to", "discover", "new", "devices", ".", "This", "function", "will", "return", "an", "array", "of", "SearchReponses", "discovered", "."], "sha": "ae8e7a0ef8a8f119ef439791570ee2a094d1d094", "url": "https://github.com/bcurren/go-ssdp/blob/ae8e7a0ef8a8f119ef439791570ee2a094d1d094/ssdp.go#L47-L62", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/concurrency/stm.go", "func_name": "first", "original_string": "func (rs readSet) first() int64 {\n\tret := int64(math.MaxInt64 - 1)\n\tfor _, resp := range rs {\n\t\tif rev := resp.Header.Revision; rev < ret {\n\t\t\tret = rev\n\t\t}\n\t}\n\treturn ret\n}", "language": "go", "code": "func (rs readSet) first() int64 {\n\tret := int64(math.MaxInt64 - 1)\n\tfor _, resp := range rs {\n\t\tif rev := resp.Header.Revision; rev < ret {\n\t\t\tret = rev\n\t\t}\n\t}\n\treturn ret\n}", "code_tokens": ["func", "(", "rs", "readSet", ")", "first", "(", ")", "int64", "{", "ret", ":=", "int64", "(", "math", ".", "MaxInt64", "-", "1", ")", "\n", "for", "_", ",", "resp", ":=", "range", "rs", "{", "if", "rev", ":=", "resp", ".", "Header", ".", "Revision", ";", "rev", "<", "ret", "{", "ret", "=", "rev", "\n", "}", "\n", "}", "\n", "return", "ret", "\n", "}"], "docstring": "// first returns the store revision from the first fetch", "docstring_tokens": ["first", "returns", "the", "store", "revision", "from", "the", "first", "fetch"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/concurrency/stm.go#L197-L205", "partition": "test"}
{"repo": "hashicorp/raft", "path": "file_snapshot.go", "func_name": "Write", "original_string": "func (s *FileSnapshotSink) Write(b []byte) (int, error) {\n\treturn s.buffered.Write(b)\n}", "language": "go", "code": "func (s *FileSnapshotSink) Write(b []byte) (int, error) {\n\treturn s.buffered.Write(b)\n}", "code_tokens": ["func", "(", "s", "*", "FileSnapshotSink", ")", "Write", "(", "b", "[", "]", "byte", ")", "(", "int", ",", "error", ")", "{", "return", "s", ".", "buffered", ".", "Write", "(", "b", ")", "\n", "}"], "docstring": "// Write is used to append to the state file. We write to the\n// buffered IO object to reduce the amount of context switches.", "docstring_tokens": ["Write", "is", "used", "to", "append", "to", "the", "state", "file", ".", "We", "write", "to", "the", "buffered", "IO", "object", "to", "reduce", "the", "amount", "of", "context", "switches", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/file_snapshot.go#L375-L377", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "typed/buffer.go", "func_name": "WriteUint32", "original_string": "func (w *WriteBuffer) WriteUint32(n uint32) {\n\tif b := w.reserve(4); b != nil {\n\t\tbinary.BigEndian.PutUint32(b, n)\n\t}\n}", "language": "go", "code": "func (w *WriteBuffer) WriteUint32(n uint32) {\n\tif b := w.reserve(4); b != nil {\n\t\tbinary.BigEndian.PutUint32(b, n)\n\t}\n}", "code_tokens": ["func", "(", "w", "*", "WriteBuffer", ")", "WriteUint32", "(", "n", "uint32", ")", "{", "if", "b", ":=", "w", ".", "reserve", "(", "4", ")", ";", "b", "!=", "nil", "{", "binary", ".", "BigEndian", ".", "PutUint32", "(", "b", ",", "n", ")", "\n", "}", "\n", "}"], "docstring": "// WriteUint32 writes a big endian uint32 value to the buffer", "docstring_tokens": ["WriteUint32", "writes", "a", "big", "endian", "uint32", "value", "to", "the", "buffer"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/typed/buffer.go#L227-L231", "partition": "test"}
{"repo": "pact-foundation/pact-go", "path": "dsl/matcher.go", "func_name": "EachLike", "original_string": "func EachLike(content interface{}, minRequired int) Matcher {\n\treturn eachLike{\n\t\tContents: content,\n\t\tMin:      minRequired,\n\t}\n}", "language": "go", "code": "func EachLike(content interface{}, minRequired int) Matcher {\n\treturn eachLike{\n\t\tContents: content,\n\t\tMin:      minRequired,\n\t}\n}", "code_tokens": ["func", "EachLike", "(", "content", "interface", "{", "}", ",", "minRequired", "int", ")", "Matcher", "{", "return", "eachLike", "{", "Contents", ":", "content", ",", "Min", ":", "minRequired", ",", "}", "\n", "}"], "docstring": "// EachLike specifies that a given element in a JSON body can be repeated\n// \"minRequired\" times. Number needs to be 1 or greater", "docstring_tokens": ["EachLike", "specifies", "that", "a", "given", "element", "in", "a", "JSON", "body", "can", "be", "repeated", "minRequired", "times", ".", "Number", "needs", "to", "be", "1", "or", "greater"], "sha": "467dea56d27e154363e1975f6e9f4dbf66148e79", "url": "https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/dsl/matcher.go#L100-L105", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/hashtree/error.go", "func_name": "errorf", "original_string": "func errorf(c ErrCode, fmtStr string, args ...interface{}) error {\n\treturn &hashTreeError{\n\t\tcode: c,\n\t\ts:    fmt.Sprintf(fmtStr, args...),\n\t}\n}", "language": "go", "code": "func errorf(c ErrCode, fmtStr string, args ...interface{}) error {\n\treturn &hashTreeError{\n\t\tcode: c,\n\t\ts:    fmt.Sprintf(fmtStr, args...),\n\t}\n}", "code_tokens": ["func", "errorf", "(", "c", "ErrCode", ",", "fmtStr", "string", ",", "args", "...", "interface", "{", "}", ")", "error", "{", "return", "&", "hashTreeError", "{", "code", ":", "c", ",", "s", ":", "fmt", ".", "Sprintf", "(", "fmtStr", ",", "args", "...", ")", ",", "}", "\n", "}"], "docstring": "// errorf is analogous to fmt.Errorf, but generates hashTreeErrors instead of\n// errorStrings.", "docstring_tokens": ["errorf", "is", "analogous", "to", "fmt", ".", "Errorf", "but", "generates", "hashTreeErrors", "instead", "of", "errorStrings", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/error.go#L32-L37", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "ArmForSwitch", "original_string": "func (u CreateAccountResult) ArmForSwitch(sw int32) (string, bool) {\n\tswitch CreateAccountResultCode(sw) {\n\tcase CreateAccountResultCodeCreateAccountSuccess:\n\t\treturn \"\", true\n\tdefault:\n\t\treturn \"\", true\n\t}\n}", "language": "go", "code": "func (u CreateAccountResult) ArmForSwitch(sw int32) (string, bool) {\n\tswitch CreateAccountResultCode(sw) {\n\tcase CreateAccountResultCodeCreateAccountSuccess:\n\t\treturn \"\", true\n\tdefault:\n\t\treturn \"\", true\n\t}\n}", "code_tokens": ["func", "(", "u", "CreateAccountResult", ")", "ArmForSwitch", "(", "sw", "int32", ")", "(", "string", ",", "bool", ")", "{", "switch", "CreateAccountResultCode", "(", "sw", ")", "{", "case", "CreateAccountResultCodeCreateAccountSuccess", ":", "return", "\"", "\"", ",", "true", "\n", "default", ":", "return", "\"", "\"", ",", "true", "\n", "}", "\n", "}"], "docstring": "// ArmForSwitch returns which field name should be used for storing\n// the value for an instance of CreateAccountResult", "docstring_tokens": ["ArmForSwitch", "returns", "which", "field", "name", "should", "be", "used", "for", "storing", "the", "value", "for", "an", "instance", "of", "CreateAccountResult"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L2544-L2551", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/containers.mapper.go", "func_name": "ContainerExists", "original_string": "func (c *ClusterTx) ContainerExists(project string, name string) (bool, error) {\n\t_, err := c.ContainerID(project, name)\n\tif err != nil {\n\t\tif err == ErrNoSuchObject {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\treturn true, nil\n}", "language": "go", "code": "func (c *ClusterTx) ContainerExists(project string, name string) (bool, error) {\n\t_, err := c.ContainerID(project, name)\n\tif err != nil {\n\t\tif err == ErrNoSuchObject {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\n\treturn true, nil\n}", "code_tokens": ["func", "(", "c", "*", "ClusterTx", ")", "ContainerExists", "(", "project", "string", ",", "name", "string", ")", "(", "bool", ",", "error", ")", "{", "_", ",", "err", ":=", "c", ".", "ContainerID", "(", "project", ",", "name", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", "==", "ErrNoSuchObject", "{", "return", "false", ",", "nil", "\n", "}", "\n", "return", "false", ",", "err", "\n", "}", "\n\n", "return", "true", ",", "nil", "\n", "}"], "docstring": "// ContainerExists checks if a container with the given key exists.", "docstring_tokens": ["ContainerExists", "checks", "if", "a", "container", "with", "the", "given", "key", "exists", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/containers.mapper.go#L373-L383", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/ppsutil/util.go", "func_name": "GetLimitsResourceListFromPipeline", "original_string": "func GetLimitsResourceListFromPipeline(pipelineInfo *pps.PipelineInfo) (*v1.ResourceList, error) {\n\treturn getResourceListFromSpec(pipelineInfo.ResourceLimits, pipelineInfo.CacheSize)\n}", "language": "go", "code": "func GetLimitsResourceListFromPipeline(pipelineInfo *pps.PipelineInfo) (*v1.ResourceList, error) {\n\treturn getResourceListFromSpec(pipelineInfo.ResourceLimits, pipelineInfo.CacheSize)\n}", "code_tokens": ["func", "GetLimitsResourceListFromPipeline", "(", "pipelineInfo", "*", "pps", ".", "PipelineInfo", ")", "(", "*", "v1", ".", "ResourceList", ",", "error", ")", "{", "return", "getResourceListFromSpec", "(", "pipelineInfo", ".", "ResourceLimits", ",", "pipelineInfo", ".", "CacheSize", ")", "\n", "}"], "docstring": "// GetLimitsResourceListFromPipeline returns a list of resources that the pipeline,\n// maximally is limited to.", "docstring_tokens": ["GetLimitsResourceListFromPipeline", "returns", "a", "list", "of", "resources", "that", "the", "pipeline", "maximally", "is", "limited", "to", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/ppsutil/util.go#L121-L123", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/pipeline/controller.go", "func_name": "sourceURL", "original_string": "func sourceURL(pj prowjobv1.ProwJob) string {\n\tif pj.Spec.Refs == nil {\n\t\treturn \"\"\n\t}\n\tsourceURL := pj.Spec.Refs.CloneURI\n\tif sourceURL == \"\" {\n\t\tsourceURL = fmt.Sprintf(\"%s.git\", pj.Spec.Refs.RepoLink)\n\t}\n\treturn sourceURL\n}", "language": "go", "code": "func sourceURL(pj prowjobv1.ProwJob) string {\n\tif pj.Spec.Refs == nil {\n\t\treturn \"\"\n\t}\n\tsourceURL := pj.Spec.Refs.CloneURI\n\tif sourceURL == \"\" {\n\t\tsourceURL = fmt.Sprintf(\"%s.git\", pj.Spec.Refs.RepoLink)\n\t}\n\treturn sourceURL\n}", "code_tokens": ["func", "sourceURL", "(", "pj", "prowjobv1", ".", "ProwJob", ")", "string", "{", "if", "pj", ".", "Spec", ".", "Refs", "==", "nil", "{", "return", "\"", "\"", "\n", "}", "\n", "sourceURL", ":=", "pj", ".", "Spec", ".", "Refs", ".", "CloneURI", "\n", "if", "sourceURL", "==", "\"", "\"", "{", "sourceURL", "=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "pj", ".", "Spec", ".", "Refs", ".", "RepoLink", ")", "\n", "}", "\n", "return", "sourceURL", "\n", "}"], "docstring": "// sourceURL returns the source URL from prow jobs repository reference", "docstring_tokens": ["sourceURL", "returns", "the", "source", "URL", "from", "prow", "jobs", "repository", "reference"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/pipeline/controller.go#L549-L558", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "handler.go", "func_name": "ServeHTTP", "original_string": "func (hs *HandlersStack) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Get a context for the request from ctxPool.\n\tc := getContext(w, r)\n\n\t// Set some \"good practice\" default headers.\n\tc.ResponseWriter.Header().Set(\"Cache-Control\", \"no-cache\")\n\tc.ResponseWriter.Header().Set(\"Content-Type\", \"application/json\")\n\tc.ResponseWriter.Header().Set(\"Connection\", \"keep-alive\")\n\tc.ResponseWriter.Header().Set(\"Vary\", \"Accept-Encoding\")\n\t//c.ResponseWriter.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.ResponseWriter.Header().Set(\"Access-Control-Allow-Headers\", \"X-Requested-With\")\n\tc.ResponseWriter.Header().Set(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\")\n\n\t// Always recover form panics.\n\tdefer c.Recover()\n\n\t// Enter the handlers stack.\n\tc.Next()\n\n\t// Respnose data\n\t// if c.written == false {\n\t// \tc.Fail(errors.New(\"not written\"))\n\t// }\n\t// Put the context to ctxPool\n\tputContext(c)\n}", "language": "go", "code": "func (hs *HandlersStack) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Get a context for the request from ctxPool.\n\tc := getContext(w, r)\n\n\t// Set some \"good practice\" default headers.\n\tc.ResponseWriter.Header().Set(\"Cache-Control\", \"no-cache\")\n\tc.ResponseWriter.Header().Set(\"Content-Type\", \"application/json\")\n\tc.ResponseWriter.Header().Set(\"Connection\", \"keep-alive\")\n\tc.ResponseWriter.Header().Set(\"Vary\", \"Accept-Encoding\")\n\t//c.ResponseWriter.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tc.ResponseWriter.Header().Set(\"Access-Control-Allow-Headers\", \"X-Requested-With\")\n\tc.ResponseWriter.Header().Set(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\")\n\n\t// Always recover form panics.\n\tdefer c.Recover()\n\n\t// Enter the handlers stack.\n\tc.Next()\n\n\t// Respnose data\n\t// if c.written == false {\n\t// \tc.Fail(errors.New(\"not written\"))\n\t// }\n\t// Put the context to ctxPool\n\tputContext(c)\n}", "code_tokens": ["func", "(", "hs", "*", "HandlersStack", ")", "ServeHTTP", "(", "w", "http", ".", "ResponseWriter", ",", "r", "*", "http", ".", "Request", ")", "{", "// Get a context for the request from ctxPool.", "c", ":=", "getContext", "(", "w", ",", "r", ")", "\n\n", "// Set some \"good practice\" default headers.", "c", ".", "ResponseWriter", ".", "Header", "(", ")", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "c", ".", "ResponseWriter", ".", "Header", "(", ")", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "c", ".", "ResponseWriter", ".", "Header", "(", ")", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "c", ".", "ResponseWriter", ".", "Header", "(", ")", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "//c.ResponseWriter.Header().Set(\"Access-Control-Allow-Origin\", \"*\")", "c", ".", "ResponseWriter", ".", "Header", "(", ")", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "c", ".", "ResponseWriter", ".", "Header", "(", ")", ".", "Set", "(", "\"", "\"", ",", "\"", "\"", ")", "\n\n", "// Always recover form panics.", "defer", "c", ".", "Recover", "(", ")", "\n\n", "// Enter the handlers stack.", "c", ".", "Next", "(", ")", "\n\n", "// Respnose data", "// if c.written == false {", "// \tc.Fail(errors.New(\"not written\"))", "// }", "// Put the context to ctxPool", "putContext", "(", "c", ")", "\n", "}"], "docstring": "// ServeHTTP makes a context for the request, sets some good practice default headers and enters the handlers stack.", "docstring_tokens": ["ServeHTTP", "makes", "a", "context", "for", "the", "request", "sets", "some", "good", "practice", "default", "headers", "and", "enters", "the", "handlers", "stack", "."], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/handler.go#L46-L71", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_containers.go", "func_name": "CreateContainerSnapshot", "original_string": "func (r *ProtocolLXD) CreateContainerSnapshot(containerName string, snapshot api.ContainerSnapshotsPost) (Operation, error) {\n\t// Validate the request\n\tif snapshot.ExpiresAt != nil && !r.HasExtension(\"snapshot_expiry_creation\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"snapshot_expiry_creation\\\" API extension\")\n\t}\n\n\t// Send the request\n\top, _, err := r.queryOperation(\"POST\", fmt.Sprintf(\"/containers/%s/snapshots\", url.QueryEscape(containerName)), snapshot, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "language": "go", "code": "func (r *ProtocolLXD) CreateContainerSnapshot(containerName string, snapshot api.ContainerSnapshotsPost) (Operation, error) {\n\t// Validate the request\n\tif snapshot.ExpiresAt != nil && !r.HasExtension(\"snapshot_expiry_creation\") {\n\t\treturn nil, fmt.Errorf(\"The server is missing the required \\\"snapshot_expiry_creation\\\" API extension\")\n\t}\n\n\t// Send the request\n\top, _, err := r.queryOperation(\"POST\", fmt.Sprintf(\"/containers/%s/snapshots\", url.QueryEscape(containerName)), snapshot, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "CreateContainerSnapshot", "(", "containerName", "string", ",", "snapshot", "api", ".", "ContainerSnapshotsPost", ")", "(", "Operation", ",", "error", ")", "{", "// Validate the request", "if", "snapshot", ".", "ExpiresAt", "!=", "nil", "&&", "!", "r", ".", "HasExtension", "(", "\"", "\"", ")", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\"", ")", "\n", "}", "\n\n", "// Send the request", "op", ",", "_", ",", "err", ":=", "r", ".", "queryOperation", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "containerName", ")", ")", ",", "snapshot", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "op", ",", "nil", "\n", "}"], "docstring": "// CreateContainerSnapshot requests that LXD creates a new snapshot for the container", "docstring_tokens": ["CreateContainerSnapshot", "requests", "that", "LXD", "creates", "a", "new", "snapshot", "for", "the", "container"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_containers.go#L1042-L1055", "partition": "test"}
{"repo": "urandom/handler", "path": "security/nonce.go", "func_name": "Nonce", "original_string": "func Nonce(h http.Handler, opts ...Option) http.Handler {\n\theaderStorage := nonceHeaderStorage{}\n\to := options{\n\t\tlogger:    handler.OutLogger(),\n\t\tgenerator: timeRandomGenerator,\n\t\tgetter:    headerStorage,\n\t\tsetter:    headerStorage,\n\t\tage:       45 * time.Second,\n\t}\n\to.apply(opts)\n\n\tstore := nonceStore{}\n\topChan := make(chan func(nonceStore))\n\n\tgo func() {\n\t\tfor op := range opChan {\n\t\t\top(store)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(5 * time.Minute):\n\t\t\t\tcleanup(o.age, opChan)\n\t\t\t}\n\t\t}\n\t}()\n\n\tsetter := func(w http.ResponseWriter, r *http.Request) error {\n\t\tnonce, err := generateAndStore(o.age, o.generator, opChan)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn o.setter.SetNonce(nonce, w, r)\n\t}\n\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tctx := r.Context()\n\n\t\tnonce := o.getter.GetNonce(r)\n\t\tif nonce != \"\" {\n\t\t\tif validateAndRemoveNonce(nonce, o.age, opChan) {\n\t\t\t\tctx = context.WithValue(ctx, nonceValueKey, NonceStatus{NonceValid})\n\t\t\t} else {\n\t\t\t\tctx = context.WithValue(ctx, nonceValueKey, NonceStatus{NonceInvalid})\n\t\t\t}\n\t\t}\n\n\t\th.ServeHTTP(w, r.WithContext(context.WithValue(ctx, nonceSetterKey, setter)))\n\t})\n}", "language": "go", "code": "func Nonce(h http.Handler, opts ...Option) http.Handler {\n\theaderStorage := nonceHeaderStorage{}\n\to := options{\n\t\tlogger:    handler.OutLogger(),\n\t\tgenerator: timeRandomGenerator,\n\t\tgetter:    headerStorage,\n\t\tsetter:    headerStorage,\n\t\tage:       45 * time.Second,\n\t}\n\to.apply(opts)\n\n\tstore := nonceStore{}\n\topChan := make(chan func(nonceStore))\n\n\tgo func() {\n\t\tfor op := range opChan {\n\t\t\top(store)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(5 * time.Minute):\n\t\t\t\tcleanup(o.age, opChan)\n\t\t\t}\n\t\t}\n\t}()\n\n\tsetter := func(w http.ResponseWriter, r *http.Request) error {\n\t\tnonce, err := generateAndStore(o.age, o.generator, opChan)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn o.setter.SetNonce(nonce, w, r)\n\t}\n\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tctx := r.Context()\n\n\t\tnonce := o.getter.GetNonce(r)\n\t\tif nonce != \"\" {\n\t\t\tif validateAndRemoveNonce(nonce, o.age, opChan) {\n\t\t\t\tctx = context.WithValue(ctx, nonceValueKey, NonceStatus{NonceValid})\n\t\t\t} else {\n\t\t\t\tctx = context.WithValue(ctx, nonceValueKey, NonceStatus{NonceInvalid})\n\t\t\t}\n\t\t}\n\n\t\th.ServeHTTP(w, r.WithContext(context.WithValue(ctx, nonceSetterKey, setter)))\n\t})\n}", "code_tokens": ["func", "Nonce", "(", "h", "http", ".", "Handler", ",", "opts", "...", "Option", ")", "http", ".", "Handler", "{", "headerStorage", ":=", "nonceHeaderStorage", "{", "}", "\n", "o", ":=", "options", "{", "logger", ":", "handler", ".", "OutLogger", "(", ")", ",", "generator", ":", "timeRandomGenerator", ",", "getter", ":", "headerStorage", ",", "setter", ":", "headerStorage", ",", "age", ":", "45", "*", "time", ".", "Second", ",", "}", "\n", "o", ".", "apply", "(", "opts", ")", "\n\n", "store", ":=", "nonceStore", "{", "}", "\n", "opChan", ":=", "make", "(", "chan", "func", "(", "nonceStore", ")", ")", "\n\n", "go", "func", "(", ")", "{", "for", "op", ":=", "range", "opChan", "{", "op", "(", "store", ")", "\n", "}", "\n", "}", "(", ")", "\n\n", "go", "func", "(", ")", "{", "for", "{", "select", "{", "case", "<-", "time", ".", "After", "(", "5", "*", "time", ".", "Minute", ")", ":", "cleanup", "(", "o", ".", "age", ",", "opChan", ")", "\n", "}", "\n", "}", "\n", "}", "(", ")", "\n\n", "setter", ":=", "func", "(", "w", "http", ".", "ResponseWriter", ",", "r", "*", "http", ".", "Request", ")", "error", "{", "nonce", ",", "err", ":=", "generateAndStore", "(", "o", ".", "age", ",", "o", ".", "generator", ",", "opChan", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "o", ".", "setter", ".", "SetNonce", "(", "nonce", ",", "w", ",", "r", ")", "\n", "}", "\n\n", "return", "http", ".", "HandlerFunc", "(", "func", "(", "w", "http", ".", "ResponseWriter", ",", "r", "*", "http", ".", "Request", ")", "{", "ctx", ":=", "r", ".", "Context", "(", ")", "\n\n", "nonce", ":=", "o", ".", "getter", ".", "GetNonce", "(", "r", ")", "\n", "if", "nonce", "!=", "\"", "\"", "{", "if", "validateAndRemoveNonce", "(", "nonce", ",", "o", ".", "age", ",", "opChan", ")", "{", "ctx", "=", "context", ".", "WithValue", "(", "ctx", ",", "nonceValueKey", ",", "NonceStatus", "{", "NonceValid", "}", ")", "\n", "}", "else", "{", "ctx", "=", "context", ".", "WithValue", "(", "ctx", ",", "nonceValueKey", ",", "NonceStatus", "{", "NonceInvalid", "}", ")", "\n", "}", "\n", "}", "\n\n", "h", ".", "ServeHTTP", "(", "w", ",", "r", ".", "WithContext", "(", "context", ".", "WithValue", "(", "ctx", ",", "nonceSetterKey", ",", "setter", ")", ")", ")", "\n", "}", ")", "\n", "}"], "docstring": "// Nonce returns a handler that will check each request for the\n// existence of a nonce. If a nonce exists, it will be checked for\n// expiration. A status will be recorded in the request's context,\n// indicating whether there was a nonce in the request, and if so,\n// whether it is valid or expired.\n//\n// The recorded status can later be obtained using the\n// NonceValueFromRequest function.\n//\n// A nonce can be set for later checking using the StoreNonce\n// function.", "docstring_tokens": ["Nonce", "returns", "a", "handler", "that", "will", "check", "each", "request", "for", "the", "existence", "of", "a", "nonce", ".", "If", "a", "nonce", "exists", "it", "will", "be", "checked", "for", "expiration", ".", "A", "status", "will", "be", "recorded", "in", "the", "request", "s", "context", "indicating", "whether", "there", "was", "a", "nonce", "in", "the", "request", "and", "if", "so", "whether", "it", "is", "valid", "or", "expired", ".", "The", "recorded", "status", "can", "later", "be", "obtained", "using", "the", "NonceValueFromRequest", "function", ".", "A", "nonce", "can", "be", "set", "for", "later", "checking", "using", "the", "StoreNonce", "function", "."], "sha": "61508044a5569d1609521d81e81f6737567fd104", "url": "https://github.com/urandom/handler/blob/61508044a5569d1609521d81e81f6737567fd104/security/nonce.go#L113-L165", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "http/response.go", "func_name": "ResponseWriter", "original_string": "func ResponseWriter(response tchannel.ArgWritable) (http.ResponseWriter, func() error) {\n\tresponseWriter := newTChanResponseWriter(response)\n\treturn responseWriter, responseWriter.finish\n}", "language": "go", "code": "func ResponseWriter(response tchannel.ArgWritable) (http.ResponseWriter, func() error) {\n\tresponseWriter := newTChanResponseWriter(response)\n\treturn responseWriter, responseWriter.finish\n}", "code_tokens": ["func", "ResponseWriter", "(", "response", "tchannel", ".", "ArgWritable", ")", "(", "http", ".", "ResponseWriter", ",", "func", "(", ")", "error", ")", "{", "responseWriter", ":=", "newTChanResponseWriter", "(", "response", ")", "\n", "return", "responseWriter", ",", "responseWriter", ".", "finish", "\n", "}"], "docstring": "// ResponseWriter returns a http.ResponseWriter that will write to an underlying writer.\n// It also returns a function that should be called once the handler has completed.", "docstring_tokens": ["ResponseWriter", "returns", "a", "http", ".", "ResponseWriter", "that", "will", "write", "to", "an", "underlying", "writer", ".", "It", "also", "returns", "a", "function", "that", "should", "be", "called", "once", "the", "handler", "has", "completed", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/http/response.go#L136-L139", "partition": "test"}
{"repo": "brankas/sentinel", "path": "sentinel.go", "func_name": "IgnoreNetOpError", "original_string": "func IgnoreNetOpError(err error) bool {\n\tif opErr, ok := err.(*net.OpError); ok {\n\t\treturn opErr.Err.Error() == \"use of closed network connection\"\n\t}\n\treturn false\n}", "language": "go", "code": "func IgnoreNetOpError(err error) bool {\n\tif opErr, ok := err.(*net.OpError); ok {\n\t\treturn opErr.Err.Error() == \"use of closed network connection\"\n\t}\n\treturn false\n}", "code_tokens": ["func", "IgnoreNetOpError", "(", "err", "error", ")", "bool", "{", "if", "opErr", ",", "ok", ":=", "err", ".", "(", "*", "net", ".", "OpError", ")", ";", "ok", "{", "return", "opErr", ".", "Err", ".", "Error", "(", ")", "==", "\"", "\"", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// IgnoreNetOpError returns true when the passed error is a net.OpError with\n// error \"use of closed network connection\".", "docstring_tokens": ["IgnoreNetOpError", "returns", "true", "when", "the", "passed", "error", "is", "a", "net", ".", "OpError", "with", "error", "use", "of", "closed", "network", "connection", "."], "sha": "0ff081867c31a45cb71f5976ea6144fd06a557b5", "url": "https://github.com/brankas/sentinel/blob/0ff081867c31a45cb71f5976ea6144fd06a557b5/sentinel.go#L226-L231", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "provision/kubernetes/pkg/client/clientset/versioned/fake/clientset_generated.go", "func_name": "TsuruV1", "original_string": "func (c *Clientset) TsuruV1() tsuruv1.TsuruV1Interface {\n\treturn &faketsuruv1.FakeTsuruV1{Fake: &c.Fake}\n}", "language": "go", "code": "func (c *Clientset) TsuruV1() tsuruv1.TsuruV1Interface {\n\treturn &faketsuruv1.FakeTsuruV1{Fake: &c.Fake}\n}", "code_tokens": ["func", "(", "c", "*", "Clientset", ")", "TsuruV1", "(", ")", "tsuruv1", ".", "TsuruV1Interface", "{", "return", "&", "faketsuruv1", ".", "FakeTsuruV1", "{", "Fake", ":", "&", "c", ".", "Fake", "}", "\n", "}"], "docstring": "// TsuruV1 retrieves the TsuruV1Client", "docstring_tokens": ["TsuruV1", "retrieves", "the", "TsuruV1Client"], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/kubernetes/pkg/client/clientset/versioned/fake/clientset_generated.go#L54-L56", "partition": "test"}
{"repo": "libp2p/go-libp2p-crypto", "path": "key.go", "func_name": "KeyEqual", "original_string": "func KeyEqual(k1, k2 Key) bool {\n\tif k1 == k2 {\n\t\treturn true\n\t}\n\n\tb1, err1 := k1.Bytes()\n\tb2, err2 := k2.Bytes()\n\treturn bytes.Equal(b1, b2) && err1 == err2\n}", "language": "go", "code": "func KeyEqual(k1, k2 Key) bool {\n\tif k1 == k2 {\n\t\treturn true\n\t}\n\n\tb1, err1 := k1.Bytes()\n\tb2, err2 := k2.Bytes()\n\treturn bytes.Equal(b1, b2) && err1 == err2\n}", "code_tokens": ["func", "KeyEqual", "(", "k1", ",", "k2", "Key", ")", "bool", "{", "if", "k1", "==", "k2", "{", "return", "true", "\n", "}", "\n\n", "b1", ",", "err1", ":=", "k1", ".", "Bytes", "(", ")", "\n", "b2", ",", "err2", ":=", "k2", ".", "Bytes", "(", ")", "\n", "return", "bytes", ".", "Equal", "(", "b1", ",", "b2", ")", "&&", "err1", "==", "err2", "\n", "}"], "docstring": "// KeyEqual checks whether two", "docstring_tokens": ["KeyEqual", "checks", "whether", "two"], "sha": "9d2fed53443f745e6dc4d02bdcc94d9742a0ca84", "url": "https://github.com/libp2p/go-libp2p-crypto/blob/9d2fed53443f745e6dc4d02bdcc94d9742a0ca84/key.go#L344-L352", "partition": "test"}
{"repo": "google/go-cmp", "path": "cmp/report_reflect.go", "func_name": "formatPointer", "original_string": "func formatPointer(v reflect.Value) string {\n\tp := v.Pointer()\n\tif flags.Deterministic {\n\t\tp = 0xdeadf00f // Only used for stable testing purposes\n\t}\n\treturn fmt.Sprintf(\"\u27ea0x%x\u27eb\", p)\n}", "language": "go", "code": "func formatPointer(v reflect.Value) string {\n\tp := v.Pointer()\n\tif flags.Deterministic {\n\t\tp = 0xdeadf00f // Only used for stable testing purposes\n\t}\n\treturn fmt.Sprintf(\"\u27ea0x%x\u27eb\", p)\n}", "code_tokens": ["func", "formatPointer", "(", "v", "reflect", ".", "Value", ")", "string", "{", "p", ":=", "v", ".", "Pointer", "(", ")", "\n", "if", "flags", ".", "Deterministic", "{", "p", "=", "0xdeadf00f", "// Only used for stable testing purposes", "\n", "}", "\n", "return", "fmt", ".", "Sprintf", "(", "\"", ")", "", "", "", "\n", "}"], "docstring": "// formatPointer prints the address of the pointer.", "docstring_tokens": ["formatPointer", "prints", "the", "address", "of", "the", "pointer", "."], "sha": "6f77996f0c42f7b84e5a2b252227263f93432e9b", "url": "https://github.com/google/go-cmp/blob/6f77996f0c42f7b84e5a2b252227263f93432e9b/cmp/report_reflect.go#L262-L268", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "contrib/raftexample/raft.go", "func_name": "openWAL", "original_string": "func (rc *raftNode) openWAL(snapshot *raftpb.Snapshot) *wal.WAL {\n\tif !wal.Exist(rc.waldir) {\n\t\tif err := os.Mkdir(rc.waldir, 0750); err != nil {\n\t\t\tlog.Fatalf(\"raftexample: cannot create dir for wal (%v)\", err)\n\t\t}\n\n\t\tw, err := wal.Create(zap.NewExample(), rc.waldir, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"raftexample: create wal error (%v)\", err)\n\t\t}\n\t\tw.Close()\n\t}\n\n\twalsnap := walpb.Snapshot{}\n\tif snapshot != nil {\n\t\twalsnap.Index, walsnap.Term = snapshot.Metadata.Index, snapshot.Metadata.Term\n\t}\n\tlog.Printf(\"loading WAL at term %d and index %d\", walsnap.Term, walsnap.Index)\n\tw, err := wal.Open(zap.NewExample(), rc.waldir, walsnap)\n\tif err != nil {\n\t\tlog.Fatalf(\"raftexample: error loading wal (%v)\", err)\n\t}\n\n\treturn w\n}", "language": "go", "code": "func (rc *raftNode) openWAL(snapshot *raftpb.Snapshot) *wal.WAL {\n\tif !wal.Exist(rc.waldir) {\n\t\tif err := os.Mkdir(rc.waldir, 0750); err != nil {\n\t\t\tlog.Fatalf(\"raftexample: cannot create dir for wal (%v)\", err)\n\t\t}\n\n\t\tw, err := wal.Create(zap.NewExample(), rc.waldir, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"raftexample: create wal error (%v)\", err)\n\t\t}\n\t\tw.Close()\n\t}\n\n\twalsnap := walpb.Snapshot{}\n\tif snapshot != nil {\n\t\twalsnap.Index, walsnap.Term = snapshot.Metadata.Index, snapshot.Metadata.Term\n\t}\n\tlog.Printf(\"loading WAL at term %d and index %d\", walsnap.Term, walsnap.Index)\n\tw, err := wal.Open(zap.NewExample(), rc.waldir, walsnap)\n\tif err != nil {\n\t\tlog.Fatalf(\"raftexample: error loading wal (%v)\", err)\n\t}\n\n\treturn w\n}", "code_tokens": ["func", "(", "rc", "*", "raftNode", ")", "openWAL", "(", "snapshot", "*", "raftpb", ".", "Snapshot", ")", "*", "wal", ".", "WAL", "{", "if", "!", "wal", ".", "Exist", "(", "rc", ".", "waldir", ")", "{", "if", "err", ":=", "os", ".", "Mkdir", "(", "rc", ".", "waldir", ",", "0750", ")", ";", "err", "!=", "nil", "{", "log", ".", "Fatalf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "w", ",", "err", ":=", "wal", ".", "Create", "(", "zap", ".", "NewExample", "(", ")", ",", "rc", ".", "waldir", ",", "nil", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatalf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "w", ".", "Close", "(", ")", "\n", "}", "\n\n", "walsnap", ":=", "walpb", ".", "Snapshot", "{", "}", "\n", "if", "snapshot", "!=", "nil", "{", "walsnap", ".", "Index", ",", "walsnap", ".", "Term", "=", "snapshot", ".", "Metadata", ".", "Index", ",", "snapshot", ".", "Metadata", ".", "Term", "\n", "}", "\n", "log", ".", "Printf", "(", "\"", "\"", ",", "walsnap", ".", "Term", ",", "walsnap", ".", "Index", ")", "\n", "w", ",", "err", ":=", "wal", ".", "Open", "(", "zap", ".", "NewExample", "(", ")", ",", "rc", ".", "waldir", ",", "walsnap", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatalf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "return", "w", "\n", "}"], "docstring": "// openWAL returns a WAL ready for reading.", "docstring_tokens": ["openWAL", "returns", "a", "WAL", "ready", "for", "reading", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/contrib/raftexample/raft.go#L200-L224", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "language/go/fix.go", "func_name": "removeLegacyGazelle", "original_string": "func removeLegacyGazelle(c *config.Config, f *rule.File) {\n\tfor _, l := range f.Loads {\n\t\tif l.Name() == \"@io_bazel_rules_go//go:def.bzl\" && l.Has(\"gazelle\") {\n\t\t\tl.Remove(\"gazelle\")\n\t\t\tif l.IsEmpty() {\n\t\t\t\tl.Delete()\n\t\t\t}\n\t\t}\n\t}\n}", "language": "go", "code": "func removeLegacyGazelle(c *config.Config, f *rule.File) {\n\tfor _, l := range f.Loads {\n\t\tif l.Name() == \"@io_bazel_rules_go//go:def.bzl\" && l.Has(\"gazelle\") {\n\t\t\tl.Remove(\"gazelle\")\n\t\t\tif l.IsEmpty() {\n\t\t\t\tl.Delete()\n\t\t\t}\n\t\t}\n\t}\n}", "code_tokens": ["func", "removeLegacyGazelle", "(", "c", "*", "config", ".", "Config", ",", "f", "*", "rule", ".", "File", ")", "{", "for", "_", ",", "l", ":=", "range", "f", ".", "Loads", "{", "if", "l", ".", "Name", "(", ")", "==", "\"", "\"", "&&", "l", ".", "Has", "(", "\"", "\"", ")", "{", "l", ".", "Remove", "(", "\"", "\"", ")", "\n", "if", "l", ".", "IsEmpty", "(", ")", "{", "l", ".", "Delete", "(", ")", "\n", "}", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// removeLegacyGazelle removes loads of the \"gazelle\" macro from\n// @io_bazel_rules_go//go:def.bzl. The definition has moved to\n// @bazel_gazelle//:def.bzl, and the old one will be deleted soon.", "docstring_tokens": ["removeLegacyGazelle", "removes", "loads", "of", "the", "gazelle", "macro", "from"], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/language/go/fix.go#L236-L245", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pfs/server/driver.go", "func_name": "validateRepoName", "original_string": "func validateRepoName(name string) error {\n\tmatch, _ := regexp.MatchString(\"^[a-zA-Z0-9_-]+$\", name)\n\tif !match {\n\t\treturn fmt.Errorf(\"repo name (%v) invalid: only alphanumeric characters, underscores, and dashes are allowed\", name)\n\t}\n\treturn nil\n}", "language": "go", "code": "func validateRepoName(name string) error {\n\tmatch, _ := regexp.MatchString(\"^[a-zA-Z0-9_-]+$\", name)\n\tif !match {\n\t\treturn fmt.Errorf(\"repo name (%v) invalid: only alphanumeric characters, underscores, and dashes are allowed\", name)\n\t}\n\treturn nil\n}", "code_tokens": ["func", "validateRepoName", "(", "name", "string", ")", "error", "{", "match", ",", "_", ":=", "regexp", ".", "MatchString", "(", "\"", "\"", ",", "name", ")", "\n", "if", "!", "match", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "name", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// validateRepoName determines if a repo name is valid", "docstring_tokens": ["validateRepoName", "determines", "if", "a", "repo", "name", "is", "valid"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pfs/server/driver.go#L71-L77", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "emulation/emulation.go", "func_name": "Do", "original_string": "func (p *SetScriptExecutionDisabledParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetScriptExecutionDisabled, p, nil)\n}", "language": "go", "code": "func (p *SetScriptExecutionDisabledParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetScriptExecutionDisabled, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetScriptExecutionDisabledParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetScriptExecutionDisabled", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Emulation.setScriptExecutionDisabled against the provided context.", "docstring_tokens": ["Do", "executes", "Emulation", ".", "setScriptExecutionDisabled", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/emulation/emulation.go#L450-L452", "partition": "test"}
{"repo": "containers/image", "path": "copy/copy.go", "func_name": "compressGoroutine", "original_string": "func compressGoroutine(dest *io.PipeWriter, src io.Reader) {\n\terr := errors.New(\"Internal error: unexpected panic in compressGoroutine\")\n\tdefer func() { // Note that this is not the same as {defer dest.CloseWithError(err)}; we need err to be evaluated lazily.\n\t\tdest.CloseWithError(err) // CloseWithError(nil) is equivalent to Close()\n\t}()\n\n\tzipper := pgzip.NewWriter(dest)\n\tdefer zipper.Close()\n\n\t_, err = io.Copy(zipper, src) // Sets err to nil, i.e. causes dest.Close()\n}", "language": "go", "code": "func compressGoroutine(dest *io.PipeWriter, src io.Reader) {\n\terr := errors.New(\"Internal error: unexpected panic in compressGoroutine\")\n\tdefer func() { // Note that this is not the same as {defer dest.CloseWithError(err)}; we need err to be evaluated lazily.\n\t\tdest.CloseWithError(err) // CloseWithError(nil) is equivalent to Close()\n\t}()\n\n\tzipper := pgzip.NewWriter(dest)\n\tdefer zipper.Close()\n\n\t_, err = io.Copy(zipper, src) // Sets err to nil, i.e. causes dest.Close()\n}", "code_tokens": ["func", "compressGoroutine", "(", "dest", "*", "io", ".", "PipeWriter", ",", "src", "io", ".", "Reader", ")", "{", "err", ":=", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "defer", "func", "(", ")", "{", "// Note that this is not the same as {defer dest.CloseWithError(err)}; we need err to be evaluated lazily.", "dest", ".", "CloseWithError", "(", "err", ")", "// CloseWithError(nil) is equivalent to Close()", "\n", "}", "(", ")", "\n\n", "zipper", ":=", "pgzip", ".", "NewWriter", "(", "dest", ")", "\n", "defer", "zipper", ".", "Close", "(", ")", "\n\n", "_", ",", "err", "=", "io", ".", "Copy", "(", "zipper", ",", "src", ")", "// Sets err to nil, i.e. causes dest.Close()", "\n", "}"], "docstring": "// compressGoroutine reads all input from src and writes its compressed equivalent to dest.", "docstring_tokens": ["compressGoroutine", "reads", "all", "input", "from", "src", "and", "writes", "its", "compressed", "equivalent", "to", "dest", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/copy/copy.go#L893-L903", "partition": "test"}
{"repo": "hashicorp/raft", "path": "file_snapshot.go", "func_name": "Open", "original_string": "func (f *FileSnapshotStore) Open(id string) (*SnapshotMeta, io.ReadCloser, error) {\n\t// Get the metadata\n\tmeta, err := f.readMeta(id)\n\tif err != nil {\n\t\tf.logger.Printf(\"[ERR] snapshot: Failed to get meta data to open snapshot: %v\", err)\n\t\treturn nil, nil, err\n\t}\n\n\t// Open the state file\n\tstatePath := filepath.Join(f.path, id, stateFilePath)\n\tfh, err := os.Open(statePath)\n\tif err != nil {\n\t\tf.logger.Printf(\"[ERR] snapshot: Failed to open state file: %v\", err)\n\t\treturn nil, nil, err\n\t}\n\n\t// Create a CRC64 hash\n\tstateHash := crc64.New(crc64.MakeTable(crc64.ECMA))\n\n\t// Compute the hash\n\t_, err = io.Copy(stateHash, fh)\n\tif err != nil {\n\t\tf.logger.Printf(\"[ERR] snapshot: Failed to read state file: %v\", err)\n\t\tfh.Close()\n\t\treturn nil, nil, err\n\t}\n\n\t// Verify the hash\n\tcomputed := stateHash.Sum(nil)\n\tif bytes.Compare(meta.CRC, computed) != 0 {\n\t\tf.logger.Printf(\"[ERR] snapshot: CRC checksum failed (stored: %v computed: %v)\",\n\t\t\tmeta.CRC, computed)\n\t\tfh.Close()\n\t\treturn nil, nil, fmt.Errorf(\"CRC mismatch\")\n\t}\n\n\t// Seek to the start\n\tif _, err := fh.Seek(0, 0); err != nil {\n\t\tf.logger.Printf(\"[ERR] snapshot: State file seek failed: %v\", err)\n\t\tfh.Close()\n\t\treturn nil, nil, err\n\t}\n\n\t// Return a buffered file\n\tbuffered := &bufferedFile{\n\t\tbh: bufio.NewReader(fh),\n\t\tfh: fh,\n\t}\n\n\treturn &meta.SnapshotMeta, buffered, nil\n}", "language": "go", "code": "func (f *FileSnapshotStore) Open(id string) (*SnapshotMeta, io.ReadCloser, error) {\n\t// Get the metadata\n\tmeta, err := f.readMeta(id)\n\tif err != nil {\n\t\tf.logger.Printf(\"[ERR] snapshot: Failed to get meta data to open snapshot: %v\", err)\n\t\treturn nil, nil, err\n\t}\n\n\t// Open the state file\n\tstatePath := filepath.Join(f.path, id, stateFilePath)\n\tfh, err := os.Open(statePath)\n\tif err != nil {\n\t\tf.logger.Printf(\"[ERR] snapshot: Failed to open state file: %v\", err)\n\t\treturn nil, nil, err\n\t}\n\n\t// Create a CRC64 hash\n\tstateHash := crc64.New(crc64.MakeTable(crc64.ECMA))\n\n\t// Compute the hash\n\t_, err = io.Copy(stateHash, fh)\n\tif err != nil {\n\t\tf.logger.Printf(\"[ERR] snapshot: Failed to read state file: %v\", err)\n\t\tfh.Close()\n\t\treturn nil, nil, err\n\t}\n\n\t// Verify the hash\n\tcomputed := stateHash.Sum(nil)\n\tif bytes.Compare(meta.CRC, computed) != 0 {\n\t\tf.logger.Printf(\"[ERR] snapshot: CRC checksum failed (stored: %v computed: %v)\",\n\t\t\tmeta.CRC, computed)\n\t\tfh.Close()\n\t\treturn nil, nil, fmt.Errorf(\"CRC mismatch\")\n\t}\n\n\t// Seek to the start\n\tif _, err := fh.Seek(0, 0); err != nil {\n\t\tf.logger.Printf(\"[ERR] snapshot: State file seek failed: %v\", err)\n\t\tfh.Close()\n\t\treturn nil, nil, err\n\t}\n\n\t// Return a buffered file\n\tbuffered := &bufferedFile{\n\t\tbh: bufio.NewReader(fh),\n\t\tfh: fh,\n\t}\n\n\treturn &meta.SnapshotMeta, buffered, nil\n}", "code_tokens": ["func", "(", "f", "*", "FileSnapshotStore", ")", "Open", "(", "id", "string", ")", "(", "*", "SnapshotMeta", ",", "io", ".", "ReadCloser", ",", "error", ")", "{", "// Get the metadata", "meta", ",", "err", ":=", "f", ".", "readMeta", "(", "id", ")", "\n", "if", "err", "!=", "nil", "{", "f", ".", "logger", ".", "Printf", "(", "\"", "\"", ",", "err", ")", "\n", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n\n", "// Open the state file", "statePath", ":=", "filepath", ".", "Join", "(", "f", ".", "path", ",", "id", ",", "stateFilePath", ")", "\n", "fh", ",", "err", ":=", "os", ".", "Open", "(", "statePath", ")", "\n", "if", "err", "!=", "nil", "{", "f", ".", "logger", ".", "Printf", "(", "\"", "\"", ",", "err", ")", "\n", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n\n", "// Create a CRC64 hash", "stateHash", ":=", "crc64", ".", "New", "(", "crc64", ".", "MakeTable", "(", "crc64", ".", "ECMA", ")", ")", "\n\n", "// Compute the hash", "_", ",", "err", "=", "io", ".", "Copy", "(", "stateHash", ",", "fh", ")", "\n", "if", "err", "!=", "nil", "{", "f", ".", "logger", ".", "Printf", "(", "\"", "\"", ",", "err", ")", "\n", "fh", ".", "Close", "(", ")", "\n", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n\n", "// Verify the hash", "computed", ":=", "stateHash", ".", "Sum", "(", "nil", ")", "\n", "if", "bytes", ".", "Compare", "(", "meta", ".", "CRC", ",", "computed", ")", "!=", "0", "{", "f", ".", "logger", ".", "Printf", "(", "\"", "\"", ",", "meta", ".", "CRC", ",", "computed", ")", "\n", "fh", ".", "Close", "(", ")", "\n", "return", "nil", ",", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n\n", "// Seek to the start", "if", "_", ",", "err", ":=", "fh", ".", "Seek", "(", "0", ",", "0", ")", ";", "err", "!=", "nil", "{", "f", ".", "logger", ".", "Printf", "(", "\"", "\"", ",", "err", ")", "\n", "fh", ".", "Close", "(", ")", "\n", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n\n", "// Return a buffered file", "buffered", ":=", "&", "bufferedFile", "{", "bh", ":", "bufio", ".", "NewReader", "(", "fh", ")", ",", "fh", ":", "fh", ",", "}", "\n\n", "return", "&", "meta", ".", "SnapshotMeta", ",", "buffered", ",", "nil", "\n", "}"], "docstring": "// Open takes a snapshot ID and returns a ReadCloser for that snapshot.", "docstring_tokens": ["Open", "takes", "a", "snapshot", "ID", "and", "returns", "a", "ReadCloser", "for", "that", "snapshot", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/file_snapshot.go#L296-L346", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/projects.mapper.go", "func_name": "ProjectUsedByRef", "original_string": "func (c *ClusterTx) ProjectUsedByRef(filter ProjectFilter) (map[string][]string, error) {\n\t// Result slice.\n\tobjects := make([]struct {\n\t\tName  string\n\t\tValue string\n\t}, 0)\n\n\t// Check which filter criteria are active.\n\tcriteria := map[string]interface{}{}\n\tif filter.Name != \"\" {\n\t\tcriteria[\"Name\"] = filter.Name\n\t}\n\n\t// Pick the prepared statement and arguments to use based on active criteria.\n\tvar stmt *sql.Stmt\n\tvar args []interface{}\n\n\tif criteria[\"Name\"] != nil {\n\t\tstmt = c.stmt(projectUsedByRefByName)\n\t\targs = []interface{}{\n\t\t\tfilter.Name,\n\t\t}\n\t} else {\n\t\tstmt = c.stmt(projectUsedByRef)\n\t\targs = []interface{}{}\n\t}\n\n\t// Dest function for scanning a row.\n\tdest := func(i int) []interface{} {\n\t\tobjects = append(objects, struct {\n\t\t\tName  string\n\t\t\tValue string\n\t\t}{})\n\t\treturn []interface{}{\n\t\t\t&objects[i].Name,\n\t\t\t&objects[i].Value,\n\t\t}\n\t}\n\n\t// Select.\n\terr := query.SelectObjects(stmt, dest, args...)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"Failed to fetch string ref for projects\")\n\t}\n\n\t// Build index by primary name.\n\tindex := map[string][]string{}\n\n\tfor _, object := range objects {\n\t\titem, ok := index[object.Name]\n\t\tif !ok {\n\t\t\titem = []string{}\n\t\t}\n\n\t\tindex[object.Name] = append(item, object.Value)\n\t}\n\n\treturn index, nil\n}", "language": "go", "code": "func (c *ClusterTx) ProjectUsedByRef(filter ProjectFilter) (map[string][]string, error) {\n\t// Result slice.\n\tobjects := make([]struct {\n\t\tName  string\n\t\tValue string\n\t}, 0)\n\n\t// Check which filter criteria are active.\n\tcriteria := map[string]interface{}{}\n\tif filter.Name != \"\" {\n\t\tcriteria[\"Name\"] = filter.Name\n\t}\n\n\t// Pick the prepared statement and arguments to use based on active criteria.\n\tvar stmt *sql.Stmt\n\tvar args []interface{}\n\n\tif criteria[\"Name\"] != nil {\n\t\tstmt = c.stmt(projectUsedByRefByName)\n\t\targs = []interface{}{\n\t\t\tfilter.Name,\n\t\t}\n\t} else {\n\t\tstmt = c.stmt(projectUsedByRef)\n\t\targs = []interface{}{}\n\t}\n\n\t// Dest function for scanning a row.\n\tdest := func(i int) []interface{} {\n\t\tobjects = append(objects, struct {\n\t\t\tName  string\n\t\t\tValue string\n\t\t}{})\n\t\treturn []interface{}{\n\t\t\t&objects[i].Name,\n\t\t\t&objects[i].Value,\n\t\t}\n\t}\n\n\t// Select.\n\terr := query.SelectObjects(stmt, dest, args...)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"Failed to fetch string ref for projects\")\n\t}\n\n\t// Build index by primary name.\n\tindex := map[string][]string{}\n\n\tfor _, object := range objects {\n\t\titem, ok := index[object.Name]\n\t\tif !ok {\n\t\t\titem = []string{}\n\t\t}\n\n\t\tindex[object.Name] = append(item, object.Value)\n\t}\n\n\treturn index, nil\n}", "code_tokens": ["func", "(", "c", "*", "ClusterTx", ")", "ProjectUsedByRef", "(", "filter", "ProjectFilter", ")", "(", "map", "[", "string", "]", "[", "]", "string", ",", "error", ")", "{", "// Result slice.", "objects", ":=", "make", "(", "[", "]", "struct", "{", "Name", "string", "\n", "Value", "string", "\n", "}", ",", "0", ")", "\n\n", "// Check which filter criteria are active.", "criteria", ":=", "map", "[", "string", "]", "interface", "{", "}", "{", "}", "\n", "if", "filter", ".", "Name", "!=", "\"", "\"", "{", "criteria", "[", "\"", "\"", "]", "=", "filter", ".", "Name", "\n", "}", "\n\n", "// Pick the prepared statement and arguments to use based on active criteria.", "var", "stmt", "*", "sql", ".", "Stmt", "\n", "var", "args", "[", "]", "interface", "{", "}", "\n\n", "if", "criteria", "[", "\"", "\"", "]", "!=", "nil", "{", "stmt", "=", "c", ".", "stmt", "(", "projectUsedByRefByName", ")", "\n", "args", "=", "[", "]", "interface", "{", "}", "{", "filter", ".", "Name", ",", "}", "\n", "}", "else", "{", "stmt", "=", "c", ".", "stmt", "(", "projectUsedByRef", ")", "\n", "args", "=", "[", "]", "interface", "{", "}", "{", "}", "\n", "}", "\n\n", "// Dest function for scanning a row.", "dest", ":=", "func", "(", "i", "int", ")", "[", "]", "interface", "{", "}", "{", "objects", "=", "append", "(", "objects", ",", "struct", "{", "Name", "string", "\n", "Value", "string", "\n", "}", "{", "}", ")", "\n", "return", "[", "]", "interface", "{", "}", "{", "&", "objects", "[", "i", "]", ".", "Name", ",", "&", "objects", "[", "i", "]", ".", "Value", ",", "}", "\n", "}", "\n\n", "// Select.", "err", ":=", "query", ".", "SelectObjects", "(", "stmt", ",", "dest", ",", "args", "...", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n\n", "// Build index by primary name.", "index", ":=", "map", "[", "string", "]", "[", "]", "string", "{", "}", "\n\n", "for", "_", ",", "object", ":=", "range", "objects", "{", "item", ",", "ok", ":=", "index", "[", "object", ".", "Name", "]", "\n", "if", "!", "ok", "{", "item", "=", "[", "]", "string", "{", "}", "\n", "}", "\n\n", "index", "[", "object", ".", "Name", "]", "=", "append", "(", "item", ",", "object", ".", "Value", ")", "\n", "}", "\n\n", "return", "index", ",", "nil", "\n", "}"], "docstring": "// ProjectUsedByRef returns entities used by projects.", "docstring_tokens": ["ProjectUsedByRef", "returns", "entities", "used", "by", "projects", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/projects.mapper.go#L326-L384", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/raft.go", "func_name": "advanceTicks", "original_string": "func (r *raftNode) advanceTicks(ticks int) {\n\tfor i := 0; i < ticks; i++ {\n\t\tr.tick()\n\t}\n}", "language": "go", "code": "func (r *raftNode) advanceTicks(ticks int) {\n\tfor i := 0; i < ticks; i++ {\n\t\tr.tick()\n\t}\n}", "code_tokens": ["func", "(", "r", "*", "raftNode", ")", "advanceTicks", "(", "ticks", "int", ")", "{", "for", "i", ":=", "0", ";", "i", "<", "ticks", ";", "i", "++", "{", "r", ".", "tick", "(", ")", "\n", "}", "\n", "}"], "docstring": "// advanceTicks advances ticks of Raft node.\n// This can be used for fast-forwarding election\n// ticks in multi data-center deployments, thus\n// speeding up election process.", "docstring_tokens": ["advanceTicks", "advances", "ticks", "of", "Raft", "node", ".", "This", "can", "be", "used", "for", "fast", "-", "forwarding", "election", "ticks", "in", "multi", "data", "-", "center", "deployments", "thus", "speeding", "up", "election", "process", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/raft.go#L415-L419", "partition": "test"}
{"repo": "profitbricks/profitbricks-sdk-go", "path": "usermanagment.go", "func_name": "DeleteUser", "original_string": "func (c *Client) DeleteUser(userid string) (*http.Header, error) {\n\turl := umUsersPath(userid) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &http.Header{}\n\terr := c.client.Delete(url, ret, http.StatusAccepted)\n\treturn ret, err\n}", "language": "go", "code": "func (c *Client) DeleteUser(userid string) (*http.Header, error) {\n\turl := umUsersPath(userid) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &http.Header{}\n\terr := c.client.Delete(url, ret, http.StatusAccepted)\n\treturn ret, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "DeleteUser", "(", "userid", "string", ")", "(", "*", "http", ".", "Header", ",", "error", ")", "{", "url", ":=", "umUsersPath", "(", "userid", ")", "+", "`?depth=`", "+", "c", ".", "client", ".", "depth", "+", "`&pretty=`", "+", "strconv", ".", "FormatBool", "(", "c", ".", "client", ".", "pretty", ")", "\n", "ret", ":=", "&", "http", ".", "Header", "{", "}", "\n", "err", ":=", "c", ".", "client", ".", "Delete", "(", "url", ",", "ret", ",", "http", ".", "StatusAccepted", ")", "\n", "return", "ret", ",", "err", "\n", "}"], "docstring": "//DeleteUser deletes the specified user", "docstring_tokens": ["DeleteUser", "deletes", "the", "specified", "user"], "sha": "1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4", "url": "https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/usermanagment.go#L304-L309", "partition": "test"}
{"repo": "golang/debug", "path": "internal/core/address.go", "func_name": "Max", "original_string": "func (a Address) Max(b Address) Address {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}", "language": "go", "code": "func (a Address) Max(b Address) Address {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}", "code_tokens": ["func", "(", "a", "Address", ")", "Max", "(", "b", "Address", ")", "Address", "{", "if", "a", ">", "b", "{", "return", "a", "\n", "}", "\n", "return", "b", "\n", "}"], "docstring": "// Max returns the larger of a and b.", "docstring_tokens": ["Max", "returns", "the", "larger", "of", "a", "and", "b", "."], "sha": "19561fee47cf8cd0400d1b094c5898002f97cf90", "url": "https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/core/address.go#L21-L26", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "ValidEnum", "original_string": "func (e LedgerEntryType) ValidEnum(v int32) bool {\n\t_, ok := ledgerEntryTypeMap[v]\n\treturn ok\n}", "language": "go", "code": "func (e LedgerEntryType) ValidEnum(v int32) bool {\n\t_, ok := ledgerEntryTypeMap[v]\n\treturn ok\n}", "code_tokens": ["func", "(", "e", "LedgerEntryType", ")", "ValidEnum", "(", "v", "int32", ")", "bool", "{", "_", ",", "ok", ":=", "ledgerEntryTypeMap", "[", "v", "]", "\n", "return", "ok", "\n", "}"], "docstring": "// ValidEnum validates a proposed value for this enum.  Implements\n// the Enum interface for LedgerEntryType", "docstring_tokens": ["ValidEnum", "validates", "a", "proposed", "value", "for", "this", "enum", ".", "Implements", "the", "Enum", "interface", "for", "LedgerEntryType"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L603-L606", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/build/controller.go", "func_name": "injectedSteps", "original_string": "func injectedSteps(encodedJobSpec string, dc prowjobv1.DecorationConfig, injectedSource bool, toolsMount coreapi.VolumeMount, entries []wrapper.Options) ([]coreapi.Container, *coreapi.Container, *coreapi.Volume, error) {\n\tgcsVol, gcsMount, gcsOptions := decorate.GCSOptions(dc)\n\n\tsidecar, err := decorate.Sidecar(dc.UtilityImages.Sidecar, gcsOptions, gcsMount, logMount, encodedJobSpec, decorate.RequirePassingEntries, entries...)\n\tif err != nil {\n\t\treturn nil, nil, nil, fmt.Errorf(\"inject sidecar: %v\", err)\n\t}\n\n\tvar cloneLogMount *coreapi.VolumeMount\n\tif injectedSource {\n\t\tcloneLogMount = &logMount\n\t}\n\tinitUpload, err := decorate.InitUpload(dc.UtilityImages.InitUpload, gcsOptions, gcsMount, cloneLogMount, encodedJobSpec)\n\tif err != nil {\n\t\treturn nil, nil, nil, fmt.Errorf(\"inject initupload: %v\", err)\n\t}\n\n\tplacer := decorate.PlaceEntrypoint(dc.UtilityImages.Entrypoint, toolsMount)\n\n\treturn []coreapi.Container{placer, *initUpload}, sidecar, &gcsVol, nil\n}", "language": "go", "code": "func injectedSteps(encodedJobSpec string, dc prowjobv1.DecorationConfig, injectedSource bool, toolsMount coreapi.VolumeMount, entries []wrapper.Options) ([]coreapi.Container, *coreapi.Container, *coreapi.Volume, error) {\n\tgcsVol, gcsMount, gcsOptions := decorate.GCSOptions(dc)\n\n\tsidecar, err := decorate.Sidecar(dc.UtilityImages.Sidecar, gcsOptions, gcsMount, logMount, encodedJobSpec, decorate.RequirePassingEntries, entries...)\n\tif err != nil {\n\t\treturn nil, nil, nil, fmt.Errorf(\"inject sidecar: %v\", err)\n\t}\n\n\tvar cloneLogMount *coreapi.VolumeMount\n\tif injectedSource {\n\t\tcloneLogMount = &logMount\n\t}\n\tinitUpload, err := decorate.InitUpload(dc.UtilityImages.InitUpload, gcsOptions, gcsMount, cloneLogMount, encodedJobSpec)\n\tif err != nil {\n\t\treturn nil, nil, nil, fmt.Errorf(\"inject initupload: %v\", err)\n\t}\n\n\tplacer := decorate.PlaceEntrypoint(dc.UtilityImages.Entrypoint, toolsMount)\n\n\treturn []coreapi.Container{placer, *initUpload}, sidecar, &gcsVol, nil\n}", "code_tokens": ["func", "injectedSteps", "(", "encodedJobSpec", "string", ",", "dc", "prowjobv1", ".", "DecorationConfig", ",", "injectedSource", "bool", ",", "toolsMount", "coreapi", ".", "VolumeMount", ",", "entries", "[", "]", "wrapper", ".", "Options", ")", "(", "[", "]", "coreapi", ".", "Container", ",", "*", "coreapi", ".", "Container", ",", "*", "coreapi", ".", "Volume", ",", "error", ")", "{", "gcsVol", ",", "gcsMount", ",", "gcsOptions", ":=", "decorate", ".", "GCSOptions", "(", "dc", ")", "\n\n", "sidecar", ",", "err", ":=", "decorate", ".", "Sidecar", "(", "dc", ".", "UtilityImages", ".", "Sidecar", ",", "gcsOptions", ",", "gcsMount", ",", "logMount", ",", "encodedJobSpec", ",", "decorate", ".", "RequirePassingEntries", ",", "entries", "...", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "var", "cloneLogMount", "*", "coreapi", ".", "VolumeMount", "\n", "if", "injectedSource", "{", "cloneLogMount", "=", "&", "logMount", "\n", "}", "\n", "initUpload", ",", "err", ":=", "decorate", ".", "InitUpload", "(", "dc", ".", "UtilityImages", ".", "InitUpload", ",", "gcsOptions", ",", "gcsMount", ",", "cloneLogMount", ",", "encodedJobSpec", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "placer", ":=", "decorate", ".", "PlaceEntrypoint", "(", "dc", ".", "UtilityImages", ".", "Entrypoint", ",", "toolsMount", ")", "\n\n", "return", "[", "]", "coreapi", ".", "Container", "{", "placer", ",", "*", "initUpload", "}", ",", "sidecar", ",", "&", "gcsVol", ",", "nil", "\n", "}"], "docstring": "// injectedSteps returns initial containers, a final container and an additional volume.", "docstring_tokens": ["injectedSteps", "returns", "initial", "containers", "a", "final", "container", "and", "an", "additional", "volume", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/build/controller.go#L699-L719", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "rule/rule.go", "func_name": "LoadMacroFile", "original_string": "func LoadMacroFile(path, pkg, defName string) (*File, error) {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn LoadMacroData(path, pkg, defName, data)\n}", "language": "go", "code": "func LoadMacroFile(path, pkg, defName string) (*File, error) {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn LoadMacroData(path, pkg, defName, data)\n}", "code_tokens": ["func", "LoadMacroFile", "(", "path", ",", "pkg", ",", "defName", "string", ")", "(", "*", "File", ",", "error", ")", "{", "data", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "LoadMacroData", "(", "path", ",", "pkg", ",", "defName", ",", "data", ")", "\n", "}"], "docstring": "// LoadMacroFile loads a bzl file from disk, parses it, then scans for the load\n// statements and the rules called from the given Starlark function. If there is\n// no matching function name, then a new function with that name will be created.\n// The function's syntax tree will be returned within File and can be modified by\n// Sync and Save calls.", "docstring_tokens": ["LoadMacroFile", "loads", "a", "bzl", "file", "from", "disk", "parses", "it", "then", "scans", "for", "the", "load", "statements", "and", "the", "rules", "called", "from", "the", "given", "Starlark", "function", ".", "If", "there", "is", "no", "matching", "function", "name", "then", "a", "new", "function", "with", "that", "name", "will", "be", "created", ".", "The", "function", "s", "syntax", "tree", "will", "be", "returned", "within", "File", "and", "can", "be", "modified", "by", "Sync", "and", "Save", "calls", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/rule/rule.go#L110-L116", "partition": "test"}
{"repo": "kljensen/snowball", "path": "snowballword/snowballword.go", "func_name": "FirstPrefix", "original_string": "func (w *SnowballWord) FirstPrefix(prefixes ...string) (foundPrefix string, foundPrefixRunes []rune) {\n\tfound := false\n\trsLen := len(w.RS)\n\n\tfor _, prefix := range prefixes {\n\t\tprefixRunes := []rune(prefix)\n\t\tif len(prefixRunes) > rsLen {\n\t\t\tcontinue\n\t\t}\n\n\t\tfound = true\n\t\tfor i, r := range prefixRunes {\n\t\t\tif i > rsLen-1 || (w.RS)[i] != r {\n\t\t\t\tfound = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif found {\n\t\t\tfoundPrefix = prefix\n\t\t\tfoundPrefixRunes = prefixRunes\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}", "language": "go", "code": "func (w *SnowballWord) FirstPrefix(prefixes ...string) (foundPrefix string, foundPrefixRunes []rune) {\n\tfound := false\n\trsLen := len(w.RS)\n\n\tfor _, prefix := range prefixes {\n\t\tprefixRunes := []rune(prefix)\n\t\tif len(prefixRunes) > rsLen {\n\t\t\tcontinue\n\t\t}\n\n\t\tfound = true\n\t\tfor i, r := range prefixRunes {\n\t\t\tif i > rsLen-1 || (w.RS)[i] != r {\n\t\t\t\tfound = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif found {\n\t\t\tfoundPrefix = prefix\n\t\t\tfoundPrefixRunes = prefixRunes\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "w", "*", "SnowballWord", ")", "FirstPrefix", "(", "prefixes", "...", "string", ")", "(", "foundPrefix", "string", ",", "foundPrefixRunes", "[", "]", "rune", ")", "{", "found", ":=", "false", "\n", "rsLen", ":=", "len", "(", "w", ".", "RS", ")", "\n\n", "for", "_", ",", "prefix", ":=", "range", "prefixes", "{", "prefixRunes", ":=", "[", "]", "rune", "(", "prefix", ")", "\n", "if", "len", "(", "prefixRunes", ")", ">", "rsLen", "{", "continue", "\n", "}", "\n\n", "found", "=", "true", "\n", "for", "i", ",", "r", ":=", "range", "prefixRunes", "{", "if", "i", ">", "rsLen", "-", "1", "||", "(", "w", ".", "RS", ")", "[", "i", "]", "!=", "r", "{", "found", "=", "false", "\n", "break", "\n", "}", "\n", "}", "\n", "if", "found", "{", "foundPrefix", "=", "prefix", "\n", "foundPrefixRunes", "=", "prefixRunes", "\n", "break", "\n", "}", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// Return the first prefix found or the empty string.", "docstring_tokens": ["Return", "the", "first", "prefix", "found", "or", "the", "empty", "string", "."], "sha": "115fa8f6419dcfb9ec4653997b1c6803a5eff962", "url": "https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/snowballword/snowballword.go#L182-L206", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "velodrome/transform/plugins/fake_open_wrapper.go", "func_name": "NewFakeOpenPluginWrapper", "original_string": "func NewFakeOpenPluginWrapper(plugin Plugin) *FakeOpenPluginWrapper {\n\treturn &FakeOpenPluginWrapper{\n\t\tplugin:      plugin,\n\t\talreadyOpen: map[string]bool{},\n\t}\n}", "language": "go", "code": "func NewFakeOpenPluginWrapper(plugin Plugin) *FakeOpenPluginWrapper {\n\treturn &FakeOpenPluginWrapper{\n\t\tplugin:      plugin,\n\t\talreadyOpen: map[string]bool{},\n\t}\n}", "code_tokens": ["func", "NewFakeOpenPluginWrapper", "(", "plugin", "Plugin", ")", "*", "FakeOpenPluginWrapper", "{", "return", "&", "FakeOpenPluginWrapper", "{", "plugin", ":", "plugin", ",", "alreadyOpen", ":", "map", "[", "string", "]", "bool", "{", "}", ",", "}", "\n", "}"], "docstring": "// NewFakeOpenPluginWrapper is the constructor for FakeOpenPluginWrapper", "docstring_tokens": ["NewFakeOpenPluginWrapper", "is", "the", "constructor", "for", "FakeOpenPluginWrapper"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/transform/plugins/fake_open_wrapper.go#L60-L65", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "grpc/rpclog/grpc.go", "func_name": "UnaryClientInterceptor", "original_string": "func UnaryClientInterceptor(log ttnlog.Interface) grpc.UnaryClientInterceptor {\n\treturn func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) (err error) {\n\t\tlog := getLog(log).WithField(\"method\", method)\n\t\tlog = log.WithFields(FieldsFromOutgoingContext(ctx))\n\t\tstart := time.Now()\n\t\terr = invoker(ctx, method, req, reply, cc, opts...)\n\t\tlog = log.WithField(\"duration\", time.Since(start))\n\t\tif err != nil {\n\t\t\tlog.WithError(err).Debug(\"rpc-client: call failed\")\n\t\t\treturn\n\t\t}\n\t\tlog.Debug(\"rpc-client: call done\")\n\t\treturn\n\t}\n}", "language": "go", "code": "func UnaryClientInterceptor(log ttnlog.Interface) grpc.UnaryClientInterceptor {\n\treturn func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) (err error) {\n\t\tlog := getLog(log).WithField(\"method\", method)\n\t\tlog = log.WithFields(FieldsFromOutgoingContext(ctx))\n\t\tstart := time.Now()\n\t\terr = invoker(ctx, method, req, reply, cc, opts...)\n\t\tlog = log.WithField(\"duration\", time.Since(start))\n\t\tif err != nil {\n\t\t\tlog.WithError(err).Debug(\"rpc-client: call failed\")\n\t\t\treturn\n\t\t}\n\t\tlog.Debug(\"rpc-client: call done\")\n\t\treturn\n\t}\n}", "code_tokens": ["func", "UnaryClientInterceptor", "(", "log", "ttnlog", ".", "Interface", ")", "grpc", ".", "UnaryClientInterceptor", "{", "return", "func", "(", "ctx", "context", ".", "Context", ",", "method", "string", ",", "req", ",", "reply", "interface", "{", "}", ",", "cc", "*", "grpc", ".", "ClientConn", ",", "invoker", "grpc", ".", "UnaryInvoker", ",", "opts", "...", "grpc", ".", "CallOption", ")", "(", "err", "error", ")", "{", "log", ":=", "getLog", "(", "log", ")", ".", "WithField", "(", "\"", "\"", ",", "method", ")", "\n", "log", "=", "log", ".", "WithFields", "(", "FieldsFromOutgoingContext", "(", "ctx", ")", ")", "\n", "start", ":=", "time", ".", "Now", "(", ")", "\n", "err", "=", "invoker", "(", "ctx", ",", "method", ",", "req", ",", "reply", ",", "cc", ",", "opts", "...", ")", "\n", "log", "=", "log", ".", "WithField", "(", "\"", "\"", ",", "time", ".", "Since", "(", "start", ")", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "WithError", "(", "err", ")", ".", "Debug", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "log", ".", "Debug", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "}"], "docstring": "// UnaryClientInterceptor logs unary RPCs on the client side", "docstring_tokens": ["UnaryClientInterceptor", "logs", "unary", "RPCs", "on", "the", "client", "side"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/grpc/rpclog/grpc.go#L78-L92", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "gopherage/cmd/aggregate/aggregate.go", "func_name": "MakeCommand", "original_string": "func MakeCommand() *cobra.Command {\n\tflags := &flags{}\n\tcmd := &cobra.Command{\n\t\tUse:   \"aggregate [files...]\",\n\t\tShort: \"Aggregates multiple Go coverage files.\",\n\t\tLong: `Given multiple Go coverage files from identical binaries recorded in\n\"count\" or \"atomic\" mode, produces a new Go coverage file in the same mode\nthat counts how many of those coverage profiles hit a block at least once.`,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\trun(flags, cmd, args)\n\t\t},\n\t}\n\tcmd.Flags().StringVarP(&flags.OutputFile, \"output\", \"o\", \"-\", \"output file\")\n\treturn cmd\n}", "language": "go", "code": "func MakeCommand() *cobra.Command {\n\tflags := &flags{}\n\tcmd := &cobra.Command{\n\t\tUse:   \"aggregate [files...]\",\n\t\tShort: \"Aggregates multiple Go coverage files.\",\n\t\tLong: `Given multiple Go coverage files from identical binaries recorded in\n\"count\" or \"atomic\" mode, produces a new Go coverage file in the same mode\nthat counts how many of those coverage profiles hit a block at least once.`,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\trun(flags, cmd, args)\n\t\t},\n\t}\n\tcmd.Flags().StringVarP(&flags.OutputFile, \"output\", \"o\", \"-\", \"output file\")\n\treturn cmd\n}", "code_tokens": ["func", "MakeCommand", "(", ")", "*", "cobra", ".", "Command", "{", "flags", ":=", "&", "flags", "{", "}", "\n", "cmd", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Long", ":", "`Given multiple Go coverage files from identical binaries recorded in\n\"count\" or \"atomic\" mode, produces a new Go coverage file in the same mode\nthat counts how many of those coverage profiles hit a block at least once.`", ",", "Run", ":", "func", "(", "cmd", "*", "cobra", ".", "Command", ",", "args", "[", "]", "string", ")", "{", "run", "(", "flags", ",", "cmd", ",", "args", ")", "\n", "}", ",", "}", "\n", "cmd", ".", "Flags", "(", ")", ".", "StringVarP", "(", "&", "flags", ".", "OutputFile", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "return", "cmd", "\n", "}"], "docstring": "// MakeCommand returns an `aggregate` command.", "docstring_tokens": ["MakeCommand", "returns", "an", "aggregate", "command", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/gopherage/cmd/aggregate/aggregate.go#L34-L48", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "item.go", "func_name": "Bytes", "original_string": "func (itm *Item) Bytes() (bs []byte) {\n\tl := itm.dataLen\n\tdataOffset := uintptr(unsafe.Pointer(itm)) + itemHeaderSize\n\n\thdr := (*reflect.SliceHeader)(unsafe.Pointer(&bs))\n\thdr.Data = dataOffset\n\thdr.Len = int(l)\n\thdr.Cap = hdr.Len\n\treturn\n}", "language": "go", "code": "func (itm *Item) Bytes() (bs []byte) {\n\tl := itm.dataLen\n\tdataOffset := uintptr(unsafe.Pointer(itm)) + itemHeaderSize\n\n\thdr := (*reflect.SliceHeader)(unsafe.Pointer(&bs))\n\thdr.Data = dataOffset\n\thdr.Len = int(l)\n\thdr.Cap = hdr.Len\n\treturn\n}", "code_tokens": ["func", "(", "itm", "*", "Item", ")", "Bytes", "(", ")", "(", "bs", "[", "]", "byte", ")", "{", "l", ":=", "itm", ".", "dataLen", "\n", "dataOffset", ":=", "uintptr", "(", "unsafe", ".", "Pointer", "(", "itm", ")", ")", "+", "itemHeaderSize", "\n\n", "hdr", ":=", "(", "*", "reflect", ".", "SliceHeader", ")", "(", "unsafe", ".", "Pointer", "(", "&", "bs", ")", ")", "\n", "hdr", ".", "Data", "=", "dataOffset", "\n", "hdr", ".", "Len", "=", "int", "(", "l", ")", "\n", "hdr", ".", "Cap", "=", "hdr", ".", "Len", "\n", "return", "\n", "}"], "docstring": "// Bytes return item data bytes", "docstring_tokens": ["Bytes", "return", "item", "data", "bytes"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/item.go#L96-L105", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "mail/message.go", "func_name": "AddBody", "original_string": "func (m *Message) AddBody(r render.Renderer, data render.Data) error {\n\tbuf := bytes.NewBuffer([]byte{})\n\terr := r.Render(buf, m.merge(data))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tm.Bodies = append(m.Bodies, Body{\n\t\tContent:     buf.String(),\n\t\tContentType: r.ContentType(),\n\t})\n\n\treturn nil\n}", "language": "go", "code": "func (m *Message) AddBody(r render.Renderer, data render.Data) error {\n\tbuf := bytes.NewBuffer([]byte{})\n\terr := r.Render(buf, m.merge(data))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tm.Bodies = append(m.Bodies, Body{\n\t\tContent:     buf.String(),\n\t\tContentType: r.ContentType(),\n\t})\n\n\treturn nil\n}", "code_tokens": ["func", "(", "m", "*", "Message", ")", "AddBody", "(", "r", "render", ".", "Renderer", ",", "data", "render", ".", "Data", ")", "error", "{", "buf", ":=", "bytes", ".", "NewBuffer", "(", "[", "]", "byte", "{", "}", ")", "\n", "err", ":=", "r", ".", "Render", "(", "buf", ",", "m", ".", "merge", "(", "data", ")", ")", "\n\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "m", ".", "Bodies", "=", "append", "(", "m", ".", "Bodies", ",", "Body", "{", "Content", ":", "buf", ".", "String", "(", ")", ",", "ContentType", ":", "r", ".", "ContentType", "(", ")", ",", "}", ")", "\n\n", "return", "nil", "\n", "}"], "docstring": "// AddBody the message by receiving a renderer and rendering data, first message will be\n// used as the main message Body rest of them will be passed as alternative bodies on the\n// email message", "docstring_tokens": ["AddBody", "the", "message", "by", "receiving", "a", "renderer", "and", "rendering", "data", "first", "message", "will", "be", "used", "as", "the", "main", "message", "Body", "rest", "of", "them", "will", "be", "passed", "as", "alternative", "bodies", "on", "the", "email", "message"], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/mail/message.go#L44-L58", "partition": "test"}
{"repo": "iron-io/functions_go", "path": "client/apps/delete_apps_app_parameters.go", "func_name": "WithHTTPClient", "original_string": "func (o *DeleteAppsAppParams) WithHTTPClient(client *http.Client) *DeleteAppsAppParams {\n\to.SetHTTPClient(client)\n\treturn o\n}", "language": "go", "code": "func (o *DeleteAppsAppParams) WithHTTPClient(client *http.Client) *DeleteAppsAppParams {\n\to.SetHTTPClient(client)\n\treturn o\n}", "code_tokens": ["func", "(", "o", "*", "DeleteAppsAppParams", ")", "WithHTTPClient", "(", "client", "*", "http", ".", "Client", ")", "*", "DeleteAppsAppParams", "{", "o", ".", "SetHTTPClient", "(", "client", ")", "\n", "return", "o", "\n", "}"], "docstring": "// WithHTTPClient adds the HTTPClient to the delete apps app params", "docstring_tokens": ["WithHTTPClient", "adds", "the", "HTTPClient", "to", "the", "delete", "apps", "app", "params"], "sha": "91b84f5bbb17095bf1c7028ec6e70a3dc06a5893", "url": "https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/apps/delete_apps_app_parameters.go#L99-L102", "partition": "test"}
{"repo": "mastahyeti/fakeca", "path": "configuration.go", "func_name": "OCSPServer", "original_string": "func OCSPServer(value ...string) Option {\n\treturn func(c *configuration) {\n\t\tc.ocspServer = append(c.ocspServer, value...)\n\t}\n}", "language": "go", "code": "func OCSPServer(value ...string) Option {\n\treturn func(c *configuration) {\n\t\tc.ocspServer = append(c.ocspServer, value...)\n\t}\n}", "code_tokens": ["func", "OCSPServer", "(", "value", "...", "string", ")", "Option", "{", "return", "func", "(", "c", "*", "configuration", ")", "{", "c", ".", "ocspServer", "=", "append", "(", "c", ".", "ocspServer", ",", "value", "...", ")", "\n", "}", "\n", "}"], "docstring": "// OCSPServer is an Option for setting the identity's certificate's OCSPServer.", "docstring_tokens": ["OCSPServer", "is", "an", "Option", "for", "setting", "the", "identity", "s", "certificate", "s", "OCSPServer", "."], "sha": "c1d84b1b473e99212130da7b311dd0605de5ed0a", "url": "https://github.com/mastahyeti/fakeca/blob/c1d84b1b473e99212130da7b311dd0605de5ed0a/configuration.go#L222-L226", "partition": "test"}
{"repo": "golang/debug", "path": "internal/core/read.go", "func_name": "ReadUint32", "original_string": "func (p *Process) ReadUint32(a Address) uint32 {\n\tm := p.findMapping(a)\n\tif m == nil {\n\t\tpanic(fmt.Errorf(\"address %x is not mapped in the core file\", a))\n\t}\n\tb := m.contents[a.Sub(m.min):]\n\tif len(b) < 4 {\n\t\tvar buf [4]byte\n\t\tb = buf[:]\n\t\tp.ReadAt(b, a)\n\t}\n\tif p.littleEndian {\n\t\treturn binary.LittleEndian.Uint32(b)\n\t}\n\treturn binary.BigEndian.Uint32(b)\n}", "language": "go", "code": "func (p *Process) ReadUint32(a Address) uint32 {\n\tm := p.findMapping(a)\n\tif m == nil {\n\t\tpanic(fmt.Errorf(\"address %x is not mapped in the core file\", a))\n\t}\n\tb := m.contents[a.Sub(m.min):]\n\tif len(b) < 4 {\n\t\tvar buf [4]byte\n\t\tb = buf[:]\n\t\tp.ReadAt(b, a)\n\t}\n\tif p.littleEndian {\n\t\treturn binary.LittleEndian.Uint32(b)\n\t}\n\treturn binary.BigEndian.Uint32(b)\n}", "code_tokens": ["func", "(", "p", "*", "Process", ")", "ReadUint32", "(", "a", "Address", ")", "uint32", "{", "m", ":=", "p", ".", "findMapping", "(", "a", ")", "\n", "if", "m", "==", "nil", "{", "panic", "(", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "a", ")", ")", "\n", "}", "\n", "b", ":=", "m", ".", "contents", "[", "a", ".", "Sub", "(", "m", ".", "min", ")", ":", "]", "\n", "if", "len", "(", "b", ")", "<", "4", "{", "var", "buf", "[", "4", "]", "byte", "\n", "b", "=", "buf", "[", ":", "]", "\n", "p", ".", "ReadAt", "(", "b", ",", "a", ")", "\n", "}", "\n", "if", "p", ".", "littleEndian", "{", "return", "binary", ".", "LittleEndian", ".", "Uint32", "(", "b", ")", "\n", "}", "\n", "return", "binary", ".", "BigEndian", ".", "Uint32", "(", "b", ")", "\n", "}"], "docstring": "// ReadUint32 returns a uint32 read from address a of the inferior.", "docstring_tokens": ["ReadUint32", "returns", "a", "uint32", "read", "from", "address", "a", "of", "the", "inferior", "."], "sha": "19561fee47cf8cd0400d1b094c5898002f97cf90", "url": "https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/core/read.go#L60-L75", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "boskos/mason/storage.go", "func_name": "UpdateConfig", "original_string": "func (s *Storage) UpdateConfig(conf common.ResourcesConfig) error {\n\treturn s.configs.Update(conf)\n}", "language": "go", "code": "func (s *Storage) UpdateConfig(conf common.ResourcesConfig) error {\n\treturn s.configs.Update(conf)\n}", "code_tokens": ["func", "(", "s", "*", "Storage", ")", "UpdateConfig", "(", "conf", "common", ".", "ResourcesConfig", ")", "error", "{", "return", "s", ".", "configs", ".", "Update", "(", "conf", ")", "\n", "}"], "docstring": "// UpdateConfig updates a given if it exists or fail otherwise", "docstring_tokens": ["UpdateConfig", "updates", "a", "given", "if", "it", "exists", "or", "fail", "otherwise"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/mason/storage.go#L53-L55", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "skl/arena.go", "func_name": "getNodeOffset", "original_string": "func (s *Arena) getNodeOffset(nd *node) uint32 {\n\tif nd == nil {\n\t\treturn 0\n\t}\n\n\treturn uint32(uintptr(unsafe.Pointer(nd)) - uintptr(unsafe.Pointer(&s.buf[0])))\n}", "language": "go", "code": "func (s *Arena) getNodeOffset(nd *node) uint32 {\n\tif nd == nil {\n\t\treturn 0\n\t}\n\n\treturn uint32(uintptr(unsafe.Pointer(nd)) - uintptr(unsafe.Pointer(&s.buf[0])))\n}", "code_tokens": ["func", "(", "s", "*", "Arena", ")", "getNodeOffset", "(", "nd", "*", "node", ")", "uint32", "{", "if", "nd", "==", "nil", "{", "return", "0", "\n", "}", "\n\n", "return", "uint32", "(", "uintptr", "(", "unsafe", ".", "Pointer", "(", "nd", ")", ")", "-", "uintptr", "(", "unsafe", ".", "Pointer", "(", "&", "s", ".", "buf", "[", "0", "]", ")", ")", ")", "\n", "}"], "docstring": "// getNodeOffset returns the offset of node in the arena. If the node pointer is\n// nil, then the zero offset is returned.", "docstring_tokens": ["getNodeOffset", "returns", "the", "offset", "of", "node", "in", "the", "arena", ".", "If", "the", "node", "pointer", "is", "nil", "then", "the", "zero", "offset", "is", "returned", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/skl/arena.go#L130-L136", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/obj/tracing.go", "func_name": "Reader", "original_string": "func (o *tracingObjClient) Reader(ctx context.Context, name string, offset uint64, size uint64) (io.ReadCloser, error) {\n\tspan, ctx := tracing.AddSpanToAnyExisting(ctx, o.provider+\".Reader\",\n\t\t\"name\", name,\n\t\t\"offset\", fmt.Sprintf(\"%d\", offset),\n\t\t\"size\", fmt.Sprintf(\"%d\", size))\n\tdefer tracing.FinishAnySpan(span)\n\treturn o.Client.Reader(ctx, name, offset, size)\n}", "language": "go", "code": "func (o *tracingObjClient) Reader(ctx context.Context, name string, offset uint64, size uint64) (io.ReadCloser, error) {\n\tspan, ctx := tracing.AddSpanToAnyExisting(ctx, o.provider+\".Reader\",\n\t\t\"name\", name,\n\t\t\"offset\", fmt.Sprintf(\"%d\", offset),\n\t\t\"size\", fmt.Sprintf(\"%d\", size))\n\tdefer tracing.FinishAnySpan(span)\n\treturn o.Client.Reader(ctx, name, offset, size)\n}", "code_tokens": ["func", "(", "o", "*", "tracingObjClient", ")", "Reader", "(", "ctx", "context", ".", "Context", ",", "name", "string", ",", "offset", "uint64", ",", "size", "uint64", ")", "(", "io", ".", "ReadCloser", ",", "error", ")", "{", "span", ",", "ctx", ":=", "tracing", ".", "AddSpanToAnyExisting", "(", "ctx", ",", "o", ".", "provider", "+", "\"", "\"", ",", "\"", "\"", ",", "name", ",", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "offset", ")", ",", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "size", ")", ")", "\n", "defer", "tracing", ".", "FinishAnySpan", "(", "span", ")", "\n", "return", "o", ".", "Client", ".", "Reader", "(", "ctx", ",", "name", ",", "offset", ",", "size", ")", "\n", "}"], "docstring": "// Reader implements the corresponding method in the Client interface", "docstring_tokens": ["Reader", "implements", "the", "corresponding", "method", "in", "the", "Client", "interface"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/obj/tracing.go#L32-L39", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "meshconn/peer.go", "func_name": "OnGossipUnicast", "original_string": "func (p *Peer) OnGossipUnicast(_ mesh.PeerName, buf []byte) error {\n\tpkt := makePkt(buf)\n\tp.recv <- pkt // to ReadFrom\n\treturn nil\n}", "language": "go", "code": "func (p *Peer) OnGossipUnicast(_ mesh.PeerName, buf []byte) error {\n\tpkt := makePkt(buf)\n\tp.recv <- pkt // to ReadFrom\n\treturn nil\n}", "code_tokens": ["func", "(", "p", "*", "Peer", ")", "OnGossipUnicast", "(", "_", "mesh", ".", "PeerName", ",", "buf", "[", "]", "byte", ")", "error", "{", "pkt", ":=", "makePkt", "(", "buf", ")", "\n", "p", ".", "recv", "<-", "pkt", "// to ReadFrom", "\n", "return", "nil", "\n", "}"], "docstring": "// OnGossipUnicast implements mesh.Gossiper.\n// The buf is a single pkt.", "docstring_tokens": ["OnGossipUnicast", "implements", "mesh", ".", "Gossiper", ".", "The", "buf", "is", "a", "single", "pkt", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/meshconn/peer.go#L178-L182", "partition": "test"}
{"repo": "ChrisTrenkamp/goxpath", "path": "tree/tree.go", "func_name": "BuildNS", "original_string": "func BuildNS(t Elem) (ret []NS) {\n\tvals := make(map[xml.Name]string)\n\n\tif nselem, ok := t.(NSElem); ok {\n\t\tbuildNS(nselem, vals)\n\n\t\tret = make([]NS, 0, len(vals))\n\t\ti := 1\n\n\t\tfor k, v := range vals {\n\t\t\tif !(k.Local == \"xmlns\" && k.Space == \"\" && v == \"\") {\n\t\t\t\tret = append(ret, NS{\n\t\t\t\t\tAttr:     xml.Attr{Name: k, Value: v},\n\t\t\t\t\tParent:   t,\n\t\t\t\t\tNodeType: NtNs,\n\t\t\t\t})\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tsort.Sort(nsValueSort(ret))\n\t\tfor i := range ret {\n\t\t\tret[i].NodePos = NodePos(t.Pos() + i + 1)\n\t\t}\n\t}\n\n\treturn ret\n}", "language": "go", "code": "func BuildNS(t Elem) (ret []NS) {\n\tvals := make(map[xml.Name]string)\n\n\tif nselem, ok := t.(NSElem); ok {\n\t\tbuildNS(nselem, vals)\n\n\t\tret = make([]NS, 0, len(vals))\n\t\ti := 1\n\n\t\tfor k, v := range vals {\n\t\t\tif !(k.Local == \"xmlns\" && k.Space == \"\" && v == \"\") {\n\t\t\t\tret = append(ret, NS{\n\t\t\t\t\tAttr:     xml.Attr{Name: k, Value: v},\n\t\t\t\t\tParent:   t,\n\t\t\t\t\tNodeType: NtNs,\n\t\t\t\t})\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tsort.Sort(nsValueSort(ret))\n\t\tfor i := range ret {\n\t\t\tret[i].NodePos = NodePos(t.Pos() + i + 1)\n\t\t}\n\t}\n\n\treturn ret\n}", "code_tokens": ["func", "BuildNS", "(", "t", "Elem", ")", "(", "ret", "[", "]", "NS", ")", "{", "vals", ":=", "make", "(", "map", "[", "xml", ".", "Name", "]", "string", ")", "\n\n", "if", "nselem", ",", "ok", ":=", "t", ".", "(", "NSElem", ")", ";", "ok", "{", "buildNS", "(", "nselem", ",", "vals", ")", "\n\n", "ret", "=", "make", "(", "[", "]", "NS", ",", "0", ",", "len", "(", "vals", ")", ")", "\n", "i", ":=", "1", "\n\n", "for", "k", ",", "v", ":=", "range", "vals", "{", "if", "!", "(", "k", ".", "Local", "==", "\"", "\"", "&&", "k", ".", "Space", "==", "\"", "\"", "&&", "v", "==", "\"", "\"", ")", "{", "ret", "=", "append", "(", "ret", ",", "NS", "{", "Attr", ":", "xml", ".", "Attr", "{", "Name", ":", "k", ",", "Value", ":", "v", "}", ",", "Parent", ":", "t", ",", "NodeType", ":", "NtNs", ",", "}", ")", "\n", "i", "++", "\n", "}", "\n", "}", "\n\n", "sort", ".", "Sort", "(", "nsValueSort", "(", "ret", ")", ")", "\n", "for", "i", ":=", "range", "ret", "{", "ret", "[", "i", "]", ".", "NodePos", "=", "NodePos", "(", "t", ".", "Pos", "(", ")", "+", "i", "+", "1", ")", "\n", "}", "\n", "}", "\n\n", "return", "ret", "\n", "}"], "docstring": "//BuildNS resolves all the namespace nodes of the element and returns them", "docstring_tokens": ["BuildNS", "resolves", "all", "the", "namespace", "nodes", "of", "the", "element", "and", "returns", "them"], "sha": "c385f95c6022e7756e91beac5f5510872f7dcb7d", "url": "https://github.com/ChrisTrenkamp/goxpath/blob/c385f95c6022e7756e91beac5f5510872f7dcb7d/tree/tree.go#L89-L116", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/config.go", "func_name": "EnabledReposForPlugin", "original_string": "func (c *Configuration) EnabledReposForPlugin(plugin string) (orgs, repos []string) {\n\tfor repo, plugins := range c.Plugins {\n\t\tfound := false\n\t\tfor _, candidate := range plugins {\n\t\t\tif candidate == plugin {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif found {\n\t\t\tif strings.Contains(repo, \"/\") {\n\t\t\t\trepos = append(repos, repo)\n\t\t\t} else {\n\t\t\t\torgs = append(orgs, repo)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}", "language": "go", "code": "func (c *Configuration) EnabledReposForPlugin(plugin string) (orgs, repos []string) {\n\tfor repo, plugins := range c.Plugins {\n\t\tfound := false\n\t\tfor _, candidate := range plugins {\n\t\t\tif candidate == plugin {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif found {\n\t\t\tif strings.Contains(repo, \"/\") {\n\t\t\t\trepos = append(repos, repo)\n\t\t\t} else {\n\t\t\t\torgs = append(orgs, repo)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "c", "*", "Configuration", ")", "EnabledReposForPlugin", "(", "plugin", "string", ")", "(", "orgs", ",", "repos", "[", "]", "string", ")", "{", "for", "repo", ",", "plugins", ":=", "range", "c", ".", "Plugins", "{", "found", ":=", "false", "\n", "for", "_", ",", "candidate", ":=", "range", "plugins", "{", "if", "candidate", "==", "plugin", "{", "found", "=", "true", "\n", "break", "\n", "}", "\n", "}", "\n", "if", "found", "{", "if", "strings", ".", "Contains", "(", "repo", ",", "\"", "\"", ")", "{", "repos", "=", "append", "(", "repos", ",", "repo", ")", "\n", "}", "else", "{", "orgs", "=", "append", "(", "orgs", ",", "repo", ")", "\n", "}", "\n", "}", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// EnabledReposForPlugin returns the orgs and repos that have enabled the passed plugin.", "docstring_tokens": ["EnabledReposForPlugin", "returns", "the", "orgs", "and", "repos", "that", "have", "enabled", "the", "passed", "plugin", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/config.go#L619-L637", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "robots/issue-creator/sources/triage-filer.go", "func_name": "Issues", "original_string": "func (f *TriageFiler) Issues(c *creator.IssueCreator) ([]creator.Issue, error) {\n\tf.creator = c\n\trawjson, err := ReadHTTP(clusterDataURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclusters, err := f.loadClusters(rawjson)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttopclusters := topClusters(clusters, f.topClustersCount)\n\tissues := make([]creator.Issue, 0, len(topclusters))\n\tfor _, clust := range topclusters {\n\t\tissues = append(issues, clust)\n\t}\n\treturn issues, nil\n}", "language": "go", "code": "func (f *TriageFiler) Issues(c *creator.IssueCreator) ([]creator.Issue, error) {\n\tf.creator = c\n\trawjson, err := ReadHTTP(clusterDataURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclusters, err := f.loadClusters(rawjson)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttopclusters := topClusters(clusters, f.topClustersCount)\n\tissues := make([]creator.Issue, 0, len(topclusters))\n\tfor _, clust := range topclusters {\n\t\tissues = append(issues, clust)\n\t}\n\treturn issues, nil\n}", "code_tokens": ["func", "(", "f", "*", "TriageFiler", ")", "Issues", "(", "c", "*", "creator", ".", "IssueCreator", ")", "(", "[", "]", "creator", ".", "Issue", ",", "error", ")", "{", "f", ".", "creator", "=", "c", "\n", "rawjson", ",", "err", ":=", "ReadHTTP", "(", "clusterDataURL", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "clusters", ",", "err", ":=", "f", ".", "loadClusters", "(", "rawjson", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "topclusters", ":=", "topClusters", "(", "clusters", ",", "f", ".", "topClustersCount", ")", "\n", "issues", ":=", "make", "(", "[", "]", "creator", ".", "Issue", ",", "0", ",", "len", "(", "topclusters", ")", ")", "\n", "for", "_", ",", "clust", ":=", "range", "topclusters", "{", "issues", "=", "append", "(", "issues", ",", "clust", ")", "\n", "}", "\n", "return", "issues", ",", "nil", "\n", "}"], "docstring": "// Issues is the main work function of the TriageFiler.  It fetches and parses cluster data,\n// then syncs the top issues to github with the IssueCreator.", "docstring_tokens": ["Issues", "is", "the", "main", "work", "function", "of", "the", "TriageFiler", ".", "It", "fetches", "and", "parses", "cluster", "data", "then", "syncs", "the", "top", "issues", "to", "github", "with", "the", "IssueCreator", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/robots/issue-creator/sources/triage-filer.go#L62-L78", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/api_cluster.go", "func_name": "tryClusterRebalance", "original_string": "func tryClusterRebalance(d *Daemon) error {\n\tleader, err := d.gateway.LeaderAddress()\n\tif err != nil {\n\t\t// This is not a fatal error, so let's just log it.\n\t\treturn errors.Wrap(err, \"failed to get current leader node\")\n\t}\n\tcert := d.endpoints.NetworkCert()\n\tclient, err := cluster.Connect(leader, cert, true)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to connect to leader node\")\n\t}\n\t_, _, err = client.RawQuery(\"POST\", \"/internal/cluster/rebalance\", nil, \"\")\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"request to rebalance cluster failed\")\n\t}\n\treturn nil\n}", "language": "go", "code": "func tryClusterRebalance(d *Daemon) error {\n\tleader, err := d.gateway.LeaderAddress()\n\tif err != nil {\n\t\t// This is not a fatal error, so let's just log it.\n\t\treturn errors.Wrap(err, \"failed to get current leader node\")\n\t}\n\tcert := d.endpoints.NetworkCert()\n\tclient, err := cluster.Connect(leader, cert, true)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to connect to leader node\")\n\t}\n\t_, _, err = client.RawQuery(\"POST\", \"/internal/cluster/rebalance\", nil, \"\")\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"request to rebalance cluster failed\")\n\t}\n\treturn nil\n}", "code_tokens": ["func", "tryClusterRebalance", "(", "d", "*", "Daemon", ")", "error", "{", "leader", ",", "err", ":=", "d", ".", "gateway", ".", "LeaderAddress", "(", ")", "\n", "if", "err", "!=", "nil", "{", "// This is not a fatal error, so let's just log it.", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "cert", ":=", "d", ".", "endpoints", ".", "NetworkCert", "(", ")", "\n", "client", ",", "err", ":=", "cluster", ".", "Connect", "(", "leader", ",", "cert", ",", "true", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "_", ",", "_", ",", "err", "=", "client", ".", "RawQuery", "(", "\"", "\"", ",", "\"", "\"", ",", "nil", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// This function is used to notify the leader that a node was removed, it will\n// decide whether to promote a new node as database node.", "docstring_tokens": ["This", "function", "is", "used", "to", "notify", "the", "leader", "that", "a", "node", "was", "removed", "it", "will", "decide", "whether", "to", "promote", "a", "new", "node", "as", "database", "node", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/api_cluster.go#L954-L970", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "store.go", "func_name": "Set", "original_string": "func (rp *redisProvider) Set(key string, values map[string]string) (*redisStore, error) {\n\trs := &redisStore{SID: key, Values: values}\n\terr := provider.refresh(rs)\n\treturn rs, err\n}", "language": "go", "code": "func (rp *redisProvider) Set(key string, values map[string]string) (*redisStore, error) {\n\trs := &redisStore{SID: key, Values: values}\n\terr := provider.refresh(rs)\n\treturn rs, err\n}", "code_tokens": ["func", "(", "rp", "*", "redisProvider", ")", "Set", "(", "key", "string", ",", "values", "map", "[", "string", "]", "string", ")", "(", "*", "redisStore", ",", "error", ")", "{", "rs", ":=", "&", "redisStore", "{", "SID", ":", "key", ",", "Values", ":", "values", "}", "\n", "err", ":=", "provider", ".", "refresh", "(", "rs", ")", "\n", "return", "rs", ",", "err", "\n", "}"], "docstring": "// Set value in redis session", "docstring_tokens": ["Set", "value", "in", "redis", "session"], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/store.go#L63-L67", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/sys/fs.go", "func_name": "initDirs", "original_string": "func (s *OS) initDirs() error {\n\tdirs := []struct {\n\t\tpath string\n\t\tmode os.FileMode\n\t}{\n\t\t{s.VarDir, 0711},\n\t\t{filepath.Join(s.VarDir, \"backups\"), 0700},\n\t\t{s.CacheDir, 0700},\n\t\t{filepath.Join(s.VarDir, \"containers\"), 0711},\n\t\t{filepath.Join(s.VarDir, \"database\"), 0700},\n\t\t{filepath.Join(s.VarDir, \"devices\"), 0711},\n\t\t{filepath.Join(s.VarDir, \"devlxd\"), 0755},\n\t\t{filepath.Join(s.VarDir, \"disks\"), 0700},\n\t\t{filepath.Join(s.VarDir, \"images\"), 0700},\n\t\t{s.LogDir, 0700},\n\t\t{filepath.Join(s.VarDir, \"networks\"), 0711},\n\t\t{filepath.Join(s.VarDir, \"security\"), 0700},\n\t\t{filepath.Join(s.VarDir, \"shmounts\"), 0711},\n\t\t{filepath.Join(s.VarDir, \"snapshots\"), 0700},\n\t\t{filepath.Join(s.VarDir, \"storage-pools\"), 0711},\n\t}\n\n\tfor _, dir := range dirs {\n\t\terr := os.Mkdir(dir.path, dir.mode)\n\t\tif err != nil && !os.IsExist(err) {\n\t\t\treturn errors.Wrapf(err, \"failed to init dir %s\", dir.path)\n\t\t}\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (s *OS) initDirs() error {\n\tdirs := []struct {\n\t\tpath string\n\t\tmode os.FileMode\n\t}{\n\t\t{s.VarDir, 0711},\n\t\t{filepath.Join(s.VarDir, \"backups\"), 0700},\n\t\t{s.CacheDir, 0700},\n\t\t{filepath.Join(s.VarDir, \"containers\"), 0711},\n\t\t{filepath.Join(s.VarDir, \"database\"), 0700},\n\t\t{filepath.Join(s.VarDir, \"devices\"), 0711},\n\t\t{filepath.Join(s.VarDir, \"devlxd\"), 0755},\n\t\t{filepath.Join(s.VarDir, \"disks\"), 0700},\n\t\t{filepath.Join(s.VarDir, \"images\"), 0700},\n\t\t{s.LogDir, 0700},\n\t\t{filepath.Join(s.VarDir, \"networks\"), 0711},\n\t\t{filepath.Join(s.VarDir, \"security\"), 0700},\n\t\t{filepath.Join(s.VarDir, \"shmounts\"), 0711},\n\t\t{filepath.Join(s.VarDir, \"snapshots\"), 0700},\n\t\t{filepath.Join(s.VarDir, \"storage-pools\"), 0711},\n\t}\n\n\tfor _, dir := range dirs {\n\t\terr := os.Mkdir(dir.path, dir.mode)\n\t\tif err != nil && !os.IsExist(err) {\n\t\t\treturn errors.Wrapf(err, \"failed to init dir %s\", dir.path)\n\t\t}\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "s", "*", "OS", ")", "initDirs", "(", ")", "error", "{", "dirs", ":=", "[", "]", "struct", "{", "path", "string", "\n", "mode", "os", ".", "FileMode", "\n", "}", "{", "{", "s", ".", "VarDir", ",", "0711", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0700", "}", ",", "{", "s", ".", "CacheDir", ",", "0700", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0711", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0700", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0711", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0755", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0700", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0700", "}", ",", "{", "s", ".", "LogDir", ",", "0700", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0711", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0700", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0711", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0700", "}", ",", "{", "filepath", ".", "Join", "(", "s", ".", "VarDir", ",", "\"", "\"", ")", ",", "0711", "}", ",", "}", "\n\n", "for", "_", ",", "dir", ":=", "range", "dirs", "{", "err", ":=", "os", ".", "Mkdir", "(", "dir", ".", "path", ",", "dir", ".", "mode", ")", "\n", "if", "err", "!=", "nil", "&&", "!", "os", ".", "IsExist", "(", "err", ")", "{", "return", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ",", "dir", ".", "path", ")", "\n", "}", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Make sure all our directories are available.", "docstring_tokens": ["Make", "sure", "all", "our", "directories", "are", "available", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/sys/fs.go#L37-L67", "partition": "test"}
{"repo": "segmentio/nsq-go", "path": "nsqlookup/response.go", "func_name": "Write", "original_string": "func (r RawResponse) Write(w *bufio.Writer) error {\n\treturn writeResponse(w, []byte(r))\n}", "language": "go", "code": "func (r RawResponse) Write(w *bufio.Writer) error {\n\treturn writeResponse(w, []byte(r))\n}", "code_tokens": ["func", "(", "r", "RawResponse", ")", "Write", "(", "w", "*", "bufio", ".", "Writer", ")", "error", "{", "return", "writeResponse", "(", "w", ",", "[", "]", "byte", "(", "r", ")", ")", "\n", "}"], "docstring": "// Write outputs the response to w.", "docstring_tokens": ["Write", "outputs", "the", "response", "to", "w", "."], "sha": "ff4eef968f46eb580d9dba4f637c5dfb1e5b2208", "url": "https://github.com/segmentio/nsq-go/blob/ff4eef968f46eb580d9dba4f637c5dfb1e5b2208/nsqlookup/response.go#L30-L32", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "internal/stack/stack.go", "func_name": "String", "original_string": "func (s *Stack) String() string {\n\tbuf := bytes.Buffer{}\n\tfor k, v := range *s {\n\t\tfmt.Fprintf(&buf, \"%03d: %q\\n\", k, v)\n\t}\n\treturn buf.String()\n}", "language": "go", "code": "func (s *Stack) String() string {\n\tbuf := bytes.Buffer{}\n\tfor k, v := range *s {\n\t\tfmt.Fprintf(&buf, \"%03d: %q\\n\", k, v)\n\t}\n\treturn buf.String()\n}", "code_tokens": ["func", "(", "s", "*", "Stack", ")", "String", "(", ")", "string", "{", "buf", ":=", "bytes", ".", "Buffer", "{", "}", "\n", "for", "k", ",", "v", ":=", "range", "*", "s", "{", "fmt", ".", "Fprintf", "(", "&", "buf", ",", "\"", "\\n", "\"", ",", "k", ",", "v", ")", "\n", "}", "\n", "return", "buf", ".", "String", "(", ")", "\n", "}"], "docstring": "// String returns the textual representation of the stack", "docstring_tokens": ["String", "returns", "the", "textual", "representation", "of", "the", "stack"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/internal/stack/stack.go#L123-L129", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "ValidEnum", "original_string": "func (e ErrorCode) ValidEnum(v int32) bool {\n\t_, ok := errorCodeMap[v]\n\treturn ok\n}", "language": "go", "code": "func (e ErrorCode) ValidEnum(v int32) bool {\n\t_, ok := errorCodeMap[v]\n\treturn ok\n}", "code_tokens": ["func", "(", "e", "ErrorCode", ")", "ValidEnum", "(", "v", "int32", ")", "bool", "{", "_", ",", "ok", ":=", "errorCodeMap", "[", "v", "]", "\n", "return", "ok", "\n", "}"], "docstring": "// ValidEnum validates a proposed value for this enum.  Implements\n// the Enum interface for ErrorCode", "docstring_tokens": ["ValidEnum", "validates", "a", "proposed", "value", "for", "this", "enum", ".", "Implements", "the", "Enum", "interface", "for", "ErrorCode"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L5959-L5962", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewPeerAddressIp", "original_string": "func NewPeerAddressIp(aType IpAddrType, value interface{}) (result PeerAddressIp, err error) {\n\tresult.Type = aType\n\tswitch IpAddrType(aType) {\n\tcase IpAddrTypeIPv4:\n\t\ttv, ok := value.([4]byte)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be [4]byte\")\n\t\t\treturn\n\t\t}\n\t\tresult.Ipv4 = &tv\n\tcase IpAddrTypeIPv6:\n\t\ttv, ok := value.([16]byte)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be [16]byte\")\n\t\t\treturn\n\t\t}\n\t\tresult.Ipv6 = &tv\n\t}\n\treturn\n}", "language": "go", "code": "func NewPeerAddressIp(aType IpAddrType, value interface{}) (result PeerAddressIp, err error) {\n\tresult.Type = aType\n\tswitch IpAddrType(aType) {\n\tcase IpAddrTypeIPv4:\n\t\ttv, ok := value.([4]byte)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be [4]byte\")\n\t\t\treturn\n\t\t}\n\t\tresult.Ipv4 = &tv\n\tcase IpAddrTypeIPv6:\n\t\ttv, ok := value.([16]byte)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be [16]byte\")\n\t\t\treturn\n\t\t}\n\t\tresult.Ipv6 = &tv\n\t}\n\treturn\n}", "code_tokens": ["func", "NewPeerAddressIp", "(", "aType", "IpAddrType", ",", "value", "interface", "{", "}", ")", "(", "result", "PeerAddressIp", ",", "err", "error", ")", "{", "result", ".", "Type", "=", "aType", "\n", "switch", "IpAddrType", "(", "aType", ")", "{", "case", "IpAddrTypeIPv4", ":", "tv", ",", "ok", ":=", "value", ".", "(", "[", "4", "]", "byte", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Ipv4", "=", "&", "tv", "\n", "case", "IpAddrTypeIPv6", ":", "tv", ",", "ok", ":=", "value", ".", "(", "[", "16", "]", "byte", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Ipv6", "=", "&", "tv", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// NewPeerAddressIp creates a new  PeerAddressIp.", "docstring_tokens": ["NewPeerAddressIp", "creates", "a", "new", "PeerAddressIp", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6106-L6125", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "experiment/resultstore/convert.go", "func_name": "convertSuiteMeta", "original_string": "func convertSuiteMeta(suiteMeta gcs.SuitesMeta) resultstore.Suite {\n\tout := resultstore.Suite{\n\t\tName: path.Base(suiteMeta.Path),\n\t\tFiles: []resultstore.File{\n\t\t\t{\n\t\t\t\tContentType: \"text/xml\",\n\t\t\t\tID:          resultstore.UUID(),\n\t\t\t\tURL:         suiteMeta.Path, // ensure the junit.xml file appears in artifacts list\n\t\t\t},\n\t\t},\n\t}\n\tfor _, suite := range suiteMeta.Suites.Suites {\n\t\tchild := resultstore.Suite{\n\t\t\tName:     suite.Name,\n\t\t\tDuration: dur(suite.Time),\n\t\t}\n\t\tswitch {\n\t\tcase suite.Failures > 0 && suite.Tests >= suite.Failures:\n\t\t\tchild.Failures = append(child.Failures, resultstore.Failure{\n\t\t\t\tMessage: fmt.Sprintf(\"%d out of %d tests failed (%.1f%% passing)\", suite.Failures, suite.Tests, float64(suite.Tests-suite.Failures)*100.0/float64(suite.Tests)),\n\t\t\t})\n\t\tcase suite.Failures > 0:\n\t\t\tchild.Failures = append(child.Failures, resultstore.Failure{\n\t\t\t\tMessage: fmt.Sprintf(\"%d tests failed\", suite.Failures),\n\t\t\t})\n\t\t}\n\t\tfor _, result := range suite.Results {\n\t\t\tname, tags := stripTags(result.Name)\n\t\t\tclass := result.ClassName\n\t\t\tif class == \"\" {\n\t\t\t\tclass = strings.Join(tags, \" \")\n\t\t\t} else {\n\t\t\t\tclass += \" \" + strings.Join(tags, \" \")\n\t\t\t}\n\t\t\tc := resultstore.Case{\n\t\t\t\tName:     name,\n\t\t\t\tClass:    class,\n\t\t\t\tDuration: dur(result.Time),\n\t\t\t\tResult:   resultstore.Completed,\n\t\t\t}\n\t\t\tconst max = 5000 // truncate messages to this length\n\t\t\tmsg := result.Message(max)\n\t\t\tswitch {\n\t\t\tcase result.Failure != nil:\n\t\t\t\t// failing tests have a completed result with an error\n\t\t\t\tif msg == \"\" {\n\t\t\t\t\tmsg = \"unknown failure\"\n\t\t\t\t}\n\t\t\t\tc.Failures = append(c.Failures, resultstore.Failure{\n\t\t\t\t\tMessage: msg,\n\t\t\t\t})\n\t\t\tcase result.Skipped != nil:\n\t\t\t\tc.Result = resultstore.Skipped\n\t\t\t\tif msg != \"\" { // skipped results do not require an error, but may.\n\t\t\t\t\tc.Errors = append(c.Errors, resultstore.Error{\n\t\t\t\t\t\tMessage: msg,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tchild.Cases = append(child.Cases, c)\n\t\t\tif c.Duration > child.Duration {\n\t\t\t\tchild.Duration = c.Duration\n\t\t\t}\n\t\t}\n\t\tif child.Duration > out.Duration {\n\t\t\t// Assume suites run in parallel, so choose max\n\t\t\tout.Duration = child.Duration\n\t\t}\n\t\tout.Suites = append(out.Suites, child)\n\t}\n\treturn out\n}", "language": "go", "code": "func convertSuiteMeta(suiteMeta gcs.SuitesMeta) resultstore.Suite {\n\tout := resultstore.Suite{\n\t\tName: path.Base(suiteMeta.Path),\n\t\tFiles: []resultstore.File{\n\t\t\t{\n\t\t\t\tContentType: \"text/xml\",\n\t\t\t\tID:          resultstore.UUID(),\n\t\t\t\tURL:         suiteMeta.Path, // ensure the junit.xml file appears in artifacts list\n\t\t\t},\n\t\t},\n\t}\n\tfor _, suite := range suiteMeta.Suites.Suites {\n\t\tchild := resultstore.Suite{\n\t\t\tName:     suite.Name,\n\t\t\tDuration: dur(suite.Time),\n\t\t}\n\t\tswitch {\n\t\tcase suite.Failures > 0 && suite.Tests >= suite.Failures:\n\t\t\tchild.Failures = append(child.Failures, resultstore.Failure{\n\t\t\t\tMessage: fmt.Sprintf(\"%d out of %d tests failed (%.1f%% passing)\", suite.Failures, suite.Tests, float64(suite.Tests-suite.Failures)*100.0/float64(suite.Tests)),\n\t\t\t})\n\t\tcase suite.Failures > 0:\n\t\t\tchild.Failures = append(child.Failures, resultstore.Failure{\n\t\t\t\tMessage: fmt.Sprintf(\"%d tests failed\", suite.Failures),\n\t\t\t})\n\t\t}\n\t\tfor _, result := range suite.Results {\n\t\t\tname, tags := stripTags(result.Name)\n\t\t\tclass := result.ClassName\n\t\t\tif class == \"\" {\n\t\t\t\tclass = strings.Join(tags, \" \")\n\t\t\t} else {\n\t\t\t\tclass += \" \" + strings.Join(tags, \" \")\n\t\t\t}\n\t\t\tc := resultstore.Case{\n\t\t\t\tName:     name,\n\t\t\t\tClass:    class,\n\t\t\t\tDuration: dur(result.Time),\n\t\t\t\tResult:   resultstore.Completed,\n\t\t\t}\n\t\t\tconst max = 5000 // truncate messages to this length\n\t\t\tmsg := result.Message(max)\n\t\t\tswitch {\n\t\t\tcase result.Failure != nil:\n\t\t\t\t// failing tests have a completed result with an error\n\t\t\t\tif msg == \"\" {\n\t\t\t\t\tmsg = \"unknown failure\"\n\t\t\t\t}\n\t\t\t\tc.Failures = append(c.Failures, resultstore.Failure{\n\t\t\t\t\tMessage: msg,\n\t\t\t\t})\n\t\t\tcase result.Skipped != nil:\n\t\t\t\tc.Result = resultstore.Skipped\n\t\t\t\tif msg != \"\" { // skipped results do not require an error, but may.\n\t\t\t\t\tc.Errors = append(c.Errors, resultstore.Error{\n\t\t\t\t\t\tMessage: msg,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tchild.Cases = append(child.Cases, c)\n\t\t\tif c.Duration > child.Duration {\n\t\t\t\tchild.Duration = c.Duration\n\t\t\t}\n\t\t}\n\t\tif child.Duration > out.Duration {\n\t\t\t// Assume suites run in parallel, so choose max\n\t\t\tout.Duration = child.Duration\n\t\t}\n\t\tout.Suites = append(out.Suites, child)\n\t}\n\treturn out\n}", "code_tokens": ["func", "convertSuiteMeta", "(", "suiteMeta", "gcs", ".", "SuitesMeta", ")", "resultstore", ".", "Suite", "{", "out", ":=", "resultstore", ".", "Suite", "{", "Name", ":", "path", ".", "Base", "(", "suiteMeta", ".", "Path", ")", ",", "Files", ":", "[", "]", "resultstore", ".", "File", "{", "{", "ContentType", ":", "\"", "\"", ",", "ID", ":", "resultstore", ".", "UUID", "(", ")", ",", "URL", ":", "suiteMeta", ".", "Path", ",", "// ensure the junit.xml file appears in artifacts list", "}", ",", "}", ",", "}", "\n", "for", "_", ",", "suite", ":=", "range", "suiteMeta", ".", "Suites", ".", "Suites", "{", "child", ":=", "resultstore", ".", "Suite", "{", "Name", ":", "suite", ".", "Name", ",", "Duration", ":", "dur", "(", "suite", ".", "Time", ")", ",", "}", "\n", "switch", "{", "case", "suite", ".", "Failures", ">", "0", "&&", "suite", ".", "Tests", ">=", "suite", ".", "Failures", ":", "child", ".", "Failures", "=", "append", "(", "child", ".", "Failures", ",", "resultstore", ".", "Failure", "{", "Message", ":", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "suite", ".", "Failures", ",", "suite", ".", "Tests", ",", "float64", "(", "suite", ".", "Tests", "-", "suite", ".", "Failures", ")", "*", "100.0", "/", "float64", "(", "suite", ".", "Tests", ")", ")", ",", "}", ")", "\n", "case", "suite", ".", "Failures", ">", "0", ":", "child", ".", "Failures", "=", "append", "(", "child", ".", "Failures", ",", "resultstore", ".", "Failure", "{", "Message", ":", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "suite", ".", "Failures", ")", ",", "}", ")", "\n", "}", "\n", "for", "_", ",", "result", ":=", "range", "suite", ".", "Results", "{", "name", ",", "tags", ":=", "stripTags", "(", "result", ".", "Name", ")", "\n", "class", ":=", "result", ".", "ClassName", "\n", "if", "class", "==", "\"", "\"", "{", "class", "=", "strings", ".", "Join", "(", "tags", ",", "\"", "\"", ")", "\n", "}", "else", "{", "class", "+=", "\"", "\"", "+", "strings", ".", "Join", "(", "tags", ",", "\"", "\"", ")", "\n", "}", "\n", "c", ":=", "resultstore", ".", "Case", "{", "Name", ":", "name", ",", "Class", ":", "class", ",", "Duration", ":", "dur", "(", "result", ".", "Time", ")", ",", "Result", ":", "resultstore", ".", "Completed", ",", "}", "\n", "const", "max", "=", "5000", "// truncate messages to this length", "\n", "msg", ":=", "result", ".", "Message", "(", "max", ")", "\n", "switch", "{", "case", "result", ".", "Failure", "!=", "nil", ":", "// failing tests have a completed result with an error", "if", "msg", "==", "\"", "\"", "{", "msg", "=", "\"", "\"", "\n", "}", "\n", "c", ".", "Failures", "=", "append", "(", "c", ".", "Failures", ",", "resultstore", ".", "Failure", "{", "Message", ":", "msg", ",", "}", ")", "\n", "case", "result", ".", "Skipped", "!=", "nil", ":", "c", ".", "Result", "=", "resultstore", ".", "Skipped", "\n", "if", "msg", "!=", "\"", "\"", "{", "// skipped results do not require an error, but may.", "c", ".", "Errors", "=", "append", "(", "c", ".", "Errors", ",", "resultstore", ".", "Error", "{", "Message", ":", "msg", ",", "}", ")", "\n", "}", "\n", "}", "\n", "child", ".", "Cases", "=", "append", "(", "child", ".", "Cases", ",", "c", ")", "\n", "if", "c", ".", "Duration", ">", "child", ".", "Duration", "{", "child", ".", "Duration", "=", "c", ".", "Duration", "\n", "}", "\n", "}", "\n", "if", "child", ".", "Duration", ">", "out", ".", "Duration", "{", "// Assume suites run in parallel, so choose max", "out", ".", "Duration", "=", "child", ".", "Duration", "\n", "}", "\n", "out", ".", "Suites", "=", "append", "(", "out", ".", "Suites", ",", "child", ")", "\n", "}", "\n", "return", "out", "\n", "}"], "docstring": "// convertSuiteMeta converts a junit result in gcs to a ResultStore Suite.", "docstring_tokens": ["convertSuiteMeta", "converts", "a", "junit", "result", "in", "gcs", "to", "a", "ResultStore", "Suite", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/experiment/resultstore/convert.go#L34-L105", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_server.go", "func_name": "UpdateServer", "original_string": "func (r *ProtocolLXD) UpdateServer(server api.ServerPut, ETag string) error {\n\t// Send the request\n\t_, _, err := r.query(\"PUT\", \"\", server, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (r *ProtocolLXD) UpdateServer(server api.ServerPut, ETag string) error {\n\t// Send the request\n\t_, _, err := r.query(\"PUT\", \"\", server, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "UpdateServer", "(", "server", "api", ".", "ServerPut", ",", "ETag", "string", ")", "error", "{", "// Send the request", "_", ",", "_", ",", "err", ":=", "r", ".", "query", "(", "\"", "\"", ",", "\"", "\"", ",", "server", ",", "ETag", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// UpdateServer updates the server status to match the provided Server struct", "docstring_tokens": ["UpdateServer", "updates", "the", "server", "status", "to", "match", "the", "provided", "Server", "struct"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_server.go#L43-L51", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/storage_btrfs.go", "func_name": "StoragePoolVolumeCreate", "original_string": "func (s *storageBtrfs) StoragePoolVolumeCreate() error {\n\tlogger.Infof(\"Creating BTRFS storage volume \\\"%s\\\" on storage pool \\\"%s\\\"\", s.volume.Name, s.pool.Name)\n\n\t_, err := s.StoragePoolMount()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tisSnapshot := shared.IsSnapshot(s.volume.Name)\n\n\t// Create subvolume path on the storage pool.\n\tvar customSubvolumePath string\n\n\tif isSnapshot {\n\t\tcustomSubvolumePath = s.getCustomSnapshotSubvolumePath(s.pool.Name)\n\t} else {\n\t\tcustomSubvolumePath = s.getCustomSubvolumePath(s.pool.Name)\n\t}\n\n\tif !shared.PathExists(customSubvolumePath) {\n\t\terr := os.MkdirAll(customSubvolumePath, 0700)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Create subvolume.\n\tvar customSubvolumeName string\n\n\tif isSnapshot {\n\t\tcustomSubvolumeName = getStoragePoolVolumeSnapshotMountPoint(s.pool.Name, s.volume.Name)\n\t} else {\n\t\tcustomSubvolumeName = getStoragePoolVolumeMountPoint(s.pool.Name, s.volume.Name)\n\t}\n\n\terr = btrfsSubVolumeCreate(customSubvolumeName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// apply quota\n\tif s.volume.Config[\"size\"] != \"\" {\n\t\tsize, err := shared.ParseByteSizeString(s.volume.Config[\"size\"])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = s.StorageEntitySetQuota(storagePoolVolumeTypeCustom, size, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogger.Infof(\"Created BTRFS storage volume \\\"%s\\\" on storage pool \\\"%s\\\"\", s.volume.Name, s.pool.Name)\n\treturn nil\n}", "language": "go", "code": "func (s *storageBtrfs) StoragePoolVolumeCreate() error {\n\tlogger.Infof(\"Creating BTRFS storage volume \\\"%s\\\" on storage pool \\\"%s\\\"\", s.volume.Name, s.pool.Name)\n\n\t_, err := s.StoragePoolMount()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tisSnapshot := shared.IsSnapshot(s.volume.Name)\n\n\t// Create subvolume path on the storage pool.\n\tvar customSubvolumePath string\n\n\tif isSnapshot {\n\t\tcustomSubvolumePath = s.getCustomSnapshotSubvolumePath(s.pool.Name)\n\t} else {\n\t\tcustomSubvolumePath = s.getCustomSubvolumePath(s.pool.Name)\n\t}\n\n\tif !shared.PathExists(customSubvolumePath) {\n\t\terr := os.MkdirAll(customSubvolumePath, 0700)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Create subvolume.\n\tvar customSubvolumeName string\n\n\tif isSnapshot {\n\t\tcustomSubvolumeName = getStoragePoolVolumeSnapshotMountPoint(s.pool.Name, s.volume.Name)\n\t} else {\n\t\tcustomSubvolumeName = getStoragePoolVolumeMountPoint(s.pool.Name, s.volume.Name)\n\t}\n\n\terr = btrfsSubVolumeCreate(customSubvolumeName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// apply quota\n\tif s.volume.Config[\"size\"] != \"\" {\n\t\tsize, err := shared.ParseByteSizeString(s.volume.Config[\"size\"])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = s.StorageEntitySetQuota(storagePoolVolumeTypeCustom, size, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogger.Infof(\"Created BTRFS storage volume \\\"%s\\\" on storage pool \\\"%s\\\"\", s.volume.Name, s.pool.Name)\n\treturn nil\n}", "code_tokens": ["func", "(", "s", "*", "storageBtrfs", ")", "StoragePoolVolumeCreate", "(", ")", "error", "{", "logger", ".", "Infof", "(", "\"", "\\\"", "\\\"", "\\\"", "\\\"", "\"", ",", "s", ".", "volume", ".", "Name", ",", "s", ".", "pool", ".", "Name", ")", "\n\n", "_", ",", "err", ":=", "s", ".", "StoragePoolMount", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "isSnapshot", ":=", "shared", ".", "IsSnapshot", "(", "s", ".", "volume", ".", "Name", ")", "\n\n", "// Create subvolume path on the storage pool.", "var", "customSubvolumePath", "string", "\n\n", "if", "isSnapshot", "{", "customSubvolumePath", "=", "s", ".", "getCustomSnapshotSubvolumePath", "(", "s", ".", "pool", ".", "Name", ")", "\n", "}", "else", "{", "customSubvolumePath", "=", "s", ".", "getCustomSubvolumePath", "(", "s", ".", "pool", ".", "Name", ")", "\n", "}", "\n\n", "if", "!", "shared", ".", "PathExists", "(", "customSubvolumePath", ")", "{", "err", ":=", "os", ".", "MkdirAll", "(", "customSubvolumePath", ",", "0700", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n\n", "// Create subvolume.", "var", "customSubvolumeName", "string", "\n\n", "if", "isSnapshot", "{", "customSubvolumeName", "=", "getStoragePoolVolumeSnapshotMountPoint", "(", "s", ".", "pool", ".", "Name", ",", "s", ".", "volume", ".", "Name", ")", "\n", "}", "else", "{", "customSubvolumeName", "=", "getStoragePoolVolumeMountPoint", "(", "s", ".", "pool", ".", "Name", ",", "s", ".", "volume", ".", "Name", ")", "\n", "}", "\n\n", "err", "=", "btrfsSubVolumeCreate", "(", "customSubvolumeName", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "// apply quota", "if", "s", ".", "volume", ".", "Config", "[", "\"", "\"", "]", "!=", "\"", "\"", "{", "size", ",", "err", ":=", "shared", ".", "ParseByteSizeString", "(", "s", ".", "volume", ".", "Config", "[", "\"", "\"", "]", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "err", "=", "s", ".", "StorageEntitySetQuota", "(", "storagePoolVolumeTypeCustom", ",", "size", ",", "nil", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n\n", "logger", ".", "Infof", "(", "\"", "\\\"", "\\\"", "\\\"", "\\\"", "\"", ",", "s", ".", "volume", ".", "Name", ",", "s", ".", "pool", ".", "Name", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// Functions dealing with storage volumes.", "docstring_tokens": ["Functions", "dealing", "with", "storage", "volumes", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/storage_btrfs.go#L552-L607", "partition": "test"}
{"repo": "op/go-logging", "path": "level.go", "func_name": "GetLevel", "original_string": "func (l *moduleLeveled) GetLevel(module string) Level {\n\tlevel, exists := l.levels[module]\n\tif exists == false {\n\t\tlevel, exists = l.levels[\"\"]\n\t\t// no configuration exists, default to debug\n\t\tif exists == false {\n\t\t\tlevel = DEBUG\n\t\t}\n\t}\n\treturn level\n}", "language": "go", "code": "func (l *moduleLeveled) GetLevel(module string) Level {\n\tlevel, exists := l.levels[module]\n\tif exists == false {\n\t\tlevel, exists = l.levels[\"\"]\n\t\t// no configuration exists, default to debug\n\t\tif exists == false {\n\t\t\tlevel = DEBUG\n\t\t}\n\t}\n\treturn level\n}", "code_tokens": ["func", "(", "l", "*", "moduleLeveled", ")", "GetLevel", "(", "module", "string", ")", "Level", "{", "level", ",", "exists", ":=", "l", ".", "levels", "[", "module", "]", "\n", "if", "exists", "==", "false", "{", "level", ",", "exists", "=", "l", ".", "levels", "[", "\"", "\"", "]", "\n", "// no configuration exists, default to debug", "if", "exists", "==", "false", "{", "level", "=", "DEBUG", "\n", "}", "\n", "}", "\n", "return", "level", "\n", "}"], "docstring": "// GetLevel returns the log level for the given module.", "docstring_tokens": ["GetLevel", "returns", "the", "log", "level", "for", "the", "given", "module", "."], "sha": "970db520ece77730c7e4724c61121037378659d9", "url": "https://github.com/op/go-logging/blob/970db520ece77730c7e4724c61121037378659d9/level.go#L90-L100", "partition": "test"}
{"repo": "xwb1989/sqlparser", "path": "dependency/sqltypes/bind_variables.go", "func_name": "BindVariablesEqual", "original_string": "func BindVariablesEqual(x, y map[string]*querypb.BindVariable) bool {\n\treturn reflect.DeepEqual(&querypb.BoundQuery{BindVariables: x}, &querypb.BoundQuery{BindVariables: y})\n}", "language": "go", "code": "func BindVariablesEqual(x, y map[string]*querypb.BindVariable) bool {\n\treturn reflect.DeepEqual(&querypb.BoundQuery{BindVariables: x}, &querypb.BoundQuery{BindVariables: y})\n}", "code_tokens": ["func", "BindVariablesEqual", "(", "x", ",", "y", "map", "[", "string", "]", "*", "querypb", ".", "BindVariable", ")", "bool", "{", "return", "reflect", ".", "DeepEqual", "(", "&", "querypb", ".", "BoundQuery", "{", "BindVariables", ":", "x", "}", ",", "&", "querypb", ".", "BoundQuery", "{", "BindVariables", ":", "y", "}", ")", "\n", "}"], "docstring": "// BindVariablesEqual compares two maps of bind variables.", "docstring_tokens": ["BindVariablesEqual", "compares", "two", "maps", "of", "bind", "variables", "."], "sha": "120387863bf27d04bc07db8015110a6e96d0146c", "url": "https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/dependency/sqltypes/bind_variables.go#L255-L257", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "grpc/ttnctx/context.go", "func_name": "LimitFromMetadata", "original_string": "func LimitFromMetadata(md metadata.MD) (uint64, error) {\n\tlimit, ok := md[\"limit\"]\n\tif !ok || len(limit) == 0 {\n\t\treturn 0, nil\n\t}\n\treturn strconv.ParseUint(limit[0], 10, 64)\n}", "language": "go", "code": "func LimitFromMetadata(md metadata.MD) (uint64, error) {\n\tlimit, ok := md[\"limit\"]\n\tif !ok || len(limit) == 0 {\n\t\treturn 0, nil\n\t}\n\treturn strconv.ParseUint(limit[0], 10, 64)\n}", "code_tokens": ["func", "LimitFromMetadata", "(", "md", "metadata", ".", "MD", ")", "(", "uint64", ",", "error", ")", "{", "limit", ",", "ok", ":=", "md", "[", "\"", "\"", "]", "\n", "if", "!", "ok", "||", "len", "(", "limit", ")", "==", "0", "{", "return", "0", ",", "nil", "\n", "}", "\n", "return", "strconv", ".", "ParseUint", "(", "limit", "[", "0", "]", ",", "10", ",", "64", ")", "\n", "}"], "docstring": "// LimitFromMetadata gets the limit from the metadata", "docstring_tokens": ["LimitFromMetadata", "gets", "the", "limit", "from", "the", "metadata"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/grpc/ttnctx/context.go#L121-L127", "partition": "test"}
{"repo": "ccding/go-config-reader", "path": "config/config.go", "func_name": "WriteTo", "original_string": "func (c *Config) WriteTo(filename string) error {\n\tcontent := \"\"\n\tfor k, v := range c.config {\n\t\tformat := \"%v = %v\\n\"\n\t\tif k != \"\" {\n\t\t\tcontent += fmt.Sprintf(\"[%v]\\n\", k)\n\t\t\tformat = \"\\t\" + format\n\t\t}\n\t\tfor key, value := range v {\n\t\t\tcontent += fmt.Sprintf(format, key, value)\n\t\t}\n\t}\n\treturn ioutil.WriteFile(filename, []byte(content), 0644)\n}", "language": "go", "code": "func (c *Config) WriteTo(filename string) error {\n\tcontent := \"\"\n\tfor k, v := range c.config {\n\t\tformat := \"%v = %v\\n\"\n\t\tif k != \"\" {\n\t\t\tcontent += fmt.Sprintf(\"[%v]\\n\", k)\n\t\t\tformat = \"\\t\" + format\n\t\t}\n\t\tfor key, value := range v {\n\t\t\tcontent += fmt.Sprintf(format, key, value)\n\t\t}\n\t}\n\treturn ioutil.WriteFile(filename, []byte(content), 0644)\n}", "code_tokens": ["func", "(", "c", "*", "Config", ")", "WriteTo", "(", "filename", "string", ")", "error", "{", "content", ":=", "\"", "\"", "\n", "for", "k", ",", "v", ":=", "range", "c", ".", "config", "{", "format", ":=", "\"", "\\n", "\"", "\n", "if", "k", "!=", "\"", "\"", "{", "content", "+=", "fmt", ".", "Sprintf", "(", "\"", "\\n", "\"", ",", "k", ")", "\n", "format", "=", "\"", "\\t", "\"", "+", "format", "\n", "}", "\n", "for", "key", ",", "value", ":=", "range", "v", "{", "content", "+=", "fmt", ".", "Sprintf", "(", "format", ",", "key", ",", "value", ")", "\n", "}", "\n", "}", "\n", "return", "ioutil", ".", "WriteFile", "(", "filename", ",", "[", "]", "byte", "(", "content", ")", ",", "0644", ")", "\n", "}"], "docstring": "// WriteTo function writes the configuration to a new file. This function\n// re-organizes the configuration and deletes all the comments.", "docstring_tokens": ["WriteTo", "function", "writes", "the", "configuration", "to", "a", "new", "file", ".", "This", "function", "re", "-", "organizes", "the", "configuration", "and", "deletes", "all", "the", "comments", "."], "sha": "8b6c2b50197f20da3b1c5944c274c173634dc056", "url": "https://github.com/ccding/go-config-reader/blob/8b6c2b50197f20da3b1c5944c274c173634dc056/config/config.go#L148-L161", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "gcsweb/cmd/gcsweb/gcsweb.go", "func_name": "Render", "original_string": "func (pfx *Prefix) Render(out http.ResponseWriter, inPath string) {\n\turl := gcsPath + inPath + pfx.Prefix\n\thtmlGridItem(out, iconDir, url, pfx.Prefix, \"-\", \"-\")\n}", "language": "go", "code": "func (pfx *Prefix) Render(out http.ResponseWriter, inPath string) {\n\turl := gcsPath + inPath + pfx.Prefix\n\thtmlGridItem(out, iconDir, url, pfx.Prefix, \"-\", \"-\")\n}", "code_tokens": ["func", "(", "pfx", "*", "Prefix", ")", "Render", "(", "out", "http", ".", "ResponseWriter", ",", "inPath", "string", ")", "{", "url", ":=", "gcsPath", "+", "inPath", "+", "pfx", ".", "Prefix", "\n", "htmlGridItem", "(", "out", ",", "iconDir", ",", "url", ",", "pfx", ".", "Prefix", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "}"], "docstring": "// Render writes HTML representing this Prefix to the provided output.", "docstring_tokens": ["Render", "writes", "HTML", "representing", "this", "Prefix", "to", "the", "provided", "output", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/gcsweb/cmd/gcsweb/gcsweb.go#L566-L569", "partition": "test"}
{"repo": "sayanarijit/gopassgen", "path": "gopassgen.go", "func_name": "Shuffle", "original_string": "func Shuffle(bs []byte) {\n\tn := len(bs)\n\tfor i := n - 1; i > 0; i-- {\n\t\trand.Seed(time.Now().UnixNano())\n\t\tj := rand.Intn(i + 1)\n\t\tbs[i], bs[j] = bs[j], bs[i]\n\t}\n}", "language": "go", "code": "func Shuffle(bs []byte) {\n\tn := len(bs)\n\tfor i := n - 1; i > 0; i-- {\n\t\trand.Seed(time.Now().UnixNano())\n\t\tj := rand.Intn(i + 1)\n\t\tbs[i], bs[j] = bs[j], bs[i]\n\t}\n}", "code_tokens": ["func", "Shuffle", "(", "bs", "[", "]", "byte", ")", "{", "n", ":=", "len", "(", "bs", ")", "\n", "for", "i", ":=", "n", "-", "1", ";", "i", ">", "0", ";", "i", "--", "{", "rand", ".", "Seed", "(", "time", ".", "Now", "(", ")", ".", "UnixNano", "(", ")", ")", "\n", "j", ":=", "rand", ".", "Intn", "(", "i", "+", "1", ")", "\n", "bs", "[", "i", "]", ",", "bs", "[", "j", "]", "=", "bs", "[", "j", "]", ",", "bs", "[", "i", "]", "\n", "}", "\n", "}"], "docstring": "// Shuffle the given byte string", "docstring_tokens": ["Shuffle", "the", "given", "byte", "string"], "sha": "cf555de90ad6031f567a55be7d7c90f2fbe8389a", "url": "https://github.com/sayanarijit/gopassgen/blob/cf555de90ad6031f567a55be7d7c90f2fbe8389a/gopassgen.go#L87-L94", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/worker/api_server.go", "func_name": "HashDatum15", "original_string": "func HashDatum15(pipelineInfo *pps.PipelineInfo, data []*Input) (string, error) {\n\thash := sha256.New()\n\tfor _, datum := range data {\n\t\thash.Write([]byte(datum.Name))\n\t\thash.Write([]byte(datum.FileInfo.File.Path))\n\t\thash.Write(datum.FileInfo.Hash)\n\t}\n\n\t// We set env to nil because if env contains more than one elements,\n\t// since it's a map, the output of Marshal() can be non-deterministic.\n\tenv := pipelineInfo.Transform.Env\n\tpipelineInfo.Transform.Env = nil\n\tdefer func() {\n\t\tpipelineInfo.Transform.Env = env\n\t}()\n\tbytes, err := pipelineInfo.Transform.Marshal()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\thash.Write(bytes)\n\thash.Write([]byte(pipelineInfo.Pipeline.Name))\n\thash.Write([]byte(pipelineInfo.ID))\n\thash.Write([]byte(strconv.Itoa(int(pipelineInfo.Version))))\n\n\t// Note in 1.5.0 this function was called HashPipelineID, it's now called\n\t// HashPipelineName but it has the same implementation.\n\treturn client.DatumTagPrefix(pipelineInfo.ID) + hex.EncodeToString(hash.Sum(nil)), nil\n}", "language": "go", "code": "func HashDatum15(pipelineInfo *pps.PipelineInfo, data []*Input) (string, error) {\n\thash := sha256.New()\n\tfor _, datum := range data {\n\t\thash.Write([]byte(datum.Name))\n\t\thash.Write([]byte(datum.FileInfo.File.Path))\n\t\thash.Write(datum.FileInfo.Hash)\n\t}\n\n\t// We set env to nil because if env contains more than one elements,\n\t// since it's a map, the output of Marshal() can be non-deterministic.\n\tenv := pipelineInfo.Transform.Env\n\tpipelineInfo.Transform.Env = nil\n\tdefer func() {\n\t\tpipelineInfo.Transform.Env = env\n\t}()\n\tbytes, err := pipelineInfo.Transform.Marshal()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\thash.Write(bytes)\n\thash.Write([]byte(pipelineInfo.Pipeline.Name))\n\thash.Write([]byte(pipelineInfo.ID))\n\thash.Write([]byte(strconv.Itoa(int(pipelineInfo.Version))))\n\n\t// Note in 1.5.0 this function was called HashPipelineID, it's now called\n\t// HashPipelineName but it has the same implementation.\n\treturn client.DatumTagPrefix(pipelineInfo.ID) + hex.EncodeToString(hash.Sum(nil)), nil\n}", "code_tokens": ["func", "HashDatum15", "(", "pipelineInfo", "*", "pps", ".", "PipelineInfo", ",", "data", "[", "]", "*", "Input", ")", "(", "string", ",", "error", ")", "{", "hash", ":=", "sha256", ".", "New", "(", ")", "\n", "for", "_", ",", "datum", ":=", "range", "data", "{", "hash", ".", "Write", "(", "[", "]", "byte", "(", "datum", ".", "Name", ")", ")", "\n", "hash", ".", "Write", "(", "[", "]", "byte", "(", "datum", ".", "FileInfo", ".", "File", ".", "Path", ")", ")", "\n", "hash", ".", "Write", "(", "datum", ".", "FileInfo", ".", "Hash", ")", "\n", "}", "\n\n", "// We set env to nil because if env contains more than one elements,", "// since it's a map, the output of Marshal() can be non-deterministic.", "env", ":=", "pipelineInfo", ".", "Transform", ".", "Env", "\n", "pipelineInfo", ".", "Transform", ".", "Env", "=", "nil", "\n", "defer", "func", "(", ")", "{", "pipelineInfo", ".", "Transform", ".", "Env", "=", "env", "\n", "}", "(", ")", "\n", "bytes", ",", "err", ":=", "pipelineInfo", ".", "Transform", ".", "Marshal", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n", "hash", ".", "Write", "(", "bytes", ")", "\n", "hash", ".", "Write", "(", "[", "]", "byte", "(", "pipelineInfo", ".", "Pipeline", ".", "Name", ")", ")", "\n", "hash", ".", "Write", "(", "[", "]", "byte", "(", "pipelineInfo", ".", "ID", ")", ")", "\n", "hash", ".", "Write", "(", "[", "]", "byte", "(", "strconv", ".", "Itoa", "(", "int", "(", "pipelineInfo", ".", "Version", ")", ")", ")", ")", "\n\n", "// Note in 1.5.0 this function was called HashPipelineID, it's now called", "// HashPipelineName but it has the same implementation.", "return", "client", ".", "DatumTagPrefix", "(", "pipelineInfo", ".", "ID", ")", "+", "hex", ".", "EncodeToString", "(", "hash", ".", "Sum", "(", "nil", ")", ")", ",", "nil", "\n", "}"], "docstring": "// HashDatum15 computes and returns the hash of datum + pipeline for version <= 1.5.0, with a\n// pipeline-specific prefix.", "docstring_tokens": ["HashDatum15", "computes", "and", "returns", "the", "hash", "of", "datum", "+", "pipeline", "for", "version", "<", "=", "1", ".", "5", ".", "0", "with", "a", "pipeline", "-", "specific", "prefix", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/worker/api_server.go#L1019-L1046", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "y/watermark.go", "func_name": "SetDoneUntil", "original_string": "func (w *WaterMark) SetDoneUntil(val uint64) {\n\tatomic.StoreUint64(&w.doneUntil, val)\n}", "language": "go", "code": "func (w *WaterMark) SetDoneUntil(val uint64) {\n\tatomic.StoreUint64(&w.doneUntil, val)\n}", "code_tokens": ["func", "(", "w", "*", "WaterMark", ")", "SetDoneUntil", "(", "val", "uint64", ")", "{", "atomic", ".", "StoreUint64", "(", "&", "w", ".", "doneUntil", ",", "val", ")", "\n", "}"], "docstring": "// SetDoneUntil sets the maximum index that has the property that all indices\n// less than or equal to it are done.", "docstring_tokens": ["SetDoneUntil", "sets", "the", "maximum", "index", "that", "has", "the", "property", "that", "all", "indices", "less", "than", "or", "equal", "to", "it", "are", "done", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/y/watermark.go#L107-L109", "partition": "test"}
{"repo": "pact-foundation/pact-go", "path": "dsl/pact.go", "func_name": "AddInteraction", "original_string": "func (p *Pact) AddInteraction() *Interaction {\n\tp.Setup(true)\n\tlog.Println(\"[DEBUG] pact add interaction\")\n\ti := &Interaction{}\n\tp.Interactions = append(p.Interactions, i)\n\treturn i\n}", "language": "go", "code": "func (p *Pact) AddInteraction() *Interaction {\n\tp.Setup(true)\n\tlog.Println(\"[DEBUG] pact add interaction\")\n\ti := &Interaction{}\n\tp.Interactions = append(p.Interactions, i)\n\treturn i\n}", "code_tokens": ["func", "(", "p", "*", "Pact", ")", "AddInteraction", "(", ")", "*", "Interaction", "{", "p", ".", "Setup", "(", "true", ")", "\n", "log", ".", "Println", "(", "\"", "\"", ")", "\n", "i", ":=", "&", "Interaction", "{", "}", "\n", "p", ".", "Interactions", "=", "append", "(", "p", ".", "Interactions", ",", "i", ")", "\n", "return", "i", "\n", "}"], "docstring": "// AddInteraction creates a new Pact interaction, initialising all\n// required things. Will automatically start a Mock Service if none running.", "docstring_tokens": ["AddInteraction", "creates", "a", "new", "Pact", "interaction", "initialising", "all", "required", "things", ".", "Will", "automatically", "start", "a", "Mock", "Service", "if", "none", "running", "."], "sha": "467dea56d27e154363e1975f6e9f4dbf66148e79", "url": "https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/dsl/pact.go#L114-L120", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "typed/buffer.go", "func_name": "WriteUint16", "original_string": "func (w *WriteBuffer) WriteUint16(n uint16) {\n\tif b := w.reserve(2); b != nil {\n\t\tbinary.BigEndian.PutUint16(b, n)\n\t}\n}", "language": "go", "code": "func (w *WriteBuffer) WriteUint16(n uint16) {\n\tif b := w.reserve(2); b != nil {\n\t\tbinary.BigEndian.PutUint16(b, n)\n\t}\n}", "code_tokens": ["func", "(", "w", "*", "WriteBuffer", ")", "WriteUint16", "(", "n", "uint16", ")", "{", "if", "b", ":=", "w", ".", "reserve", "(", "2", ")", ";", "b", "!=", "nil", "{", "binary", ".", "BigEndian", ".", "PutUint16", "(", "b", ",", "n", ")", "\n", "}", "\n", "}"], "docstring": "// WriteUint16 writes a big endian encoded uint16 value to the buffer", "docstring_tokens": ["WriteUint16", "writes", "a", "big", "endian", "encoded", "uint16", "value", "to", "the", "buffer"], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/typed/buffer.go#L220-L224", "partition": "test"}
{"repo": "apuigsech/seekret", "path": "seekret.go", "func_name": "AddException", "original_string": "func (s *Seekret) AddException(exception models.Exception) {\n\ts.exceptionList = append(s.exceptionList, exception)\n}", "language": "go", "code": "func (s *Seekret) AddException(exception models.Exception) {\n\ts.exceptionList = append(s.exceptionList, exception)\n}", "code_tokens": ["func", "(", "s", "*", "Seekret", ")", "AddException", "(", "exception", "models", ".", "Exception", ")", "{", "s", ".", "exceptionList", "=", "append", "(", "s", ".", "exceptionList", ",", "exception", ")", "\n", "}"], "docstring": "// AddException adds a new exception into the context.", "docstring_tokens": ["AddException", "adds", "a", "new", "exception", "into", "the", "context", "."], "sha": "9b1f7ea1b3fd5bd29d93cf62102cb66e54428a49", "url": "https://github.com/apuigsech/seekret/blob/9b1f7ea1b3fd5bd29d93cf62102cb66e54428a49/seekret.go#L239-L241", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "relay.go", "func_name": "addRelayItem", "original_string": "func (r *Relayer) addRelayItem(isOriginator bool, id, remapID uint32, destination *Relayer, ttl time.Duration, span Span, call RelayCall) relayItem {\n\titem := relayItem{\n\t\tcall:        call,\n\t\tremapID:     remapID,\n\t\tdestination: destination,\n\t\tspan:        span,\n\t}\n\n\titems := r.inbound\n\tif isOriginator {\n\t\titems = r.outbound\n\t}\n\titem.timeout = r.timeouts.Get()\n\titems.Add(id, item)\n\titem.timeout.Start(ttl, items, id, isOriginator)\n\treturn item\n}", "language": "go", "code": "func (r *Relayer) addRelayItem(isOriginator bool, id, remapID uint32, destination *Relayer, ttl time.Duration, span Span, call RelayCall) relayItem {\n\titem := relayItem{\n\t\tcall:        call,\n\t\tremapID:     remapID,\n\t\tdestination: destination,\n\t\tspan:        span,\n\t}\n\n\titems := r.inbound\n\tif isOriginator {\n\t\titems = r.outbound\n\t}\n\titem.timeout = r.timeouts.Get()\n\titems.Add(id, item)\n\titem.timeout.Start(ttl, items, id, isOriginator)\n\treturn item\n}", "code_tokens": ["func", "(", "r", "*", "Relayer", ")", "addRelayItem", "(", "isOriginator", "bool", ",", "id", ",", "remapID", "uint32", ",", "destination", "*", "Relayer", ",", "ttl", "time", ".", "Duration", ",", "span", "Span", ",", "call", "RelayCall", ")", "relayItem", "{", "item", ":=", "relayItem", "{", "call", ":", "call", ",", "remapID", ":", "remapID", ",", "destination", ":", "destination", ",", "span", ":", "span", ",", "}", "\n\n", "items", ":=", "r", ".", "inbound", "\n", "if", "isOriginator", "{", "items", "=", "r", ".", "outbound", "\n", "}", "\n", "item", ".", "timeout", "=", "r", ".", "timeouts", ".", "Get", "(", ")", "\n", "items", ".", "Add", "(", "id", ",", "item", ")", "\n", "item", ".", "timeout", ".", "Start", "(", "ttl", ",", "items", ",", "id", ",", "isOriginator", ")", "\n", "return", "item", "\n", "}"], "docstring": "// addRelayItem adds a relay item to either outbound or inbound.", "docstring_tokens": ["addRelayItem", "adds", "a", "relay", "item", "to", "either", "outbound", "or", "inbound", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/relay.go#L476-L492", "partition": "test"}
{"repo": "mailgun/iptools", "path": "ip.go", "func_name": "GetHostIPs", "original_string": "func GetHostIPs() ([]net.IP, error) {\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar ips []net.IP\n\tfor _, iface := range ifaces {\n\t\tif strings.HasPrefix(iface.Name, \"docker\") {\n\t\t\tcontinue\n\t\t}\n\t\taddrs, err := iface.Addrs()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tif ipnet, ok := addr.(*net.IPNet); ok {\n\t\t\t\tips = append(ips, ipnet.IP)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ips, nil\n}", "language": "go", "code": "func GetHostIPs() ([]net.IP, error) {\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar ips []net.IP\n\tfor _, iface := range ifaces {\n\t\tif strings.HasPrefix(iface.Name, \"docker\") {\n\t\t\tcontinue\n\t\t}\n\t\taddrs, err := iface.Addrs()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, addr := range addrs {\n\t\t\tif ipnet, ok := addr.(*net.IPNet); ok {\n\t\t\t\tips = append(ips, ipnet.IP)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ips, nil\n}", "code_tokens": ["func", "GetHostIPs", "(", ")", "(", "[", "]", "net", ".", "IP", ",", "error", ")", "{", "ifaces", ",", "err", ":=", "net", ".", "Interfaces", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "var", "ips", "[", "]", "net", ".", "IP", "\n", "for", "_", ",", "iface", ":=", "range", "ifaces", "{", "if", "strings", ".", "HasPrefix", "(", "iface", ".", "Name", ",", "\"", "\"", ")", "{", "continue", "\n", "}", "\n", "addrs", ",", "err", ":=", "iface", ".", "Addrs", "(", ")", "\n", "if", "err", "!=", "nil", "{", "continue", "\n", "}", "\n", "for", "_", ",", "addr", ":=", "range", "addrs", "{", "if", "ipnet", ",", "ok", ":=", "addr", ".", "(", "*", "net", ".", "IPNet", ")", ";", "ok", "{", "ips", "=", "append", "(", "ips", ",", "ipnet", ".", "IP", ")", "\n", "}", "\n", "}", "\n", "}", "\n\n", "return", "ips", ",", "nil", "\n", "}"], "docstring": "// GetHostIPs returns a list of IP addresses of all host's interfaces.", "docstring_tokens": ["GetHostIPs", "returns", "a", "list", "of", "IP", "addresses", "of", "all", "host", "s", "interfaces", "."], "sha": "ba8d5743f6788db9906c07c292a033f194849563", "url": "https://github.com/mailgun/iptools/blob/ba8d5743f6788db9906c07c292a033f194849563/ip.go#L32-L55", "partition": "test"}
{"repo": "piotrkowalczuk/mnemosyne", "path": "internal/storage/postgres/storage.go", "func_name": "Delete", "original_string": "func (s *Storage) Delete(ctx context.Context, subjectID, accessToken, refreshToken string, expiredAtFrom, expiredAtTo *time.Time) (int64, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"postgres.storage.delete\")\n\tdefer span.Finish()\n\n\twhere, args := s.where(subjectID, accessToken, refreshToken, expiredAtFrom, expiredAtTo)\n\tif where.Len() == 0 {\n\t\treturn 0, fmt.Errorf(\"session cannot be deleted, no where parameter provided: %s\", where.String())\n\t}\n\tquery := \"DELETE FROM \" + s.schema + \".\" + s.table + \" WHERE \" + where.String()\n\tlabels := prometheus.Labels{\"query\": \"delete\"}\n\tstart := time.Now()\n\n\tresult, err := s.db.Exec(query, args...)\n\ts.incQueries(labels, start)\n\tif err != nil {\n\t\ts.incError(labels)\n\t\treturn 0, err\n\t}\n\n\treturn result.RowsAffected()\n}", "language": "go", "code": "func (s *Storage) Delete(ctx context.Context, subjectID, accessToken, refreshToken string, expiredAtFrom, expiredAtTo *time.Time) (int64, error) {\n\tspan, ctx := opentracing.StartSpanFromContext(ctx, \"postgres.storage.delete\")\n\tdefer span.Finish()\n\n\twhere, args := s.where(subjectID, accessToken, refreshToken, expiredAtFrom, expiredAtTo)\n\tif where.Len() == 0 {\n\t\treturn 0, fmt.Errorf(\"session cannot be deleted, no where parameter provided: %s\", where.String())\n\t}\n\tquery := \"DELETE FROM \" + s.schema + \".\" + s.table + \" WHERE \" + where.String()\n\tlabels := prometheus.Labels{\"query\": \"delete\"}\n\tstart := time.Now()\n\n\tresult, err := s.db.Exec(query, args...)\n\ts.incQueries(labels, start)\n\tif err != nil {\n\t\ts.incError(labels)\n\t\treturn 0, err\n\t}\n\n\treturn result.RowsAffected()\n}", "code_tokens": ["func", "(", "s", "*", "Storage", ")", "Delete", "(", "ctx", "context", ".", "Context", ",", "subjectID", ",", "accessToken", ",", "refreshToken", "string", ",", "expiredAtFrom", ",", "expiredAtTo", "*", "time", ".", "Time", ")", "(", "int64", ",", "error", ")", "{", "span", ",", "ctx", ":=", "opentracing", ".", "StartSpanFromContext", "(", "ctx", ",", "\"", "\"", ")", "\n", "defer", "span", ".", "Finish", "(", ")", "\n\n", "where", ",", "args", ":=", "s", ".", "where", "(", "subjectID", ",", "accessToken", ",", "refreshToken", ",", "expiredAtFrom", ",", "expiredAtTo", ")", "\n", "if", "where", ".", "Len", "(", ")", "==", "0", "{", "return", "0", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "where", ".", "String", "(", ")", ")", "\n", "}", "\n", "query", ":=", "\"", "\"", "+", "s", ".", "schema", "+", "\"", "\"", "+", "s", ".", "table", "+", "\"", "\"", "+", "where", ".", "String", "(", ")", "\n", "labels", ":=", "prometheus", ".", "Labels", "{", "\"", "\"", ":", "\"", "\"", "}", "\n", "start", ":=", "time", ".", "Now", "(", ")", "\n\n", "result", ",", "err", ":=", "s", ".", "db", ".", "Exec", "(", "query", ",", "args", "...", ")", "\n", "s", ".", "incQueries", "(", "labels", ",", "start", ")", "\n", "if", "err", "!=", "nil", "{", "s", ".", "incError", "(", "labels", ")", "\n", "return", "0", ",", "err", "\n", "}", "\n\n", "return", "result", ".", "RowsAffected", "(", ")", "\n", "}"], "docstring": "// Delete implements storage interface.", "docstring_tokens": ["Delete", "implements", "storage", "interface", "."], "sha": "66d59c3c5b886e8e869915bb76257bcba4a47250", "url": "https://github.com/piotrkowalczuk/mnemosyne/blob/66d59c3c5b886e8e869915bb76257bcba4a47250/internal/storage/postgres/storage.go#L361-L381", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "overlay/overlay.go", "func_name": "WithMessage", "original_string": "func (p SetPausedInDebuggerMessageParams) WithMessage(message string) *SetPausedInDebuggerMessageParams {\n\tp.Message = message\n\treturn &p\n}", "language": "go", "code": "func (p SetPausedInDebuggerMessageParams) WithMessage(message string) *SetPausedInDebuggerMessageParams {\n\tp.Message = message\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "SetPausedInDebuggerMessageParams", ")", "WithMessage", "(", "message", "string", ")", "*", "SetPausedInDebuggerMessageParams", "{", "p", ".", "Message", "=", "message", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithMessage the message to display, also triggers resume and step over\n// controls.", "docstring_tokens": ["WithMessage", "the", "message", "to", "display", "also", "triggers", "resume", "and", "step", "over", "controls", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/overlay.go#L352-L355", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "MustConfirm", "original_string": "func (u ScpStatementPledges) MustConfirm() ScpStatementConfirm {\n\tval, ok := u.GetConfirm()\n\n\tif !ok {\n\t\tpanic(\"arm Confirm is not set\")\n\t}\n\n\treturn val\n}", "language": "go", "code": "func (u ScpStatementPledges) MustConfirm() ScpStatementConfirm {\n\tval, ok := u.GetConfirm()\n\n\tif !ok {\n\t\tpanic(\"arm Confirm is not set\")\n\t}\n\n\treturn val\n}", "code_tokens": ["func", "(", "u", "ScpStatementPledges", ")", "MustConfirm", "(", ")", "ScpStatementConfirm", "{", "val", ",", "ok", ":=", "u", ".", "GetConfirm", "(", ")", "\n\n", "if", "!", "ok", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "val", "\n", "}"], "docstring": "// MustConfirm retrieves the Confirm value from the union,\n// panicing if the value is not set.", "docstring_tokens": ["MustConfirm", "retrieves", "the", "Confirm", "value", "from", "the", "union", "panicing", "if", "the", "value", "is", "not", "set", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L7115-L7123", "partition": "test"}
{"repo": "libp2p/go-libp2p-pubsub", "path": "pubsub.go", "func_name": "ListPeers", "original_string": "func (p *PubSub) ListPeers(topic string) []peer.ID {\n\tout := make(chan []peer.ID)\n\tp.getPeers <- &listPeerReq{\n\t\tresp:  out,\n\t\ttopic: topic,\n\t}\n\treturn <-out\n}", "language": "go", "code": "func (p *PubSub) ListPeers(topic string) []peer.ID {\n\tout := make(chan []peer.ID)\n\tp.getPeers <- &listPeerReq{\n\t\tresp:  out,\n\t\ttopic: topic,\n\t}\n\treturn <-out\n}", "code_tokens": ["func", "(", "p", "*", "PubSub", ")", "ListPeers", "(", "topic", "string", ")", "[", "]", "peer", ".", "ID", "{", "out", ":=", "make", "(", "chan", "[", "]", "peer", ".", "ID", ")", "\n", "p", ".", "getPeers", "<-", "&", "listPeerReq", "{", "resp", ":", "out", ",", "topic", ":", "topic", ",", "}", "\n", "return", "<-", "out", "\n", "}"], "docstring": "// ListPeers returns a list of peers we are connected to in the given topic.", "docstring_tokens": ["ListPeers", "returns", "a", "list", "of", "peers", "we", "are", "connected", "to", "in", "the", "given", "topic", "."], "sha": "9db3dbdde90f44d1c420192c5cefd60682fbdbb9", "url": "https://github.com/libp2p/go-libp2p-pubsub/blob/9db3dbdde90f44d1c420192c5cefd60682fbdbb9/pubsub.go#L872-L879", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "errors.go", "func_name": "New", "original_string": "func (e *ValidationError) New(message string) *ValidationError {\n\te.HTTPCode = http.StatusBadRequest\n\te.Errno = 0\n\te.Message = message\n\treturn e\n}", "language": "go", "code": "func (e *ValidationError) New(message string) *ValidationError {\n\te.HTTPCode = http.StatusBadRequest\n\te.Errno = 0\n\te.Message = message\n\treturn e\n}", "code_tokens": ["func", "(", "e", "*", "ValidationError", ")", "New", "(", "message", "string", ")", "*", "ValidationError", "{", "e", ".", "HTTPCode", "=", "http", ".", "StatusBadRequest", "\n", "e", ".", "Errno", "=", "0", "\n", "e", ".", "Message", "=", "message", "\n", "return", "e", "\n", "}"], "docstring": "// New ValidationError.New", "docstring_tokens": ["New", "ValidationError", ".", "New"], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/errors.go#L91-L96", "partition": "test"}
{"repo": "nicholasjackson/bench", "path": "semaphore/semaphore.go", "func_name": "Resize", "original_string": "func (t *Semaphore) Resize(capacity int) {\n\n\t// only allow one resize to be called from one thread\n\tt.resizeMutex.Lock()\n\n\tif capacity == cap(t.s) {\n\t\tt.resizeMutex.Unlock()\n\t\treturn\n\t}\n\n\t// lock the locks\n\tt.resizeLock()\n\tt.readMutex.Lock()\n\tdefer t.resizeUnlock()\n\tdefer t.resizeMutex.Unlock()\n\tdefer t.readMutex.Unlock()\n\n\tnew := make(chan struct{}, capacity) // create the new semaphore with the new capcity\n\n\t// copy the old values\n\tfor n := len(t.s); n != 0; n = len(t.s) {\n\t\tnew <- <-t.s // copy elements to the new channel\n\t}\n\n\tt.s = new\n}", "language": "go", "code": "func (t *Semaphore) Resize(capacity int) {\n\n\t// only allow one resize to be called from one thread\n\tt.resizeMutex.Lock()\n\n\tif capacity == cap(t.s) {\n\t\tt.resizeMutex.Unlock()\n\t\treturn\n\t}\n\n\t// lock the locks\n\tt.resizeLock()\n\tt.readMutex.Lock()\n\tdefer t.resizeUnlock()\n\tdefer t.resizeMutex.Unlock()\n\tdefer t.readMutex.Unlock()\n\n\tnew := make(chan struct{}, capacity) // create the new semaphore with the new capcity\n\n\t// copy the old values\n\tfor n := len(t.s); n != 0; n = len(t.s) {\n\t\tnew <- <-t.s // copy elements to the new channel\n\t}\n\n\tt.s = new\n}", "code_tokens": ["func", "(", "t", "*", "Semaphore", ")", "Resize", "(", "capacity", "int", ")", "{", "// only allow one resize to be called from one thread", "t", ".", "resizeMutex", ".", "Lock", "(", ")", "\n\n", "if", "capacity", "==", "cap", "(", "t", ".", "s", ")", "{", "t", ".", "resizeMutex", ".", "Unlock", "(", ")", "\n", "return", "\n", "}", "\n\n", "// lock the locks", "t", ".", "resizeLock", "(", ")", "\n", "t", ".", "readMutex", ".", "Lock", "(", ")", "\n", "defer", "t", ".", "resizeUnlock", "(", ")", "\n", "defer", "t", ".", "resizeMutex", ".", "Unlock", "(", ")", "\n", "defer", "t", ".", "readMutex", ".", "Unlock", "(", ")", "\n\n", "new", ":=", "make", "(", "chan", "struct", "{", "}", ",", "capacity", ")", "// create the new semaphore with the new capcity", "\n\n", "// copy the old values", "for", "n", ":=", "len", "(", "t", ".", "s", ")", ";", "n", "!=", "0", ";", "n", "=", "len", "(", "t", ".", "s", ")", "{", "new", "<-", "<-", "t", ".", "s", "// copy elements to the new channel", "\n", "}", "\n\n", "t", ".", "s", "=", "new", "\n", "}"], "docstring": "// Resize allows dynamic resizing of the semaphore, it can be used if it desired\n// to increase the current number of allowable concurent processes.", "docstring_tokens": ["Resize", "allows", "dynamic", "resizing", "of", "the", "semaphore", "it", "can", "be", "used", "if", "it", "desired", "to", "increase", "the", "current", "number", "of", "allowable", "concurent", "processes", "."], "sha": "2df9635f0ad020b2e82616b0fd87130aaa1ee12e", "url": "https://github.com/nicholasjackson/bench/blob/2df9635f0ad020b2e82616b0fd87130aaa1ee12e/semaphore/semaphore.go#L69-L94", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/node/config.go", "func_name": "HTTPSAddress", "original_string": "func HTTPSAddress(node *db.Node) (string, error) {\n\tvar config *Config\n\terr := node.Transaction(func(tx *db.NodeTx) error {\n\t\tvar err error\n\t\tconfig, err = ConfigLoad(tx)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn config.HTTPSAddress(), nil\n}", "language": "go", "code": "func HTTPSAddress(node *db.Node) (string, error) {\n\tvar config *Config\n\terr := node.Transaction(func(tx *db.NodeTx) error {\n\t\tvar err error\n\t\tconfig, err = ConfigLoad(tx)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn config.HTTPSAddress(), nil\n}", "code_tokens": ["func", "HTTPSAddress", "(", "node", "*", "db", ".", "Node", ")", "(", "string", ",", "error", ")", "{", "var", "config", "*", "Config", "\n", "err", ":=", "node", ".", "Transaction", "(", "func", "(", "tx", "*", "db", ".", "NodeTx", ")", "error", "{", "var", "err", "error", "\n", "config", ",", "err", "=", "ConfigLoad", "(", "tx", ")", "\n", "return", "err", "\n", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n\n", "return", "config", ".", "HTTPSAddress", "(", ")", ",", "nil", "\n", "}"], "docstring": "// HTTPSAddress is a convenience for loading the node configuration and\n// returning the value of core.https_address.", "docstring_tokens": ["HTTPSAddress", "is", "a", "convenience", "for", "loading", "the", "node", "configuration", "and", "returning", "the", "value", "of", "core", ".", "https_address", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/node/config.go#L80-L92", "partition": "test"}
{"repo": "profitbricks/profitbricks-sdk-go", "path": "nic.go", "func_name": "ListNics", "original_string": "func (c *Client) ListNics(dcid, srvid string) (*Nics, error) {\n\turl := nicColPath(dcid, srvid) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &Nics{}\n\terr := c.client.Get(url, ret, http.StatusOK)\n\treturn ret, err\n}", "language": "go", "code": "func (c *Client) ListNics(dcid, srvid string) (*Nics, error) {\n\turl := nicColPath(dcid, srvid) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &Nics{}\n\terr := c.client.Get(url, ret, http.StatusOK)\n\treturn ret, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "ListNics", "(", "dcid", ",", "srvid", "string", ")", "(", "*", "Nics", ",", "error", ")", "{", "url", ":=", "nicColPath", "(", "dcid", ",", "srvid", ")", "+", "`?depth=`", "+", "c", ".", "client", ".", "depth", "+", "`&pretty=`", "+", "strconv", ".", "FormatBool", "(", "c", ".", "client", ".", "pretty", ")", "\n", "ret", ":=", "&", "Nics", "{", "}", "\n", "err", ":=", "c", ".", "client", ".", "Get", "(", "url", ",", "ret", ",", "http", ".", "StatusOK", ")", "\n", "return", "ret", ",", "err", "\n", "}"], "docstring": "// ListNics returns a Nics struct collection", "docstring_tokens": ["ListNics", "returns", "a", "Nics", "struct", "collection"], "sha": "1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4", "url": "https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/nic.go#L49-L54", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "routergroup.go", "func_name": "Group", "original_string": "func (group *RouterGroup) Group(relativePath string, handlers ...RouterHandler) *RouterGroup {\n\treturn &RouterGroup{\n\t\tHandlers: group.combineHandlers(handlers),\n\t\tbasePath: group.calculateAbsolutePath(relativePath),\n\t\tengine:   group.engine,\n\t}\n}", "language": "go", "code": "func (group *RouterGroup) Group(relativePath string, handlers ...RouterHandler) *RouterGroup {\n\treturn &RouterGroup{\n\t\tHandlers: group.combineHandlers(handlers),\n\t\tbasePath: group.calculateAbsolutePath(relativePath),\n\t\tengine:   group.engine,\n\t}\n}", "code_tokens": ["func", "(", "group", "*", "RouterGroup", ")", "Group", "(", "relativePath", "string", ",", "handlers", "...", "RouterHandler", ")", "*", "RouterGroup", "{", "return", "&", "RouterGroup", "{", "Handlers", ":", "group", ".", "combineHandlers", "(", "handlers", ")", ",", "basePath", ":", "group", ".", "calculateAbsolutePath", "(", "relativePath", ")", ",", "engine", ":", "group", ".", "engine", ",", "}", "\n", "}"], "docstring": "// Group creates a new router group. You should add all the routes that have common middlwares or the same path prefix.\n// For example, all the routes that use a common middlware for authorization could be grouped.", "docstring_tokens": ["Group", "creates", "a", "new", "router", "group", ".", "You", "should", "add", "all", "the", "routes", "that", "have", "common", "middlwares", "or", "the", "same", "path", "prefix", ".", "For", "example", "all", "the", "routes", "that", "use", "a", "common", "middlware", "for", "authorization", "could", "be", "grouped", "."], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/routergroup.go#L57-L63", "partition": "test"}
{"repo": "pact-foundation/pact-go", "path": "dsl/pact.go", "func_name": "VerifyMessageProviderRaw", "original_string": "func (p *Pact) VerifyMessageProviderRaw(request VerifyMessageRequest) (types.ProviderVerifierResponse, error) {\n\tp.Setup(false)\n\tresponse := types.ProviderVerifierResponse{}\n\n\t// Starts the message wrapper API with hooks back to the message handlers\n\t// This maps the 'description' field of a message pact, to a function handler\n\t// that will implement the message producer. This function must return an object and optionally\n\t// and error. The object will be marshalled to JSON for comparison.\n\tmux := http.NewServeMux()\n\n\tport, err := utils.GetFreePort()\n\tif err != nil {\n\t\treturn response, fmt.Errorf(\"unable to allocate a port for verification: %v\", err)\n\t}\n\n\t// Construct verifier request\n\tverificationRequest := types.VerifyRequest{\n\t\tProviderBaseURL:            fmt.Sprintf(\"http://localhost:%d\", port),\n\t\tPactURLs:                   request.PactURLs,\n\t\tBrokerURL:                  request.BrokerURL,\n\t\tTags:                       request.Tags,\n\t\tBrokerUsername:             request.BrokerUsername,\n\t\tBrokerPassword:             request.BrokerPassword,\n\t\tBrokerToken:                request.BrokerToken,\n\t\tPublishVerificationResults: request.PublishVerificationResults,\n\t\tProviderVersion:            request.ProviderVersion,\n\t\tProvider:                   p.Provider,\n\t}\n\n\tmux.HandleFunc(\"/\", messageVerificationHandler(request.MessageHandlers, request.StateHandlers))\n\n\tln, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tlog.Printf(\"[DEBUG] API handler starting: port %d (%s)\", port, ln.Addr())\n\tgo http.Serve(ln, mux)\n\n\tportErr := waitForPort(port, \"tcp\", \"localhost\", p.ClientTimeout,\n\t\tfmt.Sprintf(`Timed out waiting for pact proxy on port %d - check for errors`, port))\n\n\tif portErr != nil {\n\t\tlog.Fatal(\"Error:\", err)\n\t\treturn response, portErr\n\t}\n\n\tlog.Println(\"[DEBUG] pact provider verification\")\n\treturn p.pactClient.VerifyProvider(verificationRequest)\n}", "language": "go", "code": "func (p *Pact) VerifyMessageProviderRaw(request VerifyMessageRequest) (types.ProviderVerifierResponse, error) {\n\tp.Setup(false)\n\tresponse := types.ProviderVerifierResponse{}\n\n\t// Starts the message wrapper API with hooks back to the message handlers\n\t// This maps the 'description' field of a message pact, to a function handler\n\t// that will implement the message producer. This function must return an object and optionally\n\t// and error. The object will be marshalled to JSON for comparison.\n\tmux := http.NewServeMux()\n\n\tport, err := utils.GetFreePort()\n\tif err != nil {\n\t\treturn response, fmt.Errorf(\"unable to allocate a port for verification: %v\", err)\n\t}\n\n\t// Construct verifier request\n\tverificationRequest := types.VerifyRequest{\n\t\tProviderBaseURL:            fmt.Sprintf(\"http://localhost:%d\", port),\n\t\tPactURLs:                   request.PactURLs,\n\t\tBrokerURL:                  request.BrokerURL,\n\t\tTags:                       request.Tags,\n\t\tBrokerUsername:             request.BrokerUsername,\n\t\tBrokerPassword:             request.BrokerPassword,\n\t\tBrokerToken:                request.BrokerToken,\n\t\tPublishVerificationResults: request.PublishVerificationResults,\n\t\tProviderVersion:            request.ProviderVersion,\n\t\tProvider:                   p.Provider,\n\t}\n\n\tmux.HandleFunc(\"/\", messageVerificationHandler(request.MessageHandlers, request.StateHandlers))\n\n\tln, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tlog.Printf(\"[DEBUG] API handler starting: port %d (%s)\", port, ln.Addr())\n\tgo http.Serve(ln, mux)\n\n\tportErr := waitForPort(port, \"tcp\", \"localhost\", p.ClientTimeout,\n\t\tfmt.Sprintf(`Timed out waiting for pact proxy on port %d - check for errors`, port))\n\n\tif portErr != nil {\n\t\tlog.Fatal(\"Error:\", err)\n\t\treturn response, portErr\n\t}\n\n\tlog.Println(\"[DEBUG] pact provider verification\")\n\treturn p.pactClient.VerifyProvider(verificationRequest)\n}", "code_tokens": ["func", "(", "p", "*", "Pact", ")", "VerifyMessageProviderRaw", "(", "request", "VerifyMessageRequest", ")", "(", "types", ".", "ProviderVerifierResponse", ",", "error", ")", "{", "p", ".", "Setup", "(", "false", ")", "\n", "response", ":=", "types", ".", "ProviderVerifierResponse", "{", "}", "\n\n", "// Starts the message wrapper API with hooks back to the message handlers", "// This maps the 'description' field of a message pact, to a function handler", "// that will implement the message producer. This function must return an object and optionally", "// and error. The object will be marshalled to JSON for comparison.", "mux", ":=", "http", ".", "NewServeMux", "(", ")", "\n\n", "port", ",", "err", ":=", "utils", ".", "GetFreePort", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "response", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "// Construct verifier request", "verificationRequest", ":=", "types", ".", "VerifyRequest", "{", "ProviderBaseURL", ":", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "port", ")", ",", "PactURLs", ":", "request", ".", "PactURLs", ",", "BrokerURL", ":", "request", ".", "BrokerURL", ",", "Tags", ":", "request", ".", "Tags", ",", "BrokerUsername", ":", "request", ".", "BrokerUsername", ",", "BrokerPassword", ":", "request", ".", "BrokerPassword", ",", "BrokerToken", ":", "request", ".", "BrokerToken", ",", "PublishVerificationResults", ":", "request", ".", "PublishVerificationResults", ",", "ProviderVersion", ":", "request", ".", "ProviderVersion", ",", "Provider", ":", "p", ".", "Provider", ",", "}", "\n\n", "mux", ".", "HandleFunc", "(", "\"", "\"", ",", "messageVerificationHandler", "(", "request", ".", "MessageHandlers", ",", "request", ".", "StateHandlers", ")", ")", "\n\n", "ln", ",", "err", ":=", "net", ".", "Listen", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "port", ")", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n", "defer", "ln", ".", "Close", "(", ")", "\n\n", "log", ".", "Printf", "(", "\"", "\"", ",", "port", ",", "ln", ".", "Addr", "(", ")", ")", "\n", "go", "http", ".", "Serve", "(", "ln", ",", "mux", ")", "\n\n", "portErr", ":=", "waitForPort", "(", "port", ",", "\"", "\"", ",", "\"", "\"", ",", "p", ".", "ClientTimeout", ",", "fmt", ".", "Sprintf", "(", "`Timed out waiting for pact proxy on port %d - check for errors`", ",", "port", ")", ")", "\n\n", "if", "portErr", "!=", "nil", "{", "log", ".", "Fatal", "(", "\"", "\"", ",", "err", ")", "\n", "return", "response", ",", "portErr", "\n", "}", "\n\n", "log", ".", "Println", "(", "\"", "\"", ")", "\n", "return", "p", ".", "pactClient", ".", "VerifyProvider", "(", "verificationRequest", ")", "\n", "}"], "docstring": "// VerifyMessageProviderRaw runs provider message verification.\n//\n// A Message Producer is analagous to Consumer in the HTTP Interaction model.\n// It is the initiator of an interaction, and expects something on the other end\n// of the interaction to respond - just in this case, not immediately.", "docstring_tokens": ["VerifyMessageProviderRaw", "runs", "provider", "message", "verification", ".", "A", "Message", "Producer", "is", "analagous", "to", "Consumer", "in", "the", "HTTP", "Interaction", "model", ".", "It", "is", "the", "initiator", "of", "an", "interaction", "and", "expects", "something", "on", "the", "other", "end", "of", "the", "interaction", "to", "respond", "-", "just", "in", "this", "case", "not", "immediately", "."], "sha": "467dea56d27e154363e1975f6e9f4dbf66148e79", "url": "https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/dsl/pact.go#L591-L641", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "raft/storage.go", "func_name": "Entries", "original_string": "func (ms *MemoryStorage) Entries(lo, hi, maxSize uint64) ([]pb.Entry, error) {\n\tms.Lock()\n\tdefer ms.Unlock()\n\toffset := ms.ents[0].Index\n\tif lo <= offset {\n\t\treturn nil, ErrCompacted\n\t}\n\tif hi > ms.lastIndex()+1 {\n\t\traftLogger.Panicf(\"entries' hi(%d) is out of bound lastindex(%d)\", hi, ms.lastIndex())\n\t}\n\t// only contains dummy entries.\n\tif len(ms.ents) == 1 {\n\t\treturn nil, ErrUnavailable\n\t}\n\n\tents := ms.ents[lo-offset : hi-offset]\n\treturn limitSize(ents, maxSize), nil\n}", "language": "go", "code": "func (ms *MemoryStorage) Entries(lo, hi, maxSize uint64) ([]pb.Entry, error) {\n\tms.Lock()\n\tdefer ms.Unlock()\n\toffset := ms.ents[0].Index\n\tif lo <= offset {\n\t\treturn nil, ErrCompacted\n\t}\n\tif hi > ms.lastIndex()+1 {\n\t\traftLogger.Panicf(\"entries' hi(%d) is out of bound lastindex(%d)\", hi, ms.lastIndex())\n\t}\n\t// only contains dummy entries.\n\tif len(ms.ents) == 1 {\n\t\treturn nil, ErrUnavailable\n\t}\n\n\tents := ms.ents[lo-offset : hi-offset]\n\treturn limitSize(ents, maxSize), nil\n}", "code_tokens": ["func", "(", "ms", "*", "MemoryStorage", ")", "Entries", "(", "lo", ",", "hi", ",", "maxSize", "uint64", ")", "(", "[", "]", "pb", ".", "Entry", ",", "error", ")", "{", "ms", ".", "Lock", "(", ")", "\n", "defer", "ms", ".", "Unlock", "(", ")", "\n", "offset", ":=", "ms", ".", "ents", "[", "0", "]", ".", "Index", "\n", "if", "lo", "<=", "offset", "{", "return", "nil", ",", "ErrCompacted", "\n", "}", "\n", "if", "hi", ">", "ms", ".", "lastIndex", "(", ")", "+", "1", "{", "raftLogger", ".", "Panicf", "(", "\"", "\"", ",", "hi", ",", "ms", ".", "lastIndex", "(", ")", ")", "\n", "}", "\n", "// only contains dummy entries.", "if", "len", "(", "ms", ".", "ents", ")", "==", "1", "{", "return", "nil", ",", "ErrUnavailable", "\n", "}", "\n\n", "ents", ":=", "ms", ".", "ents", "[", "lo", "-", "offset", ":", "hi", "-", "offset", "]", "\n", "return", "limitSize", "(", "ents", ",", "maxSize", ")", ",", "nil", "\n", "}"], "docstring": "// Entries implements the Storage interface.", "docstring_tokens": ["Entries", "implements", "the", "Storage", "interface", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/storage.go#L108-L125", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/deploy/assets/assets.go", "func_name": "WriteLocalAssets", "original_string": "func WriteLocalAssets(encoder Encoder, opts *AssetOpts, hostPath string) error {\n\tif err := WriteAssets(encoder, opts, localBackend, localBackend, 1 /* = volume size (gb) */, hostPath); err != nil {\n\t\treturn err\n\t}\n\tif secretErr := WriteSecret(encoder, LocalSecret(), opts); secretErr != nil {\n\t\treturn secretErr\n\t}\n\treturn nil\n}", "language": "go", "code": "func WriteLocalAssets(encoder Encoder, opts *AssetOpts, hostPath string) error {\n\tif err := WriteAssets(encoder, opts, localBackend, localBackend, 1 /* = volume size (gb) */, hostPath); err != nil {\n\t\treturn err\n\t}\n\tif secretErr := WriteSecret(encoder, LocalSecret(), opts); secretErr != nil {\n\t\treturn secretErr\n\t}\n\treturn nil\n}", "code_tokens": ["func", "WriteLocalAssets", "(", "encoder", "Encoder", ",", "opts", "*", "AssetOpts", ",", "hostPath", "string", ")", "error", "{", "if", "err", ":=", "WriteAssets", "(", "encoder", ",", "opts", ",", "localBackend", ",", "localBackend", ",", "1", "/* = volume size (gb) */", ",", "hostPath", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "secretErr", ":=", "WriteSecret", "(", "encoder", ",", "LocalSecret", "(", ")", ",", "opts", ")", ";", "secretErr", "!=", "nil", "{", "return", "secretErr", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// WriteLocalAssets writes assets to a local backend.", "docstring_tokens": ["WriteLocalAssets", "writes", "assets", "to", "a", "local", "backend", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/deploy/assets/assets.go#L1463-L1471", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxc/utils/progress.go", "func_name": "Update", "original_string": "func (p *ProgressRenderer) Update(status string) {\n\t// Wait if needed\n\ttimeout := p.wait.Sub(time.Now())\n\tif timeout.Seconds() > 0 {\n\t\ttime.Sleep(timeout)\n\t}\n\n\t// Acquire rendering lock\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\t// Check if we're already done\n\tif p.done {\n\t\treturn\n\t}\n\n\t// Handle quiet mode\n\tif p.Quiet {\n\t\treturn\n\t}\n\n\t// Skip status updates when not dealing with a terminal\n\tif p.terminal == 0 {\n\t\tif !termios.IsTerminal(int(os.Stdout.Fd())) {\n\t\t\tp.terminal = -1\n\t\t}\n\n\t\tp.terminal = 1\n\t}\n\n\tif p.terminal != 1 {\n\t\treturn\n\t}\n\n\t// Print the new message\n\tmsg := \"%s\"\n\tif p.Format != \"\" {\n\t\tmsg = p.Format\n\t}\n\n\tmsg = fmt.Sprintf(msg, status)\n\n\t// Truncate msg to terminal length\n\tmsg = \"\\r\" + p.truncate(msg)\n\n\t// Don't print if empty and never printed\n\tif len(msg) == 1 && p.maxLength == 0 {\n\t\treturn\n\t}\n\n\tif len(msg) > p.maxLength {\n\t\tp.maxLength = len(msg)\n\t} else {\n\t\tfmt.Printf(\"\\r%s\", strings.Repeat(\" \", p.maxLength))\n\t}\n\n\tfmt.Print(msg)\n}", "language": "go", "code": "func (p *ProgressRenderer) Update(status string) {\n\t// Wait if needed\n\ttimeout := p.wait.Sub(time.Now())\n\tif timeout.Seconds() > 0 {\n\t\ttime.Sleep(timeout)\n\t}\n\n\t// Acquire rendering lock\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\t// Check if we're already done\n\tif p.done {\n\t\treturn\n\t}\n\n\t// Handle quiet mode\n\tif p.Quiet {\n\t\treturn\n\t}\n\n\t// Skip status updates when not dealing with a terminal\n\tif p.terminal == 0 {\n\t\tif !termios.IsTerminal(int(os.Stdout.Fd())) {\n\t\t\tp.terminal = -1\n\t\t}\n\n\t\tp.terminal = 1\n\t}\n\n\tif p.terminal != 1 {\n\t\treturn\n\t}\n\n\t// Print the new message\n\tmsg := \"%s\"\n\tif p.Format != \"\" {\n\t\tmsg = p.Format\n\t}\n\n\tmsg = fmt.Sprintf(msg, status)\n\n\t// Truncate msg to terminal length\n\tmsg = \"\\r\" + p.truncate(msg)\n\n\t// Don't print if empty and never printed\n\tif len(msg) == 1 && p.maxLength == 0 {\n\t\treturn\n\t}\n\n\tif len(msg) > p.maxLength {\n\t\tp.maxLength = len(msg)\n\t} else {\n\t\tfmt.Printf(\"\\r%s\", strings.Repeat(\" \", p.maxLength))\n\t}\n\n\tfmt.Print(msg)\n}", "code_tokens": ["func", "(", "p", "*", "ProgressRenderer", ")", "Update", "(", "status", "string", ")", "{", "// Wait if needed", "timeout", ":=", "p", ".", "wait", ".", "Sub", "(", "time", ".", "Now", "(", ")", ")", "\n", "if", "timeout", ".", "Seconds", "(", ")", ">", "0", "{", "time", ".", "Sleep", "(", "timeout", ")", "\n", "}", "\n\n", "// Acquire rendering lock", "p", ".", "lock", ".", "Lock", "(", ")", "\n", "defer", "p", ".", "lock", ".", "Unlock", "(", ")", "\n\n", "// Check if we're already done", "if", "p", ".", "done", "{", "return", "\n", "}", "\n\n", "// Handle quiet mode", "if", "p", ".", "Quiet", "{", "return", "\n", "}", "\n\n", "// Skip status updates when not dealing with a terminal", "if", "p", ".", "terminal", "==", "0", "{", "if", "!", "termios", ".", "IsTerminal", "(", "int", "(", "os", ".", "Stdout", ".", "Fd", "(", ")", ")", ")", "{", "p", ".", "terminal", "=", "-", "1", "\n", "}", "\n\n", "p", ".", "terminal", "=", "1", "\n", "}", "\n\n", "if", "p", ".", "terminal", "!=", "1", "{", "return", "\n", "}", "\n\n", "// Print the new message", "msg", ":=", "\"", "\"", "\n", "if", "p", ".", "Format", "!=", "\"", "\"", "{", "msg", "=", "p", ".", "Format", "\n", "}", "\n\n", "msg", "=", "fmt", ".", "Sprintf", "(", "msg", ",", "status", ")", "\n\n", "// Truncate msg to terminal length", "msg", "=", "\"", "\\r", "\"", "+", "p", ".", "truncate", "(", "msg", ")", "\n\n", "// Don't print if empty and never printed", "if", "len", "(", "msg", ")", "==", "1", "&&", "p", ".", "maxLength", "==", "0", "{", "return", "\n", "}", "\n\n", "if", "len", "(", "msg", ")", ">", "p", ".", "maxLength", "{", "p", ".", "maxLength", "=", "len", "(", "msg", ")", "\n", "}", "else", "{", "fmt", ".", "Printf", "(", "\"", "\\r", "\"", ",", "strings", ".", "Repeat", "(", "\"", "\"", ",", "p", ".", "maxLength", ")", ")", "\n", "}", "\n\n", "fmt", ".", "Print", "(", "msg", ")", "\n", "}"], "docstring": "// Update changes the status message to the provided string", "docstring_tokens": ["Update", "changes", "the", "status", "message", "to", "the", "provided", "string"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxc/utils/progress.go#L84-L141", "partition": "test"}
{"repo": "jinzhu/now", "path": "now.go", "func_name": "EndOfMinute", "original_string": "func (now *Now) EndOfMinute() time.Time {\n\treturn now.BeginningOfMinute().Add(time.Minute - time.Nanosecond)\n}", "language": "go", "code": "func (now *Now) EndOfMinute() time.Time {\n\treturn now.BeginningOfMinute().Add(time.Minute - time.Nanosecond)\n}", "code_tokens": ["func", "(", "now", "*", "Now", ")", "EndOfMinute", "(", ")", "time", ".", "Time", "{", "return", "now", ".", "BeginningOfMinute", "(", ")", ".", "Add", "(", "time", ".", "Minute", "-", "time", ".", "Nanosecond", ")", "\n", "}"], "docstring": "// EndOfMinute end of minute", "docstring_tokens": ["EndOfMinute", "end", "of", "minute"], "sha": "8ec929ed50c3ac25ce77ba4486e1f277c552c591", "url": "https://github.com/jinzhu/now/blob/8ec929ed50c3ac25ce77ba4486e1f277c552c591/now.go#L63-L65", "partition": "test"}
{"repo": "apuigsech/seekret", "path": "models/exception.go", "func_name": "SetContent", "original_string": "func (x *Exception) SetContent(content string) error {\n\tcontentRegexp, err := regexp.Compile(\"(?i)\" + content)\n\tif err != nil {\n\t\treturn err\n\t}\n\tx.Content = contentRegexp\n\treturn nil\n}", "language": "go", "code": "func (x *Exception) SetContent(content string) error {\n\tcontentRegexp, err := regexp.Compile(\"(?i)\" + content)\n\tif err != nil {\n\t\treturn err\n\t}\n\tx.Content = contentRegexp\n\treturn nil\n}", "code_tokens": ["func", "(", "x", "*", "Exception", ")", "SetContent", "(", "content", "string", ")", "error", "{", "contentRegexp", ",", "err", ":=", "regexp", ".", "Compile", "(", "\"", "\"", "+", "content", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "x", ".", "Content", "=", "contentRegexp", "\n", "return", "nil", "\n", "}"], "docstring": "// SetContent sets the regular expresion that should match the content of the\n// object.", "docstring_tokens": ["SetContent", "sets", "the", "regular", "expresion", "that", "should", "match", "the", "content", "of", "the", "object", "."], "sha": "9b1f7ea1b3fd5bd29d93cf62102cb66e54428a49", "url": "https://github.com/apuigsech/seekret/blob/9b1f7ea1b3fd5bd29d93cf62102cb66e54428a49/models/exception.go#L68-L75", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nitro.go", "func_name": "MemoryInUse", "original_string": "func (m *Nitro) MemoryInUse() int64 {\n\tstoreStats := m.aggrStoreStats()\n\treturn storeStats.Memory + m.snapshots.MemoryInUse() + m.gcsnapshots.MemoryInUse()\n}", "language": "go", "code": "func (m *Nitro) MemoryInUse() int64 {\n\tstoreStats := m.aggrStoreStats()\n\treturn storeStats.Memory + m.snapshots.MemoryInUse() + m.gcsnapshots.MemoryInUse()\n}", "code_tokens": ["func", "(", "m", "*", "Nitro", ")", "MemoryInUse", "(", ")", "int64", "{", "storeStats", ":=", "m", ".", "aggrStoreStats", "(", ")", "\n", "return", "storeStats", ".", "Memory", "+", "m", ".", "snapshots", ".", "MemoryInUse", "(", ")", "+", "m", ".", "gcsnapshots", ".", "MemoryInUse", "(", ")", "\n", "}"], "docstring": "// MemoryInUse returns total memory used by the Nitro instance.", "docstring_tokens": ["MemoryInUse", "returns", "total", "memory", "used", "by", "the", "Nitro", "instance", "."], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nitro.go#L410-L413", "partition": "test"}
{"repo": "janos/web", "path": "templates/templates.go", "func_name": "WithBaseDir", "original_string": "func WithBaseDir(dir string) Option {\n\treturn func(o *Options) {\n\t\to.fileFindFunc = func(f string) string {\n\t\t\treturn filepath.Join(dir, f)\n\t\t}\n\t}\n}", "language": "go", "code": "func WithBaseDir(dir string) Option {\n\treturn func(o *Options) {\n\t\to.fileFindFunc = func(f string) string {\n\t\t\treturn filepath.Join(dir, f)\n\t\t}\n\t}\n}", "code_tokens": ["func", "WithBaseDir", "(", "dir", "string", ")", "Option", "{", "return", "func", "(", "o", "*", "Options", ")", "{", "o", ".", "fileFindFunc", "=", "func", "(", "f", "string", ")", "string", "{", "return", "filepath", ".", "Join", "(", "dir", ",", "f", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// WithBaseDir sets the directory in which template files\n// are stored.", "docstring_tokens": ["WithBaseDir", "sets", "the", "directory", "in", "which", "template", "files", "are", "stored", "."], "sha": "0fb0203103deb84424510a8d5166ac00700f2b0e", "url": "https://github.com/janos/web/blob/0fb0203103deb84424510a8d5166ac00700f2b0e/templates/templates.go#L65-L71", "partition": "test"}
{"repo": "mikespook/possum", "path": "view/template.go", "func_name": "InitWatcher", "original_string": "func InitWatcher(pattern string, f func(string) error, ef func(error)) (err error) {\n\tif err = f(pattern); err != nil {\n\t\treturn\n\t}\n\tif watcher.Watcher == nil {\n\t\twatcher.Watcher, err = fsnotify.NewWatcher()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\twatcher.closer = make(chan bool)\n\t}\n\tgo func() {\n\t\tatomic.AddUint32(&watcher.count, 1)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-watcher.Events:\n\t\t\t\tif err := f(pattern); err != nil {\n\t\t\t\t\tef(err)\n\t\t\t\t}\n\t\t\tcase err := <-watcher.Errors:\n\t\t\t\tif ef != nil {\n\t\t\t\t\tef(err)\n\t\t\t\t}\n\t\t\tcase <-watcher.closer:\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar matches []string\n\tmatches, err = filepath.Glob(pattern)\n\tif err != nil {\n\t\treturn\n\t}\n\tfor _, v := range matches {\n\t\tif err = watcher.Add(v); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}", "language": "go", "code": "func InitWatcher(pattern string, f func(string) error, ef func(error)) (err error) {\n\tif err = f(pattern); err != nil {\n\t\treturn\n\t}\n\tif watcher.Watcher == nil {\n\t\twatcher.Watcher, err = fsnotify.NewWatcher()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\twatcher.closer = make(chan bool)\n\t}\n\tgo func() {\n\t\tatomic.AddUint32(&watcher.count, 1)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-watcher.Events:\n\t\t\t\tif err := f(pattern); err != nil {\n\t\t\t\t\tef(err)\n\t\t\t\t}\n\t\t\tcase err := <-watcher.Errors:\n\t\t\t\tif ef != nil {\n\t\t\t\t\tef(err)\n\t\t\t\t}\n\t\t\tcase <-watcher.closer:\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar matches []string\n\tmatches, err = filepath.Glob(pattern)\n\tif err != nil {\n\t\treturn\n\t}\n\tfor _, v := range matches {\n\t\tif err = watcher.Add(v); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}", "code_tokens": ["func", "InitWatcher", "(", "pattern", "string", ",", "f", "func", "(", "string", ")", "error", ",", "ef", "func", "(", "error", ")", ")", "(", "err", "error", ")", "{", "if", "err", "=", "f", "(", "pattern", ")", ";", "err", "!=", "nil", "{", "return", "\n", "}", "\n", "if", "watcher", ".", "Watcher", "==", "nil", "{", "watcher", ".", "Watcher", ",", "err", "=", "fsnotify", ".", "NewWatcher", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\n", "}", "\n", "watcher", ".", "closer", "=", "make", "(", "chan", "bool", ")", "\n", "}", "\n", "go", "func", "(", ")", "{", "atomic", ".", "AddUint32", "(", "&", "watcher", ".", "count", ",", "1", ")", "\n", "for", "{", "select", "{", "case", "<-", "watcher", ".", "Events", ":", "if", "err", ":=", "f", "(", "pattern", ")", ";", "err", "!=", "nil", "{", "ef", "(", "err", ")", "\n", "}", "\n", "case", "err", ":=", "<-", "watcher", ".", "Errors", ":", "if", "ef", "!=", "nil", "{", "ef", "(", "err", ")", "\n", "}", "\n", "case", "<-", "watcher", ".", "closer", ":", "break", "\n", "}", "\n", "}", "\n", "}", "(", ")", "\n\n", "var", "matches", "[", "]", "string", "\n", "matches", ",", "err", "=", "filepath", ".", "Glob", "(", "pattern", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\n", "}", "\n", "for", "_", ",", "v", ":=", "range", "matches", "{", "if", "err", "=", "watcher", ".", "Add", "(", "v", ")", ";", "err", "!=", "nil", "{", "return", "\n", "}", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// InitWatcher initialzes a watcher to watch templates changes in the `pattern`.\n// f would be InitHtmlTemplates or InitTextTemplates.\n// If the watcher raises an error internally, the callback function ef will be executed.\n// ef can be nil witch represents ignoring all internal errors.", "docstring_tokens": ["InitWatcher", "initialzes", "a", "watcher", "to", "watch", "templates", "changes", "in", "the", "pattern", ".", "f", "would", "be", "InitHtmlTemplates", "or", "InitTextTemplates", ".", "If", "the", "watcher", "raises", "an", "error", "internally", "the", "callback", "function", "ef", "will", "be", "executed", ".", "ef", "can", "be", "nil", "witch", "represents", "ignoring", "all", "internal", "errors", "."], "sha": "56d7ebb6470b670001632b11be7fc089038f4dd7", "url": "https://github.com/mikespook/possum/blob/56d7ebb6470b670001632b11be7fc089038f4dd7/view/template.go#L90-L130", "partition": "test"}
{"repo": "rightscale/rsc", "path": "httpclient/http.go", "func_name": "copyHiddenHeaders", "original_string": "func copyHiddenHeaders(from map[string]bool) (to map[string]bool) {\n\tto = make(map[string]bool)\n\tfor k, v := range from {\n\t\tto[k] = v\n\t}\n\treturn\n}", "language": "go", "code": "func copyHiddenHeaders(from map[string]bool) (to map[string]bool) {\n\tto = make(map[string]bool)\n\tfor k, v := range from {\n\t\tto[k] = v\n\t}\n\treturn\n}", "code_tokens": ["func", "copyHiddenHeaders", "(", "from", "map", "[", "string", "]", "bool", ")", "(", "to", "map", "[", "string", "]", "bool", ")", "{", "to", "=", "make", "(", "map", "[", "string", "]", "bool", ")", "\n", "for", "k", ",", "v", ":=", "range", "from", "{", "to", "[", "k", "]", "=", "v", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// copyHiddenHeaders copies the given map", "docstring_tokens": ["copyHiddenHeaders", "copies", "the", "given", "map"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/httpclient/http.go#L550-L556", "partition": "test"}
{"repo": "kljensen/snowball", "path": "russian/step1.go", "func_name": "removeAdjectivalEnding", "original_string": "func removeAdjectivalEnding(word *snowballword.SnowballWord) bool {\n\n\t// Remove adjectival endings.  Start by looking for\n\t// an adjective ending.\n\t//\n\tsuffix, _ := word.RemoveFirstSuffixIn(word.RVstart,\n\t\t\"\u0438\u043c\u0438\", \"\u044b\u043c\u0438\", \"\u0435\u0433\u043e\", \"\u043e\u0433\u043e\", \"\u0435\u043c\u0443\", \"\u043e\u043c\u0443\", \"\u0435\u0435\", \"\u0438\u0435\",\n\t\t\"\u044b\u0435\", \"\u043e\u0435\", \"\u0435\u0439\", \"\u0438\u0439\", \"\u044b\u0439\", \"\u043e\u0439\", \"\u0435\u043c\", \"\u0438\u043c\", \"\u044b\u043c\",\n\t\t\"\u043e\u043c\", \"\u0438\u0445\", \"\u044b\u0445\", \"\u0443\u044e\", \"\u044e\u044e\", \"\u0430\u044f\", \"\u044f\u044f\", \"\u043e\u044e\", \"\u0435\u044e\",\n\t)\n\tif suffix != \"\" {\n\n\t\t// We found an adjective ending.  Remove optional participle endings.\n\t\t//\n\t\tnewSuffix, newSuffixRunes := word.FirstSuffixIn(word.RVstart, len(word.RS),\n\t\t\t\"\u0438\u0432\u0448\", \"\u044b\u0432\u0448\", \"\u0443\u044e\u0449\",\n\t\t\t\"\u0435\u043c\", \"\u043d\u043d\", \"\u0432\u0448\", \"\u044e\u0449\", \"\u0449\",\n\t\t)\n\t\tswitch newSuffix {\n\t\tcase \"\u0435\u043c\", \"\u043d\u043d\", \"\u0432\u0448\", \"\u044e\u0449\", \"\u0449\":\n\n\t\t\t// These are \"Group 1\" participle endings.\n\t\t\t// Group 1 endings must follow \u0430 (a) or \u044f (ia) in RV.\n\t\t\tif precededByARinRV(word, len(newSuffixRunes)) == false {\n\t\t\t\tnewSuffix = \"\"\n\t\t\t}\n\t\t}\n\n\t\tif newSuffix != \"\" {\n\t\t\tword.RemoveLastNRunes(len(newSuffixRunes))\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}", "language": "go", "code": "func removeAdjectivalEnding(word *snowballword.SnowballWord) bool {\n\n\t// Remove adjectival endings.  Start by looking for\n\t// an adjective ending.\n\t//\n\tsuffix, _ := word.RemoveFirstSuffixIn(word.RVstart,\n\t\t\"\u0438\u043c\u0438\", \"\u044b\u043c\u0438\", \"\u0435\u0433\u043e\", \"\u043e\u0433\u043e\", \"\u0435\u043c\u0443\", \"\u043e\u043c\u0443\", \"\u0435\u0435\", \"\u0438\u0435\",\n\t\t\"\u044b\u0435\", \"\u043e\u0435\", \"\u0435\u0439\", \"\u0438\u0439\", \"\u044b\u0439\", \"\u043e\u0439\", \"\u0435\u043c\", \"\u0438\u043c\", \"\u044b\u043c\",\n\t\t\"\u043e\u043c\", \"\u0438\u0445\", \"\u044b\u0445\", \"\u0443\u044e\", \"\u044e\u044e\", \"\u0430\u044f\", \"\u044f\u044f\", \"\u043e\u044e\", \"\u0435\u044e\",\n\t)\n\tif suffix != \"\" {\n\n\t\t// We found an adjective ending.  Remove optional participle endings.\n\t\t//\n\t\tnewSuffix, newSuffixRunes := word.FirstSuffixIn(word.RVstart, len(word.RS),\n\t\t\t\"\u0438\u0432\u0448\", \"\u044b\u0432\u0448\", \"\u0443\u044e\u0449\",\n\t\t\t\"\u0435\u043c\", \"\u043d\u043d\", \"\u0432\u0448\", \"\u044e\u0449\", \"\u0449\",\n\t\t)\n\t\tswitch newSuffix {\n\t\tcase \"\u0435\u043c\", \"\u043d\u043d\", \"\u0432\u0448\", \"\u044e\u0449\", \"\u0449\":\n\n\t\t\t// These are \"Group 1\" participle endings.\n\t\t\t// Group 1 endings must follow \u0430 (a) or \u044f (ia) in RV.\n\t\t\tif precededByARinRV(word, len(newSuffixRunes)) == false {\n\t\t\t\tnewSuffix = \"\"\n\t\t\t}\n\t\t}\n\n\t\tif newSuffix != \"\" {\n\t\t\tword.RemoveLastNRunes(len(newSuffixRunes))\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}", "code_tokens": ["func", "removeAdjectivalEnding", "(", "word", "*", "snowballword", ".", "SnowballWord", ")", "bool", "{", "// Remove adjectival endings.  Start by looking for", "// an adjective ending.", "//", "suffix", ",", "_", ":=", "word", ".", "RemoveFirstSuffixIn", "(", "word", ".", "RVstart", ",", "\"", "\"", "\u044b", "\u0438", "\u043e", "\"", " ", " ", "\"", "\u043c", "\u043c", "\u0443", ",", " ", "\"", "\u0435", "", "", "", "", "", "", "", "", "\"", " ", "\"", "\u0435", "\u0435", "\u0439", ",", "\"", ",", "\"", " ", "\"", "\u0439", "\u0435", "\u043c", ",", "\"", ",", "\"", "", "", "", "", "", "", "", "", "\"", " ", "\"", "\u0445", "\u044b", "\u0445", ",", "\"", ",", "\"", " ", "\"", "\u044f", "\u044f", "\u044f", ",", "\"", ",", "\"", "", "", "", "", "", "", "", "", ")", "\n", "if", "suffix", "!=", "\"", "\"", "{", "// We found an adjective ending.  Remove optional participle endings.", "//", "newSuffix", ",", "newSuffixRunes", ":=", "word", ".", "FirstSuffixIn", "(", "word", ".", "RVstart", ",", "len", "(", "word", ".", "RS", ")", ",", "\"", "\"", "\u044b", "\u0448", "\u0449", "\"", "", "", "", "\"", " ", "\"", "\u043d", "\u0432", "\u0448", ",", "\"", ",", "\"", "", "", "", "", "", ")", "\n", "switch", "newSuffix", "{", "case", "\"", " ", "\"", "\u043d", "\u0432", "\u0448", ",", "\"", ",", "\"", "", "", "", "", "", "// These are \"Group 1\" participle endings.", "// Group 1 endings must follow \u0430 (a) or \u044f (ia) in RV.", "if", "precededByARinRV", "(", "word", ",", "len", "(", "newSuffixRunes", ")", ")", "==", "false", "{", "newSuffix", "=", "\"", "\"", "\n", "}", "\n", "}", "\n\n", "if", "newSuffix", "!=", "\"", "\"", "{", "word", ".", "RemoveLastNRunes", "(", "len", "(", "newSuffixRunes", ")", ")", "\n", "}", "\n", "return", "true", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// Remove adjectival endings and return true if one was removed.\n//", "docstring_tokens": ["Remove", "adjectival", "endings", "and", "return", "true", "if", "one", "was", "removed", "."], "sha": "115fa8f6419dcfb9ec4653997b1c6803a5eff962", "url": "https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/russian/step1.go#L84-L118", "partition": "test"}
{"repo": "iron-io/functions_go", "path": "client/apps/put_apps_app_parameters.go", "func_name": "WithTimeout", "original_string": "func (o *PutAppsAppParams) WithTimeout(timeout time.Duration) *PutAppsAppParams {\n\to.SetTimeout(timeout)\n\treturn o\n}", "language": "go", "code": "func (o *PutAppsAppParams) WithTimeout(timeout time.Duration) *PutAppsAppParams {\n\to.SetTimeout(timeout)\n\treturn o\n}", "code_tokens": ["func", "(", "o", "*", "PutAppsAppParams", ")", "WithTimeout", "(", "timeout", "time", ".", "Duration", ")", "*", "PutAppsAppParams", "{", "o", ".", "SetTimeout", "(", "timeout", ")", "\n", "return", "o", "\n", "}"], "docstring": "// WithTimeout adds the timeout to the put apps app params", "docstring_tokens": ["WithTimeout", "adds", "the", "timeout", "to", "the", "put", "apps", "app", "params"], "sha": "91b84f5bbb17095bf1c7028ec6e70a3dc06a5893", "url": "https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/apps/put_apps_app_parameters.go#L71-L74", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "buffalo/cmd/fix/webpack.go", "func_name": "WebpackCheck", "original_string": "func WebpackCheck(r *Runner) error {\n\tfmt.Println(\"~~~ Checking webpack.config.js ~~~\")\n\n\tif !r.App.WithWebpack {\n\t\treturn nil\n\t}\n\n\tbox := webpack.Templates\n\n\tf, err := box.FindString(\"webpack.config.js.tmpl\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttmpl, err := template.New(\"webpack\").Parse(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbb := &bytes.Buffer{}\n\terr = tmpl.Execute(bb, map[string]interface{}{\n\t\t\"opts\": &webpack.Options{\n\t\t\tApp: r.App,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb, err := ioutil.ReadFile(\"webpack.config.js\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif string(b) == bb.String() {\n\t\treturn nil\n\t}\n\n\tif !ask(\"Your webpack.config.js file is different from the latest Buffalo template.\\nWould you like to replace yours with the latest template?\") {\n\t\tfmt.Println(\"\\tSkipping webpack.config.js\")\n\t\treturn nil\n\t}\n\n\twf, err := os.Create(\"webpack.config.js\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = wf.Write(bb.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn wf.Close()\n}", "language": "go", "code": "func WebpackCheck(r *Runner) error {\n\tfmt.Println(\"~~~ Checking webpack.config.js ~~~\")\n\n\tif !r.App.WithWebpack {\n\t\treturn nil\n\t}\n\n\tbox := webpack.Templates\n\n\tf, err := box.FindString(\"webpack.config.js.tmpl\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttmpl, err := template.New(\"webpack\").Parse(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbb := &bytes.Buffer{}\n\terr = tmpl.Execute(bb, map[string]interface{}{\n\t\t\"opts\": &webpack.Options{\n\t\t\tApp: r.App,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb, err := ioutil.ReadFile(\"webpack.config.js\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif string(b) == bb.String() {\n\t\treturn nil\n\t}\n\n\tif !ask(\"Your webpack.config.js file is different from the latest Buffalo template.\\nWould you like to replace yours with the latest template?\") {\n\t\tfmt.Println(\"\\tSkipping webpack.config.js\")\n\t\treturn nil\n\t}\n\n\twf, err := os.Create(\"webpack.config.js\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = wf.Write(bb.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn wf.Close()\n}", "code_tokens": ["func", "WebpackCheck", "(", "r", "*", "Runner", ")", "error", "{", "fmt", ".", "Println", "(", "\"", "\"", ")", "\n\n", "if", "!", "r", ".", "App", ".", "WithWebpack", "{", "return", "nil", "\n", "}", "\n\n", "box", ":=", "webpack", ".", "Templates", "\n\n", "f", ",", "err", ":=", "box", ".", "FindString", "(", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "tmpl", ",", "err", ":=", "template", ".", "New", "(", "\"", "\"", ")", ".", "Parse", "(", "f", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "bb", ":=", "&", "bytes", ".", "Buffer", "{", "}", "\n", "err", "=", "tmpl", ".", "Execute", "(", "bb", ",", "map", "[", "string", "]", "interface", "{", "}", "{", "\"", "\"", ":", "&", "webpack", ".", "Options", "{", "App", ":", "r", ".", "App", ",", "}", ",", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "b", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "string", "(", "b", ")", "==", "bb", ".", "String", "(", ")", "{", "return", "nil", "\n", "}", "\n\n", "if", "!", "ask", "(", "\"", "\\n", "\"", ")", "{", "fmt", ".", "Println", "(", "\"", "\\t", "\"", ")", "\n", "return", "nil", "\n", "}", "\n\n", "wf", ",", "err", ":=", "os", ".", "Create", "(", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "_", ",", "err", "=", "wf", ".", "Write", "(", "bb", ".", "Bytes", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "return", "wf", ".", "Close", "(", ")", "\n", "}"], "docstring": "// WebpackCheck will compare the current default Buffalo\n// webpack.config.js against the applications webpack.config.js. If they are\n// different you have the option to overwrite the existing webpack.config.js\n// file with the new one.", "docstring_tokens": ["WebpackCheck", "will", "compare", "the", "current", "default", "Buffalo", "webpack", ".", "config", ".", "js", "against", "the", "applications", "webpack", ".", "config", ".", "js", ".", "If", "they", "are", "different", "you", "have", "the", "option", "to", "overwrite", "the", "existing", "webpack", ".", "config", ".", "js", "file", "with", "the", "new", "one", "."], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/buffalo/cmd/fix/webpack.go#L17-L69", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "build/manage_offer.go", "func_name": "MutateManageOffer", "original_string": "func (m OfferID) MutateManageOffer(o interface{}) (err error) {\n\tswitch o := o.(type) {\n\tdefault:\n\t\terr = errors.New(\"Unexpected operation type\")\n\tcase *xdr.ManageOfferOp:\n\t\to.OfferId = xdr.Uint64(m)\n\t}\n\treturn\n}", "language": "go", "code": "func (m OfferID) MutateManageOffer(o interface{}) (err error) {\n\tswitch o := o.(type) {\n\tdefault:\n\t\terr = errors.New(\"Unexpected operation type\")\n\tcase *xdr.ManageOfferOp:\n\t\to.OfferId = xdr.Uint64(m)\n\t}\n\treturn\n}", "code_tokens": ["func", "(", "m", "OfferID", ")", "MutateManageOffer", "(", "o", "interface", "{", "}", ")", "(", "err", "error", ")", "{", "switch", "o", ":=", "o", ".", "(", "type", ")", "{", "default", ":", "err", "=", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "case", "*", "xdr", ".", "ManageOfferOp", ":", "o", ".", "OfferId", "=", "xdr", ".", "Uint64", "(", "m", ")", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// MutateManageOffer for OfferID sets the ManageOfferOp's OfferID field", "docstring_tokens": ["MutateManageOffer", "for", "OfferID", "sets", "the", "ManageOfferOp", "s", "OfferID", "field"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/manage_offer.go#L92-L100", "partition": "test"}
{"repo": "256dpi/fire", "path": "coal/indexer.go", "func_name": "Add", "original_string": "func (i *Indexer) Add(model Model, unique bool, expireAfter time.Duration, fields ...string) {\n\t// construct key from fields\n\tvar key []string\n\tfor _, f := range fields {\n\t\tkey = append(key, F(model, f))\n\t}\n\n\t// add index\n\ti.AddRaw(C(model), mgo.Index{\n\t\tKey:         key,\n\t\tUnique:      unique,\n\t\tExpireAfter: expireAfter,\n\t\tBackground:  true,\n\t})\n}", "language": "go", "code": "func (i *Indexer) Add(model Model, unique bool, expireAfter time.Duration, fields ...string) {\n\t// construct key from fields\n\tvar key []string\n\tfor _, f := range fields {\n\t\tkey = append(key, F(model, f))\n\t}\n\n\t// add index\n\ti.AddRaw(C(model), mgo.Index{\n\t\tKey:         key,\n\t\tUnique:      unique,\n\t\tExpireAfter: expireAfter,\n\t\tBackground:  true,\n\t})\n}", "code_tokens": ["func", "(", "i", "*", "Indexer", ")", "Add", "(", "model", "Model", ",", "unique", "bool", ",", "expireAfter", "time", ".", "Duration", ",", "fields", "...", "string", ")", "{", "// construct key from fields", "var", "key", "[", "]", "string", "\n", "for", "_", ",", "f", ":=", "range", "fields", "{", "key", "=", "append", "(", "key", ",", "F", "(", "model", ",", "f", ")", ")", "\n", "}", "\n\n", "// add index", "i", ".", "AddRaw", "(", "C", "(", "model", ")", ",", "mgo", ".", "Index", "{", "Key", ":", "key", ",", "Unique", ":", "unique", ",", "ExpireAfter", ":", "expireAfter", ",", "Background", ":", "true", ",", "}", ")", "\n", "}"], "docstring": "// Add will add an index to the internal index list. Fields that are prefixed\n// with a dash will result in an descending index. See the MongoDB documentation\n// for more details.", "docstring_tokens": ["Add", "will", "add", "an", "index", "to", "the", "internal", "index", "list", ".", "Fields", "that", "are", "prefixed", "with", "a", "dash", "will", "result", "in", "an", "descending", "index", ".", "See", "the", "MongoDB", "documentation", "for", "more", "details", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/coal/indexer.go#L28-L42", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/types/urlsmap.go", "func_name": "URLs", "original_string": "func (c URLsMap) URLs() []string {\n\tvar urls []string\n\tfor _, us := range c {\n\t\tfor _, u := range us {\n\t\t\turls = append(urls, u.String())\n\t\t}\n\t}\n\tsort.Strings(urls)\n\treturn urls\n}", "language": "go", "code": "func (c URLsMap) URLs() []string {\n\tvar urls []string\n\tfor _, us := range c {\n\t\tfor _, u := range us {\n\t\t\turls = append(urls, u.String())\n\t\t}\n\t}\n\tsort.Strings(urls)\n\treturn urls\n}", "code_tokens": ["func", "(", "c", "URLsMap", ")", "URLs", "(", ")", "[", "]", "string", "{", "var", "urls", "[", "]", "string", "\n", "for", "_", ",", "us", ":=", "range", "c", "{", "for", "_", ",", "u", ":=", "range", "us", "{", "urls", "=", "append", "(", "urls", ",", "u", ".", "String", "(", ")", ")", "\n", "}", "\n", "}", "\n", "sort", ".", "Strings", "(", "urls", ")", "\n", "return", "urls", "\n", "}"], "docstring": "// URLs returns a list of all URLs.\n// The returned list is sorted in ascending lexicographical order.", "docstring_tokens": ["URLs", "returns", "a", "list", "of", "all", "URLs", ".", "The", "returned", "list", "is", "sorted", "in", "ascending", "lexicographical", "order", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/types/urlsmap.go#L71-L80", "partition": "test"}
{"repo": "hashicorp/raft", "path": "api.go", "func_name": "Restore", "original_string": "func (r *Raft) Restore(meta *SnapshotMeta, reader io.Reader, timeout time.Duration) error {\n\tmetrics.IncrCounter([]string{\"raft\", \"restore\"}, 1)\n\tvar timer <-chan time.Time\n\tif timeout > 0 {\n\t\ttimer = time.After(timeout)\n\t}\n\n\t// Perform the restore.\n\trestore := &userRestoreFuture{\n\t\tmeta:   meta,\n\t\treader: reader,\n\t}\n\trestore.init()\n\tselect {\n\tcase <-timer:\n\t\treturn ErrEnqueueTimeout\n\tcase <-r.shutdownCh:\n\t\treturn ErrRaftShutdown\n\tcase r.userRestoreCh <- restore:\n\t\t// If the restore is ingested then wait for it to complete.\n\t\tif err := restore.Error(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Apply a no-op log entry. Waiting for this allows us to wait until the\n\t// followers have gotten the restore and replicated at least this new\n\t// entry, which shows that we've also faulted and installed the\n\t// snapshot with the contents of the restore.\n\tnoop := &logFuture{\n\t\tlog: Log{\n\t\t\tType: LogNoop,\n\t\t},\n\t}\n\tnoop.init()\n\tselect {\n\tcase <-timer:\n\t\treturn ErrEnqueueTimeout\n\tcase <-r.shutdownCh:\n\t\treturn ErrRaftShutdown\n\tcase r.applyCh <- noop:\n\t\treturn noop.Error()\n\t}\n}", "language": "go", "code": "func (r *Raft) Restore(meta *SnapshotMeta, reader io.Reader, timeout time.Duration) error {\n\tmetrics.IncrCounter([]string{\"raft\", \"restore\"}, 1)\n\tvar timer <-chan time.Time\n\tif timeout > 0 {\n\t\ttimer = time.After(timeout)\n\t}\n\n\t// Perform the restore.\n\trestore := &userRestoreFuture{\n\t\tmeta:   meta,\n\t\treader: reader,\n\t}\n\trestore.init()\n\tselect {\n\tcase <-timer:\n\t\treturn ErrEnqueueTimeout\n\tcase <-r.shutdownCh:\n\t\treturn ErrRaftShutdown\n\tcase r.userRestoreCh <- restore:\n\t\t// If the restore is ingested then wait for it to complete.\n\t\tif err := restore.Error(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Apply a no-op log entry. Waiting for this allows us to wait until the\n\t// followers have gotten the restore and replicated at least this new\n\t// entry, which shows that we've also faulted and installed the\n\t// snapshot with the contents of the restore.\n\tnoop := &logFuture{\n\t\tlog: Log{\n\t\t\tType: LogNoop,\n\t\t},\n\t}\n\tnoop.init()\n\tselect {\n\tcase <-timer:\n\t\treturn ErrEnqueueTimeout\n\tcase <-r.shutdownCh:\n\t\treturn ErrRaftShutdown\n\tcase r.applyCh <- noop:\n\t\treturn noop.Error()\n\t}\n}", "code_tokens": ["func", "(", "r", "*", "Raft", ")", "Restore", "(", "meta", "*", "SnapshotMeta", ",", "reader", "io", ".", "Reader", ",", "timeout", "time", ".", "Duration", ")", "error", "{", "metrics", ".", "IncrCounter", "(", "[", "]", "string", "{", "\"", "\"", ",", "\"", "\"", "}", ",", "1", ")", "\n", "var", "timer", "<-", "chan", "time", ".", "Time", "\n", "if", "timeout", ">", "0", "{", "timer", "=", "time", ".", "After", "(", "timeout", ")", "\n", "}", "\n\n", "// Perform the restore.", "restore", ":=", "&", "userRestoreFuture", "{", "meta", ":", "meta", ",", "reader", ":", "reader", ",", "}", "\n", "restore", ".", "init", "(", ")", "\n", "select", "{", "case", "<-", "timer", ":", "return", "ErrEnqueueTimeout", "\n", "case", "<-", "r", ".", "shutdownCh", ":", "return", "ErrRaftShutdown", "\n", "case", "r", ".", "userRestoreCh", "<-", "restore", ":", "// If the restore is ingested then wait for it to complete.", "if", "err", ":=", "restore", ".", "Error", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n\n", "// Apply a no-op log entry. Waiting for this allows us to wait until the", "// followers have gotten the restore and replicated at least this new", "// entry, which shows that we've also faulted and installed the", "// snapshot with the contents of the restore.", "noop", ":=", "&", "logFuture", "{", "log", ":", "Log", "{", "Type", ":", "LogNoop", ",", "}", ",", "}", "\n", "noop", ".", "init", "(", ")", "\n", "select", "{", "case", "<-", "timer", ":", "return", "ErrEnqueueTimeout", "\n", "case", "<-", "r", ".", "shutdownCh", ":", "return", "ErrRaftShutdown", "\n", "case", "r", ".", "applyCh", "<-", "noop", ":", "return", "noop", ".", "Error", "(", ")", "\n", "}", "\n", "}"], "docstring": "// Restore is used to manually force Raft to consume an external snapshot, such\n// as if restoring from a backup. We will use the current Raft configuration,\n// not the one from the snapshot, so that we can restore into a new cluster. We\n// will also use the higher of the index of the snapshot, or the current index,\n// and then add 1 to that, so we force a new state with a hole in the Raft log,\n// so that the snapshot will be sent to followers and used for any new joiners.\n// This can only be run on the leader, and blocks until the restore is complete\n// or an error occurs.\n//\n// WARNING! This operation has the leader take on the state of the snapshot and\n// then sets itself up so that it replicates that to its followers though the\n// install snapshot process. This involves a potentially dangerous period where\n// the leader commits ahead of its followers, so should only be used for disaster\n// recovery into a fresh cluster, and should not be used in normal operations.", "docstring_tokens": ["Restore", "is", "used", "to", "manually", "force", "Raft", "to", "consume", "an", "external", "snapshot", "such", "as", "if", "restoring", "from", "a", "backup", ".", "We", "will", "use", "the", "current", "Raft", "configuration", "not", "the", "one", "from", "the", "snapshot", "so", "that", "we", "can", "restore", "into", "a", "new", "cluster", ".", "We", "will", "also", "use", "the", "higher", "of", "the", "index", "of", "the", "snapshot", "or", "the", "current", "index", "and", "then", "add", "1", "to", "that", "so", "we", "force", "a", "new", "state", "with", "a", "hole", "in", "the", "Raft", "log", "so", "that", "the", "snapshot", "will", "be", "sent", "to", "followers", "and", "used", "for", "any", "new", "joiners", ".", "This", "can", "only", "be", "run", "on", "the", "leader", "and", "blocks", "until", "the", "restore", "is", "complete", "or", "an", "error", "occurs", ".", "WARNING!", "This", "operation", "has", "the", "leader", "take", "on", "the", "state", "of", "the", "snapshot", "and", "then", "sets", "itself", "up", "so", "that", "it", "replicates", "that", "to", "its", "followers", "though", "the", "install", "snapshot", "process", ".", "This", "involves", "a", "potentially", "dangerous", "period", "where", "the", "leader", "commits", "ahead", "of", "its", "followers", "so", "should", "only", "be", "used", "for", "disaster", "recovery", "into", "a", "fresh", "cluster", "and", "should", "not", "be", "used", "in", "normal", "operations", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/api.go#L842-L885", "partition": "test"}
{"repo": "jhillyerd/enmime", "path": "part.go", "func_name": "AddChild", "original_string": "func (p *Part) AddChild(child *Part) {\n\tif p == child {\n\t\t// Prevent paradox.\n\t\treturn\n\t}\n\tif p != nil {\n\t\tif p.FirstChild == nil {\n\t\t\t// Make it the first child.\n\t\t\tp.FirstChild = child\n\t\t} else {\n\t\t\t// Append to sibling chain.\n\t\t\tcurrent := p.FirstChild\n\t\t\tfor current.NextSibling != nil {\n\t\t\t\tcurrent = current.NextSibling\n\t\t\t}\n\t\t\tif current == child {\n\t\t\t\t// Prevent infinite loop.\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent.NextSibling = child\n\t\t}\n\t}\n\t// Update all new first-level children Parent pointers.\n\tfor c := child; c != nil; c = c.NextSibling {\n\t\tif c == c.NextSibling {\n\t\t\t// Prevent infinite loop.\n\t\t\treturn\n\t\t}\n\t\tc.Parent = p\n\t}\n}", "language": "go", "code": "func (p *Part) AddChild(child *Part) {\n\tif p == child {\n\t\t// Prevent paradox.\n\t\treturn\n\t}\n\tif p != nil {\n\t\tif p.FirstChild == nil {\n\t\t\t// Make it the first child.\n\t\t\tp.FirstChild = child\n\t\t} else {\n\t\t\t// Append to sibling chain.\n\t\t\tcurrent := p.FirstChild\n\t\t\tfor current.NextSibling != nil {\n\t\t\t\tcurrent = current.NextSibling\n\t\t\t}\n\t\t\tif current == child {\n\t\t\t\t// Prevent infinite loop.\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent.NextSibling = child\n\t\t}\n\t}\n\t// Update all new first-level children Parent pointers.\n\tfor c := child; c != nil; c = c.NextSibling {\n\t\tif c == c.NextSibling {\n\t\t\t// Prevent infinite loop.\n\t\t\treturn\n\t\t}\n\t\tc.Parent = p\n\t}\n}", "code_tokens": ["func", "(", "p", "*", "Part", ")", "AddChild", "(", "child", "*", "Part", ")", "{", "if", "p", "==", "child", "{", "// Prevent paradox.", "return", "\n", "}", "\n", "if", "p", "!=", "nil", "{", "if", "p", ".", "FirstChild", "==", "nil", "{", "// Make it the first child.", "p", ".", "FirstChild", "=", "child", "\n", "}", "else", "{", "// Append to sibling chain.", "current", ":=", "p", ".", "FirstChild", "\n", "for", "current", ".", "NextSibling", "!=", "nil", "{", "current", "=", "current", ".", "NextSibling", "\n", "}", "\n", "if", "current", "==", "child", "{", "// Prevent infinite loop.", "return", "\n", "}", "\n", "current", ".", "NextSibling", "=", "child", "\n", "}", "\n", "}", "\n", "// Update all new first-level children Parent pointers.", "for", "c", ":=", "child", ";", "c", "!=", "nil", ";", "c", "=", "c", ".", "NextSibling", "{", "if", "c", "==", "c", ".", "NextSibling", "{", "// Prevent infinite loop.", "return", "\n", "}", "\n", "c", ".", "Parent", "=", "p", "\n", "}", "\n", "}"], "docstring": "// AddChild adds a child part to either FirstChild or the end of the children NextSibling chain.\n// The child may have siblings and children attached.  This method will set the Parent field on\n// child and all its siblings. Safe to call on nil.", "docstring_tokens": ["AddChild", "adds", "a", "child", "part", "to", "either", "FirstChild", "or", "the", "end", "of", "the", "children", "NextSibling", "chain", ".", "The", "child", "may", "have", "siblings", "and", "children", "attached", ".", "This", "method", "will", "set", "the", "Parent", "field", "on", "child", "and", "all", "its", "siblings", ".", "Safe", "to", "call", "on", "nil", "."], "sha": "874cc30e023f36bd1df525716196887b0f04851b", "url": "https://github.com/jhillyerd/enmime/blob/874cc30e023f36bd1df525716196887b0f04851b/part.go#L57-L87", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/apis/prowjobs/v1/zz_generated.deepcopy.go", "func_name": "DeepCopy", "original_string": "func (in *ProwJobStatus) DeepCopy() *ProwJobStatus {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ProwJobStatus)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "language": "go", "code": "func (in *ProwJobStatus) DeepCopy() *ProwJobStatus {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(ProwJobStatus)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "code_tokens": ["func", "(", "in", "*", "ProwJobStatus", ")", "DeepCopy", "(", ")", "*", "ProwJobStatus", "{", "if", "in", "==", "nil", "{", "return", "nil", "\n", "}", "\n", "out", ":=", "new", "(", "ProwJobStatus", ")", "\n", "in", ".", "DeepCopyInto", "(", "out", ")", "\n", "return", "out", "\n", "}"], "docstring": "// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProwJobStatus.", "docstring_tokens": ["DeepCopy", "is", "an", "autogenerated", "deepcopy", "function", "copying", "the", "receiver", "creating", "a", "new", "ProwJobStatus", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/apis/prowjobs/v1/zz_generated.deepcopy.go#L254-L261", "partition": "test"}
{"repo": "256dpi/fire", "path": "coal/helpers.go", "func_name": "Require", "original_string": "func Require(m Model, flags ...string) {\n\t// check all flags\n\tfor _, f := range flags {\n\t\tL(m, f, true)\n\t}\n}", "language": "go", "code": "func Require(m Model, flags ...string) {\n\t// check all flags\n\tfor _, f := range flags {\n\t\tL(m, f, true)\n\t}\n}", "code_tokens": ["func", "Require", "(", "m", "Model", ",", "flags", "...", "string", ")", "{", "// check all flags", "for", "_", ",", "f", ":=", "range", "flags", "{", "L", "(", "m", ",", "f", ",", "true", ")", "\n", "}", "\n", "}"], "docstring": "// Require will check if the specified flags are set on the specified model and\n// panic if one is missing.", "docstring_tokens": ["Require", "will", "check", "if", "the", "specified", "flags", "are", "set", "on", "the", "specified", "model", "and", "panic", "if", "one", "is", "missing", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/coal/helpers.go#L147-L152", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "wal/decoder.go", "func_name": "isTornEntry", "original_string": "func (d *decoder) isTornEntry(data []byte) bool {\n\tif len(d.brs) != 1 {\n\t\treturn false\n\t}\n\n\tfileOff := d.lastValidOff + frameSizeBytes\n\tcurOff := 0\n\tchunks := [][]byte{}\n\t// split data on sector boundaries\n\tfor curOff < len(data) {\n\t\tchunkLen := int(minSectorSize - (fileOff % minSectorSize))\n\t\tif chunkLen > len(data)-curOff {\n\t\t\tchunkLen = len(data) - curOff\n\t\t}\n\t\tchunks = append(chunks, data[curOff:curOff+chunkLen])\n\t\tfileOff += int64(chunkLen)\n\t\tcurOff += chunkLen\n\t}\n\n\t// if any data for a sector chunk is all 0, it's a torn write\n\tfor _, sect := range chunks {\n\t\tisZero := true\n\t\tfor _, v := range sect {\n\t\t\tif v != 0 {\n\t\t\t\tisZero = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isZero {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "language": "go", "code": "func (d *decoder) isTornEntry(data []byte) bool {\n\tif len(d.brs) != 1 {\n\t\treturn false\n\t}\n\n\tfileOff := d.lastValidOff + frameSizeBytes\n\tcurOff := 0\n\tchunks := [][]byte{}\n\t// split data on sector boundaries\n\tfor curOff < len(data) {\n\t\tchunkLen := int(minSectorSize - (fileOff % minSectorSize))\n\t\tif chunkLen > len(data)-curOff {\n\t\t\tchunkLen = len(data) - curOff\n\t\t}\n\t\tchunks = append(chunks, data[curOff:curOff+chunkLen])\n\t\tfileOff += int64(chunkLen)\n\t\tcurOff += chunkLen\n\t}\n\n\t// if any data for a sector chunk is all 0, it's a torn write\n\tfor _, sect := range chunks {\n\t\tisZero := true\n\t\tfor _, v := range sect {\n\t\t\tif v != 0 {\n\t\t\t\tisZero = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isZero {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "code_tokens": ["func", "(", "d", "*", "decoder", ")", "isTornEntry", "(", "data", "[", "]", "byte", ")", "bool", "{", "if", "len", "(", "d", ".", "brs", ")", "!=", "1", "{", "return", "false", "\n", "}", "\n\n", "fileOff", ":=", "d", ".", "lastValidOff", "+", "frameSizeBytes", "\n", "curOff", ":=", "0", "\n", "chunks", ":=", "[", "]", "[", "]", "byte", "{", "}", "\n", "// split data on sector boundaries", "for", "curOff", "<", "len", "(", "data", ")", "{", "chunkLen", ":=", "int", "(", "minSectorSize", "-", "(", "fileOff", "%", "minSectorSize", ")", ")", "\n", "if", "chunkLen", ">", "len", "(", "data", ")", "-", "curOff", "{", "chunkLen", "=", "len", "(", "data", ")", "-", "curOff", "\n", "}", "\n", "chunks", "=", "append", "(", "chunks", ",", "data", "[", "curOff", ":", "curOff", "+", "chunkLen", "]", ")", "\n", "fileOff", "+=", "int64", "(", "chunkLen", ")", "\n", "curOff", "+=", "chunkLen", "\n", "}", "\n\n", "// if any data for a sector chunk is all 0, it's a torn write", "for", "_", ",", "sect", ":=", "range", "chunks", "{", "isZero", ":=", "true", "\n", "for", "_", ",", "v", ":=", "range", "sect", "{", "if", "v", "!=", "0", "{", "isZero", "=", "false", "\n", "break", "\n", "}", "\n", "}", "\n", "if", "isZero", "{", "return", "true", "\n", "}", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// isTornEntry determines whether the last entry of the WAL was partially written\n// and corrupted because of a torn write.", "docstring_tokens": ["isTornEntry", "determines", "whether", "the", "last", "entry", "of", "the", "WAL", "was", "partially", "written", "and", "corrupted", "because", "of", "a", "torn", "write", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/wal/decoder.go#L127-L160", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "levels.go", "func_name": "dropTree", "original_string": "func (s *levelsController) dropTree() (int, error) {\n\t// First pick all tables, so we can create a manifest changelog.\n\tvar all []*table.Table\n\tfor _, l := range s.levels {\n\t\tl.RLock()\n\t\tall = append(all, l.tables...)\n\t\tl.RUnlock()\n\t}\n\tif len(all) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Generate the manifest changes.\n\tchanges := []*pb.ManifestChange{}\n\tfor _, table := range all {\n\t\tchanges = append(changes, newDeleteChange(table.ID()))\n\t}\n\tchangeSet := pb.ManifestChangeSet{Changes: changes}\n\tif err := s.kv.manifest.addChanges(changeSet.Changes); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Now that manifest has been successfully written, we can delete the tables.\n\tfor _, l := range s.levels {\n\t\tl.Lock()\n\t\tl.totalSize = 0\n\t\tl.tables = l.tables[:0]\n\t\tl.Unlock()\n\t}\n\tfor _, table := range all {\n\t\tif err := table.DecrRef(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn len(all), nil\n}", "language": "go", "code": "func (s *levelsController) dropTree() (int, error) {\n\t// First pick all tables, so we can create a manifest changelog.\n\tvar all []*table.Table\n\tfor _, l := range s.levels {\n\t\tl.RLock()\n\t\tall = append(all, l.tables...)\n\t\tl.RUnlock()\n\t}\n\tif len(all) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Generate the manifest changes.\n\tchanges := []*pb.ManifestChange{}\n\tfor _, table := range all {\n\t\tchanges = append(changes, newDeleteChange(table.ID()))\n\t}\n\tchangeSet := pb.ManifestChangeSet{Changes: changes}\n\tif err := s.kv.manifest.addChanges(changeSet.Changes); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Now that manifest has been successfully written, we can delete the tables.\n\tfor _, l := range s.levels {\n\t\tl.Lock()\n\t\tl.totalSize = 0\n\t\tl.tables = l.tables[:0]\n\t\tl.Unlock()\n\t}\n\tfor _, table := range all {\n\t\tif err := table.DecrRef(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn len(all), nil\n}", "code_tokens": ["func", "(", "s", "*", "levelsController", ")", "dropTree", "(", ")", "(", "int", ",", "error", ")", "{", "// First pick all tables, so we can create a manifest changelog.", "var", "all", "[", "]", "*", "table", ".", "Table", "\n", "for", "_", ",", "l", ":=", "range", "s", ".", "levels", "{", "l", ".", "RLock", "(", ")", "\n", "all", "=", "append", "(", "all", ",", "l", ".", "tables", "...", ")", "\n", "l", ".", "RUnlock", "(", ")", "\n", "}", "\n", "if", "len", "(", "all", ")", "==", "0", "{", "return", "0", ",", "nil", "\n", "}", "\n\n", "// Generate the manifest changes.", "changes", ":=", "[", "]", "*", "pb", ".", "ManifestChange", "{", "}", "\n", "for", "_", ",", "table", ":=", "range", "all", "{", "changes", "=", "append", "(", "changes", ",", "newDeleteChange", "(", "table", ".", "ID", "(", ")", ")", ")", "\n", "}", "\n", "changeSet", ":=", "pb", ".", "ManifestChangeSet", "{", "Changes", ":", "changes", "}", "\n", "if", "err", ":=", "s", ".", "kv", ".", "manifest", ".", "addChanges", "(", "changeSet", ".", "Changes", ")", ";", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n\n", "// Now that manifest has been successfully written, we can delete the tables.", "for", "_", ",", "l", ":=", "range", "s", ".", "levels", "{", "l", ".", "Lock", "(", ")", "\n", "l", ".", "totalSize", "=", "0", "\n", "l", ".", "tables", "=", "l", ".", "tables", "[", ":", "0", "]", "\n", "l", ".", "Unlock", "(", ")", "\n", "}", "\n", "for", "_", ",", "table", ":=", "range", "all", "{", "if", "err", ":=", "table", ".", "DecrRef", "(", ")", ";", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n", "}", "\n", "return", "len", "(", "all", ")", ",", "nil", "\n", "}"], "docstring": "// dropTree picks all tables from all levels, creates a manifest changeset,\n// applies it, and then decrements the refs of these tables, which would result\n// in their deletion.", "docstring_tokens": ["dropTree", "picks", "all", "tables", "from", "all", "levels", "creates", "a", "manifest", "changeset", "applies", "it", "and", "then", "decrements", "the", "refs", "of", "these", "tables", "which", "would", "result", "in", "their", "deletion", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/levels.go#L222-L257", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "y/iterator.go", "func_name": "Key", "original_string": "func (s *MergeIterator) Key() []byte {\n\tif len(s.h) == 0 {\n\t\treturn nil\n\t}\n\treturn s.h[0].itr.Key()\n}", "language": "go", "code": "func (s *MergeIterator) Key() []byte {\n\tif len(s.h) == 0 {\n\t\treturn nil\n\t}\n\treturn s.h[0].itr.Key()\n}", "code_tokens": ["func", "(", "s", "*", "MergeIterator", ")", "Key", "(", ")", "[", "]", "byte", "{", "if", "len", "(", "s", ".", "h", ")", "==", "0", "{", "return", "nil", "\n", "}", "\n", "return", "s", ".", "h", "[", "0", "]", ".", "itr", ".", "Key", "(", ")", "\n", "}"], "docstring": "// Key returns the key associated with the current iterator", "docstring_tokens": ["Key", "returns", "the", "key", "associated", "with", "the", "current", "iterator"], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/y/iterator.go#L194-L199", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "robots/coverage/downloader/downloader.go", "func_name": "listGcsObjects", "original_string": "func listGcsObjects(ctx context.Context, client *storage.Client, bucketName, prefix, delim string) (\n\t[]string, error) {\n\n\tvar objects []string\n\tit := client.Bucket(bucketName).Objects(ctx, &storage.Query{\n\t\tPrefix:    prefix,\n\t\tDelimiter: delim,\n\t})\n\n\tfor {\n\t\tattrs, err := it.Next()\n\t\tif err == iterator.Done {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn objects, fmt.Errorf(\"error iterating: %v\", err)\n\t\t}\n\n\t\tif attrs.Prefix != \"\" {\n\t\t\tobjects = append(objects, path.Base(attrs.Prefix))\n\t\t}\n\t}\n\tlogrus.Info(\"end of listGcsObjects(...)\")\n\treturn objects, nil\n}", "language": "go", "code": "func listGcsObjects(ctx context.Context, client *storage.Client, bucketName, prefix, delim string) (\n\t[]string, error) {\n\n\tvar objects []string\n\tit := client.Bucket(bucketName).Objects(ctx, &storage.Query{\n\t\tPrefix:    prefix,\n\t\tDelimiter: delim,\n\t})\n\n\tfor {\n\t\tattrs, err := it.Next()\n\t\tif err == iterator.Done {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn objects, fmt.Errorf(\"error iterating: %v\", err)\n\t\t}\n\n\t\tif attrs.Prefix != \"\" {\n\t\t\tobjects = append(objects, path.Base(attrs.Prefix))\n\t\t}\n\t}\n\tlogrus.Info(\"end of listGcsObjects(...)\")\n\treturn objects, nil\n}", "code_tokens": ["func", "listGcsObjects", "(", "ctx", "context", ".", "Context", ",", "client", "*", "storage", ".", "Client", ",", "bucketName", ",", "prefix", ",", "delim", "string", ")", "(", "[", "]", "string", ",", "error", ")", "{", "var", "objects", "[", "]", "string", "\n", "it", ":=", "client", ".", "Bucket", "(", "bucketName", ")", ".", "Objects", "(", "ctx", ",", "&", "storage", ".", "Query", "{", "Prefix", ":", "prefix", ",", "Delimiter", ":", "delim", ",", "}", ")", "\n\n", "for", "{", "attrs", ",", "err", ":=", "it", ".", "Next", "(", ")", "\n", "if", "err", "==", "iterator", ".", "Done", "{", "break", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "return", "objects", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "if", "attrs", ".", "Prefix", "!=", "\"", "\"", "{", "objects", "=", "append", "(", "objects", ",", "path", ".", "Base", "(", "attrs", ".", "Prefix", ")", ")", "\n", "}", "\n", "}", "\n", "logrus", ".", "Info", "(", "\"", "\"", ")", "\n", "return", "objects", ",", "nil", "\n", "}"], "docstring": "//listGcsObjects get the slice of gcs objects under a given path", "docstring_tokens": ["listGcsObjects", "get", "the", "slice", "of", "gcs", "objects", "under", "a", "given", "path"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/robots/coverage/downloader/downloader.go#L41-L65", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "WithPrintBackground", "original_string": "func (p PrintToPDFParams) WithPrintBackground(printBackground bool) *PrintToPDFParams {\n\tp.PrintBackground = printBackground\n\treturn &p\n}", "language": "go", "code": "func (p PrintToPDFParams) WithPrintBackground(printBackground bool) *PrintToPDFParams {\n\tp.PrintBackground = printBackground\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "PrintToPDFParams", ")", "WithPrintBackground", "(", "printBackground", "bool", ")", "*", "PrintToPDFParams", "{", "p", ".", "PrintBackground", "=", "printBackground", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithPrintBackground print background graphics. Defaults to false.", "docstring_tokens": ["WithPrintBackground", "print", "background", "graphics", ".", "Defaults", "to", "false", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L698-L701", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "gossip.go", "func_name": "newGossipSender", "original_string": "func newGossipSender(\n\tmakeMsg func(msg []byte) protocolMsg,\n\tmakeBroadcastMsg func(srcName PeerName, msg []byte) protocolMsg,\n\tsender protocolSender,\n\tstop <-chan struct{},\n) *gossipSender {\n\tmore := make(chan struct{}, 1)\n\tflush := make(chan chan<- bool)\n\ts := &gossipSender{\n\t\tmakeMsg:          makeMsg,\n\t\tmakeBroadcastMsg: makeBroadcastMsg,\n\t\tsender:           sender,\n\t\tbroadcasts:       make(map[PeerName]GossipData),\n\t\tmore:             more,\n\t\tflush:            flush,\n\t}\n\tgo s.run(stop, more, flush)\n\treturn s\n}", "language": "go", "code": "func newGossipSender(\n\tmakeMsg func(msg []byte) protocolMsg,\n\tmakeBroadcastMsg func(srcName PeerName, msg []byte) protocolMsg,\n\tsender protocolSender,\n\tstop <-chan struct{},\n) *gossipSender {\n\tmore := make(chan struct{}, 1)\n\tflush := make(chan chan<- bool)\n\ts := &gossipSender{\n\t\tmakeMsg:          makeMsg,\n\t\tmakeBroadcastMsg: makeBroadcastMsg,\n\t\tsender:           sender,\n\t\tbroadcasts:       make(map[PeerName]GossipData),\n\t\tmore:             more,\n\t\tflush:            flush,\n\t}\n\tgo s.run(stop, more, flush)\n\treturn s\n}", "code_tokens": ["func", "newGossipSender", "(", "makeMsg", "func", "(", "msg", "[", "]", "byte", ")", "protocolMsg", ",", "makeBroadcastMsg", "func", "(", "srcName", "PeerName", ",", "msg", "[", "]", "byte", ")", "protocolMsg", ",", "sender", "protocolSender", ",", "stop", "<-", "chan", "struct", "{", "}", ",", ")", "*", "gossipSender", "{", "more", ":=", "make", "(", "chan", "struct", "{", "}", ",", "1", ")", "\n", "flush", ":=", "make", "(", "chan", "chan", "<-", "bool", ")", "\n", "s", ":=", "&", "gossipSender", "{", "makeMsg", ":", "makeMsg", ",", "makeBroadcastMsg", ":", "makeBroadcastMsg", ",", "sender", ":", "sender", ",", "broadcasts", ":", "make", "(", "map", "[", "PeerName", "]", "GossipData", ")", ",", "more", ":", "more", ",", "flush", ":", "flush", ",", "}", "\n", "go", "s", ".", "run", "(", "stop", ",", "more", ",", "flush", ")", "\n", "return", "s", "\n", "}"], "docstring": "// NewGossipSender constructs a usable GossipSender.", "docstring_tokens": ["NewGossipSender", "constructs", "a", "usable", "GossipSender", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/gossip.go#L78-L96", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/types/devices.go", "func_name": "DeviceNames", "original_string": "func (list Devices) DeviceNames() []string {\n\tsortable := sortableDevices{}\n\tfor k, d := range list {\n\t\tsortable = append(sortable, namedDevice{k, d})\n\t}\n\n\tsort.Sort(sortable)\n\treturn sortable.Names()\n}", "language": "go", "code": "func (list Devices) DeviceNames() []string {\n\tsortable := sortableDevices{}\n\tfor k, d := range list {\n\t\tsortable = append(sortable, namedDevice{k, d})\n\t}\n\n\tsort.Sort(sortable)\n\treturn sortable.Names()\n}", "code_tokens": ["func", "(", "list", "Devices", ")", "DeviceNames", "(", ")", "[", "]", "string", "{", "sortable", ":=", "sortableDevices", "{", "}", "\n", "for", "k", ",", "d", ":=", "range", "list", "{", "sortable", "=", "append", "(", "sortable", ",", "namedDevice", "{", "k", ",", "d", "}", ")", "\n", "}", "\n\n", "sort", ".", "Sort", "(", "sortable", ")", "\n", "return", "sortable", ".", "Names", "(", ")", "\n", "}"], "docstring": "// DeviceNames returns the name of all devices in the set, sorted properly", "docstring_tokens": ["DeviceNames", "returns", "the", "name", "of", "all", "devices", "in", "the", "set", "sorted", "properly"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/types/devices.go#L80-L88", "partition": "test"}
{"repo": "jhillyerd/enmime", "path": "builder.go", "func_name": "AddFileAttachment", "original_string": "func (p MailBuilder) AddFileAttachment(path string) MailBuilder {\n\t// Only allow first p.err value\n\tif p.err != nil {\n\t\treturn p\n\t}\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\tp.err = err\n\t\treturn p\n\t}\n\tb, err := ioutil.ReadAll(f)\n\tif err != nil {\n\t\tp.err = err\n\t\treturn p\n\t}\n\tname := filepath.Base(path)\n\tctype := mime.TypeByExtension(filepath.Ext(name))\n\treturn p.AddAttachment(b, ctype, name)\n}", "language": "go", "code": "func (p MailBuilder) AddFileAttachment(path string) MailBuilder {\n\t// Only allow first p.err value\n\tif p.err != nil {\n\t\treturn p\n\t}\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\tp.err = err\n\t\treturn p\n\t}\n\tb, err := ioutil.ReadAll(f)\n\tif err != nil {\n\t\tp.err = err\n\t\treturn p\n\t}\n\tname := filepath.Base(path)\n\tctype := mime.TypeByExtension(filepath.Ext(name))\n\treturn p.AddAttachment(b, ctype, name)\n}", "code_tokens": ["func", "(", "p", "MailBuilder", ")", "AddFileAttachment", "(", "path", "string", ")", "MailBuilder", "{", "// Only allow first p.err value", "if", "p", ".", "err", "!=", "nil", "{", "return", "p", "\n", "}", "\n", "f", ",", "err", ":=", "os", ".", "Open", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "p", ".", "err", "=", "err", "\n", "return", "p", "\n", "}", "\n", "b", ",", "err", ":=", "ioutil", ".", "ReadAll", "(", "f", ")", "\n", "if", "err", "!=", "nil", "{", "p", ".", "err", "=", "err", "\n", "return", "p", "\n", "}", "\n", "name", ":=", "filepath", ".", "Base", "(", "path", ")", "\n", "ctype", ":=", "mime", ".", "TypeByExtension", "(", "filepath", ".", "Ext", "(", "name", ")", ")", "\n", "return", "p", ".", "AddAttachment", "(", "b", ",", "ctype", ",", "name", ")", "\n", "}"], "docstring": "// AddFileAttachment returns a copy of MailBuilder that includes the specified attachment.\n// fileName, will be populated from the base name of path.  Content type will be detected from the\n// path extension.", "docstring_tokens": ["AddFileAttachment", "returns", "a", "copy", "of", "MailBuilder", "that", "includes", "the", "specified", "attachment", ".", "fileName", "will", "be", "populated", "from", "the", "base", "name", "of", "path", ".", "Content", "type", "will", "be", "detected", "from", "the", "path", "extension", "."], "sha": "874cc30e023f36bd1df525716196887b0f04851b", "url": "https://github.com/jhillyerd/enmime/blob/874cc30e023f36bd1df525716196887b0f04851b/builder.go#L149-L167", "partition": "test"}
{"repo": "tendermint/go-amino", "path": "codec.go", "func_name": "NewPrefixBytes", "original_string": "func NewPrefixBytes(prefixBytes []byte) PrefixBytes {\n\tpb := PrefixBytes{}\n\tcopy(pb[:], prefixBytes)\n\treturn pb\n}", "language": "go", "code": "func NewPrefixBytes(prefixBytes []byte) PrefixBytes {\n\tpb := PrefixBytes{}\n\tcopy(pb[:], prefixBytes)\n\treturn pb\n}", "code_tokens": ["func", "NewPrefixBytes", "(", "prefixBytes", "[", "]", "byte", ")", "PrefixBytes", "{", "pb", ":=", "PrefixBytes", "{", "}", "\n", "copy", "(", "pb", "[", ":", "]", ",", "prefixBytes", ")", "\n", "return", "pb", "\n", "}"], "docstring": "// Copy into PrefixBytes", "docstring_tokens": ["Copy", "into", "PrefixBytes"], "sha": "dc14acf9ef15f85828bfbc561ed9dd9d2a284885", "url": "https://github.com/tendermint/go-amino/blob/dc14acf9ef15f85828bfbc561ed9dd9d2a284885/codec.go#L32-L36", "partition": "test"}
{"repo": "hashicorp/raft", "path": "api.go", "func_name": "Snapshot", "original_string": "func (r *Raft) Snapshot() SnapshotFuture {\n\tfuture := &userSnapshotFuture{}\n\tfuture.init()\n\tselect {\n\tcase r.userSnapshotCh <- future:\n\t\treturn future\n\tcase <-r.shutdownCh:\n\t\tfuture.respond(ErrRaftShutdown)\n\t\treturn future\n\t}\n}", "language": "go", "code": "func (r *Raft) Snapshot() SnapshotFuture {\n\tfuture := &userSnapshotFuture{}\n\tfuture.init()\n\tselect {\n\tcase r.userSnapshotCh <- future:\n\t\treturn future\n\tcase <-r.shutdownCh:\n\t\tfuture.respond(ErrRaftShutdown)\n\t\treturn future\n\t}\n}", "code_tokens": ["func", "(", "r", "*", "Raft", ")", "Snapshot", "(", ")", "SnapshotFuture", "{", "future", ":=", "&", "userSnapshotFuture", "{", "}", "\n", "future", ".", "init", "(", ")", "\n", "select", "{", "case", "r", ".", "userSnapshotCh", "<-", "future", ":", "return", "future", "\n", "case", "<-", "r", ".", "shutdownCh", ":", "future", ".", "respond", "(", "ErrRaftShutdown", ")", "\n", "return", "future", "\n", "}", "\n", "}"], "docstring": "// Snapshot is used to manually force Raft to take a snapshot. Returns a future\n// that can be used to block until complete, and that contains a function that\n// can be used to open the snapshot.", "docstring_tokens": ["Snapshot", "is", "used", "to", "manually", "force", "Raft", "to", "take", "a", "snapshot", ".", "Returns", "a", "future", "that", "can", "be", "used", "to", "block", "until", "complete", "and", "that", "contains", "a", "function", "that", "can", "be", "used", "to", "open", "the", "snapshot", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/api.go#L816-L826", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/cluster/raft.go", "func_name": "raftMaybeBootstrap", "original_string": "func raftMaybeBootstrap(\n\tconf *raft.Config,\n\tlogs *raftboltdb.BoltStore,\n\tsnaps raft.SnapshotStore,\n\ttrans raft.Transport) error {\n\t// First check if we were already bootstrapped.\n\thasExistingState, err := raft.HasExistingState(logs, logs, snaps)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to check if raft has existing state\")\n\t}\n\tif hasExistingState {\n\t\treturn nil\n\t}\n\tserver := raft.Server{\n\t\tID:      conf.LocalID,\n\t\tAddress: trans.LocalAddr(),\n\t}\n\tconfiguration := raft.Configuration{\n\t\tServers: []raft.Server{server},\n\t}\n\treturn raft.BootstrapCluster(conf, logs, logs, snaps, trans, configuration)\n}", "language": "go", "code": "func raftMaybeBootstrap(\n\tconf *raft.Config,\n\tlogs *raftboltdb.BoltStore,\n\tsnaps raft.SnapshotStore,\n\ttrans raft.Transport) error {\n\t// First check if we were already bootstrapped.\n\thasExistingState, err := raft.HasExistingState(logs, logs, snaps)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to check if raft has existing state\")\n\t}\n\tif hasExistingState {\n\t\treturn nil\n\t}\n\tserver := raft.Server{\n\t\tID:      conf.LocalID,\n\t\tAddress: trans.LocalAddr(),\n\t}\n\tconfiguration := raft.Configuration{\n\t\tServers: []raft.Server{server},\n\t}\n\treturn raft.BootstrapCluster(conf, logs, logs, snaps, trans, configuration)\n}", "code_tokens": ["func", "raftMaybeBootstrap", "(", "conf", "*", "raft", ".", "Config", ",", "logs", "*", "raftboltdb", ".", "BoltStore", ",", "snaps", "raft", ".", "SnapshotStore", ",", "trans", "raft", ".", "Transport", ")", "error", "{", "// First check if we were already bootstrapped.", "hasExistingState", ",", "err", ":=", "raft", ".", "HasExistingState", "(", "logs", ",", "logs", ",", "snaps", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "if", "hasExistingState", "{", "return", "nil", "\n", "}", "\n", "server", ":=", "raft", ".", "Server", "{", "ID", ":", "conf", ".", "LocalID", ",", "Address", ":", "trans", ".", "LocalAddr", "(", ")", ",", "}", "\n", "configuration", ":=", "raft", ".", "Configuration", "{", "Servers", ":", "[", "]", "raft", ".", "Server", "{", "server", "}", ",", "}", "\n", "return", "raft", ".", "BootstrapCluster", "(", "conf", ",", "logs", ",", "logs", ",", "snaps", ",", "trans", ",", "configuration", ")", "\n", "}"], "docstring": "// Helper to bootstrap the raft cluster if needed.", "docstring_tokens": ["Helper", "to", "bootstrap", "the", "raft", "cluster", "if", "needed", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/raft.go#L400-L421", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/container_lxc.go", "func_name": "deviceExistsInDevicesFolder", "original_string": "func (c *containerLXC) deviceExistsInDevicesFolder(prefix string, path string) bool {\n\trelativeDestPath := strings.TrimPrefix(path, \"/\")\n\tdevName := fmt.Sprintf(\"%s.%s\", strings.Replace(prefix, \"/\", \"-\", -1), strings.Replace(relativeDestPath, \"/\", \"-\", -1))\n\tdevPath := filepath.Join(c.DevicesPath(), devName)\n\n\treturn shared.PathExists(devPath)\n}", "language": "go", "code": "func (c *containerLXC) deviceExistsInDevicesFolder(prefix string, path string) bool {\n\trelativeDestPath := strings.TrimPrefix(path, \"/\")\n\tdevName := fmt.Sprintf(\"%s.%s\", strings.Replace(prefix, \"/\", \"-\", -1), strings.Replace(relativeDestPath, \"/\", \"-\", -1))\n\tdevPath := filepath.Join(c.DevicesPath(), devName)\n\n\treturn shared.PathExists(devPath)\n}", "code_tokens": ["func", "(", "c", "*", "containerLXC", ")", "deviceExistsInDevicesFolder", "(", "prefix", "string", ",", "path", "string", ")", "bool", "{", "relativeDestPath", ":=", "strings", ".", "TrimPrefix", "(", "path", ",", "\"", "\"", ")", "\n", "devName", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "strings", ".", "Replace", "(", "prefix", ",", "\"", "\"", ",", "\"", "\"", ",", "-", "1", ")", ",", "strings", ".", "Replace", "(", "relativeDestPath", ",", "\"", "\"", ",", "\"", "\"", ",", "-", "1", ")", ")", "\n", "devPath", ":=", "filepath", ".", "Join", "(", "c", ".", "DevicesPath", "(", ")", ",", "devName", ")", "\n\n", "return", "shared", ".", "PathExists", "(", "devPath", ")", "\n", "}"], "docstring": "// Check if the unix device already exists.", "docstring_tokens": ["Check", "if", "the", "unix", "device", "already", "exists", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/container_lxc.go#L6698-L6704", "partition": "test"}
{"repo": "coryb/figtree", "path": "gen-rawoption.go", "func_name": "String", "original_string": "func (o BoolOption) String() string {\n\tif StringifyValue {\n\t\treturn fmt.Sprintf(\"%v\", o.Value)\n\t}\n\treturn fmt.Sprintf(\"{Source:%s Defined:%t Value:%v}\", o.Source, o.Defined, o.Value)\n}", "language": "go", "code": "func (o BoolOption) String() string {\n\tif StringifyValue {\n\t\treturn fmt.Sprintf(\"%v\", o.Value)\n\t}\n\treturn fmt.Sprintf(\"{Source:%s Defined:%t Value:%v}\", o.Source, o.Defined, o.Value)\n}", "code_tokens": ["func", "(", "o", "BoolOption", ")", "String", "(", ")", "string", "{", "if", "StringifyValue", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "o", ".", "Value", ")", "\n", "}", "\n", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "o", ".", "Source", ",", "o", ".", "Defined", ",", "o", ".", "Value", ")", "\n", "}"], "docstring": "// String is required for kingpin to generate usage with this datatype", "docstring_tokens": ["String", "is", "required", "for", "kingpin", "to", "generate", "usage", "with", "this", "datatype"], "sha": "e5fa026ccd54e0a6a99b6d81f73bfcc8e6fe6a6b", "url": "https://github.com/coryb/figtree/blob/e5fa026ccd54e0a6a99b6d81f73bfcc8e6fe6a6b/gen-rawoption.go#L124-L129", "partition": "test"}
{"repo": "danott/envflag", "path": "envflag.go", "func_name": "flagAsEnv", "original_string": "func flagAsEnv(name string) string {\n\tname = strings.ToUpper(EnvPrefix + name)\n\tname = strings.Replace(name, \".\", \"_\", -1)\n\tname = strings.Replace(name, \"-\", \"_\", -1)\n\treturn name\n}", "language": "go", "code": "func flagAsEnv(name string) string {\n\tname = strings.ToUpper(EnvPrefix + name)\n\tname = strings.Replace(name, \".\", \"_\", -1)\n\tname = strings.Replace(name, \"-\", \"_\", -1)\n\treturn name\n}", "code_tokens": ["func", "flagAsEnv", "(", "name", "string", ")", "string", "{", "name", "=", "strings", ".", "ToUpper", "(", "EnvPrefix", "+", "name", ")", "\n", "name", "=", "strings", ".", "Replace", "(", "name", ",", "\"", "\"", ",", "\"", "\"", ",", "-", "1", ")", "\n", "name", "=", "strings", ".", "Replace", "(", "name", ",", "\"", "\"", ",", "\"", "\"", ",", "-", "1", ")", "\n", "return", "name", "\n", "}"], "docstring": "// To be unix'y, we translate flagnames to their uppercase equivalents.", "docstring_tokens": ["To", "be", "unix", "y", "we", "translate", "flagnames", "to", "their", "uppercase", "equivalents", "."], "sha": "14c5f9aaa227ddb49f3206fe06432edfc27735a5", "url": "https://github.com/danott/envflag/blob/14c5f9aaa227ddb49f3206fe06432edfc27735a5/envflag.go#L113-L118", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "api/server.go", "func_name": "RegisterHandlerVersion", "original_string": "func RegisterHandlerVersion(version, path, method string, h http.Handler) {\n\tvar th TsuruHandler\n\tth.version = version\n\tth.path = path\n\tth.method = method\n\tth.h = h\n\ttsuruHandlerList = append(tsuruHandlerList, th)\n}", "language": "go", "code": "func RegisterHandlerVersion(version, path, method string, h http.Handler) {\n\tvar th TsuruHandler\n\tth.version = version\n\tth.path = path\n\tth.method = method\n\tth.h = h\n\ttsuruHandlerList = append(tsuruHandlerList, th)\n}", "code_tokens": ["func", "RegisterHandlerVersion", "(", "version", ",", "path", ",", "method", "string", ",", "h", "http", ".", "Handler", ")", "{", "var", "th", "TsuruHandler", "\n", "th", ".", "version", "=", "version", "\n", "th", ".", "path", "=", "path", "\n", "th", ".", "method", "=", "method", "\n", "th", ".", "h", "=", "h", "\n", "tsuruHandlerList", "=", "append", "(", "tsuruHandlerList", ",", "th", ")", "\n", "}"], "docstring": "// RegisterHandlerVersion inserts a handler on a list of handlers", "docstring_tokens": ["RegisterHandlerVersion", "inserts", "a", "handler", "on", "a", "list", "of", "handlers"], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/api/server.go#L76-L83", "partition": "test"}
{"repo": "containers/image", "path": "docker/daemon/client.go", "func_name": "newDockerClient", "original_string": "func newDockerClient(sys *types.SystemContext) (*dockerclient.Client, error) {\n\thost := dockerclient.DefaultDockerHost\n\tif sys != nil && sys.DockerDaemonHost != \"\" {\n\t\thost = sys.DockerDaemonHost\n\t}\n\n\t// Sadly, unix:// sockets don't work transparently with dockerclient.NewClient.\n\t// They work fine with a nil httpClient; with a non-nil httpClient, the transport\u2019s\n\t// TLSClientConfig must be nil (or the client will try using HTTPS over the PF_UNIX socket\n\t// regardless of the values in the *tls.Config), and we would have to call sockets.ConfigureTransport.\n\t//\n\t// We don't really want to configure anything for unix:// sockets, so just pass a nil *http.Client.\n\t//\n\t// Similarly, if we want to communicate over plain HTTP on a TCP socket, we also need to set\n\t// TLSClientConfig to nil. This can be achieved by using the form `http://`\n\turl, err := dockerclient.ParseHostURL(host)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar httpClient *http.Client\n\tif url.Scheme != \"unix\" {\n\t\tif url.Scheme == \"http\" {\n\t\t\thttpClient = httpConfig()\n\t\t} else {\n\t\t\thc, err := tlsConfig(sys)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\thttpClient = hc\n\t\t}\n\t}\n\n\treturn dockerclient.NewClient(host, defaultAPIVersion, httpClient, nil)\n}", "language": "go", "code": "func newDockerClient(sys *types.SystemContext) (*dockerclient.Client, error) {\n\thost := dockerclient.DefaultDockerHost\n\tif sys != nil && sys.DockerDaemonHost != \"\" {\n\t\thost = sys.DockerDaemonHost\n\t}\n\n\t// Sadly, unix:// sockets don't work transparently with dockerclient.NewClient.\n\t// They work fine with a nil httpClient; with a non-nil httpClient, the transport\u2019s\n\t// TLSClientConfig must be nil (or the client will try using HTTPS over the PF_UNIX socket\n\t// regardless of the values in the *tls.Config), and we would have to call sockets.ConfigureTransport.\n\t//\n\t// We don't really want to configure anything for unix:// sockets, so just pass a nil *http.Client.\n\t//\n\t// Similarly, if we want to communicate over plain HTTP on a TCP socket, we also need to set\n\t// TLSClientConfig to nil. This can be achieved by using the form `http://`\n\turl, err := dockerclient.ParseHostURL(host)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar httpClient *http.Client\n\tif url.Scheme != \"unix\" {\n\t\tif url.Scheme == \"http\" {\n\t\t\thttpClient = httpConfig()\n\t\t} else {\n\t\t\thc, err := tlsConfig(sys)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\thttpClient = hc\n\t\t}\n\t}\n\n\treturn dockerclient.NewClient(host, defaultAPIVersion, httpClient, nil)\n}", "code_tokens": ["func", "newDockerClient", "(", "sys", "*", "types", ".", "SystemContext", ")", "(", "*", "dockerclient", ".", "Client", ",", "error", ")", "{", "host", ":=", "dockerclient", ".", "DefaultDockerHost", "\n", "if", "sys", "!=", "nil", "&&", "sys", ".", "DockerDaemonHost", "!=", "\"", "\"", "{", "host", "=", "sys", ".", "DockerDaemonHost", "\n", "}", "\n\n", "// Sadly, unix:// sockets don't work transparently with dockerclient.NewClient.", "// They work fine with a nil httpClient; with a non-nil httpClient, the transport\u2019s", "// TLSClientConfig must be nil (or the client will try using HTTPS over the PF_UNIX socket", "// regardless of the values in the *tls.Config), and we would have to call sockets.ConfigureTransport.", "//", "// We don't really want to configure anything for unix:// sockets, so just pass a nil *http.Client.", "//", "// Similarly, if we want to communicate over plain HTTP on a TCP socket, we also need to set", "// TLSClientConfig to nil. This can be achieved by using the form `http://`", "url", ",", "err", ":=", "dockerclient", ".", "ParseHostURL", "(", "host", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "var", "httpClient", "*", "http", ".", "Client", "\n", "if", "url", ".", "Scheme", "!=", "\"", "\"", "{", "if", "url", ".", "Scheme", "==", "\"", "\"", "{", "httpClient", "=", "httpConfig", "(", ")", "\n", "}", "else", "{", "hc", ",", "err", ":=", "tlsConfig", "(", "sys", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "httpClient", "=", "hc", "\n", "}", "\n", "}", "\n\n", "return", "dockerclient", ".", "NewClient", "(", "host", ",", "defaultAPIVersion", ",", "httpClient", ",", "nil", ")", "\n", "}"], "docstring": "// NewDockerClient initializes a new API client based on the passed SystemContext.", "docstring_tokens": ["NewDockerClient", "initializes", "a", "new", "API", "client", "based", "on", "the", "passed", "SystemContext", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/docker/daemon/client.go#L18-L51", "partition": "test"}
{"repo": "ant0ine/go-json-rest", "path": "rest/trie/impl.go", "func_name": "AddRoute", "original_string": "func (t *Trie) AddRoute(httpMethod, pathExp string, route interface{}) error {\n\treturn t.root.addRoute(httpMethod, pathExp, route, []string{})\n}", "language": "go", "code": "func (t *Trie) AddRoute(httpMethod, pathExp string, route interface{}) error {\n\treturn t.root.addRoute(httpMethod, pathExp, route, []string{})\n}", "code_tokens": ["func", "(", "t", "*", "Trie", ")", "AddRoute", "(", "httpMethod", ",", "pathExp", "string", ",", "route", "interface", "{", "}", ")", "error", "{", "return", "t", ".", "root", ".", "addRoute", "(", "httpMethod", ",", "pathExp", ",", "route", ",", "[", "]", "string", "{", "}", ")", "\n", "}"], "docstring": "// Insert the route in the Trie following or creating the nodes corresponding to the path.", "docstring_tokens": ["Insert", "the", "route", "in", "the", "Trie", "following", "or", "creating", "the", "nodes", "corresponding", "to", "the", "path", "."], "sha": "ebb33769ae013bd5f518a8bac348c310dea768b8", "url": "https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/trie/impl.go#L349-L351", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "log/namespaced/namespaced.go", "func_name": "WithFields", "original_string": "func (n *Namespaced) WithFields(fields log.Fields) log.Interface {\n\treturn &Namespaced{\n\t\tInterface:  n.Interface.WithFields(fields),\n\t\tnamespaces: n.namespaces,\n\t\tnamespace:  n.namespace,\n\t}\n}", "language": "go", "code": "func (n *Namespaced) WithFields(fields log.Fields) log.Interface {\n\treturn &Namespaced{\n\t\tInterface:  n.Interface.WithFields(fields),\n\t\tnamespaces: n.namespaces,\n\t\tnamespace:  n.namespace,\n\t}\n}", "code_tokens": ["func", "(", "n", "*", "Namespaced", ")", "WithFields", "(", "fields", "log", ".", "Fields", ")", "log", ".", "Interface", "{", "return", "&", "Namespaced", "{", "Interface", ":", "n", ".", "Interface", ".", "WithFields", "(", "fields", ")", ",", "namespaces", ":", "n", ".", "namespaces", ",", "namespace", ":", "n", ".", "namespace", ",", "}", "\n", "}"], "docstring": "// WithFields adds multiple fields to the logger", "docstring_tokens": ["WithFields", "adds", "multiple", "fields", "to", "the", "logger"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/log/namespaced/namespaced.go#L71-L77", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/rafthttp/peer.go", "func_name": "Resume", "original_string": "func (p *peer) Resume() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.paused = false\n\tp.msgAppReader.resume()\n\tp.msgAppV2Reader.resume()\n}", "language": "go", "code": "func (p *peer) Resume() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.paused = false\n\tp.msgAppReader.resume()\n\tp.msgAppV2Reader.resume()\n}", "code_tokens": ["func", "(", "p", "*", "peer", ")", "Resume", "(", ")", "{", "p", ".", "mu", ".", "Lock", "(", ")", "\n", "defer", "p", ".", "mu", ".", "Unlock", "(", ")", "\n", "p", ".", "paused", "=", "false", "\n", "p", ".", "msgAppReader", ".", "resume", "(", ")", "\n", "p", ".", "msgAppV2Reader", ".", "resume", "(", ")", "\n", "}"], "docstring": "// Resume resumes a paused peer.", "docstring_tokens": ["Resume", "resumes", "a", "paused", "peer", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/peer.go#L323-L329", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "tethering/tethering.go", "func_name": "Do", "original_string": "func (p *UnbindParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandUnbind, p, nil)\n}", "language": "go", "code": "func (p *UnbindParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandUnbind, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "UnbindParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandUnbind", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Tethering.unbind against the provided context.", "docstring_tokens": ["Do", "executes", "Tethering", ".", "unbind", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/tethering/tethering.go#L57-L59", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/logger.go", "func_name": "SetLogger", "original_string": "func SetLogger(l grpclog.LoggerV2) {\n\tlgMu.Lock()\n\tlg = logutil.NewLogger(l)\n\t// override grpclog so that any changes happen with locking\n\tgrpclog.SetLoggerV2(lg)\n\tlgMu.Unlock()\n}", "language": "go", "code": "func SetLogger(l grpclog.LoggerV2) {\n\tlgMu.Lock()\n\tlg = logutil.NewLogger(l)\n\t// override grpclog so that any changes happen with locking\n\tgrpclog.SetLoggerV2(lg)\n\tlgMu.Unlock()\n}", "code_tokens": ["func", "SetLogger", "(", "l", "grpclog", ".", "LoggerV2", ")", "{", "lgMu", ".", "Lock", "(", ")", "\n", "lg", "=", "logutil", ".", "NewLogger", "(", "l", ")", "\n", "// override grpclog so that any changes happen with locking", "grpclog", ".", "SetLoggerV2", "(", "lg", ")", "\n", "lgMu", ".", "Unlock", "(", ")", "\n", "}"], "docstring": "// SetLogger sets client-side Logger.", "docstring_tokens": ["SetLogger", "sets", "client", "-", "side", "Logger", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/logger.go#L43-L49", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/peribolos/main.go", "func_name": "updateString", "original_string": "func updateString(have, want *string) bool {\n\tswitch {\n\tcase have == nil:\n\t\tpanic(\"have must be non-nil\")\n\tcase want == nil:\n\t\treturn false // do not care what we have\n\tcase *have == *want:\n\t\treturn false // already have it\n\t}\n\t*have = *want // update value\n\treturn true\n}", "language": "go", "code": "func updateString(have, want *string) bool {\n\tswitch {\n\tcase have == nil:\n\t\tpanic(\"have must be non-nil\")\n\tcase want == nil:\n\t\treturn false // do not care what we have\n\tcase *have == *want:\n\t\treturn false // already have it\n\t}\n\t*have = *want // update value\n\treturn true\n}", "code_tokens": ["func", "updateString", "(", "have", ",", "want", "*", "string", ")", "bool", "{", "switch", "{", "case", "have", "==", "nil", ":", "panic", "(", "\"", "\"", ")", "\n", "case", "want", "==", "nil", ":", "return", "false", "// do not care what we have", "\n", "case", "*", "have", "==", "*", "want", ":", "return", "false", "// already have it", "\n", "}", "\n", "*", "have", "=", "*", "want", "// update value", "\n", "return", "true", "\n", "}"], "docstring": "// updateString will return true and set have to want iff they are set and different.", "docstring_tokens": ["updateString", "will", "return", "true", "and", "set", "have", "to", "want", "iff", "they", "are", "set", "and", "different", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/peribolos/main.go#L686-L697", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "build/transaction.go", "func_name": "MutateTransaction", "original_string": "func (m ManageOfferBuilder) MutateTransaction(o *TransactionBuilder) error {\n\tif m.Err != nil {\n\t\treturn m.Err\n\t}\n\n\tif m.PassiveOffer {\n\t\tm.O.Body, m.Err = xdr.NewOperationBody(xdr.OperationTypeCreatePassiveOffer, m.PO)\n\t\to.TX.Operations = append(o.TX.Operations, m.O)\n\t} else {\n\t\tm.O.Body, m.Err = xdr.NewOperationBody(xdr.OperationTypeManageOffer, m.MO)\n\t\to.TX.Operations = append(o.TX.Operations, m.O)\n\t}\n\treturn m.Err\n}", "language": "go", "code": "func (m ManageOfferBuilder) MutateTransaction(o *TransactionBuilder) error {\n\tif m.Err != nil {\n\t\treturn m.Err\n\t}\n\n\tif m.PassiveOffer {\n\t\tm.O.Body, m.Err = xdr.NewOperationBody(xdr.OperationTypeCreatePassiveOffer, m.PO)\n\t\to.TX.Operations = append(o.TX.Operations, m.O)\n\t} else {\n\t\tm.O.Body, m.Err = xdr.NewOperationBody(xdr.OperationTypeManageOffer, m.MO)\n\t\to.TX.Operations = append(o.TX.Operations, m.O)\n\t}\n\treturn m.Err\n}", "code_tokens": ["func", "(", "m", "ManageOfferBuilder", ")", "MutateTransaction", "(", "o", "*", "TransactionBuilder", ")", "error", "{", "if", "m", ".", "Err", "!=", "nil", "{", "return", "m", ".", "Err", "\n", "}", "\n\n", "if", "m", ".", "PassiveOffer", "{", "m", ".", "O", ".", "Body", ",", "m", ".", "Err", "=", "xdr", ".", "NewOperationBody", "(", "xdr", ".", "OperationTypeCreatePassiveOffer", ",", "m", ".", "PO", ")", "\n", "o", ".", "TX", ".", "Operations", "=", "append", "(", "o", ".", "TX", ".", "Operations", ",", "m", ".", "O", ")", "\n", "}", "else", "{", "m", ".", "O", ".", "Body", ",", "m", ".", "Err", "=", "xdr", ".", "NewOperationBody", "(", "xdr", ".", "OperationTypeManageOffer", ",", "m", ".", "MO", ")", "\n", "o", ".", "TX", ".", "Operations", "=", "append", "(", "o", ".", "TX", ".", "Operations", ",", "m", ".", "O", ")", "\n", "}", "\n", "return", "m", ".", "Err", "\n", "}"], "docstring": "// MutateTransaction for ManageOfferBuilder causes the underylying\n// ManageData to be added to the operation list for the provided\n// transaction", "docstring_tokens": ["MutateTransaction", "for", "ManageOfferBuilder", "causes", "the", "underylying", "ManageData", "to", "be", "added", "to", "the", "operation", "list", "for", "the", "provided", "transaction"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/build/transaction.go#L213-L226", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/spyglass/artifacts.go", "func_name": "prowToGCS", "original_string": "func (s *Spyglass) prowToGCS(prowKey string) (string, error) {\n\tjobName, buildID, err := s.KeyToJob(prowKey)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not get GCS src: %v\", err)\n\t}\n\n\tjob, err := s.jobAgent.GetProwJob(jobName, buildID)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to get prow job from src %q: %v\", prowKey, err)\n\t}\n\n\turl := job.Status.URL\n\tprefix := s.config().Plank.GetJobURLPrefix(job.Spec.Refs)\n\tif !strings.HasPrefix(url, prefix) {\n\t\treturn \"\", fmt.Errorf(\"unexpected job URL %q when finding GCS path: expected something starting with %q\", url, prefix)\n\t}\n\treturn url[len(prefix):], nil\n}", "language": "go", "code": "func (s *Spyglass) prowToGCS(prowKey string) (string, error) {\n\tjobName, buildID, err := s.KeyToJob(prowKey)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not get GCS src: %v\", err)\n\t}\n\n\tjob, err := s.jobAgent.GetProwJob(jobName, buildID)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to get prow job from src %q: %v\", prowKey, err)\n\t}\n\n\turl := job.Status.URL\n\tprefix := s.config().Plank.GetJobURLPrefix(job.Spec.Refs)\n\tif !strings.HasPrefix(url, prefix) {\n\t\treturn \"\", fmt.Errorf(\"unexpected job URL %q when finding GCS path: expected something starting with %q\", url, prefix)\n\t}\n\treturn url[len(prefix):], nil\n}", "code_tokens": ["func", "(", "s", "*", "Spyglass", ")", "prowToGCS", "(", "prowKey", "string", ")", "(", "string", ",", "error", ")", "{", "jobName", ",", "buildID", ",", "err", ":=", "s", ".", "KeyToJob", "(", "prowKey", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n\n", "job", ",", "err", ":=", "s", ".", "jobAgent", ".", "GetProwJob", "(", "jobName", ",", "buildID", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "prowKey", ",", "err", ")", "\n", "}", "\n\n", "url", ":=", "job", ".", "Status", ".", "URL", "\n", "prefix", ":=", "s", ".", "config", "(", ")", ".", "Plank", ".", "GetJobURLPrefix", "(", "job", ".", "Spec", ".", "Refs", ")", "\n", "if", "!", "strings", ".", "HasPrefix", "(", "url", ",", "prefix", ")", "{", "return", "\"", "\"", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "url", ",", "prefix", ")", "\n", "}", "\n", "return", "url", "[", "len", "(", "prefix", ")", ":", "]", ",", "nil", "\n", "}"], "docstring": "// prowToGCS returns the GCS key corresponding to the given prow key", "docstring_tokens": ["prowToGCS", "returns", "the", "GCS", "key", "corresponding", "to", "the", "given", "prow", "key"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/spyglass/artifacts.go#L73-L90", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "local_peer.go", "func_name": "doAddConnection", "original_string": "func (peer *localPeer) doAddConnection(conn ourConnection, isRestartedPeer bool) error {\n\tresultChan := make(chan error)\n\tpeer.actionChan <- func() {\n\t\tresultChan <- peer.handleAddConnection(conn, isRestartedPeer)\n\t}\n\treturn <-resultChan\n}", "language": "go", "code": "func (peer *localPeer) doAddConnection(conn ourConnection, isRestartedPeer bool) error {\n\tresultChan := make(chan error)\n\tpeer.actionChan <- func() {\n\t\tresultChan <- peer.handleAddConnection(conn, isRestartedPeer)\n\t}\n\treturn <-resultChan\n}", "code_tokens": ["func", "(", "peer", "*", "localPeer", ")", "doAddConnection", "(", "conn", "ourConnection", ",", "isRestartedPeer", "bool", ")", "error", "{", "resultChan", ":=", "make", "(", "chan", "error", ")", "\n", "peer", ".", "actionChan", "<-", "func", "(", ")", "{", "resultChan", "<-", "peer", ".", "handleAddConnection", "(", "conn", ",", "isRestartedPeer", ")", "\n", "}", "\n", "return", "<-", "resultChan", "\n", "}"], "docstring": "// ACTOR client API\n// Synchronous.", "docstring_tokens": ["ACTOR", "client", "API", "Synchronous", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/local_peer.go#L105-L111", "partition": "test"}
{"repo": "mikespook/possum", "path": "view/template.go", "func_name": "CloseWatcher", "original_string": "func CloseWatcher() error {\n\tfor i := uint32(0); i < watcher.count; i++ {\n\t\twatcher.closer <- true\n\t}\n\treturn watcher.Close()\n}", "language": "go", "code": "func CloseWatcher() error {\n\tfor i := uint32(0); i < watcher.count; i++ {\n\t\twatcher.closer <- true\n\t}\n\treturn watcher.Close()\n}", "code_tokens": ["func", "CloseWatcher", "(", ")", "error", "{", "for", "i", ":=", "uint32", "(", "0", ")", ";", "i", "<", "watcher", ".", "count", ";", "i", "++", "{", "watcher", ".", "closer", "<-", "true", "\n", "}", "\n", "return", "watcher", ".", "Close", "(", ")", "\n", "}"], "docstring": "// CloseWatcher closes the wathcer.", "docstring_tokens": ["CloseWatcher", "closes", "the", "wathcer", "."], "sha": "56d7ebb6470b670001632b11be7fc089038f4dd7", "url": "https://github.com/mikespook/possum/blob/56d7ebb6470b670001632b11be7fc089038f4dd7/view/template.go#L133-L138", "partition": "test"}
{"repo": "blacksails/cgp", "path": "mailing_list.go", "func_name": "MailingList", "original_string": "func (dom *Domain) MailingList(name string) *MailingList {\n\treturn &MailingList{Domain: dom, Name: name}\n}", "language": "go", "code": "func (dom *Domain) MailingList(name string) *MailingList {\n\treturn &MailingList{Domain: dom, Name: name}\n}", "code_tokens": ["func", "(", "dom", "*", "Domain", ")", "MailingList", "(", "name", "string", ")", "*", "MailingList", "{", "return", "&", "MailingList", "{", "Domain", ":", "dom", ",", "Name", ":", "name", "}", "\n", "}"], "docstring": "// MailingList creates a MailingList type from a domain, with the given name", "docstring_tokens": ["MailingList", "creates", "a", "MailingList", "type", "from", "a", "domain", "with", "the", "given", "name"], "sha": "570ac705cf2d7a9235d911d00b6f976ab3386c2f", "url": "https://github.com/blacksails/cgp/blob/570ac705cf2d7a9235d911d00b6f976ab3386c2f/mailing_list.go#L15-L17", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pfs/pretty/pretty.go", "func_name": "PrintRepoInfo", "original_string": "func PrintRepoInfo(w io.Writer, repoInfo *pfs.RepoInfo, fullTimestamps bool) {\n\tfmt.Fprintf(w, \"%s\\t\", repoInfo.Repo.Name)\n\tif fullTimestamps {\n\t\tfmt.Fprintf(w, \"%s\\t\", repoInfo.Created.String())\n\t} else {\n\t\tfmt.Fprintf(w, \"%s\\t\", pretty.Ago(repoInfo.Created))\n\t}\n\tfmt.Fprintf(w, \"%s\\t\", units.BytesSize(float64(repoInfo.SizeBytes)))\n\tif repoInfo.AuthInfo != nil {\n\t\tfmt.Fprintf(w, \"%s\\t\", repoInfo.AuthInfo.AccessLevel.String())\n\t}\n\tfmt.Fprintln(w)\n}", "language": "go", "code": "func PrintRepoInfo(w io.Writer, repoInfo *pfs.RepoInfo, fullTimestamps bool) {\n\tfmt.Fprintf(w, \"%s\\t\", repoInfo.Repo.Name)\n\tif fullTimestamps {\n\t\tfmt.Fprintf(w, \"%s\\t\", repoInfo.Created.String())\n\t} else {\n\t\tfmt.Fprintf(w, \"%s\\t\", pretty.Ago(repoInfo.Created))\n\t}\n\tfmt.Fprintf(w, \"%s\\t\", units.BytesSize(float64(repoInfo.SizeBytes)))\n\tif repoInfo.AuthInfo != nil {\n\t\tfmt.Fprintf(w, \"%s\\t\", repoInfo.AuthInfo.AccessLevel.String())\n\t}\n\tfmt.Fprintln(w)\n}", "code_tokens": ["func", "PrintRepoInfo", "(", "w", "io", ".", "Writer", ",", "repoInfo", "*", "pfs", ".", "RepoInfo", ",", "fullTimestamps", "bool", ")", "{", "fmt", ".", "Fprintf", "(", "w", ",", "\"", "\\t", "\"", ",", "repoInfo", ".", "Repo", ".", "Name", ")", "\n", "if", "fullTimestamps", "{", "fmt", ".", "Fprintf", "(", "w", ",", "\"", "\\t", "\"", ",", "repoInfo", ".", "Created", ".", "String", "(", ")", ")", "\n", "}", "else", "{", "fmt", ".", "Fprintf", "(", "w", ",", "\"", "\\t", "\"", ",", "pretty", ".", "Ago", "(", "repoInfo", ".", "Created", ")", ")", "\n", "}", "\n", "fmt", ".", "Fprintf", "(", "w", ",", "\"", "\\t", "\"", ",", "units", ".", "BytesSize", "(", "float64", "(", "repoInfo", ".", "SizeBytes", ")", ")", ")", "\n", "if", "repoInfo", ".", "AuthInfo", "!=", "nil", "{", "fmt", ".", "Fprintf", "(", "w", ",", "\"", "\\t", "\"", ",", "repoInfo", ".", "AuthInfo", ".", "AccessLevel", ".", "String", "(", ")", ")", "\n", "}", "\n", "fmt", ".", "Fprintln", "(", "w", ")", "\n", "}"], "docstring": "// PrintRepoInfo pretty-prints repo info.", "docstring_tokens": ["PrintRepoInfo", "pretty", "-", "prints", "repo", "info", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pfs/pretty/pretty.go#L37-L49", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/balancer/resolver/endpoint/endpoint.go", "func_name": "SetEndpoints", "original_string": "func (e *ResolverGroup) SetEndpoints(endpoints []string) {\n\taddrs := epsToAddrs(endpoints...)\n\te.mu.Lock()\n\te.endpoints = endpoints\n\tfor _, r := range e.resolvers {\n\t\tr.cc.NewAddress(addrs)\n\t}\n\te.mu.Unlock()\n}", "language": "go", "code": "func (e *ResolverGroup) SetEndpoints(endpoints []string) {\n\taddrs := epsToAddrs(endpoints...)\n\te.mu.Lock()\n\te.endpoints = endpoints\n\tfor _, r := range e.resolvers {\n\t\tr.cc.NewAddress(addrs)\n\t}\n\te.mu.Unlock()\n}", "code_tokens": ["func", "(", "e", "*", "ResolverGroup", ")", "SetEndpoints", "(", "endpoints", "[", "]", "string", ")", "{", "addrs", ":=", "epsToAddrs", "(", "endpoints", "...", ")", "\n", "e", ".", "mu", ".", "Lock", "(", ")", "\n", "e", ".", "endpoints", "=", "endpoints", "\n", "for", "_", ",", "r", ":=", "range", "e", ".", "resolvers", "{", "r", ".", "cc", ".", "NewAddress", "(", "addrs", ")", "\n", "}", "\n", "e", ".", "mu", ".", "Unlock", "(", ")", "\n", "}"], "docstring": "// SetEndpoints updates the endpoints for ResolverGroup. All registered resolver are updated\n// immediately with the new endpoints.", "docstring_tokens": ["SetEndpoints", "updates", "the", "endpoints", "for", "ResolverGroup", ".", "All", "registered", "resolver", "are", "updated", "immediately", "with", "the", "new", "endpoints", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/balancer/resolver/endpoint/endpoint.go#L82-L90", "partition": "test"}
{"repo": "Unknwon/goconfig", "path": "read.go", "func_name": "LoadFromData", "original_string": "func LoadFromData(data []byte) (c *ConfigFile, err error) {\n\t// Save memory data to temporary file to support further operations.\n\ttmpName := path.Join(os.TempDir(), \"goconfig\", fmt.Sprintf(\"%d\", time.Now().Nanosecond()))\n\tif err = os.MkdirAll(path.Dir(tmpName), os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = ioutil.WriteFile(tmpName, data, 0655); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc = newConfigFile([]string{tmpName})\n\terr = c.read(bytes.NewBuffer(data))\n\treturn c, err\n}", "language": "go", "code": "func LoadFromData(data []byte) (c *ConfigFile, err error) {\n\t// Save memory data to temporary file to support further operations.\n\ttmpName := path.Join(os.TempDir(), \"goconfig\", fmt.Sprintf(\"%d\", time.Now().Nanosecond()))\n\tif err = os.MkdirAll(path.Dir(tmpName), os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = ioutil.WriteFile(tmpName, data, 0655); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc = newConfigFile([]string{tmpName})\n\terr = c.read(bytes.NewBuffer(data))\n\treturn c, err\n}", "code_tokens": ["func", "LoadFromData", "(", "data", "[", "]", "byte", ")", "(", "c", "*", "ConfigFile", ",", "err", "error", ")", "{", "// Save memory data to temporary file to support further operations.", "tmpName", ":=", "path", ".", "Join", "(", "os", ".", "TempDir", "(", ")", ",", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "time", ".", "Now", "(", ")", ".", "Nanosecond", "(", ")", ")", ")", "\n", "if", "err", "=", "os", ".", "MkdirAll", "(", "path", ".", "Dir", "(", "tmpName", ")", ",", "os", ".", "ModePerm", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "err", "=", "ioutil", ".", "WriteFile", "(", "tmpName", ",", "data", ",", "0655", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "c", "=", "newConfigFile", "(", "[", "]", "string", "{", "tmpName", "}", ")", "\n", "err", "=", "c", ".", "read", "(", "bytes", ".", "NewBuffer", "(", "data", ")", ")", "\n", "return", "c", ",", "err", "\n", "}"], "docstring": "// LoadFromData accepts raw data directly from memory\n// and returns a new configuration representation.\n// Note that the configuration is written to the system\n// temporary folder, so your file should not contain\n// sensitive information.", "docstring_tokens": ["LoadFromData", "accepts", "raw", "data", "directly", "from", "memory", "and", "returns", "a", "new", "configuration", "representation", ".", "Note", "that", "the", "configuration", "is", "written", "to", "the", "system", "temporary", "folder", "so", "your", "file", "should", "not", "contain", "sensitive", "information", "."], "sha": "3dba17dd7b9ec8509b3621a73a30a4b333eb28da", "url": "https://github.com/Unknwon/goconfig/blob/3dba17dd7b9ec8509b3621a73a30a4b333eb28da/read.go#L182-L195", "partition": "test"}
{"repo": "rightscale/rsc", "path": "ca/cac/codegen_client.go", "func_name": "InstanceUsagePeriodLocator", "original_string": "func (api *API) InstanceUsagePeriodLocator(href string) *InstanceUsagePeriodLocator {\n\treturn &InstanceUsagePeriodLocator{Href(href), api}\n}", "language": "go", "code": "func (api *API) InstanceUsagePeriodLocator(href string) *InstanceUsagePeriodLocator {\n\treturn &InstanceUsagePeriodLocator{Href(href), api}\n}", "code_tokens": ["func", "(", "api", "*", "API", ")", "InstanceUsagePeriodLocator", "(", "href", "string", ")", "*", "InstanceUsagePeriodLocator", "{", "return", "&", "InstanceUsagePeriodLocator", "{", "Href", "(", "href", ")", ",", "api", "}", "\n", "}"], "docstring": "// InstanceUsagePeriodLocator builds a locator from the given href.", "docstring_tokens": ["InstanceUsagePeriodLocator", "builds", "a", "locator", "from", "the", "given", "href", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/ca/cac/codegen_client.go#L2012-L2014", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "raft/progress.go", "func_name": "add", "original_string": "func (in *inflights) add(inflight uint64) {\n\tif in.full() {\n\t\tpanic(\"cannot add into a full inflights\")\n\t}\n\tnext := in.start + in.count\n\tsize := in.size\n\tif next >= size {\n\t\tnext -= size\n\t}\n\tif next >= len(in.buffer) {\n\t\tin.growBuf()\n\t}\n\tin.buffer[next] = inflight\n\tin.count++\n}", "language": "go", "code": "func (in *inflights) add(inflight uint64) {\n\tif in.full() {\n\t\tpanic(\"cannot add into a full inflights\")\n\t}\n\tnext := in.start + in.count\n\tsize := in.size\n\tif next >= size {\n\t\tnext -= size\n\t}\n\tif next >= len(in.buffer) {\n\t\tin.growBuf()\n\t}\n\tin.buffer[next] = inflight\n\tin.count++\n}", "code_tokens": ["func", "(", "in", "*", "inflights", ")", "add", "(", "inflight", "uint64", ")", "{", "if", "in", ".", "full", "(", ")", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "next", ":=", "in", ".", "start", "+", "in", ".", "count", "\n", "size", ":=", "in", ".", "size", "\n", "if", "next", ">=", "size", "{", "next", "-=", "size", "\n", "}", "\n", "if", "next", ">=", "len", "(", "in", ".", "buffer", ")", "{", "in", ".", "growBuf", "(", ")", "\n", "}", "\n", "in", ".", "buffer", "[", "next", "]", "=", "inflight", "\n", "in", ".", "count", "++", "\n", "}"], "docstring": "// add adds an inflight into inflights", "docstring_tokens": ["add", "adds", "an", "inflight", "into", "inflights"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/progress.go#L213-L227", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewPublicKey", "original_string": "func NewPublicKey(aType CryptoKeyType, value interface{}) (result PublicKey, err error) {\n\tresult.Type = aType\n\tswitch CryptoKeyType(aType) {\n\tcase CryptoKeyTypeKeyTypeEd25519:\n\t\ttv, ok := value.(Uint256)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Uint256\")\n\t\t\treturn\n\t\t}\n\t\tresult.Ed25519 = &tv\n\t}\n\treturn\n}", "language": "go", "code": "func NewPublicKey(aType CryptoKeyType, value interface{}) (result PublicKey, err error) {\n\tresult.Type = aType\n\tswitch CryptoKeyType(aType) {\n\tcase CryptoKeyTypeKeyTypeEd25519:\n\t\ttv, ok := value.(Uint256)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Uint256\")\n\t\t\treturn\n\t\t}\n\t\tresult.Ed25519 = &tv\n\t}\n\treturn\n}", "code_tokens": ["func", "NewPublicKey", "(", "aType", "CryptoKeyType", ",", "value", "interface", "{", "}", ")", "(", "result", "PublicKey", ",", "err", "error", ")", "{", "result", ".", "Type", "=", "aType", "\n", "switch", "CryptoKeyType", "(", "aType", ")", "{", "case", "CryptoKeyTypeKeyTypeEd25519", ":", "tv", ",", "ok", ":=", "value", ".", "(", "Uint256", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Ed25519", "=", "&", "tv", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// NewPublicKey creates a new  PublicKey.", "docstring_tokens": ["NewPublicKey", "creates", "a", "new", "PublicKey", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L128-L140", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/pod-utils/gcs/target.go", "func_name": "AliasForSpec", "original_string": "func AliasForSpec(spec *downwardapi.JobSpec) string {\n\tswitch spec.Type {\n\tcase prowapi.PeriodicJob, prowapi.PostsubmitJob, prowapi.BatchJob:\n\t\treturn \"\"\n\tcase prowapi.PresubmitJob:\n\t\treturn path.Join(PRLogs, \"directory\", spec.Job, fmt.Sprintf(\"%s.txt\", spec.BuildID))\n\tdefault:\n\t\tlogrus.Fatalf(\"unknown job spec type: %v\", spec.Type)\n\t}\n\treturn \"\"\n}", "language": "go", "code": "func AliasForSpec(spec *downwardapi.JobSpec) string {\n\tswitch spec.Type {\n\tcase prowapi.PeriodicJob, prowapi.PostsubmitJob, prowapi.BatchJob:\n\t\treturn \"\"\n\tcase prowapi.PresubmitJob:\n\t\treturn path.Join(PRLogs, \"directory\", spec.Job, fmt.Sprintf(\"%s.txt\", spec.BuildID))\n\tdefault:\n\t\tlogrus.Fatalf(\"unknown job spec type: %v\", spec.Type)\n\t}\n\treturn \"\"\n}", "code_tokens": ["func", "AliasForSpec", "(", "spec", "*", "downwardapi", ".", "JobSpec", ")", "string", "{", "switch", "spec", ".", "Type", "{", "case", "prowapi", ".", "PeriodicJob", ",", "prowapi", ".", "PostsubmitJob", ",", "prowapi", ".", "BatchJob", ":", "return", "\"", "\"", "\n", "case", "prowapi", ".", "PresubmitJob", ":", "return", "path", ".", "Join", "(", "PRLogs", ",", "\"", "\"", ",", "spec", ".", "Job", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "spec", ".", "BuildID", ")", ")", "\n", "default", ":", "logrus", ".", "Fatalf", "(", "\"", "\"", ",", "spec", ".", "Type", ")", "\n", "}", "\n", "return", "\"", "\"", "\n", "}"], "docstring": "// AliasForSpec determines the GCS path aliases for a job spec", "docstring_tokens": ["AliasForSpec", "determines", "the", "GCS", "path", "aliases", "for", "a", "job", "spec"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/pod-utils/gcs/target.go#L55-L65", "partition": "test"}
{"repo": "hashicorp/raft", "path": "net_transport.go", "func_name": "returnConn", "original_string": "func (n *NetworkTransport) returnConn(conn *netConn) {\n\tn.connPoolLock.Lock()\n\tdefer n.connPoolLock.Unlock()\n\n\tkey := conn.target\n\tconns, _ := n.connPool[key]\n\n\tif !n.IsShutdown() && len(conns) < n.maxPool {\n\t\tn.connPool[key] = append(conns, conn)\n\t} else {\n\t\tconn.Release()\n\t}\n}", "language": "go", "code": "func (n *NetworkTransport) returnConn(conn *netConn) {\n\tn.connPoolLock.Lock()\n\tdefer n.connPoolLock.Unlock()\n\n\tkey := conn.target\n\tconns, _ := n.connPool[key]\n\n\tif !n.IsShutdown() && len(conns) < n.maxPool {\n\t\tn.connPool[key] = append(conns, conn)\n\t} else {\n\t\tconn.Release()\n\t}\n}", "code_tokens": ["func", "(", "n", "*", "NetworkTransport", ")", "returnConn", "(", "conn", "*", "netConn", ")", "{", "n", ".", "connPoolLock", ".", "Lock", "(", ")", "\n", "defer", "n", ".", "connPoolLock", ".", "Unlock", "(", ")", "\n\n", "key", ":=", "conn", ".", "target", "\n", "conns", ",", "_", ":=", "n", ".", "connPool", "[", "key", "]", "\n\n", "if", "!", "n", ".", "IsShutdown", "(", ")", "&&", "len", "(", "conns", ")", "<", "n", ".", "maxPool", "{", "n", ".", "connPool", "[", "key", "]", "=", "append", "(", "conns", ",", "conn", ")", "\n", "}", "else", "{", "conn", ".", "Release", "(", ")", "\n", "}", "\n", "}"], "docstring": "// returnConn returns a connection back to the pool.", "docstring_tokens": ["returnConn", "returns", "a", "connection", "back", "to", "the", "pool", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/net_transport.go#L350-L362", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "loader/cache.go", "func_name": "NewFileCache", "original_string": "func NewFileCache(dir string) (*FileCache, error) {\n\tf := &FileCache{dir}\n\treturn f, nil\n}", "language": "go", "code": "func NewFileCache(dir string) (*FileCache, error) {\n\tf := &FileCache{dir}\n\treturn f, nil\n}", "code_tokens": ["func", "NewFileCache", "(", "dir", "string", ")", "(", "*", "FileCache", ",", "error", ")", "{", "f", ":=", "&", "FileCache", "{", "dir", "}", "\n", "return", "f", ",", "nil", "\n", "}"], "docstring": "// NewFileCache creates a new FileCache which stores caches underneath\n// the directory specified by `dir`", "docstring_tokens": ["NewFileCache", "creates", "a", "new", "FileCache", "which", "stores", "caches", "underneath", "the", "directory", "specified", "by", "dir"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/loader/cache.go#L121-L124", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nodetable/table.go", "func_name": "Stats", "original_string": "func (nt *NodeTable) Stats() string {\n\treturn fmt.Sprintf(\"\\nFastHTCount = %d\\n\"+\n\t\t\"SlowHTCount = %d\\n\"+\n\t\t\"Conflicts   = %d\\n\"+\n\t\t\"MemoryInUse = %d\\n\",\n\t\tnt.fastHTCount, nt.slowHTCount, nt.conflicts, nt.MemoryInUse())\n}", "language": "go", "code": "func (nt *NodeTable) Stats() string {\n\treturn fmt.Sprintf(\"\\nFastHTCount = %d\\n\"+\n\t\t\"SlowHTCount = %d\\n\"+\n\t\t\"Conflicts   = %d\\n\"+\n\t\t\"MemoryInUse = %d\\n\",\n\t\tnt.fastHTCount, nt.slowHTCount, nt.conflicts, nt.MemoryInUse())\n}", "code_tokens": ["func", "(", "nt", "*", "NodeTable", ")", "Stats", "(", ")", "string", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\\n", "\\n", "\"", "+", "\"", "\\n", "\"", "+", "\"", "\\n", "\"", "+", "\"", "\\n", "\"", ",", "nt", ".", "fastHTCount", ",", "nt", ".", "slowHTCount", ",", "nt", ".", "conflicts", ",", "nt", ".", "MemoryInUse", "(", ")", ")", "\n", "}"], "docstring": "// Stats returns nodetable statistics", "docstring_tokens": ["Stats", "returns", "nodetable", "statistics"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nodetable/table.go#L96-L102", "partition": "test"}
{"repo": "golang/appengine", "path": "datastore/prop.go", "func_name": "LoadStruct", "original_string": "func LoadStruct(dst interface{}, p []Property) error {\n\tx, err := newStructPLS(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn x.Load(p)\n}", "language": "go", "code": "func LoadStruct(dst interface{}, p []Property) error {\n\tx, err := newStructPLS(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn x.Load(p)\n}", "code_tokens": ["func", "LoadStruct", "(", "dst", "interface", "{", "}", ",", "p", "[", "]", "Property", ")", "error", "{", "x", ",", "err", ":=", "newStructPLS", "(", "dst", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "return", "x", ".", "Load", "(", "p", ")", "\n", "}"], "docstring": "// LoadStruct loads the properties from p to dst.\n// dst must be a struct pointer.", "docstring_tokens": ["LoadStruct", "loads", "the", "properties", "from", "p", "to", "dst", ".", "dst", "must", "be", "a", "struct", "pointer", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/datastore/prop.go#L314-L320", "partition": "test"}
{"repo": "nwaples/rardecode", "path": "archive15.go", "func_name": "readBlockHeader", "original_string": "func (a *archive15) readBlockHeader() (*blockHeader15, error) {\n\tvar err error\n\tb := a.buf[:7]\n\tr := io.Reader(a.v)\n\tif a.encrypted {\n\t\tsalt := a.buf[:saltSize]\n\t\t_, err = io.ReadFull(r, salt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkey, iv := a.getKeys(salt)\n\t\tr = newAesDecryptReader(r, key, iv)\n\t\terr = readFull(r, b)\n\t} else {\n\t\t_, err = io.ReadFull(r, b)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcrc := b.uint16()\n\thash := crc32.NewIEEE()\n\thash.Write(b)\n\th := new(blockHeader15)\n\th.htype = b.byte()\n\th.flags = b.uint16()\n\tsize := b.uint16()\n\tif size < 7 {\n\t\treturn nil, errCorruptHeader\n\t}\n\tsize -= 7\n\tif int(size) > cap(a.buf) {\n\t\ta.buf = readBuf(make([]byte, size))\n\t}\n\th.data = a.buf[:size]\n\tif err := readFull(r, h.data); err != nil {\n\t\treturn nil, err\n\t}\n\thash.Write(h.data)\n\tif crc != uint16(hash.Sum32()) {\n\t\treturn nil, errBadHeaderCrc\n\t}\n\tif h.flags&blockHasData > 0 {\n\t\tif len(h.data) < 4 {\n\t\t\treturn nil, errCorruptHeader\n\t\t}\n\t\th.dataSize = int64(h.data.uint32())\n\t}\n\tif (h.htype == blockService || h.htype == blockFile) && h.flags&fileLargeData > 0 {\n\t\tif len(h.data) < 25 {\n\t\t\treturn nil, errCorruptHeader\n\t\t}\n\t\tb := h.data[21:25]\n\t\th.dataSize |= int64(b.uint32()) << 32\n\t}\n\treturn h, nil\n}", "language": "go", "code": "func (a *archive15) readBlockHeader() (*blockHeader15, error) {\n\tvar err error\n\tb := a.buf[:7]\n\tr := io.Reader(a.v)\n\tif a.encrypted {\n\t\tsalt := a.buf[:saltSize]\n\t\t_, err = io.ReadFull(r, salt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkey, iv := a.getKeys(salt)\n\t\tr = newAesDecryptReader(r, key, iv)\n\t\terr = readFull(r, b)\n\t} else {\n\t\t_, err = io.ReadFull(r, b)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcrc := b.uint16()\n\thash := crc32.NewIEEE()\n\thash.Write(b)\n\th := new(blockHeader15)\n\th.htype = b.byte()\n\th.flags = b.uint16()\n\tsize := b.uint16()\n\tif size < 7 {\n\t\treturn nil, errCorruptHeader\n\t}\n\tsize -= 7\n\tif int(size) > cap(a.buf) {\n\t\ta.buf = readBuf(make([]byte, size))\n\t}\n\th.data = a.buf[:size]\n\tif err := readFull(r, h.data); err != nil {\n\t\treturn nil, err\n\t}\n\thash.Write(h.data)\n\tif crc != uint16(hash.Sum32()) {\n\t\treturn nil, errBadHeaderCrc\n\t}\n\tif h.flags&blockHasData > 0 {\n\t\tif len(h.data) < 4 {\n\t\t\treturn nil, errCorruptHeader\n\t\t}\n\t\th.dataSize = int64(h.data.uint32())\n\t}\n\tif (h.htype == blockService || h.htype == blockFile) && h.flags&fileLargeData > 0 {\n\t\tif len(h.data) < 25 {\n\t\t\treturn nil, errCorruptHeader\n\t\t}\n\t\tb := h.data[21:25]\n\t\th.dataSize |= int64(b.uint32()) << 32\n\t}\n\treturn h, nil\n}", "code_tokens": ["func", "(", "a", "*", "archive15", ")", "readBlockHeader", "(", ")", "(", "*", "blockHeader15", ",", "error", ")", "{", "var", "err", "error", "\n", "b", ":=", "a", ".", "buf", "[", ":", "7", "]", "\n", "r", ":=", "io", ".", "Reader", "(", "a", ".", "v", ")", "\n", "if", "a", ".", "encrypted", "{", "salt", ":=", "a", ".", "buf", "[", ":", "saltSize", "]", "\n", "_", ",", "err", "=", "io", ".", "ReadFull", "(", "r", ",", "salt", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "key", ",", "iv", ":=", "a", ".", "getKeys", "(", "salt", ")", "\n", "r", "=", "newAesDecryptReader", "(", "r", ",", "key", ",", "iv", ")", "\n", "err", "=", "readFull", "(", "r", ",", "b", ")", "\n", "}", "else", "{", "_", ",", "err", "=", "io", ".", "ReadFull", "(", "r", ",", "b", ")", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "crc", ":=", "b", ".", "uint16", "(", ")", "\n", "hash", ":=", "crc32", ".", "NewIEEE", "(", ")", "\n", "hash", ".", "Write", "(", "b", ")", "\n", "h", ":=", "new", "(", "blockHeader15", ")", "\n", "h", ".", "htype", "=", "b", ".", "byte", "(", ")", "\n", "h", ".", "flags", "=", "b", ".", "uint16", "(", ")", "\n", "size", ":=", "b", ".", "uint16", "(", ")", "\n", "if", "size", "<", "7", "{", "return", "nil", ",", "errCorruptHeader", "\n", "}", "\n", "size", "-=", "7", "\n", "if", "int", "(", "size", ")", ">", "cap", "(", "a", ".", "buf", ")", "{", "a", ".", "buf", "=", "readBuf", "(", "make", "(", "[", "]", "byte", ",", "size", ")", ")", "\n", "}", "\n", "h", ".", "data", "=", "a", ".", "buf", "[", ":", "size", "]", "\n", "if", "err", ":=", "readFull", "(", "r", ",", "h", ".", "data", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "hash", ".", "Write", "(", "h", ".", "data", ")", "\n", "if", "crc", "!=", "uint16", "(", "hash", ".", "Sum32", "(", ")", ")", "{", "return", "nil", ",", "errBadHeaderCrc", "\n", "}", "\n", "if", "h", ".", "flags", "&", "blockHasData", ">", "0", "{", "if", "len", "(", "h", ".", "data", ")", "<", "4", "{", "return", "nil", ",", "errCorruptHeader", "\n", "}", "\n", "h", ".", "dataSize", "=", "int64", "(", "h", ".", "data", ".", "uint32", "(", ")", ")", "\n", "}", "\n", "if", "(", "h", ".", "htype", "==", "blockService", "||", "h", ".", "htype", "==", "blockFile", ")", "&&", "h", ".", "flags", "&", "fileLargeData", ">", "0", "{", "if", "len", "(", "h", ".", "data", ")", "<", "25", "{", "return", "nil", ",", "errCorruptHeader", "\n", "}", "\n", "b", ":=", "h", ".", "data", "[", "21", ":", "25", "]", "\n", "h", ".", "dataSize", "|=", "int64", "(", "b", ".", "uint32", "(", ")", ")", "<<", "32", "\n", "}", "\n", "return", "h", ",", "nil", "\n", "}"], "docstring": "// readBlockHeader returns the next block header in the archive.\n// It will return io.EOF if there were no bytes read.", "docstring_tokens": ["readBlockHeader", "returns", "the", "next", "block", "header", "in", "the", "archive", ".", "It", "will", "return", "io", ".", "EOF", "if", "there", "were", "no", "bytes", "read", "."], "sha": "197ef08ef68c4454ae5970a9c2692d6056ceb8d7", "url": "https://github.com/nwaples/rardecode/blob/197ef08ef68c4454ae5970a9c2692d6056ceb8d7/archive15.go#L360-L416", "partition": "test"}
{"repo": "hashicorp/raft", "path": "configuration.go", "func_name": "Clone", "original_string": "func (c *Configuration) Clone() (copy Configuration) {\n\tcopy.Servers = append(copy.Servers, c.Servers...)\n\treturn\n}", "language": "go", "code": "func (c *Configuration) Clone() (copy Configuration) {\n\tcopy.Servers = append(copy.Servers, c.Servers...)\n\treturn\n}", "code_tokens": ["func", "(", "c", "*", "Configuration", ")", "Clone", "(", ")", "(", "copy", "Configuration", ")", "{", "copy", ".", "Servers", "=", "append", "(", "copy", ".", "Servers", ",", "c", ".", "Servers", "...", ")", "\n", "return", "\n", "}"], "docstring": "// Clone makes a deep copy of a Configuration.", "docstring_tokens": ["Clone", "makes", "a", "deep", "copy", "of", "a", "Configuration", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/configuration.go#L60-L63", "partition": "test"}
{"repo": "nwaples/rardecode", "path": "archive50.go", "func_name": "newArchive50", "original_string": "func newArchive50(r *bufio.Reader, password string) fileBlockReader {\n\ta := new(archive50)\n\ta.v = r\n\ta.pass = []byte(password)\n\ta.buf = make([]byte, 100)\n\treturn a\n}", "language": "go", "code": "func newArchive50(r *bufio.Reader, password string) fileBlockReader {\n\ta := new(archive50)\n\ta.v = r\n\ta.pass = []byte(password)\n\ta.buf = make([]byte, 100)\n\treturn a\n}", "code_tokens": ["func", "newArchive50", "(", "r", "*", "bufio", ".", "Reader", ",", "password", "string", ")", "fileBlockReader", "{", "a", ":=", "new", "(", "archive50", ")", "\n", "a", ".", "v", "=", "r", "\n", "a", ".", "pass", "=", "[", "]", "byte", "(", "password", ")", "\n", "a", ".", "buf", "=", "make", "(", "[", "]", "byte", ",", "100", ")", "\n", "return", "a", "\n", "}"], "docstring": "// newArchive50 creates a new fileBlockReader for a Version 5 archive.", "docstring_tokens": ["newArchive50", "creates", "a", "new", "fileBlockReader", "for", "a", "Version", "5", "archive", "."], "sha": "197ef08ef68c4454ae5970a9c2692d6056ceb8d7", "url": "https://github.com/nwaples/rardecode/blob/197ef08ef68c4454ae5970a9c2692d6056ceb8d7/archive50.go#L469-L475", "partition": "test"}
{"repo": "adamzy/cedar-go", "path": "cedar.go", "func_name": "get", "original_string": "func (da *cedar) get(key []byte, from, pos int) *int {\n\tfor ; pos < len(key); pos++ {\n\t\tif value := da.Array[from].Value; value >= 0 && value != ValueLimit {\n\t\t\tto := da.follow(from, 0)\n\t\t\tda.Array[to].Value = value\n\t\t}\n\t\tfrom = da.follow(from, key[pos])\n\t}\n\tto := from\n\tif da.Array[from].Value < 0 {\n\t\tto = da.follow(from, 0)\n\t}\n\treturn &da.Array[to].Value\n}", "language": "go", "code": "func (da *cedar) get(key []byte, from, pos int) *int {\n\tfor ; pos < len(key); pos++ {\n\t\tif value := da.Array[from].Value; value >= 0 && value != ValueLimit {\n\t\t\tto := da.follow(from, 0)\n\t\t\tda.Array[to].Value = value\n\t\t}\n\t\tfrom = da.follow(from, key[pos])\n\t}\n\tto := from\n\tif da.Array[from].Value < 0 {\n\t\tto = da.follow(from, 0)\n\t}\n\treturn &da.Array[to].Value\n}", "code_tokens": ["func", "(", "da", "*", "cedar", ")", "get", "(", "key", "[", "]", "byte", ",", "from", ",", "pos", "int", ")", "*", "int", "{", "for", ";", "pos", "<", "len", "(", "key", ")", ";", "pos", "++", "{", "if", "value", ":=", "da", ".", "Array", "[", "from", "]", ".", "Value", ";", "value", ">=", "0", "&&", "value", "!=", "ValueLimit", "{", "to", ":=", "da", ".", "follow", "(", "from", ",", "0", ")", "\n", "da", ".", "Array", "[", "to", "]", ".", "Value", "=", "value", "\n", "}", "\n", "from", "=", "da", ".", "follow", "(", "from", ",", "key", "[", "pos", "]", ")", "\n", "}", "\n", "to", ":=", "from", "\n", "if", "da", ".", "Array", "[", "from", "]", ".", "Value", "<", "0", "{", "to", "=", "da", ".", "follow", "(", "from", ",", "0", ")", "\n", "}", "\n", "return", "&", "da", ".", "Array", "[", "to", "]", ".", "Value", "\n", "}"], "docstring": "// Get value by key, insert the key if not exist", "docstring_tokens": ["Get", "value", "by", "key", "insert", "the", "key", "if", "not", "exist"], "sha": "80a9c64b256db37ac20aff007907c649afb714f1", "url": "https://github.com/adamzy/cedar-go/blob/80a9c64b256db37ac20aff007907c649afb714f1/cedar.go#L72-L85", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/kube/client.go", "func_name": "NewClient", "original_string": "func NewClient(c *Cluster, namespace string) (*Client, error) {\n\t// Relies on json encoding/decoding []byte as base64\n\t// https://golang.org/pkg/encoding/json/#Marshal\n\tcc := c.ClientCertificate\n\tck := c.ClientKey\n\tca := c.ClusterCACertificate\n\n\tcert, err := tls.X509KeyPair(cc, ck)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcp := x509.NewCertPool()\n\tcp.AppendCertsFromPEM(ca)\n\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tMinVersion:   tls.VersionTLS12,\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tRootCAs:      cp,\n\t\t},\n\t}\n\treturn &Client{\n\t\tlogger:    logrus.WithField(\"client\", \"kube\"),\n\t\tbaseURL:   c.Endpoint,\n\t\tclient:    &http.Client{Transport: tr, Timeout: requestTimeout},\n\t\tnamespace: namespace,\n\t}, nil\n}", "language": "go", "code": "func NewClient(c *Cluster, namespace string) (*Client, error) {\n\t// Relies on json encoding/decoding []byte as base64\n\t// https://golang.org/pkg/encoding/json/#Marshal\n\tcc := c.ClientCertificate\n\tck := c.ClientKey\n\tca := c.ClusterCACertificate\n\n\tcert, err := tls.X509KeyPair(cc, ck)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcp := x509.NewCertPool()\n\tcp.AppendCertsFromPEM(ca)\n\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tMinVersion:   tls.VersionTLS12,\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tRootCAs:      cp,\n\t\t},\n\t}\n\treturn &Client{\n\t\tlogger:    logrus.WithField(\"client\", \"kube\"),\n\t\tbaseURL:   c.Endpoint,\n\t\tclient:    &http.Client{Transport: tr, Timeout: requestTimeout},\n\t\tnamespace: namespace,\n\t}, nil\n}", "code_tokens": ["func", "NewClient", "(", "c", "*", "Cluster", ",", "namespace", "string", ")", "(", "*", "Client", ",", "error", ")", "{", "// Relies on json encoding/decoding []byte as base64", "// https://golang.org/pkg/encoding/json/#Marshal", "cc", ":=", "c", ".", "ClientCertificate", "\n", "ck", ":=", "c", ".", "ClientKey", "\n", "ca", ":=", "c", ".", "ClusterCACertificate", "\n\n", "cert", ",", "err", ":=", "tls", ".", "X509KeyPair", "(", "cc", ",", "ck", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "cp", ":=", "x509", ".", "NewCertPool", "(", ")", "\n", "cp", ".", "AppendCertsFromPEM", "(", "ca", ")", "\n\n", "tr", ":=", "&", "http", ".", "Transport", "{", "TLSClientConfig", ":", "&", "tls", ".", "Config", "{", "MinVersion", ":", "tls", ".", "VersionTLS12", ",", "Certificates", ":", "[", "]", "tls", ".", "Certificate", "{", "cert", "}", ",", "RootCAs", ":", "cp", ",", "}", ",", "}", "\n", "return", "&", "Client", "{", "logger", ":", "logrus", ".", "WithField", "(", "\"", "\"", ",", "\"", "\"", ")", ",", "baseURL", ":", "c", ".", "Endpoint", ",", "client", ":", "&", "http", ".", "Client", "{", "Transport", ":", "tr", ",", "Timeout", ":", "requestTimeout", "}", ",", "namespace", ":", "namespace", ",", "}", ",", "nil", "\n", "}"], "docstring": "// NewClient returns an authenticated Client using the keys in the Cluster.", "docstring_tokens": ["NewClient", "returns", "an", "authenticated", "Client", "using", "the", "keys", "in", "the", "Cluster", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/kube/client.go#L385-L413", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "connection.go", "func_name": "handlePingReq", "original_string": "func (c *Connection) handlePingReq(frame *Frame) {\n\tif state := c.readState(); state != connectionActive {\n\t\tc.protocolError(frame.Header.ID, errConnNotActive{\"ping on incoming\", state})\n\t\treturn\n\t}\n\n\tpingRes := &pingRes{id: frame.Header.ID}\n\tif err := c.sendMessage(pingRes); err != nil {\n\t\tc.connectionError(\"send pong\", err)\n\t}\n}", "language": "go", "code": "func (c *Connection) handlePingReq(frame *Frame) {\n\tif state := c.readState(); state != connectionActive {\n\t\tc.protocolError(frame.Header.ID, errConnNotActive{\"ping on incoming\", state})\n\t\treturn\n\t}\n\n\tpingRes := &pingRes{id: frame.Header.ID}\n\tif err := c.sendMessage(pingRes); err != nil {\n\t\tc.connectionError(\"send pong\", err)\n\t}\n}", "code_tokens": ["func", "(", "c", "*", "Connection", ")", "handlePingReq", "(", "frame", "*", "Frame", ")", "{", "if", "state", ":=", "c", ".", "readState", "(", ")", ";", "state", "!=", "connectionActive", "{", "c", ".", "protocolError", "(", "frame", ".", "Header", ".", "ID", ",", "errConnNotActive", "{", "\"", "\"", ",", "state", "}", ")", "\n", "return", "\n", "}", "\n\n", "pingRes", ":=", "&", "pingRes", "{", "id", ":", "frame", ".", "Header", ".", "ID", "}", "\n", "if", "err", ":=", "c", ".", "sendMessage", "(", "pingRes", ")", ";", "err", "!=", "nil", "{", "c", ".", "connectionError", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "}"], "docstring": "// handlePingReq responds to the pingReq message with a pingRes.", "docstring_tokens": ["handlePingReq", "responds", "to", "the", "pingReq", "message", "with", "a", "pingRes", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/connection.go#L416-L426", "partition": "test"}
{"repo": "blacklabeldata/namedtuple", "path": "integers.go", "func_name": "PutUint64", "original_string": "func (b *TupleBuilder) PutUint64(field string, value uint64) (wrote uint64, err error) {\n\n\t// field type should be\n\tif err = b.typeCheck(field, Uint64Field); err != nil {\n\t\treturn 0, err\n\t}\n\n\tif value < math.MaxUint8 {\n\n\t\t// minimum bytes is 2 (type code + value)\n\t\tif b.available() < 2 {\n\t\t\treturn 0, xbinary.ErrOutOfRange\n\t\t}\n\n\t\t// write type code\n\t\tb.buffer[b.pos] = byte(UnsignedLong8Code.OpCode)\n\n\t\t// write value\n\t\tb.buffer[b.pos+1] = byte(value)\n\n\t\t// set field offset\n\t\tb.offsets[field] = b.pos\n\n\t\t// incr pos\n\t\tb.pos += 2\n\n\t\treturn 2, nil\n\t} else if value < math.MaxUint16 {\n\n\t\t// write value\n\t\t// length check performed by xbinary\n\t\twrote, err = xbinary.LittleEndian.PutUint16(b.buffer, b.pos+1, uint16(value))\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// write type code\n\t\tb.buffer[b.pos] = byte(UnsignedLong16Code.OpCode)\n\n\t\t// set field offset\n\t\tb.offsets[field] = b.pos\n\n\t\t// incr pos\n\t\tb.pos += 3\n\n\t\t// wrote 3 bytes\n\t\treturn 3, nil\n\t} else if value < math.MaxUint32 {\n\n\t\t// write value\n\t\t// length check performed by xbinary\n\t\twrote, err = xbinary.LittleEndian.PutUint32(b.buffer, b.pos+1, uint32(value))\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// write type code\n\t\tb.buffer[b.pos] = byte(UnsignedLong32Code.OpCode)\n\n\t\t// set field offset\n\t\tb.offsets[field] = b.pos\n\n\t\t// incr pos\n\t\tb.pos += 5\n\n\t\t// wrote 5 bytes\n\t\treturn 5, nil\n\t}\n\n\t// write value\n\t// length check performed by xbinary\n\twrote, err = xbinary.LittleEndian.PutUint64(b.buffer, b.pos+1, value)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// write type code\n\tb.buffer[b.pos] = byte(UnsignedLong64Code.OpCode)\n\n\t// set field offset\n\tb.offsets[field] = b.pos\n\n\t// incr pos\n\tb.pos += 9\n\n\t// wrote 9 bytes\n\treturn 9, nil\n\n}", "language": "go", "code": "func (b *TupleBuilder) PutUint64(field string, value uint64) (wrote uint64, err error) {\n\n\t// field type should be\n\tif err = b.typeCheck(field, Uint64Field); err != nil {\n\t\treturn 0, err\n\t}\n\n\tif value < math.MaxUint8 {\n\n\t\t// minimum bytes is 2 (type code + value)\n\t\tif b.available() < 2 {\n\t\t\treturn 0, xbinary.ErrOutOfRange\n\t\t}\n\n\t\t// write type code\n\t\tb.buffer[b.pos] = byte(UnsignedLong8Code.OpCode)\n\n\t\t// write value\n\t\tb.buffer[b.pos+1] = byte(value)\n\n\t\t// set field offset\n\t\tb.offsets[field] = b.pos\n\n\t\t// incr pos\n\t\tb.pos += 2\n\n\t\treturn 2, nil\n\t} else if value < math.MaxUint16 {\n\n\t\t// write value\n\t\t// length check performed by xbinary\n\t\twrote, err = xbinary.LittleEndian.PutUint16(b.buffer, b.pos+1, uint16(value))\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// write type code\n\t\tb.buffer[b.pos] = byte(UnsignedLong16Code.OpCode)\n\n\t\t// set field offset\n\t\tb.offsets[field] = b.pos\n\n\t\t// incr pos\n\t\tb.pos += 3\n\n\t\t// wrote 3 bytes\n\t\treturn 3, nil\n\t} else if value < math.MaxUint32 {\n\n\t\t// write value\n\t\t// length check performed by xbinary\n\t\twrote, err = xbinary.LittleEndian.PutUint32(b.buffer, b.pos+1, uint32(value))\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// write type code\n\t\tb.buffer[b.pos] = byte(UnsignedLong32Code.OpCode)\n\n\t\t// set field offset\n\t\tb.offsets[field] = b.pos\n\n\t\t// incr pos\n\t\tb.pos += 5\n\n\t\t// wrote 5 bytes\n\t\treturn 5, nil\n\t}\n\n\t// write value\n\t// length check performed by xbinary\n\twrote, err = xbinary.LittleEndian.PutUint64(b.buffer, b.pos+1, value)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// write type code\n\tb.buffer[b.pos] = byte(UnsignedLong64Code.OpCode)\n\n\t// set field offset\n\tb.offsets[field] = b.pos\n\n\t// incr pos\n\tb.pos += 9\n\n\t// wrote 9 bytes\n\treturn 9, nil\n\n}", "code_tokens": ["func", "(", "b", "*", "TupleBuilder", ")", "PutUint64", "(", "field", "string", ",", "value", "uint64", ")", "(", "wrote", "uint64", ",", "err", "error", ")", "{", "// field type should be", "if", "err", "=", "b", ".", "typeCheck", "(", "field", ",", "Uint64Field", ")", ";", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n\n", "if", "value", "<", "math", ".", "MaxUint8", "{", "// minimum bytes is 2 (type code + value)", "if", "b", ".", "available", "(", ")", "<", "2", "{", "return", "0", ",", "xbinary", ".", "ErrOutOfRange", "\n", "}", "\n\n", "// write type code", "b", ".", "buffer", "[", "b", ".", "pos", "]", "=", "byte", "(", "UnsignedLong8Code", ".", "OpCode", ")", "\n\n", "// write value", "b", ".", "buffer", "[", "b", ".", "pos", "+", "1", "]", "=", "byte", "(", "value", ")", "\n\n", "// set field offset", "b", ".", "offsets", "[", "field", "]", "=", "b", ".", "pos", "\n\n", "// incr pos", "b", ".", "pos", "+=", "2", "\n\n", "return", "2", ",", "nil", "\n", "}", "else", "if", "value", "<", "math", ".", "MaxUint16", "{", "// write value", "// length check performed by xbinary", "wrote", ",", "err", "=", "xbinary", ".", "LittleEndian", ".", "PutUint16", "(", "b", ".", "buffer", ",", "b", ".", "pos", "+", "1", ",", "uint16", "(", "value", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n\n", "// write type code", "b", ".", "buffer", "[", "b", ".", "pos", "]", "=", "byte", "(", "UnsignedLong16Code", ".", "OpCode", ")", "\n\n", "// set field offset", "b", ".", "offsets", "[", "field", "]", "=", "b", ".", "pos", "\n\n", "// incr pos", "b", ".", "pos", "+=", "3", "\n\n", "// wrote 3 bytes", "return", "3", ",", "nil", "\n", "}", "else", "if", "value", "<", "math", ".", "MaxUint32", "{", "// write value", "// length check performed by xbinary", "wrote", ",", "err", "=", "xbinary", ".", "LittleEndian", ".", "PutUint32", "(", "b", ".", "buffer", ",", "b", ".", "pos", "+", "1", ",", "uint32", "(", "value", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n\n", "// write type code", "b", ".", "buffer", "[", "b", ".", "pos", "]", "=", "byte", "(", "UnsignedLong32Code", ".", "OpCode", ")", "\n\n", "// set field offset", "b", ".", "offsets", "[", "field", "]", "=", "b", ".", "pos", "\n\n", "// incr pos", "b", ".", "pos", "+=", "5", "\n\n", "// wrote 5 bytes", "return", "5", ",", "nil", "\n", "}", "\n\n", "// write value", "// length check performed by xbinary", "wrote", ",", "err", "=", "xbinary", ".", "LittleEndian", ".", "PutUint64", "(", "b", ".", "buffer", ",", "b", ".", "pos", "+", "1", ",", "value", ")", "\n", "if", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n", "// write type code", "b", ".", "buffer", "[", "b", ".", "pos", "]", "=", "byte", "(", "UnsignedLong64Code", ".", "OpCode", ")", "\n\n", "// set field offset", "b", ".", "offsets", "[", "field", "]", "=", "b", ".", "pos", "\n\n", "// incr pos", "b", ".", "pos", "+=", "9", "\n\n", "// wrote 9 bytes", "return", "9", ",", "nil", "\n\n", "}"], "docstring": "// PutUint64 sets a 64-bit unsigned integer for the given field name. The field name must be a Uint64Field. Otherwise, an error will be returned. If the type buffer no longer has enough space to write the value, an `xbinary.ErrOutOfRange` error will be returned. Upon success, the number of bytes written as well as a nil error will be returned. The type code will be written first. If the absolute value is `< math.MaxUint8`, only 1 byte will be written. If the absolute value is `< math.MaxUint16`, only 2 bytes will be written. If the absolute value is `< math.MaxUint32`, only 4 bytes will be written. Otherwise, the entire 64-bit value will be written.", "docstring_tokens": ["PutUint64", "sets", "a", "64", "-", "bit", "unsigned", "integer", "for", "the", "given", "field", "name", ".", "The", "field", "name", "must", "be", "a", "Uint64Field", ".", "Otherwise", "an", "error", "will", "be", "returned", ".", "If", "the", "type", "buffer", "no", "longer", "has", "enough", "space", "to", "write", "the", "value", "an", "xbinary", ".", "ErrOutOfRange", "error", "will", "be", "returned", ".", "Upon", "success", "the", "number", "of", "bytes", "written", "as", "well", "as", "a", "nil", "error", "will", "be", "returned", ".", "The", "type", "code", "will", "be", "written", "first", ".", "If", "the", "absolute", "value", "is", "<", "math", ".", "MaxUint8", "only", "1", "byte", "will", "be", "written", ".", "If", "the", "absolute", "value", "is", "<", "math", ".", "MaxUint16", "only", "2", "bytes", "will", "be", "written", ".", "If", "the", "absolute", "value", "is", "<", "math", ".", "MaxUint32", "only", "4", "bytes", "will", "be", "written", ".", "Otherwise", "the", "entire", "64", "-", "bit", "value", "will", "be", "written", "."], "sha": "c341f1db44f30b8164294aa8605ede42be604aba", "url": "https://github.com/blacklabeldata/namedtuple/blob/c341f1db44f30b8164294aa8605ede42be604aba/integers.go#L308-L395", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "velodrome/transform/plugins/comment_counter.go", "func_name": "ReceiveComment", "original_string": "func (c *CommentCounterPlugin) ReceiveComment(comment sql.Comment) []Point {\n\tpoints := []Point{}\n\tfor _, matcher := range c.matcher {\n\t\tif matcher.MatchString(comment.Body) {\n\t\t\tpoints = append(points, Point{\n\t\t\t\tValues: map[string]interface{}{\n\t\t\t\t\t\"comment\": 1,\n\t\t\t\t},\n\t\t\t\tDate: comment.CommentCreatedAt,\n\t\t\t})\n\t\t}\n\t}\n\treturn points\n}", "language": "go", "code": "func (c *CommentCounterPlugin) ReceiveComment(comment sql.Comment) []Point {\n\tpoints := []Point{}\n\tfor _, matcher := range c.matcher {\n\t\tif matcher.MatchString(comment.Body) {\n\t\t\tpoints = append(points, Point{\n\t\t\t\tValues: map[string]interface{}{\n\t\t\t\t\t\"comment\": 1,\n\t\t\t\t},\n\t\t\t\tDate: comment.CommentCreatedAt,\n\t\t\t})\n\t\t}\n\t}\n\treturn points\n}", "code_tokens": ["func", "(", "c", "*", "CommentCounterPlugin", ")", "ReceiveComment", "(", "comment", "sql", ".", "Comment", ")", "[", "]", "Point", "{", "points", ":=", "[", "]", "Point", "{", "}", "\n", "for", "_", ",", "matcher", ":=", "range", "c", ".", "matcher", "{", "if", "matcher", ".", "MatchString", "(", "comment", ".", "Body", ")", "{", "points", "=", "append", "(", "points", ",", "Point", "{", "Values", ":", "map", "[", "string", "]", "interface", "{", "}", "{", "\"", "\"", ":", "1", ",", "}", ",", "Date", ":", "comment", ".", "CommentCreatedAt", ",", "}", ")", "\n", "}", "\n", "}", "\n", "return", "points", "\n", "}"], "docstring": "// ReceiveComment adds matching comments to InfluxDB", "docstring_tokens": ["ReceiveComment", "adds", "matching", "comments", "to", "InfluxDB"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/transform/plugins/comment_counter.go#L62-L75", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "http/response.go", "func_name": "ReadResponse", "original_string": "func ReadResponse(call tchannel.ArgReadable) (*http.Response, error) {\n\tvar arg2 []byte\n\tif err := tchannel.NewArgReader(call.Arg2Reader()).Read(&arg2); err != nil {\n\t\treturn nil, err\n\t}\n\n\trb := typed.NewReadBuffer(arg2)\n\tstatusCode := rb.ReadUint16()\n\tmessage := readVarintString(rb)\n\n\tresponse := &http.Response{\n\t\tStatusCode: int(statusCode),\n\t\tStatus:     fmt.Sprintf(\"%v %v\", statusCode, message),\n\t\tProto:      \"HTTP/1.1\",\n\t\tProtoMajor: 1,\n\t\tProtoMinor: 1,\n\t\tHeader:     make(http.Header),\n\t}\n\treadHeaders(rb, response.Header)\n\tif err := rb.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\targ3Reader, err := call.Arg3Reader()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.Body = arg3Reader\n\treturn response, nil\n}", "language": "go", "code": "func ReadResponse(call tchannel.ArgReadable) (*http.Response, error) {\n\tvar arg2 []byte\n\tif err := tchannel.NewArgReader(call.Arg2Reader()).Read(&arg2); err != nil {\n\t\treturn nil, err\n\t}\n\n\trb := typed.NewReadBuffer(arg2)\n\tstatusCode := rb.ReadUint16()\n\tmessage := readVarintString(rb)\n\n\tresponse := &http.Response{\n\t\tStatusCode: int(statusCode),\n\t\tStatus:     fmt.Sprintf(\"%v %v\", statusCode, message),\n\t\tProto:      \"HTTP/1.1\",\n\t\tProtoMajor: 1,\n\t\tProtoMinor: 1,\n\t\tHeader:     make(http.Header),\n\t}\n\treadHeaders(rb, response.Header)\n\tif err := rb.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\targ3Reader, err := call.Arg3Reader()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse.Body = arg3Reader\n\treturn response, nil\n}", "code_tokens": ["func", "ReadResponse", "(", "call", "tchannel", ".", "ArgReadable", ")", "(", "*", "http", ".", "Response", ",", "error", ")", "{", "var", "arg2", "[", "]", "byte", "\n", "if", "err", ":=", "tchannel", ".", "NewArgReader", "(", "call", ".", "Arg2Reader", "(", ")", ")", ".", "Read", "(", "&", "arg2", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "rb", ":=", "typed", ".", "NewReadBuffer", "(", "arg2", ")", "\n", "statusCode", ":=", "rb", ".", "ReadUint16", "(", ")", "\n", "message", ":=", "readVarintString", "(", "rb", ")", "\n\n", "response", ":=", "&", "http", ".", "Response", "{", "StatusCode", ":", "int", "(", "statusCode", ")", ",", "Status", ":", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "statusCode", ",", "message", ")", ",", "Proto", ":", "\"", "\"", ",", "ProtoMajor", ":", "1", ",", "ProtoMinor", ":", "1", ",", "Header", ":", "make", "(", "http", ".", "Header", ")", ",", "}", "\n", "readHeaders", "(", "rb", ",", "response", ".", "Header", ")", "\n", "if", "err", ":=", "rb", ".", "Err", "(", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "arg3Reader", ",", "err", ":=", "call", ".", "Arg3Reader", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "response", ".", "Body", "=", "arg3Reader", "\n", "return", "response", ",", "nil", "\n", "}"], "docstring": "// ReadResponse reads a http.Response from the given readers.", "docstring_tokens": ["ReadResponse", "reads", "a", "http", ".", "Response", "from", "the", "given", "readers", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/http/response.go#L33-L63", "partition": "test"}
{"repo": "libp2p/go-libp2p-net", "path": "options.go", "func_name": "GetNoDial", "original_string": "func GetNoDial(ctx context.Context) (nodial bool, reason string) {\n\tv := ctx.Value(noDial)\n\tif v != nil {\n\t\treturn true, v.(string)\n\t}\n\n\treturn false, \"\"\n}", "language": "go", "code": "func GetNoDial(ctx context.Context) (nodial bool, reason string) {\n\tv := ctx.Value(noDial)\n\tif v != nil {\n\t\treturn true, v.(string)\n\t}\n\n\treturn false, \"\"\n}", "code_tokens": ["func", "GetNoDial", "(", "ctx", "context", ".", "Context", ")", "(", "nodial", "bool", ",", "reason", "string", ")", "{", "v", ":=", "ctx", ".", "Value", "(", "noDial", ")", "\n", "if", "v", "!=", "nil", "{", "return", "true", ",", "v", ".", "(", "string", ")", "\n", "}", "\n\n", "return", "false", ",", "\"", "\"", "\n", "}"], "docstring": "// GetNoDial returns true if the no dial option is set in the context.", "docstring_tokens": ["GetNoDial", "returns", "true", "if", "the", "no", "dial", "option", "is", "set", "in", "the", "context", "."], "sha": "a60cde50df6872512892ca85019341d281f72a42", "url": "https://github.com/libp2p/go-libp2p-net/blob/a60cde50df6872512892ca85019341d281f72a42/options.go#L18-L25", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "store.go", "func_name": "UpExpire", "original_string": "func (rp *redisProvider) UpExpire(sid string) error {\n\tvar err error\n\tredisPool.Exec(func(c *redis.Client) {\n\t\terr = c.Expire(sid, sessExpire).Err()\n\t})\n\treturn err\n}", "language": "go", "code": "func (rp *redisProvider) UpExpire(sid string) error {\n\tvar err error\n\tredisPool.Exec(func(c *redis.Client) {\n\t\terr = c.Expire(sid, sessExpire).Err()\n\t})\n\treturn err\n}", "code_tokens": ["func", "(", "rp", "*", "redisProvider", ")", "UpExpire", "(", "sid", "string", ")", "error", "{", "var", "err", "error", "\n", "redisPool", ".", "Exec", "(", "func", "(", "c", "*", "redis", ".", "Client", ")", "{", "err", "=", "c", ".", "Expire", "(", "sid", ",", "sessExpire", ")", ".", "Err", "(", ")", "\n", "}", ")", "\n", "return", "err", "\n", "}"], "docstring": "// UpExpire refresh session expire", "docstring_tokens": ["UpExpire", "refresh", "session", "expire"], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/store.go#L104-L110", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/storage_lvm_utils.go", "func_name": "copyContainerThinpool", "original_string": "func (s *storageLvm) copyContainerThinpool(target container, source container, readonly bool) error {\n\terr := s.createSnapshotContainer(target, source, readonly)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error creating snapshot LV for copy: %s\", err)\n\t\treturn err\n\t}\n\n\t// Generate a new xfs's UUID\n\tLVFilesystem := s.getLvmFilesystem()\n\tpoolName := s.getOnDiskPoolName()\n\tcontainerName := target.Name()\n\tcontainerLvmName := containerNameToLVName(containerName)\n\tcontainerLvDevPath := getLvmDevPath(target.Project(), poolName,\n\t\tstoragePoolVolumeAPIEndpointContainers, containerLvmName)\n\n\t// If btrfstune sees two btrfs filesystems with the same UUID it\n\t// gets confused and wants both of them unmounted. So unmount\n\t// the source as well.\n\tif LVFilesystem == \"btrfs\" {\n\t\tourUmount, err := s.ContainerUmount(source, source.Path())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif ourUmount {\n\t\t\tdefer s.ContainerMount(source)\n\t\t}\n\t}\n\n\tmsg, err := fsGenerateNewUUID(LVFilesystem, containerLvDevPath)\n\tif err != nil {\n\t\tlogger.Errorf(\"Failed to create new \\\"%s\\\" UUID for container \\\"%s\\\" on storage pool \\\"%s\\\": %s\", LVFilesystem, containerName, s.pool.Name, msg)\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (s *storageLvm) copyContainerThinpool(target container, source container, readonly bool) error {\n\terr := s.createSnapshotContainer(target, source, readonly)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error creating snapshot LV for copy: %s\", err)\n\t\treturn err\n\t}\n\n\t// Generate a new xfs's UUID\n\tLVFilesystem := s.getLvmFilesystem()\n\tpoolName := s.getOnDiskPoolName()\n\tcontainerName := target.Name()\n\tcontainerLvmName := containerNameToLVName(containerName)\n\tcontainerLvDevPath := getLvmDevPath(target.Project(), poolName,\n\t\tstoragePoolVolumeAPIEndpointContainers, containerLvmName)\n\n\t// If btrfstune sees two btrfs filesystems with the same UUID it\n\t// gets confused and wants both of them unmounted. So unmount\n\t// the source as well.\n\tif LVFilesystem == \"btrfs\" {\n\t\tourUmount, err := s.ContainerUmount(source, source.Path())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif ourUmount {\n\t\t\tdefer s.ContainerMount(source)\n\t\t}\n\t}\n\n\tmsg, err := fsGenerateNewUUID(LVFilesystem, containerLvDevPath)\n\tif err != nil {\n\t\tlogger.Errorf(\"Failed to create new \\\"%s\\\" UUID for container \\\"%s\\\" on storage pool \\\"%s\\\": %s\", LVFilesystem, containerName, s.pool.Name, msg)\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "s", "*", "storageLvm", ")", "copyContainerThinpool", "(", "target", "container", ",", "source", "container", ",", "readonly", "bool", ")", "error", "{", "err", ":=", "s", ".", "createSnapshotContainer", "(", "target", ",", "source", ",", "readonly", ")", "\n", "if", "err", "!=", "nil", "{", "logger", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "return", "err", "\n", "}", "\n\n", "// Generate a new xfs's UUID", "LVFilesystem", ":=", "s", ".", "getLvmFilesystem", "(", ")", "\n", "poolName", ":=", "s", ".", "getOnDiskPoolName", "(", ")", "\n", "containerName", ":=", "target", ".", "Name", "(", ")", "\n", "containerLvmName", ":=", "containerNameToLVName", "(", "containerName", ")", "\n", "containerLvDevPath", ":=", "getLvmDevPath", "(", "target", ".", "Project", "(", ")", ",", "poolName", ",", "storagePoolVolumeAPIEndpointContainers", ",", "containerLvmName", ")", "\n\n", "// If btrfstune sees two btrfs filesystems with the same UUID it", "// gets confused and wants both of them unmounted. So unmount", "// the source as well.", "if", "LVFilesystem", "==", "\"", "\"", "{", "ourUmount", ",", "err", ":=", "s", ".", "ContainerUmount", "(", "source", ",", "source", ".", "Path", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "ourUmount", "{", "defer", "s", ".", "ContainerMount", "(", "source", ")", "\n", "}", "\n", "}", "\n\n", "msg", ",", "err", ":=", "fsGenerateNewUUID", "(", "LVFilesystem", ",", "containerLvDevPath", ")", "\n", "if", "err", "!=", "nil", "{", "logger", ".", "Errorf", "(", "\"", "\\\"", "\\\"", "\\\"", "\\\"", "\\\"", "\\\"", "\"", ",", "LVFilesystem", ",", "containerName", ",", "s", ".", "pool", ".", "Name", ",", "msg", ")", "\n", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Copy a container on a storage pool that does use a thinpool.", "docstring_tokens": ["Copy", "a", "container", "on", "a", "storage", "pool", "that", "does", "use", "a", "thinpool", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/storage_lvm_utils.go#L302-L338", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pfs/pfs.go", "func_name": "IsCommitDeletedErr", "original_string": "func IsCommitDeletedErr(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\treturn commitDeletedRe.MatchString(grpcutil.ScrubGRPC(err).Error())\n}", "language": "go", "code": "func IsCommitDeletedErr(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\treturn commitDeletedRe.MatchString(grpcutil.ScrubGRPC(err).Error())\n}", "code_tokens": ["func", "IsCommitDeletedErr", "(", "err", "error", ")", "bool", "{", "if", "err", "==", "nil", "{", "return", "false", "\n", "}", "\n", "return", "commitDeletedRe", ".", "MatchString", "(", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", ".", "Error", "(", ")", ")", "\n", "}"], "docstring": "// IsCommitDeletedErr returns true if 'err' has an error message that matches\n// ErrCommitDeleted", "docstring_tokens": ["IsCommitDeletedErr", "returns", "true", "if", "err", "has", "an", "error", "message", "that", "matches", "ErrCommitDeleted"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pfs/pfs.go#L121-L126", "partition": "test"}
{"repo": "danott/envflag", "path": "envflag.go", "func_name": "Environ", "original_string": "func Environ() []string {\n\ts := make([]string, 0)\n\n\tFlagSet.VisitAll(func(f *flag.Flag) {\n\t\tif value, ok := getenv(f.Name); ok {\n\t\t\ts = append(s, flagAsEnv(f.Name)+\"=\"+value)\n\t\t}\n\t})\n\n\treturn s\n}", "language": "go", "code": "func Environ() []string {\n\ts := make([]string, 0)\n\n\tFlagSet.VisitAll(func(f *flag.Flag) {\n\t\tif value, ok := getenv(f.Name); ok {\n\t\t\ts = append(s, flagAsEnv(f.Name)+\"=\"+value)\n\t\t}\n\t})\n\n\treturn s\n}", "code_tokens": ["func", "Environ", "(", ")", "[", "]", "string", "{", "s", ":=", "make", "(", "[", "]", "string", ",", "0", ")", "\n\n", "FlagSet", ".", "VisitAll", "(", "func", "(", "f", "*", "flag", ".", "Flag", ")", "{", "if", "value", ",", "ok", ":=", "getenv", "(", "f", ".", "Name", ")", ";", "ok", "{", "s", "=", "append", "(", "s", ",", "flagAsEnv", "(", "f", ".", "Name", ")", "+", "\"", "\"", "+", "value", ")", "\n", "}", "\n", "}", ")", "\n\n", "return", "s", "\n", "}"], "docstring": "// Identical to os.Environ, but limited to the environment variable equivalents\n// for the flags your program cares about.", "docstring_tokens": ["Identical", "to", "os", ".", "Environ", "but", "limited", "to", "the", "environment", "variable", "equivalents", "for", "the", "flags", "your", "program", "cares", "about", "."], "sha": "14c5f9aaa227ddb49f3206fe06432edfc27735a5", "url": "https://github.com/danott/envflag/blob/14c5f9aaa227ddb49f3206fe06432edfc27735a5/envflag.go#L59-L69", "partition": "test"}
{"repo": "qor/render", "path": "render.go", "func_name": "RegisterViewPath", "original_string": "func (render *Render) RegisterViewPath(paths ...string) {\n\tfor _, pth := range paths {\n\t\tif filepath.IsAbs(pth) {\n\t\t\trender.ViewPaths = append(render.ViewPaths, pth)\n\t\t\trender.AssetFileSystem.RegisterPath(pth)\n\t\t} else {\n\t\t\tif absPath, err := filepath.Abs(pth); err == nil && isExistingDir(absPath) {\n\t\t\t\trender.ViewPaths = append(render.ViewPaths, absPath)\n\t\t\t\trender.AssetFileSystem.RegisterPath(absPath)\n\t\t\t} else if isExistingDir(filepath.Join(utils.AppRoot, \"vendor\", pth)) {\n\t\t\t\trender.AssetFileSystem.RegisterPath(filepath.Join(utils.AppRoot, \"vendor\", pth))\n\t\t\t} else {\n\t\t\t\tfor _, gopath := range utils.GOPATH() {\n\t\t\t\t\tif p := filepath.Join(gopath, \"src\", pth); isExistingDir(p) {\n\t\t\t\t\t\trender.ViewPaths = append(render.ViewPaths, p)\n\t\t\t\t\t\trender.AssetFileSystem.RegisterPath(p)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "language": "go", "code": "func (render *Render) RegisterViewPath(paths ...string) {\n\tfor _, pth := range paths {\n\t\tif filepath.IsAbs(pth) {\n\t\t\trender.ViewPaths = append(render.ViewPaths, pth)\n\t\t\trender.AssetFileSystem.RegisterPath(pth)\n\t\t} else {\n\t\t\tif absPath, err := filepath.Abs(pth); err == nil && isExistingDir(absPath) {\n\t\t\t\trender.ViewPaths = append(render.ViewPaths, absPath)\n\t\t\t\trender.AssetFileSystem.RegisterPath(absPath)\n\t\t\t} else if isExistingDir(filepath.Join(utils.AppRoot, \"vendor\", pth)) {\n\t\t\t\trender.AssetFileSystem.RegisterPath(filepath.Join(utils.AppRoot, \"vendor\", pth))\n\t\t\t} else {\n\t\t\t\tfor _, gopath := range utils.GOPATH() {\n\t\t\t\t\tif p := filepath.Join(gopath, \"src\", pth); isExistingDir(p) {\n\t\t\t\t\t\trender.ViewPaths = append(render.ViewPaths, p)\n\t\t\t\t\t\trender.AssetFileSystem.RegisterPath(p)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "render", "*", "Render", ")", "RegisterViewPath", "(", "paths", "...", "string", ")", "{", "for", "_", ",", "pth", ":=", "range", "paths", "{", "if", "filepath", ".", "IsAbs", "(", "pth", ")", "{", "render", ".", "ViewPaths", "=", "append", "(", "render", ".", "ViewPaths", ",", "pth", ")", "\n", "render", ".", "AssetFileSystem", ".", "RegisterPath", "(", "pth", ")", "\n", "}", "else", "{", "if", "absPath", ",", "err", ":=", "filepath", ".", "Abs", "(", "pth", ")", ";", "err", "==", "nil", "&&", "isExistingDir", "(", "absPath", ")", "{", "render", ".", "ViewPaths", "=", "append", "(", "render", ".", "ViewPaths", ",", "absPath", ")", "\n", "render", ".", "AssetFileSystem", ".", "RegisterPath", "(", "absPath", ")", "\n", "}", "else", "if", "isExistingDir", "(", "filepath", ".", "Join", "(", "utils", ".", "AppRoot", ",", "\"", "\"", ",", "pth", ")", ")", "{", "render", ".", "AssetFileSystem", ".", "RegisterPath", "(", "filepath", ".", "Join", "(", "utils", ".", "AppRoot", ",", "\"", "\"", ",", "pth", ")", ")", "\n", "}", "else", "{", "for", "_", ",", "gopath", ":=", "range", "utils", ".", "GOPATH", "(", ")", "{", "if", "p", ":=", "filepath", ".", "Join", "(", "gopath", ",", "\"", "\"", ",", "pth", ")", ";", "isExistingDir", "(", "p", ")", "{", "render", ".", "ViewPaths", "=", "append", "(", "render", ".", "ViewPaths", ",", "p", ")", "\n", "render", ".", "AssetFileSystem", ".", "RegisterPath", "(", "p", ")", "\n", "}", "\n", "}", "\n", "}", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// RegisterViewPath register view path", "docstring_tokens": ["RegisterViewPath", "register", "view", "path"], "sha": "63566e46f01b134ae9882a59a06518e82a903231", "url": "https://github.com/qor/render/blob/63566e46f01b134ae9882a59a06518e82a903231/render.go#L60-L81", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/auth/cmds/cmds.go", "func_name": "Cmds", "original_string": "func Cmds(noMetrics, noPortForwarding *bool) []*cobra.Command {\n\tvar commands []*cobra.Command\n\n\tauth := &cobra.Command{\n\t\tShort: \"Auth commands manage access to data in a Pachyderm cluster\",\n\t\tLong:  \"Auth commands manage access to data in a Pachyderm cluster\",\n\t}\n\n\tcommands = append(commands, cmdutil.CreateAlias(auth, \"auth\"))\n\tcommands = append(commands, ActivateCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, DeactivateCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, LoginCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, LogoutCmd())\n\tcommands = append(commands, WhoamiCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, CheckCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, SetScopeCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, GetCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, ListAdminsCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, ModifyAdminsCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, GetAuthTokenCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, UseAuthTokenCmd())\n\tcommands = append(commands, GetConfigCmd(noPortForwarding))\n\tcommands = append(commands, SetConfigCmd(noPortForwarding))\n\n\treturn commands\n}", "language": "go", "code": "func Cmds(noMetrics, noPortForwarding *bool) []*cobra.Command {\n\tvar commands []*cobra.Command\n\n\tauth := &cobra.Command{\n\t\tShort: \"Auth commands manage access to data in a Pachyderm cluster\",\n\t\tLong:  \"Auth commands manage access to data in a Pachyderm cluster\",\n\t}\n\n\tcommands = append(commands, cmdutil.CreateAlias(auth, \"auth\"))\n\tcommands = append(commands, ActivateCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, DeactivateCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, LoginCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, LogoutCmd())\n\tcommands = append(commands, WhoamiCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, CheckCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, SetScopeCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, GetCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, ListAdminsCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, ModifyAdminsCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, GetAuthTokenCmd(noMetrics, noPortForwarding))\n\tcommands = append(commands, UseAuthTokenCmd())\n\tcommands = append(commands, GetConfigCmd(noPortForwarding))\n\tcommands = append(commands, SetConfigCmd(noPortForwarding))\n\n\treturn commands\n}", "code_tokens": ["func", "Cmds", "(", "noMetrics", ",", "noPortForwarding", "*", "bool", ")", "[", "]", "*", "cobra", ".", "Command", "{", "var", "commands", "[", "]", "*", "cobra", ".", "Command", "\n\n", "auth", ":=", "&", "cobra", ".", "Command", "{", "Short", ":", "\"", "\"", ",", "Long", ":", "\"", "\"", ",", "}", "\n\n", "commands", "=", "append", "(", "commands", ",", "cmdutil", ".", "CreateAlias", "(", "auth", ",", "\"", "\"", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "ActivateCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "DeactivateCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "LoginCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "LogoutCmd", "(", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "WhoamiCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "CheckCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "SetScopeCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "GetCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "ListAdminsCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "ModifyAdminsCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "GetAuthTokenCmd", "(", "noMetrics", ",", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "UseAuthTokenCmd", "(", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "GetConfigCmd", "(", "noPortForwarding", ")", ")", "\n", "commands", "=", "append", "(", "commands", ",", "SetConfigCmd", "(", "noPortForwarding", ")", ")", "\n\n", "return", "commands", "\n", "}"], "docstring": "// Cmds returns a list of cobra commands for authenticating and authorizing\n// users in an auth-enabled Pachyderm cluster.", "docstring_tokens": ["Cmds", "returns", "a", "list", "of", "cobra", "commands", "for", "authenticating", "and", "authorizing", "users", "in", "an", "auth", "-", "enabled", "Pachyderm", "cluster", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/auth/cmds/cmds.go#L493-L518", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nodetable/table.go", "func_name": "New", "original_string": "func New(hfn HashFn, kfn EqualKeyFn) *NodeTable {\n\tnt := &NodeTable{\n\t\tfastHT:   make(map[uint32]uint64),\n\t\tslowHT:   make(map[uint32][]uint64),\n\t\thash:     hfn,\n\t\tkeyEqual: kfn,\n\t}\n\n\tbuf := dbInstances.MakeBuf()\n\tdefer dbInstances.FreeBuf(buf)\n\tdbInstances.Insert(unsafe.Pointer(nt), CompareNodeTable, buf, &dbInstances.Stats)\n\n\treturn nt\n}", "language": "go", "code": "func New(hfn HashFn, kfn EqualKeyFn) *NodeTable {\n\tnt := &NodeTable{\n\t\tfastHT:   make(map[uint32]uint64),\n\t\tslowHT:   make(map[uint32][]uint64),\n\t\thash:     hfn,\n\t\tkeyEqual: kfn,\n\t}\n\n\tbuf := dbInstances.MakeBuf()\n\tdefer dbInstances.FreeBuf(buf)\n\tdbInstances.Insert(unsafe.Pointer(nt), CompareNodeTable, buf, &dbInstances.Stats)\n\n\treturn nt\n}", "code_tokens": ["func", "New", "(", "hfn", "HashFn", ",", "kfn", "EqualKeyFn", ")", "*", "NodeTable", "{", "nt", ":=", "&", "NodeTable", "{", "fastHT", ":", "make", "(", "map", "[", "uint32", "]", "uint64", ")", ",", "slowHT", ":", "make", "(", "map", "[", "uint32", "]", "[", "]", "uint64", ")", ",", "hash", ":", "hfn", ",", "keyEqual", ":", "kfn", ",", "}", "\n\n", "buf", ":=", "dbInstances", ".", "MakeBuf", "(", ")", "\n", "defer", "dbInstances", ".", "FreeBuf", "(", "buf", ")", "\n", "dbInstances", ".", "Insert", "(", "unsafe", ".", "Pointer", "(", "nt", ")", ",", "CompareNodeTable", ",", "buf", ",", "&", "dbInstances", ".", "Stats", ")", "\n\n", "return", "nt", "\n", "}"], "docstring": "// New creates a nodetable instance", "docstring_tokens": ["New", "creates", "a", "nodetable", "instance"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nodetable/table.go#L80-L93", "partition": "test"}
{"repo": "jhillyerd/enmime", "path": "match.go", "func_name": "BreadthMatchAll", "original_string": "func (p *Part) BreadthMatchAll(matcher PartMatcher) []*Part {\n\tq := list.New()\n\tq.PushBack(p)\n\n\tmatches := make([]*Part, 0, 10)\n\n\t// Push children onto queue and attempt to match in that order\n\tfor q.Len() > 0 {\n\t\te := q.Front()\n\t\tp := e.Value.(*Part)\n\t\tif matcher(p) {\n\t\t\tmatches = append(matches, p)\n\t\t}\n\t\tq.Remove(e)\n\t\tc := p.FirstChild\n\t\tfor c != nil {\n\t\t\tq.PushBack(c)\n\t\t\tc = c.NextSibling\n\t\t}\n\t}\n\n\treturn matches\n}", "language": "go", "code": "func (p *Part) BreadthMatchAll(matcher PartMatcher) []*Part {\n\tq := list.New()\n\tq.PushBack(p)\n\n\tmatches := make([]*Part, 0, 10)\n\n\t// Push children onto queue and attempt to match in that order\n\tfor q.Len() > 0 {\n\t\te := q.Front()\n\t\tp := e.Value.(*Part)\n\t\tif matcher(p) {\n\t\t\tmatches = append(matches, p)\n\t\t}\n\t\tq.Remove(e)\n\t\tc := p.FirstChild\n\t\tfor c != nil {\n\t\t\tq.PushBack(c)\n\t\t\tc = c.NextSibling\n\t\t}\n\t}\n\n\treturn matches\n}", "code_tokens": ["func", "(", "p", "*", "Part", ")", "BreadthMatchAll", "(", "matcher", "PartMatcher", ")", "[", "]", "*", "Part", "{", "q", ":=", "list", ".", "New", "(", ")", "\n", "q", ".", "PushBack", "(", "p", ")", "\n\n", "matches", ":=", "make", "(", "[", "]", "*", "Part", ",", "0", ",", "10", ")", "\n\n", "// Push children onto queue and attempt to match in that order", "for", "q", ".", "Len", "(", ")", ">", "0", "{", "e", ":=", "q", ".", "Front", "(", ")", "\n", "p", ":=", "e", ".", "Value", ".", "(", "*", "Part", ")", "\n", "if", "matcher", "(", "p", ")", "{", "matches", "=", "append", "(", "matches", ",", "p", ")", "\n", "}", "\n", "q", ".", "Remove", "(", "e", ")", "\n", "c", ":=", "p", ".", "FirstChild", "\n", "for", "c", "!=", "nil", "{", "q", ".", "PushBack", "(", "c", ")", "\n", "c", "=", "c", ".", "NextSibling", "\n", "}", "\n", "}", "\n\n", "return", "matches", "\n", "}"], "docstring": "// BreadthMatchAll performs a breadth first search of the Part tree and returns all parts that cause\n// the given matcher to return true", "docstring_tokens": ["BreadthMatchAll", "performs", "a", "breadth", "first", "search", "of", "the", "Part", "tree", "and", "returns", "all", "parts", "that", "cause", "the", "given", "matcher", "to", "return", "true"], "sha": "874cc30e023f36bd1df525716196887b0f04851b", "url": "https://github.com/jhillyerd/enmime/blob/874cc30e023f36bd1df525716196887b0f04851b/match.go#L38-L60", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "functional/runner/election_command.go", "func_name": "NewElectionCommand", "original_string": "func NewElectionCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"election [election name (defaults to 'elector')]\",\n\t\tShort: \"Performs election operation\",\n\t\tRun:   runElectionFunc,\n\t}\n\tcmd.Flags().IntVar(&totalClientConnections, \"total-client-connections\", 10, \"total number of client connections\")\n\treturn cmd\n}", "language": "go", "code": "func NewElectionCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"election [election name (defaults to 'elector')]\",\n\t\tShort: \"Performs election operation\",\n\t\tRun:   runElectionFunc,\n\t}\n\tcmd.Flags().IntVar(&totalClientConnections, \"total-client-connections\", 10, \"total number of client connections\")\n\treturn cmd\n}", "code_tokens": ["func", "NewElectionCommand", "(", ")", "*", "cobra", ".", "Command", "{", "cmd", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Run", ":", "runElectionFunc", ",", "}", "\n", "cmd", ".", "Flags", "(", ")", ".", "IntVar", "(", "&", "totalClientConnections", ",", "\"", "\"", ",", "10", ",", "\"", "\"", ")", "\n", "return", "cmd", "\n", "}"], "docstring": "// NewElectionCommand returns the cobra command for \"election runner\".", "docstring_tokens": ["NewElectionCommand", "returns", "the", "cobra", "command", "for", "election", "runner", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/functional/runner/election_command.go#L28-L36", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/pfs.go", "func_name": "DeleteBranch", "original_string": "func (c APIClient) DeleteBranch(repoName string, branch string, force bool) error {\n\t_, err := c.PfsAPIClient.DeleteBranch(\n\t\tc.Ctx(),\n\t\t&pfs.DeleteBranchRequest{\n\t\t\tBranch: NewBranch(repoName, branch),\n\t\t\tForce:  force,\n\t\t},\n\t)\n\treturn grpcutil.ScrubGRPC(err)\n}", "language": "go", "code": "func (c APIClient) DeleteBranch(repoName string, branch string, force bool) error {\n\t_, err := c.PfsAPIClient.DeleteBranch(\n\t\tc.Ctx(),\n\t\t&pfs.DeleteBranchRequest{\n\t\t\tBranch: NewBranch(repoName, branch),\n\t\t\tForce:  force,\n\t\t},\n\t)\n\treturn grpcutil.ScrubGRPC(err)\n}", "code_tokens": ["func", "(", "c", "APIClient", ")", "DeleteBranch", "(", "repoName", "string", ",", "branch", "string", ",", "force", "bool", ")", "error", "{", "_", ",", "err", ":=", "c", ".", "PfsAPIClient", ".", "DeleteBranch", "(", "c", ".", "Ctx", "(", ")", ",", "&", "pfs", ".", "DeleteBranchRequest", "{", "Branch", ":", "NewBranch", "(", "repoName", ",", "branch", ")", ",", "Force", ":", "force", ",", "}", ",", ")", "\n", "return", "grpcutil", ".", "ScrubGRPC", "(", "err", ")", "\n", "}"], "docstring": "// DeleteBranch deletes a branch, but leaves the commits themselves intact.\n// In other words, those commits can still be accessed via commit IDs and\n// other branches they happen to be on.", "docstring_tokens": ["DeleteBranch", "deletes", "a", "branch", "but", "leaves", "the", "commits", "themselves", "intact", ".", "In", "other", "words", "those", "commits", "can", "still", "be", "accessed", "via", "commit", "IDs", "and", "other", "branches", "they", "happen", "to", "be", "on", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/pfs.go#L367-L376", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/collection/collection.go", "func_name": "getMultiIndexPaths", "original_string": "func (c *readWriteCollection) getMultiIndexPaths(val interface{}, index *Index, key string) []string {\n\tvar indexPaths []string\n\tfield := reflect.Indirect(reflect.ValueOf(val)).FieldByName(index.Field)\n\tfor i := 0; i < field.Len(); i++ {\n\t\tindexPaths = append(indexPaths, c.indexPath(index, field.Index(i).Interface(), key))\n\t}\n\treturn indexPaths\n}", "language": "go", "code": "func (c *readWriteCollection) getMultiIndexPaths(val interface{}, index *Index, key string) []string {\n\tvar indexPaths []string\n\tfield := reflect.Indirect(reflect.ValueOf(val)).FieldByName(index.Field)\n\tfor i := 0; i < field.Len(); i++ {\n\t\tindexPaths = append(indexPaths, c.indexPath(index, field.Index(i).Interface(), key))\n\t}\n\treturn indexPaths\n}", "code_tokens": ["func", "(", "c", "*", "readWriteCollection", ")", "getMultiIndexPaths", "(", "val", "interface", "{", "}", ",", "index", "*", "Index", ",", "key", "string", ")", "[", "]", "string", "{", "var", "indexPaths", "[", "]", "string", "\n", "field", ":=", "reflect", ".", "Indirect", "(", "reflect", ".", "ValueOf", "(", "val", ")", ")", ".", "FieldByName", "(", "index", ".", "Field", ")", "\n", "for", "i", ":=", "0", ";", "i", "<", "field", ".", "Len", "(", ")", ";", "i", "++", "{", "indexPaths", "=", "append", "(", "indexPaths", ",", "c", ".", "indexPath", "(", "index", ",", "field", ".", "Index", "(", "i", ")", ".", "Interface", "(", ")", ",", "key", ")", ")", "\n", "}", "\n", "return", "indexPaths", "\n", "}"], "docstring": "// Giving a value, a multi-index, and the key of the item, return the\n// paths under which the multi-index items should be stored.", "docstring_tokens": ["Giving", "a", "value", "a", "multi", "-", "index", "and", "the", "key", "of", "the", "item", "return", "the", "paths", "under", "which", "the", "multi", "-", "index", "items", "should", "be", "stored", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/collection/collection.go#L227-L234", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/rafthttp/transport.go", "func_name": "MendPeer", "original_string": "func (t *Transport) MendPeer(id types.ID) {\n\tt.mu.RLock()\n\tp, pok := t.peers[id]\n\tg, gok := t.remotes[id]\n\tt.mu.RUnlock()\n\n\tif pok {\n\t\tp.(Pausable).Resume()\n\t}\n\tif gok {\n\t\tg.Resume()\n\t}\n}", "language": "go", "code": "func (t *Transport) MendPeer(id types.ID) {\n\tt.mu.RLock()\n\tp, pok := t.peers[id]\n\tg, gok := t.remotes[id]\n\tt.mu.RUnlock()\n\n\tif pok {\n\t\tp.(Pausable).Resume()\n\t}\n\tif gok {\n\t\tg.Resume()\n\t}\n}", "code_tokens": ["func", "(", "t", "*", "Transport", ")", "MendPeer", "(", "id", "types", ".", "ID", ")", "{", "t", ".", "mu", ".", "RLock", "(", ")", "\n", "p", ",", "pok", ":=", "t", ".", "peers", "[", "id", "]", "\n", "g", ",", "gok", ":=", "t", ".", "remotes", "[", "id", "]", "\n", "t", ".", "mu", ".", "RUnlock", "(", ")", "\n\n", "if", "pok", "{", "p", ".", "(", "Pausable", ")", ".", "Resume", "(", ")", "\n", "}", "\n", "if", "gok", "{", "g", ".", "Resume", "(", ")", "\n", "}", "\n", "}"], "docstring": "// MendPeer recovers the message dropping behavior of the given peer.", "docstring_tokens": ["MendPeer", "recovers", "the", "message", "dropping", "behavior", "of", "the", "given", "peer", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/transport.go#L254-L266", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "app/app.go", "func_name": "validateNew", "original_string": "func (app *App) validateNew() error {\n\tif app.Name == InternalAppName || !validation.ValidateName(app.Name) {\n\t\tmsg := \"Invalid app name, your app should have at most 40 \" +\n\t\t\t\"characters, containing only lower case letters, numbers or dashes, \" +\n\t\t\t\"starting with a letter.\"\n\t\treturn &tsuruErrors.ValidationError{Message: msg}\n\t}\n\treturn app.validate()\n}", "language": "go", "code": "func (app *App) validateNew() error {\n\tif app.Name == InternalAppName || !validation.ValidateName(app.Name) {\n\t\tmsg := \"Invalid app name, your app should have at most 40 \" +\n\t\t\t\"characters, containing only lower case letters, numbers or dashes, \" +\n\t\t\t\"starting with a letter.\"\n\t\treturn &tsuruErrors.ValidationError{Message: msg}\n\t}\n\treturn app.validate()\n}", "code_tokens": ["func", "(", "app", "*", "App", ")", "validateNew", "(", ")", "error", "{", "if", "app", ".", "Name", "==", "InternalAppName", "||", "!", "validation", ".", "ValidateName", "(", "app", ".", "Name", ")", "{", "msg", ":=", "\"", "\"", "+", "\"", "\"", "+", "\"", "\"", "\n", "return", "&", "tsuruErrors", ".", "ValidationError", "{", "Message", ":", "msg", "}", "\n", "}", "\n", "return", "app", ".", "validate", "(", ")", "\n", "}"], "docstring": "// validateNew checks app name format, pool and plan", "docstring_tokens": ["validateNew", "checks", "app", "name", "format", "pool", "and", "plan"], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/app/app.go#L1173-L1181", "partition": "test"}
{"repo": "mgutz/str", "path": "funcsAO.go", "func_name": "ChompLeftF", "original_string": "func ChompLeftF(prefix string) func(string) string {\n\treturn func(s string) string {\n\t\treturn ChompLeft(s, prefix)\n\t}\n}", "language": "go", "code": "func ChompLeftF(prefix string) func(string) string {\n\treturn func(s string) string {\n\t\treturn ChompLeft(s, prefix)\n\t}\n}", "code_tokens": ["func", "ChompLeftF", "(", "prefix", "string", ")", "func", "(", "string", ")", "string", "{", "return", "func", "(", "s", "string", ")", "string", "{", "return", "ChompLeft", "(", "s", ",", "prefix", ")", "\n", "}", "\n", "}"], "docstring": "// ChompLeftF is the filter form of ChompLeft.", "docstring_tokens": ["ChompLeftF", "is", "the", "filter", "form", "of", "ChompLeft", "."], "sha": "968bf66e3da857419e4f6e71b2d5c9ae95682dc4", "url": "https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsAO.go#L115-L119", "partition": "test"}
{"repo": "enaml-ops/enaml", "path": "concourse.go", "func_name": "AddGithubResource", "original_string": "func (s *ConcoursePipeline) AddGithubResource(name string, source map[string]interface{}) {\n\ts.AddResource(name, GithubResourceName, source)\n}", "language": "go", "code": "func (s *ConcoursePipeline) AddGithubResource(name string, source map[string]interface{}) {\n\ts.AddResource(name, GithubResourceName, source)\n}", "code_tokens": ["func", "(", "s", "*", "ConcoursePipeline", ")", "AddGithubResource", "(", "name", "string", ",", "source", "map", "[", "string", "]", "interface", "{", "}", ")", "{", "s", ".", "AddResource", "(", "name", ",", "GithubResourceName", ",", "source", ")", "\n", "}"], "docstring": "//AddGithubResource github specific resource add", "docstring_tokens": ["AddGithubResource", "github", "specific", "resource", "add"], "sha": "4f847ee10b41afca41fe09fa839cb2f6ade06fb5", "url": "https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/concourse.go#L86-L88", "partition": "test"}
{"repo": "bsm/sarama-cluster", "path": "offsets.go", "func_name": "MarkOffset", "original_string": "func (s *OffsetStash) MarkOffset(msg *sarama.ConsumerMessage, metadata string) {\n\ts.MarkPartitionOffset(msg.Topic, msg.Partition, msg.Offset, metadata)\n}", "language": "go", "code": "func (s *OffsetStash) MarkOffset(msg *sarama.ConsumerMessage, metadata string) {\n\ts.MarkPartitionOffset(msg.Topic, msg.Partition, msg.Offset, metadata)\n}", "code_tokens": ["func", "(", "s", "*", "OffsetStash", ")", "MarkOffset", "(", "msg", "*", "sarama", ".", "ConsumerMessage", ",", "metadata", "string", ")", "{", "s", ".", "MarkPartitionOffset", "(", "msg", ".", "Topic", ",", "msg", ".", "Partition", ",", "msg", ".", "Offset", ",", "metadata", ")", "\n", "}"], "docstring": "// MarkOffset stashes the provided message offset", "docstring_tokens": ["MarkOffset", "stashes", "the", "provided", "message", "offset"], "sha": "d5779253526cc8a3129a0e5d7cc429f4b4473ab4", "url": "https://github.com/bsm/sarama-cluster/blob/d5779253526cc8a3129a0e5d7cc429f4b4473ab4/offsets.go#L22-L24", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "genny/resource/resource.go", "func_name": "New", "original_string": "func New(opts *Options) (*genny.Generator, error) {\n\tg := genny.New()\n\n\tif err := opts.Validate(); err != nil {\n\t\treturn g, err\n\t}\n\n\tif !opts.SkipTemplates {\n\t\tcore := packr.New(\"github.com/gobuffalo/buffalo/genny/resource/templates/core\", \"../resource/templates/core\")\n\n\t\tif err := g.Box(core); err != nil {\n\t\t\treturn g, err\n\t\t}\n\t}\n\n\tvar abox packd.Box\n\tif opts.SkipModel {\n\t\tabox = packr.New(\"github.com/gobuffalo/buffalo/genny/resource/templates/standard\", \"../resource/templates/standard\")\n\t} else {\n\t\tabox = packr.New(\"github.com/gobuffalo/buffalo/genny/resource/templates/use_model\", \"../resource/templates/use_model\")\n\t}\n\n\tif err := g.Box(abox); err != nil {\n\t\treturn g, err\n\t}\n\n\tpres := presenter{\n\t\tApp:   opts.App,\n\t\tName:  name.New(opts.Name),\n\t\tModel: name.New(opts.Model),\n\t\tAttrs: opts.Attrs,\n\t}\n\tx := pres.Name.Resource().File().String()\n\tfolder := pres.Name.Folder().Pluralize().String()\n\tg.Transformer(genny.Replace(\"resource-name\", x))\n\tg.Transformer(genny.Replace(\"resource-use_model\", x))\n\tg.Transformer(genny.Replace(\"folder-name\", folder))\n\n\tdata := map[string]interface{}{\n\t\t\"opts\":    pres,\n\t\t\"actions\": actions(opts),\n\t\t\"folder\":  folder,\n\t}\n\thelpers := template.FuncMap{\n\t\t\"camelize\": func(s string) string {\n\t\t\treturn flect.Camelize(s)\n\t\t},\n\t}\n\tg.Transformer(gogen.TemplateTransformer(data, helpers))\n\n\tg.RunFn(installPop(opts))\n\n\tg.RunFn(addResource(pres))\n\treturn g, nil\n}", "language": "go", "code": "func New(opts *Options) (*genny.Generator, error) {\n\tg := genny.New()\n\n\tif err := opts.Validate(); err != nil {\n\t\treturn g, err\n\t}\n\n\tif !opts.SkipTemplates {\n\t\tcore := packr.New(\"github.com/gobuffalo/buffalo/genny/resource/templates/core\", \"../resource/templates/core\")\n\n\t\tif err := g.Box(core); err != nil {\n\t\t\treturn g, err\n\t\t}\n\t}\n\n\tvar abox packd.Box\n\tif opts.SkipModel {\n\t\tabox = packr.New(\"github.com/gobuffalo/buffalo/genny/resource/templates/standard\", \"../resource/templates/standard\")\n\t} else {\n\t\tabox = packr.New(\"github.com/gobuffalo/buffalo/genny/resource/templates/use_model\", \"../resource/templates/use_model\")\n\t}\n\n\tif err := g.Box(abox); err != nil {\n\t\treturn g, err\n\t}\n\n\tpres := presenter{\n\t\tApp:   opts.App,\n\t\tName:  name.New(opts.Name),\n\t\tModel: name.New(opts.Model),\n\t\tAttrs: opts.Attrs,\n\t}\n\tx := pres.Name.Resource().File().String()\n\tfolder := pres.Name.Folder().Pluralize().String()\n\tg.Transformer(genny.Replace(\"resource-name\", x))\n\tg.Transformer(genny.Replace(\"resource-use_model\", x))\n\tg.Transformer(genny.Replace(\"folder-name\", folder))\n\n\tdata := map[string]interface{}{\n\t\t\"opts\":    pres,\n\t\t\"actions\": actions(opts),\n\t\t\"folder\":  folder,\n\t}\n\thelpers := template.FuncMap{\n\t\t\"camelize\": func(s string) string {\n\t\t\treturn flect.Camelize(s)\n\t\t},\n\t}\n\tg.Transformer(gogen.TemplateTransformer(data, helpers))\n\n\tg.RunFn(installPop(opts))\n\n\tg.RunFn(addResource(pres))\n\treturn g, nil\n}", "code_tokens": ["func", "New", "(", "opts", "*", "Options", ")", "(", "*", "genny", ".", "Generator", ",", "error", ")", "{", "g", ":=", "genny", ".", "New", "(", ")", "\n\n", "if", "err", ":=", "opts", ".", "Validate", "(", ")", ";", "err", "!=", "nil", "{", "return", "g", ",", "err", "\n", "}", "\n\n", "if", "!", "opts", ".", "SkipTemplates", "{", "core", ":=", "packr", ".", "New", "(", "\"", "\"", ",", "\"", "\"", ")", "\n\n", "if", "err", ":=", "g", ".", "Box", "(", "core", ")", ";", "err", "!=", "nil", "{", "return", "g", ",", "err", "\n", "}", "\n", "}", "\n\n", "var", "abox", "packd", ".", "Box", "\n", "if", "opts", ".", "SkipModel", "{", "abox", "=", "packr", ".", "New", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "}", "else", "{", "abox", "=", "packr", ".", "New", "(", "\"", "\"", ",", "\"", "\"", ")", "\n", "}", "\n\n", "if", "err", ":=", "g", ".", "Box", "(", "abox", ")", ";", "err", "!=", "nil", "{", "return", "g", ",", "err", "\n", "}", "\n\n", "pres", ":=", "presenter", "{", "App", ":", "opts", ".", "App", ",", "Name", ":", "name", ".", "New", "(", "opts", ".", "Name", ")", ",", "Model", ":", "name", ".", "New", "(", "opts", ".", "Model", ")", ",", "Attrs", ":", "opts", ".", "Attrs", ",", "}", "\n", "x", ":=", "pres", ".", "Name", ".", "Resource", "(", ")", ".", "File", "(", ")", ".", "String", "(", ")", "\n", "folder", ":=", "pres", ".", "Name", ".", "Folder", "(", ")", ".", "Pluralize", "(", ")", ".", "String", "(", ")", "\n", "g", ".", "Transformer", "(", "genny", ".", "Replace", "(", "\"", "\"", ",", "x", ")", ")", "\n", "g", ".", "Transformer", "(", "genny", ".", "Replace", "(", "\"", "\"", ",", "x", ")", ")", "\n", "g", ".", "Transformer", "(", "genny", ".", "Replace", "(", "\"", "\"", ",", "folder", ")", ")", "\n\n", "data", ":=", "map", "[", "string", "]", "interface", "{", "}", "{", "\"", "\"", ":", "pres", ",", "\"", "\"", ":", "actions", "(", "opts", ")", ",", "\"", "\"", ":", "folder", ",", "}", "\n", "helpers", ":=", "template", ".", "FuncMap", "{", "\"", "\"", ":", "func", "(", "s", "string", ")", "string", "{", "return", "flect", ".", "Camelize", "(", "s", ")", "\n", "}", ",", "}", "\n", "g", ".", "Transformer", "(", "gogen", ".", "TemplateTransformer", "(", "data", ",", "helpers", ")", ")", "\n\n", "g", ".", "RunFn", "(", "installPop", "(", "opts", ")", ")", "\n\n", "g", ".", "RunFn", "(", "addResource", "(", "pres", ")", ")", "\n", "return", "g", ",", "nil", "\n", "}"], "docstring": "// New resource generator", "docstring_tokens": ["New", "resource", "generator"], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/genny/resource/resource.go#L15-L69", "partition": "test"}
{"repo": "HiLittleCat/core", "path": "log/log.go", "func_name": "StackWithCaller", "original_string": "func StackWithCaller(err interface{}) {\n\tstack := make([]byte, 64<<10)\n\tstack = stack[:runtime.Stack(stack, false)]\n\n\tif pack, ok := callerPackage(); ok {\n\t\tlog.Printf(\"%s: %v\\n%s\", pack, err, stack)\n\t} else {\n\t\tlog.Printf(\"%v\\n%s\", err, stack)\n\t}\n}", "language": "go", "code": "func StackWithCaller(err interface{}) {\n\tstack := make([]byte, 64<<10)\n\tstack = stack[:runtime.Stack(stack, false)]\n\n\tif pack, ok := callerPackage(); ok {\n\t\tlog.Printf(\"%s: %v\\n%s\", pack, err, stack)\n\t} else {\n\t\tlog.Printf(\"%v\\n%s\", err, stack)\n\t}\n}", "code_tokens": ["func", "StackWithCaller", "(", "err", "interface", "{", "}", ")", "{", "stack", ":=", "make", "(", "[", "]", "byte", ",", "64", "<<", "10", ")", "\n", "stack", "=", "stack", "[", ":", "runtime", ".", "Stack", "(", "stack", ",", "false", ")", "]", "\n\n", "if", "pack", ",", "ok", ":=", "callerPackage", "(", ")", ";", "ok", "{", "log", ".", "Printf", "(", "\"", "\\n", "\"", ",", "pack", ",", "err", ",", "stack", ")", "\n", "}", "else", "{", "log", ".", "Printf", "(", "\"", "\\n", "\"", ",", "err", ",", "stack", ")", "\n", "}", "\n", "}"], "docstring": "// StackWithCaller logs the error err with the caller package name and the stack trace.", "docstring_tokens": ["StackWithCaller", "logs", "the", "error", "err", "with", "the", "caller", "package", "name", "and", "the", "stack", "trace", "."], "sha": "ae2101184ecd36354d3fcff0ea69d67d3fdbe156", "url": "https://github.com/HiLittleCat/core/blob/ae2101184ecd36354d3fcff0ea69d67d3fdbe156/log/log.go#L19-L28", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/api_cluster.go", "func_name": "clusterGetMemberConfig", "original_string": "func clusterGetMemberConfig(cluster *db.Cluster) ([]api.ClusterMemberConfigKey, error) {\n\tvar pools map[string]map[string]string\n\tvar networks map[string]map[string]string\n\n\tkeys := []api.ClusterMemberConfigKey{}\n\n\terr := cluster.Transaction(func(tx *db.ClusterTx) error {\n\t\tvar err error\n\n\t\tpools, err = tx.StoragePoolsNodeConfig()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"Failed to fetch storage pools configuration\")\n\t\t}\n\n\t\tnetworks, err = tx.NetworksNodeConfig()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"Failed to fetch networks configuration\")\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor pool, config := range pools {\n\t\tfor key := range config {\n\t\t\tif strings.HasPrefix(key, \"volatile.\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tkey := api.ClusterMemberConfigKey{\n\t\t\t\tEntity:      \"storage-pool\",\n\t\t\t\tName:        pool,\n\t\t\t\tKey:         key,\n\t\t\t\tDescription: fmt.Sprintf(\"\\\"%s\\\" property for storage pool \\\"%s\\\"\", key, pool),\n\t\t\t}\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\n\tfor network, config := range networks {\n\t\tfor key := range config {\n\t\t\tif strings.HasPrefix(key, \"volatile.\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tkey := api.ClusterMemberConfigKey{\n\t\t\t\tEntity:      \"network\",\n\t\t\t\tName:        network,\n\t\t\t\tKey:         key,\n\t\t\t\tDescription: fmt.Sprintf(\"\\\"%s\\\" property for network \\\"%s\\\"\", key, network),\n\t\t\t}\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\n\treturn keys, nil\n}", "language": "go", "code": "func clusterGetMemberConfig(cluster *db.Cluster) ([]api.ClusterMemberConfigKey, error) {\n\tvar pools map[string]map[string]string\n\tvar networks map[string]map[string]string\n\n\tkeys := []api.ClusterMemberConfigKey{}\n\n\terr := cluster.Transaction(func(tx *db.ClusterTx) error {\n\t\tvar err error\n\n\t\tpools, err = tx.StoragePoolsNodeConfig()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"Failed to fetch storage pools configuration\")\n\t\t}\n\n\t\tnetworks, err = tx.NetworksNodeConfig()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"Failed to fetch networks configuration\")\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor pool, config := range pools {\n\t\tfor key := range config {\n\t\t\tif strings.HasPrefix(key, \"volatile.\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tkey := api.ClusterMemberConfigKey{\n\t\t\t\tEntity:      \"storage-pool\",\n\t\t\t\tName:        pool,\n\t\t\t\tKey:         key,\n\t\t\t\tDescription: fmt.Sprintf(\"\\\"%s\\\" property for storage pool \\\"%s\\\"\", key, pool),\n\t\t\t}\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\n\tfor network, config := range networks {\n\t\tfor key := range config {\n\t\t\tif strings.HasPrefix(key, \"volatile.\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tkey := api.ClusterMemberConfigKey{\n\t\t\t\tEntity:      \"network\",\n\t\t\t\tName:        network,\n\t\t\t\tKey:         key,\n\t\t\t\tDescription: fmt.Sprintf(\"\\\"%s\\\" property for network \\\"%s\\\"\", key, network),\n\t\t\t}\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\n\treturn keys, nil\n}", "code_tokens": ["func", "clusterGetMemberConfig", "(", "cluster", "*", "db", ".", "Cluster", ")", "(", "[", "]", "api", ".", "ClusterMemberConfigKey", ",", "error", ")", "{", "var", "pools", "map", "[", "string", "]", "map", "[", "string", "]", "string", "\n", "var", "networks", "map", "[", "string", "]", "map", "[", "string", "]", "string", "\n\n", "keys", ":=", "[", "]", "api", ".", "ClusterMemberConfigKey", "{", "}", "\n\n", "err", ":=", "cluster", ".", "Transaction", "(", "func", "(", "tx", "*", "db", ".", "ClusterTx", ")", "error", "{", "var", "err", "error", "\n\n", "pools", ",", "err", "=", "tx", ".", "StoragePoolsNodeConfig", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n\n", "networks", ",", "err", "=", "tx", ".", "NetworksNodeConfig", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "for", "pool", ",", "config", ":=", "range", "pools", "{", "for", "key", ":=", "range", "config", "{", "if", "strings", ".", "HasPrefix", "(", "key", ",", "\"", "\"", ")", "{", "continue", "\n", "}", "\n\n", "key", ":=", "api", ".", "ClusterMemberConfigKey", "{", "Entity", ":", "\"", "\"", ",", "Name", ":", "pool", ",", "Key", ":", "key", ",", "Description", ":", "fmt", ".", "Sprintf", "(", "\"", "\\\"", "\\\"", "\\\"", "\\\"", "\"", ",", "key", ",", "pool", ")", ",", "}", "\n", "keys", "=", "append", "(", "keys", ",", "key", ")", "\n", "}", "\n", "}", "\n\n", "for", "network", ",", "config", ":=", "range", "networks", "{", "for", "key", ":=", "range", "config", "{", "if", "strings", ".", "HasPrefix", "(", "key", ",", "\"", "\"", ")", "{", "continue", "\n", "}", "\n\n", "key", ":=", "api", ".", "ClusterMemberConfigKey", "{", "Entity", ":", "\"", "\"", ",", "Name", ":", "network", ",", "Key", ":", "key", ",", "Description", ":", "fmt", ".", "Sprintf", "(", "\"", "\\\"", "\\\"", "\\\"", "\\\"", "\"", ",", "key", ",", "network", ")", ",", "}", "\n", "keys", "=", "append", "(", "keys", ",", "key", ")", "\n", "}", "\n", "}", "\n\n", "return", "keys", ",", "nil", "\n", "}"], "docstring": "// Fetch information about all node-specific configuration keys set on the\n// storage pools and networks of this cluster.", "docstring_tokens": ["Fetch", "information", "about", "all", "node", "-", "specific", "configuration", "keys", "set", "on", "the", "storage", "pools", "and", "networks", "of", "this", "cluster", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/api_cluster.go#L101-L159", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "label_sync/main.go", "func_name": "create", "original_string": "func create(repo string, label Label) Update {\n\tlogrus.WithField(\"repo\", repo).WithField(\"label\", label.Name).Info(\"create\")\n\treturn Update{Why: \"missing\", Wanted: &label, repo: repo}\n}", "language": "go", "code": "func create(repo string, label Label) Update {\n\tlogrus.WithField(\"repo\", repo).WithField(\"label\", label.Name).Info(\"create\")\n\treturn Update{Why: \"missing\", Wanted: &label, repo: repo}\n}", "code_tokens": ["func", "create", "(", "repo", "string", ",", "label", "Label", ")", "Update", "{", "logrus", ".", "WithField", "(", "\"", "\"", ",", "repo", ")", ".", "WithField", "(", "\"", "\"", ",", "label", ".", "Name", ")", ".", "Info", "(", "\"", "\"", ")", "\n", "return", "Update", "{", "Why", ":", "\"", "\"", ",", "Wanted", ":", "&", "label", ",", "repo", ":", "repo", "}", "\n", "}"], "docstring": "// Create the label", "docstring_tokens": ["Create", "the", "label"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/label_sync/main.go#L396-L399", "partition": "test"}
{"repo": "fujiwara/fluent-agent-hydra", "path": "fluent/fluent.go", "func_name": "connect", "original_string": "func (f *Fluent) connect() (err error) {\n\thost, port, err := net.SplitHostPort(f.Server)\n\tif err != nil {\n\t\treturn err\n\t}\n\taddrs, err := net.LookupHost(host)\n\tif err != nil || len(addrs) == 0 {\n\t\treturn err\n\t}\n\t// for DNS round robin\n\tn := Rand.Intn(len(addrs))\n\taddr := addrs[n]\n\tvar format string\n\tif strings.Contains(addr, \":\") {\n\t\t// v6\n\t\tformat = \"[%s]:%s\"\n\t} else {\n\t\t// v4\n\t\tformat = \"%s:%s\"\n\t}\n\tresolved := fmt.Sprintf(format, addr, port)\n\tlog.Printf(\"[info] Connect to %s (%s)\", f.Server, resolved)\n\tf.conn, err = net.DialTimeout(\"tcp\", resolved, f.Config.Timeout)\n\tf.recordError(err)\n\treturn\n}", "language": "go", "code": "func (f *Fluent) connect() (err error) {\n\thost, port, err := net.SplitHostPort(f.Server)\n\tif err != nil {\n\t\treturn err\n\t}\n\taddrs, err := net.LookupHost(host)\n\tif err != nil || len(addrs) == 0 {\n\t\treturn err\n\t}\n\t// for DNS round robin\n\tn := Rand.Intn(len(addrs))\n\taddr := addrs[n]\n\tvar format string\n\tif strings.Contains(addr, \":\") {\n\t\t// v6\n\t\tformat = \"[%s]:%s\"\n\t} else {\n\t\t// v4\n\t\tformat = \"%s:%s\"\n\t}\n\tresolved := fmt.Sprintf(format, addr, port)\n\tlog.Printf(\"[info] Connect to %s (%s)\", f.Server, resolved)\n\tf.conn, err = net.DialTimeout(\"tcp\", resolved, f.Config.Timeout)\n\tf.recordError(err)\n\treturn\n}", "code_tokens": ["func", "(", "f", "*", "Fluent", ")", "connect", "(", ")", "(", "err", "error", ")", "{", "host", ",", "port", ",", "err", ":=", "net", ".", "SplitHostPort", "(", "f", ".", "Server", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "addrs", ",", "err", ":=", "net", ".", "LookupHost", "(", "host", ")", "\n", "if", "err", "!=", "nil", "||", "len", "(", "addrs", ")", "==", "0", "{", "return", "err", "\n", "}", "\n", "// for DNS round robin", "n", ":=", "Rand", ".", "Intn", "(", "len", "(", "addrs", ")", ")", "\n", "addr", ":=", "addrs", "[", "n", "]", "\n", "var", "format", "string", "\n", "if", "strings", ".", "Contains", "(", "addr", ",", "\"", "\"", ")", "{", "// v6", "format", "=", "\"", "\"", "\n", "}", "else", "{", "// v4", "format", "=", "\"", "\"", "\n", "}", "\n", "resolved", ":=", "fmt", ".", "Sprintf", "(", "format", ",", "addr", ",", "port", ")", "\n", "log", ".", "Printf", "(", "\"", "\"", ",", "f", ".", "Server", ",", "resolved", ")", "\n", "f", ".", "conn", ",", "err", "=", "net", ".", "DialTimeout", "(", "\"", "\"", ",", "resolved", ",", "f", ".", "Config", ".", "Timeout", ")", "\n", "f", ".", "recordError", "(", "err", ")", "\n", "return", "\n", "}"], "docstring": "// connect establishes a new connection using the specified transport.", "docstring_tokens": ["connect", "establishes", "a", "new", "connection", "using", "the", "specified", "transport", "."], "sha": "f5c1c02a0b892cf5c08918ec2ff7bbca71cc7e4f", "url": "https://github.com/fujiwara/fluent-agent-hydra/blob/f5c1c02a0b892cf5c08918ec2ff7bbca71cc7e4f/fluent/fluent.go#L132-L157", "partition": "test"}
{"repo": "enaml-ops/enaml", "path": "release/boshrelease.go", "func_name": "readBoshRelease", "original_string": "func (r *BoshRelease) readBoshRelease(rr io.Reader) error {\n\tw := pkg.NewTgzWalker(rr)\n\tw.OnMatch(\"release.MF\", func(file pkg.FileEntry) error {\n\t\treturn decodeYaml(file.Reader, &r.ReleaseManifest)\n\t})\n\tw.OnMatch(\"/jobs/\", func(file pkg.FileEntry) error {\n\t\tjob, jerr := r.readBoshJob(file.Reader)\n\t\tif jerr == nil {\n\t\t\tr.JobManifests[job.Name] = job\n\t\t}\n\t\treturn jerr\n\t})\n\terr := w.Walk()\n\treturn err\n}", "language": "go", "code": "func (r *BoshRelease) readBoshRelease(rr io.Reader) error {\n\tw := pkg.NewTgzWalker(rr)\n\tw.OnMatch(\"release.MF\", func(file pkg.FileEntry) error {\n\t\treturn decodeYaml(file.Reader, &r.ReleaseManifest)\n\t})\n\tw.OnMatch(\"/jobs/\", func(file pkg.FileEntry) error {\n\t\tjob, jerr := r.readBoshJob(file.Reader)\n\t\tif jerr == nil {\n\t\t\tr.JobManifests[job.Name] = job\n\t\t}\n\t\treturn jerr\n\t})\n\terr := w.Walk()\n\treturn err\n}", "code_tokens": ["func", "(", "r", "*", "BoshRelease", ")", "readBoshRelease", "(", "rr", "io", ".", "Reader", ")", "error", "{", "w", ":=", "pkg", ".", "NewTgzWalker", "(", "rr", ")", "\n", "w", ".", "OnMatch", "(", "\"", "\"", ",", "func", "(", "file", "pkg", ".", "FileEntry", ")", "error", "{", "return", "decodeYaml", "(", "file", ".", "Reader", ",", "&", "r", ".", "ReleaseManifest", ")", "\n", "}", ")", "\n", "w", ".", "OnMatch", "(", "\"", "\"", ",", "func", "(", "file", "pkg", ".", "FileEntry", ")", "error", "{", "job", ",", "jerr", ":=", "r", ".", "readBoshJob", "(", "file", ".", "Reader", ")", "\n", "if", "jerr", "==", "nil", "{", "r", ".", "JobManifests", "[", "job", ".", "Name", "]", "=", "job", "\n", "}", "\n", "return", "jerr", "\n", "}", ")", "\n", "err", ":=", "w", ".", "Walk", "(", ")", "\n", "return", "err", "\n", "}"], "docstring": "// readBoshRelease reads a bosh release out of the given reader into a new\n// boshRelease struct", "docstring_tokens": ["readBoshRelease", "reads", "a", "bosh", "release", "out", "of", "the", "given", "reader", "into", "a", "new", "boshRelease", "struct"], "sha": "4f847ee10b41afca41fe09fa839cb2f6ade06fb5", "url": "https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/release/boshrelease.go#L53-L67", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "draw2dpdf/gc.go", "func_name": "clearRect", "original_string": "func clearRect(gc *GraphicContext, x1, y1, x2, y2 float64) {\n\t// save state\n\tf := gc.Current.FillColor\n\tx, y := gc.pdf.GetXY()\n\t// cover page with white rectangle\n\tgc.SetFillColor(white)\n\tdraw2dkit.Rectangle(gc, x1, y1, x2, y2)\n\tgc.Fill()\n\t// restore state\n\tgc.SetFillColor(f)\n\tgc.pdf.MoveTo(x, y)\n}", "language": "go", "code": "func clearRect(gc *GraphicContext, x1, y1, x2, y2 float64) {\n\t// save state\n\tf := gc.Current.FillColor\n\tx, y := gc.pdf.GetXY()\n\t// cover page with white rectangle\n\tgc.SetFillColor(white)\n\tdraw2dkit.Rectangle(gc, x1, y1, x2, y2)\n\tgc.Fill()\n\t// restore state\n\tgc.SetFillColor(f)\n\tgc.pdf.MoveTo(x, y)\n}", "code_tokens": ["func", "clearRect", "(", "gc", "*", "GraphicContext", ",", "x1", ",", "y1", ",", "x2", ",", "y2", "float64", ")", "{", "// save state", "f", ":=", "gc", ".", "Current", ".", "FillColor", "\n", "x", ",", "y", ":=", "gc", ".", "pdf", ".", "GetXY", "(", ")", "\n", "// cover page with white rectangle", "gc", ".", "SetFillColor", "(", "white", ")", "\n", "draw2dkit", ".", "Rectangle", "(", "gc", ",", "x1", ",", "y1", ",", "x2", ",", "y2", ")", "\n", "gc", ".", "Fill", "(", ")", "\n", "// restore state", "gc", ".", "SetFillColor", "(", "f", ")", "\n", "gc", ".", "pdf", ".", "MoveTo", "(", "x", ",", "y", ")", "\n", "}"], "docstring": "// clearRect draws a white rectangle", "docstring_tokens": ["clearRect", "draws", "a", "white", "rectangle"], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dpdf/gc.go#L67-L78", "partition": "test"}
{"repo": "nwaples/rardecode", "path": "decode29.go", "func_name": "init", "original_string": "func (d *decoder29) init(r io.ByteReader, reset bool) error {\n\tif d.br == nil {\n\t\td.br = newRarBitReader(r)\n\t} else {\n\t\td.br.reset(r)\n\t}\n\td.eof = false\n\tif reset {\n\t\td.initFilters()\n\t\td.lz.reset()\n\t\td.ppm.reset()\n\t\td.decode = nil\n\t}\n\tif d.decode == nil {\n\t\treturn d.readBlockHeader()\n\t}\n\treturn nil\n}", "language": "go", "code": "func (d *decoder29) init(r io.ByteReader, reset bool) error {\n\tif d.br == nil {\n\t\td.br = newRarBitReader(r)\n\t} else {\n\t\td.br.reset(r)\n\t}\n\td.eof = false\n\tif reset {\n\t\td.initFilters()\n\t\td.lz.reset()\n\t\td.ppm.reset()\n\t\td.decode = nil\n\t}\n\tif d.decode == nil {\n\t\treturn d.readBlockHeader()\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "d", "*", "decoder29", ")", "init", "(", "r", "io", ".", "ByteReader", ",", "reset", "bool", ")", "error", "{", "if", "d", ".", "br", "==", "nil", "{", "d", ".", "br", "=", "newRarBitReader", "(", "r", ")", "\n", "}", "else", "{", "d", ".", "br", ".", "reset", "(", "r", ")", "\n", "}", "\n", "d", ".", "eof", "=", "false", "\n", "if", "reset", "{", "d", ".", "initFilters", "(", ")", "\n", "d", ".", "lz", ".", "reset", "(", ")", "\n", "d", ".", "ppm", ".", "reset", "(", ")", "\n", "d", ".", "decode", "=", "nil", "\n", "}", "\n", "if", "d", ".", "decode", "==", "nil", "{", "return", "d", ".", "readBlockHeader", "(", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// init intializes the decoder for decoding a new file.", "docstring_tokens": ["init", "intializes", "the", "decoder", "for", "decoding", "a", "new", "file", "."], "sha": "197ef08ef68c4454ae5970a9c2692d6056ceb8d7", "url": "https://github.com/nwaples/rardecode/blob/197ef08ef68c4454ae5970a9c2692d6056ceb8d7/decode29.go#L43-L60", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/jenkins/jenkins.go", "func_name": "CrumbRequest", "original_string": "func (c *Client) CrumbRequest() error {\n\tif c.authConfig.csrfToken != \"\" && c.authConfig.csrfRequestField != \"\" {\n\t\treturn nil\n\t}\n\tc.logger.Debug(\"CrumbRequest\")\n\tdata, err := c.GetSkipMetrics(\"/crumbIssuer/api/json\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tcrumbResp := struct {\n\t\tCrumb             string `json:\"crumb\"`\n\t\tCrumbRequestField string `json:\"crumbRequestField\"`\n\t}{}\n\tif err := json.Unmarshal(data, &crumbResp); err != nil {\n\t\treturn fmt.Errorf(\"cannot unmarshal crumb response: %v\", err)\n\t}\n\tc.authConfig.csrfToken = crumbResp.Crumb\n\tc.authConfig.csrfRequestField = crumbResp.CrumbRequestField\n\treturn nil\n}", "language": "go", "code": "func (c *Client) CrumbRequest() error {\n\tif c.authConfig.csrfToken != \"\" && c.authConfig.csrfRequestField != \"\" {\n\t\treturn nil\n\t}\n\tc.logger.Debug(\"CrumbRequest\")\n\tdata, err := c.GetSkipMetrics(\"/crumbIssuer/api/json\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tcrumbResp := struct {\n\t\tCrumb             string `json:\"crumb\"`\n\t\tCrumbRequestField string `json:\"crumbRequestField\"`\n\t}{}\n\tif err := json.Unmarshal(data, &crumbResp); err != nil {\n\t\treturn fmt.Errorf(\"cannot unmarshal crumb response: %v\", err)\n\t}\n\tc.authConfig.csrfToken = crumbResp.Crumb\n\tc.authConfig.csrfRequestField = crumbResp.CrumbRequestField\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "CrumbRequest", "(", ")", "error", "{", "if", "c", ".", "authConfig", ".", "csrfToken", "!=", "\"", "\"", "&&", "c", ".", "authConfig", ".", "csrfRequestField", "!=", "\"", "\"", "{", "return", "nil", "\n", "}", "\n", "c", ".", "logger", ".", "Debug", "(", "\"", "\"", ")", "\n", "data", ",", "err", ":=", "c", ".", "GetSkipMetrics", "(", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "crumbResp", ":=", "struct", "{", "Crumb", "string", "`json:\"crumb\"`", "\n", "CrumbRequestField", "string", "`json:\"crumbRequestField\"`", "\n", "}", "{", "}", "\n", "if", "err", ":=", "json", ".", "Unmarshal", "(", "data", ",", "&", "crumbResp", ")", ";", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "c", ".", "authConfig", ".", "csrfToken", "=", "crumbResp", ".", "Crumb", "\n", "c", ".", "authConfig", ".", "csrfRequestField", "=", "crumbResp", ".", "CrumbRequestField", "\n", "return", "nil", "\n", "}"], "docstring": "// CrumbRequest requests a CSRF protection token from Jenkins to\n// use it in subsequent requests. Required for Jenkins masters that\n// prevent cross site request forgery exploits.", "docstring_tokens": ["CrumbRequest", "requests", "a", "CSRF", "protection", "token", "from", "Jenkins", "to", "use", "it", "in", "subsequent", "requests", ".", "Required", "for", "Jenkins", "masters", "that", "prevent", "cross", "site", "request", "forgery", "exploits", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/jenkins/jenkins.go#L295-L314", "partition": "test"}
{"repo": "google/acme", "path": "config.go", "func_name": "writeKey", "original_string": "func writeKey(path string, k *ecdsa.PrivateKey) error {\n\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbytes, err := x509.MarshalECPrivateKey(k)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb := &pem.Block{Type: ecPrivateKey, Bytes: bytes}\n\tif err := pem.Encode(f, b); err != nil {\n\t\tf.Close()\n\t\treturn err\n\t}\n\treturn f.Close()\n}", "language": "go", "code": "func writeKey(path string, k *ecdsa.PrivateKey) error {\n\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbytes, err := x509.MarshalECPrivateKey(k)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb := &pem.Block{Type: ecPrivateKey, Bytes: bytes}\n\tif err := pem.Encode(f, b); err != nil {\n\t\tf.Close()\n\t\treturn err\n\t}\n\treturn f.Close()\n}", "code_tokens": ["func", "writeKey", "(", "path", "string", ",", "k", "*", "ecdsa", ".", "PrivateKey", ")", "error", "{", "f", ",", "err", ":=", "os", ".", "OpenFile", "(", "path", ",", "os", ".", "O_WRONLY", "|", "os", ".", "O_CREATE", "|", "os", ".", "O_TRUNC", ",", "0600", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "bytes", ",", "err", ":=", "x509", ".", "MarshalECPrivateKey", "(", "k", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "b", ":=", "&", "pem", ".", "Block", "{", "Type", ":", "ecPrivateKey", ",", "Bytes", ":", "bytes", "}", "\n", "if", "err", ":=", "pem", ".", "Encode", "(", "f", ",", "b", ")", ";", "err", "!=", "nil", "{", "f", ".", "Close", "(", ")", "\n", "return", "err", "\n", "}", "\n", "return", "f", ".", "Close", "(", ")", "\n", "}"], "docstring": "// writeKey writes k to the specified path in PEM format.\n// If file does not exists, it will be created with 0600 mod.", "docstring_tokens": ["writeKey", "writes", "k", "to", "the", "specified", "path", "in", "PEM", "format", ".", "If", "file", "does", "not", "exists", "it", "will", "be", "created", "with", "0600", "mod", "."], "sha": "7c6dfc908d68ed254a16c126f6770f4d9d9352da", "url": "https://github.com/google/acme/blob/7c6dfc908d68ed254a16c126f6770f4d9d9352da/config.go#L127-L142", "partition": "test"}
{"repo": "mgutz/str", "path": "funcsAO.go", "func_name": "DecodeHTMLEntities", "original_string": "func DecodeHTMLEntities(s string) string {\n\tif Verbose {\n\t\tfmt.Println(\"Use html.UnescapeString instead of DecodeHTMLEntities\")\n\t}\n\treturn html.UnescapeString(s)\n}", "language": "go", "code": "func DecodeHTMLEntities(s string) string {\n\tif Verbose {\n\t\tfmt.Println(\"Use html.UnescapeString instead of DecodeHTMLEntities\")\n\t}\n\treturn html.UnescapeString(s)\n}", "code_tokens": ["func", "DecodeHTMLEntities", "(", "s", "string", ")", "string", "{", "if", "Verbose", "{", "fmt", ".", "Println", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "html", ".", "UnescapeString", "(", "s", ")", "\n", "}"], "docstring": "// DecodeHTMLEntities decodes HTML entities into their proper string representation.\n// DecodeHTMLEntities is an alias for html.UnescapeString", "docstring_tokens": ["DecodeHTMLEntities", "decodes", "HTML", "entities", "into", "their", "proper", "string", "representation", ".", "DecodeHTMLEntities", "is", "an", "alias", "for", "html", ".", "UnescapeString"], "sha": "968bf66e3da857419e4f6e71b2d5c9ae95682dc4", "url": "https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsAO.go#L175-L180", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/containers.go", "func_name": "ContainerBackupCreate", "original_string": "func (c *Cluster) ContainerBackupCreate(args ContainerBackupArgs) error {\n\t_, err := c.ContainerBackupID(args.Name)\n\tif err == nil {\n\t\treturn ErrAlreadyDefined\n\t}\n\n\terr = c.Transaction(func(tx *ClusterTx) error {\n\t\tcontainerOnlyInt := 0\n\t\tif args.ContainerOnly {\n\t\t\tcontainerOnlyInt = 1\n\t\t}\n\n\t\toptimizedStorageInt := 0\n\t\tif args.OptimizedStorage {\n\t\t\toptimizedStorageInt = 1\n\t\t}\n\n\t\tstr := fmt.Sprintf(\"INSERT INTO containers_backups (container_id, name, creation_date, expiry_date, container_only, optimized_storage) VALUES (?, ?, ?, ?, ?, ?)\")\n\t\tstmt, err := tx.tx.Prepare(str)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer stmt.Close()\n\t\tresult, err := stmt.Exec(args.ContainerID, args.Name,\n\t\t\targs.CreationDate.Unix(), args.ExpiryDate.Unix(), containerOnlyInt,\n\t\t\toptimizedStorageInt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = result.LastInsertId()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Error inserting %s into database\", args.Name)\n\t\t}\n\n\t\treturn nil\n\t})\n\n\treturn err\n}", "language": "go", "code": "func (c *Cluster) ContainerBackupCreate(args ContainerBackupArgs) error {\n\t_, err := c.ContainerBackupID(args.Name)\n\tif err == nil {\n\t\treturn ErrAlreadyDefined\n\t}\n\n\terr = c.Transaction(func(tx *ClusterTx) error {\n\t\tcontainerOnlyInt := 0\n\t\tif args.ContainerOnly {\n\t\t\tcontainerOnlyInt = 1\n\t\t}\n\n\t\toptimizedStorageInt := 0\n\t\tif args.OptimizedStorage {\n\t\t\toptimizedStorageInt = 1\n\t\t}\n\n\t\tstr := fmt.Sprintf(\"INSERT INTO containers_backups (container_id, name, creation_date, expiry_date, container_only, optimized_storage) VALUES (?, ?, ?, ?, ?, ?)\")\n\t\tstmt, err := tx.tx.Prepare(str)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer stmt.Close()\n\t\tresult, err := stmt.Exec(args.ContainerID, args.Name,\n\t\t\targs.CreationDate.Unix(), args.ExpiryDate.Unix(), containerOnlyInt,\n\t\t\toptimizedStorageInt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = result.LastInsertId()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Error inserting %s into database\", args.Name)\n\t\t}\n\n\t\treturn nil\n\t})\n\n\treturn err\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "ContainerBackupCreate", "(", "args", "ContainerBackupArgs", ")", "error", "{", "_", ",", "err", ":=", "c", ".", "ContainerBackupID", "(", "args", ".", "Name", ")", "\n", "if", "err", "==", "nil", "{", "return", "ErrAlreadyDefined", "\n", "}", "\n\n", "err", "=", "c", ".", "Transaction", "(", "func", "(", "tx", "*", "ClusterTx", ")", "error", "{", "containerOnlyInt", ":=", "0", "\n", "if", "args", ".", "ContainerOnly", "{", "containerOnlyInt", "=", "1", "\n", "}", "\n\n", "optimizedStorageInt", ":=", "0", "\n", "if", "args", ".", "OptimizedStorage", "{", "optimizedStorageInt", "=", "1", "\n", "}", "\n\n", "str", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ")", "\n", "stmt", ",", "err", ":=", "tx", ".", "tx", ".", "Prepare", "(", "str", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "defer", "stmt", ".", "Close", "(", ")", "\n", "result", ",", "err", ":=", "stmt", ".", "Exec", "(", "args", ".", "ContainerID", ",", "args", ".", "Name", ",", "args", ".", "CreationDate", ".", "Unix", "(", ")", ",", "args", ".", "ExpiryDate", ".", "Unix", "(", ")", ",", "containerOnlyInt", ",", "optimizedStorageInt", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "_", ",", "err", "=", "result", ".", "LastInsertId", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "args", ".", "Name", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}", ")", "\n\n", "return", "err", "\n", "}"], "docstring": "// ContainerBackupCreate creates a new backup", "docstring_tokens": ["ContainerBackupCreate", "creates", "a", "new", "backup"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/containers.go#L1049-L1088", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "overlay/overlay.go", "func_name": "Do", "original_string": "func (p *HighlightNodeParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandHighlightNode, p, nil)\n}", "language": "go", "code": "func (p *HighlightNodeParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandHighlightNode, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "HighlightNodeParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandHighlightNode", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Overlay.highlightNode against the provided context.", "docstring_tokens": ["Do", "executes", "Overlay", ".", "highlightNode", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/overlay/overlay.go#L189-L191", "partition": "test"}
{"repo": "profitbricks/profitbricks-sdk-go", "path": "usermanagment.go", "func_name": "DeleteUserFromGroup", "original_string": "func (c *Client) DeleteUserFromGroup(groupid string, userid string) (*http.Header, error) {\n\turl := umGroupUsersPath(groupid, userid) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &http.Header{}\n\terr := c.client.Delete(url, ret, http.StatusAccepted)\n\treturn ret, err\n}", "language": "go", "code": "func (c *Client) DeleteUserFromGroup(groupid string, userid string) (*http.Header, error) {\n\turl := umGroupUsersPath(groupid, userid) + `?depth=` + c.client.depth + `&pretty=` + strconv.FormatBool(c.client.pretty)\n\tret := &http.Header{}\n\terr := c.client.Delete(url, ret, http.StatusAccepted)\n\treturn ret, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "DeleteUserFromGroup", "(", "groupid", "string", ",", "userid", "string", ")", "(", "*", "http", ".", "Header", ",", "error", ")", "{", "url", ":=", "umGroupUsersPath", "(", "groupid", ",", "userid", ")", "+", "`?depth=`", "+", "c", ".", "client", ".", "depth", "+", "`&pretty=`", "+", "strconv", ".", "FormatBool", "(", "c", ".", "client", ".", "pretty", ")", "\n", "ret", ":=", "&", "http", ".", "Header", "{", "}", "\n", "err", ":=", "c", ".", "client", ".", "Delete", "(", "url", ",", "ret", ",", "http", ".", "StatusAccepted", ")", "\n", "return", "ret", ",", "err", "\n", "}"], "docstring": "// DeleteUserFromGroup removes a user from a group", "docstring_tokens": ["DeleteUserFromGroup", "removes", "a", "user", "from", "a", "group"], "sha": "1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4", "url": "https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/usermanagment.go#L264-L269", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "thrift/thrift-gen/typestate.go", "func_name": "goType", "original_string": "func (s *State) goType(thriftType *parser.Type) string {\n\treturn s.goTypePrefix(\"\", thriftType)\n}", "language": "go", "code": "func (s *State) goType(thriftType *parser.Type) string {\n\treturn s.goTypePrefix(\"\", thriftType)\n}", "code_tokens": ["func", "(", "s", "*", "State", ")", "goType", "(", "thriftType", "*", "parser", ".", "Type", ")", "string", "{", "return", "s", ".", "goTypePrefix", "(", "\"", "\"", ",", "thriftType", ")", "\n", "}"], "docstring": "// goType returns the Go type name for the given thrift type.", "docstring_tokens": ["goType", "returns", "the", "Go", "type", "name", "for", "the", "given", "thrift", "type", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/thrift/thrift-gen/typestate.go#L103-L105", "partition": "test"}
{"repo": "sclevine/agouti", "path": "selection.go", "func_name": "Count", "original_string": "func (s *Selection) Count() (int, error) {\n\telements, err := s.elements.Get()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to select elements from %s: %s\", s, err)\n\t}\n\n\treturn len(elements), nil\n}", "language": "go", "code": "func (s *Selection) Count() (int, error) {\n\telements, err := s.elements.Get()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to select elements from %s: %s\", s, err)\n\t}\n\n\treturn len(elements), nil\n}", "code_tokens": ["func", "(", "s", "*", "Selection", ")", "Count", "(", ")", "(", "int", ",", "error", ")", "{", "elements", ",", "err", ":=", "s", ".", "elements", ".", "Get", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "0", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "s", ",", "err", ")", "\n", "}", "\n\n", "return", "len", "(", "elements", ")", ",", "nil", "\n", "}"], "docstring": "// Count returns the number of elements that the selection refers to.", "docstring_tokens": ["Count", "returns", "the", "number", "of", "elements", "that", "the", "selection", "refers", "to", "."], "sha": "96599c91888f1b1cf2dccc7f1776ba7f511909e5", "url": "https://github.com/sclevine/agouti/blob/96599c91888f1b1cf2dccc7f1776ba7f511909e5/selection.go#L66-L73", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "mvcc/backend/batch_tx.go", "func_name": "UnsafePut", "original_string": "func (t *batchTx) UnsafePut(bucketName []byte, key []byte, value []byte) {\n\tt.unsafePut(bucketName, key, value, false)\n}", "language": "go", "code": "func (t *batchTx) UnsafePut(bucketName []byte, key []byte, value []byte) {\n\tt.unsafePut(bucketName, key, value, false)\n}", "code_tokens": ["func", "(", "t", "*", "batchTx", ")", "UnsafePut", "(", "bucketName", "[", "]", "byte", ",", "key", "[", "]", "byte", ",", "value", "[", "]", "byte", ")", "{", "t", ".", "unsafePut", "(", "bucketName", ",", "key", ",", "value", ",", "false", ")", "\n", "}"], "docstring": "// UnsafePut must be called holding the lock on the tx.", "docstring_tokens": ["UnsafePut", "must", "be", "called", "holding", "the", "lock", "on", "the", "tx", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/mvcc/backend/batch_tx.go#L88-L90", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "meta/bundle.go", "func_name": "InitialState", "original_string": "func (b *Bundle) InitialState(key xdr.LedgerKey) (*xdr.LedgerEntry, error) {\n\tall := b.Changes(key)\n\n\tif len(all) == 0 {\n\t\treturn nil, ErrMetaNotFound\n\t}\n\n\tfirst := all[0]\n\n\tif first.Type != xdr.LedgerEntryChangeTypeLedgerEntryState {\n\t\treturn nil, nil\n\t}\n\n\tresult := first.MustState()\n\n\treturn &result, nil\n}", "language": "go", "code": "func (b *Bundle) InitialState(key xdr.LedgerKey) (*xdr.LedgerEntry, error) {\n\tall := b.Changes(key)\n\n\tif len(all) == 0 {\n\t\treturn nil, ErrMetaNotFound\n\t}\n\n\tfirst := all[0]\n\n\tif first.Type != xdr.LedgerEntryChangeTypeLedgerEntryState {\n\t\treturn nil, nil\n\t}\n\n\tresult := first.MustState()\n\n\treturn &result, nil\n}", "code_tokens": ["func", "(", "b", "*", "Bundle", ")", "InitialState", "(", "key", "xdr", ".", "LedgerKey", ")", "(", "*", "xdr", ".", "LedgerEntry", ",", "error", ")", "{", "all", ":=", "b", ".", "Changes", "(", "key", ")", "\n\n", "if", "len", "(", "all", ")", "==", "0", "{", "return", "nil", ",", "ErrMetaNotFound", "\n", "}", "\n\n", "first", ":=", "all", "[", "0", "]", "\n\n", "if", "first", ".", "Type", "!=", "xdr", ".", "LedgerEntryChangeTypeLedgerEntryState", "{", "return", "nil", ",", "nil", "\n", "}", "\n\n", "result", ":=", "first", ".", "MustState", "(", ")", "\n\n", "return", "&", "result", ",", "nil", "\n", "}"], "docstring": "// InitialState returns the initial state of the LedgerEntry identified by `key`\n// just prior to the application of the transaction the produced `b`.  Returns\n// nil if the ledger entry did not exist prior to the bundle.", "docstring_tokens": ["InitialState", "returns", "the", "initial", "state", "of", "the", "LedgerEntry", "identified", "by", "key", "just", "prior", "to", "the", "application", "of", "the", "transaction", "the", "produced", "b", ".", "Returns", "nil", "if", "the", "ledger", "entry", "did", "not", "exist", "prior", "to", "the", "bundle", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/meta/bundle.go#L18-L34", "partition": "test"}
{"repo": "profitbricks/profitbricks-sdk-go", "path": "ipblock.go", "func_name": "ReleaseIPBlock", "original_string": "func (c *Client) ReleaseIPBlock(ipblockid string) (*http.Header, error) {\n\turl := ipblockPath(ipblockid)\n\tret := &http.Header{}\n\terr := c.client.Delete(url, ret, http.StatusAccepted)\n\treturn ret, err\n}", "language": "go", "code": "func (c *Client) ReleaseIPBlock(ipblockid string) (*http.Header, error) {\n\turl := ipblockPath(ipblockid)\n\tret := &http.Header{}\n\terr := c.client.Delete(url, ret, http.StatusAccepted)\n\treturn ret, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "ReleaseIPBlock", "(", "ipblockid", "string", ")", "(", "*", "http", ".", "Header", ",", "error", ")", "{", "url", ":=", "ipblockPath", "(", "ipblockid", ")", "\n", "ret", ":=", "&", "http", ".", "Header", "{", "}", "\n", "err", ":=", "c", ".", "client", ".", "Delete", "(", "url", ",", "ret", ",", "http", ".", "StatusAccepted", ")", "\n", "return", "ret", ",", "err", "\n", "}"], "docstring": "//ReleaseIPBlock deletes an IP block", "docstring_tokens": ["ReleaseIPBlock", "deletes", "an", "IP", "block"], "sha": "1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4", "url": "https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/ipblock.go#L72-L77", "partition": "test"}
{"repo": "hooklift/govix", "path": "vix.go", "func_name": "Error", "original_string": "func (e *Error) Error() string {\n\treturn fmt.Sprintf(\"VIX Error: %s, code: %d, operation: %s\", e.Text, e.Code, e.Operation)\n}", "language": "go", "code": "func (e *Error) Error() string {\n\treturn fmt.Sprintf(\"VIX Error: %s, code: %d, operation: %s\", e.Text, e.Code, e.Operation)\n}", "code_tokens": ["func", "(", "e", "*", "Error", ")", "Error", "(", ")", "string", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "e", ".", "Text", ",", "e", ".", "Code", ",", "e", ".", "Operation", ")", "\n", "}"], "docstring": "// Error returns a description of the error along with its code and operation\n// implementing Go's error interface.", "docstring_tokens": ["Error", "returns", "a", "description", "of", "the", "error", "along", "with", "its", "code", "and", "operation", "implementing", "Go", "s", "error", "interface", "."], "sha": "063702285520a992b920fc1575e305dc9ffd6ffe", "url": "https://github.com/hooklift/govix/blob/063702285520a992b920fc1575e305dc9ffd6ffe/vix.go#L396-L398", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/config/org/org.go", "func_name": "UnmarshalText", "original_string": "func (p *Privacy) UnmarshalText(text []byte) error {\n\tv := Privacy(text)\n\tif _, ok := privacySettings[v]; !ok {\n\t\treturn fmt.Errorf(\"bad privacy setting: %s\", v)\n\t}\n\t*p = v\n\treturn nil\n}", "language": "go", "code": "func (p *Privacy) UnmarshalText(text []byte) error {\n\tv := Privacy(text)\n\tif _, ok := privacySettings[v]; !ok {\n\t\treturn fmt.Errorf(\"bad privacy setting: %s\", v)\n\t}\n\t*p = v\n\treturn nil\n}", "code_tokens": ["func", "(", "p", "*", "Privacy", ")", "UnmarshalText", "(", "text", "[", "]", "byte", ")", "error", "{", "v", ":=", "Privacy", "(", "text", ")", "\n", "if", "_", ",", "ok", ":=", "privacySettings", "[", "v", "]", ";", "!", "ok", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "v", ")", "\n", "}", "\n", "*", "p", "=", "v", "\n", "return", "nil", "\n", "}"], "docstring": "// UnmarshalText returns an error if text != secret or closed", "docstring_tokens": ["UnmarshalText", "returns", "an", "error", "if", "text", "!", "=", "secret", "or", "closed"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/org/org.go#L103-L110", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "WithPreferCSSPageSize", "original_string": "func (p PrintToPDFParams) WithPreferCSSPageSize(preferCSSPageSize bool) *PrintToPDFParams {\n\tp.PreferCSSPageSize = preferCSSPageSize\n\treturn &p\n}", "language": "go", "code": "func (p PrintToPDFParams) WithPreferCSSPageSize(preferCSSPageSize bool) *PrintToPDFParams {\n\tp.PreferCSSPageSize = preferCSSPageSize\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "PrintToPDFParams", ")", "WithPreferCSSPageSize", "(", "preferCSSPageSize", "bool", ")", "*", "PrintToPDFParams", "{", "p", ".", "PreferCSSPageSize", "=", "preferCSSPageSize", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithPreferCSSPageSize whether or not to prefer page size as defined by\n// css. Defaults to false, in which case the content will be scaled to fit the\n// paper size.", "docstring_tokens": ["WithPreferCSSPageSize", "whether", "or", "not", "to", "prefer", "page", "size", "as", "defined", "by", "css", ".", "Defaults", "to", "false", "in", "which", "case", "the", "content", "will", "be", "scaled", "to", "fit", "the", "paper", "size", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L780-L783", "partition": "test"}
{"repo": "qor/roles", "path": "permissioner.go", "func_name": "HasPermission", "original_string": "func (ps permissioners) HasPermission(mode PermissionMode, roles ...interface{}) bool {\n\tfor _, p := range ps {\n\t\tif p != nil && !p.HasPermission(mode, roles) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}", "language": "go", "code": "func (ps permissioners) HasPermission(mode PermissionMode, roles ...interface{}) bool {\n\tfor _, p := range ps {\n\t\tif p != nil && !p.HasPermission(mode, roles) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}", "code_tokens": ["func", "(", "ps", "permissioners", ")", "HasPermission", "(", "mode", "PermissionMode", ",", "roles", "...", "interface", "{", "}", ")", "bool", "{", "for", "_", ",", "p", ":=", "range", "ps", "{", "if", "p", "!=", "nil", "&&", "!", "p", ".", "HasPermission", "(", "mode", ",", "roles", ")", "{", "return", "false", "\n", "}", "\n", "}", "\n\n", "return", "true", "\n", "}"], "docstring": "// HasPermission check has permission for permissioners or not", "docstring_tokens": ["HasPermission", "check", "has", "permission", "for", "permissioners", "or", "not"], "sha": "d6375609fe3e5da46ad3a574fae244fb633e79c1", "url": "https://github.com/qor/roles/blob/d6375609fe3e5da46ad3a574fae244fb633e79c1/permissioner.go#L22-L30", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "velodrome/transform/fetcher.go", "func_name": "NewFetcher", "original_string": "func NewFetcher(repository string) *Fetcher {\n\treturn &Fetcher{\n\t\tIssuesChannel:         make(chan sql.Issue, 100),\n\t\tEventsCommentsChannel: make(chan interface{}, 100),\n\t\trepository:            repository,\n\t}\n}", "language": "go", "code": "func NewFetcher(repository string) *Fetcher {\n\treturn &Fetcher{\n\t\tIssuesChannel:         make(chan sql.Issue, 100),\n\t\tEventsCommentsChannel: make(chan interface{}, 100),\n\t\trepository:            repository,\n\t}\n}", "code_tokens": ["func", "NewFetcher", "(", "repository", "string", ")", "*", "Fetcher", "{", "return", "&", "Fetcher", "{", "IssuesChannel", ":", "make", "(", "chan", "sql", ".", "Issue", ",", "100", ")", ",", "EventsCommentsChannel", ":", "make", "(", "chan", "interface", "{", "}", ",", "100", ")", ",", "repository", ":", "repository", ",", "}", "\n", "}"], "docstring": "// NewFetcher creates a new Fetcher and initializes the output channels", "docstring_tokens": ["NewFetcher", "creates", "a", "new", "Fetcher", "and", "initializes", "the", "output", "channels"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/transform/fetcher.go#L41-L47", "partition": "test"}
{"repo": "containers/image", "path": "pkg/blobinfocache/default.go", "func_name": "DefaultCache", "original_string": "func DefaultCache(sys *types.SystemContext) types.BlobInfoCache {\n\tdir, err := blobInfoCacheDir(sys, getRootlessUID())\n\tif err != nil {\n\t\tlogrus.Debugf(\"Error determining a location for %s, using a memory-only cache\", blobInfoCacheFilename)\n\t\treturn memory.New()\n\t}\n\tpath := filepath.Join(dir, blobInfoCacheFilename)\n\tif err := os.MkdirAll(dir, 0700); err != nil {\n\t\tlogrus.Debugf(\"Error creating parent directories for %s, using a memory-only cache: %v\", blobInfoCacheFilename, err)\n\t\treturn memory.New()\n\t}\n\n\tlogrus.Debugf(\"Using blob info cache at %s\", path)\n\treturn boltdb.New(path)\n}", "language": "go", "code": "func DefaultCache(sys *types.SystemContext) types.BlobInfoCache {\n\tdir, err := blobInfoCacheDir(sys, getRootlessUID())\n\tif err != nil {\n\t\tlogrus.Debugf(\"Error determining a location for %s, using a memory-only cache\", blobInfoCacheFilename)\n\t\treturn memory.New()\n\t}\n\tpath := filepath.Join(dir, blobInfoCacheFilename)\n\tif err := os.MkdirAll(dir, 0700); err != nil {\n\t\tlogrus.Debugf(\"Error creating parent directories for %s, using a memory-only cache: %v\", blobInfoCacheFilename, err)\n\t\treturn memory.New()\n\t}\n\n\tlogrus.Debugf(\"Using blob info cache at %s\", path)\n\treturn boltdb.New(path)\n}", "code_tokens": ["func", "DefaultCache", "(", "sys", "*", "types", ".", "SystemContext", ")", "types", ".", "BlobInfoCache", "{", "dir", ",", "err", ":=", "blobInfoCacheDir", "(", "sys", ",", "getRootlessUID", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "logrus", ".", "Debugf", "(", "\"", "\"", ",", "blobInfoCacheFilename", ")", "\n", "return", "memory", ".", "New", "(", ")", "\n", "}", "\n", "path", ":=", "filepath", ".", "Join", "(", "dir", ",", "blobInfoCacheFilename", ")", "\n", "if", "err", ":=", "os", ".", "MkdirAll", "(", "dir", ",", "0700", ")", ";", "err", "!=", "nil", "{", "logrus", ".", "Debugf", "(", "\"", "\"", ",", "blobInfoCacheFilename", ",", "err", ")", "\n", "return", "memory", ".", "New", "(", ")", "\n", "}", "\n\n", "logrus", ".", "Debugf", "(", "\"", "\"", ",", "path", ")", "\n", "return", "boltdb", ".", "New", "(", "path", ")", "\n", "}"], "docstring": "// DefaultCache returns the default BlobInfoCache implementation appropriate for sys.", "docstring_tokens": ["DefaultCache", "returns", "the", "default", "BlobInfoCache", "implementation", "appropriate", "for", "sys", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/pkg/blobinfocache/default.go#L61-L75", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/config/config.go", "func_name": "finalizeJobConfig", "original_string": "func (c *Config) finalizeJobConfig() error {\n\tif c.decorationRequested() {\n\t\tif c.Plank.DefaultDecorationConfig == nil {\n\t\t\treturn errors.New(\"no default decoration config provided for plank\")\n\t\t}\n\t\tif c.Plank.DefaultDecorationConfig.UtilityImages == nil {\n\t\t\treturn errors.New(\"no default decoration image pull specs provided for plank\")\n\t\t}\n\t\tif c.Plank.DefaultDecorationConfig.GCSConfiguration == nil {\n\t\t\treturn errors.New(\"no default GCS decoration config provided for plank\")\n\t\t}\n\t\tif c.Plank.DefaultDecorationConfig.GCSCredentialsSecret == \"\" {\n\t\t\treturn errors.New(\"no default GCS credentials secret provided for plank\")\n\t\t}\n\n\t\tfor _, vs := range c.Presubmits {\n\t\t\tfor i := range vs {\n\t\t\t\tsetPresubmitDecorationDefaults(c, &vs[i])\n\t\t\t}\n\t\t}\n\n\t\tfor _, js := range c.Postsubmits {\n\t\t\tfor i := range js {\n\t\t\t\tsetPostsubmitDecorationDefaults(c, &js[i])\n\t\t\t}\n\t\t}\n\n\t\tfor i := range c.Periodics {\n\t\t\tsetPeriodicDecorationDefaults(c, &c.Periodics[i])\n\t\t}\n\t}\n\n\t// Ensure that regexes are valid and set defaults.\n\tfor _, vs := range c.Presubmits {\n\t\tc.defaultPresubmitFields(vs)\n\t\tif err := SetPresubmitRegexes(vs); err != nil {\n\t\t\treturn fmt.Errorf(\"could not set regex: %v\", err)\n\t\t}\n\t}\n\tfor _, js := range c.Postsubmits {\n\t\tc.defaultPostsubmitFields(js)\n\t\tif err := SetPostsubmitRegexes(js); err != nil {\n\t\t\treturn fmt.Errorf(\"could not set regex: %v\", err)\n\t\t}\n\t}\n\n\tc.defaultPeriodicFields(c.Periodics)\n\n\tfor _, v := range c.AllPresubmits(nil) {\n\t\tif err := resolvePresets(v.Name, v.Labels, v.Spec, v.BuildSpec, c.Presets); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor _, v := range c.AllPostsubmits(nil) {\n\t\tif err := resolvePresets(v.Name, v.Labels, v.Spec, v.BuildSpec, c.Presets); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor _, v := range c.AllPeriodics() {\n\t\tif err := resolvePresets(v.Name, v.Labels, v.Spec, v.BuildSpec, c.Presets); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *Config) finalizeJobConfig() error {\n\tif c.decorationRequested() {\n\t\tif c.Plank.DefaultDecorationConfig == nil {\n\t\t\treturn errors.New(\"no default decoration config provided for plank\")\n\t\t}\n\t\tif c.Plank.DefaultDecorationConfig.UtilityImages == nil {\n\t\t\treturn errors.New(\"no default decoration image pull specs provided for plank\")\n\t\t}\n\t\tif c.Plank.DefaultDecorationConfig.GCSConfiguration == nil {\n\t\t\treturn errors.New(\"no default GCS decoration config provided for plank\")\n\t\t}\n\t\tif c.Plank.DefaultDecorationConfig.GCSCredentialsSecret == \"\" {\n\t\t\treturn errors.New(\"no default GCS credentials secret provided for plank\")\n\t\t}\n\n\t\tfor _, vs := range c.Presubmits {\n\t\t\tfor i := range vs {\n\t\t\t\tsetPresubmitDecorationDefaults(c, &vs[i])\n\t\t\t}\n\t\t}\n\n\t\tfor _, js := range c.Postsubmits {\n\t\t\tfor i := range js {\n\t\t\t\tsetPostsubmitDecorationDefaults(c, &js[i])\n\t\t\t}\n\t\t}\n\n\t\tfor i := range c.Periodics {\n\t\t\tsetPeriodicDecorationDefaults(c, &c.Periodics[i])\n\t\t}\n\t}\n\n\t// Ensure that regexes are valid and set defaults.\n\tfor _, vs := range c.Presubmits {\n\t\tc.defaultPresubmitFields(vs)\n\t\tif err := SetPresubmitRegexes(vs); err != nil {\n\t\t\treturn fmt.Errorf(\"could not set regex: %v\", err)\n\t\t}\n\t}\n\tfor _, js := range c.Postsubmits {\n\t\tc.defaultPostsubmitFields(js)\n\t\tif err := SetPostsubmitRegexes(js); err != nil {\n\t\t\treturn fmt.Errorf(\"could not set regex: %v\", err)\n\t\t}\n\t}\n\n\tc.defaultPeriodicFields(c.Periodics)\n\n\tfor _, v := range c.AllPresubmits(nil) {\n\t\tif err := resolvePresets(v.Name, v.Labels, v.Spec, v.BuildSpec, c.Presets); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor _, v := range c.AllPostsubmits(nil) {\n\t\tif err := resolvePresets(v.Name, v.Labels, v.Spec, v.BuildSpec, c.Presets); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor _, v := range c.AllPeriodics() {\n\t\tif err := resolvePresets(v.Name, v.Labels, v.Spec, v.BuildSpec, c.Presets); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Config", ")", "finalizeJobConfig", "(", ")", "error", "{", "if", "c", ".", "decorationRequested", "(", ")", "{", "if", "c", ".", "Plank", ".", "DefaultDecorationConfig", "==", "nil", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "c", ".", "Plank", ".", "DefaultDecorationConfig", ".", "UtilityImages", "==", "nil", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "c", ".", "Plank", ".", "DefaultDecorationConfig", ".", "GCSConfiguration", "==", "nil", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "c", ".", "Plank", ".", "DefaultDecorationConfig", ".", "GCSCredentialsSecret", "==", "\"", "\"", "{", "return", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n\n", "for", "_", ",", "vs", ":=", "range", "c", ".", "Presubmits", "{", "for", "i", ":=", "range", "vs", "{", "setPresubmitDecorationDefaults", "(", "c", ",", "&", "vs", "[", "i", "]", ")", "\n", "}", "\n", "}", "\n\n", "for", "_", ",", "js", ":=", "range", "c", ".", "Postsubmits", "{", "for", "i", ":=", "range", "js", "{", "setPostsubmitDecorationDefaults", "(", "c", ",", "&", "js", "[", "i", "]", ")", "\n", "}", "\n", "}", "\n\n", "for", "i", ":=", "range", "c", ".", "Periodics", "{", "setPeriodicDecorationDefaults", "(", "c", ",", "&", "c", ".", "Periodics", "[", "i", "]", ")", "\n", "}", "\n", "}", "\n\n", "// Ensure that regexes are valid and set defaults.", "for", "_", ",", "vs", ":=", "range", "c", ".", "Presubmits", "{", "c", ".", "defaultPresubmitFields", "(", "vs", ")", "\n", "if", "err", ":=", "SetPresubmitRegexes", "(", "vs", ")", ";", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "}", "\n", "for", "_", ",", "js", ":=", "range", "c", ".", "Postsubmits", "{", "c", ".", "defaultPostsubmitFields", "(", "js", ")", "\n", "if", "err", ":=", "SetPostsubmitRegexes", "(", "js", ")", ";", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "}", "\n\n", "c", ".", "defaultPeriodicFields", "(", "c", ".", "Periodics", ")", "\n\n", "for", "_", ",", "v", ":=", "range", "c", ".", "AllPresubmits", "(", "nil", ")", "{", "if", "err", ":=", "resolvePresets", "(", "v", ".", "Name", ",", "v", ".", "Labels", ",", "v", ".", "Spec", ",", "v", ".", "BuildSpec", ",", "c", ".", "Presets", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n\n", "for", "_", ",", "v", ":=", "range", "c", ".", "AllPostsubmits", "(", "nil", ")", "{", "if", "err", ":=", "resolvePresets", "(", "v", ".", "Name", ",", "v", ".", "Labels", ",", "v", ".", "Spec", ",", "v", ".", "BuildSpec", ",", "c", ".", "Presets", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n\n", "for", "_", ",", "v", ":=", "range", "c", ".", "AllPeriodics", "(", ")", "{", "if", "err", ":=", "resolvePresets", "(", "v", ".", "Name", ",", "v", ".", "Labels", ",", "v", ".", "Spec", ",", "v", ".", "BuildSpec", ",", "c", ".", "Presets", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// finalizeJobConfig mutates and fixes entries for jobspecs", "docstring_tokens": ["finalizeJobConfig", "mutates", "and", "fixes", "entries", "for", "jobspecs"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/config.go#L656-L723", "partition": "test"}
{"repo": "DamienFontaine/lunarc", "path": "security/utils.go", "func_name": "HashPassword", "original_string": "func HashPassword(password []byte, salt []byte) (hash []byte, err error) {\n\thash, err = scrypt.Key(password, salt, N, R, P, KEYLENGTH)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn\n}", "language": "go", "code": "func HashPassword(password []byte, salt []byte) (hash []byte, err error) {\n\thash, err = scrypt.Key(password, salt, N, R, P, KEYLENGTH)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn\n}", "code_tokens": ["func", "HashPassword", "(", "password", "[", "]", "byte", ",", "salt", "[", "]", "byte", ")", "(", "hash", "[", "]", "byte", ",", "err", "error", ")", "{", "hash", ",", "err", "=", "scrypt", ".", "Key", "(", "password", ",", "salt", ",", "N", ",", "R", ",", "P", ",", "KEYLENGTH", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "\n", "}"], "docstring": "//HashPassword hash un mot de passe", "docstring_tokens": ["HashPassword", "hash", "un", "mot", "de", "passe"], "sha": "2e7332a51f554794a549a313430eaa7dec8d13cc", "url": "https://github.com/DamienFontaine/lunarc/blob/2e7332a51f554794a549a313430eaa7dec8d13cc/security/utils.go#L41-L47", "partition": "test"}
{"repo": "enaml-ops/enaml", "path": "deploymentmanifest.go", "func_name": "RemoveTag", "original_string": "func (s *DeploymentManifest) RemoveTag(key string) {\n\tif s.Tags != nil {\n\t\tdelete(s.Tags, key)\n\t}\n}", "language": "go", "code": "func (s *DeploymentManifest) RemoveTag(key string) {\n\tif s.Tags != nil {\n\t\tdelete(s.Tags, key)\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "DeploymentManifest", ")", "RemoveTag", "(", "key", "string", ")", "{", "if", "s", ".", "Tags", "!=", "nil", "{", "delete", "(", "s", ".", "Tags", ",", "key", ")", "\n", "}", "\n", "}"], "docstring": "// RemoveTag removes the tag with the specified key.", "docstring_tokens": ["RemoveTag", "removes", "the", "tag", "with", "the", "specified", "key", "."], "sha": "4f847ee10b41afca41fe09fa839cb2f6ade06fb5", "url": "https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/deploymentmanifest.go#L197-L201", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/rafthttp/util.go", "func_name": "createPostRequest", "original_string": "func createPostRequest(u url.URL, path string, body io.Reader, ct string, urls types.URLs, from, cid types.ID) *http.Request {\n\tuu := u\n\tuu.Path = path\n\treq, err := http.NewRequest(\"POST\", uu.String(), body)\n\tif err != nil {\n\t\tplog.Panicf(\"unexpected new request error (%v)\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", ct)\n\treq.Header.Set(\"X-Server-From\", from.String())\n\treq.Header.Set(\"X-Server-Version\", version.Version)\n\treq.Header.Set(\"X-Min-Cluster-Version\", version.MinClusterVersion)\n\treq.Header.Set(\"X-Etcd-Cluster-ID\", cid.String())\n\tsetPeerURLsHeader(req, urls)\n\n\treturn req\n}", "language": "go", "code": "func createPostRequest(u url.URL, path string, body io.Reader, ct string, urls types.URLs, from, cid types.ID) *http.Request {\n\tuu := u\n\tuu.Path = path\n\treq, err := http.NewRequest(\"POST\", uu.String(), body)\n\tif err != nil {\n\t\tplog.Panicf(\"unexpected new request error (%v)\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", ct)\n\treq.Header.Set(\"X-Server-From\", from.String())\n\treq.Header.Set(\"X-Server-Version\", version.Version)\n\treq.Header.Set(\"X-Min-Cluster-Version\", version.MinClusterVersion)\n\treq.Header.Set(\"X-Etcd-Cluster-ID\", cid.String())\n\tsetPeerURLsHeader(req, urls)\n\n\treturn req\n}", "code_tokens": ["func", "createPostRequest", "(", "u", "url", ".", "URL", ",", "path", "string", ",", "body", "io", ".", "Reader", ",", "ct", "string", ",", "urls", "types", ".", "URLs", ",", "from", ",", "cid", "types", ".", "ID", ")", "*", "http", ".", "Request", "{", "uu", ":=", "u", "\n", "uu", ".", "Path", "=", "path", "\n", "req", ",", "err", ":=", "http", ".", "NewRequest", "(", "\"", "\"", ",", "uu", ".", "String", "(", ")", ",", "body", ")", "\n", "if", "err", "!=", "nil", "{", "plog", ".", "Panicf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "ct", ")", "\n", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "from", ".", "String", "(", ")", ")", "\n", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "version", ".", "Version", ")", "\n", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "version", ".", "MinClusterVersion", ")", "\n", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "cid", ".", "String", "(", ")", ")", "\n", "setPeerURLsHeader", "(", "req", ",", "urls", ")", "\n\n", "return", "req", "\n", "}"], "docstring": "// createPostRequest creates a HTTP POST request that sends raft message.", "docstring_tokens": ["createPostRequest", "creates", "a", "HTTP", "POST", "request", "that", "sends", "raft", "message", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/util.go#L63-L78", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "boskos/common/aws/common.go", "func_name": "GetAWSCreds", "original_string": "func GetAWSCreds(r *common.Resource) (credentials.Value, error) {\n\tval := credentials.Value{}\n\n\tif r.Type != ResourceType {\n\t\treturn val, fmt.Errorf(\"Wanted resource of type %q, got %q\", ResourceType, r.Type)\n\t}\n\n\taccessKey, ok := r.UserData.Map.Load(UserDataAccessIDKey)\n\tif !ok {\n\t\treturn val, errors.New(\"No Access Key ID in UserData\")\n\t}\n\tsecretKey, ok := r.UserData.Map.Load(UserDataSecretAccessKey)\n\tif !ok {\n\t\treturn val, errors.New(\"No Secret Access Key in UserData\")\n\t}\n\n\tval.AccessKeyID = accessKey.(string)\n\tval.SecretAccessKey = secretKey.(string)\n\n\treturn val, nil\n\n}", "language": "go", "code": "func GetAWSCreds(r *common.Resource) (credentials.Value, error) {\n\tval := credentials.Value{}\n\n\tif r.Type != ResourceType {\n\t\treturn val, fmt.Errorf(\"Wanted resource of type %q, got %q\", ResourceType, r.Type)\n\t}\n\n\taccessKey, ok := r.UserData.Map.Load(UserDataAccessIDKey)\n\tif !ok {\n\t\treturn val, errors.New(\"No Access Key ID in UserData\")\n\t}\n\tsecretKey, ok := r.UserData.Map.Load(UserDataSecretAccessKey)\n\tif !ok {\n\t\treturn val, errors.New(\"No Secret Access Key in UserData\")\n\t}\n\n\tval.AccessKeyID = accessKey.(string)\n\tval.SecretAccessKey = secretKey.(string)\n\n\treturn val, nil\n\n}", "code_tokens": ["func", "GetAWSCreds", "(", "r", "*", "common", ".", "Resource", ")", "(", "credentials", ".", "Value", ",", "error", ")", "{", "val", ":=", "credentials", ".", "Value", "{", "}", "\n\n", "if", "r", ".", "Type", "!=", "ResourceType", "{", "return", "val", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "ResourceType", ",", "r", ".", "Type", ")", "\n", "}", "\n\n", "accessKey", ",", "ok", ":=", "r", ".", "UserData", ".", "Map", ".", "Load", "(", "UserDataAccessIDKey", ")", "\n", "if", "!", "ok", "{", "return", "val", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n", "secretKey", ",", "ok", ":=", "r", ".", "UserData", ".", "Map", ".", "Load", "(", "UserDataSecretAccessKey", ")", "\n", "if", "!", "ok", "{", "return", "val", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}", "\n\n", "val", ".", "AccessKeyID", "=", "accessKey", ".", "(", "string", ")", "\n", "val", ".", "SecretAccessKey", "=", "secretKey", ".", "(", "string", ")", "\n\n", "return", "val", ",", "nil", "\n\n", "}"], "docstring": "// GetAWSCreds tries to fetch AWS credentials from a resource", "docstring_tokens": ["GetAWSCreds", "tries", "to", "fetch", "AWS", "credentials", "from", "a", "resource"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/boskos/common/aws/common.go#L39-L60", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "velodrome/fetcher/comments.go", "func_name": "UpdateComments", "original_string": "func UpdateComments(issueID int, pullRequest bool, db *gorm.DB, client ClientInterface) {\n\tlatest := findLatestCommentUpdate(issueID, db, client.RepositoryName())\n\n\tupdateIssueComments(issueID, latest, db, client)\n\tif pullRequest {\n\t\tupdatePullComments(issueID, latest, db, client)\n\t}\n}", "language": "go", "code": "func UpdateComments(issueID int, pullRequest bool, db *gorm.DB, client ClientInterface) {\n\tlatest := findLatestCommentUpdate(issueID, db, client.RepositoryName())\n\n\tupdateIssueComments(issueID, latest, db, client)\n\tif pullRequest {\n\t\tupdatePullComments(issueID, latest, db, client)\n\t}\n}", "code_tokens": ["func", "UpdateComments", "(", "issueID", "int", ",", "pullRequest", "bool", ",", "db", "*", "gorm", ".", "DB", ",", "client", "ClientInterface", ")", "{", "latest", ":=", "findLatestCommentUpdate", "(", "issueID", ",", "db", ",", "client", ".", "RepositoryName", "(", ")", ")", "\n\n", "updateIssueComments", "(", "issueID", ",", "latest", ",", "db", ",", "client", ")", "\n", "if", "pullRequest", "{", "updatePullComments", "(", "issueID", ",", "latest", ",", "db", ",", "client", ")", "\n", "}", "\n", "}"], "docstring": "// UpdateComments downloads issue and pull-request comments and save in DB", "docstring_tokens": ["UpdateComments", "downloads", "issue", "and", "pull", "-", "request", "comments", "and", "save", "in", "DB"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/velodrome/fetcher/comments.go#L80-L87", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewStellarMessage", "original_string": "func NewStellarMessage(aType MessageType, value interface{}) (result StellarMessage, err error) {\n\tresult.Type = aType\n\tswitch MessageType(aType) {\n\tcase MessageTypeErrorMsg:\n\t\ttv, ok := value.(Error)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Error\")\n\t\t\treturn\n\t\t}\n\t\tresult.Error = &tv\n\tcase MessageTypeHello:\n\t\ttv, ok := value.(Hello)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Hello\")\n\t\t\treturn\n\t\t}\n\t\tresult.Hello = &tv\n\tcase MessageTypeAuth:\n\t\ttv, ok := value.(Auth)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Auth\")\n\t\t\treturn\n\t\t}\n\t\tresult.Auth = &tv\n\tcase MessageTypeDontHave:\n\t\ttv, ok := value.(DontHave)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be DontHave\")\n\t\t\treturn\n\t\t}\n\t\tresult.DontHave = &tv\n\tcase MessageTypeGetPeers:\n\t\t// void\n\tcase MessageTypePeers:\n\t\ttv, ok := value.([]PeerAddress)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be []PeerAddress\")\n\t\t\treturn\n\t\t}\n\t\tresult.Peers = &tv\n\tcase MessageTypeGetTxSet:\n\t\ttv, ok := value.(Uint256)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Uint256\")\n\t\t\treturn\n\t\t}\n\t\tresult.TxSetHash = &tv\n\tcase MessageTypeTxSet:\n\t\ttv, ok := value.(TransactionSet)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be TransactionSet\")\n\t\t\treturn\n\t\t}\n\t\tresult.TxSet = &tv\n\tcase MessageTypeTransaction:\n\t\ttv, ok := value.(TransactionEnvelope)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be TransactionEnvelope\")\n\t\t\treturn\n\t\t}\n\t\tresult.Transaction = &tv\n\tcase MessageTypeGetScpQuorumset:\n\t\ttv, ok := value.(Uint256)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Uint256\")\n\t\t\treturn\n\t\t}\n\t\tresult.QSetHash = &tv\n\tcase MessageTypeScpQuorumset:\n\t\ttv, ok := value.(ScpQuorumSet)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be ScpQuorumSet\")\n\t\t\treturn\n\t\t}\n\t\tresult.QSet = &tv\n\tcase MessageTypeScpMessage:\n\t\ttv, ok := value.(ScpEnvelope)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be ScpEnvelope\")\n\t\t\treturn\n\t\t}\n\t\tresult.Envelope = &tv\n\tcase MessageTypeGetScpState:\n\t\ttv, ok := value.(Uint32)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Uint32\")\n\t\t\treturn\n\t\t}\n\t\tresult.GetScpLedgerSeq = &tv\n\t}\n\treturn\n}", "language": "go", "code": "func NewStellarMessage(aType MessageType, value interface{}) (result StellarMessage, err error) {\n\tresult.Type = aType\n\tswitch MessageType(aType) {\n\tcase MessageTypeErrorMsg:\n\t\ttv, ok := value.(Error)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Error\")\n\t\t\treturn\n\t\t}\n\t\tresult.Error = &tv\n\tcase MessageTypeHello:\n\t\ttv, ok := value.(Hello)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Hello\")\n\t\t\treturn\n\t\t}\n\t\tresult.Hello = &tv\n\tcase MessageTypeAuth:\n\t\ttv, ok := value.(Auth)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Auth\")\n\t\t\treturn\n\t\t}\n\t\tresult.Auth = &tv\n\tcase MessageTypeDontHave:\n\t\ttv, ok := value.(DontHave)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be DontHave\")\n\t\t\treturn\n\t\t}\n\t\tresult.DontHave = &tv\n\tcase MessageTypeGetPeers:\n\t\t// void\n\tcase MessageTypePeers:\n\t\ttv, ok := value.([]PeerAddress)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be []PeerAddress\")\n\t\t\treturn\n\t\t}\n\t\tresult.Peers = &tv\n\tcase MessageTypeGetTxSet:\n\t\ttv, ok := value.(Uint256)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Uint256\")\n\t\t\treturn\n\t\t}\n\t\tresult.TxSetHash = &tv\n\tcase MessageTypeTxSet:\n\t\ttv, ok := value.(TransactionSet)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be TransactionSet\")\n\t\t\treturn\n\t\t}\n\t\tresult.TxSet = &tv\n\tcase MessageTypeTransaction:\n\t\ttv, ok := value.(TransactionEnvelope)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be TransactionEnvelope\")\n\t\t\treturn\n\t\t}\n\t\tresult.Transaction = &tv\n\tcase MessageTypeGetScpQuorumset:\n\t\ttv, ok := value.(Uint256)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Uint256\")\n\t\t\treturn\n\t\t}\n\t\tresult.QSetHash = &tv\n\tcase MessageTypeScpQuorumset:\n\t\ttv, ok := value.(ScpQuorumSet)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be ScpQuorumSet\")\n\t\t\treturn\n\t\t}\n\t\tresult.QSet = &tv\n\tcase MessageTypeScpMessage:\n\t\ttv, ok := value.(ScpEnvelope)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be ScpEnvelope\")\n\t\t\treturn\n\t\t}\n\t\tresult.Envelope = &tv\n\tcase MessageTypeGetScpState:\n\t\ttv, ok := value.(Uint32)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be Uint32\")\n\t\t\treturn\n\t\t}\n\t\tresult.GetScpLedgerSeq = &tv\n\t}\n\treturn\n}", "code_tokens": ["func", "NewStellarMessage", "(", "aType", "MessageType", ",", "value", "interface", "{", "}", ")", "(", "result", "StellarMessage", ",", "err", "error", ")", "{", "result", ".", "Type", "=", "aType", "\n", "switch", "MessageType", "(", "aType", ")", "{", "case", "MessageTypeErrorMsg", ":", "tv", ",", "ok", ":=", "value", ".", "(", "Error", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Error", "=", "&", "tv", "\n", "case", "MessageTypeHello", ":", "tv", ",", "ok", ":=", "value", ".", "(", "Hello", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Hello", "=", "&", "tv", "\n", "case", "MessageTypeAuth", ":", "tv", ",", "ok", ":=", "value", ".", "(", "Auth", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Auth", "=", "&", "tv", "\n", "case", "MessageTypeDontHave", ":", "tv", ",", "ok", ":=", "value", ".", "(", "DontHave", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "DontHave", "=", "&", "tv", "\n", "case", "MessageTypeGetPeers", ":", "// void", "case", "MessageTypePeers", ":", "tv", ",", "ok", ":=", "value", ".", "(", "[", "]", "PeerAddress", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Peers", "=", "&", "tv", "\n", "case", "MessageTypeGetTxSet", ":", "tv", ",", "ok", ":=", "value", ".", "(", "Uint256", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "TxSetHash", "=", "&", "tv", "\n", "case", "MessageTypeTxSet", ":", "tv", ",", "ok", ":=", "value", ".", "(", "TransactionSet", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "TxSet", "=", "&", "tv", "\n", "case", "MessageTypeTransaction", ":", "tv", ",", "ok", ":=", "value", ".", "(", "TransactionEnvelope", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Transaction", "=", "&", "tv", "\n", "case", "MessageTypeGetScpQuorumset", ":", "tv", ",", "ok", ":=", "value", ".", "(", "Uint256", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "QSetHash", "=", "&", "tv", "\n", "case", "MessageTypeScpQuorumset", ":", "tv", ",", "ok", ":=", "value", ".", "(", "ScpQuorumSet", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "QSet", "=", "&", "tv", "\n", "case", "MessageTypeScpMessage", ":", "tv", ",", "ok", ":=", "value", ".", "(", "ScpEnvelope", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Envelope", "=", "&", "tv", "\n", "case", "MessageTypeGetScpState", ":", "tv", ",", "ok", ":=", "value", ".", "(", "Uint32", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "GetScpLedgerSeq", "=", "&", "tv", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// NewStellarMessage creates a new  StellarMessage.", "docstring_tokens": ["NewStellarMessage", "creates", "a", "new", "StellarMessage", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6378-L6469", "partition": "test"}
{"repo": "aphistic/gomol", "path": "attrs.go", "func_name": "NewAttrsFromMap", "original_string": "func NewAttrsFromMap(attrs map[string]interface{}) *Attrs {\n\tnewAttrs := NewAttrs()\n\tfor attrKey, attrVal := range attrs {\n\t\tnewAttrs.SetAttr(attrKey, attrVal)\n\t}\n\treturn newAttrs\n}", "language": "go", "code": "func NewAttrsFromMap(attrs map[string]interface{}) *Attrs {\n\tnewAttrs := NewAttrs()\n\tfor attrKey, attrVal := range attrs {\n\t\tnewAttrs.SetAttr(attrKey, attrVal)\n\t}\n\treturn newAttrs\n}", "code_tokens": ["func", "NewAttrsFromMap", "(", "attrs", "map", "[", "string", "]", "interface", "{", "}", ")", "*", "Attrs", "{", "newAttrs", ":=", "NewAttrs", "(", ")", "\n", "for", "attrKey", ",", "attrVal", ":=", "range", "attrs", "{", "newAttrs", ".", "SetAttr", "(", "attrKey", ",", "attrVal", ")", "\n", "}", "\n", "return", "newAttrs", "\n", "}"], "docstring": "// NewAttrsFromMap will create a new Attrs struct with the given attributes pre-populated", "docstring_tokens": ["NewAttrsFromMap", "will", "create", "a", "new", "Attrs", "struct", "with", "the", "given", "attributes", "pre", "-", "populated"], "sha": "1546845ba714699f76f484ad3af64cf0503064d1", "url": "https://github.com/aphistic/gomol/blob/1546845ba714699f76f484ad3af64cf0503064d1/attrs.go#L25-L31", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/cluster/gateway.go", "func_name": "currentRaftNodes", "original_string": "func (g *Gateway) currentRaftNodes() ([]db.RaftNode, error) {\n\tif g.raft == nil {\n\t\treturn nil, raft.ErrNotLeader\n\t}\n\tservers, err := g.raft.Servers()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprovider := raftAddressProvider{db: g.db}\n\tnodes := make([]db.RaftNode, len(servers))\n\tfor i, server := range servers {\n\t\taddress, err := provider.ServerAddr(server.ID)\n\t\tif err != nil {\n\t\t\tif err != db.ErrNoSuchObject {\n\t\t\t\treturn nil, errors.Wrap(err, \"Failed to fetch raft server address\")\n\t\t\t}\n\t\t\t// Use the initial address as fallback. This is an edge\n\t\t\t// case that happens when a new leader is elected and\n\t\t\t// its raft_nodes table is not fully up-to-date yet.\n\t\t\taddress = server.Address\n\t\t}\n\t\tid, err := strconv.Atoi(string(server.ID))\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"Non-numeric server ID\")\n\t\t}\n\t\tnodes[i].ID = int64(id)\n\t\tnodes[i].Address = string(address)\n\t}\n\treturn nodes, nil\n}", "language": "go", "code": "func (g *Gateway) currentRaftNodes() ([]db.RaftNode, error) {\n\tif g.raft == nil {\n\t\treturn nil, raft.ErrNotLeader\n\t}\n\tservers, err := g.raft.Servers()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprovider := raftAddressProvider{db: g.db}\n\tnodes := make([]db.RaftNode, len(servers))\n\tfor i, server := range servers {\n\t\taddress, err := provider.ServerAddr(server.ID)\n\t\tif err != nil {\n\t\t\tif err != db.ErrNoSuchObject {\n\t\t\t\treturn nil, errors.Wrap(err, \"Failed to fetch raft server address\")\n\t\t\t}\n\t\t\t// Use the initial address as fallback. This is an edge\n\t\t\t// case that happens when a new leader is elected and\n\t\t\t// its raft_nodes table is not fully up-to-date yet.\n\t\t\taddress = server.Address\n\t\t}\n\t\tid, err := strconv.Atoi(string(server.ID))\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"Non-numeric server ID\")\n\t\t}\n\t\tnodes[i].ID = int64(id)\n\t\tnodes[i].Address = string(address)\n\t}\n\treturn nodes, nil\n}", "code_tokens": ["func", "(", "g", "*", "Gateway", ")", "currentRaftNodes", "(", ")", "(", "[", "]", "db", ".", "RaftNode", ",", "error", ")", "{", "if", "g", ".", "raft", "==", "nil", "{", "return", "nil", ",", "raft", ".", "ErrNotLeader", "\n", "}", "\n", "servers", ",", "err", ":=", "g", ".", "raft", ".", "Servers", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "provider", ":=", "raftAddressProvider", "{", "db", ":", "g", ".", "db", "}", "\n", "nodes", ":=", "make", "(", "[", "]", "db", ".", "RaftNode", ",", "len", "(", "servers", ")", ")", "\n", "for", "i", ",", "server", ":=", "range", "servers", "{", "address", ",", "err", ":=", "provider", ".", "ServerAddr", "(", "server", ".", "ID", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", "!=", "db", ".", "ErrNoSuchObject", "{", "return", "nil", ",", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "// Use the initial address as fallback. This is an edge", "// case that happens when a new leader is elected and", "// its raft_nodes table is not fully up-to-date yet.", "address", "=", "server", ".", "Address", "\n", "}", "\n", "id", ",", "err", ":=", "strconv", ".", "Atoi", "(", "string", "(", "server", ".", "ID", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "nodes", "[", "i", "]", ".", "ID", "=", "int64", "(", "id", ")", "\n", "nodes", "[", "i", "]", ".", "Address", "=", "string", "(", "address", ")", "\n", "}", "\n", "return", "nodes", ",", "nil", "\n", "}"], "docstring": "// Return information about the LXD nodes that a currently part of the raft\n// cluster, as configured in the raft log. It returns an error if this node is\n// not the leader.", "docstring_tokens": ["Return", "information", "about", "the", "LXD", "nodes", "that", "a", "currently", "part", "of", "the", "raft", "cluster", "as", "configured", "in", "the", "raft", "log", ".", "It", "returns", "an", "error", "if", "this", "node", "is", "not", "the", "leader", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/gateway.go#L516-L545", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/api/v2store/store.go", "func_name": "walk", "original_string": "func (s *store) walk(nodePath string, walkFunc func(prev *node, component string) (*node, *v2error.Error)) (*node, *v2error.Error) {\n\tcomponents := strings.Split(nodePath, \"/\")\n\n\tcurr := s.Root\n\tvar err *v2error.Error\n\n\tfor i := 1; i < len(components); i++ {\n\t\tif len(components[i]) == 0 { // ignore empty string\n\t\t\treturn curr, nil\n\t\t}\n\n\t\tcurr, err = walkFunc(curr, components[i])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn curr, nil\n}", "language": "go", "code": "func (s *store) walk(nodePath string, walkFunc func(prev *node, component string) (*node, *v2error.Error)) (*node, *v2error.Error) {\n\tcomponents := strings.Split(nodePath, \"/\")\n\n\tcurr := s.Root\n\tvar err *v2error.Error\n\n\tfor i := 1; i < len(components); i++ {\n\t\tif len(components[i]) == 0 { // ignore empty string\n\t\t\treturn curr, nil\n\t\t}\n\n\t\tcurr, err = walkFunc(curr, components[i])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn curr, nil\n}", "code_tokens": ["func", "(", "s", "*", "store", ")", "walk", "(", "nodePath", "string", ",", "walkFunc", "func", "(", "prev", "*", "node", ",", "component", "string", ")", "(", "*", "node", ",", "*", "v2error", ".", "Error", ")", ")", "(", "*", "node", ",", "*", "v2error", ".", "Error", ")", "{", "components", ":=", "strings", ".", "Split", "(", "nodePath", ",", "\"", "\"", ")", "\n\n", "curr", ":=", "s", ".", "Root", "\n", "var", "err", "*", "v2error", ".", "Error", "\n\n", "for", "i", ":=", "1", ";", "i", "<", "len", "(", "components", ")", ";", "i", "++", "{", "if", "len", "(", "components", "[", "i", "]", ")", "==", "0", "{", "// ignore empty string", "return", "curr", ",", "nil", "\n", "}", "\n\n", "curr", ",", "err", "=", "walkFunc", "(", "curr", ",", "components", "[", "i", "]", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "}", "\n\n", "return", "curr", ",", "nil", "\n", "}"], "docstring": "// walk walks all the nodePath and apply the walkFunc on each directory", "docstring_tokens": ["walk", "walks", "all", "the", "nodePath", "and", "apply", "the", "walkFunc", "on", "each", "directory"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2store/store.go#L469-L487", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "handlers/cli/cli.go", "func_name": "HandleLog", "original_string": "func (h *Handler) HandleLog(e *log.Entry) error {\n\tcolor := Colors[e.Level]\n\tlevel := Strings[e.Level]\n\n\tvar fields []field\n\n\tfor k, v := range e.Fields {\n\t\tfields = append(fields, field{k, v})\n\t}\n\n\tsort.Sort(byName(fields))\n\n\th.mu.Lock()\n\tdefer h.mu.Unlock()\n\n\tif h.UseColor {\n\t\tfmt.Fprintf(h.Writer, \"\\033[%dm%6s\\033[0m %-40s\", color, level, e.Message)\n\t} else {\n\t\tfmt.Fprintf(h.Writer, \"%6s %-40s\", level, e.Message)\n\t}\n\n\tfor _, f := range fields {\n\t\tvar value interface{}\n\t\tswitch t := f.Value.(type) {\n\t\tcase []byte: // addresses and EUIs are []byte\n\t\t\tvalue = fmt.Sprintf(\"%X\", t)\n\t\tcase [21]byte: // bundle IDs [21]byte\n\t\t\tvalue = fmt.Sprintf(\"%X-%X-%X-%X\", t[0], t[1:9], t[9:17], t[17:])\n\t\tdefault:\n\t\t\tvalue = f.Value\n\t\t}\n\n\t\tif h.UseColor {\n\t\t\tfmt.Fprintf(h.Writer, \" \\033[%dm%s\\033[0m=%v\", color, f.Name, value)\n\t\t} else {\n\t\t\tfmt.Fprintf(h.Writer, \" %s=%v\", f.Name, value)\n\t\t}\n\n\t}\n\n\tfmt.Fprintln(h.Writer)\n\n\treturn nil\n}", "language": "go", "code": "func (h *Handler) HandleLog(e *log.Entry) error {\n\tcolor := Colors[e.Level]\n\tlevel := Strings[e.Level]\n\n\tvar fields []field\n\n\tfor k, v := range e.Fields {\n\t\tfields = append(fields, field{k, v})\n\t}\n\n\tsort.Sort(byName(fields))\n\n\th.mu.Lock()\n\tdefer h.mu.Unlock()\n\n\tif h.UseColor {\n\t\tfmt.Fprintf(h.Writer, \"\\033[%dm%6s\\033[0m %-40s\", color, level, e.Message)\n\t} else {\n\t\tfmt.Fprintf(h.Writer, \"%6s %-40s\", level, e.Message)\n\t}\n\n\tfor _, f := range fields {\n\t\tvar value interface{}\n\t\tswitch t := f.Value.(type) {\n\t\tcase []byte: // addresses and EUIs are []byte\n\t\t\tvalue = fmt.Sprintf(\"%X\", t)\n\t\tcase [21]byte: // bundle IDs [21]byte\n\t\t\tvalue = fmt.Sprintf(\"%X-%X-%X-%X\", t[0], t[1:9], t[9:17], t[17:])\n\t\tdefault:\n\t\t\tvalue = f.Value\n\t\t}\n\n\t\tif h.UseColor {\n\t\t\tfmt.Fprintf(h.Writer, \" \\033[%dm%s\\033[0m=%v\", color, f.Name, value)\n\t\t} else {\n\t\t\tfmt.Fprintf(h.Writer, \" %s=%v\", f.Name, value)\n\t\t}\n\n\t}\n\n\tfmt.Fprintln(h.Writer)\n\n\treturn nil\n}", "code_tokens": ["func", "(", "h", "*", "Handler", ")", "HandleLog", "(", "e", "*", "log", ".", "Entry", ")", "error", "{", "color", ":=", "Colors", "[", "e", ".", "Level", "]", "\n", "level", ":=", "Strings", "[", "e", ".", "Level", "]", "\n\n", "var", "fields", "[", "]", "field", "\n\n", "for", "k", ",", "v", ":=", "range", "e", ".", "Fields", "{", "fields", "=", "append", "(", "fields", ",", "field", "{", "k", ",", "v", "}", ")", "\n", "}", "\n\n", "sort", ".", "Sort", "(", "byName", "(", "fields", ")", ")", "\n\n", "h", ".", "mu", ".", "Lock", "(", ")", "\n", "defer", "h", ".", "mu", ".", "Unlock", "(", ")", "\n\n", "if", "h", ".", "UseColor", "{", "fmt", ".", "Fprintf", "(", "h", ".", "Writer", ",", "\"", "\\033", "\\033", "\"", ",", "color", ",", "level", ",", "e", ".", "Message", ")", "\n", "}", "else", "{", "fmt", ".", "Fprintf", "(", "h", ".", "Writer", ",", "\"", "\"", ",", "level", ",", "e", ".", "Message", ")", "\n", "}", "\n\n", "for", "_", ",", "f", ":=", "range", "fields", "{", "var", "value", "interface", "{", "}", "\n", "switch", "t", ":=", "f", ".", "Value", ".", "(", "type", ")", "{", "case", "[", "]", "byte", ":", "// addresses and EUIs are []byte", "value", "=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "t", ")", "\n", "case", "[", "21", "]", "byte", ":", "// bundle IDs [21]byte", "value", "=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "t", "[", "0", "]", ",", "t", "[", "1", ":", "9", "]", ",", "t", "[", "9", ":", "17", "]", ",", "t", "[", "17", ":", "]", ")", "\n", "default", ":", "value", "=", "f", ".", "Value", "\n", "}", "\n\n", "if", "h", ".", "UseColor", "{", "fmt", ".", "Fprintf", "(", "h", ".", "Writer", ",", "\"", "\\033", "\\033", "\"", ",", "color", ",", "f", ".", "Name", ",", "value", ")", "\n", "}", "else", "{", "fmt", ".", "Fprintf", "(", "h", ".", "Writer", ",", "\"", "\"", ",", "f", ".", "Name", ",", "value", ")", "\n", "}", "\n\n", "}", "\n\n", "fmt", ".", "Fprintln", "(", "h", ".", "Writer", ")", "\n\n", "return", "nil", "\n", "}"], "docstring": "// HandleLog implements log.Handler.", "docstring_tokens": ["HandleLog", "implements", "log", ".", "Handler", "."], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/handlers/cli/cli.go#L92-L135", "partition": "test"}
{"repo": "rightscale/rsc", "path": "metadata/resource.go", "func_name": "findMatches", "original_string": "func (r *Resource) findMatches(href string) []*PathPattern {\n\tvar matches []*PathPattern\n\tfor _, action := range r.Actions {\n\t\tfor _, pattern := range action.PathPatterns {\n\t\t\tif pattern.Regexp.MatchString(href) || pattern.Regexp.MatchString(href+\"/\") {\n\t\t\t\tmatches = append(matches, pattern)\n\t\t\t}\n\t\t}\n\t}\n\treturn matches\n}", "language": "go", "code": "func (r *Resource) findMatches(href string) []*PathPattern {\n\tvar matches []*PathPattern\n\tfor _, action := range r.Actions {\n\t\tfor _, pattern := range action.PathPatterns {\n\t\t\tif pattern.Regexp.MatchString(href) || pattern.Regexp.MatchString(href+\"/\") {\n\t\t\t\tmatches = append(matches, pattern)\n\t\t\t}\n\t\t}\n\t}\n\treturn matches\n}", "code_tokens": ["func", "(", "r", "*", "Resource", ")", "findMatches", "(", "href", "string", ")", "[", "]", "*", "PathPattern", "{", "var", "matches", "[", "]", "*", "PathPattern", "\n", "for", "_", ",", "action", ":=", "range", "r", ".", "Actions", "{", "for", "_", ",", "pattern", ":=", "range", "action", ".", "PathPatterns", "{", "if", "pattern", ".", "Regexp", ".", "MatchString", "(", "href", ")", "||", "pattern", ".", "Regexp", ".", "MatchString", "(", "href", "+", "\"", "\"", ")", "{", "matches", "=", "append", "(", "matches", ",", "pattern", ")", "\n", "}", "\n", "}", "\n", "}", "\n", "return", "matches", "\n", "}"], "docstring": "// Find paths that match given href", "docstring_tokens": ["Find", "paths", "that", "match", "given", "href"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/metadata/resource.go#L71-L81", "partition": "test"}
{"repo": "golang/debug", "path": "internal/core/process.go", "func_name": "ReadableN", "original_string": "func (p *Process) ReadableN(a Address, n int64) bool {\n\tfor {\n\t\tm := p.findMapping(a)\n\t\tif m == nil || m.perm&Read == 0 {\n\t\t\treturn false\n\t\t}\n\t\tc := m.max.Sub(a)\n\t\tif n <= c {\n\t\t\treturn true\n\t\t}\n\t\tn -= c\n\t\ta = a.Add(c)\n\t}\n}", "language": "go", "code": "func (p *Process) ReadableN(a Address, n int64) bool {\n\tfor {\n\t\tm := p.findMapping(a)\n\t\tif m == nil || m.perm&Read == 0 {\n\t\t\treturn false\n\t\t}\n\t\tc := m.max.Sub(a)\n\t\tif n <= c {\n\t\t\treturn true\n\t\t}\n\t\tn -= c\n\t\ta = a.Add(c)\n\t}\n}", "code_tokens": ["func", "(", "p", "*", "Process", ")", "ReadableN", "(", "a", "Address", ",", "n", "int64", ")", "bool", "{", "for", "{", "m", ":=", "p", ".", "findMapping", "(", "a", ")", "\n", "if", "m", "==", "nil", "||", "m", ".", "perm", "&", "Read", "==", "0", "{", "return", "false", "\n", "}", "\n", "c", ":=", "m", ".", "max", ".", "Sub", "(", "a", ")", "\n", "if", "n", "<=", "c", "{", "return", "true", "\n", "}", "\n", "n", "-=", "c", "\n", "a", "=", "a", ".", "Add", "(", "c", ")", "\n", "}", "\n", "}"], "docstring": "// ReadableN reports whether the n bytes starting at address a are readable.", "docstring_tokens": ["ReadableN", "reports", "whether", "the", "n", "bytes", "starting", "at", "address", "a", "are", "readable", "."], "sha": "19561fee47cf8cd0400d1b094c5898002f97cf90", "url": "https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/core/process.go#L75-L88", "partition": "test"}
{"repo": "google/go-cmp", "path": "cmp/report_reflect.go", "func_name": "formatMapKey", "original_string": "func formatMapKey(v reflect.Value) string {\n\tvar opts formatOptions\n\topts.TypeMode = elideType\n\topts.AvoidStringer = true\n\topts.ShallowPointers = true\n\ts := opts.FormatValue(v, visitedPointers{}).String()\n\treturn strings.TrimSpace(s)\n}", "language": "go", "code": "func formatMapKey(v reflect.Value) string {\n\tvar opts formatOptions\n\topts.TypeMode = elideType\n\topts.AvoidStringer = true\n\topts.ShallowPointers = true\n\ts := opts.FormatValue(v, visitedPointers{}).String()\n\treturn strings.TrimSpace(s)\n}", "code_tokens": ["func", "formatMapKey", "(", "v", "reflect", ".", "Value", ")", "string", "{", "var", "opts", "formatOptions", "\n", "opts", ".", "TypeMode", "=", "elideType", "\n", "opts", ".", "AvoidStringer", "=", "true", "\n", "opts", ".", "ShallowPointers", "=", "true", "\n", "s", ":=", "opts", ".", "FormatValue", "(", "v", ",", "visitedPointers", "{", "}", ")", ".", "String", "(", ")", "\n", "return", "strings", ".", "TrimSpace", "(", "s", ")", "\n", "}"], "docstring": "// formatMapKey formats v as if it were a map key.\n// The result is guaranteed to be a single line.", "docstring_tokens": ["formatMapKey", "formats", "v", "as", "if", "it", "were", "a", "map", "key", ".", "The", "result", "is", "guaranteed", "to", "be", "a", "single", "line", "."], "sha": "6f77996f0c42f7b84e5a2b252227263f93432e9b", "url": "https://github.com/google/go-cmp/blob/6f77996f0c42f7b84e5a2b252227263f93432e9b/cmp/report_reflect.go#L208-L215", "partition": "test"}
{"repo": "mikespook/possum", "path": "server.go", "func_name": "NewServerMux", "original_string": "func NewServerMux() (mux *ServerMux) {\n\tnf := struct {\n\t\tView    view.View\n\t\tHandler HandlerFunc\n\t}{view.Simple(view.ContentTypePlain, view.CharSetUTF8), defaultNotFound}\n\treturn &ServerMux{NewRouters(), nil, nil, nil, nf}\n}", "language": "go", "code": "func NewServerMux() (mux *ServerMux) {\n\tnf := struct {\n\t\tView    view.View\n\t\tHandler HandlerFunc\n\t}{view.Simple(view.ContentTypePlain, view.CharSetUTF8), defaultNotFound}\n\treturn &ServerMux{NewRouters(), nil, nil, nil, nf}\n}", "code_tokens": ["func", "NewServerMux", "(", ")", "(", "mux", "*", "ServerMux", ")", "{", "nf", ":=", "struct", "{", "View", "view", ".", "View", "\n", "Handler", "HandlerFunc", "\n", "}", "{", "view", ".", "Simple", "(", "view", ".", "ContentTypePlain", ",", "view", ".", "CharSetUTF8", ")", ",", "defaultNotFound", "}", "\n", "return", "&", "ServerMux", "{", "NewRouters", "(", ")", ",", "nil", ",", "nil", ",", "nil", ",", "nf", "}", "\n", "}"], "docstring": "// NewServerMux returns a new Handler.", "docstring_tokens": ["NewServerMux", "returns", "a", "new", "Handler", "."], "sha": "56d7ebb6470b670001632b11be7fc089038f4dd7", "url": "https://github.com/mikespook/possum/blob/56d7ebb6470b670001632b11be7fc089038f4dd7/server.go#L36-L42", "partition": "test"}
{"repo": "adamzy/cedar-go", "path": "io.go", "func_name": "SaveToFile", "original_string": "func (da *Cedar) SaveToFile(fileName string, dataType string) error {\n\tfile, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tout := bufio.NewWriter(file)\n\tdefer out.Flush()\n\tda.Save(out, dataType)\n\treturn nil\n}", "language": "go", "code": "func (da *Cedar) SaveToFile(fileName string, dataType string) error {\n\tfile, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tout := bufio.NewWriter(file)\n\tdefer out.Flush()\n\tda.Save(out, dataType)\n\treturn nil\n}", "code_tokens": ["func", "(", "da", "*", "Cedar", ")", "SaveToFile", "(", "fileName", "string", ",", "dataType", "string", ")", "error", "{", "file", ",", "err", ":=", "os", ".", "OpenFile", "(", "fileName", ",", "os", ".", "O_CREATE", "|", "os", ".", "O_WRONLY", ",", "0666", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "defer", "file", ".", "Close", "(", ")", "\n", "out", ":=", "bufio", ".", "NewWriter", "(", "file", ")", "\n", "defer", "out", ".", "Flush", "(", ")", "\n", "da", ".", "Save", "(", "out", ",", "dataType", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// SaveToFile saves the cedar to a file,\n// where dataType is either \"json\" or \"gob\".", "docstring_tokens": ["SaveToFile", "saves", "the", "cedar", "to", "a", "file", "where", "dataType", "is", "either", "json", "or", "gob", "."], "sha": "80a9c64b256db37ac20aff007907c649afb714f1", "url": "https://github.com/adamzy/cedar-go/blob/80a9c64b256db37ac20aff007907c649afb714f1/io.go#L27-L37", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "app/platform.go", "func_name": "Remove", "original_string": "func (s *platformService) Remove(name string) error {\n\tif name == \"\" {\n\t\treturn appTypes.ErrPlatformNameMissing\n\t}\n\tconn, err := db.Conn()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\tapps, _ := conn.Apps().Find(bson.M{\"framework\": name}).Count()\n\tif apps > 0 {\n\t\treturn appTypes.ErrDeletePlatformWithApps\n\t}\n\terr = builder.PlatformRemove(name)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to remove platform from builder: %s\", err)\n\t}\n\timages, err := servicemanager.PlatformImage.ListImagesOrDefault(name)\n\tif err == nil {\n\t\tfor _, img := range images {\n\t\t\tif regErr := registry.RemoveImage(img); regErr != nil {\n\t\t\t\tlog.Errorf(\"Failed to remove platform image from registry: %s\", regErr)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.Errorf(\"Failed to retrieve platform images from storage: %s\", err)\n\t}\n\terr = servicemanager.PlatformImage.DeleteImages(name)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to remove platform images from storage: %s\", err)\n\t}\n\treturn s.storage.Delete(appTypes.Platform{Name: name})\n}", "language": "go", "code": "func (s *platformService) Remove(name string) error {\n\tif name == \"\" {\n\t\treturn appTypes.ErrPlatformNameMissing\n\t}\n\tconn, err := db.Conn()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Close()\n\tapps, _ := conn.Apps().Find(bson.M{\"framework\": name}).Count()\n\tif apps > 0 {\n\t\treturn appTypes.ErrDeletePlatformWithApps\n\t}\n\terr = builder.PlatformRemove(name)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to remove platform from builder: %s\", err)\n\t}\n\timages, err := servicemanager.PlatformImage.ListImagesOrDefault(name)\n\tif err == nil {\n\t\tfor _, img := range images {\n\t\t\tif regErr := registry.RemoveImage(img); regErr != nil {\n\t\t\t\tlog.Errorf(\"Failed to remove platform image from registry: %s\", regErr)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.Errorf(\"Failed to retrieve platform images from storage: %s\", err)\n\t}\n\terr = servicemanager.PlatformImage.DeleteImages(name)\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to remove platform images from storage: %s\", err)\n\t}\n\treturn s.storage.Delete(appTypes.Platform{Name: name})\n}", "code_tokens": ["func", "(", "s", "*", "platformService", ")", "Remove", "(", "name", "string", ")", "error", "{", "if", "name", "==", "\"", "\"", "{", "return", "appTypes", ".", "ErrPlatformNameMissing", "\n", "}", "\n", "conn", ",", "err", ":=", "db", ".", "Conn", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "defer", "conn", ".", "Close", "(", ")", "\n", "apps", ",", "_", ":=", "conn", ".", "Apps", "(", ")", ".", "Find", "(", "bson", ".", "M", "{", "\"", "\"", ":", "name", "}", ")", ".", "Count", "(", ")", "\n", "if", "apps", ">", "0", "{", "return", "appTypes", ".", "ErrDeletePlatformWithApps", "\n", "}", "\n", "err", "=", "builder", ".", "PlatformRemove", "(", "name", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "images", ",", "err", ":=", "servicemanager", ".", "PlatformImage", ".", "ListImagesOrDefault", "(", "name", ")", "\n", "if", "err", "==", "nil", "{", "for", "_", ",", "img", ":=", "range", "images", "{", "if", "regErr", ":=", "registry", ".", "RemoveImage", "(", "img", ")", ";", "regErr", "!=", "nil", "{", "log", ".", "Errorf", "(", "\"", "\"", ",", "regErr", ")", "\n", "}", "\n", "}", "\n", "}", "else", "{", "log", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "err", "=", "servicemanager", ".", "PlatformImage", ".", "DeleteImages", "(", "name", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "return", "s", ".", "storage", ".", "Delete", "(", "appTypes", ".", "Platform", "{", "Name", ":", "name", "}", ")", "\n", "}"], "docstring": "// Remove implements Remove method of PlatformService interface", "docstring_tokens": ["Remove", "implements", "Remove", "method", "of", "PlatformService", "interface"], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/app/platform.go#L147-L179", "partition": "test"}
{"repo": "janos/web", "path": "recovery/recovery.go", "func_name": "WithPanicResponse", "original_string": "func WithPanicResponse(body, contentType string) Option {\n\treturn func(o *Handler) {\n\t\to.panicBody = body\n\t\to.panicContentType = contentType\n\t}\n}", "language": "go", "code": "func WithPanicResponse(body, contentType string) Option {\n\treturn func(o *Handler) {\n\t\to.panicBody = body\n\t\to.panicContentType = contentType\n\t}\n}", "code_tokens": ["func", "WithPanicResponse", "(", "body", ",", "contentType", "string", ")", "Option", "{", "return", "func", "(", "o", "*", "Handler", ")", "{", "o", ".", "panicBody", "=", "body", "\n", "o", ".", "panicContentType", "=", "contentType", "\n", "}", "\n", "}"], "docstring": "// WithPanicResponse sets a fixed body and its content type HTTP header\n// that will be returned as HTTP response on panic event.\n// If WithPanicResponseHandler is defined, this options are ignored.", "docstring_tokens": ["WithPanicResponse", "sets", "a", "fixed", "body", "and", "its", "content", "type", "HTTP", "header", "that", "will", "be", "returned", "as", "HTTP", "response", "on", "panic", "event", ".", "If", "WithPanicResponseHandler", "is", "defined", "this", "options", "are", "ignored", "."], "sha": "0fb0203103deb84424510a8d5166ac00700f2b0e", "url": "https://github.com/janos/web/blob/0fb0203103deb84424510a8d5166ac00700f2b0e/recovery/recovery.go#L38-L43", "partition": "test"}
{"repo": "ant0ine/go-json-rest", "path": "rest/recover.go", "func_name": "MiddlewareFunc", "original_string": "func (mw *RecoverMiddleware) MiddlewareFunc(h HandlerFunc) HandlerFunc {\n\n\t// set the default Logger\n\tif mw.Logger == nil {\n\t\tmw.Logger = log.New(os.Stderr, \"\", 0)\n\t}\n\n\treturn func(w ResponseWriter, r *Request) {\n\n\t\t// catch user code's panic, and convert to http response\n\t\tdefer func() {\n\t\t\tif reco := recover(); reco != nil {\n\t\t\t\ttrace := debug.Stack()\n\n\t\t\t\t// log the trace\n\t\t\t\tmessage := fmt.Sprintf(\"%s\\n%s\", reco, trace)\n\t\t\t\tmw.logError(message)\n\n\t\t\t\t// write error response\n\t\t\t\tif mw.EnableResponseStackTrace {\n\t\t\t\t\tError(w, message, http.StatusInternalServerError)\n\t\t\t\t} else {\n\t\t\t\t\tError(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// call the handler\n\t\th(w, r)\n\t}\n}", "language": "go", "code": "func (mw *RecoverMiddleware) MiddlewareFunc(h HandlerFunc) HandlerFunc {\n\n\t// set the default Logger\n\tif mw.Logger == nil {\n\t\tmw.Logger = log.New(os.Stderr, \"\", 0)\n\t}\n\n\treturn func(w ResponseWriter, r *Request) {\n\n\t\t// catch user code's panic, and convert to http response\n\t\tdefer func() {\n\t\t\tif reco := recover(); reco != nil {\n\t\t\t\ttrace := debug.Stack()\n\n\t\t\t\t// log the trace\n\t\t\t\tmessage := fmt.Sprintf(\"%s\\n%s\", reco, trace)\n\t\t\t\tmw.logError(message)\n\n\t\t\t\t// write error response\n\t\t\t\tif mw.EnableResponseStackTrace {\n\t\t\t\t\tError(w, message, http.StatusInternalServerError)\n\t\t\t\t} else {\n\t\t\t\t\tError(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// call the handler\n\t\th(w, r)\n\t}\n}", "code_tokens": ["func", "(", "mw", "*", "RecoverMiddleware", ")", "MiddlewareFunc", "(", "h", "HandlerFunc", ")", "HandlerFunc", "{", "// set the default Logger", "if", "mw", ".", "Logger", "==", "nil", "{", "mw", ".", "Logger", "=", "log", ".", "New", "(", "os", ".", "Stderr", ",", "\"", "\"", ",", "0", ")", "\n", "}", "\n\n", "return", "func", "(", "w", "ResponseWriter", ",", "r", "*", "Request", ")", "{", "// catch user code's panic, and convert to http response", "defer", "func", "(", ")", "{", "if", "reco", ":=", "recover", "(", ")", ";", "reco", "!=", "nil", "{", "trace", ":=", "debug", ".", "Stack", "(", ")", "\n\n", "// log the trace", "message", ":=", "fmt", ".", "Sprintf", "(", "\"", "\\n", "\"", ",", "reco", ",", "trace", ")", "\n", "mw", ".", "logError", "(", "message", ")", "\n\n", "// write error response", "if", "mw", ".", "EnableResponseStackTrace", "{", "Error", "(", "w", ",", "message", ",", "http", ".", "StatusInternalServerError", ")", "\n", "}", "else", "{", "Error", "(", "w", ",", "\"", "\"", ",", "http", ".", "StatusInternalServerError", ")", "\n", "}", "\n", "}", "\n", "}", "(", ")", "\n\n", "// call the handler", "h", "(", "w", ",", "r", ")", "\n", "}", "\n", "}"], "docstring": "// MiddlewareFunc makes RecoverMiddleware implement the Middleware interface.", "docstring_tokens": ["MiddlewareFunc", "makes", "RecoverMiddleware", "implement", "the", "Middleware", "interface", "."], "sha": "ebb33769ae013bd5f518a8bac348c310dea768b8", "url": "https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/recover.go#L29-L59", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "emulation/emulation.go", "func_name": "WithLatitude", "original_string": "func (p SetGeolocationOverrideParams) WithLatitude(latitude float64) *SetGeolocationOverrideParams {\n\tp.Latitude = latitude\n\treturn &p\n}", "language": "go", "code": "func (p SetGeolocationOverrideParams) WithLatitude(latitude float64) *SetGeolocationOverrideParams {\n\tp.Latitude = latitude\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "SetGeolocationOverrideParams", ")", "WithLatitude", "(", "latitude", "float64", ")", "*", "SetGeolocationOverrideParams", "{", "p", ".", "Latitude", "=", "latitude", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithLatitude mock latitude.", "docstring_tokens": ["WithLatitude", "mock", "latitude", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/emulation/emulation.go#L388-L391", "partition": "test"}
{"repo": "mrd0ll4r/tbotapi", "path": "examples/boilerplate/boilerplate.go", "func_name": "RunBotOnWebhook", "original_string": "func RunBotOnWebhook(apiKey string, bot BotFunc, name, description, webhookHost string, webhookPort uint16, pubkey, privkey string) {\n\tclosing := make(chan struct{})\n\n\tfmt.Printf(\"%s: %s\\n\", name, description)\n\tfmt.Println(\"Starting...\")\n\tu := url.URL{\n\t\tHost:   webhookHost + \":\" + fmt.Sprint(webhookPort),\n\t\tScheme: \"https\",\n\t\tPath:   apiKey,\n\t}\n\n\tapi, handler, err := tbotapi.NewWithWebhook(apiKey, u.String(), pubkey)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Just to show its working.\n\tfmt.Printf(\"User ID: %d\\n\", api.ID)\n\tfmt.Printf(\"Bot Name: %s\\n\", api.Name)\n\tfmt.Printf(\"Bot Username: %s\\n\", api.Username)\n\n\tclosed := make(chan struct{})\n\twg := &sync.WaitGroup{}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-closed:\n\t\t\t\treturn\n\t\t\tcase update := <-api.Updates:\n\t\t\t\tif update.Error() != nil {\n\t\t\t\t\t// TODO handle this properly\n\t\t\t\t\tfmt.Printf(\"Update error: %s\\n\", update.Error())\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tbot(update.Update(), api)\n\t\t\t}\n\t\t}\n\t}()\n\n\thttp.HandleFunc(\"/\"+apiKey, handler)\n\n\tfmt.Println(\"Starting webhook...\")\n\tgo func() {\n\t\tlog.Fatal(http.ListenAndServeTLS(\"0.0.0.0:\"+fmt.Sprint(webhookPort), pubkey, privkey, nil))\n\t}()\n\n\t// Ensure a clean shutdown.\n\tshutdown := make(chan os.Signal)\n\tsignal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-shutdown\n\t\tclose(closing)\n\t}()\n\n\tfmt.Println(\"Bot started. Press CTRL-C to close...\")\n\n\t// Wait for the signal.\n\t<-closing\n\tfmt.Println(\"Closing...\")\n\n\t// Always close the API first.\n\tapi.Close()\n\tclose(closed)\n\twg.Wait()\n}", "language": "go", "code": "func RunBotOnWebhook(apiKey string, bot BotFunc, name, description, webhookHost string, webhookPort uint16, pubkey, privkey string) {\n\tclosing := make(chan struct{})\n\n\tfmt.Printf(\"%s: %s\\n\", name, description)\n\tfmt.Println(\"Starting...\")\n\tu := url.URL{\n\t\tHost:   webhookHost + \":\" + fmt.Sprint(webhookPort),\n\t\tScheme: \"https\",\n\t\tPath:   apiKey,\n\t}\n\n\tapi, handler, err := tbotapi.NewWithWebhook(apiKey, u.String(), pubkey)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Just to show its working.\n\tfmt.Printf(\"User ID: %d\\n\", api.ID)\n\tfmt.Printf(\"Bot Name: %s\\n\", api.Name)\n\tfmt.Printf(\"Bot Username: %s\\n\", api.Username)\n\n\tclosed := make(chan struct{})\n\twg := &sync.WaitGroup{}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-closed:\n\t\t\t\treturn\n\t\t\tcase update := <-api.Updates:\n\t\t\t\tif update.Error() != nil {\n\t\t\t\t\t// TODO handle this properly\n\t\t\t\t\tfmt.Printf(\"Update error: %s\\n\", update.Error())\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tbot(update.Update(), api)\n\t\t\t}\n\t\t}\n\t}()\n\n\thttp.HandleFunc(\"/\"+apiKey, handler)\n\n\tfmt.Println(\"Starting webhook...\")\n\tgo func() {\n\t\tlog.Fatal(http.ListenAndServeTLS(\"0.0.0.0:\"+fmt.Sprint(webhookPort), pubkey, privkey, nil))\n\t}()\n\n\t// Ensure a clean shutdown.\n\tshutdown := make(chan os.Signal)\n\tsignal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-shutdown\n\t\tclose(closing)\n\t}()\n\n\tfmt.Println(\"Bot started. Press CTRL-C to close...\")\n\n\t// Wait for the signal.\n\t<-closing\n\tfmt.Println(\"Closing...\")\n\n\t// Always close the API first.\n\tapi.Close()\n\tclose(closed)\n\twg.Wait()\n}", "code_tokens": ["func", "RunBotOnWebhook", "(", "apiKey", "string", ",", "bot", "BotFunc", ",", "name", ",", "description", ",", "webhookHost", "string", ",", "webhookPort", "uint16", ",", "pubkey", ",", "privkey", "string", ")", "{", "closing", ":=", "make", "(", "chan", "struct", "{", "}", ")", "\n\n", "fmt", ".", "Printf", "(", "\"", "\\n", "\"", ",", "name", ",", "description", ")", "\n", "fmt", ".", "Println", "(", "\"", "\"", ")", "\n", "u", ":=", "url", ".", "URL", "{", "Host", ":", "webhookHost", "+", "\"", "\"", "+", "fmt", ".", "Sprint", "(", "webhookPort", ")", ",", "Scheme", ":", "\"", "\"", ",", "Path", ":", "apiKey", ",", "}", "\n\n", "api", ",", "handler", ",", "err", ":=", "tbotapi", ".", "NewWithWebhook", "(", "apiKey", ",", "u", ".", "String", "(", ")", ",", "pubkey", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Fatal", "(", "err", ")", "\n", "}", "\n\n", "// Just to show its working.", "fmt", ".", "Printf", "(", "\"", "\\n", "\"", ",", "api", ".", "ID", ")", "\n", "fmt", ".", "Printf", "(", "\"", "\\n", "\"", ",", "api", ".", "Name", ")", "\n", "fmt", ".", "Printf", "(", "\"", "\\n", "\"", ",", "api", ".", "Username", ")", "\n\n", "closed", ":=", "make", "(", "chan", "struct", "{", "}", ")", "\n", "wg", ":=", "&", "sync", ".", "WaitGroup", "{", "}", "\n\n", "wg", ".", "Add", "(", "1", ")", "\n", "go", "func", "(", ")", "{", "defer", "wg", ".", "Done", "(", ")", "\n", "for", "{", "select", "{", "case", "<-", "closed", ":", "return", "\n", "case", "update", ":=", "<-", "api", ".", "Updates", ":", "if", "update", ".", "Error", "(", ")", "!=", "nil", "{", "// TODO handle this properly", "fmt", ".", "Printf", "(", "\"", "\\n", "\"", ",", "update", ".", "Error", "(", ")", ")", "\n", "continue", "\n", "}", "\n\n", "bot", "(", "update", ".", "Update", "(", ")", ",", "api", ")", "\n", "}", "\n", "}", "\n", "}", "(", ")", "\n\n", "http", ".", "HandleFunc", "(", "\"", "\"", "+", "apiKey", ",", "handler", ")", "\n\n", "fmt", ".", "Println", "(", "\"", "\"", ")", "\n", "go", "func", "(", ")", "{", "log", ".", "Fatal", "(", "http", ".", "ListenAndServeTLS", "(", "\"", "\"", "+", "fmt", ".", "Sprint", "(", "webhookPort", ")", ",", "pubkey", ",", "privkey", ",", "nil", ")", ")", "\n", "}", "(", ")", "\n\n", "// Ensure a clean shutdown.", "shutdown", ":=", "make", "(", "chan", "os", ".", "Signal", ")", "\n", "signal", ".", "Notify", "(", "shutdown", ",", "syscall", ".", "SIGINT", ",", "syscall", ".", "SIGTERM", ")", "\n\n", "go", "func", "(", ")", "{", "<-", "shutdown", "\n", "close", "(", "closing", ")", "\n", "}", "(", ")", "\n\n", "fmt", ".", "Println", "(", "\"", "\"", ")", "\n\n", "// Wait for the signal.", "<-", "closing", "\n", "fmt", ".", "Println", "(", "\"", "\"", ")", "\n\n", "// Always close the API first.", "api", ".", "Close", "(", ")", "\n", "close", "(", "closed", ")", "\n", "wg", ".", "Wait", "(", ")", "\n", "}"], "docstring": "// RunBotOnWebhook runs the given BotFunc with a webhook.", "docstring_tokens": ["RunBotOnWebhook", "runs", "the", "given", "BotFunc", "with", "a", "webhook", "."], "sha": "edc257282178bb5cebbfcc41260ec04c1ec7ac19", "url": "https://github.com/mrd0ll4r/tbotapi/blob/edc257282178bb5cebbfcc41260ec04c1ec7ac19/examples/boilerplate/boilerplate.go#L86-L155", "partition": "test"}
{"repo": "hashicorp/raft", "path": "fuzzy/apply_src.go", "func_name": "reset", "original_string": "func (a *applySource) reset() {\n\ta.rnd = rand.New(rand.NewSource(a.seed))\n}", "language": "go", "code": "func (a *applySource) reset() {\n\ta.rnd = rand.New(rand.NewSource(a.seed))\n}", "code_tokens": ["func", "(", "a", "*", "applySource", ")", "reset", "(", ")", "{", "a", ".", "rnd", "=", "rand", ".", "New", "(", "rand", ".", "NewSource", "(", "a", ".", "seed", ")", ")", "\n", "}"], "docstring": "// reset this source back to its initial state, it'll generate the same sequence of data it initially did", "docstring_tokens": ["reset", "this", "source", "back", "to", "its", "initial", "state", "it", "ll", "generate", "the", "same", "sequence", "of", "data", "it", "initially", "did"], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/fuzzy/apply_src.go#L25-L27", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pfs/pfs.go", "func_name": "IsFileNotFoundErr", "original_string": "func IsFileNotFoundErr(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\treturn fileNotFoundRe.MatchString(err.Error())\n}", "language": "go", "code": "func IsFileNotFoundErr(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\treturn fileNotFoundRe.MatchString(err.Error())\n}", "code_tokens": ["func", "IsFileNotFoundErr", "(", "err", "error", ")", "bool", "{", "if", "err", "==", "nil", "{", "return", "false", "\n", "}", "\n", "return", "fileNotFoundRe", ".", "MatchString", "(", "err", ".", "Error", "(", ")", ")", "\n", "}"], "docstring": "// IsFileNotFoundErr returns true if 'err' is an error message about a PFS\n// file not being found", "docstring_tokens": ["IsFileNotFoundErr", "returns", "true", "if", "err", "is", "an", "error", "message", "about", "a", "PFS", "file", "not", "being", "found"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pfs/pfs.go#L157-L162", "partition": "test"}
{"repo": "rightscale/rsc", "path": "cm15/codegen_client.go", "func_name": "VolumeSnapshotLocator", "original_string": "func (api *API) VolumeSnapshotLocator(href string) *VolumeSnapshotLocator {\n\treturn &VolumeSnapshotLocator{Href(href), api}\n}", "language": "go", "code": "func (api *API) VolumeSnapshotLocator(href string) *VolumeSnapshotLocator {\n\treturn &VolumeSnapshotLocator{Href(href), api}\n}", "code_tokens": ["func", "(", "api", "*", "API", ")", "VolumeSnapshotLocator", "(", "href", "string", ")", "*", "VolumeSnapshotLocator", "{", "return", "&", "VolumeSnapshotLocator", "{", "Href", "(", "href", ")", ",", "api", "}", "\n", "}"], "docstring": "// VolumeSnapshotLocator builds a locator from the given href.", "docstring_tokens": ["VolumeSnapshotLocator", "builds", "a", "locator", "from", "the", "given", "href", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L14776-L14778", "partition": "test"}
{"repo": "mgutz/str", "path": "funcsAO.go", "func_name": "Humanize", "original_string": "func Humanize(s string) string {\n\tif s == \"\" {\n\t\treturn s\n\t}\n\ts = Underscore(s)\n\tvar humanizeRe = regexp.MustCompile(`_id$`)\n\ts = humanizeRe.ReplaceAllString(s, \"\")\n\ts = strings.Replace(s, \"_\", \" \", -1)\n\ts = strings.TrimSpace(s)\n\ts = Capitalize(s)\n\treturn s\n}", "language": "go", "code": "func Humanize(s string) string {\n\tif s == \"\" {\n\t\treturn s\n\t}\n\ts = Underscore(s)\n\tvar humanizeRe = regexp.MustCompile(`_id$`)\n\ts = humanizeRe.ReplaceAllString(s, \"\")\n\ts = strings.Replace(s, \"_\", \" \", -1)\n\ts = strings.TrimSpace(s)\n\ts = Capitalize(s)\n\treturn s\n}", "code_tokens": ["func", "Humanize", "(", "s", "string", ")", "string", "{", "if", "s", "==", "\"", "\"", "{", "return", "s", "\n", "}", "\n", "s", "=", "Underscore", "(", "s", ")", "\n", "var", "humanizeRe", "=", "regexp", ".", "MustCompile", "(", "`_id$`", ")", "\n", "s", "=", "humanizeRe", ".", "ReplaceAllString", "(", "s", ",", "\"", "\"", ")", "\n", "s", "=", "strings", ".", "Replace", "(", "s", ",", "\"", "\"", ",", "\"", "\"", ",", "-", "1", ")", "\n", "s", "=", "strings", ".", "TrimSpace", "(", "s", ")", "\n", "s", "=", "Capitalize", "(", "s", ")", "\n", "return", "s", "\n", "}"], "docstring": "// Humanize transforms s into a human friendly form.", "docstring_tokens": ["Humanize", "transforms", "s", "into", "a", "human", "friendly", "form", "."], "sha": "968bf66e3da857419e4f6e71b2d5c9ae95682dc4", "url": "https://github.com/mgutz/str/blob/968bf66e3da857419e4f6e71b2d5c9ae95682dc4/funcsAO.go#L213-L224", "partition": "test"}
{"repo": "golang/debug", "path": "internal/gocore/region.go", "func_name": "Int", "original_string": "func (r region) Int() int64 {\n\tif r.typ.Kind != KindInt || r.typ.Size != r.p.proc.PtrSize() {\n\t\tpanic(\"not an int: \" + r.typ.Name)\n\t}\n\treturn r.p.proc.ReadInt(r.a)\n}", "language": "go", "code": "func (r region) Int() int64 {\n\tif r.typ.Kind != KindInt || r.typ.Size != r.p.proc.PtrSize() {\n\t\tpanic(\"not an int: \" + r.typ.Name)\n\t}\n\treturn r.p.proc.ReadInt(r.a)\n}", "code_tokens": ["func", "(", "r", "region", ")", "Int", "(", ")", "int64", "{", "if", "r", ".", "typ", ".", "Kind", "!=", "KindInt", "||", "r", ".", "typ", ".", "Size", "!=", "r", ".", "p", ".", "proc", ".", "PtrSize", "(", ")", "{", "panic", "(", "\"", "\"", "+", "r", ".", "typ", ".", "Name", ")", "\n", "}", "\n", "return", "r", ".", "p", ".", "proc", ".", "ReadInt", "(", "r", ".", "a", ")", "\n", "}"], "docstring": "// Int returns the int value stored in r.", "docstring_tokens": ["Int", "returns", "the", "int", "value", "stored", "in", "r", "."], "sha": "19561fee47cf8cd0400d1b094c5898002f97cf90", "url": "https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/gocore/region.go#L28-L33", "partition": "test"}
{"repo": "rightscale/rsc", "path": "gen/api15gen/param_analyzer.go", "func_name": "parseParam", "original_string": "func (p *ParamAnalyzer) parseParam(path string, param map[string]interface{}, child *gen.ActionParam) *gen.ActionParam {\n\tdType := p.parseDataType(path, child)\n\treturn p.newParam(path, param, dType)\n}", "language": "go", "code": "func (p *ParamAnalyzer) parseParam(path string, param map[string]interface{}, child *gen.ActionParam) *gen.ActionParam {\n\tdType := p.parseDataType(path, child)\n\treturn p.newParam(path, param, dType)\n}", "code_tokens": ["func", "(", "p", "*", "ParamAnalyzer", ")", "parseParam", "(", "path", "string", ",", "param", "map", "[", "string", "]", "interface", "{", "}", ",", "child", "*", "gen", ".", "ActionParam", ")", "*", "gen", ".", "ActionParam", "{", "dType", ":=", "p", ".", "parseDataType", "(", "path", ",", "child", ")", "\n", "return", "p", ".", "newParam", "(", "path", ",", "param", ",", "dType", ")", "\n", "}"], "docstring": "// Build action param struct from json data", "docstring_tokens": ["Build", "action", "param", "struct", "from", "json", "data"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/api15gen/param_analyzer.go#L295-L298", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/cmd/branchprotector/request.go", "func_name": "makeReviews", "original_string": "func makeReviews(rp *branchprotection.ReviewPolicy) *github.RequiredPullRequestReviews {\n\tswitch {\n\tcase rp == nil:\n\t\treturn nil\n\tcase rp.Approvals == nil:\n\t\tlogrus.Warn(\"WARNING: required_pull_request_reviews policy does not specify required_approving_review_count, disabling\")\n\t\treturn nil\n\tcase *rp.Approvals == 0:\n\t\treturn nil\n\t}\n\trprr := github.RequiredPullRequestReviews{\n\t\tDismissStaleReviews:          makeBool(rp.DismissStale),\n\t\tRequireCodeOwnerReviews:      makeBool(rp.RequireOwners),\n\t\tRequiredApprovingReviewCount: *rp.Approvals,\n\t}\n\tif rp.DismissalRestrictions != nil {\n\t\trprr.DismissalRestrictions = *makeRestrictions(rp.DismissalRestrictions)\n\t}\n\treturn &rprr\n}", "language": "go", "code": "func makeReviews(rp *branchprotection.ReviewPolicy) *github.RequiredPullRequestReviews {\n\tswitch {\n\tcase rp == nil:\n\t\treturn nil\n\tcase rp.Approvals == nil:\n\t\tlogrus.Warn(\"WARNING: required_pull_request_reviews policy does not specify required_approving_review_count, disabling\")\n\t\treturn nil\n\tcase *rp.Approvals == 0:\n\t\treturn nil\n\t}\n\trprr := github.RequiredPullRequestReviews{\n\t\tDismissStaleReviews:          makeBool(rp.DismissStale),\n\t\tRequireCodeOwnerReviews:      makeBool(rp.RequireOwners),\n\t\tRequiredApprovingReviewCount: *rp.Approvals,\n\t}\n\tif rp.DismissalRestrictions != nil {\n\t\trprr.DismissalRestrictions = *makeRestrictions(rp.DismissalRestrictions)\n\t}\n\treturn &rprr\n}", "code_tokens": ["func", "makeReviews", "(", "rp", "*", "branchprotection", ".", "ReviewPolicy", ")", "*", "github", ".", "RequiredPullRequestReviews", "{", "switch", "{", "case", "rp", "==", "nil", ":", "return", "nil", "\n", "case", "rp", ".", "Approvals", "==", "nil", ":", "logrus", ".", "Warn", "(", "\"", "\"", ")", "\n", "return", "nil", "\n", "case", "*", "rp", ".", "Approvals", "==", "0", ":", "return", "nil", "\n", "}", "\n", "rprr", ":=", "github", ".", "RequiredPullRequestReviews", "{", "DismissStaleReviews", ":", "makeBool", "(", "rp", ".", "DismissStale", ")", ",", "RequireCodeOwnerReviews", ":", "makeBool", "(", "rp", ".", "RequireOwners", ")", ",", "RequiredApprovingReviewCount", ":", "*", "rp", ".", "Approvals", ",", "}", "\n", "if", "rp", ".", "DismissalRestrictions", "!=", "nil", "{", "rprr", ".", "DismissalRestrictions", "=", "*", "makeRestrictions", "(", "rp", ".", "DismissalRestrictions", ")", "\n", "}", "\n", "return", "&", "rprr", "\n", "}"], "docstring": "// makeReviews renders review policy into the corresponding GitHub api object.\n//\n// Returns nil if the policy is nil, or approvals is nil or 0.", "docstring_tokens": ["makeReviews", "renders", "review", "policy", "into", "the", "corresponding", "GitHub", "api", "object", ".", "Returns", "nil", "if", "the", "policy", "is", "nil", "or", "approvals", "is", "nil", "or", "0", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/cmd/branchprotector/request.go#L84-L103", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "config/jobs/kubernetes-security/genjobs.go", "func_name": "undoPreset", "original_string": "func undoPreset(preset *config.Preset, labels map[string]string, pod *coreapi.PodSpec) {\n\t// skip presets that do not match the job labels\n\tfor l, v := range preset.Labels {\n\t\tif v2, ok := labels[l]; !ok || v2 != v {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// collect up preset created keys\n\tremoveEnvNames := sets.NewString()\n\tfor _, e1 := range preset.Env {\n\t\tremoveEnvNames.Insert(e1.Name)\n\t}\n\tremoveVolumeNames := sets.NewString()\n\tfor _, volume := range preset.Volumes {\n\t\tremoveVolumeNames.Insert(volume.Name)\n\t}\n\tremoveVolumeMountNames := sets.NewString()\n\tfor _, volumeMount := range preset.VolumeMounts {\n\t\tremoveVolumeMountNames.Insert(volumeMount.Name)\n\t}\n\n\t// remove volumes from spec\n\tfilteredVolumes := []coreapi.Volume{}\n\tfor _, volume := range pod.Volumes {\n\t\tif !removeVolumeNames.Has(volume.Name) {\n\t\t\tfilteredVolumes = append(filteredVolumes, volume)\n\t\t}\n\t}\n\tpod.Volumes = filteredVolumes\n\n\t// remove env and volume mounts from containers\n\tfor i := range pod.Containers {\n\t\tfilteredEnv := []coreapi.EnvVar{}\n\t\tfor _, env := range pod.Containers[i].Env {\n\t\t\tif !removeEnvNames.Has(env.Name) {\n\t\t\t\tfilteredEnv = append(filteredEnv, env)\n\t\t\t}\n\t\t}\n\t\tpod.Containers[i].Env = filteredEnv\n\n\t\tfilteredVolumeMounts := []coreapi.VolumeMount{}\n\t\tfor _, mount := range pod.Containers[i].VolumeMounts {\n\t\t\tif !removeVolumeMountNames.Has(mount.Name) {\n\t\t\t\tfilteredVolumeMounts = append(filteredVolumeMounts, mount)\n\t\t\t}\n\t\t}\n\t\tpod.Containers[i].VolumeMounts = filteredVolumeMounts\n\t}\n}", "language": "go", "code": "func undoPreset(preset *config.Preset, labels map[string]string, pod *coreapi.PodSpec) {\n\t// skip presets that do not match the job labels\n\tfor l, v := range preset.Labels {\n\t\tif v2, ok := labels[l]; !ok || v2 != v {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// collect up preset created keys\n\tremoveEnvNames := sets.NewString()\n\tfor _, e1 := range preset.Env {\n\t\tremoveEnvNames.Insert(e1.Name)\n\t}\n\tremoveVolumeNames := sets.NewString()\n\tfor _, volume := range preset.Volumes {\n\t\tremoveVolumeNames.Insert(volume.Name)\n\t}\n\tremoveVolumeMountNames := sets.NewString()\n\tfor _, volumeMount := range preset.VolumeMounts {\n\t\tremoveVolumeMountNames.Insert(volumeMount.Name)\n\t}\n\n\t// remove volumes from spec\n\tfilteredVolumes := []coreapi.Volume{}\n\tfor _, volume := range pod.Volumes {\n\t\tif !removeVolumeNames.Has(volume.Name) {\n\t\t\tfilteredVolumes = append(filteredVolumes, volume)\n\t\t}\n\t}\n\tpod.Volumes = filteredVolumes\n\n\t// remove env and volume mounts from containers\n\tfor i := range pod.Containers {\n\t\tfilteredEnv := []coreapi.EnvVar{}\n\t\tfor _, env := range pod.Containers[i].Env {\n\t\t\tif !removeEnvNames.Has(env.Name) {\n\t\t\t\tfilteredEnv = append(filteredEnv, env)\n\t\t\t}\n\t\t}\n\t\tpod.Containers[i].Env = filteredEnv\n\n\t\tfilteredVolumeMounts := []coreapi.VolumeMount{}\n\t\tfor _, mount := range pod.Containers[i].VolumeMounts {\n\t\t\tif !removeVolumeMountNames.Has(mount.Name) {\n\t\t\t\tfilteredVolumeMounts = append(filteredVolumeMounts, mount)\n\t\t\t}\n\t\t}\n\t\tpod.Containers[i].VolumeMounts = filteredVolumeMounts\n\t}\n}", "code_tokens": ["func", "undoPreset", "(", "preset", "*", "config", ".", "Preset", ",", "labels", "map", "[", "string", "]", "string", ",", "pod", "*", "coreapi", ".", "PodSpec", ")", "{", "// skip presets that do not match the job labels", "for", "l", ",", "v", ":=", "range", "preset", ".", "Labels", "{", "if", "v2", ",", "ok", ":=", "labels", "[", "l", "]", ";", "!", "ok", "||", "v2", "!=", "v", "{", "return", "\n", "}", "\n", "}", "\n\n", "// collect up preset created keys", "removeEnvNames", ":=", "sets", ".", "NewString", "(", ")", "\n", "for", "_", ",", "e1", ":=", "range", "preset", ".", "Env", "{", "removeEnvNames", ".", "Insert", "(", "e1", ".", "Name", ")", "\n", "}", "\n", "removeVolumeNames", ":=", "sets", ".", "NewString", "(", ")", "\n", "for", "_", ",", "volume", ":=", "range", "preset", ".", "Volumes", "{", "removeVolumeNames", ".", "Insert", "(", "volume", ".", "Name", ")", "\n", "}", "\n", "removeVolumeMountNames", ":=", "sets", ".", "NewString", "(", ")", "\n", "for", "_", ",", "volumeMount", ":=", "range", "preset", ".", "VolumeMounts", "{", "removeVolumeMountNames", ".", "Insert", "(", "volumeMount", ".", "Name", ")", "\n", "}", "\n\n", "// remove volumes from spec", "filteredVolumes", ":=", "[", "]", "coreapi", ".", "Volume", "{", "}", "\n", "for", "_", ",", "volume", ":=", "range", "pod", ".", "Volumes", "{", "if", "!", "removeVolumeNames", ".", "Has", "(", "volume", ".", "Name", ")", "{", "filteredVolumes", "=", "append", "(", "filteredVolumes", ",", "volume", ")", "\n", "}", "\n", "}", "\n", "pod", ".", "Volumes", "=", "filteredVolumes", "\n\n", "// remove env and volume mounts from containers", "for", "i", ":=", "range", "pod", ".", "Containers", "{", "filteredEnv", ":=", "[", "]", "coreapi", ".", "EnvVar", "{", "}", "\n", "for", "_", ",", "env", ":=", "range", "pod", ".", "Containers", "[", "i", "]", ".", "Env", "{", "if", "!", "removeEnvNames", ".", "Has", "(", "env", ".", "Name", ")", "{", "filteredEnv", "=", "append", "(", "filteredEnv", ",", "env", ")", "\n", "}", "\n", "}", "\n", "pod", ".", "Containers", "[", "i", "]", ".", "Env", "=", "filteredEnv", "\n\n", "filteredVolumeMounts", ":=", "[", "]", "coreapi", ".", "VolumeMount", "{", "}", "\n", "for", "_", ",", "mount", ":=", "range", "pod", ".", "Containers", "[", "i", "]", ".", "VolumeMounts", "{", "if", "!", "removeVolumeMountNames", ".", "Has", "(", "mount", ".", "Name", ")", "{", "filteredVolumeMounts", "=", "append", "(", "filteredVolumeMounts", ",", "mount", ")", "\n", "}", "\n", "}", "\n", "pod", ".", "Containers", "[", "i", "]", ".", "VolumeMounts", "=", "filteredVolumeMounts", "\n", "}", "\n", "}"], "docstring": "// remove merged presets from a podspec", "docstring_tokens": ["remove", "merged", "presets", "from", "a", "podspec"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/config/jobs/kubernetes-security/genjobs.go#L55-L104", "partition": "test"}
{"repo": "iron-io/functions_go", "path": "client/routes/patch_apps_app_routes_route_parameters.go", "func_name": "WithTimeout", "original_string": "func (o *PatchAppsAppRoutesRouteParams) WithTimeout(timeout time.Duration) *PatchAppsAppRoutesRouteParams {\n\to.SetTimeout(timeout)\n\treturn o\n}", "language": "go", "code": "func (o *PatchAppsAppRoutesRouteParams) WithTimeout(timeout time.Duration) *PatchAppsAppRoutesRouteParams {\n\to.SetTimeout(timeout)\n\treturn o\n}", "code_tokens": ["func", "(", "o", "*", "PatchAppsAppRoutesRouteParams", ")", "WithTimeout", "(", "timeout", "time", ".", "Duration", ")", "*", "PatchAppsAppRoutesRouteParams", "{", "o", ".", "SetTimeout", "(", "timeout", ")", "\n", "return", "o", "\n", "}"], "docstring": "// WithTimeout adds the timeout to the patch apps app routes route params", "docstring_tokens": ["WithTimeout", "adds", "the", "timeout", "to", "the", "patch", "apps", "app", "routes", "route", "params"], "sha": "91b84f5bbb17095bf1c7028ec6e70a3dc06a5893", "url": "https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/routes/patch_apps_app_routes_route_parameters.go#L89-L92", "partition": "test"}
{"repo": "rightscale/rsc", "path": "command_line.go", "func_name": "validateCommandLine", "original_string": "func validateCommandLine(cmdLine *cmd.CommandLine) {\n\tif cmdLine.Command == \"setup\" ||\n\t\tcmdLine.Command == \"actions\" ||\n\t\tcmdLine.Command == \"json\" ||\n\t\tcmdLine.ShowHelp ||\n\t\tcmdLine.RL10 {\n\t\treturn\n\t}\n\tif cmdLine.Account == 0 && cmdLine.OAuthToken == \"\" && cmdLine.OAuthAccessToken == \"\" && cmdLine.APIToken == \"\" && !cmdLine.NoAuth {\n\t\tkingpin.Fatalf(\"missing --account option\")\n\t}\n\tif cmdLine.Host == \"\" {\n\t\tkingpin.Fatalf(\"missing --host option\")\n\t}\n\tif cmdLine.Password == \"\" && cmdLine.OAuthToken == \"\" && cmdLine.OAuthAccessToken == \"\" && cmdLine.APIToken == \"\" && !cmdLine.NoAuth {\n\t\tkingpin.Fatalf(\"missing login info, use --email and --pwd or use --key, --apiToken or --rl10\")\n\t}\n}", "language": "go", "code": "func validateCommandLine(cmdLine *cmd.CommandLine) {\n\tif cmdLine.Command == \"setup\" ||\n\t\tcmdLine.Command == \"actions\" ||\n\t\tcmdLine.Command == \"json\" ||\n\t\tcmdLine.ShowHelp ||\n\t\tcmdLine.RL10 {\n\t\treturn\n\t}\n\tif cmdLine.Account == 0 && cmdLine.OAuthToken == \"\" && cmdLine.OAuthAccessToken == \"\" && cmdLine.APIToken == \"\" && !cmdLine.NoAuth {\n\t\tkingpin.Fatalf(\"missing --account option\")\n\t}\n\tif cmdLine.Host == \"\" {\n\t\tkingpin.Fatalf(\"missing --host option\")\n\t}\n\tif cmdLine.Password == \"\" && cmdLine.OAuthToken == \"\" && cmdLine.OAuthAccessToken == \"\" && cmdLine.APIToken == \"\" && !cmdLine.NoAuth {\n\t\tkingpin.Fatalf(\"missing login info, use --email and --pwd or use --key, --apiToken or --rl10\")\n\t}\n}", "code_tokens": ["func", "validateCommandLine", "(", "cmdLine", "*", "cmd", ".", "CommandLine", ")", "{", "if", "cmdLine", ".", "Command", "==", "\"", "\"", "||", "cmdLine", ".", "Command", "==", "\"", "\"", "||", "cmdLine", ".", "Command", "==", "\"", "\"", "||", "cmdLine", ".", "ShowHelp", "||", "cmdLine", ".", "RL10", "{", "return", "\n", "}", "\n", "if", "cmdLine", ".", "Account", "==", "0", "&&", "cmdLine", ".", "OAuthToken", "==", "\"", "\"", "&&", "cmdLine", ".", "OAuthAccessToken", "==", "\"", "\"", "&&", "cmdLine", ".", "APIToken", "==", "\"", "\"", "&&", "!", "cmdLine", ".", "NoAuth", "{", "kingpin", ".", "Fatalf", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "cmdLine", ".", "Host", "==", "\"", "\"", "{", "kingpin", ".", "Fatalf", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "cmdLine", ".", "Password", "==", "\"", "\"", "&&", "cmdLine", ".", "OAuthToken", "==", "\"", "\"", "&&", "cmdLine", ".", "OAuthAccessToken", "==", "\"", "\"", "&&", "cmdLine", ".", "APIToken", "==", "\"", "\"", "&&", "!", "cmdLine", ".", "NoAuth", "{", "kingpin", ".", "Fatalf", "(", "\"", "\"", ")", "\n", "}", "\n", "}"], "docstring": "// Make sure all the required information is there", "docstring_tokens": ["Make", "sure", "all", "the", "required", "information", "is", "there"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/command_line.go#L112-L129", "partition": "test"}
{"repo": "blacksails/cgp", "path": "forwarder.go", "func_name": "Forwarders", "original_string": "func (dom *Domain) Forwarders() ([]*Forwarder, error) {\n\tvar vl valueList\n\terr := dom.cgp.request(listForwarders{Param: dom.Name}, &vl)\n\tif err != nil {\n\t\treturn []*Forwarder{}, err\n\t}\n\tvals := vl.compact()\n\tfs := make([]*Forwarder, len(vals))\n\tfor i, v := range vals {\n\t\tf, err := dom.GetForwarder(v)\n\t\tif err != nil {\n\t\t\treturn fs, err\n\t\t}\n\t\tfs[i] = f\n\t}\n\treturn fs, err\n}", "language": "go", "code": "func (dom *Domain) Forwarders() ([]*Forwarder, error) {\n\tvar vl valueList\n\terr := dom.cgp.request(listForwarders{Param: dom.Name}, &vl)\n\tif err != nil {\n\t\treturn []*Forwarder{}, err\n\t}\n\tvals := vl.compact()\n\tfs := make([]*Forwarder, len(vals))\n\tfor i, v := range vals {\n\t\tf, err := dom.GetForwarder(v)\n\t\tif err != nil {\n\t\t\treturn fs, err\n\t\t}\n\t\tfs[i] = f\n\t}\n\treturn fs, err\n}", "code_tokens": ["func", "(", "dom", "*", "Domain", ")", "Forwarders", "(", ")", "(", "[", "]", "*", "Forwarder", ",", "error", ")", "{", "var", "vl", "valueList", "\n", "err", ":=", "dom", ".", "cgp", ".", "request", "(", "listForwarders", "{", "Param", ":", "dom", ".", "Name", "}", ",", "&", "vl", ")", "\n", "if", "err", "!=", "nil", "{", "return", "[", "]", "*", "Forwarder", "{", "}", ",", "err", "\n", "}", "\n", "vals", ":=", "vl", ".", "compact", "(", ")", "\n", "fs", ":=", "make", "(", "[", "]", "*", "Forwarder", ",", "len", "(", "vals", ")", ")", "\n", "for", "i", ",", "v", ":=", "range", "vals", "{", "f", ",", "err", ":=", "dom", ".", "GetForwarder", "(", "v", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fs", ",", "err", "\n", "}", "\n", "fs", "[", "i", "]", "=", "f", "\n", "}", "\n", "return", "fs", ",", "err", "\n", "}"], "docstring": "// Forwarders lists the forwarders of a domain", "docstring_tokens": ["Forwarders", "lists", "the", "forwarders", "of", "a", "domain"], "sha": "570ac705cf2d7a9235d911d00b6f976ab3386c2f", "url": "https://github.com/blacksails/cgp/blob/570ac705cf2d7a9235d911d00b6f976ab3386c2f/forwarder.go#L31-L47", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/storage_volumes.go", "func_name": "StorageVolumeDescriptionUpdate", "original_string": "func StorageVolumeDescriptionUpdate(tx *sql.Tx, volumeID int64, description string) error {\n\t_, err := tx.Exec(\"UPDATE storage_volumes SET description=? WHERE id=?\", description, volumeID)\n\treturn err\n}", "language": "go", "code": "func StorageVolumeDescriptionUpdate(tx *sql.Tx, volumeID int64, description string) error {\n\t_, err := tx.Exec(\"UPDATE storage_volumes SET description=? WHERE id=?\", description, volumeID)\n\treturn err\n}", "code_tokens": ["func", "StorageVolumeDescriptionUpdate", "(", "tx", "*", "sql", ".", "Tx", ",", "volumeID", "int64", ",", "description", "string", ")", "error", "{", "_", ",", "err", ":=", "tx", ".", "Exec", "(", "\"", "\"", ",", "description", ",", "volumeID", ")", "\n", "return", "err", "\n", "}"], "docstring": "// StorageVolumeDescriptionUpdate updates the description of a storage volume.", "docstring_tokens": ["StorageVolumeDescriptionUpdate", "updates", "the", "description", "of", "a", "storage", "volume", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/storage_volumes.go#L253-L256", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/hook/server.go", "func_name": "needDemux", "original_string": "func (s *Server) needDemux(eventType, srcRepo string) []plugins.ExternalPlugin {\n\tvar matching []plugins.ExternalPlugin\n\tsrcOrg := strings.Split(srcRepo, \"/\")[0]\n\n\tfor repo, plugins := range s.Plugins.Config().ExternalPlugins {\n\t\t// Make sure the repositories match\n\t\tif repo != srcRepo && repo != srcOrg {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Make sure the events match\n\t\tfor _, p := range plugins {\n\t\t\tif len(p.Events) == 0 {\n\t\t\t\tmatching = append(matching, p)\n\t\t\t} else {\n\t\t\t\tfor _, et := range p.Events {\n\t\t\t\t\tif et != eventType {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tmatching = append(matching, p)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn matching\n}", "language": "go", "code": "func (s *Server) needDemux(eventType, srcRepo string) []plugins.ExternalPlugin {\n\tvar matching []plugins.ExternalPlugin\n\tsrcOrg := strings.Split(srcRepo, \"/\")[0]\n\n\tfor repo, plugins := range s.Plugins.Config().ExternalPlugins {\n\t\t// Make sure the repositories match\n\t\tif repo != srcRepo && repo != srcOrg {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Make sure the events match\n\t\tfor _, p := range plugins {\n\t\t\tif len(p.Events) == 0 {\n\t\t\t\tmatching = append(matching, p)\n\t\t\t} else {\n\t\t\t\tfor _, et := range p.Events {\n\t\t\t\t\tif et != eventType {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tmatching = append(matching, p)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn matching\n}", "code_tokens": ["func", "(", "s", "*", "Server", ")", "needDemux", "(", "eventType", ",", "srcRepo", "string", ")", "[", "]", "plugins", ".", "ExternalPlugin", "{", "var", "matching", "[", "]", "plugins", ".", "ExternalPlugin", "\n", "srcOrg", ":=", "strings", ".", "Split", "(", "srcRepo", ",", "\"", "\"", ")", "[", "0", "]", "\n\n", "for", "repo", ",", "plugins", ":=", "range", "s", ".", "Plugins", ".", "Config", "(", ")", ".", "ExternalPlugins", "{", "// Make sure the repositories match", "if", "repo", "!=", "srcRepo", "&&", "repo", "!=", "srcOrg", "{", "continue", "\n", "}", "\n\n", "// Make sure the events match", "for", "_", ",", "p", ":=", "range", "plugins", "{", "if", "len", "(", "p", ".", "Events", ")", "==", "0", "{", "matching", "=", "append", "(", "matching", ",", "p", ")", "\n", "}", "else", "{", "for", "_", ",", "et", ":=", "range", "p", ".", "Events", "{", "if", "et", "!=", "eventType", "{", "continue", "\n", "}", "\n", "matching", "=", "append", "(", "matching", ",", "p", ")", "\n", "break", "\n", "}", "\n", "}", "\n", "}", "\n", "}", "\n", "return", "matching", "\n", "}"], "docstring": "// needDemux returns whether there are any external plugins that need to\n// get the present event.", "docstring_tokens": ["needDemux", "returns", "whether", "there", "are", "any", "external", "plugins", "that", "need", "to", "get", "the", "present", "event", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/hook/server.go#L164-L190", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/osutil/interrupt_unix.go", "func_name": "RegisterInterruptHandler", "original_string": "func RegisterInterruptHandler(h InterruptHandler) {\n\tinterruptRegisterMu.Lock()\n\tdefer interruptRegisterMu.Unlock()\n\tinterruptHandlers = append(interruptHandlers, h)\n}", "language": "go", "code": "func RegisterInterruptHandler(h InterruptHandler) {\n\tinterruptRegisterMu.Lock()\n\tdefer interruptRegisterMu.Unlock()\n\tinterruptHandlers = append(interruptHandlers, h)\n}", "code_tokens": ["func", "RegisterInterruptHandler", "(", "h", "InterruptHandler", ")", "{", "interruptRegisterMu", ".", "Lock", "(", ")", "\n", "defer", "interruptRegisterMu", ".", "Unlock", "(", ")", "\n", "interruptHandlers", "=", "append", "(", "interruptHandlers", ",", "h", ")", "\n", "}"], "docstring": "// RegisterInterruptHandler registers a new InterruptHandler. Handlers registered\n// after interrupt handing was initiated will not be executed.", "docstring_tokens": ["RegisterInterruptHandler", "registers", "a", "new", "InterruptHandler", ".", "Handlers", "registered", "after", "interrupt", "handing", "was", "initiated", "will", "not", "be", "executed", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/osutil/interrupt_unix.go#L41-L45", "partition": "test"}
{"repo": "segmentio/objconv", "path": "codec.go", "func_name": "NewStreamEncoder", "original_string": "func (c Codec) NewStreamEncoder(w io.Writer) *StreamEncoder {\n\treturn NewStreamEncoder(c.NewEmitter(w))\n}", "language": "go", "code": "func (c Codec) NewStreamEncoder(w io.Writer) *StreamEncoder {\n\treturn NewStreamEncoder(c.NewEmitter(w))\n}", "code_tokens": ["func", "(", "c", "Codec", ")", "NewStreamEncoder", "(", "w", "io", ".", "Writer", ")", "*", "StreamEncoder", "{", "return", "NewStreamEncoder", "(", "c", ".", "NewEmitter", "(", "w", ")", ")", "\n", "}"], "docstring": "// NewStreamEncoder returns a new stream encoder that outputs to w.", "docstring_tokens": ["NewStreamEncoder", "returns", "a", "new", "stream", "encoder", "that", "outputs", "to", "w", "."], "sha": "7a1d7b8e6f3551b30751e6b2ea6bae500883870e", "url": "https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/codec.go#L25-L27", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/util/net.go", "func_name": "IsAddressCovered", "original_string": "func IsAddressCovered(address1, address2 string) bool {\n\tif address1 == address2 {\n\t\treturn true\n\t}\n\n\thost1, port1, err := net.SplitHostPort(address1)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\thost2, port2, err := net.SplitHostPort(address2)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// If the ports are different, then address1 is clearly not covered by\n\t// address2.\n\tif port2 != port1 {\n\t\treturn false\n\t}\n\n\t// If address2 is using an IPv4 wildcard for the host, then address2 is\n\t// only covered if it's an IPv4 address.\n\tif host2 == \"0.0.0.0\" {\n\t\tip := net.ParseIP(host1)\n\t\tif ip != nil && ip.To4() != nil {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t// If address2 is using an IPv6 wildcard for the host, then address2 is\n\t// always covered.\n\tif host2 == \"::\" || host2 == \"\" {\n\t\treturn true\n\t}\n\n\treturn false\n}", "language": "go", "code": "func IsAddressCovered(address1, address2 string) bool {\n\tif address1 == address2 {\n\t\treturn true\n\t}\n\n\thost1, port1, err := net.SplitHostPort(address1)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\thost2, port2, err := net.SplitHostPort(address2)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// If the ports are different, then address1 is clearly not covered by\n\t// address2.\n\tif port2 != port1 {\n\t\treturn false\n\t}\n\n\t// If address2 is using an IPv4 wildcard for the host, then address2 is\n\t// only covered if it's an IPv4 address.\n\tif host2 == \"0.0.0.0\" {\n\t\tip := net.ParseIP(host1)\n\t\tif ip != nil && ip.To4() != nil {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t// If address2 is using an IPv6 wildcard for the host, then address2 is\n\t// always covered.\n\tif host2 == \"::\" || host2 == \"\" {\n\t\treturn true\n\t}\n\n\treturn false\n}", "code_tokens": ["func", "IsAddressCovered", "(", "address1", ",", "address2", "string", ")", "bool", "{", "if", "address1", "==", "address2", "{", "return", "true", "\n", "}", "\n\n", "host1", ",", "port1", ",", "err", ":=", "net", ".", "SplitHostPort", "(", "address1", ")", "\n", "if", "err", "!=", "nil", "{", "return", "false", "\n", "}", "\n\n", "host2", ",", "port2", ",", "err", ":=", "net", ".", "SplitHostPort", "(", "address2", ")", "\n", "if", "err", "!=", "nil", "{", "return", "false", "\n", "}", "\n\n", "// If the ports are different, then address1 is clearly not covered by", "// address2.", "if", "port2", "!=", "port1", "{", "return", "false", "\n", "}", "\n\n", "// If address2 is using an IPv4 wildcard for the host, then address2 is", "// only covered if it's an IPv4 address.", "if", "host2", "==", "\"", "\"", "{", "ip", ":=", "net", ".", "ParseIP", "(", "host1", ")", "\n", "if", "ip", "!=", "nil", "&&", "ip", ".", "To4", "(", ")", "!=", "nil", "{", "return", "true", "\n", "}", "\n", "return", "false", "\n", "}", "\n\n", "// If address2 is using an IPv6 wildcard for the host, then address2 is", "// always covered.", "if", "host2", "==", "\"", "\"", "||", "host2", "==", "\"", "\"", "{", "return", "true", "\n", "}", "\n\n", "return", "false", "\n", "}"], "docstring": "// IsAddressCovered detects if network address1 is actually covered by\n// address2, in the sense that they are either the same address or address2 is\n// specified using a wildcard with the same port of address1.", "docstring_tokens": ["IsAddressCovered", "detects", "if", "network", "address1", "is", "actually", "covered", "by", "address2", "in", "the", "sense", "that", "they", "are", "either", "the", "same", "address", "or", "address2", "is", "specified", "using", "a", "wildcard", "with", "the", "same", "port", "of", "address1", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/util/net.go#L139-L177", "partition": "test"}
{"repo": "kokardy/listing", "path": "perm.go", "func_name": "permutations", "original_string": "func permutations(list []int, select_num, buf int) (c chan []int) {\n\tc = make(chan []int, buf)\n\tgo func() {\n\t\tdefer close(c)\n\t\tswitch select_num {\n\t\tcase 1:\n\t\t\tfor _, v := range list {\n\t\t\t\tc <- []int{v}\n\t\t\t}\n\t\t\treturn\n\t\tcase 0:\n\t\t\treturn\n\t\tcase len(list):\n\t\t\tfor i := 0; i < len(list); i++ {\n\t\t\t\ttop, sub_list := pop(list, i)\n\t\t\t\tfor perm := range permutations(sub_list, select_num-1, buf) {\n\t\t\t\t\tc <- append([]int{top}, perm...)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tfor comb := range combinations(list, select_num, buf) {\n\t\t\t\tfor perm := range permutations(comb, select_num, buf) {\n\t\t\t\t\tc <- perm\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn\n}", "language": "go", "code": "func permutations(list []int, select_num, buf int) (c chan []int) {\n\tc = make(chan []int, buf)\n\tgo func() {\n\t\tdefer close(c)\n\t\tswitch select_num {\n\t\tcase 1:\n\t\t\tfor _, v := range list {\n\t\t\t\tc <- []int{v}\n\t\t\t}\n\t\t\treturn\n\t\tcase 0:\n\t\t\treturn\n\t\tcase len(list):\n\t\t\tfor i := 0; i < len(list); i++ {\n\t\t\t\ttop, sub_list := pop(list, i)\n\t\t\t\tfor perm := range permutations(sub_list, select_num-1, buf) {\n\t\t\t\t\tc <- append([]int{top}, perm...)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tfor comb := range combinations(list, select_num, buf) {\n\t\t\t\tfor perm := range permutations(comb, select_num, buf) {\n\t\t\t\t\tc <- perm\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn\n}", "code_tokens": ["func", "permutations", "(", "list", "[", "]", "int", ",", "select_num", ",", "buf", "int", ")", "(", "c", "chan", "[", "]", "int", ")", "{", "c", "=", "make", "(", "chan", "[", "]", "int", ",", "buf", ")", "\n", "go", "func", "(", ")", "{", "defer", "close", "(", "c", ")", "\n", "switch", "select_num", "{", "case", "1", ":", "for", "_", ",", "v", ":=", "range", "list", "{", "c", "<-", "[", "]", "int", "{", "v", "}", "\n", "}", "\n", "return", "\n", "case", "0", ":", "return", "\n", "case", "len", "(", "list", ")", ":", "for", "i", ":=", "0", ";", "i", "<", "len", "(", "list", ")", ";", "i", "++", "{", "top", ",", "sub_list", ":=", "pop", "(", "list", ",", "i", ")", "\n", "for", "perm", ":=", "range", "permutations", "(", "sub_list", ",", "select_num", "-", "1", ",", "buf", ")", "{", "c", "<-", "append", "(", "[", "]", "int", "{", "top", "}", ",", "perm", "...", ")", "\n", "}", "\n", "}", "\n", "default", ":", "for", "comb", ":=", "range", "combinations", "(", "list", ",", "select_num", ",", "buf", ")", "{", "for", "perm", ":=", "range", "permutations", "(", "comb", ",", "select_num", ",", "buf", ")", "{", "c", "<-", "perm", "\n", "}", "\n", "}", "\n", "}", "\n", "}", "(", ")", "\n", "return", "\n", "}"], "docstring": "//Permtation generator for int slice", "docstring_tokens": ["Permtation", "generator", "for", "int", "slice"], "sha": "795534c33c5ab6be8b85a15951664ab11fb70ea7", "url": "https://github.com/kokardy/listing/blob/795534c33c5ab6be8b85a15951664ab11fb70ea7/perm.go#L35-L63", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "vm/ops.go", "func_name": "txPrintRaw", "original_string": "func txPrintRaw(st *State) {\n\t// XXX TODO: mark_raw handling\n\targ := st.sa\n\tif arg == nil {\n\t\tst.Warnf(\"Use of nil to print\\n\")\n\t} else {\n\t\tst.AppendOutputString(interfaceToString(arg))\n\t}\n\tst.Advance()\n}", "language": "go", "code": "func txPrintRaw(st *State) {\n\t// XXX TODO: mark_raw handling\n\targ := st.sa\n\tif arg == nil {\n\t\tst.Warnf(\"Use of nil to print\\n\")\n\t} else {\n\t\tst.AppendOutputString(interfaceToString(arg))\n\t}\n\tst.Advance()\n}", "code_tokens": ["func", "txPrintRaw", "(", "st", "*", "State", ")", "{", "// XXX TODO: mark_raw handling", "arg", ":=", "st", ".", "sa", "\n", "if", "arg", "==", "nil", "{", "st", ".", "Warnf", "(", "\"", "\\n", "\"", ")", "\n", "}", "else", "{", "st", ".", "AppendOutputString", "(", "interfaceToString", "(", "arg", ")", ")", "\n", "}", "\n", "st", ".", "Advance", "(", ")", "\n", "}"], "docstring": "// Prints the contents of register sa, forcing raw string semantics", "docstring_tokens": ["Prints", "the", "contents", "of", "register", "sa", "forcing", "raw", "string", "semantics"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/vm/ops.go#L357-L366", "partition": "test"}
{"repo": "onsi/gomega", "path": "gstruct/errors/nested_types.go", "func_name": "Nest", "original_string": "func Nest(path string, err error) error {\n\tif ag, ok := err.(AggregateError); ok {\n\t\tvar errs AggregateError\n\t\tfor _, e := range ag {\n\t\t\terrs = append(errs, Nest(path, e))\n\t\t}\n\t\treturn errs\n\t}\n\tif ne, ok := err.(*NestedError); ok {\n\t\treturn &NestedError{\n\t\t\tPath: path + ne.Path,\n\t\t\tErr:  ne.Err,\n\t\t}\n\t}\n\treturn &NestedError{\n\t\tPath: path,\n\t\tErr:  err,\n\t}\n}", "language": "go", "code": "func Nest(path string, err error) error {\n\tif ag, ok := err.(AggregateError); ok {\n\t\tvar errs AggregateError\n\t\tfor _, e := range ag {\n\t\t\terrs = append(errs, Nest(path, e))\n\t\t}\n\t\treturn errs\n\t}\n\tif ne, ok := err.(*NestedError); ok {\n\t\treturn &NestedError{\n\t\t\tPath: path + ne.Path,\n\t\t\tErr:  ne.Err,\n\t\t}\n\t}\n\treturn &NestedError{\n\t\tPath: path,\n\t\tErr:  err,\n\t}\n}", "code_tokens": ["func", "Nest", "(", "path", "string", ",", "err", "error", ")", "error", "{", "if", "ag", ",", "ok", ":=", "err", ".", "(", "AggregateError", ")", ";", "ok", "{", "var", "errs", "AggregateError", "\n", "for", "_", ",", "e", ":=", "range", "ag", "{", "errs", "=", "append", "(", "errs", ",", "Nest", "(", "path", ",", "e", ")", ")", "\n", "}", "\n", "return", "errs", "\n", "}", "\n", "if", "ne", ",", "ok", ":=", "err", ".", "(", "*", "NestedError", ")", ";", "ok", "{", "return", "&", "NestedError", "{", "Path", ":", "path", "+", "ne", ".", "Path", ",", "Err", ":", "ne", ".", "Err", ",", "}", "\n", "}", "\n", "return", "&", "NestedError", "{", "Path", ":", "path", ",", "Err", ":", "err", ",", "}", "\n", "}"], "docstring": "// Create a NestedError with the given path.\n// If err is a NestedError, prepend the path to it.\n// If err is an AggregateError, recursively Nest each error.", "docstring_tokens": ["Create", "a", "NestedError", "with", "the", "given", "path", ".", "If", "err", "is", "a", "NestedError", "prepend", "the", "path", "to", "it", ".", "If", "err", "is", "an", "AggregateError", "recursively", "Nest", "each", "error", "."], "sha": "f0e010e04c08c48a875f83d17df37b04eb3a985b", "url": "https://github.com/onsi/gomega/blob/f0e010e04c08c48a875f83d17df37b04eb3a985b/gstruct/errors/nested_types.go#L34-L52", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "dom/dom.go", "func_name": "Do", "original_string": "func (p *SetInspectedNodeParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetInspectedNode, p, nil)\n}", "language": "go", "code": "func (p *SetInspectedNodeParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetInspectedNode, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetInspectedNodeParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetInspectedNode", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes DOM.setInspectedNode against the provided context.", "docstring_tokens": ["Do", "executes", "DOM", ".", "setInspectedNode", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/dom/dom.go#L1376-L1378", "partition": "test"}
{"repo": "aphistic/gomol", "path": "log_adapter.go", "func_name": "NewLogAdapterFor", "original_string": "func NewLogAdapterFor(base WrappableLogger, attrs *Attrs) *LogAdapter {\n\tif attrs == nil {\n\t\tattrs = NewAttrs()\n\t}\n\n\treturn &LogAdapter{\n\t\tbase:  base,\n\t\tattrs: attrs,\n\t}\n}", "language": "go", "code": "func NewLogAdapterFor(base WrappableLogger, attrs *Attrs) *LogAdapter {\n\tif attrs == nil {\n\t\tattrs = NewAttrs()\n\t}\n\n\treturn &LogAdapter{\n\t\tbase:  base,\n\t\tattrs: attrs,\n\t}\n}", "code_tokens": ["func", "NewLogAdapterFor", "(", "base", "WrappableLogger", ",", "attrs", "*", "Attrs", ")", "*", "LogAdapter", "{", "if", "attrs", "==", "nil", "{", "attrs", "=", "NewAttrs", "(", ")", "\n", "}", "\n\n", "return", "&", "LogAdapter", "{", "base", ":", "base", ",", "attrs", ":", "attrs", ",", "}", "\n", "}"], "docstring": "// NewLogAdapterFor creates a LogAdapter that wraps the given loger with the\n// given attributes.", "docstring_tokens": ["NewLogAdapterFor", "creates", "a", "LogAdapter", "that", "wraps", "the", "given", "loger", "with", "the", "given", "attributes", "."], "sha": "1546845ba714699f76f484ad3af64cf0503064d1", "url": "https://github.com/aphistic/gomol/blob/1546845ba714699f76f484ad3af64cf0503064d1/log_adapter.go#L37-L46", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/hashtree/db.go", "func_name": "NewUnordered", "original_string": "func NewUnordered(root string) *Unordered {\n\treturn &Unordered{\n\t\tfs:   make(map[string]*NodeProto),\n\t\troot: clean(root),\n\t}\n}", "language": "go", "code": "func NewUnordered(root string) *Unordered {\n\treturn &Unordered{\n\t\tfs:   make(map[string]*NodeProto),\n\t\troot: clean(root),\n\t}\n}", "code_tokens": ["func", "NewUnordered", "(", "root", "string", ")", "*", "Unordered", "{", "return", "&", "Unordered", "{", "fs", ":", "make", "(", "map", "[", "string", "]", "*", "NodeProto", ")", ",", "root", ":", "clean", "(", "root", ")", ",", "}", "\n", "}"], "docstring": "// NewUnordered creates a new unordered hashtree.", "docstring_tokens": ["NewUnordered", "creates", "a", "new", "unordered", "hashtree", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/db.go#L1755-L1760", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "input/input.go", "func_name": "Do", "original_string": "func (p *SynthesizePinchGestureParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSynthesizePinchGesture, p, nil)\n}", "language": "go", "code": "func (p *SynthesizePinchGestureParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSynthesizePinchGesture, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SynthesizePinchGestureParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSynthesizePinchGesture", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Input.synthesizePinchGesture against the provided context.", "docstring_tokens": ["Do", "executes", "Input", ".", "synthesizePinchGesture", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/input/input.go#L424-L426", "partition": "test"}
{"repo": "segmentio/nsq-go", "path": "producer.go", "func_name": "Start", "original_string": "func (p *Producer) Start() {\n\tif p.started {\n\t\tpanic(\"(*Producer).Start has already been called\")\n\t}\n\n\tconcurrency := cap(p.reqs)\n\tp.join.Add(concurrency)\n\tfor i := 0; i != concurrency; i++ {\n\t\tgo p.run()\n\t}\n\n\tp.started = true\n}", "language": "go", "code": "func (p *Producer) Start() {\n\tif p.started {\n\t\tpanic(\"(*Producer).Start has already been called\")\n\t}\n\n\tconcurrency := cap(p.reqs)\n\tp.join.Add(concurrency)\n\tfor i := 0; i != concurrency; i++ {\n\t\tgo p.run()\n\t}\n\n\tp.started = true\n}", "code_tokens": ["func", "(", "p", "*", "Producer", ")", "Start", "(", ")", "{", "if", "p", ".", "started", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "concurrency", ":=", "cap", "(", "p", ".", "reqs", ")", "\n", "p", ".", "join", ".", "Add", "(", "concurrency", ")", "\n", "for", "i", ":=", "0", ";", "i", "!=", "concurrency", ";", "i", "++", "{", "go", "p", ".", "run", "(", ")", "\n", "}", "\n\n", "p", ".", "started", "=", "true", "\n", "}"], "docstring": "// Start explicitly begins the producer in case it was initialized with\n// NewProducer instead of StartProducer.", "docstring_tokens": ["Start", "explicitly", "begins", "the", "producer", "in", "case", "it", "was", "initialized", "with", "NewProducer", "instead", "of", "StartProducer", "."], "sha": "ff4eef968f46eb580d9dba4f637c5dfb1e5b2208", "url": "https://github.com/segmentio/nsq-go/blob/ff4eef968f46eb580d9dba4f637c5dfb1e5b2208/producer.go#L105-L117", "partition": "test"}
{"repo": "golang/appengine", "path": "socket/socket_classic.go", "func_name": "withDeadline", "original_string": "func withDeadline(parent context.Context, deadline time.Time) (context.Context, context.CancelFunc) {\n\tif deadline.IsZero() {\n\t\treturn parent, func() {}\n\t}\n\treturn context.WithDeadline(parent, deadline)\n}", "language": "go", "code": "func withDeadline(parent context.Context, deadline time.Time) (context.Context, context.CancelFunc) {\n\tif deadline.IsZero() {\n\t\treturn parent, func() {}\n\t}\n\treturn context.WithDeadline(parent, deadline)\n}", "code_tokens": ["func", "withDeadline", "(", "parent", "context", ".", "Context", ",", "deadline", "time", ".", "Time", ")", "(", "context", ".", "Context", ",", "context", ".", "CancelFunc", ")", "{", "if", "deadline", ".", "IsZero", "(", ")", "{", "return", "parent", ",", "func", "(", ")", "{", "}", "\n", "}", "\n", "return", "context", ".", "WithDeadline", "(", "parent", ",", "deadline", ")", "\n", "}"], "docstring": "// withDeadline is like context.WithDeadline, except it ignores the zero deadline.", "docstring_tokens": ["withDeadline", "is", "like", "context", ".", "WithDeadline", "except", "it", "ignores", "the", "zero", "deadline", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/socket/socket_classic.go#L141-L146", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "parser/symbols.go", "func_name": "Swap", "original_string": "func (s LexSymbolSorter) Swap(i, j int) {\n\ts.list[i], s.list[j] = s.list[j], s.list[i]\n}", "language": "go", "code": "func (s LexSymbolSorter) Swap(i, j int) {\n\ts.list[i], s.list[j] = s.list[j], s.list[i]\n}", "code_tokens": ["func", "(", "s", "LexSymbolSorter", ")", "Swap", "(", "i", ",", "j", "int", ")", "{", "s", ".", "list", "[", "i", "]", ",", "s", ".", "list", "[", "j", "]", "=", "s", ".", "list", "[", "j", "]", ",", "s", ".", "list", "[", "i", "]", "\n", "}"], "docstring": "// Swap swaps the elements at i and j", "docstring_tokens": ["Swap", "swaps", "the", "elements", "at", "i", "and", "j"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/parser/symbols.go#L58-L60", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "histogram.go", "func_name": "buildHistogram", "original_string": "func (db *DB) buildHistogram(keyPrefix []byte) *sizeHistogram {\n\ttxn := db.NewTransaction(false)\n\tdefer txn.Discard()\n\n\titr := txn.NewIterator(DefaultIteratorOptions)\n\tdefer itr.Close()\n\n\tbadgerHistogram := newSizeHistogram()\n\n\t// Collect key and value sizes.\n\tfor itr.Seek(keyPrefix); itr.ValidForPrefix(keyPrefix); itr.Next() {\n\t\titem := itr.Item()\n\t\tbadgerHistogram.keySizeHistogram.Update(item.KeySize())\n\t\tbadgerHistogram.valueSizeHistogram.Update(item.ValueSize())\n\t}\n\treturn badgerHistogram\n}", "language": "go", "code": "func (db *DB) buildHistogram(keyPrefix []byte) *sizeHistogram {\n\ttxn := db.NewTransaction(false)\n\tdefer txn.Discard()\n\n\titr := txn.NewIterator(DefaultIteratorOptions)\n\tdefer itr.Close()\n\n\tbadgerHistogram := newSizeHistogram()\n\n\t// Collect key and value sizes.\n\tfor itr.Seek(keyPrefix); itr.ValidForPrefix(keyPrefix); itr.Next() {\n\t\titem := itr.Item()\n\t\tbadgerHistogram.keySizeHistogram.Update(item.KeySize())\n\t\tbadgerHistogram.valueSizeHistogram.Update(item.ValueSize())\n\t}\n\treturn badgerHistogram\n}", "code_tokens": ["func", "(", "db", "*", "DB", ")", "buildHistogram", "(", "keyPrefix", "[", "]", "byte", ")", "*", "sizeHistogram", "{", "txn", ":=", "db", ".", "NewTransaction", "(", "false", ")", "\n", "defer", "txn", ".", "Discard", "(", ")", "\n\n", "itr", ":=", "txn", ".", "NewIterator", "(", "DefaultIteratorOptions", ")", "\n", "defer", "itr", ".", "Close", "(", ")", "\n\n", "badgerHistogram", ":=", "newSizeHistogram", "(", ")", "\n\n", "// Collect key and value sizes.", "for", "itr", ".", "Seek", "(", "keyPrefix", ")", ";", "itr", ".", "ValidForPrefix", "(", "keyPrefix", ")", ";", "itr", ".", "Next", "(", ")", "{", "item", ":=", "itr", ".", "Item", "(", ")", "\n", "badgerHistogram", ".", "keySizeHistogram", ".", "Update", "(", "item", ".", "KeySize", "(", ")", ")", "\n", "badgerHistogram", ".", "valueSizeHistogram", ".", "Update", "(", "item", ".", "ValueSize", "(", ")", ")", "\n", "}", "\n", "return", "badgerHistogram", "\n", "}"], "docstring": "// buildHistogram builds the key-value size histogram.\n// When keyPrefix is set, only the keys that have prefix \"keyPrefix\" are\n// considered for creating the histogram", "docstring_tokens": ["buildHistogram", "builds", "the", "key", "-", "value", "size", "histogram", ".", "When", "keyPrefix", "is", "set", "only", "the", "keys", "that", "have", "prefix", "keyPrefix", "are", "considered", "for", "creating", "the", "histogram"], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/histogram.go#L119-L135", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/endpoints/endpoints.go", "func_name": "activatedListeners", "original_string": "func activatedListeners(systemdListeners []net.Listener, cert *shared.CertInfo) map[kind]net.Listener {\n\tlisteners := map[kind]net.Listener{}\n\tfor _, listener := range systemdListeners {\n\t\tvar kind kind\n\t\tswitch listener.(type) {\n\t\tcase *net.UnixListener:\n\t\t\tkind = local\n\t\tcase *net.TCPListener:\n\t\t\tkind = network\n\t\t\tlistener = networkTLSListener(listener, cert)\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tlisteners[kind] = listener\n\t}\n\treturn listeners\n}", "language": "go", "code": "func activatedListeners(systemdListeners []net.Listener, cert *shared.CertInfo) map[kind]net.Listener {\n\tlisteners := map[kind]net.Listener{}\n\tfor _, listener := range systemdListeners {\n\t\tvar kind kind\n\t\tswitch listener.(type) {\n\t\tcase *net.UnixListener:\n\t\t\tkind = local\n\t\tcase *net.TCPListener:\n\t\t\tkind = network\n\t\t\tlistener = networkTLSListener(listener, cert)\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tlisteners[kind] = listener\n\t}\n\treturn listeners\n}", "code_tokens": ["func", "activatedListeners", "(", "systemdListeners", "[", "]", "net", ".", "Listener", ",", "cert", "*", "shared", ".", "CertInfo", ")", "map", "[", "kind", "]", "net", ".", "Listener", "{", "listeners", ":=", "map", "[", "kind", "]", "net", ".", "Listener", "{", "}", "\n", "for", "_", ",", "listener", ":=", "range", "systemdListeners", "{", "var", "kind", "kind", "\n", "switch", "listener", ".", "(", "type", ")", "{", "case", "*", "net", ".", "UnixListener", ":", "kind", "=", "local", "\n", "case", "*", "net", ".", "TCPListener", ":", "kind", "=", "network", "\n", "listener", "=", "networkTLSListener", "(", "listener", ",", "cert", ")", "\n", "default", ":", "continue", "\n", "}", "\n", "listeners", "[", "kind", "]", "=", "listener", "\n", "}", "\n", "return", "listeners", "\n", "}"], "docstring": "// Use the listeners associated with the file descriptors passed via\n// socket-based activation.", "docstring_tokens": ["Use", "the", "listeners", "associated", "with", "the", "file", "descriptors", "passed", "via", "socket", "-", "based", "activation", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/endpoints/endpoints.go#L329-L345", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "debugger/debugger.go", "func_name": "Do", "original_string": "func (p *SetPauseOnExceptionsParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetPauseOnExceptions, p, nil)\n}", "language": "go", "code": "func (p *SetPauseOnExceptionsParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetPauseOnExceptions, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetPauseOnExceptionsParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetPauseOnExceptions", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Debugger.setPauseOnExceptions against the provided context.", "docstring_tokens": ["Do", "executes", "Debugger", ".", "setPauseOnExceptions", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/debugger/debugger.go#L816-L818", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/git/localgit/localgit.go", "func_name": "MakeFakeRepo", "original_string": "func (lg *LocalGit) MakeFakeRepo(org, repo string) error {\n\trdir := filepath.Join(lg.Dir, org, repo)\n\tif err := os.MkdirAll(rdir, os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\tif err := runCmd(lg.Git, rdir, \"init\"); err != nil {\n\t\treturn err\n\t}\n\tif err := runCmd(lg.Git, rdir, \"config\", \"user.email\", \"test@test.test\"); err != nil {\n\t\treturn err\n\t}\n\tif err := runCmd(lg.Git, rdir, \"config\", \"user.name\", \"test test\"); err != nil {\n\t\treturn err\n\t}\n\tif err := runCmd(lg.Git, rdir, \"config\", \"commit.gpgsign\", \"false\"); err != nil {\n\t\treturn err\n\t}\n\tif err := lg.AddCommit(org, repo, map[string][]byte{\"initial\": {}}); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (lg *LocalGit) MakeFakeRepo(org, repo string) error {\n\trdir := filepath.Join(lg.Dir, org, repo)\n\tif err := os.MkdirAll(rdir, os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\tif err := runCmd(lg.Git, rdir, \"init\"); err != nil {\n\t\treturn err\n\t}\n\tif err := runCmd(lg.Git, rdir, \"config\", \"user.email\", \"test@test.test\"); err != nil {\n\t\treturn err\n\t}\n\tif err := runCmd(lg.Git, rdir, \"config\", \"user.name\", \"test test\"); err != nil {\n\t\treturn err\n\t}\n\tif err := runCmd(lg.Git, rdir, \"config\", \"commit.gpgsign\", \"false\"); err != nil {\n\t\treturn err\n\t}\n\tif err := lg.AddCommit(org, repo, map[string][]byte{\"initial\": {}}); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "lg", "*", "LocalGit", ")", "MakeFakeRepo", "(", "org", ",", "repo", "string", ")", "error", "{", "rdir", ":=", "filepath", ".", "Join", "(", "lg", ".", "Dir", ",", "org", ",", "repo", ")", "\n", "if", "err", ":=", "os", ".", "MkdirAll", "(", "rdir", ",", "os", ".", "ModePerm", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "err", ":=", "runCmd", "(", "lg", ".", "Git", ",", "rdir", ",", "\"", "\"", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "err", ":=", "runCmd", "(", "lg", ".", "Git", ",", "rdir", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "err", ":=", "runCmd", "(", "lg", ".", "Git", ",", "rdir", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "err", ":=", "runCmd", "(", "lg", ".", "Git", ",", "rdir", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "err", ":=", "lg", ".", "AddCommit", "(", "org", ",", "repo", ",", "map", "[", "string", "]", "[", "]", "byte", "{", "\"", "\"", ":", "{", "}", "}", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// MakeFakeRepo creates the given repo and makes an initial commit.", "docstring_tokens": ["MakeFakeRepo", "creates", "the", "given", "repo", "and", "makes", "an", "initial", "commit", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/git/localgit/localgit.go#L95-L118", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/deck/jobs/jobs.go", "func_name": "Jobs", "original_string": "func (ja *JobAgent) Jobs() []Job {\n\tja.mut.Lock()\n\tdefer ja.mut.Unlock()\n\tres := make([]Job, len(ja.jobs))\n\tcopy(res, ja.jobs)\n\treturn res\n}", "language": "go", "code": "func (ja *JobAgent) Jobs() []Job {\n\tja.mut.Lock()\n\tdefer ja.mut.Unlock()\n\tres := make([]Job, len(ja.jobs))\n\tcopy(res, ja.jobs)\n\treturn res\n}", "code_tokens": ["func", "(", "ja", "*", "JobAgent", ")", "Jobs", "(", ")", "[", "]", "Job", "{", "ja", ".", "mut", ".", "Lock", "(", ")", "\n", "defer", "ja", ".", "mut", ".", "Unlock", "(", ")", "\n", "res", ":=", "make", "(", "[", "]", "Job", ",", "len", "(", "ja", ".", "jobs", ")", ")", "\n", "copy", "(", "res", ",", "ja", ".", "jobs", ")", "\n", "return", "res", "\n", "}"], "docstring": "// Jobs returns a thread-safe snapshot of the current job state.", "docstring_tokens": ["Jobs", "returns", "a", "thread", "-", "safe", "snapshot", "of", "the", "current", "job", "state", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/deck/jobs/jobs.go#L112-L118", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "peer.go", "func_name": "SetStrategy", "original_string": "func (l *PeerList) SetStrategy(sc ScoreCalculator) {\n\tl.Lock()\n\tdefer l.Unlock()\n\n\tl.scoreCalculator = sc\n\tfor _, ps := range l.peersByHostPort {\n\t\tnewScore := l.scoreCalculator.GetScore(ps.Peer)\n\t\tl.updatePeer(ps, newScore)\n\t}\n}", "language": "go", "code": "func (l *PeerList) SetStrategy(sc ScoreCalculator) {\n\tl.Lock()\n\tdefer l.Unlock()\n\n\tl.scoreCalculator = sc\n\tfor _, ps := range l.peersByHostPort {\n\t\tnewScore := l.scoreCalculator.GetScore(ps.Peer)\n\t\tl.updatePeer(ps, newScore)\n\t}\n}", "code_tokens": ["func", "(", "l", "*", "PeerList", ")", "SetStrategy", "(", "sc", "ScoreCalculator", ")", "{", "l", ".", "Lock", "(", ")", "\n", "defer", "l", ".", "Unlock", "(", ")", "\n\n", "l", ".", "scoreCalculator", "=", "sc", "\n", "for", "_", ",", "ps", ":=", "range", "l", ".", "peersByHostPort", "{", "newScore", ":=", "l", ".", "scoreCalculator", ".", "GetScore", "(", "ps", ".", "Peer", ")", "\n", "l", ".", "updatePeer", "(", "ps", ",", "newScore", ")", "\n", "}", "\n", "}"], "docstring": "// SetStrategy sets customized peer selection strategy.", "docstring_tokens": ["SetStrategy", "sets", "customized", "peer", "selection", "strategy", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/peer.go#L83-L92", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "reqres.go", "func_name": "recvNextFragment", "original_string": "func (r *reqResReader) recvNextFragment(initial bool) (*readableFragment, error) {\n\tif r.initialFragment != nil {\n\t\tfragment := r.initialFragment\n\t\tr.initialFragment = nil\n\t\tr.previousFragment = fragment\n\t\treturn fragment, nil\n\t}\n\n\t// Wait for the appropriate message from the peer\n\tmessage := r.messageForFragment(initial)\n\tframe, err := r.mex.recvPeerFrameOfType(message.messageType())\n\tif err != nil {\n\t\tif err, ok := err.(errorMessage); ok {\n\t\t\t// If we received a serialized error from the other side, then we should go through\n\t\t\t// the normal doneReading path so stats get updated with this error.\n\t\t\tr.err = err.AsSystemError()\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn nil, r.failed(err)\n\t}\n\n\t// Parse the message and setup the fragment\n\tfragment, err := parseInboundFragment(r.mex.framePool, frame, message)\n\tif err != nil {\n\t\treturn nil, r.failed(err)\n\t}\n\n\tr.previousFragment = fragment\n\treturn fragment, nil\n}", "language": "go", "code": "func (r *reqResReader) recvNextFragment(initial bool) (*readableFragment, error) {\n\tif r.initialFragment != nil {\n\t\tfragment := r.initialFragment\n\t\tr.initialFragment = nil\n\t\tr.previousFragment = fragment\n\t\treturn fragment, nil\n\t}\n\n\t// Wait for the appropriate message from the peer\n\tmessage := r.messageForFragment(initial)\n\tframe, err := r.mex.recvPeerFrameOfType(message.messageType())\n\tif err != nil {\n\t\tif err, ok := err.(errorMessage); ok {\n\t\t\t// If we received a serialized error from the other side, then we should go through\n\t\t\t// the normal doneReading path so stats get updated with this error.\n\t\t\tr.err = err.AsSystemError()\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn nil, r.failed(err)\n\t}\n\n\t// Parse the message and setup the fragment\n\tfragment, err := parseInboundFragment(r.mex.framePool, frame, message)\n\tif err != nil {\n\t\treturn nil, r.failed(err)\n\t}\n\n\tr.previousFragment = fragment\n\treturn fragment, nil\n}", "code_tokens": ["func", "(", "r", "*", "reqResReader", ")", "recvNextFragment", "(", "initial", "bool", ")", "(", "*", "readableFragment", ",", "error", ")", "{", "if", "r", ".", "initialFragment", "!=", "nil", "{", "fragment", ":=", "r", ".", "initialFragment", "\n", "r", ".", "initialFragment", "=", "nil", "\n", "r", ".", "previousFragment", "=", "fragment", "\n", "return", "fragment", ",", "nil", "\n", "}", "\n\n", "// Wait for the appropriate message from the peer", "message", ":=", "r", ".", "messageForFragment", "(", "initial", ")", "\n", "frame", ",", "err", ":=", "r", ".", "mex", ".", "recvPeerFrameOfType", "(", "message", ".", "messageType", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", ",", "ok", ":=", "err", ".", "(", "errorMessage", ")", ";", "ok", "{", "// If we received a serialized error from the other side, then we should go through", "// the normal doneReading path so stats get updated with this error.", "r", ".", "err", "=", "err", ".", "AsSystemError", "(", ")", "\n", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "nil", ",", "r", ".", "failed", "(", "err", ")", "\n", "}", "\n\n", "// Parse the message and setup the fragment", "fragment", ",", "err", ":=", "parseInboundFragment", "(", "r", ".", "mex", ".", "framePool", ",", "frame", ",", "message", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "r", ".", "failed", "(", "err", ")", "\n", "}", "\n\n", "r", ".", "previousFragment", "=", "fragment", "\n", "return", "fragment", ",", "nil", "\n", "}"], "docstring": "// recvNextFragment receives the next fragment from the underlying message exchange.", "docstring_tokens": ["recvNextFragment", "receives", "the", "next", "fragment", "from", "the", "underlying", "message", "exchange", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/reqres.go#L226-L256", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "draw2dgl/gc.go", "func_name": "NewPainter", "original_string": "func NewPainter() *Painter {\n\tp := new(Painter)\n\tp.vertices = make([]int32, 0, 1024)\n\tp.colors = make([]uint8, 0, 1024)\n\treturn p\n}", "language": "go", "code": "func NewPainter() *Painter {\n\tp := new(Painter)\n\tp.vertices = make([]int32, 0, 1024)\n\tp.colors = make([]uint8, 0, 1024)\n\treturn p\n}", "code_tokens": ["func", "NewPainter", "(", ")", "*", "Painter", "{", "p", ":=", "new", "(", "Painter", ")", "\n", "p", ".", "vertices", "=", "make", "(", "[", "]", "int32", ",", "0", ",", "1024", ")", "\n", "p", ".", "colors", "=", "make", "(", "[", "]", "uint8", ",", "0", ",", "1024", ")", "\n", "return", "p", "\n", "}"], "docstring": "// NewRGBAPainter creates a new RGBAPainter for the given image.", "docstring_tokens": ["NewRGBAPainter", "creates", "a", "new", "RGBAPainter", "for", "the", "given", "image", "."], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/draw2dgl/gc.go#L115-L120", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "router.go", "func_name": "OnGossipUnicast", "original_string": "func (router *Router) OnGossipUnicast(sender PeerName, msg []byte) error {\n\treturn fmt.Errorf(\"unexpected topology gossip unicast: %v\", msg)\n}", "language": "go", "code": "func (router *Router) OnGossipUnicast(sender PeerName, msg []byte) error {\n\treturn fmt.Errorf(\"unexpected topology gossip unicast: %v\", msg)\n}", "code_tokens": ["func", "(", "router", "*", "Router", ")", "OnGossipUnicast", "(", "sender", "PeerName", ",", "msg", "[", "]", "byte", ")", "error", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "msg", ")", "\n", "}"], "docstring": "// OnGossipUnicast implements Gossiper, but always returns an error, as a\n// router should only receive gossip broadcasts of TopologyGossipData.", "docstring_tokens": ["OnGossipUnicast", "implements", "Gossiper", "but", "always", "returns", "an", "error", "as", "a", "router", "should", "only", "receive", "gossip", "broadcasts", "of", "TopologyGossipData", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/router.go#L234-L236", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "render/template.go", "func_name": "partialFeeder", "original_string": "func (s templateRenderer) partialFeeder(name string) (string, error) {\n\tct := strings.ToLower(s.contentType)\n\n\td, f := filepath.Split(name)\n\tname = filepath.Join(d, \"_\"+f)\n\tname = fixExtension(name, ct)\n\n\treturn s.TemplatesBox.FindString(name)\n}", "language": "go", "code": "func (s templateRenderer) partialFeeder(name string) (string, error) {\n\tct := strings.ToLower(s.contentType)\n\n\td, f := filepath.Split(name)\n\tname = filepath.Join(d, \"_\"+f)\n\tname = fixExtension(name, ct)\n\n\treturn s.TemplatesBox.FindString(name)\n}", "code_tokens": ["func", "(", "s", "templateRenderer", ")", "partialFeeder", "(", "name", "string", ")", "(", "string", ",", "error", ")", "{", "ct", ":=", "strings", ".", "ToLower", "(", "s", ".", "contentType", ")", "\n\n", "d", ",", "f", ":=", "filepath", ".", "Split", "(", "name", ")", "\n", "name", "=", "filepath", ".", "Join", "(", "d", ",", "\"", "\"", "+", "f", ")", "\n", "name", "=", "fixExtension", "(", "name", ",", "ct", ")", "\n\n", "return", "s", ".", "TemplatesBox", ".", "FindString", "(", "name", ")", "\n", "}"], "docstring": "// partialFeeder returns template string for the name from `TemplateBox`.\n// It should be registered as helper named `partialFeeder` so plush can\n// find it with the name.", "docstring_tokens": ["partialFeeder", "returns", "template", "string", "for", "the", "name", "from", "TemplateBox", ".", "It", "should", "be", "registered", "as", "helper", "named", "partialFeeder", "so", "plush", "can", "find", "it", "with", "the", "name", "."], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/render/template.go#L56-L64", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/profiles.go", "func_name": "Profiles", "original_string": "func (c *Cluster) Profiles(project string) ([]string, error) {\n\terr := c.Transaction(func(tx *ClusterTx) error {\n\t\tenabled, err := tx.ProjectHasProfiles(project)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"Check if project has profiles\")\n\t\t}\n\t\tif !enabled {\n\t\t\tproject = \"default\"\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := fmt.Sprintf(`\nSELECT profiles.name\n FROM profiles\n JOIN projects ON projects.id = profiles.project_id\nWHERE projects.name = ?\n`)\n\tinargs := []interface{}{project}\n\tvar name string\n\toutfmt := []interface{}{name}\n\tresult, err := queryScan(c.db, q, inargs, outfmt)\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\n\tresponse := []string{}\n\tfor _, r := range result {\n\t\tresponse = append(response, r[0].(string))\n\t}\n\n\treturn response, nil\n}", "language": "go", "code": "func (c *Cluster) Profiles(project string) ([]string, error) {\n\terr := c.Transaction(func(tx *ClusterTx) error {\n\t\tenabled, err := tx.ProjectHasProfiles(project)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"Check if project has profiles\")\n\t\t}\n\t\tif !enabled {\n\t\t\tproject = \"default\"\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := fmt.Sprintf(`\nSELECT profiles.name\n FROM profiles\n JOIN projects ON projects.id = profiles.project_id\nWHERE projects.name = ?\n`)\n\tinargs := []interface{}{project}\n\tvar name string\n\toutfmt := []interface{}{name}\n\tresult, err := queryScan(c.db, q, inargs, outfmt)\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\n\tresponse := []string{}\n\tfor _, r := range result {\n\t\tresponse = append(response, r[0].(string))\n\t}\n\n\treturn response, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "Profiles", "(", "project", "string", ")", "(", "[", "]", "string", ",", "error", ")", "{", "err", ":=", "c", ".", "Transaction", "(", "func", "(", "tx", "*", "ClusterTx", ")", "error", "{", "enabled", ",", "err", ":=", "tx", ".", "ProjectHasProfiles", "(", "project", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "if", "!", "enabled", "{", "project", "=", "\"", "\"", "\n", "}", "\n", "return", "nil", "\n", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "q", ":=", "fmt", ".", "Sprintf", "(", "`\nSELECT profiles.name\n FROM profiles\n JOIN projects ON projects.id = profiles.project_id\nWHERE projects.name = ?\n`", ")", "\n", "inargs", ":=", "[", "]", "interface", "{", "}", "{", "project", "}", "\n", "var", "name", "string", "\n", "outfmt", ":=", "[", "]", "interface", "{", "}", "{", "name", "}", "\n", "result", ",", "err", ":=", "queryScan", "(", "c", ".", "db", ",", "q", ",", "inargs", ",", "outfmt", ")", "\n", "if", "err", "!=", "nil", "{", "return", "[", "]", "string", "{", "}", ",", "err", "\n", "}", "\n\n", "response", ":=", "[", "]", "string", "{", "}", "\n", "for", "_", ",", "r", ":=", "range", "result", "{", "response", "=", "append", "(", "response", ",", "r", "[", "0", "]", ".", "(", "string", ")", ")", "\n", "}", "\n\n", "return", "response", ",", "nil", "\n", "}"], "docstring": "// Profiles returns a string list of profiles.", "docstring_tokens": ["Profiles", "returns", "a", "string", "list", "of", "profiles", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/profiles.go#L83-L118", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/config/jobs.go", "func_name": "AllPostsubmits", "original_string": "func (c *JobConfig) AllPostsubmits(repos []string) []Postsubmit {\n\tvar res []Postsubmit\n\n\tfor repo, v := range c.Postsubmits {\n\t\tif len(repos) == 0 {\n\t\t\tres = append(res, v...)\n\t\t} else {\n\t\t\tfor _, r := range repos {\n\t\t\t\tif r == repo {\n\t\t\t\t\tres = append(res, v...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res\n}", "language": "go", "code": "func (c *JobConfig) AllPostsubmits(repos []string) []Postsubmit {\n\tvar res []Postsubmit\n\n\tfor repo, v := range c.Postsubmits {\n\t\tif len(repos) == 0 {\n\t\t\tres = append(res, v...)\n\t\t} else {\n\t\t\tfor _, r := range repos {\n\t\t\t\tif r == repo {\n\t\t\t\t\tres = append(res, v...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res\n}", "code_tokens": ["func", "(", "c", "*", "JobConfig", ")", "AllPostsubmits", "(", "repos", "[", "]", "string", ")", "[", "]", "Postsubmit", "{", "var", "res", "[", "]", "Postsubmit", "\n\n", "for", "repo", ",", "v", ":=", "range", "c", ".", "Postsubmits", "{", "if", "len", "(", "repos", ")", "==", "0", "{", "res", "=", "append", "(", "res", ",", "v", "...", ")", "\n", "}", "else", "{", "for", "_", ",", "r", ":=", "range", "repos", "{", "if", "r", "==", "repo", "{", "res", "=", "append", "(", "res", ",", "v", "...", ")", "\n", "break", "\n", "}", "\n", "}", "\n", "}", "\n", "}", "\n\n", "return", "res", "\n", "}"], "docstring": "// AllPostsubmits returns all prow postsubmit jobs in repos.\n// if repos is empty, return all postsubmits.", "docstring_tokens": ["AllPostsubmits", "returns", "all", "prow", "postsubmit", "jobs", "in", "repos", ".", "if", "repos", "is", "empty", "return", "all", "postsubmits", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/jobs.go#L503-L520", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/config/tide.go", "func_name": "ForRepo", "original_string": "func (qm *QueryMap) ForRepo(org, repo string) TideQueries {\n\tres := TideQueries(nil)\n\tfullName := fmt.Sprintf(\"%s/%s\", org, repo)\n\n\tqm.Lock()\n\tdefer qm.Unlock()\n\n\tif qs, ok := qm.cache[fullName]; ok {\n\t\treturn append(res, qs...) // Return a copy.\n\t}\n\t// Cache miss. Need to determine relevant queries.\n\n\tfor _, query := range qm.queries {\n\t\tif query.ForRepo(org, repo) {\n\t\t\tres = append(res, query)\n\t\t}\n\t}\n\tqm.cache[fullName] = res\n\treturn res\n}", "language": "go", "code": "func (qm *QueryMap) ForRepo(org, repo string) TideQueries {\n\tres := TideQueries(nil)\n\tfullName := fmt.Sprintf(\"%s/%s\", org, repo)\n\n\tqm.Lock()\n\tdefer qm.Unlock()\n\n\tif qs, ok := qm.cache[fullName]; ok {\n\t\treturn append(res, qs...) // Return a copy.\n\t}\n\t// Cache miss. Need to determine relevant queries.\n\n\tfor _, query := range qm.queries {\n\t\tif query.ForRepo(org, repo) {\n\t\t\tres = append(res, query)\n\t\t}\n\t}\n\tqm.cache[fullName] = res\n\treturn res\n}", "code_tokens": ["func", "(", "qm", "*", "QueryMap", ")", "ForRepo", "(", "org", ",", "repo", "string", ")", "TideQueries", "{", "res", ":=", "TideQueries", "(", "nil", ")", "\n", "fullName", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "org", ",", "repo", ")", "\n\n", "qm", ".", "Lock", "(", ")", "\n", "defer", "qm", ".", "Unlock", "(", ")", "\n\n", "if", "qs", ",", "ok", ":=", "qm", ".", "cache", "[", "fullName", "]", ";", "ok", "{", "return", "append", "(", "res", ",", "qs", "...", ")", "// Return a copy.", "\n", "}", "\n", "// Cache miss. Need to determine relevant queries.", "for", "_", ",", "query", ":=", "range", "qm", ".", "queries", "{", "if", "query", ".", "ForRepo", "(", "org", ",", "repo", ")", "{", "res", "=", "append", "(", "res", ",", "query", ")", "\n", "}", "\n", "}", "\n", "qm", ".", "cache", "[", "fullName", "]", "=", "res", "\n", "return", "res", "\n", "}"], "docstring": "// ForRepo returns the tide queries that apply to a repo.", "docstring_tokens": ["ForRepo", "returns", "the", "tide", "queries", "that", "apply", "to", "a", "repo", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/tide.go#L304-L323", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/retry.go", "func_name": "RetryAuthClient", "original_string": "func RetryAuthClient(c *Client) pb.AuthClient {\n\treturn &retryAuthClient{\n\t\tac: pb.NewAuthClient(c.conn),\n\t}\n}", "language": "go", "code": "func RetryAuthClient(c *Client) pb.AuthClient {\n\treturn &retryAuthClient{\n\t\tac: pb.NewAuthClient(c.conn),\n\t}\n}", "code_tokens": ["func", "RetryAuthClient", "(", "c", "*", "Client", ")", "pb", ".", "AuthClient", "{", "return", "&", "retryAuthClient", "{", "ac", ":", "pb", ".", "NewAuthClient", "(", "c", ".", "conn", ")", ",", "}", "\n", "}"], "docstring": "// RetryAuthClient implements a AuthClient.", "docstring_tokens": ["RetryAuthClient", "implements", "a", "AuthClient", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/retry.go#L230-L234", "partition": "test"}
{"repo": "golang/appengine", "path": "image/image.go", "func_name": "ServingURL", "original_string": "func ServingURL(c context.Context, key appengine.BlobKey, opts *ServingURLOptions) (*url.URL, error) {\n\treq := &pb.ImagesGetUrlBaseRequest{\n\t\tBlobKey: (*string)(&key),\n\t}\n\tif opts != nil && opts.Secure {\n\t\treq.CreateSecureUrl = &opts.Secure\n\t}\n\tres := &pb.ImagesGetUrlBaseResponse{}\n\tif err := internal.Call(c, \"images\", \"GetUrlBase\", req, res); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The URL may have suffixes added to dynamically resize or crop:\n\t// - adding \"=s32\" will serve the image resized to 32 pixels, preserving the aspect ratio.\n\t// - adding \"=s32-c\" is the same as \"=s32\" except it will be cropped.\n\tu := *res.Url\n\tif opts != nil && opts.Size > 0 {\n\t\tu += fmt.Sprintf(\"=s%d\", opts.Size)\n\t\tif opts.Crop {\n\t\t\tu += \"-c\"\n\t\t}\n\t}\n\treturn url.Parse(u)\n}", "language": "go", "code": "func ServingURL(c context.Context, key appengine.BlobKey, opts *ServingURLOptions) (*url.URL, error) {\n\treq := &pb.ImagesGetUrlBaseRequest{\n\t\tBlobKey: (*string)(&key),\n\t}\n\tif opts != nil && opts.Secure {\n\t\treq.CreateSecureUrl = &opts.Secure\n\t}\n\tres := &pb.ImagesGetUrlBaseResponse{}\n\tif err := internal.Call(c, \"images\", \"GetUrlBase\", req, res); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The URL may have suffixes added to dynamically resize or crop:\n\t// - adding \"=s32\" will serve the image resized to 32 pixels, preserving the aspect ratio.\n\t// - adding \"=s32-c\" is the same as \"=s32\" except it will be cropped.\n\tu := *res.Url\n\tif opts != nil && opts.Size > 0 {\n\t\tu += fmt.Sprintf(\"=s%d\", opts.Size)\n\t\tif opts.Crop {\n\t\t\tu += \"-c\"\n\t\t}\n\t}\n\treturn url.Parse(u)\n}", "code_tokens": ["func", "ServingURL", "(", "c", "context", ".", "Context", ",", "key", "appengine", ".", "BlobKey", ",", "opts", "*", "ServingURLOptions", ")", "(", "*", "url", ".", "URL", ",", "error", ")", "{", "req", ":=", "&", "pb", ".", "ImagesGetUrlBaseRequest", "{", "BlobKey", ":", "(", "*", "string", ")", "(", "&", "key", ")", ",", "}", "\n", "if", "opts", "!=", "nil", "&&", "opts", ".", "Secure", "{", "req", ".", "CreateSecureUrl", "=", "&", "opts", ".", "Secure", "\n", "}", "\n", "res", ":=", "&", "pb", ".", "ImagesGetUrlBaseResponse", "{", "}", "\n", "if", "err", ":=", "internal", ".", "Call", "(", "c", ",", "\"", "\"", ",", "\"", "\"", ",", "req", ",", "res", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "// The URL may have suffixes added to dynamically resize or crop:", "// - adding \"=s32\" will serve the image resized to 32 pixels, preserving the aspect ratio.", "// - adding \"=s32-c\" is the same as \"=s32\" except it will be cropped.", "u", ":=", "*", "res", ".", "Url", "\n", "if", "opts", "!=", "nil", "&&", "opts", ".", "Size", ">", "0", "{", "u", "+=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "opts", ".", "Size", ")", "\n", "if", "opts", ".", "Crop", "{", "u", "+=", "\"", "\"", "\n", "}", "\n", "}", "\n", "return", "url", ".", "Parse", "(", "u", ")", "\n", "}"], "docstring": "// ServingURL returns a URL that will serve an image from Blobstore.", "docstring_tokens": ["ServingURL", "returns", "a", "URL", "that", "will", "serve", "an", "image", "from", "Blobstore", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/image/image.go#L31-L54", "partition": "test"}
{"repo": "op/go-logging", "path": "syslog.go", "func_name": "NewSyslogBackendPriority", "original_string": "func NewSyslogBackendPriority(prefix string, priority syslog.Priority) (b *SyslogBackend, err error) {\n\tvar w *syslog.Writer\n\tw, err = syslog.New(priority, prefix)\n\treturn &SyslogBackend{w}, err\n}", "language": "go", "code": "func NewSyslogBackendPriority(prefix string, priority syslog.Priority) (b *SyslogBackend, err error) {\n\tvar w *syslog.Writer\n\tw, err = syslog.New(priority, prefix)\n\treturn &SyslogBackend{w}, err\n}", "code_tokens": ["func", "NewSyslogBackendPriority", "(", "prefix", "string", ",", "priority", "syslog", ".", "Priority", ")", "(", "b", "*", "SyslogBackend", ",", "err", "error", ")", "{", "var", "w", "*", "syslog", ".", "Writer", "\n", "w", ",", "err", "=", "syslog", ".", "New", "(", "priority", ",", "prefix", ")", "\n", "return", "&", "SyslogBackend", "{", "w", "}", ",", "err", "\n", "}"], "docstring": "// NewSyslogBackendPriority is the same as NewSyslogBackend, but with custom\n// syslog priority, like syslog.LOG_LOCAL3|syslog.LOG_DEBUG etc.", "docstring_tokens": ["NewSyslogBackendPriority", "is", "the", "same", "as", "NewSyslogBackend", "but", "with", "custom", "syslog", "priority", "like", "syslog", ".", "LOG_LOCAL3|syslog", ".", "LOG_DEBUG", "etc", "."], "sha": "970db520ece77730c7e4724c61121037378659d9", "url": "https://github.com/op/go-logging/blob/970db520ece77730c7e4724c61121037378659d9/syslog.go#L28-L32", "partition": "test"}
{"repo": "opentracing/opentracing-go", "path": "mocktracer/mockspan.go", "func_name": "Logs", "original_string": "func (s *MockSpan) Logs() []MockLogRecord {\n\ts.RLock()\n\tdefer s.RUnlock()\n\tlogs := make([]MockLogRecord, len(s.logs))\n\tcopy(logs, s.logs)\n\treturn logs\n}", "language": "go", "code": "func (s *MockSpan) Logs() []MockLogRecord {\n\ts.RLock()\n\tdefer s.RUnlock()\n\tlogs := make([]MockLogRecord, len(s.logs))\n\tcopy(logs, s.logs)\n\treturn logs\n}", "code_tokens": ["func", "(", "s", "*", "MockSpan", ")", "Logs", "(", ")", "[", "]", "MockLogRecord", "{", "s", ".", "RLock", "(", ")", "\n", "defer", "s", ".", "RUnlock", "(", ")", "\n", "logs", ":=", "make", "(", "[", "]", "MockLogRecord", ",", "len", "(", "s", ".", "logs", ")", ")", "\n", "copy", "(", "logs", ",", "s", ".", "logs", ")", "\n", "return", "logs", "\n", "}"], "docstring": "// Logs returns a copy of logs accumulated in the span so far", "docstring_tokens": ["Logs", "returns", "a", "copy", "of", "logs", "accumulated", "in", "the", "span", "so", "far"], "sha": "659c90643e714681897ec2521c60567dd21da733", "url": "https://github.com/opentracing/opentracing-go/blob/659c90643e714681897ec2521c60567dd21da733/mocktracer/mockspan.go#L128-L134", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "gossip.go", "func_name": "Sender", "original_string": "func (gs *gossipSenders) Sender(channelName string, makeGossipSender func(sender protocolSender, stop <-chan struct{}) *gossipSender) *gossipSender {\n\tgs.Lock()\n\tdefer gs.Unlock()\n\ts, found := gs.senders[channelName]\n\tif !found {\n\t\ts = makeGossipSender(gs.sender, gs.stop)\n\t\tgs.senders[channelName] = s\n\t}\n\treturn s\n}", "language": "go", "code": "func (gs *gossipSenders) Sender(channelName string, makeGossipSender func(sender protocolSender, stop <-chan struct{}) *gossipSender) *gossipSender {\n\tgs.Lock()\n\tdefer gs.Unlock()\n\ts, found := gs.senders[channelName]\n\tif !found {\n\t\ts = makeGossipSender(gs.sender, gs.stop)\n\t\tgs.senders[channelName] = s\n\t}\n\treturn s\n}", "code_tokens": ["func", "(", "gs", "*", "gossipSenders", ")", "Sender", "(", "channelName", "string", ",", "makeGossipSender", "func", "(", "sender", "protocolSender", ",", "stop", "<-", "chan", "struct", "{", "}", ")", "*", "gossipSender", ")", "*", "gossipSender", "{", "gs", ".", "Lock", "(", ")", "\n", "defer", "gs", ".", "Unlock", "(", ")", "\n", "s", ",", "found", ":=", "gs", ".", "senders", "[", "channelName", "]", "\n", "if", "!", "found", "{", "s", "=", "makeGossipSender", "(", "gs", ".", "sender", ",", "gs", ".", "stop", ")", "\n", "gs", ".", "senders", "[", "channelName", "]", "=", "s", "\n", "}", "\n", "return", "s", "\n", "}"], "docstring": "// Sender yields the GossipSender for the named channel.\n// It will use the factory function if no sender yet exists.", "docstring_tokens": ["Sender", "yields", "the", "GossipSender", "for", "the", "named", "channel", ".", "It", "will", "use", "the", "factory", "function", "if", "no", "sender", "yet", "exists", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/gossip.go#L242-L251", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/cluster/raft.go", "func_name": "Servers", "original_string": "func (i *raftInstance) Servers() ([]raft.Server, error) {\n\tif i.raft.State() != raft.Leader {\n\t\treturn nil, raft.ErrNotLeader\n\t}\n\tfuture := i.raft.GetConfiguration()\n\terr := future.Error()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfiguration := future.Configuration()\n\treturn configuration.Servers, nil\n}", "language": "go", "code": "func (i *raftInstance) Servers() ([]raft.Server, error) {\n\tif i.raft.State() != raft.Leader {\n\t\treturn nil, raft.ErrNotLeader\n\t}\n\tfuture := i.raft.GetConfiguration()\n\terr := future.Error()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfiguration := future.Configuration()\n\treturn configuration.Servers, nil\n}", "code_tokens": ["func", "(", "i", "*", "raftInstance", ")", "Servers", "(", ")", "(", "[", "]", "raft", ".", "Server", ",", "error", ")", "{", "if", "i", ".", "raft", ".", "State", "(", ")", "!=", "raft", ".", "Leader", "{", "return", "nil", ",", "raft", ".", "ErrNotLeader", "\n", "}", "\n", "future", ":=", "i", ".", "raft", ".", "GetConfiguration", "(", ")", "\n", "err", ":=", "future", ".", "Error", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "configuration", ":=", "future", ".", "Configuration", "(", ")", "\n", "return", "configuration", ".", "Servers", ",", "nil", "\n", "}"], "docstring": "// Servers returns the servers that are currently part of the cluster.\n//\n// If this raft instance is not the leader, an error is returned.", "docstring_tokens": ["Servers", "returns", "the", "servers", "that", "are", "currently", "part", "of", "the", "cluster", ".", "If", "this", "raft", "instance", "is", "not", "the", "leader", "an", "error", "is", "returned", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/raft.go#L239-L250", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/daemon.go", "func_name": "UnixSocket", "original_string": "func (d *Daemon) UnixSocket() string {\n\tpath := os.Getenv(\"LXD_SOCKET\")\n\tif path != \"\" {\n\t\treturn path\n\t}\n\n\treturn filepath.Join(d.os.VarDir, \"unix.socket\")\n}", "language": "go", "code": "func (d *Daemon) UnixSocket() string {\n\tpath := os.Getenv(\"LXD_SOCKET\")\n\tif path != \"\" {\n\t\treturn path\n\t}\n\n\treturn filepath.Join(d.os.VarDir, \"unix.socket\")\n}", "code_tokens": ["func", "(", "d", "*", "Daemon", ")", "UnixSocket", "(", ")", "string", "{", "path", ":=", "os", ".", "Getenv", "(", "\"", "\"", ")", "\n", "if", "path", "!=", "\"", "\"", "{", "return", "path", "\n", "}", "\n\n", "return", "filepath", ".", "Join", "(", "d", ".", "os", ".", "VarDir", ",", "\"", "\"", ")", "\n", "}"], "docstring": "// UnixSocket returns the full path to the unix.socket file that this daemon is\n// listening on. Used by tests.", "docstring_tokens": ["UnixSocket", "returns", "the", "full", "path", "to", "the", "unix", ".", "socket", "file", "that", "this", "daemon", "is", "listening", "on", ".", "Used", "by", "tests", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/daemon.go#L323-L330", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/flags/selective_string.go", "func_name": "Valids", "original_string": "func (ss *SelectiveStringValue) Valids() []string {\n\ts := make([]string, 0, len(ss.valids))\n\tfor k := range ss.valids {\n\t\ts = append(s, k)\n\t}\n\tsort.Strings(s)\n\treturn s\n}", "language": "go", "code": "func (ss *SelectiveStringValue) Valids() []string {\n\ts := make([]string, 0, len(ss.valids))\n\tfor k := range ss.valids {\n\t\ts = append(s, k)\n\t}\n\tsort.Strings(s)\n\treturn s\n}", "code_tokens": ["func", "(", "ss", "*", "SelectiveStringValue", ")", "Valids", "(", ")", "[", "]", "string", "{", "s", ":=", "make", "(", "[", "]", "string", ",", "0", ",", "len", "(", "ss", ".", "valids", ")", ")", "\n", "for", "k", ":=", "range", "ss", ".", "valids", "{", "s", "=", "append", "(", "s", ",", "k", ")", "\n", "}", "\n", "sort", ".", "Strings", "(", "s", ")", "\n", "return", "s", "\n", "}"], "docstring": "// Valids returns the list of valid strings.", "docstring_tokens": ["Valids", "returns", "the", "list", "of", "valid", "strings", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/flags/selective_string.go#L46-L53", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/apparmor.go", "func_name": "AALoadProfile", "original_string": "func AALoadProfile(c container) error {\n\tstate := c.DaemonState()\n\tif !state.OS.AppArmorAdmin {\n\t\treturn nil\n\t}\n\n\tif err := mkApparmorNamespace(c, AANamespace(c)); err != nil {\n\t\treturn err\n\t}\n\n\t/* In order to avoid forcing a profile parse (potentially slow) on\n\t * every container start, let's use apparmor's binary policy cache,\n\t * which checks mtime of the files to figure out if the policy needs to\n\t * be regenerated.\n\t *\n\t * Since it uses mtimes, we shouldn't just always write out our local\n\t * apparmor template; instead we should check to see whether the\n\t * template is the same as ours. If it isn't we should write our\n\t * version out so that the new changes are reflected and we definitely\n\t * force a recompile.\n\t */\n\tprofile := path.Join(aaPath, \"profiles\", AAProfileShort(c))\n\tcontent, err := ioutil.ReadFile(profile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\tupdated := getAAProfileContent(c)\n\n\tif string(content) != string(updated) {\n\t\tif err := os.MkdirAll(path.Join(aaPath, \"cache\"), 0700); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := os.MkdirAll(path.Join(aaPath, \"profiles\"), 0700); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := ioutil.WriteFile(profile, []byte(updated), 0600); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn runApparmor(APPARMOR_CMD_LOAD, c)\n}", "language": "go", "code": "func AALoadProfile(c container) error {\n\tstate := c.DaemonState()\n\tif !state.OS.AppArmorAdmin {\n\t\treturn nil\n\t}\n\n\tif err := mkApparmorNamespace(c, AANamespace(c)); err != nil {\n\t\treturn err\n\t}\n\n\t/* In order to avoid forcing a profile parse (potentially slow) on\n\t * every container start, let's use apparmor's binary policy cache,\n\t * which checks mtime of the files to figure out if the policy needs to\n\t * be regenerated.\n\t *\n\t * Since it uses mtimes, we shouldn't just always write out our local\n\t * apparmor template; instead we should check to see whether the\n\t * template is the same as ours. If it isn't we should write our\n\t * version out so that the new changes are reflected and we definitely\n\t * force a recompile.\n\t */\n\tprofile := path.Join(aaPath, \"profiles\", AAProfileShort(c))\n\tcontent, err := ioutil.ReadFile(profile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\tupdated := getAAProfileContent(c)\n\n\tif string(content) != string(updated) {\n\t\tif err := os.MkdirAll(path.Join(aaPath, \"cache\"), 0700); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := os.MkdirAll(path.Join(aaPath, \"profiles\"), 0700); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := ioutil.WriteFile(profile, []byte(updated), 0600); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn runApparmor(APPARMOR_CMD_LOAD, c)\n}", "code_tokens": ["func", "AALoadProfile", "(", "c", "container", ")", "error", "{", "state", ":=", "c", ".", "DaemonState", "(", ")", "\n", "if", "!", "state", ".", "OS", ".", "AppArmorAdmin", "{", "return", "nil", "\n", "}", "\n\n", "if", "err", ":=", "mkApparmorNamespace", "(", "c", ",", "AANamespace", "(", "c", ")", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "/* In order to avoid forcing a profile parse (potentially slow) on\n\t * every container start, let's use apparmor's binary policy cache,\n\t * which checks mtime of the files to figure out if the policy needs to\n\t * be regenerated.\n\t *\n\t * Since it uses mtimes, we shouldn't just always write out our local\n\t * apparmor template; instead we should check to see whether the\n\t * template is the same as ours. If it isn't we should write our\n\t * version out so that the new changes are reflected and we definitely\n\t * force a recompile.\n\t */", "profile", ":=", "path", ".", "Join", "(", "aaPath", ",", "\"", "\"", ",", "AAProfileShort", "(", "c", ")", ")", "\n", "content", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "profile", ")", "\n", "if", "err", "!=", "nil", "&&", "!", "os", ".", "IsNotExist", "(", "err", ")", "{", "return", "err", "\n", "}", "\n\n", "updated", ":=", "getAAProfileContent", "(", "c", ")", "\n\n", "if", "string", "(", "content", ")", "!=", "string", "(", "updated", ")", "{", "if", "err", ":=", "os", ".", "MkdirAll", "(", "path", ".", "Join", "(", "aaPath", ",", "\"", "\"", ")", ",", "0700", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "err", ":=", "os", ".", "MkdirAll", "(", "path", ".", "Join", "(", "aaPath", ",", "\"", "\"", ")", ",", "0700", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "if", "err", ":=", "ioutil", ".", "WriteFile", "(", "profile", ",", "[", "]", "byte", "(", "updated", ")", ",", "0600", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n\n", "return", "runApparmor", "(", "APPARMOR_CMD_LOAD", ",", "c", ")", "\n", "}"], "docstring": "// Ensure that the container's policy is loaded into the kernel so the\n// container can boot.", "docstring_tokens": ["Ensure", "that", "the", "container", "s", "policy", "is", "loaded", "into", "the", "kernel", "so", "the", "container", "can", "boot", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/apparmor.go#L663-L707", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "ArmForSwitch", "original_string": "func (u ManageOfferResult) ArmForSwitch(sw int32) (string, bool) {\n\tswitch ManageOfferResultCode(sw) {\n\tcase ManageOfferResultCodeManageOfferSuccess:\n\t\treturn \"Success\", true\n\tdefault:\n\t\treturn \"\", true\n\t}\n}", "language": "go", "code": "func (u ManageOfferResult) ArmForSwitch(sw int32) (string, bool) {\n\tswitch ManageOfferResultCode(sw) {\n\tcase ManageOfferResultCodeManageOfferSuccess:\n\t\treturn \"Success\", true\n\tdefault:\n\t\treturn \"\", true\n\t}\n}", "code_tokens": ["func", "(", "u", "ManageOfferResult", ")", "ArmForSwitch", "(", "sw", "int32", ")", "(", "string", ",", "bool", ")", "{", "switch", "ManageOfferResultCode", "(", "sw", ")", "{", "case", "ManageOfferResultCodeManageOfferSuccess", ":", "return", "\"", "\"", ",", "true", "\n", "default", ":", "return", "\"", "\"", ",", "true", "\n", "}", "\n", "}"], "docstring": "// ArmForSwitch returns which field name should be used for storing\n// the value for an instance of ManageOfferResult", "docstring_tokens": ["ArmForSwitch", "returns", "which", "field", "name", "should", "be", "used", "for", "storing", "the", "value", "for", "an", "instance", "of", "ManageOfferResult"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L3118-L3125", "partition": "test"}
{"repo": "tylerb/gls", "path": "gls.go", "func_name": "Set", "original_string": "func Set(key string, value interface{}) {\n\tgid := curGoroutineID()\n\tdataLock.Lock()\n\tif data[gid] == nil {\n\t\tdata[gid] = Values{}\n\t}\n\tdata[gid][key] = value\n\tdataLock.Unlock()\n}", "language": "go", "code": "func Set(key string, value interface{}) {\n\tgid := curGoroutineID()\n\tdataLock.Lock()\n\tif data[gid] == nil {\n\t\tdata[gid] = Values{}\n\t}\n\tdata[gid][key] = value\n\tdataLock.Unlock()\n}", "code_tokens": ["func", "Set", "(", "key", "string", ",", "value", "interface", "{", "}", ")", "{", "gid", ":=", "curGoroutineID", "(", ")", "\n", "dataLock", ".", "Lock", "(", ")", "\n", "if", "data", "[", "gid", "]", "==", "nil", "{", "data", "[", "gid", "]", "=", "Values", "{", "}", "\n", "}", "\n", "data", "[", "gid", "]", "[", "key", "]", "=", "value", "\n", "dataLock", ".", "Unlock", "(", ")", "\n", "}"], "docstring": "// Set sets the value by key and associates it with the current goroutine.", "docstring_tokens": ["Set", "sets", "the", "value", "by", "key", "and", "associates", "it", "with", "the", "current", "goroutine", "."], "sha": "e606233f194d6c314156dc6a35f21a42a470c6f6", "url": "https://github.com/tylerb/gls/blob/e606233f194d6c314156dc6a35f21a42a470c6f6/gls.go#L39-L47", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/worker/api_server.go", "func_name": "mergeChunk", "original_string": "func (a *APIServer) mergeChunk(logger *taggedLogger, high int64, result *processResult) (retErr error) {\n\tlogger.Logf(\"starting to merge chunk\")\n\tdefer func(start time.Time) {\n\t\tif retErr != nil {\n\t\t\tlogger.Logf(\"errored merging chunk after %v: %v\", time.Since(start), retErr)\n\t\t} else {\n\t\t\tlogger.Logf(\"finished merging chunk after %v\", time.Since(start))\n\t\t}\n\t}(time.Now())\n\tbuf := &bytes.Buffer{}\n\tif result.datumsFailed <= 0 {\n\t\tif err := a.datumCache.Merge(hashtree.NewWriter(buf), nil, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := a.chunkCache.Put(high, buf); err != nil {\n\t\treturn err\n\t}\n\tif a.pipelineInfo.EnableStats {\n\t\tbuf.Reset()\n\t\tif err := a.datumStatsCache.Merge(hashtree.NewWriter(buf), nil, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn a.chunkStatsCache.Put(high, buf)\n\t}\n\treturn nil\n}", "language": "go", "code": "func (a *APIServer) mergeChunk(logger *taggedLogger, high int64, result *processResult) (retErr error) {\n\tlogger.Logf(\"starting to merge chunk\")\n\tdefer func(start time.Time) {\n\t\tif retErr != nil {\n\t\t\tlogger.Logf(\"errored merging chunk after %v: %v\", time.Since(start), retErr)\n\t\t} else {\n\t\t\tlogger.Logf(\"finished merging chunk after %v\", time.Since(start))\n\t\t}\n\t}(time.Now())\n\tbuf := &bytes.Buffer{}\n\tif result.datumsFailed <= 0 {\n\t\tif err := a.datumCache.Merge(hashtree.NewWriter(buf), nil, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := a.chunkCache.Put(high, buf); err != nil {\n\t\treturn err\n\t}\n\tif a.pipelineInfo.EnableStats {\n\t\tbuf.Reset()\n\t\tif err := a.datumStatsCache.Merge(hashtree.NewWriter(buf), nil, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn a.chunkStatsCache.Put(high, buf)\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "a", "*", "APIServer", ")", "mergeChunk", "(", "logger", "*", "taggedLogger", ",", "high", "int64", ",", "result", "*", "processResult", ")", "(", "retErr", "error", ")", "{", "logger", ".", "Logf", "(", "\"", "\"", ")", "\n", "defer", "func", "(", "start", "time", ".", "Time", ")", "{", "if", "retErr", "!=", "nil", "{", "logger", ".", "Logf", "(", "\"", "\"", ",", "time", ".", "Since", "(", "start", ")", ",", "retErr", ")", "\n", "}", "else", "{", "logger", ".", "Logf", "(", "\"", "\"", ",", "time", ".", "Since", "(", "start", ")", ")", "\n", "}", "\n", "}", "(", "time", ".", "Now", "(", ")", ")", "\n", "buf", ":=", "&", "bytes", ".", "Buffer", "{", "}", "\n", "if", "result", ".", "datumsFailed", "<=", "0", "{", "if", "err", ":=", "a", ".", "datumCache", ".", "Merge", "(", "hashtree", ".", "NewWriter", "(", "buf", ")", ",", "nil", ",", "nil", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "}", "\n", "if", "err", ":=", "a", ".", "chunkCache", ".", "Put", "(", "high", ",", "buf", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "a", ".", "pipelineInfo", ".", "EnableStats", "{", "buf", ".", "Reset", "(", ")", "\n", "if", "err", ":=", "a", ".", "datumStatsCache", ".", "Merge", "(", "hashtree", ".", "NewWriter", "(", "buf", ")", ",", "nil", ",", "nil", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "return", "a", ".", "chunkStatsCache", ".", "Put", "(", "high", ",", "buf", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// mergeChunk merges the datum hashtrees into a chunk hashtree and stores it.", "docstring_tokens": ["mergeChunk", "merges", "the", "datum", "hashtrees", "into", "a", "chunk", "hashtree", "and", "stores", "it", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/worker/api_server.go#L2219-L2245", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/schedule/schedule.go", "func_name": "Schedule", "original_string": "func (f *fifo) Schedule(j Job) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tif f.cancel == nil {\n\t\tpanic(\"schedule: schedule to stopped scheduler\")\n\t}\n\n\tif len(f.pendings) == 0 {\n\t\tselect {\n\t\tcase f.resume <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\tf.pendings = append(f.pendings, j)\n}", "language": "go", "code": "func (f *fifo) Schedule(j Job) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tif f.cancel == nil {\n\t\tpanic(\"schedule: schedule to stopped scheduler\")\n\t}\n\n\tif len(f.pendings) == 0 {\n\t\tselect {\n\t\tcase f.resume <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\tf.pendings = append(f.pendings, j)\n}", "code_tokens": ["func", "(", "f", "*", "fifo", ")", "Schedule", "(", "j", "Job", ")", "{", "f", ".", "mu", ".", "Lock", "(", ")", "\n", "defer", "f", ".", "mu", ".", "Unlock", "(", ")", "\n\n", "if", "f", ".", "cancel", "==", "nil", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "if", "len", "(", "f", ".", "pendings", ")", "==", "0", "{", "select", "{", "case", "f", ".", "resume", "<-", "struct", "{", "}", "{", "}", ":", "default", ":", "}", "\n", "}", "\n", "f", ".", "pendings", "=", "append", "(", "f", ".", "pendings", ",", "j", ")", "\n", "}"], "docstring": "// Schedule schedules a job that will be ran in FIFO order sequentially.", "docstring_tokens": ["Schedule", "schedules", "a", "job", "that", "will", "be", "ran", "in", "FIFO", "order", "sequentially", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/schedule/schedule.go#L75-L90", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "_metcd/etcd_store.go", "func_name": "Compact", "original_string": "func (s *etcdStore) Compact(ctx context.Context, req *etcdserverpb.CompactionRequest) (*etcdserverpb.CompactionResponse, error) {\n\t// We don't have snapshotting yet, so compact just puts us in a bad state.\n\t// TODO(pb): fix this when we implement snapshotting.\n\treturn nil, errors.New(\"not implemented\")\n}", "language": "go", "code": "func (s *etcdStore) Compact(ctx context.Context, req *etcdserverpb.CompactionRequest) (*etcdserverpb.CompactionResponse, error) {\n\t// We don't have snapshotting yet, so compact just puts us in a bad state.\n\t// TODO(pb): fix this when we implement snapshotting.\n\treturn nil, errors.New(\"not implemented\")\n}", "code_tokens": ["func", "(", "s", "*", "etcdStore", ")", "Compact", "(", "ctx", "context", ".", "Context", ",", "req", "*", "etcdserverpb", ".", "CompactionRequest", ")", "(", "*", "etcdserverpb", ".", "CompactionResponse", ",", "error", ")", "{", "// We don't have snapshotting yet, so compact just puts us in a bad state.", "// TODO(pb): fix this when we implement snapshotting.", "return", "nil", ",", "errors", ".", "New", "(", "\"", "\"", ")", "\n", "}"], "docstring": "// Compact implements gRPC KVServer.\n// Compact compacts the event history in s. User should compact the\n// event history periodically, or it will grow infinitely.", "docstring_tokens": ["Compact", "implements", "gRPC", "KVServer", ".", "Compact", "compacts", "the", "event", "history", "in", "s", ".", "User", "should", "compact", "the", "event", "history", "periodically", "or", "it", "will", "grow", "infinitely", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/_metcd/etcd_store.go#L186-L190", "partition": "test"}
{"repo": "btcsuite/btclog", "path": "log.go", "func_name": "Level", "original_string": "func (l *slog) Level() Level {\n\treturn Level(atomic.LoadUint32((*uint32)(&l.lvl)))\n}", "language": "go", "code": "func (l *slog) Level() Level {\n\treturn Level(atomic.LoadUint32((*uint32)(&l.lvl)))\n}", "code_tokens": ["func", "(", "l", "*", "slog", ")", "Level", "(", ")", "Level", "{", "return", "Level", "(", "atomic", ".", "LoadUint32", "(", "(", "*", "uint32", ")", "(", "&", "l", ".", "lvl", ")", ")", ")", "\n", "}"], "docstring": "// Level returns the current logging level\n//\n// This is part of the Logger interface implementation.", "docstring_tokens": ["Level", "returns", "the", "current", "logging", "level", "This", "is", "part", "of", "the", "Logger", "interface", "implementation", "."], "sha": "84c8d2346e9fc8c7b947e243b9c24e6df9fd206a", "url": "https://github.com/btcsuite/btclog/blob/84c8d2346e9fc8c7b947e243b9c24e6df9fd206a/log.go#L464-L466", "partition": "test"}
{"repo": "mastahyeti/fakeca", "path": "configuration.go", "func_name": "Subject", "original_string": "func Subject(value pkix.Name) Option {\n\treturn func(c *configuration) {\n\t\tc.subject = &value\n\t}\n}", "language": "go", "code": "func Subject(value pkix.Name) Option {\n\treturn func(c *configuration) {\n\t\tc.subject = &value\n\t}\n}", "code_tokens": ["func", "Subject", "(", "value", "pkix", ".", "Name", ")", "Option", "{", "return", "func", "(", "c", "*", "configuration", ")", "{", "c", ".", "subject", "=", "&", "value", "\n", "}", "\n", "}"], "docstring": "// Subject is an Option that sets a identity's subject field.", "docstring_tokens": ["Subject", "is", "an", "Option", "that", "sets", "a", "identity", "s", "subject", "field", "."], "sha": "c1d84b1b473e99212130da7b311dd0605de5ed0a", "url": "https://github.com/mastahyeti/fakeca/blob/c1d84b1b473e99212130da7b311dd0605de5ed0a/configuration.go#L171-L175", "partition": "test"}
{"repo": "mrd0ll4r/tbotapi", "path": "ctors.go", "func_name": "NewOutgoingPhotoResend", "original_string": "func (api *TelegramBotAPI) NewOutgoingPhotoResend(recipient Recipient, fileID string) *OutgoingPhoto {\n\treturn &OutgoingPhoto{\n\t\toutgoingMessageBase: outgoingMessageBase{\n\t\t\toutgoingBase: outgoingBase{\n\t\t\t\tapi:       api,\n\t\t\t\tRecipient: recipient,\n\t\t\t},\n\t\t},\n\t\toutgoingFileBase: outgoingFileBase{\n\t\t\tfileID: fileID,\n\t\t},\n\t}\n}", "language": "go", "code": "func (api *TelegramBotAPI) NewOutgoingPhotoResend(recipient Recipient, fileID string) *OutgoingPhoto {\n\treturn &OutgoingPhoto{\n\t\toutgoingMessageBase: outgoingMessageBase{\n\t\t\toutgoingBase: outgoingBase{\n\t\t\t\tapi:       api,\n\t\t\t\tRecipient: recipient,\n\t\t\t},\n\t\t},\n\t\toutgoingFileBase: outgoingFileBase{\n\t\t\tfileID: fileID,\n\t\t},\n\t}\n}", "code_tokens": ["func", "(", "api", "*", "TelegramBotAPI", ")", "NewOutgoingPhotoResend", "(", "recipient", "Recipient", ",", "fileID", "string", ")", "*", "OutgoingPhoto", "{", "return", "&", "OutgoingPhoto", "{", "outgoingMessageBase", ":", "outgoingMessageBase", "{", "outgoingBase", ":", "outgoingBase", "{", "api", ":", "api", ",", "Recipient", ":", "recipient", ",", "}", ",", "}", ",", "outgoingFileBase", ":", "outgoingFileBase", "{", "fileID", ":", "fileID", ",", "}", ",", "}", "\n", "}"], "docstring": "// NewOutgoingPhotoResend creates a new outgoing photo for re-sending.", "docstring_tokens": ["NewOutgoingPhotoResend", "creates", "a", "new", "outgoing", "photo", "for", "re", "-", "sending", "."], "sha": "edc257282178bb5cebbfcc41260ec04c1ec7ac19", "url": "https://github.com/mrd0ll4r/tbotapi/blob/edc257282178bb5cebbfcc41260ec04c1ec7ac19/ctors.go#L101-L113", "partition": "test"}
{"repo": "segmentio/nsq-go", "path": "nsqlookup/local.go", "func_name": "NewLocalEngine", "original_string": "func NewLocalEngine(config LocalConfig) *LocalEngine {\n\tif config.NodeTimeout == 0 {\n\t\tconfig.NodeTimeout = DefaultLocalEngineNodeTimeout\n\t}\n\n\tif config.TombstoneTimeout == 0 {\n\t\tconfig.TombstoneTimeout = DefaultLocalEngineTombstoneTimeout\n\t}\n\n\te := &LocalEngine{\n\t\tnodeTimeout: config.NodeTimeout,\n\t\ttombTimeout: config.TombstoneTimeout,\n\n\t\tdone: make(chan struct{}),\n\t\tjoin: make(chan struct{}),\n\n\t\tnodes: make(map[string]*LocalNode),\n\t}\n\n\tgo e.run()\n\treturn e\n}", "language": "go", "code": "func NewLocalEngine(config LocalConfig) *LocalEngine {\n\tif config.NodeTimeout == 0 {\n\t\tconfig.NodeTimeout = DefaultLocalEngineNodeTimeout\n\t}\n\n\tif config.TombstoneTimeout == 0 {\n\t\tconfig.TombstoneTimeout = DefaultLocalEngineTombstoneTimeout\n\t}\n\n\te := &LocalEngine{\n\t\tnodeTimeout: config.NodeTimeout,\n\t\ttombTimeout: config.TombstoneTimeout,\n\n\t\tdone: make(chan struct{}),\n\t\tjoin: make(chan struct{}),\n\n\t\tnodes: make(map[string]*LocalNode),\n\t}\n\n\tgo e.run()\n\treturn e\n}", "code_tokens": ["func", "NewLocalEngine", "(", "config", "LocalConfig", ")", "*", "LocalEngine", "{", "if", "config", ".", "NodeTimeout", "==", "0", "{", "config", ".", "NodeTimeout", "=", "DefaultLocalEngineNodeTimeout", "\n", "}", "\n\n", "if", "config", ".", "TombstoneTimeout", "==", "0", "{", "config", ".", "TombstoneTimeout", "=", "DefaultLocalEngineTombstoneTimeout", "\n", "}", "\n\n", "e", ":=", "&", "LocalEngine", "{", "nodeTimeout", ":", "config", ".", "NodeTimeout", ",", "tombTimeout", ":", "config", ".", "TombstoneTimeout", ",", "done", ":", "make", "(", "chan", "struct", "{", "}", ")", ",", "join", ":", "make", "(", "chan", "struct", "{", "}", ")", ",", "nodes", ":", "make", "(", "map", "[", "string", "]", "*", "LocalNode", ")", ",", "}", "\n\n", "go", "e", ".", "run", "(", ")", "\n", "return", "e", "\n", "}"], "docstring": "// NewLocalEngine creates and returns an instance of LocalEngine configured with\n// config.", "docstring_tokens": ["NewLocalEngine", "creates", "and", "returns", "an", "instance", "of", "LocalEngine", "configured", "with", "config", "."], "sha": "ff4eef968f46eb580d9dba4f637c5dfb1e5b2208", "url": "https://github.com/segmentio/nsq-go/blob/ff4eef968f46eb580d9dba4f637c5dfb1e5b2208/nsqlookup/local.go#L52-L73", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "protocol_crypto.go", "func_name": "Receive", "original_string": "func (receiver *gobTCPReceiver) Receive() ([]byte, error) {\n\tvar msg []byte\n\terr := receiver.decoder.Decode(&msg)\n\treturn msg, err\n}", "language": "go", "code": "func (receiver *gobTCPReceiver) Receive() ([]byte, error) {\n\tvar msg []byte\n\terr := receiver.decoder.Decode(&msg)\n\treturn msg, err\n}", "code_tokens": ["func", "(", "receiver", "*", "gobTCPReceiver", ")", "Receive", "(", ")", "(", "[", "]", "byte", ",", "error", ")", "{", "var", "msg", "[", "]", "byte", "\n", "err", ":=", "receiver", ".", "decoder", ".", "Decode", "(", "&", "msg", ")", "\n", "return", "msg", ",", "err", "\n", "}"], "docstring": "// Receive implements TCPReciever by Gob decoding into a byte slice directly.", "docstring_tokens": ["Receive", "implements", "TCPReciever", "by", "Gob", "decoding", "into", "a", "byte", "slice", "directly", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/protocol_crypto.go#L150-L154", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdserver/server.go", "func_name": "configure", "original_string": "func (s *EtcdServer) configure(ctx context.Context, cc raftpb.ConfChange) ([]*membership.Member, error) {\n\tcc.ID = s.reqIDGen.Next()\n\tch := s.w.Register(cc.ID)\n\n\tstart := time.Now()\n\tif err := s.r.ProposeConfChange(ctx, cc); err != nil {\n\t\ts.w.Trigger(cc.ID, nil)\n\t\treturn nil, err\n\t}\n\n\tselect {\n\tcase x := <-ch:\n\t\tif x == nil {\n\t\t\tif lg := s.getLogger(); lg != nil {\n\t\t\t\tlg.Panic(\"failed to configure\")\n\t\t\t} else {\n\t\t\t\tplog.Panicf(\"configure trigger value should never be nil\")\n\t\t\t}\n\t\t}\n\t\tresp := x.(*confChangeResponse)\n\t\tif lg := s.getLogger(); lg != nil {\n\t\t\tlg.Info(\n\t\t\t\t\"applied a configuration change through raft\",\n\t\t\t\tzap.String(\"local-member-id\", s.ID().String()),\n\t\t\t\tzap.String(\"raft-conf-change\", cc.Type.String()),\n\t\t\t\tzap.String(\"raft-conf-change-node-id\", types.ID(cc.NodeID).String()),\n\t\t\t)\n\t\t}\n\t\treturn resp.membs, resp.err\n\n\tcase <-ctx.Done():\n\t\ts.w.Trigger(cc.ID, nil) // GC wait\n\t\treturn nil, s.parseProposeCtxErr(ctx.Err(), start)\n\n\tcase <-s.stopping:\n\t\treturn nil, ErrStopped\n\t}\n}", "language": "go", "code": "func (s *EtcdServer) configure(ctx context.Context, cc raftpb.ConfChange) ([]*membership.Member, error) {\n\tcc.ID = s.reqIDGen.Next()\n\tch := s.w.Register(cc.ID)\n\n\tstart := time.Now()\n\tif err := s.r.ProposeConfChange(ctx, cc); err != nil {\n\t\ts.w.Trigger(cc.ID, nil)\n\t\treturn nil, err\n\t}\n\n\tselect {\n\tcase x := <-ch:\n\t\tif x == nil {\n\t\t\tif lg := s.getLogger(); lg != nil {\n\t\t\t\tlg.Panic(\"failed to configure\")\n\t\t\t} else {\n\t\t\t\tplog.Panicf(\"configure trigger value should never be nil\")\n\t\t\t}\n\t\t}\n\t\tresp := x.(*confChangeResponse)\n\t\tif lg := s.getLogger(); lg != nil {\n\t\t\tlg.Info(\n\t\t\t\t\"applied a configuration change through raft\",\n\t\t\t\tzap.String(\"local-member-id\", s.ID().String()),\n\t\t\t\tzap.String(\"raft-conf-change\", cc.Type.String()),\n\t\t\t\tzap.String(\"raft-conf-change-node-id\", types.ID(cc.NodeID).String()),\n\t\t\t)\n\t\t}\n\t\treturn resp.membs, resp.err\n\n\tcase <-ctx.Done():\n\t\ts.w.Trigger(cc.ID, nil) // GC wait\n\t\treturn nil, s.parseProposeCtxErr(ctx.Err(), start)\n\n\tcase <-s.stopping:\n\t\treturn nil, ErrStopped\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "EtcdServer", ")", "configure", "(", "ctx", "context", ".", "Context", ",", "cc", "raftpb", ".", "ConfChange", ")", "(", "[", "]", "*", "membership", ".", "Member", ",", "error", ")", "{", "cc", ".", "ID", "=", "s", ".", "reqIDGen", ".", "Next", "(", ")", "\n", "ch", ":=", "s", ".", "w", ".", "Register", "(", "cc", ".", "ID", ")", "\n\n", "start", ":=", "time", ".", "Now", "(", ")", "\n", "if", "err", ":=", "s", ".", "r", ".", "ProposeConfChange", "(", "ctx", ",", "cc", ")", ";", "err", "!=", "nil", "{", "s", ".", "w", ".", "Trigger", "(", "cc", ".", "ID", ",", "nil", ")", "\n", "return", "nil", ",", "err", "\n", "}", "\n\n", "select", "{", "case", "x", ":=", "<-", "ch", ":", "if", "x", "==", "nil", "{", "if", "lg", ":=", "s", ".", "getLogger", "(", ")", ";", "lg", "!=", "nil", "{", "lg", ".", "Panic", "(", "\"", "\"", ")", "\n", "}", "else", "{", "plog", ".", "Panicf", "(", "\"", "\"", ")", "\n", "}", "\n", "}", "\n", "resp", ":=", "x", ".", "(", "*", "confChangeResponse", ")", "\n", "if", "lg", ":=", "s", ".", "getLogger", "(", ")", ";", "lg", "!=", "nil", "{", "lg", ".", "Info", "(", "\"", "\"", ",", "zap", ".", "String", "(", "\"", "\"", ",", "s", ".", "ID", "(", ")", ".", "String", "(", ")", ")", ",", "zap", ".", "String", "(", "\"", "\"", ",", "cc", ".", "Type", ".", "String", "(", ")", ")", ",", "zap", ".", "String", "(", "\"", "\"", ",", "types", ".", "ID", "(", "cc", ".", "NodeID", ")", ".", "String", "(", ")", ")", ",", ")", "\n", "}", "\n", "return", "resp", ".", "membs", ",", "resp", ".", "err", "\n\n", "case", "<-", "ctx", ".", "Done", "(", ")", ":", "s", ".", "w", ".", "Trigger", "(", "cc", ".", "ID", ",", "nil", ")", "// GC wait", "\n", "return", "nil", ",", "s", ".", "parseProposeCtxErr", "(", "ctx", ".", "Err", "(", ")", ",", "start", ")", "\n\n", "case", "<-", "s", ".", "stopping", ":", "return", "nil", ",", "ErrStopped", "\n", "}", "\n", "}"], "docstring": "// configure sends a configuration change through consensus and\n// then waits for it to be applied to the server. It\n// will block until the change is performed or there is an error.", "docstring_tokens": ["configure", "sends", "a", "configuration", "change", "through", "consensus", "and", "then", "waits", "for", "it", "to", "be", "applied", "to", "the", "server", ".", "It", "will", "block", "until", "the", "change", "is", "performed", "or", "there", "is", "an", "error", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/server.go#L1737-L1774", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "wal/util.go", "func_name": "searchIndex", "original_string": "func searchIndex(lg *zap.Logger, names []string, index uint64) (int, bool) {\n\tfor i := len(names) - 1; i >= 0; i-- {\n\t\tname := names[i]\n\t\t_, curIndex, err := parseWALName(name)\n\t\tif err != nil {\n\t\t\tif lg != nil {\n\t\t\t\tlg.Panic(\"failed to parse WAL file name\", zap.String(\"path\", name), zap.Error(err))\n\t\t\t} else {\n\t\t\t\tplog.Panicf(\"parse correct name should never fail: %v\", err)\n\t\t\t}\n\t\t}\n\t\tif index >= curIndex {\n\t\t\treturn i, true\n\t\t}\n\t}\n\treturn -1, false\n}", "language": "go", "code": "func searchIndex(lg *zap.Logger, names []string, index uint64) (int, bool) {\n\tfor i := len(names) - 1; i >= 0; i-- {\n\t\tname := names[i]\n\t\t_, curIndex, err := parseWALName(name)\n\t\tif err != nil {\n\t\t\tif lg != nil {\n\t\t\t\tlg.Panic(\"failed to parse WAL file name\", zap.String(\"path\", name), zap.Error(err))\n\t\t\t} else {\n\t\t\t\tplog.Panicf(\"parse correct name should never fail: %v\", err)\n\t\t\t}\n\t\t}\n\t\tif index >= curIndex {\n\t\t\treturn i, true\n\t\t}\n\t}\n\treturn -1, false\n}", "code_tokens": ["func", "searchIndex", "(", "lg", "*", "zap", ".", "Logger", ",", "names", "[", "]", "string", ",", "index", "uint64", ")", "(", "int", ",", "bool", ")", "{", "for", "i", ":=", "len", "(", "names", ")", "-", "1", ";", "i", ">=", "0", ";", "i", "--", "{", "name", ":=", "names", "[", "i", "]", "\n", "_", ",", "curIndex", ",", "err", ":=", "parseWALName", "(", "name", ")", "\n", "if", "err", "!=", "nil", "{", "if", "lg", "!=", "nil", "{", "lg", ".", "Panic", "(", "\"", "\"", ",", "zap", ".", "String", "(", "\"", "\"", ",", "name", ")", ",", "zap", ".", "Error", "(", "err", ")", ")", "\n", "}", "else", "{", "plog", ".", "Panicf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "}", "\n", "if", "index", ">=", "curIndex", "{", "return", "i", ",", "true", "\n", "}", "\n", "}", "\n", "return", "-", "1", ",", "false", "\n", "}"], "docstring": "// searchIndex returns the last array index of names whose raft index section is\n// equal to or smaller than the given index.\n// The given names MUST be sorted.", "docstring_tokens": ["searchIndex", "returns", "the", "last", "array", "index", "of", "names", "whose", "raft", "index", "section", "is", "equal", "to", "or", "smaller", "than", "the", "given", "index", ".", "The", "given", "names", "MUST", "be", "sorted", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/wal/util.go#L41-L57", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewManageOfferSuccessResultOffer", "original_string": "func NewManageOfferSuccessResultOffer(effect ManageOfferEffect, value interface{}) (result ManageOfferSuccessResultOffer, err error) {\n\tresult.Effect = effect\n\tswitch ManageOfferEffect(effect) {\n\tcase ManageOfferEffectManageOfferCreated:\n\t\ttv, ok := value.(OfferEntry)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be OfferEntry\")\n\t\t\treturn\n\t\t}\n\t\tresult.Offer = &tv\n\tcase ManageOfferEffectManageOfferUpdated:\n\t\ttv, ok := value.(OfferEntry)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be OfferEntry\")\n\t\t\treturn\n\t\t}\n\t\tresult.Offer = &tv\n\tdefault:\n\t\t// void\n\t}\n\treturn\n}", "language": "go", "code": "func NewManageOfferSuccessResultOffer(effect ManageOfferEffect, value interface{}) (result ManageOfferSuccessResultOffer, err error) {\n\tresult.Effect = effect\n\tswitch ManageOfferEffect(effect) {\n\tcase ManageOfferEffectManageOfferCreated:\n\t\ttv, ok := value.(OfferEntry)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be OfferEntry\")\n\t\t\treturn\n\t\t}\n\t\tresult.Offer = &tv\n\tcase ManageOfferEffectManageOfferUpdated:\n\t\ttv, ok := value.(OfferEntry)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be OfferEntry\")\n\t\t\treturn\n\t\t}\n\t\tresult.Offer = &tv\n\tdefault:\n\t\t// void\n\t}\n\treturn\n}", "code_tokens": ["func", "NewManageOfferSuccessResultOffer", "(", "effect", "ManageOfferEffect", ",", "value", "interface", "{", "}", ")", "(", "result", "ManageOfferSuccessResultOffer", ",", "err", "error", ")", "{", "result", ".", "Effect", "=", "effect", "\n", "switch", "ManageOfferEffect", "(", "effect", ")", "{", "case", "ManageOfferEffectManageOfferCreated", ":", "tv", ",", "ok", ":=", "value", ".", "(", "OfferEntry", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Offer", "=", "&", "tv", "\n", "case", "ManageOfferEffectManageOfferUpdated", ":", "tv", ",", "ok", ":=", "value", ".", "(", "OfferEntry", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "Offer", "=", "&", "tv", "\n", "default", ":", "// void", "}", "\n", "return", "\n", "}"], "docstring": "// NewManageOfferSuccessResultOffer creates a new  ManageOfferSuccessResultOffer.", "docstring_tokens": ["NewManageOfferSuccessResultOffer", "creates", "a", "new", "ManageOfferSuccessResultOffer", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L3024-L3045", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "quota/quota.go", "func_name": "SetLimit", "original_string": "func (s *QuotaService) SetLimit(appName string, limit int) error {\n\tq, err := s.Storage.Get(appName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif limit < 0 {\n\t\tlimit = -1\n\t} else if limit < q.InUse {\n\t\treturn quota.ErrLimitLowerThanAllocated\n\t}\n\treturn s.Storage.SetLimit(appName, limit)\n}", "language": "go", "code": "func (s *QuotaService) SetLimit(appName string, limit int) error {\n\tq, err := s.Storage.Get(appName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif limit < 0 {\n\t\tlimit = -1\n\t} else if limit < q.InUse {\n\t\treturn quota.ErrLimitLowerThanAllocated\n\t}\n\treturn s.Storage.SetLimit(appName, limit)\n}", "code_tokens": ["func", "(", "s", "*", "QuotaService", ")", "SetLimit", "(", "appName", "string", ",", "limit", "int", ")", "error", "{", "q", ",", "err", ":=", "s", ".", "Storage", ".", "Get", "(", "appName", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "if", "limit", "<", "0", "{", "limit", "=", "-", "1", "\n", "}", "else", "if", "limit", "<", "q", ".", "InUse", "{", "return", "quota", ".", "ErrLimitLowerThanAllocated", "\n", "}", "\n", "return", "s", ".", "Storage", ".", "SetLimit", "(", "appName", ",", "limit", ")", "\n", "}"], "docstring": "// SetLimit redefines the limit of the app. The new limit must be bigger\n// than or equal to the current number of units in the app. The new limit may be\n// smaller than 0, which means that the app should have an unlimited number of\n// units.\n// SetLimit implements SetLimit method from QuotaService interface", "docstring_tokens": ["SetLimit", "redefines", "the", "limit", "of", "the", "app", ".", "The", "new", "limit", "must", "be", "bigger", "than", "or", "equal", "to", "the", "current", "number", "of", "units", "in", "the", "app", ".", "The", "new", "limit", "may", "be", "smaller", "than", "0", "which", "means", "that", "the", "app", "should", "have", "an", "unlimited", "number", "of", "units", ".", "SetLimit", "implements", "SetLimit", "method", "from", "QuotaService", "interface"], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/quota/quota.go#L46-L57", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_containers.go", "func_name": "UpdateContainerState", "original_string": "func (r *ProtocolLXD) UpdateContainerState(name string, state api.ContainerStatePut, ETag string) (Operation, error) {\n\t// Send the request\n\top, _, err := r.queryOperation(\"PUT\", fmt.Sprintf(\"/containers/%s/state\", url.QueryEscape(name)), state, ETag)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "language": "go", "code": "func (r *ProtocolLXD) UpdateContainerState(name string, state api.ContainerStatePut, ETag string) (Operation, error) {\n\t// Send the request\n\top, _, err := r.queryOperation(\"PUT\", fmt.Sprintf(\"/containers/%s/state\", url.QueryEscape(name)), state, ETag)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn op, nil\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "UpdateContainerState", "(", "name", "string", ",", "state", "api", ".", "ContainerStatePut", ",", "ETag", "string", ")", "(", "Operation", ",", "error", ")", "{", "// Send the request", "op", ",", "_", ",", "err", ":=", "r", ".", "queryOperation", "(", "\"", "\"", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "url", ".", "QueryEscape", "(", "name", ")", ")", ",", "state", ",", "ETag", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "op", ",", "nil", "\n", "}"], "docstring": "// UpdateContainerState updates the container to match the requested state", "docstring_tokens": ["UpdateContainerState", "updates", "the", "container", "to", "match", "the", "requested", "state"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_containers.go#L1390-L1398", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "typed/reader.go", "func_name": "ReadUint16", "original_string": "func (r *Reader) ReadUint16() uint16 {\n\tif r.err != nil {\n\t\treturn 0\n\t}\n\n\tbuf := r.buf[:2]\n\n\tvar readN int\n\treadN, r.err = io.ReadFull(r.reader, buf)\n\tif readN < 2 {\n\t\treturn 0\n\t}\n\treturn binary.BigEndian.Uint16(buf)\n}", "language": "go", "code": "func (r *Reader) ReadUint16() uint16 {\n\tif r.err != nil {\n\t\treturn 0\n\t}\n\n\tbuf := r.buf[:2]\n\n\tvar readN int\n\treadN, r.err = io.ReadFull(r.reader, buf)\n\tif readN < 2 {\n\t\treturn 0\n\t}\n\treturn binary.BigEndian.Uint16(buf)\n}", "code_tokens": ["func", "(", "r", "*", "Reader", ")", "ReadUint16", "(", ")", "uint16", "{", "if", "r", ".", "err", "!=", "nil", "{", "return", "0", "\n", "}", "\n\n", "buf", ":=", "r", ".", "buf", "[", ":", "2", "]", "\n\n", "var", "readN", "int", "\n", "readN", ",", "r", ".", "err", "=", "io", ".", "ReadFull", "(", "r", ".", "reader", ",", "buf", ")", "\n", "if", "readN", "<", "2", "{", "return", "0", "\n", "}", "\n", "return", "binary", ".", "BigEndian", ".", "Uint16", "(", "buf", ")", "\n", "}"], "docstring": "// ReadUint16 reads a uint16.", "docstring_tokens": ["ReadUint16", "reads", "a", "uint16", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/typed/reader.go#L53-L66", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "cmd/gazelle/metaresolver.go", "func_name": "AddBuiltin", "original_string": "func (mr *metaResolver) AddBuiltin(kindName string, resolver resolve.Resolver) {\n\tmr.builtins[kindName] = resolver\n}", "language": "go", "code": "func (mr *metaResolver) AddBuiltin(kindName string, resolver resolve.Resolver) {\n\tmr.builtins[kindName] = resolver\n}", "code_tokens": ["func", "(", "mr", "*", "metaResolver", ")", "AddBuiltin", "(", "kindName", "string", ",", "resolver", "resolve", ".", "Resolver", ")", "{", "mr", ".", "builtins", "[", "kindName", "]", "=", "resolver", "\n", "}"], "docstring": "// AddBuiltin registers a builtin kind with its info.", "docstring_tokens": ["AddBuiltin", "registers", "a", "builtin", "kind", "with", "its", "info", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/cmd/gazelle/metaresolver.go#L41-L43", "partition": "test"}
{"repo": "rightscale/rsc", "path": "cm15/codegen_client.go", "func_name": "MultiCloudImageSettingLocator", "original_string": "func (api *API) MultiCloudImageSettingLocator(href string) *MultiCloudImageSettingLocator {\n\treturn &MultiCloudImageSettingLocator{Href(href), api}\n}", "language": "go", "code": "func (api *API) MultiCloudImageSettingLocator(href string) *MultiCloudImageSettingLocator {\n\treturn &MultiCloudImageSettingLocator{Href(href), api}\n}", "code_tokens": ["func", "(", "api", "*", "API", ")", "MultiCloudImageSettingLocator", "(", "href", "string", ")", "*", "MultiCloudImageSettingLocator", "{", "return", "&", "MultiCloudImageSettingLocator", "{", "Href", "(", "href", ")", ",", "api", "}", "\n", "}"], "docstring": "// MultiCloudImageSettingLocator builds a locator from the given href.", "docstring_tokens": ["MultiCloudImageSettingLocator", "builds", "a", "locator", "from", "the", "given", "href", "."], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/cm15/codegen_client.go#L5925-L5927", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nodetable/table.go", "func_name": "Update", "original_string": "func (nt *NodeTable) Update(key []byte, nptr unsafe.Pointer) (updated bool, oldPtr unsafe.Pointer) {\n\tres := nt.find(key)\n\tif res.status&ntFoundMask == ntFoundMask {\n\t\t// Found key, replace old pointer value with new one\n\t\tupdated = true\n\t\tif res.status == ntFoundInFast {\n\t\t\toldPtr = decodePointer(res.fastHTValue)\n\t\t\tnt.fastHT[res.hash] = encodePointer(nptr, res.hasConflict)\n\t\t} else {\n\t\t\toldPtr = decodePointer(res.slowHTValues[res.slowHTPos])\n\t\t\tres.slowHTValues[res.slowHTPos] = encodePointer(nptr, true)\n\t\t}\n\t} else {\n\t\t// Insert new key\n\t\tupdated = false\n\t\tnewSlowValue := res.fastHTHasEntry && !res.hasConflict\n\t\t// Key needs to be inserted into slowHT\n\t\tif res.hasConflict || newSlowValue {\n\t\t\tslowHTValues := nt.slowHT[res.hash]\n\t\t\tslowHTValues = append(slowHTValues, encodePointer(nptr, false))\n\t\t\tnt.slowHT[res.hash] = slowHTValues\n\t\t\t// There is an entry already in the fastHT for same crc32 hash\n\t\t\t// We have inserted first entry into the slowHT. Now mark conflict bit.\n\t\t\tif newSlowValue {\n\t\t\t\tnt.fastHT[res.hash] = encodePointer(decodePointer(nt.fastHT[res.hash]), true)\n\t\t\t\tnt.conflicts++\n\t\t\t}\n\t\t\tnt.slowHTCount++\n\t\t} else {\n\t\t\t// Insert new item into fastHT\n\t\t\tnt.fastHT[res.hash] = encodePointer(nptr, false)\n\t\t\tnt.fastHTCount++\n\t\t}\n\t}\n\n\treturn\n}", "language": "go", "code": "func (nt *NodeTable) Update(key []byte, nptr unsafe.Pointer) (updated bool, oldPtr unsafe.Pointer) {\n\tres := nt.find(key)\n\tif res.status&ntFoundMask == ntFoundMask {\n\t\t// Found key, replace old pointer value with new one\n\t\tupdated = true\n\t\tif res.status == ntFoundInFast {\n\t\t\toldPtr = decodePointer(res.fastHTValue)\n\t\t\tnt.fastHT[res.hash] = encodePointer(nptr, res.hasConflict)\n\t\t} else {\n\t\t\toldPtr = decodePointer(res.slowHTValues[res.slowHTPos])\n\t\t\tres.slowHTValues[res.slowHTPos] = encodePointer(nptr, true)\n\t\t}\n\t} else {\n\t\t// Insert new key\n\t\tupdated = false\n\t\tnewSlowValue := res.fastHTHasEntry && !res.hasConflict\n\t\t// Key needs to be inserted into slowHT\n\t\tif res.hasConflict || newSlowValue {\n\t\t\tslowHTValues := nt.slowHT[res.hash]\n\t\t\tslowHTValues = append(slowHTValues, encodePointer(nptr, false))\n\t\t\tnt.slowHT[res.hash] = slowHTValues\n\t\t\t// There is an entry already in the fastHT for same crc32 hash\n\t\t\t// We have inserted first entry into the slowHT. Now mark conflict bit.\n\t\t\tif newSlowValue {\n\t\t\t\tnt.fastHT[res.hash] = encodePointer(decodePointer(nt.fastHT[res.hash]), true)\n\t\t\t\tnt.conflicts++\n\t\t\t}\n\t\t\tnt.slowHTCount++\n\t\t} else {\n\t\t\t// Insert new item into fastHT\n\t\t\tnt.fastHT[res.hash] = encodePointer(nptr, false)\n\t\t\tnt.fastHTCount++\n\t\t}\n\t}\n\n\treturn\n}", "code_tokens": ["func", "(", "nt", "*", "NodeTable", ")", "Update", "(", "key", "[", "]", "byte", ",", "nptr", "unsafe", ".", "Pointer", ")", "(", "updated", "bool", ",", "oldPtr", "unsafe", ".", "Pointer", ")", "{", "res", ":=", "nt", ".", "find", "(", "key", ")", "\n", "if", "res", ".", "status", "&", "ntFoundMask", "==", "ntFoundMask", "{", "// Found key, replace old pointer value with new one", "updated", "=", "true", "\n", "if", "res", ".", "status", "==", "ntFoundInFast", "{", "oldPtr", "=", "decodePointer", "(", "res", ".", "fastHTValue", ")", "\n", "nt", ".", "fastHT", "[", "res", ".", "hash", "]", "=", "encodePointer", "(", "nptr", ",", "res", ".", "hasConflict", ")", "\n", "}", "else", "{", "oldPtr", "=", "decodePointer", "(", "res", ".", "slowHTValues", "[", "res", ".", "slowHTPos", "]", ")", "\n", "res", ".", "slowHTValues", "[", "res", ".", "slowHTPos", "]", "=", "encodePointer", "(", "nptr", ",", "true", ")", "\n", "}", "\n", "}", "else", "{", "// Insert new key", "updated", "=", "false", "\n", "newSlowValue", ":=", "res", ".", "fastHTHasEntry", "&&", "!", "res", ".", "hasConflict", "\n", "// Key needs to be inserted into slowHT", "if", "res", ".", "hasConflict", "||", "newSlowValue", "{", "slowHTValues", ":=", "nt", ".", "slowHT", "[", "res", ".", "hash", "]", "\n", "slowHTValues", "=", "append", "(", "slowHTValues", ",", "encodePointer", "(", "nptr", ",", "false", ")", ")", "\n", "nt", ".", "slowHT", "[", "res", ".", "hash", "]", "=", "slowHTValues", "\n", "// There is an entry already in the fastHT for same crc32 hash", "// We have inserted first entry into the slowHT. Now mark conflict bit.", "if", "newSlowValue", "{", "nt", ".", "fastHT", "[", "res", ".", "hash", "]", "=", "encodePointer", "(", "decodePointer", "(", "nt", ".", "fastHT", "[", "res", ".", "hash", "]", ")", ",", "true", ")", "\n", "nt", ".", "conflicts", "++", "\n", "}", "\n", "nt", ".", "slowHTCount", "++", "\n", "}", "else", "{", "// Insert new item into fastHT", "nt", ".", "fastHT", "[", "res", ".", "hash", "]", "=", "encodePointer", "(", "nptr", ",", "false", ")", "\n", "nt", ".", "fastHTCount", "++", "\n", "}", "\n", "}", "\n\n", "return", "\n", "}"], "docstring": "// Update inserts or replaces an existing entry", "docstring_tokens": ["Update", "inserts", "or", "replaces", "an", "existing", "entry"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nodetable/table.go#L123-L159", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/containers.go", "func_name": "ContainerGetSnapshots", "original_string": "func (c *Cluster) ContainerGetSnapshots(project, name string) ([]string, error) {\n\tresult := []string{}\n\n\tregexp := name + shared.SnapshotDelimiter\n\tlength := len(regexp)\n\tq := `\nSELECT containers.name\n  FROM containers\n  JOIN projects ON projects.id = containers.project_id\nWHERE projects.name=? AND containers.type=? AND SUBSTR(containers.name,1,?)=?\n`\n\tinargs := []interface{}{project, CTypeSnapshot, length, regexp}\n\toutfmt := []interface{}{name}\n\tdbResults, err := queryScan(c.db, q, inargs, outfmt)\n\tif err != nil {\n\t\treturn result, err\n\t}\n\n\tfor _, r := range dbResults {\n\t\tresult = append(result, r[0].(string))\n\t}\n\n\treturn result, nil\n}", "language": "go", "code": "func (c *Cluster) ContainerGetSnapshots(project, name string) ([]string, error) {\n\tresult := []string{}\n\n\tregexp := name + shared.SnapshotDelimiter\n\tlength := len(regexp)\n\tq := `\nSELECT containers.name\n  FROM containers\n  JOIN projects ON projects.id = containers.project_id\nWHERE projects.name=? AND containers.type=? AND SUBSTR(containers.name,1,?)=?\n`\n\tinargs := []interface{}{project, CTypeSnapshot, length, regexp}\n\toutfmt := []interface{}{name}\n\tdbResults, err := queryScan(c.db, q, inargs, outfmt)\n\tif err != nil {\n\t\treturn result, err\n\t}\n\n\tfor _, r := range dbResults {\n\t\tresult = append(result, r[0].(string))\n\t}\n\n\treturn result, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "ContainerGetSnapshots", "(", "project", ",", "name", "string", ")", "(", "[", "]", "string", ",", "error", ")", "{", "result", ":=", "[", "]", "string", "{", "}", "\n\n", "regexp", ":=", "name", "+", "shared", ".", "SnapshotDelimiter", "\n", "length", ":=", "len", "(", "regexp", ")", "\n", "q", ":=", "`\nSELECT containers.name\n  FROM containers\n  JOIN projects ON projects.id = containers.project_id\nWHERE projects.name=? AND containers.type=? AND SUBSTR(containers.name,1,?)=?\n`", "\n", "inargs", ":=", "[", "]", "interface", "{", "}", "{", "project", ",", "CTypeSnapshot", ",", "length", ",", "regexp", "}", "\n", "outfmt", ":=", "[", "]", "interface", "{", "}", "{", "name", "}", "\n", "dbResults", ",", "err", ":=", "queryScan", "(", "c", ".", "db", ",", "q", ",", "inargs", ",", "outfmt", ")", "\n", "if", "err", "!=", "nil", "{", "return", "result", ",", "err", "\n", "}", "\n\n", "for", "_", ",", "r", ":=", "range", "dbResults", "{", "result", "=", "append", "(", "result", ",", "r", "[", "0", "]", ".", "(", "string", ")", ")", "\n", "}", "\n\n", "return", "result", ",", "nil", "\n", "}"], "docstring": "// ContainerGetSnapshots returns the names of all snapshots of the container\n// in the given project with the given name.", "docstring_tokens": ["ContainerGetSnapshots", "returns", "the", "names", "of", "all", "snapshots", "of", "the", "container", "in", "the", "given", "project", "with", "the", "given", "name", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/containers.go#L859-L882", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/cert/logging_conn.go", "func_name": "Write", "original_string": "func (l *loggingConn) Write(b []byte) (n int, err error) {\n\treturn l.w.Write(b)\n}", "language": "go", "code": "func (l *loggingConn) Write(b []byte) (n int, err error) {\n\treturn l.w.Write(b)\n}", "code_tokens": ["func", "(", "l", "*", "loggingConn", ")", "Write", "(", "b", "[", "]", "byte", ")", "(", "n", "int", ",", "err", "error", ")", "{", "return", "l", ".", "w", ".", "Write", "(", "b", ")", "\n", "}"], "docstring": "// Write implements the corresponding method of net.Conn", "docstring_tokens": ["Write", "implements", "the", "corresponding", "method", "of", "net", ".", "Conn"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/cert/logging_conn.go#L94-L96", "partition": "test"}
{"repo": "rightscale/rsc", "path": "gen/writers/helpers.go", "func_name": "toVerb", "original_string": "func toVerb(text string) (res string) {\n\tres = strings.ToUpper(string(text[0])) + strings.ToLower(text[1:])\n\tif text == \"GET\" || text == \"POST\" {\n\t\tres += \"Raw\"\n\t}\n\treturn\n}", "language": "go", "code": "func toVerb(text string) (res string) {\n\tres = strings.ToUpper(string(text[0])) + strings.ToLower(text[1:])\n\tif text == \"GET\" || text == \"POST\" {\n\t\tres += \"Raw\"\n\t}\n\treturn\n}", "code_tokens": ["func", "toVerb", "(", "text", "string", ")", "(", "res", "string", ")", "{", "res", "=", "strings", ".", "ToUpper", "(", "string", "(", "text", "[", "0", "]", ")", ")", "+", "strings", ".", "ToLower", "(", "text", "[", "1", ":", "]", ")", "\n", "if", "text", "==", "\"", "\"", "||", "text", "==", "\"", "\"", "{", "res", "+=", "\"", "\"", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// GET => Get", "docstring_tokens": ["GET", "=", ">", "Get"], "sha": "96079a1ee7238dae9cbb7efa77dd94a479d217bd", "url": "https://github.com/rightscale/rsc/blob/96079a1ee7238dae9cbb7efa77dd94a479d217bd/gen/writers/helpers.go#L174-L180", "partition": "test"}
{"repo": "segmentio/objconv", "path": "json/decode.go", "func_name": "Unmarshal", "original_string": "func Unmarshal(b []byte, v interface{}) error {\n\tu := unmarshalerPool.Get().(*unmarshaler)\n\tu.reset(b)\n\n\terr := (objconv.Decoder{Parser: u}).Decode(v)\n\n\tu.reset(nil)\n\tunmarshalerPool.Put(u)\n\treturn err\n}", "language": "go", "code": "func Unmarshal(b []byte, v interface{}) error {\n\tu := unmarshalerPool.Get().(*unmarshaler)\n\tu.reset(b)\n\n\terr := (objconv.Decoder{Parser: u}).Decode(v)\n\n\tu.reset(nil)\n\tunmarshalerPool.Put(u)\n\treturn err\n}", "code_tokens": ["func", "Unmarshal", "(", "b", "[", "]", "byte", ",", "v", "interface", "{", "}", ")", "error", "{", "u", ":=", "unmarshalerPool", ".", "Get", "(", ")", ".", "(", "*", "unmarshaler", ")", "\n", "u", ".", "reset", "(", "b", ")", "\n\n", "err", ":=", "(", "objconv", ".", "Decoder", "{", "Parser", ":", "u", "}", ")", ".", "Decode", "(", "v", ")", "\n\n", "u", ".", "reset", "(", "nil", ")", "\n", "unmarshalerPool", ".", "Put", "(", "u", ")", "\n", "return", "err", "\n", "}"], "docstring": "// Unmarshal decodes a JSON representation of v from b.", "docstring_tokens": ["Unmarshal", "decodes", "a", "JSON", "representation", "of", "v", "from", "b", "."], "sha": "7a1d7b8e6f3551b30751e6b2ea6bae500883870e", "url": "https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/json/decode.go#L22-L31", "partition": "test"}
{"repo": "hashicorp/raft", "path": "tcp_transport.go", "func_name": "NewTCPTransportWithLogger", "original_string": "func NewTCPTransportWithLogger(\n\tbindAddr string,\n\tadvertise net.Addr,\n\tmaxPool int,\n\ttimeout time.Duration,\n\tlogger *log.Logger,\n) (*NetworkTransport, error) {\n\treturn newTCPTransport(bindAddr, advertise, func(stream StreamLayer) *NetworkTransport {\n\t\treturn NewNetworkTransportWithLogger(stream, maxPool, timeout, logger)\n\t})\n}", "language": "go", "code": "func NewTCPTransportWithLogger(\n\tbindAddr string,\n\tadvertise net.Addr,\n\tmaxPool int,\n\ttimeout time.Duration,\n\tlogger *log.Logger,\n) (*NetworkTransport, error) {\n\treturn newTCPTransport(bindAddr, advertise, func(stream StreamLayer) *NetworkTransport {\n\t\treturn NewNetworkTransportWithLogger(stream, maxPool, timeout, logger)\n\t})\n}", "code_tokens": ["func", "NewTCPTransportWithLogger", "(", "bindAddr", "string", ",", "advertise", "net", ".", "Addr", ",", "maxPool", "int", ",", "timeout", "time", ".", "Duration", ",", "logger", "*", "log", ".", "Logger", ",", ")", "(", "*", "NetworkTransport", ",", "error", ")", "{", "return", "newTCPTransport", "(", "bindAddr", ",", "advertise", ",", "func", "(", "stream", "StreamLayer", ")", "*", "NetworkTransport", "{", "return", "NewNetworkTransportWithLogger", "(", "stream", ",", "maxPool", ",", "timeout", ",", "logger", ")", "\n", "}", ")", "\n", "}"], "docstring": "// NewTCPTransportWithLogger returns a NetworkTransport that is built on top of\n// a TCP streaming transport layer, with log output going to the supplied Logger", "docstring_tokens": ["NewTCPTransportWithLogger", "returns", "a", "NetworkTransport", "that", "is", "built", "on", "top", "of", "a", "TCP", "streaming", "transport", "layer", "with", "log", "output", "going", "to", "the", "supplied", "Logger"], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/tcp_transport.go#L38-L48", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/container_lxc.go", "func_name": "containerLXCUnload", "original_string": "func containerLXCUnload(c *containerLXC) {\n\truntime.SetFinalizer(c, nil)\n\tif c.c != nil {\n\t\tc.c.Release()\n\t\tc.c = nil\n\t}\n}", "language": "go", "code": "func containerLXCUnload(c *containerLXC) {\n\truntime.SetFinalizer(c, nil)\n\tif c.c != nil {\n\t\tc.c.Release()\n\t\tc.c = nil\n\t}\n}", "code_tokens": ["func", "containerLXCUnload", "(", "c", "*", "containerLXC", ")", "{", "runtime", ".", "SetFinalizer", "(", "c", ",", "nil", ")", "\n", "if", "c", ".", "c", "!=", "nil", "{", "c", ".", "c", ".", "Release", "(", ")", "\n", "c", ".", "c", "=", "nil", "\n", "}", "\n", "}"], "docstring": "// Unload is called by the garbage collector", "docstring_tokens": ["Unload", "is", "called", "by", "the", "garbage", "collector"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/container_lxc.go#L512-L518", "partition": "test"}
{"repo": "xwb1989/sqlparser", "path": "analyzer.go", "func_name": "Preview", "original_string": "func Preview(sql string) int {\n\ttrimmed := StripLeadingComments(sql)\n\n\tfirstWord := trimmed\n\tif end := strings.IndexFunc(trimmed, unicode.IsSpace); end != -1 {\n\t\tfirstWord = trimmed[:end]\n\t}\n\tfirstWord = strings.TrimLeftFunc(firstWord, func(r rune) bool { return !unicode.IsLetter(r) })\n\t// Comparison is done in order of priority.\n\tloweredFirstWord := strings.ToLower(firstWord)\n\tswitch loweredFirstWord {\n\tcase \"select\":\n\t\treturn StmtSelect\n\tcase \"stream\":\n\t\treturn StmtStream\n\tcase \"insert\":\n\t\treturn StmtInsert\n\tcase \"replace\":\n\t\treturn StmtReplace\n\tcase \"update\":\n\t\treturn StmtUpdate\n\tcase \"delete\":\n\t\treturn StmtDelete\n\t}\n\t// For the following statements it is not sufficient to rely\n\t// on loweredFirstWord. This is because they are not statements\n\t// in the grammar and we are relying on Preview to parse them.\n\t// For instance, we don't want: \"BEGIN JUNK\" to be parsed\n\t// as StmtBegin.\n\ttrimmedNoComments, _ := SplitMarginComments(trimmed)\n\tswitch strings.ToLower(trimmedNoComments) {\n\tcase \"begin\", \"start transaction\":\n\t\treturn StmtBegin\n\tcase \"commit\":\n\t\treturn StmtCommit\n\tcase \"rollback\":\n\t\treturn StmtRollback\n\t}\n\tswitch loweredFirstWord {\n\tcase \"create\", \"alter\", \"rename\", \"drop\", \"truncate\":\n\t\treturn StmtDDL\n\tcase \"set\":\n\t\treturn StmtSet\n\tcase \"show\":\n\t\treturn StmtShow\n\tcase \"use\":\n\t\treturn StmtUse\n\tcase \"analyze\", \"describe\", \"desc\", \"explain\", \"repair\", \"optimize\":\n\t\treturn StmtOther\n\t}\n\tif strings.Index(trimmed, \"/*!\") == 0 {\n\t\treturn StmtComment\n\t}\n\treturn StmtUnknown\n}", "language": "go", "code": "func Preview(sql string) int {\n\ttrimmed := StripLeadingComments(sql)\n\n\tfirstWord := trimmed\n\tif end := strings.IndexFunc(trimmed, unicode.IsSpace); end != -1 {\n\t\tfirstWord = trimmed[:end]\n\t}\n\tfirstWord = strings.TrimLeftFunc(firstWord, func(r rune) bool { return !unicode.IsLetter(r) })\n\t// Comparison is done in order of priority.\n\tloweredFirstWord := strings.ToLower(firstWord)\n\tswitch loweredFirstWord {\n\tcase \"select\":\n\t\treturn StmtSelect\n\tcase \"stream\":\n\t\treturn StmtStream\n\tcase \"insert\":\n\t\treturn StmtInsert\n\tcase \"replace\":\n\t\treturn StmtReplace\n\tcase \"update\":\n\t\treturn StmtUpdate\n\tcase \"delete\":\n\t\treturn StmtDelete\n\t}\n\t// For the following statements it is not sufficient to rely\n\t// on loweredFirstWord. This is because they are not statements\n\t// in the grammar and we are relying on Preview to parse them.\n\t// For instance, we don't want: \"BEGIN JUNK\" to be parsed\n\t// as StmtBegin.\n\ttrimmedNoComments, _ := SplitMarginComments(trimmed)\n\tswitch strings.ToLower(trimmedNoComments) {\n\tcase \"begin\", \"start transaction\":\n\t\treturn StmtBegin\n\tcase \"commit\":\n\t\treturn StmtCommit\n\tcase \"rollback\":\n\t\treturn StmtRollback\n\t}\n\tswitch loweredFirstWord {\n\tcase \"create\", \"alter\", \"rename\", \"drop\", \"truncate\":\n\t\treturn StmtDDL\n\tcase \"set\":\n\t\treturn StmtSet\n\tcase \"show\":\n\t\treturn StmtShow\n\tcase \"use\":\n\t\treturn StmtUse\n\tcase \"analyze\", \"describe\", \"desc\", \"explain\", \"repair\", \"optimize\":\n\t\treturn StmtOther\n\t}\n\tif strings.Index(trimmed, \"/*!\") == 0 {\n\t\treturn StmtComment\n\t}\n\treturn StmtUnknown\n}", "code_tokens": ["func", "Preview", "(", "sql", "string", ")", "int", "{", "trimmed", ":=", "StripLeadingComments", "(", "sql", ")", "\n\n", "firstWord", ":=", "trimmed", "\n", "if", "end", ":=", "strings", ".", "IndexFunc", "(", "trimmed", ",", "unicode", ".", "IsSpace", ")", ";", "end", "!=", "-", "1", "{", "firstWord", "=", "trimmed", "[", ":", "end", "]", "\n", "}", "\n", "firstWord", "=", "strings", ".", "TrimLeftFunc", "(", "firstWord", ",", "func", "(", "r", "rune", ")", "bool", "{", "return", "!", "unicode", ".", "IsLetter", "(", "r", ")", "}", ")", "\n", "// Comparison is done in order of priority.", "loweredFirstWord", ":=", "strings", ".", "ToLower", "(", "firstWord", ")", "\n", "switch", "loweredFirstWord", "{", "case", "\"", "\"", ":", "return", "StmtSelect", "\n", "case", "\"", "\"", ":", "return", "StmtStream", "\n", "case", "\"", "\"", ":", "return", "StmtInsert", "\n", "case", "\"", "\"", ":", "return", "StmtReplace", "\n", "case", "\"", "\"", ":", "return", "StmtUpdate", "\n", "case", "\"", "\"", ":", "return", "StmtDelete", "\n", "}", "\n", "// For the following statements it is not sufficient to rely", "// on loweredFirstWord. This is because they are not statements", "// in the grammar and we are relying on Preview to parse them.", "// For instance, we don't want: \"BEGIN JUNK\" to be parsed", "// as StmtBegin.", "trimmedNoComments", ",", "_", ":=", "SplitMarginComments", "(", "trimmed", ")", "\n", "switch", "strings", ".", "ToLower", "(", "trimmedNoComments", ")", "{", "case", "\"", "\"", ",", "\"", "\"", ":", "return", "StmtBegin", "\n", "case", "\"", "\"", ":", "return", "StmtCommit", "\n", "case", "\"", "\"", ":", "return", "StmtRollback", "\n", "}", "\n", "switch", "loweredFirstWord", "{", "case", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ":", "return", "StmtDDL", "\n", "case", "\"", "\"", ":", "return", "StmtSet", "\n", "case", "\"", "\"", ":", "return", "StmtShow", "\n", "case", "\"", "\"", ":", "return", "StmtUse", "\n", "case", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ":", "return", "StmtOther", "\n", "}", "\n", "if", "strings", ".", "Index", "(", "trimmed", ",", "\"", "\"", ")", "==", "0", "{", "return", "StmtComment", "\n", "}", "\n", "return", "StmtUnknown", "\n", "}"], "docstring": "// Preview analyzes the beginning of the query using a simpler and faster\n// textual comparison to identify the statement type.", "docstring_tokens": ["Preview", "analyzes", "the", "beginning", "of", "the", "query", "using", "a", "simpler", "and", "faster", "textual", "comparison", "to", "identify", "the", "statement", "type", "."], "sha": "120387863bf27d04bc07db8015110a6e96d0146c", "url": "https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/analyzer.go#L53-L107", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "pkg/srv/srv.go", "func_name": "GetClient", "original_string": "func GetClient(service, domain string, serviceName string) (*SRVClients, error) {\n\tvar urls []*url.URL\n\tvar srvs []*net.SRV\n\n\tupdateURLs := func(service, scheme string) error {\n\t\t_, addrs, err := lookupSRV(service, \"tcp\", domain)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, srv := range addrs {\n\t\t\turls = append(urls, &url.URL{\n\t\t\t\tScheme: scheme,\n\t\t\t\tHost:   net.JoinHostPort(srv.Target, fmt.Sprintf(\"%d\", srv.Port)),\n\t\t\t})\n\t\t}\n\t\tsrvs = append(srvs, addrs...)\n\t\treturn nil\n\t}\n\n\terrHTTPS := updateURLs(GetSRVService(service, serviceName, \"https\"), \"https\")\n\terrHTTP := updateURLs(GetSRVService(service, serviceName, \"http\"), \"http\")\n\n\tif errHTTPS != nil && errHTTP != nil {\n\t\treturn nil, fmt.Errorf(\"dns lookup errors: %s and %s\", errHTTPS, errHTTP)\n\t}\n\n\tendpoints := make([]string, len(urls))\n\tfor i := range urls {\n\t\tendpoints[i] = urls[i].String()\n\t}\n\treturn &SRVClients{Endpoints: endpoints, SRVs: srvs}, nil\n}", "language": "go", "code": "func GetClient(service, domain string, serviceName string) (*SRVClients, error) {\n\tvar urls []*url.URL\n\tvar srvs []*net.SRV\n\n\tupdateURLs := func(service, scheme string) error {\n\t\t_, addrs, err := lookupSRV(service, \"tcp\", domain)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, srv := range addrs {\n\t\t\turls = append(urls, &url.URL{\n\t\t\t\tScheme: scheme,\n\t\t\t\tHost:   net.JoinHostPort(srv.Target, fmt.Sprintf(\"%d\", srv.Port)),\n\t\t\t})\n\t\t}\n\t\tsrvs = append(srvs, addrs...)\n\t\treturn nil\n\t}\n\n\terrHTTPS := updateURLs(GetSRVService(service, serviceName, \"https\"), \"https\")\n\terrHTTP := updateURLs(GetSRVService(service, serviceName, \"http\"), \"http\")\n\n\tif errHTTPS != nil && errHTTP != nil {\n\t\treturn nil, fmt.Errorf(\"dns lookup errors: %s and %s\", errHTTPS, errHTTP)\n\t}\n\n\tendpoints := make([]string, len(urls))\n\tfor i := range urls {\n\t\tendpoints[i] = urls[i].String()\n\t}\n\treturn &SRVClients{Endpoints: endpoints, SRVs: srvs}, nil\n}", "code_tokens": ["func", "GetClient", "(", "service", ",", "domain", "string", ",", "serviceName", "string", ")", "(", "*", "SRVClients", ",", "error", ")", "{", "var", "urls", "[", "]", "*", "url", ".", "URL", "\n", "var", "srvs", "[", "]", "*", "net", ".", "SRV", "\n\n", "updateURLs", ":=", "func", "(", "service", ",", "scheme", "string", ")", "error", "{", "_", ",", "addrs", ",", "err", ":=", "lookupSRV", "(", "service", ",", "\"", "\"", ",", "domain", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "for", "_", ",", "srv", ":=", "range", "addrs", "{", "urls", "=", "append", "(", "urls", ",", "&", "url", ".", "URL", "{", "Scheme", ":", "scheme", ",", "Host", ":", "net", ".", "JoinHostPort", "(", "srv", ".", "Target", ",", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "srv", ".", "Port", ")", ")", ",", "}", ")", "\n", "}", "\n", "srvs", "=", "append", "(", "srvs", ",", "addrs", "...", ")", "\n", "return", "nil", "\n", "}", "\n\n", "errHTTPS", ":=", "updateURLs", "(", "GetSRVService", "(", "service", ",", "serviceName", ",", "\"", "\"", ")", ",", "\"", "\"", ")", "\n", "errHTTP", ":=", "updateURLs", "(", "GetSRVService", "(", "service", ",", "serviceName", ",", "\"", "\"", ")", ",", "\"", "\"", ")", "\n\n", "if", "errHTTPS", "!=", "nil", "&&", "errHTTP", "!=", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "errHTTPS", ",", "errHTTP", ")", "\n", "}", "\n\n", "endpoints", ":=", "make", "(", "[", "]", "string", ",", "len", "(", "urls", ")", ")", "\n", "for", "i", ":=", "range", "urls", "{", "endpoints", "[", "i", "]", "=", "urls", "[", "i", "]", ".", "String", "(", ")", "\n", "}", "\n", "return", "&", "SRVClients", "{", "Endpoints", ":", "endpoints", ",", "SRVs", ":", "srvs", "}", ",", "nil", "\n", "}"], "docstring": "// GetClient looks up the client endpoints for a service and domain.", "docstring_tokens": ["GetClient", "looks", "up", "the", "client", "endpoints", "for", "a", "service", "and", "domain", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/srv/srv.go#L99-L130", "partition": "test"}
{"repo": "justinfx/gofileseq", "path": "exp/cpp/export/uuid.go", "func_name": "xor64", "original_string": "func xor64(x uint64) uint64 {\n\tx ^= x << 13\n\tx ^= x >> 7\n\tx ^= x << 17\n\treturn x\n}", "language": "go", "code": "func xor64(x uint64) uint64 {\n\tx ^= x << 13\n\tx ^= x >> 7\n\tx ^= x << 17\n\treturn x\n}", "code_tokens": ["func", "xor64", "(", "x", "uint64", ")", "uint64", "{", "x", "^=", "x", "<<", "13", "\n", "x", "^=", "x", ">>", "7", "\n", "x", "^=", "x", "<<", "17", "\n", "return", "x", "\n", "}"], "docstring": "// xor64 generates the next value of a pseudo-random sequence given a current\n// state x.", "docstring_tokens": ["xor64", "generates", "the", "next", "value", "of", "a", "pseudo", "-", "random", "sequence", "given", "a", "current", "state", "x", "."], "sha": "2555f296b4493d1825f5f6fab4aa0ff51a8306cd", "url": "https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/exp/cpp/export/uuid.go#L64-L69", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "raft/storage.go", "func_name": "Term", "original_string": "func (ms *MemoryStorage) Term(i uint64) (uint64, error) {\n\tms.Lock()\n\tdefer ms.Unlock()\n\toffset := ms.ents[0].Index\n\tif i < offset {\n\t\treturn 0, ErrCompacted\n\t}\n\tif int(i-offset) >= len(ms.ents) {\n\t\treturn 0, ErrUnavailable\n\t}\n\treturn ms.ents[i-offset].Term, nil\n}", "language": "go", "code": "func (ms *MemoryStorage) Term(i uint64) (uint64, error) {\n\tms.Lock()\n\tdefer ms.Unlock()\n\toffset := ms.ents[0].Index\n\tif i < offset {\n\t\treturn 0, ErrCompacted\n\t}\n\tif int(i-offset) >= len(ms.ents) {\n\t\treturn 0, ErrUnavailable\n\t}\n\treturn ms.ents[i-offset].Term, nil\n}", "code_tokens": ["func", "(", "ms", "*", "MemoryStorage", ")", "Term", "(", "i", "uint64", ")", "(", "uint64", ",", "error", ")", "{", "ms", ".", "Lock", "(", ")", "\n", "defer", "ms", ".", "Unlock", "(", ")", "\n", "offset", ":=", "ms", ".", "ents", "[", "0", "]", ".", "Index", "\n", "if", "i", "<", "offset", "{", "return", "0", ",", "ErrCompacted", "\n", "}", "\n", "if", "int", "(", "i", "-", "offset", ")", ">=", "len", "(", "ms", ".", "ents", ")", "{", "return", "0", ",", "ErrUnavailable", "\n", "}", "\n", "return", "ms", ".", "ents", "[", "i", "-", "offset", "]", ".", "Term", ",", "nil", "\n", "}"], "docstring": "// Term implements the Storage interface.", "docstring_tokens": ["Term", "implements", "the", "Storage", "interface", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/raft/storage.go#L128-L139", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/apparmor.go", "func_name": "AADestroy", "original_string": "func AADestroy(c container) error {\n\tstate := c.DaemonState()\n\tif !state.OS.AppArmorAdmin {\n\t\treturn nil\n\t}\n\n\tif state.OS.AppArmorStacking && !state.OS.AppArmorStacked {\n\t\tp := path.Join(\"/sys/kernel/security/apparmor/policy/namespaces\", AANamespace(c))\n\t\tif err := os.Remove(p); err != nil {\n\t\t\tlogger.Error(\"Error removing apparmor namespace\", log.Ctx{\"err\": err, \"ns\": p})\n\t\t}\n\t}\n\n\treturn runApparmor(APPARMOR_CMD_UNLOAD, c)\n}", "language": "go", "code": "func AADestroy(c container) error {\n\tstate := c.DaemonState()\n\tif !state.OS.AppArmorAdmin {\n\t\treturn nil\n\t}\n\n\tif state.OS.AppArmorStacking && !state.OS.AppArmorStacked {\n\t\tp := path.Join(\"/sys/kernel/security/apparmor/policy/namespaces\", AANamespace(c))\n\t\tif err := os.Remove(p); err != nil {\n\t\t\tlogger.Error(\"Error removing apparmor namespace\", log.Ctx{\"err\": err, \"ns\": p})\n\t\t}\n\t}\n\n\treturn runApparmor(APPARMOR_CMD_UNLOAD, c)\n}", "code_tokens": ["func", "AADestroy", "(", "c", "container", ")", "error", "{", "state", ":=", "c", ".", "DaemonState", "(", ")", "\n", "if", "!", "state", ".", "OS", ".", "AppArmorAdmin", "{", "return", "nil", "\n", "}", "\n\n", "if", "state", ".", "OS", ".", "AppArmorStacking", "&&", "!", "state", ".", "OS", ".", "AppArmorStacked", "{", "p", ":=", "path", ".", "Join", "(", "\"", "\"", ",", "AANamespace", "(", "c", ")", ")", "\n", "if", "err", ":=", "os", ".", "Remove", "(", "p", ")", ";", "err", "!=", "nil", "{", "logger", ".", "Error", "(", "\"", "\"", ",", "log", ".", "Ctx", "{", "\"", "\"", ":", "err", ",", "\"", "\"", ":", "p", "}", ")", "\n", "}", "\n", "}", "\n\n", "return", "runApparmor", "(", "APPARMOR_CMD_UNLOAD", ",", "c", ")", "\n", "}"], "docstring": "// Ensure that the container's policy namespace is unloaded to free kernel\n// memory. This does not delete the policy from disk or cache.", "docstring_tokens": ["Ensure", "that", "the", "container", "s", "policy", "namespace", "is", "unloaded", "to", "free", "kernel", "memory", ".", "This", "does", "not", "delete", "the", "policy", "from", "disk", "or", "cache", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/apparmor.go#L711-L725", "partition": "test"}
{"repo": "containers/image", "path": "manifest/manifest.go", "func_name": "Digest", "original_string": "func Digest(manifest []byte) (digest.Digest, error) {\n\tif GuessMIMEType(manifest) == DockerV2Schema1SignedMediaType {\n\t\tsig, err := libtrust.ParsePrettySignature(manifest, \"signatures\")\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tmanifest, err = sig.Payload()\n\t\tif err != nil {\n\t\t\t// Coverage: This should never happen, libtrust's Payload() can fail only if joseBase64UrlDecode() fails, on a string\n\t\t\t// that libtrust itself has josebase64UrlEncode()d\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\treturn digest.FromBytes(manifest), nil\n}", "language": "go", "code": "func Digest(manifest []byte) (digest.Digest, error) {\n\tif GuessMIMEType(manifest) == DockerV2Schema1SignedMediaType {\n\t\tsig, err := libtrust.ParsePrettySignature(manifest, \"signatures\")\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tmanifest, err = sig.Payload()\n\t\tif err != nil {\n\t\t\t// Coverage: This should never happen, libtrust's Payload() can fail only if joseBase64UrlDecode() fails, on a string\n\t\t\t// that libtrust itself has josebase64UrlEncode()d\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\treturn digest.FromBytes(manifest), nil\n}", "code_tokens": ["func", "Digest", "(", "manifest", "[", "]", "byte", ")", "(", "digest", ".", "Digest", ",", "error", ")", "{", "if", "GuessMIMEType", "(", "manifest", ")", "==", "DockerV2Schema1SignedMediaType", "{", "sig", ",", "err", ":=", "libtrust", ".", "ParsePrettySignature", "(", "manifest", ",", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n", "manifest", ",", "err", "=", "sig", ".", "Payload", "(", ")", "\n", "if", "err", "!=", "nil", "{", "// Coverage: This should never happen, libtrust's Payload() can fail only if joseBase64UrlDecode() fails, on a string", "// that libtrust itself has josebase64UrlEncode()d", "return", "\"", "\"", ",", "err", "\n", "}", "\n", "}", "\n\n", "return", "digest", ".", "FromBytes", "(", "manifest", ")", ",", "nil", "\n", "}"], "docstring": "// Digest returns the a digest of a docker manifest, with any necessary implied transformations like stripping v1s1 signatures.", "docstring_tokens": ["Digest", "returns", "the", "a", "digest", "of", "a", "docker", "manifest", "with", "any", "necessary", "implied", "transformations", "like", "stripping", "v1s1", "signatures", "."], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/manifest/manifest.go#L139-L154", "partition": "test"}
{"repo": "golang/debug", "path": "internal/core/address.go", "func_name": "Min", "original_string": "func (a Address) Min(b Address) Address {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}", "language": "go", "code": "func (a Address) Min(b Address) Address {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}", "code_tokens": ["func", "(", "a", "Address", ")", "Min", "(", "b", "Address", ")", "Address", "{", "if", "a", "<", "b", "{", "return", "a", "\n", "}", "\n", "return", "b", "\n", "}"], "docstring": "// Min returns the smaller of a and b.", "docstring_tokens": ["Min", "returns", "the", "smaller", "of", "a", "and", "b", "."], "sha": "19561fee47cf8cd0400d1b094c5898002f97cf90", "url": "https://github.com/golang/debug/blob/19561fee47cf8cd0400d1b094c5898002f97cf90/internal/core/address.go#L29-L34", "partition": "test"}
{"repo": "golang/appengine", "path": "memcache/memcache.go", "func_name": "Get", "original_string": "func Get(c context.Context, key string) (*Item, error) {\n\tm, err := GetMulti(c, []string{key})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif _, ok := m[key]; !ok {\n\t\treturn nil, ErrCacheMiss\n\t}\n\treturn m[key], nil\n}", "language": "go", "code": "func Get(c context.Context, key string) (*Item, error) {\n\tm, err := GetMulti(c, []string{key})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif _, ok := m[key]; !ok {\n\t\treturn nil, ErrCacheMiss\n\t}\n\treturn m[key], nil\n}", "code_tokens": ["func", "Get", "(", "c", "context", ".", "Context", ",", "key", "string", ")", "(", "*", "Item", ",", "error", ")", "{", "m", ",", "err", ":=", "GetMulti", "(", "c", ",", "[", "]", "string", "{", "key", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "if", "_", ",", "ok", ":=", "m", "[", "key", "]", ";", "!", "ok", "{", "return", "nil", ",", "ErrCacheMiss", "\n", "}", "\n", "return", "m", "[", "key", "]", ",", "nil", "\n", "}"], "docstring": "// Get gets the item for the given key. ErrCacheMiss is returned for a memcache\n// cache miss. The key must be at most 250 bytes in length.", "docstring_tokens": ["Get", "gets", "the", "item", "for", "the", "given", "key", ".", "ErrCacheMiss", "is", "returned", "for", "a", "memcache", "cache", "miss", ".", "The", "key", "must", "be", "at", "most", "250", "bytes", "in", "length", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/memcache/memcache.go#L111-L120", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nitro.go", "func_name": "Encode", "original_string": "func (s *Snapshot) Encode(buf []byte, w io.Writer) error {\n\tl := 4\n\tif len(buf) < l {\n\t\treturn errNotEnoughSpace\n\t}\n\n\tbinary.BigEndian.PutUint32(buf[0:4], s.sn)\n\tif _, err := w.Write(buf[0:4]); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n\n}", "language": "go", "code": "func (s *Snapshot) Encode(buf []byte, w io.Writer) error {\n\tl := 4\n\tif len(buf) < l {\n\t\treturn errNotEnoughSpace\n\t}\n\n\tbinary.BigEndian.PutUint32(buf[0:4], s.sn)\n\tif _, err := w.Write(buf[0:4]); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n\n}", "code_tokens": ["func", "(", "s", "*", "Snapshot", ")", "Encode", "(", "buf", "[", "]", "byte", ",", "w", "io", ".", "Writer", ")", "error", "{", "l", ":=", "4", "\n", "if", "len", "(", "buf", ")", "<", "l", "{", "return", "errNotEnoughSpace", "\n", "}", "\n\n", "binary", ".", "BigEndian", ".", "PutUint32", "(", "buf", "[", "0", ":", "4", "]", ",", "s", ".", "sn", ")", "\n", "if", "_", ",", "err", ":=", "w", ".", "Write", "(", "buf", "[", "0", ":", "4", "]", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n\n", "}"], "docstring": "// Encode implements Binary encoder for snapshot metadata", "docstring_tokens": ["Encode", "implements", "Binary", "encoder", "for", "snapshot", "metadata"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nitro.go#L524-L537", "partition": "test"}
{"repo": "lestrrat-go/xslate", "path": "loader/cache.go", "func_name": "Get", "original_string": "func (c *FileCache) Get(key string) (*CacheEntity, error) {\n\tpath := c.GetCachePath(key)\n\n\t// Need to avoid race condition\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to open cache file '\"+path+\"'\")\n\t}\n\tdefer file.Close()\n\n\tvar entity CacheEntity\n\tdec := gob.NewDecoder(file)\n\tif err = dec.Decode(&entity); err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to gob decode from cache file '\"+path+\"'\")\n\t}\n\n\treturn &entity, nil\n}", "language": "go", "code": "func (c *FileCache) Get(key string) (*CacheEntity, error) {\n\tpath := c.GetCachePath(key)\n\n\t// Need to avoid race condition\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to open cache file '\"+path+\"'\")\n\t}\n\tdefer file.Close()\n\n\tvar entity CacheEntity\n\tdec := gob.NewDecoder(file)\n\tif err = dec.Decode(&entity); err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to gob decode from cache file '\"+path+\"'\")\n\t}\n\n\treturn &entity, nil\n}", "code_tokens": ["func", "(", "c", "*", "FileCache", ")", "Get", "(", "key", "string", ")", "(", "*", "CacheEntity", ",", "error", ")", "{", "path", ":=", "c", ".", "GetCachePath", "(", "key", ")", "\n\n", "// Need to avoid race condition", "file", ",", "err", ":=", "os", ".", "Open", "(", "path", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", "+", "path", "+", "\"", "\"", ")", "\n", "}", "\n", "defer", "file", ".", "Close", "(", ")", "\n\n", "var", "entity", "CacheEntity", "\n", "dec", ":=", "gob", ".", "NewDecoder", "(", "file", ")", "\n", "if", "err", "=", "dec", ".", "Decode", "(", "&", "entity", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", "+", "path", "+", "\"", "\"", ")", "\n", "}", "\n\n", "return", "&", "entity", ",", "nil", "\n", "}"], "docstring": "// Get returns the cached vm.ByteCode, if available", "docstring_tokens": ["Get", "returns", "the", "cached", "vm", ".", "ByteCode", "if", "available"], "sha": "6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8", "url": "https://github.com/lestrrat-go/xslate/blob/6a6eb0fce8ab7407a3e0460af60758e5d6f2b9f8/loader/cache.go#L137-L154", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "ghproxy/ghcache/ghcache.go", "func_name": "NewFromCache", "original_string": "func NewFromCache(delegate http.RoundTripper, cache httpcache.Cache, maxConcurrency int) http.RoundTripper {\n\tcacheTransport := httpcache.NewTransport(cache)\n\tcacheTransport.Transport = newThrottlingTransport(maxConcurrency, upstreamTransport{delegate: delegate})\n\treturn &requestCoalescer{\n\t\tkeys:     make(map[string]*responseWaiter),\n\t\tdelegate: cacheTransport,\n\t}\n}", "language": "go", "code": "func NewFromCache(delegate http.RoundTripper, cache httpcache.Cache, maxConcurrency int) http.RoundTripper {\n\tcacheTransport := httpcache.NewTransport(cache)\n\tcacheTransport.Transport = newThrottlingTransport(maxConcurrency, upstreamTransport{delegate: delegate})\n\treturn &requestCoalescer{\n\t\tkeys:     make(map[string]*responseWaiter),\n\t\tdelegate: cacheTransport,\n\t}\n}", "code_tokens": ["func", "NewFromCache", "(", "delegate", "http", ".", "RoundTripper", ",", "cache", "httpcache", ".", "Cache", ",", "maxConcurrency", "int", ")", "http", ".", "RoundTripper", "{", "cacheTransport", ":=", "httpcache", ".", "NewTransport", "(", "cache", ")", "\n", "cacheTransport", ".", "Transport", "=", "newThrottlingTransport", "(", "maxConcurrency", ",", "upstreamTransport", "{", "delegate", ":", "delegate", "}", ")", "\n", "return", "&", "requestCoalescer", "{", "keys", ":", "make", "(", "map", "[", "string", "]", "*", "responseWaiter", ")", ",", "delegate", ":", "cacheTransport", ",", "}", "\n", "}"], "docstring": "// NewFromCache creates a GitHub cache RoundTripper that is backed by the\n// specified httpcache.Cache implementation.", "docstring_tokens": ["NewFromCache", "creates", "a", "GitHub", "cache", "RoundTripper", "that", "is", "backed", "by", "the", "specified", "httpcache", ".", "Cache", "implementation", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/ghproxy/ghcache/ghcache.go#L195-L202", "partition": "test"}
{"repo": "nicholasjackson/bench", "path": "semaphore/semaphore.go", "func_name": "Release", "original_string": "func (t *Semaphore) Release() {\n\tt.waitIfResizing()\n\n\t// we need a read lock to ensure we do not resize whilst resizing\n\tt.readMutex.RLock()\n\tdefer t.readMutex.RUnlock()\n\n\t// make sure we have not called Release without Lock\n\tif len(t.s) == 0 {\n\t\treturn\n\t}\n\t<-t.s\n}", "language": "go", "code": "func (t *Semaphore) Release() {\n\tt.waitIfResizing()\n\n\t// we need a read lock to ensure we do not resize whilst resizing\n\tt.readMutex.RLock()\n\tdefer t.readMutex.RUnlock()\n\n\t// make sure we have not called Release without Lock\n\tif len(t.s) == 0 {\n\t\treturn\n\t}\n\t<-t.s\n}", "code_tokens": ["func", "(", "t", "*", "Semaphore", ")", "Release", "(", ")", "{", "t", ".", "waitIfResizing", "(", ")", "\n\n", "// we need a read lock to ensure we do not resize whilst resizing", "t", ".", "readMutex", ".", "RLock", "(", ")", "\n", "defer", "t", ".", "readMutex", ".", "RUnlock", "(", ")", "\n\n", "// make sure we have not called Release without Lock", "if", "len", "(", "t", ".", "s", ")", "==", "0", "{", "return", "\n", "}", "\n", "<-", "t", ".", "s", "\n", "}"], "docstring": "// Release unlocks the semaphore and allows new lock instances to be called without\n// blocking if the number of locks currently equal the capacity.\n// It is important to call Release at the end of any operation which aquires a lock.", "docstring_tokens": ["Release", "unlocks", "the", "semaphore", "and", "allows", "new", "lock", "instances", "to", "be", "called", "without", "blocking", "if", "the", "number", "of", "locks", "currently", "equal", "the", "capacity", ".", "It", "is", "important", "to", "call", "Release", "at", "the", "end", "of", "any", "operation", "which", "aquires", "a", "lock", "."], "sha": "2df9635f0ad020b2e82616b0fd87130aaa1ee12e", "url": "https://github.com/nicholasjackson/bench/blob/2df9635f0ad020b2e82616b0fd87130aaa1ee12e/semaphore/semaphore.go#L53-L65", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/endpoints/pprof.go", "func_name": "PprofAddress", "original_string": "func (e *Endpoints) PprofAddress() string {\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tlistener := e.listeners[pprof]\n\tif listener == nil {\n\t\treturn \"\"\n\t}\n\n\treturn listener.Addr().String()\n}", "language": "go", "code": "func (e *Endpoints) PprofAddress() string {\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tlistener := e.listeners[pprof]\n\tif listener == nil {\n\t\treturn \"\"\n\t}\n\n\treturn listener.Addr().String()\n}", "code_tokens": ["func", "(", "e", "*", "Endpoints", ")", "PprofAddress", "(", ")", "string", "{", "e", ".", "mu", ".", "RLock", "(", ")", "\n", "defer", "e", ".", "mu", ".", "RUnlock", "(", ")", "\n\n", "listener", ":=", "e", ".", "listeners", "[", "pprof", "]", "\n", "if", "listener", "==", "nil", "{", "return", "\"", "\"", "\n", "}", "\n\n", "return", "listener", ".", "Addr", "(", ")", ".", "String", "(", ")", "\n", "}"], "docstring": "// PprofAddress returns the network addresss of the pprof endpoint, or an empty string if there's no pprof endpoint", "docstring_tokens": ["PprofAddress", "returns", "the", "network", "addresss", "of", "the", "pprof", "endpoint", "or", "an", "empty", "string", "if", "there", "s", "no", "pprof", "endpoint"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/endpoints/pprof.go#L33-L43", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "GetGetScpLedgerSeq", "original_string": "func (u StellarMessage) GetGetScpLedgerSeq() (result Uint32, ok bool) {\n\tarmName, _ := u.ArmForSwitch(int32(u.Type))\n\n\tif armName == \"GetScpLedgerSeq\" {\n\t\tresult = *u.GetScpLedgerSeq\n\t\tok = true\n\t}\n\n\treturn\n}", "language": "go", "code": "func (u StellarMessage) GetGetScpLedgerSeq() (result Uint32, ok bool) {\n\tarmName, _ := u.ArmForSwitch(int32(u.Type))\n\n\tif armName == \"GetScpLedgerSeq\" {\n\t\tresult = *u.GetScpLedgerSeq\n\t\tok = true\n\t}\n\n\treturn\n}", "code_tokens": ["func", "(", "u", "StellarMessage", ")", "GetGetScpLedgerSeq", "(", ")", "(", "result", "Uint32", ",", "ok", "bool", ")", "{", "armName", ",", "_", ":=", "u", ".", "ArmForSwitch", "(", "int32", "(", "u", ".", "Type", ")", ")", "\n\n", "if", "armName", "==", "\"", "\"", "{", "result", "=", "*", "u", ".", "GetScpLedgerSeq", "\n", "ok", "=", "true", "\n", "}", "\n\n", "return", "\n", "}"], "docstring": "// GetGetScpLedgerSeq retrieves the GetScpLedgerSeq value from the union,\n// returning ok if the union's switch indicated the value is valid.", "docstring_tokens": ["GetGetScpLedgerSeq", "retrieves", "the", "GetScpLedgerSeq", "value", "from", "the", "union", "returning", "ok", "if", "the", "union", "s", "switch", "indicated", "the", "value", "is", "valid", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6760-L6769", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "skl/skl.go", "func_name": "Put", "original_string": "func (s *Skiplist) Put(key []byte, v y.ValueStruct) {\n\t// Since we allow overwrite, we may not need to create a new node. We might not even need to\n\t// increase the height. Let's defer these actions.\n\n\tlistHeight := s.getHeight()\n\tvar prev [maxHeight + 1]*node\n\tvar next [maxHeight + 1]*node\n\tprev[listHeight] = s.head\n\tnext[listHeight] = nil\n\tfor i := int(listHeight) - 1; i >= 0; i-- {\n\t\t// Use higher level to speed up for current level.\n\t\tprev[i], next[i] = s.findSpliceForLevel(key, prev[i+1], i)\n\t\tif prev[i] == next[i] {\n\t\t\tprev[i].setValue(s.arena, v)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// We do need to create a new node.\n\theight := randomHeight()\n\tx := newNode(s.arena, key, v, height)\n\n\t// Try to increase s.height via CAS.\n\tlistHeight = s.getHeight()\n\tfor height > int(listHeight) {\n\t\tif atomic.CompareAndSwapInt32(&s.height, listHeight, int32(height)) {\n\t\t\t// Successfully increased skiplist.height.\n\t\t\tbreak\n\t\t}\n\t\tlistHeight = s.getHeight()\n\t}\n\n\t// We always insert from the base level and up. After you add a node in base level, we cannot\n\t// create a node in the level above because it would have discovered the node in the base level.\n\tfor i := 0; i < height; i++ {\n\t\tfor {\n\t\t\tif prev[i] == nil {\n\t\t\t\ty.AssertTrue(i > 1) // This cannot happen in base level.\n\t\t\t\t// We haven't computed prev, next for this level because height exceeds old listHeight.\n\t\t\t\t// For these levels, we expect the lists to be sparse, so we can just search from head.\n\t\t\t\tprev[i], next[i] = s.findSpliceForLevel(key, s.head, i)\n\t\t\t\t// Someone adds the exact same key before we are able to do so. This can only happen on\n\t\t\t\t// the base level. But we know we are not on the base level.\n\t\t\t\ty.AssertTrue(prev[i] != next[i])\n\t\t\t}\n\t\t\tnextOffset := s.arena.getNodeOffset(next[i])\n\t\t\tx.tower[i] = nextOffset\n\t\t\tif prev[i].casNextOffset(i, nextOffset, s.arena.getNodeOffset(x)) {\n\t\t\t\t// Managed to insert x between prev[i] and next[i]. Go to the next level.\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// CAS failed. We need to recompute prev and next.\n\t\t\t// It is unlikely to be helpful to try to use a different level as we redo the search,\n\t\t\t// because it is unlikely that lots of nodes are inserted between prev[i] and next[i].\n\t\t\tprev[i], next[i] = s.findSpliceForLevel(key, prev[i], i)\n\t\t\tif prev[i] == next[i] {\n\t\t\t\ty.AssertTruef(i == 0, \"Equality can happen only on base level: %d\", i)\n\t\t\t\tprev[i].setValue(s.arena, v)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}", "language": "go", "code": "func (s *Skiplist) Put(key []byte, v y.ValueStruct) {\n\t// Since we allow overwrite, we may not need to create a new node. We might not even need to\n\t// increase the height. Let's defer these actions.\n\n\tlistHeight := s.getHeight()\n\tvar prev [maxHeight + 1]*node\n\tvar next [maxHeight + 1]*node\n\tprev[listHeight] = s.head\n\tnext[listHeight] = nil\n\tfor i := int(listHeight) - 1; i >= 0; i-- {\n\t\t// Use higher level to speed up for current level.\n\t\tprev[i], next[i] = s.findSpliceForLevel(key, prev[i+1], i)\n\t\tif prev[i] == next[i] {\n\t\t\tprev[i].setValue(s.arena, v)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// We do need to create a new node.\n\theight := randomHeight()\n\tx := newNode(s.arena, key, v, height)\n\n\t// Try to increase s.height via CAS.\n\tlistHeight = s.getHeight()\n\tfor height > int(listHeight) {\n\t\tif atomic.CompareAndSwapInt32(&s.height, listHeight, int32(height)) {\n\t\t\t// Successfully increased skiplist.height.\n\t\t\tbreak\n\t\t}\n\t\tlistHeight = s.getHeight()\n\t}\n\n\t// We always insert from the base level and up. After you add a node in base level, we cannot\n\t// create a node in the level above because it would have discovered the node in the base level.\n\tfor i := 0; i < height; i++ {\n\t\tfor {\n\t\t\tif prev[i] == nil {\n\t\t\t\ty.AssertTrue(i > 1) // This cannot happen in base level.\n\t\t\t\t// We haven't computed prev, next for this level because height exceeds old listHeight.\n\t\t\t\t// For these levels, we expect the lists to be sparse, so we can just search from head.\n\t\t\t\tprev[i], next[i] = s.findSpliceForLevel(key, s.head, i)\n\t\t\t\t// Someone adds the exact same key before we are able to do so. This can only happen on\n\t\t\t\t// the base level. But we know we are not on the base level.\n\t\t\t\ty.AssertTrue(prev[i] != next[i])\n\t\t\t}\n\t\t\tnextOffset := s.arena.getNodeOffset(next[i])\n\t\t\tx.tower[i] = nextOffset\n\t\t\tif prev[i].casNextOffset(i, nextOffset, s.arena.getNodeOffset(x)) {\n\t\t\t\t// Managed to insert x between prev[i] and next[i]. Go to the next level.\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// CAS failed. We need to recompute prev and next.\n\t\t\t// It is unlikely to be helpful to try to use a different level as we redo the search,\n\t\t\t// because it is unlikely that lots of nodes are inserted between prev[i] and next[i].\n\t\t\tprev[i], next[i] = s.findSpliceForLevel(key, prev[i], i)\n\t\t\tif prev[i] == next[i] {\n\t\t\t\ty.AssertTruef(i == 0, \"Equality can happen only on base level: %d\", i)\n\t\t\t\tprev[i].setValue(s.arena, v)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "Skiplist", ")", "Put", "(", "key", "[", "]", "byte", ",", "v", "y", ".", "ValueStruct", ")", "{", "// Since we allow overwrite, we may not need to create a new node. We might not even need to", "// increase the height. Let's defer these actions.", "listHeight", ":=", "s", ".", "getHeight", "(", ")", "\n", "var", "prev", "[", "maxHeight", "+", "1", "]", "*", "node", "\n", "var", "next", "[", "maxHeight", "+", "1", "]", "*", "node", "\n", "prev", "[", "listHeight", "]", "=", "s", ".", "head", "\n", "next", "[", "listHeight", "]", "=", "nil", "\n", "for", "i", ":=", "int", "(", "listHeight", ")", "-", "1", ";", "i", ">=", "0", ";", "i", "--", "{", "// Use higher level to speed up for current level.", "prev", "[", "i", "]", ",", "next", "[", "i", "]", "=", "s", ".", "findSpliceForLevel", "(", "key", ",", "prev", "[", "i", "+", "1", "]", ",", "i", ")", "\n", "if", "prev", "[", "i", "]", "==", "next", "[", "i", "]", "{", "prev", "[", "i", "]", ".", "setValue", "(", "s", ".", "arena", ",", "v", ")", "\n", "return", "\n", "}", "\n", "}", "\n\n", "// We do need to create a new node.", "height", ":=", "randomHeight", "(", ")", "\n", "x", ":=", "newNode", "(", "s", ".", "arena", ",", "key", ",", "v", ",", "height", ")", "\n\n", "// Try to increase s.height via CAS.", "listHeight", "=", "s", ".", "getHeight", "(", ")", "\n", "for", "height", ">", "int", "(", "listHeight", ")", "{", "if", "atomic", ".", "CompareAndSwapInt32", "(", "&", "s", ".", "height", ",", "listHeight", ",", "int32", "(", "height", ")", ")", "{", "// Successfully increased skiplist.height.", "break", "\n", "}", "\n", "listHeight", "=", "s", ".", "getHeight", "(", ")", "\n", "}", "\n\n", "// We always insert from the base level and up. After you add a node in base level, we cannot", "// create a node in the level above because it would have discovered the node in the base level.", "for", "i", ":=", "0", ";", "i", "<", "height", ";", "i", "++", "{", "for", "{", "if", "prev", "[", "i", "]", "==", "nil", "{", "y", ".", "AssertTrue", "(", "i", ">", "1", ")", "// This cannot happen in base level.", "\n", "// We haven't computed prev, next for this level because height exceeds old listHeight.", "// For these levels, we expect the lists to be sparse, so we can just search from head.", "prev", "[", "i", "]", ",", "next", "[", "i", "]", "=", "s", ".", "findSpliceForLevel", "(", "key", ",", "s", ".", "head", ",", "i", ")", "\n", "// Someone adds the exact same key before we are able to do so. This can only happen on", "// the base level. But we know we are not on the base level.", "y", ".", "AssertTrue", "(", "prev", "[", "i", "]", "!=", "next", "[", "i", "]", ")", "\n", "}", "\n", "nextOffset", ":=", "s", ".", "arena", ".", "getNodeOffset", "(", "next", "[", "i", "]", ")", "\n", "x", ".", "tower", "[", "i", "]", "=", "nextOffset", "\n", "if", "prev", "[", "i", "]", ".", "casNextOffset", "(", "i", ",", "nextOffset", ",", "s", ".", "arena", ".", "getNodeOffset", "(", "x", ")", ")", "{", "// Managed to insert x between prev[i] and next[i]. Go to the next level.", "break", "\n", "}", "\n", "// CAS failed. We need to recompute prev and next.", "// It is unlikely to be helpful to try to use a different level as we redo the search,", "// because it is unlikely that lots of nodes are inserted between prev[i] and next[i].", "prev", "[", "i", "]", ",", "next", "[", "i", "]", "=", "s", ".", "findSpliceForLevel", "(", "key", ",", "prev", "[", "i", "]", ",", "i", ")", "\n", "if", "prev", "[", "i", "]", "==", "next", "[", "i", "]", "{", "y", ".", "AssertTruef", "(", "i", "==", "0", ",", "\"", "\"", ",", "i", ")", "\n", "prev", "[", "i", "]", ".", "setValue", "(", "s", ".", "arena", ",", "v", ")", "\n", "return", "\n", "}", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// Put inserts the key-value pair.", "docstring_tokens": ["Put", "inserts", "the", "key", "-", "value", "pair", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/skl/skl.go#L283-L345", "partition": "test"}
{"repo": "kr/s3", "path": "s3util/readdir.go", "func_name": "Readdir", "original_string": "func (f *File) Readdir(n int) ([]os.FileInfo, error) {\n\tif f.result != nil && !f.result.IsTruncated {\n\t\treturn make([]os.FileInfo, 0), io.EOF\n\t}\n\n\treader, err := f.sendRequest(n)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer reader.Close()\n\n\treturn f.parseResponse(reader)\n}", "language": "go", "code": "func (f *File) Readdir(n int) ([]os.FileInfo, error) {\n\tif f.result != nil && !f.result.IsTruncated {\n\t\treturn make([]os.FileInfo, 0), io.EOF\n\t}\n\n\treader, err := f.sendRequest(n)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer reader.Close()\n\n\treturn f.parseResponse(reader)\n}", "code_tokens": ["func", "(", "f", "*", "File", ")", "Readdir", "(", "n", "int", ")", "(", "[", "]", "os", ".", "FileInfo", ",", "error", ")", "{", "if", "f", ".", "result", "!=", "nil", "&&", "!", "f", ".", "result", ".", "IsTruncated", "{", "return", "make", "(", "[", "]", "os", ".", "FileInfo", ",", "0", ")", ",", "io", ".", "EOF", "\n", "}", "\n\n", "reader", ",", "err", ":=", "f", ".", "sendRequest", "(", "n", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "defer", "reader", ".", "Close", "(", ")", "\n\n", "return", "f", ".", "parseResponse", "(", "reader", ")", "\n", "}"], "docstring": "// Readdir requests a list of entries in the S3 directory\n// represented by f and returns a slice of up to n FileInfo\n// values, in alphabetical order. Subsequent calls\n// on the same File will yield further FileInfos.\n// Only direct children are returned, not deeper descendants.", "docstring_tokens": ["Readdir", "requests", "a", "list", "of", "entries", "in", "the", "S3", "directory", "represented", "by", "f", "and", "returns", "a", "slice", "of", "up", "to", "n", "FileInfo", "values", "in", "alphabetical", "order", ".", "Subsequent", "calls", "on", "the", "same", "File", "will", "yield", "further", "FileInfos", ".", "Only", "direct", "children", "are", "returned", "not", "deeper", "descendants", "."], "sha": "c070c8f9a8f0032d48f0d2a77d4e382788bd8a1d", "url": "https://github.com/kr/s3/blob/c070c8f9a8f0032d48f0d2a77d4e382788bd8a1d/s3util/readdir.go#L103-L115", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "nodetable/table.go", "func_name": "Get", "original_string": "func (nt *NodeTable) Get(key []byte) unsafe.Pointer {\n\tres := nt.find(key)\n\tif res.status&ntFoundMask == ntFoundMask {\n\t\tif res.status == ntFoundInFast {\n\t\t\treturn decodePointer(res.fastHTValue)\n\t\t}\n\t\treturn decodePointer(res.slowHTValues[res.slowHTPos])\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (nt *NodeTable) Get(key []byte) unsafe.Pointer {\n\tres := nt.find(key)\n\tif res.status&ntFoundMask == ntFoundMask {\n\t\tif res.status == ntFoundInFast {\n\t\t\treturn decodePointer(res.fastHTValue)\n\t\t}\n\t\treturn decodePointer(res.slowHTValues[res.slowHTPos])\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "nt", "*", "NodeTable", ")", "Get", "(", "key", "[", "]", "byte", ")", "unsafe", ".", "Pointer", "{", "res", ":=", "nt", ".", "find", "(", "key", ")", "\n", "if", "res", ".", "status", "&", "ntFoundMask", "==", "ntFoundMask", "{", "if", "res", ".", "status", "==", "ntFoundInFast", "{", "return", "decodePointer", "(", "res", ".", "fastHTValue", ")", "\n", "}", "\n", "return", "decodePointer", "(", "res", ".", "slowHTValues", "[", "res", ".", "slowHTPos", "]", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Get returns node pointer for the lookup key", "docstring_tokens": ["Get", "returns", "node", "pointer", "for", "the", "lookup", "key"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/nodetable/table.go#L110-L120", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/dlock/dlock.go", "func_name": "NewDLock", "original_string": "func NewDLock(client *etcd.Client, prefix string) DLock {\n\treturn &etcdImpl{\n\t\tclient: client,\n\t\tprefix: prefix,\n\t}\n}", "language": "go", "code": "func NewDLock(client *etcd.Client, prefix string) DLock {\n\treturn &etcdImpl{\n\t\tclient: client,\n\t\tprefix: prefix,\n\t}\n}", "code_tokens": ["func", "NewDLock", "(", "client", "*", "etcd", ".", "Client", ",", "prefix", "string", ")", "DLock", "{", "return", "&", "etcdImpl", "{", "client", ":", "client", ",", "prefix", ":", "prefix", ",", "}", "\n", "}"], "docstring": "// NewDLock attempts to acquire a distributed lock that locks a given prefix\n// in the data store.", "docstring_tokens": ["NewDLock", "attempts", "to", "acquire", "a", "distributed", "lock", "that", "locks", "a", "given", "prefix", "in", "the", "data", "store", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/dlock/dlock.go#L32-L37", "partition": "test"}
{"repo": "siddontang/go-log", "path": "log/logger.go", "func_name": "OutputJson", "original_string": "func (l *Logger) OutputJson(callDepth int, level Level, body interface{}) {\n\tif l.level > level {\n\t\treturn\n\t}\n\n\tbuf := l.bufs.Get().([]byte)\n\tbuf = buf[0:0]\n\tdefer l.bufs.Put(buf)\n\n\ttype JsonLog struct {\n\t\tTime string `json:\"log_time\"`\n\t\tLevel string `json:\"log_level\"`\n\t\tFile string `json:\"log_file\"`\n\t\tLine string `json:\"log_line\"`\n\t\tBody interface{} `json:\"log_body\"`\n\t}\n\n\tvar jsonlog JsonLog\n\tif l.flag&Ltime > 0 {\n\t\tnow := time.Now().Format(timeFormat)\n\t\tjsonlog.Time = now\n\t}\n\n\tif l.flag&Llevel > 0 {\n\t\tjsonlog.Level = level.String()\n\t}\n\n\tif l.flag&Lfile > 0 {\n\t\t_, file, line, ok := runtime.Caller(callDepth)\n\t\tif !ok {\n\t\t\tfile = \"???\"\n\t\t\tline = 0\n\t\t} else {\n\t\t\tfor i := len(file) - 1; i > 0; i-- {\n\t\t\t\tif file[i] == '/' {\n\t\t\t\t\tfile = file[i+1:]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tjsonlog.File = file\n\t\tjsonlog.Line = string(strconv.AppendInt(buf, int64(line), 10))\n\t}\n\n\tjsonlog.Body = body\n\n\tmsg, _ := json.Marshal(jsonlog)\n\tmsg = append(msg, '\\n')\n\n\tl.hLock.Lock()\n\tl.handler.Write(msg)\n\tl.hLock.Unlock()\n}", "language": "go", "code": "func (l *Logger) OutputJson(callDepth int, level Level, body interface{}) {\n\tif l.level > level {\n\t\treturn\n\t}\n\n\tbuf := l.bufs.Get().([]byte)\n\tbuf = buf[0:0]\n\tdefer l.bufs.Put(buf)\n\n\ttype JsonLog struct {\n\t\tTime string `json:\"log_time\"`\n\t\tLevel string `json:\"log_level\"`\n\t\tFile string `json:\"log_file\"`\n\t\tLine string `json:\"log_line\"`\n\t\tBody interface{} `json:\"log_body\"`\n\t}\n\n\tvar jsonlog JsonLog\n\tif l.flag&Ltime > 0 {\n\t\tnow := time.Now().Format(timeFormat)\n\t\tjsonlog.Time = now\n\t}\n\n\tif l.flag&Llevel > 0 {\n\t\tjsonlog.Level = level.String()\n\t}\n\n\tif l.flag&Lfile > 0 {\n\t\t_, file, line, ok := runtime.Caller(callDepth)\n\t\tif !ok {\n\t\t\tfile = \"???\"\n\t\t\tline = 0\n\t\t} else {\n\t\t\tfor i := len(file) - 1; i > 0; i-- {\n\t\t\t\tif file[i] == '/' {\n\t\t\t\t\tfile = file[i+1:]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tjsonlog.File = file\n\t\tjsonlog.Line = string(strconv.AppendInt(buf, int64(line), 10))\n\t}\n\n\tjsonlog.Body = body\n\n\tmsg, _ := json.Marshal(jsonlog)\n\tmsg = append(msg, '\\n')\n\n\tl.hLock.Lock()\n\tl.handler.Write(msg)\n\tl.hLock.Unlock()\n}", "code_tokens": ["func", "(", "l", "*", "Logger", ")", "OutputJson", "(", "callDepth", "int", ",", "level", "Level", ",", "body", "interface", "{", "}", ")", "{", "if", "l", ".", "level", ">", "level", "{", "return", "\n", "}", "\n\n", "buf", ":=", "l", ".", "bufs", ".", "Get", "(", ")", ".", "(", "[", "]", "byte", ")", "\n", "buf", "=", "buf", "[", "0", ":", "0", "]", "\n", "defer", "l", ".", "bufs", ".", "Put", "(", "buf", ")", "\n\n", "type", "JsonLog", "struct", "{", "Time", "string", "`json:\"log_time\"`", "\n", "Level", "string", "`json:\"log_level\"`", "\n", "File", "string", "`json:\"log_file\"`", "\n", "Line", "string", "`json:\"log_line\"`", "\n", "Body", "interface", "{", "}", "`json:\"log_body\"`", "\n", "}", "\n\n", "var", "jsonlog", "JsonLog", "\n", "if", "l", ".", "flag", "&", "Ltime", ">", "0", "{", "now", ":=", "time", ".", "Now", "(", ")", ".", "Format", "(", "timeFormat", ")", "\n", "jsonlog", ".", "Time", "=", "now", "\n", "}", "\n\n", "if", "l", ".", "flag", "&", "Llevel", ">", "0", "{", "jsonlog", ".", "Level", "=", "level", ".", "String", "(", ")", "\n", "}", "\n\n", "if", "l", ".", "flag", "&", "Lfile", ">", "0", "{", "_", ",", "file", ",", "line", ",", "ok", ":=", "runtime", ".", "Caller", "(", "callDepth", ")", "\n", "if", "!", "ok", "{", "file", "=", "\"", "\"", "\n", "line", "=", "0", "\n", "}", "else", "{", "for", "i", ":=", "len", "(", "file", ")", "-", "1", ";", "i", ">", "0", ";", "i", "--", "{", "if", "file", "[", "i", "]", "==", "'/'", "{", "file", "=", "file", "[", "i", "+", "1", ":", "]", "\n", "break", "\n", "}", "\n", "}", "\n", "}", "\n\n", "jsonlog", ".", "File", "=", "file", "\n", "jsonlog", ".", "Line", "=", "string", "(", "strconv", ".", "AppendInt", "(", "buf", ",", "int64", "(", "line", ")", ",", "10", ")", ")", "\n", "}", "\n\n", "jsonlog", ".", "Body", "=", "body", "\n\n", "msg", ",", "_", ":=", "json", ".", "Marshal", "(", "jsonlog", ")", "\n", "msg", "=", "append", "(", "msg", ",", "'\\n'", ")", "\n\n", "l", ".", "hLock", ".", "Lock", "(", ")", "\n", "l", ".", "handler", ".", "Write", "(", "msg", ")", "\n", "l", ".", "hLock", ".", "Unlock", "(", ")", "\n", "}"], "docstring": "// Output json format records the log with special callstack depth and log level.", "docstring_tokens": ["Output", "json", "format", "records", "the", "log", "with", "special", "callstack", "depth", "and", "log", "level", "."], "sha": "1e957dd83bed18c84716181da7b80d4af48eaefe", "url": "https://github.com/siddontang/go-log/blob/1e957dd83bed18c84716181da7b80d4af48eaefe/log/logger.go#L191-L244", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "db.go", "func_name": "calculateSize", "original_string": "func (db *DB) calculateSize() {\n\tnewInt := func(val int64) *expvar.Int {\n\t\tv := new(expvar.Int)\n\t\tv.Add(val)\n\t\treturn v\n\t}\n\n\ttotalSize := func(dir string) (int64, int64) {\n\t\tvar lsmSize, vlogSize int64\n\t\terr := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\text := filepath.Ext(path)\n\t\t\tif ext == \".sst\" {\n\t\t\t\tlsmSize += info.Size()\n\t\t\t} else if ext == \".vlog\" {\n\t\t\t\tvlogSize += info.Size()\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tdb.elog.Printf(\"Got error while calculating total size of directory: %s\", dir)\n\t\t}\n\t\treturn lsmSize, vlogSize\n\t}\n\n\tlsmSize, vlogSize := totalSize(db.opt.Dir)\n\ty.LSMSize.Set(db.opt.Dir, newInt(lsmSize))\n\t// If valueDir is different from dir, we'd have to do another walk.\n\tif db.opt.ValueDir != db.opt.Dir {\n\t\t_, vlogSize = totalSize(db.opt.ValueDir)\n\t}\n\ty.VlogSize.Set(db.opt.Dir, newInt(vlogSize))\n}", "language": "go", "code": "func (db *DB) calculateSize() {\n\tnewInt := func(val int64) *expvar.Int {\n\t\tv := new(expvar.Int)\n\t\tv.Add(val)\n\t\treturn v\n\t}\n\n\ttotalSize := func(dir string) (int64, int64) {\n\t\tvar lsmSize, vlogSize int64\n\t\terr := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\text := filepath.Ext(path)\n\t\t\tif ext == \".sst\" {\n\t\t\t\tlsmSize += info.Size()\n\t\t\t} else if ext == \".vlog\" {\n\t\t\t\tvlogSize += info.Size()\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tdb.elog.Printf(\"Got error while calculating total size of directory: %s\", dir)\n\t\t}\n\t\treturn lsmSize, vlogSize\n\t}\n\n\tlsmSize, vlogSize := totalSize(db.opt.Dir)\n\ty.LSMSize.Set(db.opt.Dir, newInt(lsmSize))\n\t// If valueDir is different from dir, we'd have to do another walk.\n\tif db.opt.ValueDir != db.opt.Dir {\n\t\t_, vlogSize = totalSize(db.opt.ValueDir)\n\t}\n\ty.VlogSize.Set(db.opt.Dir, newInt(vlogSize))\n}", "code_tokens": ["func", "(", "db", "*", "DB", ")", "calculateSize", "(", ")", "{", "newInt", ":=", "func", "(", "val", "int64", ")", "*", "expvar", ".", "Int", "{", "v", ":=", "new", "(", "expvar", ".", "Int", ")", "\n", "v", ".", "Add", "(", "val", ")", "\n", "return", "v", "\n", "}", "\n\n", "totalSize", ":=", "func", "(", "dir", "string", ")", "(", "int64", ",", "int64", ")", "{", "var", "lsmSize", ",", "vlogSize", "int64", "\n", "err", ":=", "filepath", ".", "Walk", "(", "dir", ",", "func", "(", "path", "string", ",", "info", "os", ".", "FileInfo", ",", "err", "error", ")", "error", "{", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "ext", ":=", "filepath", ".", "Ext", "(", "path", ")", "\n", "if", "ext", "==", "\"", "\"", "{", "lsmSize", "+=", "info", ".", "Size", "(", ")", "\n", "}", "else", "if", "ext", "==", "\"", "\"", "{", "vlogSize", "+=", "info", ".", "Size", "(", ")", "\n", "}", "\n", "return", "nil", "\n", "}", ")", "\n", "if", "err", "!=", "nil", "{", "db", ".", "elog", ".", "Printf", "(", "\"", "\"", ",", "dir", ")", "\n", "}", "\n", "return", "lsmSize", ",", "vlogSize", "\n", "}", "\n\n", "lsmSize", ",", "vlogSize", ":=", "totalSize", "(", "db", ".", "opt", ".", "Dir", ")", "\n", "y", ".", "LSMSize", ".", "Set", "(", "db", ".", "opt", ".", "Dir", ",", "newInt", "(", "lsmSize", ")", ")", "\n", "// If valueDir is different from dir, we'd have to do another walk.", "if", "db", ".", "opt", ".", "ValueDir", "!=", "db", ".", "opt", ".", "Dir", "{", "_", ",", "vlogSize", "=", "totalSize", "(", "db", ".", "opt", ".", "ValueDir", ")", "\n", "}", "\n", "y", ".", "VlogSize", ".", "Set", "(", "db", ".", "opt", ".", "Dir", ",", "newInt", "(", "vlogSize", ")", ")", "\n", "}"], "docstring": "// This function does a filewalk, calculates the size of vlog and sst files and stores it in\n// y.LSMSize and y.VlogSize.", "docstring_tokens": ["This", "function", "does", "a", "filewalk", "calculates", "the", "size", "of", "vlog", "and", "sst", "files", "and", "stores", "it", "in", "y", ".", "LSMSize", "and", "y", ".", "VlogSize", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/db.go#L919-L953", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "grpc/rpcerror/grpc.go", "func_name": "StreamClientInterceptor", "original_string": "func StreamClientInterceptor(fn ConvertFunc) grpc.StreamClientInterceptor {\n\treturn func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (stream grpc.ClientStream, err error) {\n\t\tstream, err = streamer(ctx, desc, cc, method, opts...)\n\t\treturn stream, fn(err)\n\t}\n}", "language": "go", "code": "func StreamClientInterceptor(fn ConvertFunc) grpc.StreamClientInterceptor {\n\treturn func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (stream grpc.ClientStream, err error) {\n\t\tstream, err = streamer(ctx, desc, cc, method, opts...)\n\t\treturn stream, fn(err)\n\t}\n}", "code_tokens": ["func", "StreamClientInterceptor", "(", "fn", "ConvertFunc", ")", "grpc", ".", "StreamClientInterceptor", "{", "return", "func", "(", "ctx", "context", ".", "Context", ",", "desc", "*", "grpc", ".", "StreamDesc", ",", "cc", "*", "grpc", ".", "ClientConn", ",", "method", "string", ",", "streamer", "grpc", ".", "Streamer", ",", "opts", "...", "grpc", ".", "CallOption", ")", "(", "stream", "grpc", ".", "ClientStream", ",", "err", "error", ")", "{", "stream", ",", "err", "=", "streamer", "(", "ctx", ",", "desc", ",", "cc", ",", "method", ",", "opts", "...", ")", "\n", "return", "stream", ",", "fn", "(", "err", ")", "\n", "}", "\n", "}"], "docstring": "// StreamClientInterceptor applies fn to errors recieved by client.", "docstring_tokens": ["StreamClientInterceptor", "applies", "fn", "to", "errors", "recieved", "by", "client", "."], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/grpc/rpcerror/grpc.go#L37-L42", "partition": "test"}
{"repo": "lxc/lxd", "path": "client/lxd_containers.go", "func_name": "GetContainerLogfile", "original_string": "func (r *ProtocolLXD) GetContainerLogfile(name string, filename string) (io.ReadCloser, error) {\n\t// Prepare the HTTP request\n\turl := fmt.Sprintf(\"%s/1.0/containers/%s/logs/%s\", r.httpHost, url.QueryEscape(name), url.QueryEscape(filename))\n\n\turl, err := r.setQueryAttributes(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the user agent\n\tif r.httpUserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", r.httpUserAgent)\n\t}\n\n\t// Send the request\n\tresp, err := r.do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the return value for a cleaner error\n\tif resp.StatusCode != http.StatusOK {\n\t\t_, _, err := lxdParseResponse(resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn resp.Body, err\n}", "language": "go", "code": "func (r *ProtocolLXD) GetContainerLogfile(name string, filename string) (io.ReadCloser, error) {\n\t// Prepare the HTTP request\n\turl := fmt.Sprintf(\"%s/1.0/containers/%s/logs/%s\", r.httpHost, url.QueryEscape(name), url.QueryEscape(filename))\n\n\turl, err := r.setQueryAttributes(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the user agent\n\tif r.httpUserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", r.httpUserAgent)\n\t}\n\n\t// Send the request\n\tresp, err := r.do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the return value for a cleaner error\n\tif resp.StatusCode != http.StatusOK {\n\t\t_, _, err := lxdParseResponse(resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn resp.Body, err\n}", "code_tokens": ["func", "(", "r", "*", "ProtocolLXD", ")", "GetContainerLogfile", "(", "name", "string", ",", "filename", "string", ")", "(", "io", ".", "ReadCloser", ",", "error", ")", "{", "// Prepare the HTTP request", "url", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "r", ".", "httpHost", ",", "url", ".", "QueryEscape", "(", "name", ")", ",", "url", ".", "QueryEscape", "(", "filename", ")", ")", "\n\n", "url", ",", "err", ":=", "r", ".", "setQueryAttributes", "(", "url", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "req", ",", "err", ":=", "http", ".", "NewRequest", "(", "\"", "\"", ",", "url", ",", "nil", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "// Set the user agent", "if", "r", ".", "httpUserAgent", "!=", "\"", "\"", "{", "req", ".", "Header", ".", "Set", "(", "\"", "\"", ",", "r", ".", "httpUserAgent", ")", "\n", "}", "\n\n", "// Send the request", "resp", ",", "err", ":=", "r", ".", "do", "(", "req", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "// Check the return value for a cleaner error", "if", "resp", ".", "StatusCode", "!=", "http", ".", "StatusOK", "{", "_", ",", "_", ",", "err", ":=", "lxdParseResponse", "(", "resp", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "}", "\n\n", "return", "resp", ".", "Body", ",", "err", "\n", "}"], "docstring": "// GetContainerLogfile returns the content of the requested logfile\n//\n// Note that it's the caller's responsibility to close the returned ReadCloser", "docstring_tokens": ["GetContainerLogfile", "returns", "the", "content", "of", "the", "requested", "logfile", "Note", "that", "it", "s", "the", "caller", "s", "responsibility", "to", "close", "the", "returned", "ReadCloser"], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/client/lxd_containers.go#L1423-L1457", "partition": "test"}
{"repo": "hashicorp/raft", "path": "snapshot.go", "func_name": "shouldSnapshot", "original_string": "func (r *Raft) shouldSnapshot() bool {\n\t// Check the last snapshot index\n\tlastSnap, _ := r.getLastSnapshot()\n\n\t// Check the last log index\n\tlastIdx, err := r.logs.LastIndex()\n\tif err != nil {\n\t\tr.logger.Error(fmt.Sprintf(\"Failed to get last log index: %v\", err))\n\t\treturn false\n\t}\n\n\t// Compare the delta to the threshold\n\tdelta := lastIdx - lastSnap\n\treturn delta >= r.conf.SnapshotThreshold\n}", "language": "go", "code": "func (r *Raft) shouldSnapshot() bool {\n\t// Check the last snapshot index\n\tlastSnap, _ := r.getLastSnapshot()\n\n\t// Check the last log index\n\tlastIdx, err := r.logs.LastIndex()\n\tif err != nil {\n\t\tr.logger.Error(fmt.Sprintf(\"Failed to get last log index: %v\", err))\n\t\treturn false\n\t}\n\n\t// Compare the delta to the threshold\n\tdelta := lastIdx - lastSnap\n\treturn delta >= r.conf.SnapshotThreshold\n}", "code_tokens": ["func", "(", "r", "*", "Raft", ")", "shouldSnapshot", "(", ")", "bool", "{", "// Check the last snapshot index", "lastSnap", ",", "_", ":=", "r", ".", "getLastSnapshot", "(", ")", "\n\n", "// Check the last log index", "lastIdx", ",", "err", ":=", "r", ".", "logs", ".", "LastIndex", "(", ")", "\n", "if", "err", "!=", "nil", "{", "r", ".", "logger", ".", "Error", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "err", ")", ")", "\n", "return", "false", "\n", "}", "\n\n", "// Compare the delta to the threshold", "delta", ":=", "lastIdx", "-", "lastSnap", "\n", "return", "delta", ">=", "r", ".", "conf", ".", "SnapshotThreshold", "\n", "}"], "docstring": "// shouldSnapshot checks if we meet the conditions to take\n// a new snapshot.", "docstring_tokens": ["shouldSnapshot", "checks", "if", "we", "meet", "the", "conditions", "to", "take", "a", "new", "snapshot", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/snapshot.go#L103-L117", "partition": "test"}
{"repo": "justinfx/gofileseq", "path": "fileseq.go", "func_name": "frameRangeMatches", "original_string": "func frameRangeMatches(frange string) ([][]string, error) {\n\tfor _, k := range defaultPadding.AllChars() {\n\t\tfrange = strings.Replace(frange, k, \"\", -1)\n\t}\n\n\tvar (\n\t\tmatched bool\n\t\tmatch   []string\n\t\trx      *regexp.Regexp\n\t)\n\n\tfrange = strings.Replace(frange, \" \", \"\", -1)\n\n\t// For each comma-sep component, we will parse a frame range\n\tparts := strings.Split(frange, \",\")\n\tsize := len(parts)\n\tmatches := make([][]string, size, size)\n\n\tfor i, part := range parts {\n\n\t\tmatched = false\n\n\t\t// Build up frames for all comma-sep components\n\t\tfor _, rx = range rangePatterns {\n\t\t\tif match = rx.FindStringSubmatch(part); match == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmatched = true\n\t\t\tmatches[i] = match[1:]\n\t\t}\n\n\t\t// If any component of the comma-sep frame range fails to\n\t\t// parse, we bail out\n\t\tif !matched {\n\t\t\terr := fmt.Errorf(\"Failed to parse frame range: %s on part %q\", frange, part)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn matches, nil\n}", "language": "go", "code": "func frameRangeMatches(frange string) ([][]string, error) {\n\tfor _, k := range defaultPadding.AllChars() {\n\t\tfrange = strings.Replace(frange, k, \"\", -1)\n\t}\n\n\tvar (\n\t\tmatched bool\n\t\tmatch   []string\n\t\trx      *regexp.Regexp\n\t)\n\n\tfrange = strings.Replace(frange, \" \", \"\", -1)\n\n\t// For each comma-sep component, we will parse a frame range\n\tparts := strings.Split(frange, \",\")\n\tsize := len(parts)\n\tmatches := make([][]string, size, size)\n\n\tfor i, part := range parts {\n\n\t\tmatched = false\n\n\t\t// Build up frames for all comma-sep components\n\t\tfor _, rx = range rangePatterns {\n\t\t\tif match = rx.FindStringSubmatch(part); match == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmatched = true\n\t\t\tmatches[i] = match[1:]\n\t\t}\n\n\t\t// If any component of the comma-sep frame range fails to\n\t\t// parse, we bail out\n\t\tif !matched {\n\t\t\terr := fmt.Errorf(\"Failed to parse frame range: %s on part %q\", frange, part)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn matches, nil\n}", "code_tokens": ["func", "frameRangeMatches", "(", "frange", "string", ")", "(", "[", "]", "[", "]", "string", ",", "error", ")", "{", "for", "_", ",", "k", ":=", "range", "defaultPadding", ".", "AllChars", "(", ")", "{", "frange", "=", "strings", ".", "Replace", "(", "frange", ",", "k", ",", "\"", "\"", ",", "-", "1", ")", "\n", "}", "\n\n", "var", "(", "matched", "bool", "\n", "match", "[", "]", "string", "\n", "rx", "*", "regexp", ".", "Regexp", "\n", ")", "\n\n", "frange", "=", "strings", ".", "Replace", "(", "frange", ",", "\"", "\"", ",", "\"", "\"", ",", "-", "1", ")", "\n\n", "// For each comma-sep component, we will parse a frame range", "parts", ":=", "strings", ".", "Split", "(", "frange", ",", "\"", "\"", ")", "\n", "size", ":=", "len", "(", "parts", ")", "\n", "matches", ":=", "make", "(", "[", "]", "[", "]", "string", ",", "size", ",", "size", ")", "\n\n", "for", "i", ",", "part", ":=", "range", "parts", "{", "matched", "=", "false", "\n\n", "// Build up frames for all comma-sep components", "for", "_", ",", "rx", "=", "range", "rangePatterns", "{", "if", "match", "=", "rx", ".", "FindStringSubmatch", "(", "part", ")", ";", "match", "==", "nil", "{", "continue", "\n", "}", "\n", "matched", "=", "true", "\n", "matches", "[", "i", "]", "=", "match", "[", "1", ":", "]", "\n", "}", "\n\n", "// If any component of the comma-sep frame range fails to", "// parse, we bail out", "if", "!", "matched", "{", "err", ":=", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "frange", ",", "part", ")", "\n", "return", "nil", ",", "err", "\n", "}", "\n", "}", "\n\n", "return", "matches", ",", "nil", "\n", "}"], "docstring": "// frameRangeMatches breaks down the string frame range\n// into groups of range matches, for further processing.", "docstring_tokens": ["frameRangeMatches", "breaks", "down", "the", "string", "frame", "range", "into", "groups", "of", "range", "matches", "for", "further", "processing", "."], "sha": "2555f296b4493d1825f5f6fab4aa0ff51a8306cd", "url": "https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/fileseq.go#L175-L215", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/cluster/config.go", "func_name": "ConfigGetInt64", "original_string": "func ConfigGetInt64(cluster *db.Cluster, key string) (int64, error) {\n\tconfig, err := configGet(cluster)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn config.m.GetInt64(key), nil\n}", "language": "go", "code": "func ConfigGetInt64(cluster *db.Cluster, key string) (int64, error) {\n\tconfig, err := configGet(cluster)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn config.m.GetInt64(key), nil\n}", "code_tokens": ["func", "ConfigGetInt64", "(", "cluster", "*", "db", ".", "Cluster", ",", "key", "string", ")", "(", "int64", ",", "error", ")", "{", "config", ",", "err", ":=", "configGet", "(", "cluster", ")", "\n", "if", "err", "!=", "nil", "{", "return", "0", ",", "err", "\n", "}", "\n", "return", "config", ".", "m", ".", "GetInt64", "(", "key", ")", ",", "nil", "\n", "}"], "docstring": "// ConfigGetInt64 is a convenience for loading the cluster configuration and\n// returning the value of a particular key.\n//\n// It's a deprecated API meant to be used by call sites that are not\n// interacting with the database in a transactional way.", "docstring_tokens": ["ConfigGetInt64", "is", "a", "convenience", "for", "loading", "the", "cluster", "configuration", "and", "returning", "the", "value", "of", "a", "particular", "key", ".", "It", "s", "a", "deprecated", "API", "meant", "to", "be", "used", "by", "call", "sites", "that", "are", "not", "interacting", "with", "the", "database", "in", "a", "transactional", "way", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/cluster/config.go#L202-L208", "partition": "test"}
{"repo": "256dpi/fire", "path": "context.go", "func_name": "Respond", "original_string": "func (c *Context) Respond(value interface{}) error {\n\t// encode response\n\tbytes, err := json.Marshal(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// write token\n\t_, err = c.ResponseWriter.Write(bytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *Context) Respond(value interface{}) error {\n\t// encode response\n\tbytes, err := json.Marshal(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// write token\n\t_, err = c.ResponseWriter.Write(bytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Context", ")", "Respond", "(", "value", "interface", "{", "}", ")", "error", "{", "// encode response", "bytes", ",", "err", ":=", "json", ".", "Marshal", "(", "value", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "// write token", "_", ",", "err", "=", "c", ".", "ResponseWriter", ".", "Write", "(", "bytes", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Respond will encode the provided value as JSON and write it to the client.", "docstring_tokens": ["Respond", "will", "encode", "the", "provided", "value", "as", "JSON", "and", "write", "it", "to", "the", "client", "."], "sha": "fa66e74352b30b9a4c730f7b8dc773302941b0fb", "url": "https://github.com/256dpi/fire/blob/fa66e74352b30b9a4c730f7b8dc773302941b0fb/context.go#L253-L267", "partition": "test"}
{"repo": "kljensen/snowball", "path": "russian/step3.go", "func_name": "step3", "original_string": "func step3(word *snowballword.SnowballWord) bool {\n\n\t// Search for a DERIVATIONAL ending in R2 (i.e. the entire\n\t// ending must lie in R2), and if one is found, remove it.\n\n\tsuffix, _ := word.RemoveFirstSuffixIn(word.R2start, \"\u043e\u0441\u0442\", \"\u043e\u0441\u0442\u044c\")\n\tif suffix != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}", "language": "go", "code": "func step3(word *snowballword.SnowballWord) bool {\n\n\t// Search for a DERIVATIONAL ending in R2 (i.e. the entire\n\t// ending must lie in R2), and if one is found, remove it.\n\n\tsuffix, _ := word.RemoveFirstSuffixIn(word.R2start, \"\u043e\u0441\u0442\", \"\u043e\u0441\u0442\u044c\")\n\tif suffix != \"\" {\n\t\treturn true\n\t}\n\treturn false\n}", "code_tokens": ["func", "step3", "(", "word", "*", "snowballword", ".", "SnowballWord", ")", "bool", "{", "// Search for a DERIVATIONAL ending in R2 (i.e. the entire", "// ending must lie in R2), and if one is found, remove it.", "suffix", ",", "_", ":=", "word", ".", "RemoveFirstSuffixIn", "(", "word", ".", "R2start", ",", "\"", "\"", "\u043e", "\u0442", "", "", "\n", "if", "suffix", "!=", "\"", "\"", "{", "return", "true", "\n", "}", "\n", "return", "false", "\n", "}"], "docstring": "// Step 3 is the removal of the derivational suffix.\n//", "docstring_tokens": ["Step", "3", "is", "the", "removal", "of", "the", "derivational", "suffix", "."], "sha": "115fa8f6419dcfb9ec4653997b1c6803a5eff962", "url": "https://github.com/kljensen/snowball/blob/115fa8f6419dcfb9ec4653997b1c6803a5eff962/russian/step3.go#L9-L19", "partition": "test"}
{"repo": "geoffgarside/ber", "path": "ber.go", "func_name": "UnmarshalWithParams", "original_string": "func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err error) {\n\tv := reflect.ValueOf(val).Elem()\n\toffset, err := parseField(v, b, 0, parseFieldParameters(params))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn b[offset:], nil\n}", "language": "go", "code": "func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err error) {\n\tv := reflect.ValueOf(val).Elem()\n\toffset, err := parseField(v, b, 0, parseFieldParameters(params))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn b[offset:], nil\n}", "code_tokens": ["func", "UnmarshalWithParams", "(", "b", "[", "]", "byte", ",", "val", "interface", "{", "}", ",", "params", "string", ")", "(", "rest", "[", "]", "byte", ",", "err", "error", ")", "{", "v", ":=", "reflect", ".", "ValueOf", "(", "val", ")", ".", "Elem", "(", ")", "\n", "offset", ",", "err", ":=", "parseField", "(", "v", ",", "b", ",", "0", ",", "parseFieldParameters", "(", "params", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "b", "[", "offset", ":", "]", ",", "nil", "\n", "}"], "docstring": "// UnmarshalWithParams allows field parameters to be specified for the\n// top-level element. The form of the params is the same as the field tags.", "docstring_tokens": ["UnmarshalWithParams", "allows", "field", "parameters", "to", "be", "specified", "for", "the", "top", "-", "level", "element", ".", "The", "form", "of", "the", "params", "is", "the", "same", "as", "the", "field", "tags", "."], "sha": "27a1aff36ce64dbe5d93c08cc5f161983134ddc5", "url": "https://github.com/geoffgarside/ber/blob/27a1aff36ce64dbe5d93c08cc5f161983134ddc5/ber.go#L892-L899", "partition": "test"}
{"repo": "containers/image", "path": "signature/policy_config.go", "func_name": "NewPRSignedByKeyPath", "original_string": "func NewPRSignedByKeyPath(keyType sbKeyType, keyPath string, signedIdentity PolicyReferenceMatch) (PolicyRequirement, error) {\n\treturn newPRSignedByKeyPath(keyType, keyPath, signedIdentity)\n}", "language": "go", "code": "func NewPRSignedByKeyPath(keyType sbKeyType, keyPath string, signedIdentity PolicyReferenceMatch) (PolicyRequirement, error) {\n\treturn newPRSignedByKeyPath(keyType, keyPath, signedIdentity)\n}", "code_tokens": ["func", "NewPRSignedByKeyPath", "(", "keyType", "sbKeyType", ",", "keyPath", "string", ",", "signedIdentity", "PolicyReferenceMatch", ")", "(", "PolicyRequirement", ",", "error", ")", "{", "return", "newPRSignedByKeyPath", "(", "keyType", ",", "keyPath", ",", "signedIdentity", ")", "\n", "}"], "docstring": "// NewPRSignedByKeyPath returns a new \"signedBy\" PolicyRequirement using a KeyPath", "docstring_tokens": ["NewPRSignedByKeyPath", "returns", "a", "new", "signedBy", "PolicyRequirement", "using", "a", "KeyPath"], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/signature/policy_config.go#L331-L333", "partition": "test"}
{"repo": "malice-plugins/go-plugin-utils", "path": "database/elasticsearch/elasticsearch.go", "func_name": "WaitForConnection", "original_string": "func (db *Database) WaitForConnection(ctx context.Context, timeout int) error {\n\n\tvar err error\n\n\tsecondsWaited := 0\n\n\tconnCtx, cancel := context.WithTimeout(ctx, time.Duration(timeout)*time.Second)\n\tdefer cancel()\n\n\tlog.Debug(\"===> trying to connect to elasticsearch\")\n\tfor {\n\t\t// Try to connect to Elasticsearch\n\t\tselect {\n\t\tcase <-connCtx.Done():\n\t\t\treturn errors.Wrapf(err, \"connecting to elasticsearch timed out after %d seconds\", secondsWaited)\n\t\tdefault:\n\t\t\terr = db.TestConnection()\n\t\t\tif err == nil {\n\t\t\t\tlog.Debugf(\"elasticsearch came online after %d seconds\", secondsWaited)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// not ready yet\n\t\t\tsecondsWaited++\n\t\t\tlog.Debug(\" * could not connect to elasticsearch (sleeping for 1 second)\")\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}\n}", "language": "go", "code": "func (db *Database) WaitForConnection(ctx context.Context, timeout int) error {\n\n\tvar err error\n\n\tsecondsWaited := 0\n\n\tconnCtx, cancel := context.WithTimeout(ctx, time.Duration(timeout)*time.Second)\n\tdefer cancel()\n\n\tlog.Debug(\"===> trying to connect to elasticsearch\")\n\tfor {\n\t\t// Try to connect to Elasticsearch\n\t\tselect {\n\t\tcase <-connCtx.Done():\n\t\t\treturn errors.Wrapf(err, \"connecting to elasticsearch timed out after %d seconds\", secondsWaited)\n\t\tdefault:\n\t\t\terr = db.TestConnection()\n\t\t\tif err == nil {\n\t\t\t\tlog.Debugf(\"elasticsearch came online after %d seconds\", secondsWaited)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// not ready yet\n\t\t\tsecondsWaited++\n\t\t\tlog.Debug(\" * could not connect to elasticsearch (sleeping for 1 second)\")\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "db", "*", "Database", ")", "WaitForConnection", "(", "ctx", "context", ".", "Context", ",", "timeout", "int", ")", "error", "{", "var", "err", "error", "\n\n", "secondsWaited", ":=", "0", "\n\n", "connCtx", ",", "cancel", ":=", "context", ".", "WithTimeout", "(", "ctx", ",", "time", ".", "Duration", "(", "timeout", ")", "*", "time", ".", "Second", ")", "\n", "defer", "cancel", "(", ")", "\n\n", "log", ".", "Debug", "(", "\"", "\"", ")", "\n", "for", "{", "// Try to connect to Elasticsearch", "select", "{", "case", "<-", "connCtx", ".", "Done", "(", ")", ":", "return", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ",", "secondsWaited", ")", "\n", "default", ":", "err", "=", "db", ".", "TestConnection", "(", ")", "\n", "if", "err", "==", "nil", "{", "log", ".", "Debugf", "(", "\"", "\"", ",", "secondsWaited", ")", "\n", "return", "nil", "\n", "}", "\n", "// not ready yet", "secondsWaited", "++", "\n", "log", ".", "Debug", "(", "\"", "\"", ")", "\n", "time", ".", "Sleep", "(", "1", "*", "time", ".", "Second", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// WaitForConnection waits for connection to Elasticsearch to be ready", "docstring_tokens": ["WaitForConnection", "waits", "for", "connection", "to", "Elasticsearch", "to", "be", "ready"], "sha": "9ee76663c3b0a531b8c529f03f12a5a84ff9b61b", "url": "https://github.com/malice-plugins/go-plugin-utils/blob/9ee76663c3b0a531b8c529f03f12a5a84ff9b61b/database/elasticsearch/elasticsearch.go#L164-L191", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "clientv3/retry_interceptor.go", "func_name": "isSafeRetry", "original_string": "func isSafeRetry(lg *zap.Logger, err error, callOpts *options) bool {\n\tif isContextError(err) {\n\t\treturn false\n\t}\n\tswitch callOpts.retryPolicy {\n\tcase repeatable:\n\t\treturn isSafeRetryImmutableRPC(err)\n\tcase nonRepeatable:\n\t\treturn isSafeRetryMutableRPC(err)\n\tdefault:\n\t\tlg.Warn(\"unrecognized retry policy\", zap.String(\"retryPolicy\", callOpts.retryPolicy.String()))\n\t\treturn false\n\t}\n}", "language": "go", "code": "func isSafeRetry(lg *zap.Logger, err error, callOpts *options) bool {\n\tif isContextError(err) {\n\t\treturn false\n\t}\n\tswitch callOpts.retryPolicy {\n\tcase repeatable:\n\t\treturn isSafeRetryImmutableRPC(err)\n\tcase nonRepeatable:\n\t\treturn isSafeRetryMutableRPC(err)\n\tdefault:\n\t\tlg.Warn(\"unrecognized retry policy\", zap.String(\"retryPolicy\", callOpts.retryPolicy.String()))\n\t\treturn false\n\t}\n}", "code_tokens": ["func", "isSafeRetry", "(", "lg", "*", "zap", ".", "Logger", ",", "err", "error", ",", "callOpts", "*", "options", ")", "bool", "{", "if", "isContextError", "(", "err", ")", "{", "return", "false", "\n", "}", "\n", "switch", "callOpts", ".", "retryPolicy", "{", "case", "repeatable", ":", "return", "isSafeRetryImmutableRPC", "(", "err", ")", "\n", "case", "nonRepeatable", ":", "return", "isSafeRetryMutableRPC", "(", "err", ")", "\n", "default", ":", "lg", ".", "Warn", "(", "\"", "\"", ",", "zap", ".", "String", "(", "\"", "\"", ",", "callOpts", ".", "retryPolicy", ".", "String", "(", ")", ")", ")", "\n", "return", "false", "\n", "}", "\n", "}"], "docstring": "// isSafeRetry returns \"true\", if request is safe for retry with the given error.", "docstring_tokens": ["isSafeRetry", "returns", "true", "if", "request", "is", "safe", "for", "retry", "with", "the", "given", "error", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/retry_interceptor.go#L277-L290", "partition": "test"}
{"repo": "enaml-ops/enaml", "path": "release/pivnetrelease.go", "func_name": "BoshReleaseOrEmpty", "original_string": "func (r *PivnetRelease) BoshReleaseOrEmpty(name string) *BoshRelease {\n\tbr := r.BoshRelease[name]\n\tif br == nil {\n\t\tbr = emptyBoshRelease\n\t}\n\treturn br\n}", "language": "go", "code": "func (r *PivnetRelease) BoshReleaseOrEmpty(name string) *BoshRelease {\n\tbr := r.BoshRelease[name]\n\tif br == nil {\n\t\tbr = emptyBoshRelease\n\t}\n\treturn br\n}", "code_tokens": ["func", "(", "r", "*", "PivnetRelease", ")", "BoshReleaseOrEmpty", "(", "name", "string", ")", "*", "BoshRelease", "{", "br", ":=", "r", ".", "BoshRelease", "[", "name", "]", "\n", "if", "br", "==", "nil", "{", "br", "=", "emptyBoshRelease", "\n", "}", "\n", "return", "br", "\n", "}"], "docstring": "// BoshReleaseOrEmpty returns the named BOSH release from this pivnet release\n// if it exists, otherwise emptyBoshRelease is returned.", "docstring_tokens": ["BoshReleaseOrEmpty", "returns", "the", "named", "BOSH", "release", "from", "this", "pivnet", "release", "if", "it", "exists", "otherwise", "emptyBoshRelease", "is", "returned", "."], "sha": "4f847ee10b41afca41fe09fa839cb2f6ade06fb5", "url": "https://github.com/enaml-ops/enaml/blob/4f847ee10b41afca41fe09fa839cb2f6ade06fb5/release/pivnetrelease.go#L32-L38", "partition": "test"}
{"repo": "guregu/null", "path": "bool.go", "func_name": "UnmarshalJSON", "original_string": "func (b *Bool) UnmarshalJSON(data []byte) error {\n\tvar err error\n\tvar v interface{}\n\tif err = json.Unmarshal(data, &v); err != nil {\n\t\treturn err\n\t}\n\tswitch x := v.(type) {\n\tcase bool:\n\t\tb.Bool = x\n\tcase map[string]interface{}:\n\t\terr = json.Unmarshal(data, &b.NullBool)\n\tcase nil:\n\t\tb.Valid = false\n\t\treturn nil\n\tdefault:\n\t\terr = fmt.Errorf(\"json: cannot unmarshal %v into Go value of type null.Bool\", reflect.TypeOf(v).Name())\n\t}\n\tb.Valid = err == nil\n\treturn err\n}", "language": "go", "code": "func (b *Bool) UnmarshalJSON(data []byte) error {\n\tvar err error\n\tvar v interface{}\n\tif err = json.Unmarshal(data, &v); err != nil {\n\t\treturn err\n\t}\n\tswitch x := v.(type) {\n\tcase bool:\n\t\tb.Bool = x\n\tcase map[string]interface{}:\n\t\terr = json.Unmarshal(data, &b.NullBool)\n\tcase nil:\n\t\tb.Valid = false\n\t\treturn nil\n\tdefault:\n\t\terr = fmt.Errorf(\"json: cannot unmarshal %v into Go value of type null.Bool\", reflect.TypeOf(v).Name())\n\t}\n\tb.Valid = err == nil\n\treturn err\n}", "code_tokens": ["func", "(", "b", "*", "Bool", ")", "UnmarshalJSON", "(", "data", "[", "]", "byte", ")", "error", "{", "var", "err", "error", "\n", "var", "v", "interface", "{", "}", "\n", "if", "err", "=", "json", ".", "Unmarshal", "(", "data", ",", "&", "v", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "switch", "x", ":=", "v", ".", "(", "type", ")", "{", "case", "bool", ":", "b", ".", "Bool", "=", "x", "\n", "case", "map", "[", "string", "]", "interface", "{", "}", ":", "err", "=", "json", ".", "Unmarshal", "(", "data", ",", "&", "b", ".", "NullBool", ")", "\n", "case", "nil", ":", "b", ".", "Valid", "=", "false", "\n", "return", "nil", "\n", "default", ":", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "reflect", ".", "TypeOf", "(", "v", ")", ".", "Name", "(", ")", ")", "\n", "}", "\n", "b", ".", "Valid", "=", "err", "==", "nil", "\n", "return", "err", "\n", "}"], "docstring": "// UnmarshalJSON implements json.Unmarshaler.\n// It supports number and null input.\n// 0 will not be considered a null Bool.\n// It also supports unmarshalling a sql.NullBool.", "docstring_tokens": ["UnmarshalJSON", "implements", "json", ".", "Unmarshaler", ".", "It", "supports", "number", "and", "null", "input", ".", "0", "will", "not", "be", "considered", "a", "null", "Bool", ".", "It", "also", "supports", "unmarshalling", "a", "sql", ".", "NullBool", "."], "sha": "80515d440932108546bcade467bb7d6968e812e2", "url": "https://github.com/guregu/null/blob/80515d440932108546bcade467bb7d6968e812e2/bool.go#L50-L69", "partition": "test"}
{"repo": "justinfx/gofileseq", "path": "cmd/seqls/manager.go", "func_name": "preparePaths", "original_string": "func preparePaths(paths []string) ([]string, fileseq.FileSequences) {\n\tvar (\n\t\tfi  os.FileInfo\n\t\terr error\n\t)\n\n\tdirs := make([]string, 0)\n\tseqs := make(fileseq.FileSequences, 0)\n\tprevious := make(map[string]struct{})\n\n\tfor _, p := range paths {\n\t\tp := strings.TrimSpace(filepath.Clean(p))\n\t\tif p == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, seen := previous[p]; seen {\n\t\t\tcontinue\n\t\t}\n\t\tprevious[p] = struct{}{}\n\n\t\tif fi, err = os.Stat(p); err != nil {\n\n\t\t\t// If the path doesn't exist, test it for\n\t\t\t// a valid fileseq pattern\n\t\t\tif seq, err := fileseq.NewFileSequence(p); err == nil {\n\t\t\t\tseqs = append(seqs, seq)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintf(errOut, \"%s %q: %s\\n\", ErrorPath, p, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tdirs = append(dirs, p)\n\t}\n\n\treturn dirs, seqs\n}", "language": "go", "code": "func preparePaths(paths []string) ([]string, fileseq.FileSequences) {\n\tvar (\n\t\tfi  os.FileInfo\n\t\terr error\n\t)\n\n\tdirs := make([]string, 0)\n\tseqs := make(fileseq.FileSequences, 0)\n\tprevious := make(map[string]struct{})\n\n\tfor _, p := range paths {\n\t\tp := strings.TrimSpace(filepath.Clean(p))\n\t\tif p == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, seen := previous[p]; seen {\n\t\t\tcontinue\n\t\t}\n\t\tprevious[p] = struct{}{}\n\n\t\tif fi, err = os.Stat(p); err != nil {\n\n\t\t\t// If the path doesn't exist, test it for\n\t\t\t// a valid fileseq pattern\n\t\t\tif seq, err := fileseq.NewFileSequence(p); err == nil {\n\t\t\t\tseqs = append(seqs, seq)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintf(errOut, \"%s %q: %s\\n\", ErrorPath, p, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tdirs = append(dirs, p)\n\t}\n\n\treturn dirs, seqs\n}", "code_tokens": ["func", "preparePaths", "(", "paths", "[", "]", "string", ")", "(", "[", "]", "string", ",", "fileseq", ".", "FileSequences", ")", "{", "var", "(", "fi", "os", ".", "FileInfo", "\n", "err", "error", "\n", ")", "\n\n", "dirs", ":=", "make", "(", "[", "]", "string", ",", "0", ")", "\n", "seqs", ":=", "make", "(", "fileseq", ".", "FileSequences", ",", "0", ")", "\n", "previous", ":=", "make", "(", "map", "[", "string", "]", "struct", "{", "}", ")", "\n\n", "for", "_", ",", "p", ":=", "range", "paths", "{", "p", ":=", "strings", ".", "TrimSpace", "(", "filepath", ".", "Clean", "(", "p", ")", ")", "\n", "if", "p", "==", "\"", "\"", "{", "continue", "\n", "}", "\n\n", "if", "_", ",", "seen", ":=", "previous", "[", "p", "]", ";", "seen", "{", "continue", "\n", "}", "\n", "previous", "[", "p", "]", "=", "struct", "{", "}", "{", "}", "\n\n", "if", "fi", ",", "err", "=", "os", ".", "Stat", "(", "p", ")", ";", "err", "!=", "nil", "{", "// If the path doesn't exist, test it for", "// a valid fileseq pattern", "if", "seq", ",", "err", ":=", "fileseq", ".", "NewFileSequence", "(", "p", ")", ";", "err", "==", "nil", "{", "seqs", "=", "append", "(", "seqs", ",", "seq", ")", "\n", "continue", "\n", "}", "\n\n", "fmt", ".", "Fprintf", "(", "errOut", ",", "\"", "\\n", "\"", ",", "ErrorPath", ",", "p", ",", "err", ")", "\n", "continue", "\n", "}", "\n\n", "if", "!", "fi", ".", "IsDir", "(", ")", "{", "continue", "\n", "}", "\n\n", "dirs", "=", "append", "(", "dirs", ",", "p", ")", "\n", "}", "\n\n", "return", "dirs", ",", "seqs", "\n", "}"], "docstring": "// Take a list of paths and reduce them to cleaned\n// and unique paths. Return two slices, separated by\n// directory paths, and sequence patterns", "docstring_tokens": ["Take", "a", "list", "of", "paths", "and", "reduce", "them", "to", "cleaned", "and", "unique", "paths", ".", "Return", "two", "slices", "separated", "by", "directory", "paths", "and", "sequence", "patterns"], "sha": "2555f296b4493d1825f5f6fab4aa0ff51a8306cd", "url": "https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/cmd/seqls/manager.go#L292-L334", "partition": "test"}
{"repo": "golang/appengine", "path": "socket/socket_classic.go", "func_name": "KeepAlive", "original_string": "func (cn *Conn) KeepAlive() error {\n\treq := &pb.GetSocketNameRequest{\n\t\tSocketDescriptor: &cn.desc,\n\t}\n\tres := &pb.GetSocketNameReply{}\n\treturn internal.Call(cn.ctx, \"remote_socket\", \"GetSocketName\", req, res)\n}", "language": "go", "code": "func (cn *Conn) KeepAlive() error {\n\treq := &pb.GetSocketNameRequest{\n\t\tSocketDescriptor: &cn.desc,\n\t}\n\tres := &pb.GetSocketNameReply{}\n\treturn internal.Call(cn.ctx, \"remote_socket\", \"GetSocketName\", req, res)\n}", "code_tokens": ["func", "(", "cn", "*", "Conn", ")", "KeepAlive", "(", ")", "error", "{", "req", ":=", "&", "pb", ".", "GetSocketNameRequest", "{", "SocketDescriptor", ":", "&", "cn", ".", "desc", ",", "}", "\n", "res", ":=", "&", "pb", ".", "GetSocketNameReply", "{", "}", "\n", "return", "internal", ".", "Call", "(", "cn", ".", "ctx", ",", "\"", "\"", ",", "\"", "\"", ",", "req", ",", "res", ")", "\n", "}"], "docstring": "// KeepAlive signals that the connection is still in use.\n// It may be called to prevent the socket being closed due to inactivity.", "docstring_tokens": ["KeepAlive", "signals", "that", "the", "connection", "is", "still", "in", "use", ".", "It", "may", "be", "called", "to", "prevent", "the", "socket", "being", "closed", "due", "to", "inactivity", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/socket/socket_classic.go#L280-L286", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "default_context.go", "func_name": "File", "original_string": "func (d *DefaultContext) File(name string) (binding.File, error) {\n\treq := d.Request()\n\tif err := req.ParseMultipartForm(5 * 1024 * 1024); err != nil {\n\t\treturn binding.File{}, err\n\t}\n\tf, h, err := req.FormFile(name)\n\tbf := binding.File{\n\t\tFile:       f,\n\t\tFileHeader: h,\n\t}\n\tif err != nil {\n\t\treturn bf, err\n\t}\n\treturn bf, nil\n}", "language": "go", "code": "func (d *DefaultContext) File(name string) (binding.File, error) {\n\treq := d.Request()\n\tif err := req.ParseMultipartForm(5 * 1024 * 1024); err != nil {\n\t\treturn binding.File{}, err\n\t}\n\tf, h, err := req.FormFile(name)\n\tbf := binding.File{\n\t\tFile:       f,\n\t\tFileHeader: h,\n\t}\n\tif err != nil {\n\t\treturn bf, err\n\t}\n\treturn bf, nil\n}", "code_tokens": ["func", "(", "d", "*", "DefaultContext", ")", "File", "(", "name", "string", ")", "(", "binding", ".", "File", ",", "error", ")", "{", "req", ":=", "d", ".", "Request", "(", ")", "\n", "if", "err", ":=", "req", ".", "ParseMultipartForm", "(", "5", "*", "1024", "*", "1024", ")", ";", "err", "!=", "nil", "{", "return", "binding", ".", "File", "{", "}", ",", "err", "\n", "}", "\n", "f", ",", "h", ",", "err", ":=", "req", ".", "FormFile", "(", "name", ")", "\n", "bf", ":=", "binding", ".", "File", "{", "File", ":", "f", ",", "FileHeader", ":", "h", ",", "}", "\n", "if", "err", "!=", "nil", "{", "return", "bf", ",", "err", "\n", "}", "\n", "return", "bf", ",", "nil", "\n", "}"], "docstring": "// File returns an uploaded file by name, or an error", "docstring_tokens": ["File", "returns", "an", "uploaded", "file", "by", "name", "or", "an", "error"], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/default_context.go#L248-L262", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/storage_zfs_utils.go", "func_name": "zfsIsEnabled", "original_string": "func zfsIsEnabled() bool {\n\tout, err := exec.LookPath(\"zfs\")\n\tif err != nil || len(out) == 0 {\n\t\treturn false\n\t}\n\n\treturn true\n}", "language": "go", "code": "func zfsIsEnabled() bool {\n\tout, err := exec.LookPath(\"zfs\")\n\tif err != nil || len(out) == 0 {\n\t\treturn false\n\t}\n\n\treturn true\n}", "code_tokens": ["func", "zfsIsEnabled", "(", ")", "bool", "{", "out", ",", "err", ":=", "exec", ".", "LookPath", "(", "\"", "\"", ")", "\n", "if", "err", "!=", "nil", "||", "len", "(", "out", ")", "==", "0", "{", "return", "false", "\n", "}", "\n\n", "return", "true", "\n", "}"], "docstring": "// zfsIsEnabled returns whether zfs backend is supported.", "docstring_tokens": ["zfsIsEnabled", "returns", "whether", "zfs", "backend", "is", "supported", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/storage_zfs_utils.go#L20-L27", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/price.go", "func_name": "String", "original_string": "func (p *Price) String() string {\n\treturn big.NewRat(int64(p.N), int64(p.D)).FloatString(7)\n}", "language": "go", "code": "func (p *Price) String() string {\n\treturn big.NewRat(int64(p.N), int64(p.D)).FloatString(7)\n}", "code_tokens": ["func", "(", "p", "*", "Price", ")", "String", "(", ")", "string", "{", "return", "big", ".", "NewRat", "(", "int64", "(", "p", ".", "N", ")", ",", "int64", "(", "p", ".", "D", ")", ")", ".", "FloatString", "(", "7", ")", "\n", "}"], "docstring": "// String returns a string represenation of `p`", "docstring_tokens": ["String", "returns", "a", "string", "represenation", "of", "p"], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/price.go#L8-L10", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "badger/cmd/bank.go", "func_name": "seekTotal", "original_string": "func seekTotal(txn *badger.Txn) ([]account, error) {\n\texpected := uint64(numAccounts) * uint64(initialBal)\n\tvar accounts []account\n\n\tvar total uint64\n\tfor i := 0; i < numAccounts; i++ {\n\t\titem, err := txn.Get(key(i))\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error for account: %d. err=%v. key=%q\\n\", i, err, key(i))\n\t\t\treturn accounts, err\n\t\t}\n\t\tval, err := item.ValueCopy(nil)\n\t\tif err != nil {\n\t\t\treturn accounts, err\n\t\t}\n\t\tacc := account{\n\t\t\tId:  i,\n\t\t\tBal: toUint64(val),\n\t\t}\n\t\taccounts = append(accounts, acc)\n\t\ttotal += acc.Bal\n\t}\n\tif total != expected {\n\t\tlog.Printf(\"Balance did NOT match up. Expected: %d. Received: %d\",\n\t\t\texpected, total)\n\t\tatomic.AddInt32(&stopAll, 1)\n\t\treturn accounts, errFailure\n\t}\n\treturn accounts, nil\n}", "language": "go", "code": "func seekTotal(txn *badger.Txn) ([]account, error) {\n\texpected := uint64(numAccounts) * uint64(initialBal)\n\tvar accounts []account\n\n\tvar total uint64\n\tfor i := 0; i < numAccounts; i++ {\n\t\titem, err := txn.Get(key(i))\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error for account: %d. err=%v. key=%q\\n\", i, err, key(i))\n\t\t\treturn accounts, err\n\t\t}\n\t\tval, err := item.ValueCopy(nil)\n\t\tif err != nil {\n\t\t\treturn accounts, err\n\t\t}\n\t\tacc := account{\n\t\t\tId:  i,\n\t\t\tBal: toUint64(val),\n\t\t}\n\t\taccounts = append(accounts, acc)\n\t\ttotal += acc.Bal\n\t}\n\tif total != expected {\n\t\tlog.Printf(\"Balance did NOT match up. Expected: %d. Received: %d\",\n\t\t\texpected, total)\n\t\tatomic.AddInt32(&stopAll, 1)\n\t\treturn accounts, errFailure\n\t}\n\treturn accounts, nil\n}", "code_tokens": ["func", "seekTotal", "(", "txn", "*", "badger", ".", "Txn", ")", "(", "[", "]", "account", ",", "error", ")", "{", "expected", ":=", "uint64", "(", "numAccounts", ")", "*", "uint64", "(", "initialBal", ")", "\n", "var", "accounts", "[", "]", "account", "\n\n", "var", "total", "uint64", "\n", "for", "i", ":=", "0", ";", "i", "<", "numAccounts", ";", "i", "++", "{", "item", ",", "err", ":=", "txn", ".", "Get", "(", "key", "(", "i", ")", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Printf", "(", "\"", "\\n", "\"", ",", "i", ",", "err", ",", "key", "(", "i", ")", ")", "\n", "return", "accounts", ",", "err", "\n", "}", "\n", "val", ",", "err", ":=", "item", ".", "ValueCopy", "(", "nil", ")", "\n", "if", "err", "!=", "nil", "{", "return", "accounts", ",", "err", "\n", "}", "\n", "acc", ":=", "account", "{", "Id", ":", "i", ",", "Bal", ":", "toUint64", "(", "val", ")", ",", "}", "\n", "accounts", "=", "append", "(", "accounts", ",", "acc", ")", "\n", "total", "+=", "acc", ".", "Bal", "\n", "}", "\n", "if", "total", "!=", "expected", "{", "log", ".", "Printf", "(", "\"", "\"", ",", "expected", ",", "total", ")", "\n", "atomic", ".", "AddInt32", "(", "&", "stopAll", ",", "1", ")", "\n", "return", "accounts", ",", "errFailure", "\n", "}", "\n", "return", "accounts", ",", "nil", "\n", "}"], "docstring": "// seekTotal retrives the total of all accounts by seeking for each account key.", "docstring_tokens": ["seekTotal", "retrives", "the", "total", "of", "all", "accounts", "by", "seeking", "for", "each", "account", "key", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/badger/cmd/bank.go#L181-L210", "partition": "test"}
{"repo": "blacksails/cgp", "path": "domain.go", "func_name": "Domains", "original_string": "func (cgp *CGP) Domains() ([]*Domain, error) {\n\tvar vl valueList\n\terr := cgp.request(listDomains{}, &vl)\n\tif err != nil {\n\t\treturn []*Domain{}, err\n\t}\n\tvals := vl.SubValues\n\tds := make([]*Domain, len(vals))\n\tfor i, d := range vals {\n\t\tds[i] = cgp.Domain(d)\n\t}\n\treturn ds, nil\n}", "language": "go", "code": "func (cgp *CGP) Domains() ([]*Domain, error) {\n\tvar vl valueList\n\terr := cgp.request(listDomains{}, &vl)\n\tif err != nil {\n\t\treturn []*Domain{}, err\n\t}\n\tvals := vl.SubValues\n\tds := make([]*Domain, len(vals))\n\tfor i, d := range vals {\n\t\tds[i] = cgp.Domain(d)\n\t}\n\treturn ds, nil\n}", "code_tokens": ["func", "(", "cgp", "*", "CGP", ")", "Domains", "(", ")", "(", "[", "]", "*", "Domain", ",", "error", ")", "{", "var", "vl", "valueList", "\n", "err", ":=", "cgp", ".", "request", "(", "listDomains", "{", "}", ",", "&", "vl", ")", "\n", "if", "err", "!=", "nil", "{", "return", "[", "]", "*", "Domain", "{", "}", ",", "err", "\n", "}", "\n", "vals", ":=", "vl", ".", "SubValues", "\n", "ds", ":=", "make", "(", "[", "]", "*", "Domain", ",", "len", "(", "vals", ")", ")", "\n", "for", "i", ",", "d", ":=", "range", "vals", "{", "ds", "[", "i", "]", "=", "cgp", ".", "Domain", "(", "d", ")", "\n", "}", "\n", "return", "ds", ",", "nil", "\n", "}"], "docstring": "// Domains lists the domains on the server", "docstring_tokens": ["Domains", "lists", "the", "domains", "on", "the", "server"], "sha": "570ac705cf2d7a9235d911d00b6f976ab3386c2f", "url": "https://github.com/blacksails/cgp/blob/570ac705cf2d7a9235d911d00b6f976ab3386c2f/domain.go#L54-L66", "partition": "test"}
{"repo": "containers/image", "path": "copy/manifest.go", "func_name": "isMultiImage", "original_string": "func isMultiImage(ctx context.Context, img types.UnparsedImage) (bool, error) {\n\t_, mt, err := img.Manifest(ctx)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn manifest.MIMETypeIsMultiImage(mt), nil\n}", "language": "go", "code": "func isMultiImage(ctx context.Context, img types.UnparsedImage) (bool, error) {\n\t_, mt, err := img.Manifest(ctx)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn manifest.MIMETypeIsMultiImage(mt), nil\n}", "code_tokens": ["func", "isMultiImage", "(", "ctx", "context", ".", "Context", ",", "img", "types", ".", "UnparsedImage", ")", "(", "bool", ",", "error", ")", "{", "_", ",", "mt", ",", "err", ":=", "img", ".", "Manifest", "(", "ctx", ")", "\n", "if", "err", "!=", "nil", "{", "return", "false", ",", "err", "\n", "}", "\n", "return", "manifest", ".", "MIMETypeIsMultiImage", "(", "mt", ")", ",", "nil", "\n", "}"], "docstring": "// isMultiImage returns true if img is a list of images", "docstring_tokens": ["isMultiImage", "returns", "true", "if", "img", "is", "a", "list", "of", "images"], "sha": "da9ab3561ad2031aeb5e036b7cf2755d4e246fec", "url": "https://github.com/containers/image/blob/da9ab3561ad2031aeb5e036b7cf2755d4e246fec/copy/manifest.go#L115-L121", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "backgroundservice/backgroundservice.go", "func_name": "Do", "original_string": "func (p *StopObservingParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStopObserving, p, nil)\n}", "language": "go", "code": "func (p *StopObservingParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandStopObserving, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "StopObservingParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandStopObserving", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes BackgroundService.stopObserving against the provided context.", "docstring_tokens": ["Do", "executes", "BackgroundService", ".", "stopObserving", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/backgroundservice/backgroundservice.go#L57-L59", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "merger/fix.go", "func_name": "fixLoad", "original_string": "func fixLoad(load *rule.Load, file string, kinds map[string]bool, knownKinds map[string]string) *rule.Load {\n\tif load == nil {\n\t\tif len(kinds) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tload = rule.NewLoad(file)\n\t}\n\n\tfor k := range kinds {\n\t\tload.Add(k)\n\t}\n\tfor _, k := range load.Symbols() {\n\t\tif knownKinds[k] != \"\" && !kinds[k] {\n\t\t\tload.Remove(k)\n\t\t}\n\t}\n\treturn load\n}", "language": "go", "code": "func fixLoad(load *rule.Load, file string, kinds map[string]bool, knownKinds map[string]string) *rule.Load {\n\tif load == nil {\n\t\tif len(kinds) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tload = rule.NewLoad(file)\n\t}\n\n\tfor k := range kinds {\n\t\tload.Add(k)\n\t}\n\tfor _, k := range load.Symbols() {\n\t\tif knownKinds[k] != \"\" && !kinds[k] {\n\t\t\tload.Remove(k)\n\t\t}\n\t}\n\treturn load\n}", "code_tokens": ["func", "fixLoad", "(", "load", "*", "rule", ".", "Load", ",", "file", "string", ",", "kinds", "map", "[", "string", "]", "bool", ",", "knownKinds", "map", "[", "string", "]", "string", ")", "*", "rule", ".", "Load", "{", "if", "load", "==", "nil", "{", "if", "len", "(", "kinds", ")", "==", "0", "{", "return", "nil", "\n", "}", "\n", "load", "=", "rule", ".", "NewLoad", "(", "file", ")", "\n", "}", "\n\n", "for", "k", ":=", "range", "kinds", "{", "load", ".", "Add", "(", "k", ")", "\n", "}", "\n", "for", "_", ",", "k", ":=", "range", "load", ".", "Symbols", "(", ")", "{", "if", "knownKinds", "[", "k", "]", "!=", "\"", "\"", "&&", "!", "kinds", "[", "k", "]", "{", "load", ".", "Remove", "(", "k", ")", "\n", "}", "\n", "}", "\n", "return", "load", "\n", "}"], "docstring": "// fixLoad updates a load statement with the given symbols. If load is nil,\n// a new load may be created and returned. Symbols in kinds will be added\n// to the load if they're not already present. Known symbols not in kinds\n// will be removed if present. Other symbols will be preserved. If load is\n// empty, nil is returned.", "docstring_tokens": ["fixLoad", "updates", "a", "load", "statement", "with", "the", "given", "symbols", ".", "If", "load", "is", "nil", "a", "new", "load", "may", "be", "created", "and", "returned", ".", "Symbols", "in", "kinds", "will", "be", "added", "to", "the", "load", "if", "they", "re", "not", "already", "present", ".", "Known", "symbols", "not", "in", "kinds", "will", "be", "removed", "if", "present", ".", "Other", "symbols", "will", "be", "preserved", ".", "If", "load", "is", "empty", "nil", "is", "returned", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/merger/fix.go#L105-L122", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "gossip.go", "func_name": "Flush", "original_string": "func (s *gossipSender) Flush() bool {\n\tch := make(chan bool)\n\ts.flush <- ch\n\treturn <-ch\n}", "language": "go", "code": "func (s *gossipSender) Flush() bool {\n\tch := make(chan bool)\n\ts.flush <- ch\n\treturn <-ch\n}", "code_tokens": ["func", "(", "s", "*", "gossipSender", ")", "Flush", "(", ")", "bool", "{", "ch", ":=", "make", "(", "chan", "bool", ")", "\n", "s", ".", "flush", "<-", "ch", "\n", "return", "<-", "ch", "\n", "}"], "docstring": "// Flush sends all pending data, and returns true if anything was sent since\n// the previous flush. For testing.", "docstring_tokens": ["Flush", "sends", "all", "pending", "data", "and", "returns", "true", "if", "anything", "was", "sent", "since", "the", "previous", "flush", ".", "For", "testing", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/gossip.go#L214-L218", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "arguments.go", "func_name": "WriteJSON", "original_string": "func (w ArgWriteHelper) WriteJSON(data interface{}) error {\n\treturn w.write(func() error {\n\t\te := json.NewEncoder(w.writer)\n\t\treturn e.Encode(data)\n\t})\n}", "language": "go", "code": "func (w ArgWriteHelper) WriteJSON(data interface{}) error {\n\treturn w.write(func() error {\n\t\te := json.NewEncoder(w.writer)\n\t\treturn e.Encode(data)\n\t})\n}", "code_tokens": ["func", "(", "w", "ArgWriteHelper", ")", "WriteJSON", "(", "data", "interface", "{", "}", ")", "error", "{", "return", "w", ".", "write", "(", "func", "(", ")", "error", "{", "e", ":=", "json", ".", "NewEncoder", "(", "w", ".", "writer", ")", "\n", "return", "e", ".", "Encode", "(", "data", ")", "\n", "}", ")", "\n", "}"], "docstring": "// WriteJSON writes the given object as JSON.", "docstring_tokens": ["WriteJSON", "writes", "the", "given", "object", "as", "JSON", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/arguments.go#L145-L150", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/plugins/trigger/pull-request.go", "func_name": "TrustedPullRequest", "original_string": "func TrustedPullRequest(ghc githubClient, trigger plugins.Trigger, author, org, repo string, num int, l []github.Label) ([]github.Label, bool, error) {\n\t// First check if the author is a member of the org.\n\tif orgMember, err := TrustedUser(ghc, trigger, author, org, repo); err != nil {\n\t\treturn l, false, fmt.Errorf(\"error checking %s for trust: %v\", author, err)\n\t} else if orgMember {\n\t\treturn l, true, nil\n\t}\n\t// Then check if PR has ok-to-test label\n\tif l == nil {\n\t\tvar err error\n\t\tl, err = ghc.GetIssueLabels(org, repo, num)\n\t\tif err != nil {\n\t\t\treturn l, false, err\n\t\t}\n\t}\n\treturn l, github.HasLabel(labels.OkToTest, l), nil\n}", "language": "go", "code": "func TrustedPullRequest(ghc githubClient, trigger plugins.Trigger, author, org, repo string, num int, l []github.Label) ([]github.Label, bool, error) {\n\t// First check if the author is a member of the org.\n\tif orgMember, err := TrustedUser(ghc, trigger, author, org, repo); err != nil {\n\t\treturn l, false, fmt.Errorf(\"error checking %s for trust: %v\", author, err)\n\t} else if orgMember {\n\t\treturn l, true, nil\n\t}\n\t// Then check if PR has ok-to-test label\n\tif l == nil {\n\t\tvar err error\n\t\tl, err = ghc.GetIssueLabels(org, repo, num)\n\t\tif err != nil {\n\t\t\treturn l, false, err\n\t\t}\n\t}\n\treturn l, github.HasLabel(labels.OkToTest, l), nil\n}", "code_tokens": ["func", "TrustedPullRequest", "(", "ghc", "githubClient", ",", "trigger", "plugins", ".", "Trigger", ",", "author", ",", "org", ",", "repo", "string", ",", "num", "int", ",", "l", "[", "]", "github", ".", "Label", ")", "(", "[", "]", "github", ".", "Label", ",", "bool", ",", "error", ")", "{", "// First check if the author is a member of the org.", "if", "orgMember", ",", "err", ":=", "TrustedUser", "(", "ghc", ",", "trigger", ",", "author", ",", "org", ",", "repo", ")", ";", "err", "!=", "nil", "{", "return", "l", ",", "false", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "author", ",", "err", ")", "\n", "}", "else", "if", "orgMember", "{", "return", "l", ",", "true", ",", "nil", "\n", "}", "\n", "// Then check if PR has ok-to-test label", "if", "l", "==", "nil", "{", "var", "err", "error", "\n", "l", ",", "err", "=", "ghc", ".", "GetIssueLabels", "(", "org", ",", "repo", ",", "num", ")", "\n", "if", "err", "!=", "nil", "{", "return", "l", ",", "false", ",", "err", "\n", "}", "\n", "}", "\n", "return", "l", ",", "github", ".", "HasLabel", "(", "labels", ".", "OkToTest", ",", "l", ")", ",", "nil", "\n", "}"], "docstring": "// TrustedPullRequest returns whether or not the given PR should be tested.\n// It first checks if the author is in the org, then looks for \"ok-to-test\" label.", "docstring_tokens": ["TrustedPullRequest", "returns", "whether", "or", "not", "the", "given", "PR", "should", "be", "tested", ".", "It", "first", "checks", "if", "the", "author", "is", "in", "the", "org", "then", "looks", "for", "ok", "-", "to", "-", "test", "label", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/plugins/trigger/pull-request.go#L207-L223", "partition": "test"}
{"repo": "iron-io/functions_go", "path": "client/apps/delete_apps_app_parameters.go", "func_name": "WithTimeout", "original_string": "func (o *DeleteAppsAppParams) WithTimeout(timeout time.Duration) *DeleteAppsAppParams {\n\to.SetTimeout(timeout)\n\treturn o\n}", "language": "go", "code": "func (o *DeleteAppsAppParams) WithTimeout(timeout time.Duration) *DeleteAppsAppParams {\n\to.SetTimeout(timeout)\n\treturn o\n}", "code_tokens": ["func", "(", "o", "*", "DeleteAppsAppParams", ")", "WithTimeout", "(", "timeout", "time", ".", "Duration", ")", "*", "DeleteAppsAppParams", "{", "o", ".", "SetTimeout", "(", "timeout", ")", "\n", "return", "o", "\n", "}"], "docstring": "// WithTimeout adds the timeout to the delete apps app params", "docstring_tokens": ["WithTimeout", "adds", "the", "timeout", "to", "the", "delete", "apps", "app", "params"], "sha": "91b84f5bbb17095bf1c7028ec6e70a3dc06a5893", "url": "https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/apps/delete_apps_app_parameters.go#L77-L80", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/storage_pools.go", "func_name": "StoragePoolVolumeGetTypeID", "original_string": "func (c *Cluster) StoragePoolVolumeGetTypeID(project string, volumeName string, volumeType int, poolID, nodeID int64) (int64, error) {\n\tvolumeID := int64(-1)\n\tquery := `SELECT storage_volumes.id\nFROM storage_volumes\nJOIN storage_pools ON storage_volumes.storage_pool_id = storage_pools.id\nJOIN projects ON storage_volumes.project_id = projects.id\nWHERE projects.name=? AND storage_volumes.storage_pool_id=? AND storage_volumes.node_id=?\nAND storage_volumes.name=? AND storage_volumes.type=?`\n\tinargs := []interface{}{project, poolID, nodeID, volumeName, volumeType}\n\toutargs := []interface{}{&volumeID}\n\n\terr := dbQueryRowScan(c.db, query, inargs, outargs)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn -1, ErrNoSuchObject\n\t\t}\n\t\treturn -1, err\n\t}\n\n\treturn volumeID, nil\n}", "language": "go", "code": "func (c *Cluster) StoragePoolVolumeGetTypeID(project string, volumeName string, volumeType int, poolID, nodeID int64) (int64, error) {\n\tvolumeID := int64(-1)\n\tquery := `SELECT storage_volumes.id\nFROM storage_volumes\nJOIN storage_pools ON storage_volumes.storage_pool_id = storage_pools.id\nJOIN projects ON storage_volumes.project_id = projects.id\nWHERE projects.name=? AND storage_volumes.storage_pool_id=? AND storage_volumes.node_id=?\nAND storage_volumes.name=? AND storage_volumes.type=?`\n\tinargs := []interface{}{project, poolID, nodeID, volumeName, volumeType}\n\toutargs := []interface{}{&volumeID}\n\n\terr := dbQueryRowScan(c.db, query, inargs, outargs)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn -1, ErrNoSuchObject\n\t\t}\n\t\treturn -1, err\n\t}\n\n\treturn volumeID, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "StoragePoolVolumeGetTypeID", "(", "project", "string", ",", "volumeName", "string", ",", "volumeType", "int", ",", "poolID", ",", "nodeID", "int64", ")", "(", "int64", ",", "error", ")", "{", "volumeID", ":=", "int64", "(", "-", "1", ")", "\n", "query", ":=", "`SELECT storage_volumes.id\nFROM storage_volumes\nJOIN storage_pools ON storage_volumes.storage_pool_id = storage_pools.id\nJOIN projects ON storage_volumes.project_id = projects.id\nWHERE projects.name=? AND storage_volumes.storage_pool_id=? AND storage_volumes.node_id=?\nAND storage_volumes.name=? AND storage_volumes.type=?`", "\n", "inargs", ":=", "[", "]", "interface", "{", "}", "{", "project", ",", "poolID", ",", "nodeID", ",", "volumeName", ",", "volumeType", "}", "\n", "outargs", ":=", "[", "]", "interface", "{", "}", "{", "&", "volumeID", "}", "\n\n", "err", ":=", "dbQueryRowScan", "(", "c", ".", "db", ",", "query", ",", "inargs", ",", "outargs", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", "==", "sql", ".", "ErrNoRows", "{", "return", "-", "1", ",", "ErrNoSuchObject", "\n", "}", "\n", "return", "-", "1", ",", "err", "\n", "}", "\n\n", "return", "volumeID", ",", "nil", "\n", "}"], "docstring": "// StoragePoolVolumeGetTypeID returns the ID of a storage volume on a given\n// storage pool of a given storage volume type, on the given node.", "docstring_tokens": ["StoragePoolVolumeGetTypeID", "returns", "the", "ID", "of", "a", "storage", "volume", "on", "a", "given", "storage", "pool", "of", "a", "given", "storage", "volume", "type", "on", "the", "given", "node", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/storage_pools.go#L1013-L1033", "partition": "test"}
{"repo": "olorin/nagiosplugin", "path": "result.go", "func_name": "NewDefaultStatusPolicy", "original_string": "func NewDefaultStatusPolicy() *statusPolicy {\n\treturn &statusPolicy{\n\t\tOK:       statusSeverity(OK),\n\t\tWARNING:  statusSeverity(WARNING),\n\t\tCRITICAL: statusSeverity(CRITICAL),\n\t\tUNKNOWN:  statusSeverity(UNKNOWN),\n\t}\n}", "language": "go", "code": "func NewDefaultStatusPolicy() *statusPolicy {\n\treturn &statusPolicy{\n\t\tOK:       statusSeverity(OK),\n\t\tWARNING:  statusSeverity(WARNING),\n\t\tCRITICAL: statusSeverity(CRITICAL),\n\t\tUNKNOWN:  statusSeverity(UNKNOWN),\n\t}\n}", "code_tokens": ["func", "NewDefaultStatusPolicy", "(", ")", "*", "statusPolicy", "{", "return", "&", "statusPolicy", "{", "OK", ":", "statusSeverity", "(", "OK", ")", ",", "WARNING", ":", "statusSeverity", "(", "WARNING", ")", ",", "CRITICAL", ":", "statusSeverity", "(", "CRITICAL", ")", ",", "UNKNOWN", ":", "statusSeverity", "(", "UNKNOWN", ")", ",", "}", "\n", "}"], "docstring": "// NewDefaultStatusPolicy returns a status policy that assigns relative\n// severity in accordance with conventional Nagios plugin return codes.\n// Statuses associated with higher return codes are more severe.", "docstring_tokens": ["NewDefaultStatusPolicy", "returns", "a", "status", "policy", "that", "assigns", "relative", "severity", "in", "accordance", "with", "conventional", "Nagios", "plugin", "return", "codes", ".", "Statuses", "associated", "with", "higher", "return", "codes", "are", "more", "severe", "."], "sha": "893f9702af4ea1e2dc4cd6528cbdcdb3dc7ca064", "url": "https://github.com/olorin/nagiosplugin/blob/893f9702af4ea1e2dc4cd6528cbdcdb3dc7ca064/result.go#L29-L36", "partition": "test"}
{"repo": "bsm/sarama-cluster", "path": "config.go", "func_name": "Validate", "original_string": "func (c *Config) Validate() error {\n\tif c.Group.Heartbeat.Interval%time.Millisecond != 0 {\n\t\tsarama.Logger.Println(\"Group.Heartbeat.Interval only supports millisecond precision; nanoseconds will be truncated.\")\n\t}\n\tif c.Group.Session.Timeout%time.Millisecond != 0 {\n\t\tsarama.Logger.Println(\"Group.Session.Timeout only supports millisecond precision; nanoseconds will be truncated.\")\n\t}\n\tif c.Group.PartitionStrategy != StrategyRange && c.Group.PartitionStrategy != StrategyRoundRobin {\n\t\tsarama.Logger.Println(\"Group.PartitionStrategy is not supported; range will be assumed.\")\n\t}\n\tif !c.Version.IsAtLeast(minVersion) {\n\t\tsarama.Logger.Println(\"Version is not supported; 0.9. will be assumed.\")\n\t\tc.Version = minVersion\n\t}\n\tif err := c.Config.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// validate the Group values\n\tswitch {\n\tcase c.Group.Offsets.Retry.Max < 0:\n\t\treturn sarama.ConfigurationError(\"Group.Offsets.Retry.Max must be >= 0\")\n\tcase c.Group.Offsets.Synchronization.DwellTime <= 0:\n\t\treturn sarama.ConfigurationError(\"Group.Offsets.Synchronization.DwellTime must be > 0\")\n\tcase c.Group.Offsets.Synchronization.DwellTime > 10*time.Minute:\n\t\treturn sarama.ConfigurationError(\"Group.Offsets.Synchronization.DwellTime must be <= 10m\")\n\tcase c.Group.Heartbeat.Interval <= 0:\n\t\treturn sarama.ConfigurationError(\"Group.Heartbeat.Interval must be > 0\")\n\tcase c.Group.Session.Timeout <= 0:\n\t\treturn sarama.ConfigurationError(\"Group.Session.Timeout must be > 0\")\n\tcase !c.Metadata.Full && c.Group.Topics.Whitelist != nil:\n\t\treturn sarama.ConfigurationError(\"Metadata.Full must be enabled when Group.Topics.Whitelist is used\")\n\tcase !c.Metadata.Full && c.Group.Topics.Blacklist != nil:\n\t\treturn sarama.ConfigurationError(\"Metadata.Full must be enabled when Group.Topics.Blacklist is used\")\n\t}\n\n\t// ensure offset is correct\n\tswitch c.Consumer.Offsets.Initial {\n\tcase sarama.OffsetOldest, sarama.OffsetNewest:\n\tdefault:\n\t\treturn sarama.ConfigurationError(\"Consumer.Offsets.Initial must be either OffsetOldest or OffsetNewest\")\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (c *Config) Validate() error {\n\tif c.Group.Heartbeat.Interval%time.Millisecond != 0 {\n\t\tsarama.Logger.Println(\"Group.Heartbeat.Interval only supports millisecond precision; nanoseconds will be truncated.\")\n\t}\n\tif c.Group.Session.Timeout%time.Millisecond != 0 {\n\t\tsarama.Logger.Println(\"Group.Session.Timeout only supports millisecond precision; nanoseconds will be truncated.\")\n\t}\n\tif c.Group.PartitionStrategy != StrategyRange && c.Group.PartitionStrategy != StrategyRoundRobin {\n\t\tsarama.Logger.Println(\"Group.PartitionStrategy is not supported; range will be assumed.\")\n\t}\n\tif !c.Version.IsAtLeast(minVersion) {\n\t\tsarama.Logger.Println(\"Version is not supported; 0.9. will be assumed.\")\n\t\tc.Version = minVersion\n\t}\n\tif err := c.Config.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// validate the Group values\n\tswitch {\n\tcase c.Group.Offsets.Retry.Max < 0:\n\t\treturn sarama.ConfigurationError(\"Group.Offsets.Retry.Max must be >= 0\")\n\tcase c.Group.Offsets.Synchronization.DwellTime <= 0:\n\t\treturn sarama.ConfigurationError(\"Group.Offsets.Synchronization.DwellTime must be > 0\")\n\tcase c.Group.Offsets.Synchronization.DwellTime > 10*time.Minute:\n\t\treturn sarama.ConfigurationError(\"Group.Offsets.Synchronization.DwellTime must be <= 10m\")\n\tcase c.Group.Heartbeat.Interval <= 0:\n\t\treturn sarama.ConfigurationError(\"Group.Heartbeat.Interval must be > 0\")\n\tcase c.Group.Session.Timeout <= 0:\n\t\treturn sarama.ConfigurationError(\"Group.Session.Timeout must be > 0\")\n\tcase !c.Metadata.Full && c.Group.Topics.Whitelist != nil:\n\t\treturn sarama.ConfigurationError(\"Metadata.Full must be enabled when Group.Topics.Whitelist is used\")\n\tcase !c.Metadata.Full && c.Group.Topics.Blacklist != nil:\n\t\treturn sarama.ConfigurationError(\"Metadata.Full must be enabled when Group.Topics.Blacklist is used\")\n\t}\n\n\t// ensure offset is correct\n\tswitch c.Consumer.Offsets.Initial {\n\tcase sarama.OffsetOldest, sarama.OffsetNewest:\n\tdefault:\n\t\treturn sarama.ConfigurationError(\"Consumer.Offsets.Initial must be either OffsetOldest or OffsetNewest\")\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "c", "*", "Config", ")", "Validate", "(", ")", "error", "{", "if", "c", ".", "Group", ".", "Heartbeat", ".", "Interval", "%", "time", ".", "Millisecond", "!=", "0", "{", "sarama", ".", "Logger", ".", "Println", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "c", ".", "Group", ".", "Session", ".", "Timeout", "%", "time", ".", "Millisecond", "!=", "0", "{", "sarama", ".", "Logger", ".", "Println", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "c", ".", "Group", ".", "PartitionStrategy", "!=", "StrategyRange", "&&", "c", ".", "Group", ".", "PartitionStrategy", "!=", "StrategyRoundRobin", "{", "sarama", ".", "Logger", ".", "Println", "(", "\"", "\"", ")", "\n", "}", "\n", "if", "!", "c", ".", "Version", ".", "IsAtLeast", "(", "minVersion", ")", "{", "sarama", ".", "Logger", ".", "Println", "(", "\"", "\"", ")", "\n", "c", ".", "Version", "=", "minVersion", "\n", "}", "\n", "if", "err", ":=", "c", ".", "Config", ".", "Validate", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "// validate the Group values", "switch", "{", "case", "c", ".", "Group", ".", "Offsets", ".", "Retry", ".", "Max", "<", "0", ":", "return", "sarama", ".", "ConfigurationError", "(", "\"", "\"", ")", "\n", "case", "c", ".", "Group", ".", "Offsets", ".", "Synchronization", ".", "DwellTime", "<=", "0", ":", "return", "sarama", ".", "ConfigurationError", "(", "\"", "\"", ")", "\n", "case", "c", ".", "Group", ".", "Offsets", ".", "Synchronization", ".", "DwellTime", ">", "10", "*", "time", ".", "Minute", ":", "return", "sarama", ".", "ConfigurationError", "(", "\"", "\"", ")", "\n", "case", "c", ".", "Group", ".", "Heartbeat", ".", "Interval", "<=", "0", ":", "return", "sarama", ".", "ConfigurationError", "(", "\"", "\"", ")", "\n", "case", "c", ".", "Group", ".", "Session", ".", "Timeout", "<=", "0", ":", "return", "sarama", ".", "ConfigurationError", "(", "\"", "\"", ")", "\n", "case", "!", "c", ".", "Metadata", ".", "Full", "&&", "c", ".", "Group", ".", "Topics", ".", "Whitelist", "!=", "nil", ":", "return", "sarama", ".", "ConfigurationError", "(", "\"", "\"", ")", "\n", "case", "!", "c", ".", "Metadata", ".", "Full", "&&", "c", ".", "Group", ".", "Topics", ".", "Blacklist", "!=", "nil", ":", "return", "sarama", ".", "ConfigurationError", "(", "\"", "\"", ")", "\n", "}", "\n\n", "// ensure offset is correct", "switch", "c", ".", "Consumer", ".", "Offsets", ".", "Initial", "{", "case", "sarama", ".", "OffsetOldest", ",", "sarama", ".", "OffsetNewest", ":", "default", ":", "return", "sarama", ".", "ConfigurationError", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Validate checks a Config instance. It will return a\n// sarama.ConfigurationError if the specified values don't make sense.", "docstring_tokens": ["Validate", "checks", "a", "Config", "instance", ".", "It", "will", "return", "a", "sarama", ".", "ConfigurationError", "if", "the", "specified", "values", "don", "t", "make", "sense", "."], "sha": "d5779253526cc8a3129a0e5d7cc429f4b4473ab4", "url": "https://github.com/bsm/sarama-cluster/blob/d5779253526cc8a3129a0e5d7cc429f4b4473ab4/config.go#L102-L146", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "integration/cluster.go", "func_name": "NewClientV3", "original_string": "func NewClientV3(m *member) (*clientv3.Client, error) {\n\tif m.grpcAddr == \"\" {\n\t\treturn nil, fmt.Errorf(\"member not configured for grpc\")\n\t}\n\n\tcfg := clientv3.Config{\n\t\tEndpoints:          []string{m.grpcAddr},\n\t\tDialTimeout:        5 * time.Second,\n\t\tDialOptions:        []grpc.DialOption{grpc.WithBlock()},\n\t\tMaxCallSendMsgSize: m.clientMaxCallSendMsgSize,\n\t\tMaxCallRecvMsgSize: m.clientMaxCallRecvMsgSize,\n\t}\n\n\tif m.ClientTLSInfo != nil {\n\t\ttls, err := m.ClientTLSInfo.ClientConfig()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcfg.TLS = tls\n\t}\n\tif m.DialOptions != nil {\n\t\tcfg.DialOptions = append(cfg.DialOptions, m.DialOptions...)\n\t}\n\treturn newClientV3(cfg)\n}", "language": "go", "code": "func NewClientV3(m *member) (*clientv3.Client, error) {\n\tif m.grpcAddr == \"\" {\n\t\treturn nil, fmt.Errorf(\"member not configured for grpc\")\n\t}\n\n\tcfg := clientv3.Config{\n\t\tEndpoints:          []string{m.grpcAddr},\n\t\tDialTimeout:        5 * time.Second,\n\t\tDialOptions:        []grpc.DialOption{grpc.WithBlock()},\n\t\tMaxCallSendMsgSize: m.clientMaxCallSendMsgSize,\n\t\tMaxCallRecvMsgSize: m.clientMaxCallRecvMsgSize,\n\t}\n\n\tif m.ClientTLSInfo != nil {\n\t\ttls, err := m.ClientTLSInfo.ClientConfig()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcfg.TLS = tls\n\t}\n\tif m.DialOptions != nil {\n\t\tcfg.DialOptions = append(cfg.DialOptions, m.DialOptions...)\n\t}\n\treturn newClientV3(cfg)\n}", "code_tokens": ["func", "NewClientV3", "(", "m", "*", "member", ")", "(", "*", "clientv3", ".", "Client", ",", "error", ")", "{", "if", "m", ".", "grpcAddr", "==", "\"", "\"", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n\n", "cfg", ":=", "clientv3", ".", "Config", "{", "Endpoints", ":", "[", "]", "string", "{", "m", ".", "grpcAddr", "}", ",", "DialTimeout", ":", "5", "*", "time", ".", "Second", ",", "DialOptions", ":", "[", "]", "grpc", ".", "DialOption", "{", "grpc", ".", "WithBlock", "(", ")", "}", ",", "MaxCallSendMsgSize", ":", "m", ".", "clientMaxCallSendMsgSize", ",", "MaxCallRecvMsgSize", ":", "m", ".", "clientMaxCallRecvMsgSize", ",", "}", "\n\n", "if", "m", ".", "ClientTLSInfo", "!=", "nil", "{", "tls", ",", "err", ":=", "m", ".", "ClientTLSInfo", ".", "ClientConfig", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "cfg", ".", "TLS", "=", "tls", "\n", "}", "\n", "if", "m", ".", "DialOptions", "!=", "nil", "{", "cfg", ".", "DialOptions", "=", "append", "(", "cfg", ".", "DialOptions", ",", "m", ".", "DialOptions", "...", ")", "\n", "}", "\n", "return", "newClientV3", "(", "cfg", ")", "\n", "}"], "docstring": "// NewClientV3 creates a new grpc client connection to the member", "docstring_tokens": ["NewClientV3", "creates", "a", "new", "grpc", "client", "connection", "to", "the", "member"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/integration/cluster.go#L726-L750", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdctl/ctlv3/command/make_mirror_command.go", "func_name": "NewMakeMirrorCommand", "original_string": "func NewMakeMirrorCommand() *cobra.Command {\n\tc := &cobra.Command{\n\t\tUse:   \"make-mirror [options] <destination>\",\n\t\tShort: \"Makes a mirror at the destination etcd cluster\",\n\t\tRun:   makeMirrorCommandFunc,\n\t}\n\n\tc.Flags().StringVar(&mmprefix, \"prefix\", \"\", \"Key-value prefix to mirror\")\n\tc.Flags().StringVar(&mmdestprefix, \"dest-prefix\", \"\", \"destination prefix to mirror a prefix to a different prefix in the destination cluster\")\n\tc.Flags().BoolVar(&mmnodestprefix, \"no-dest-prefix\", false, \"mirror key-values to the root of the destination cluster\")\n\tc.Flags().StringVar(&mmcert, \"dest-cert\", \"\", \"Identify secure client using this TLS certificate file for the destination cluster\")\n\tc.Flags().StringVar(&mmkey, \"dest-key\", \"\", \"Identify secure client using this TLS key file\")\n\tc.Flags().StringVar(&mmcacert, \"dest-cacert\", \"\", \"Verify certificates of TLS enabled secure servers using this CA bundle\")\n\t// TODO: secure by default when etcd enables secure gRPC by default.\n\tc.Flags().BoolVar(&mminsecureTr, \"dest-insecure-transport\", true, \"Disable transport security for client connections\")\n\n\treturn c\n}", "language": "go", "code": "func NewMakeMirrorCommand() *cobra.Command {\n\tc := &cobra.Command{\n\t\tUse:   \"make-mirror [options] <destination>\",\n\t\tShort: \"Makes a mirror at the destination etcd cluster\",\n\t\tRun:   makeMirrorCommandFunc,\n\t}\n\n\tc.Flags().StringVar(&mmprefix, \"prefix\", \"\", \"Key-value prefix to mirror\")\n\tc.Flags().StringVar(&mmdestprefix, \"dest-prefix\", \"\", \"destination prefix to mirror a prefix to a different prefix in the destination cluster\")\n\tc.Flags().BoolVar(&mmnodestprefix, \"no-dest-prefix\", false, \"mirror key-values to the root of the destination cluster\")\n\tc.Flags().StringVar(&mmcert, \"dest-cert\", \"\", \"Identify secure client using this TLS certificate file for the destination cluster\")\n\tc.Flags().StringVar(&mmkey, \"dest-key\", \"\", \"Identify secure client using this TLS key file\")\n\tc.Flags().StringVar(&mmcacert, \"dest-cacert\", \"\", \"Verify certificates of TLS enabled secure servers using this CA bundle\")\n\t// TODO: secure by default when etcd enables secure gRPC by default.\n\tc.Flags().BoolVar(&mminsecureTr, \"dest-insecure-transport\", true, \"Disable transport security for client connections\")\n\n\treturn c\n}", "code_tokens": ["func", "NewMakeMirrorCommand", "(", ")", "*", "cobra", ".", "Command", "{", "c", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Run", ":", "makeMirrorCommandFunc", ",", "}", "\n\n", "c", ".", "Flags", "(", ")", ".", "StringVar", "(", "&", "mmprefix", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "c", ".", "Flags", "(", ")", ".", "StringVar", "(", "&", "mmdestprefix", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "c", ".", "Flags", "(", ")", ".", "BoolVar", "(", "&", "mmnodestprefix", ",", "\"", "\"", ",", "false", ",", "\"", "\"", ")", "\n", "c", ".", "Flags", "(", ")", ".", "StringVar", "(", "&", "mmcert", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "c", ".", "Flags", "(", ")", ".", "StringVar", "(", "&", "mmkey", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "c", ".", "Flags", "(", ")", ".", "StringVar", "(", "&", "mmcacert", ",", "\"", "\"", ",", "\"", "\"", ",", "\"", "\"", ")", "\n", "// TODO: secure by default when etcd enables secure gRPC by default.", "c", ".", "Flags", "(", ")", ".", "BoolVar", "(", "&", "mminsecureTr", ",", "\"", "\"", ",", "true", ",", "\"", "\"", ")", "\n\n", "return", "c", "\n", "}"], "docstring": "// NewMakeMirrorCommand returns the cobra command for \"makeMirror\".", "docstring_tokens": ["NewMakeMirrorCommand", "returns", "the", "cobra", "command", "for", "makeMirror", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv3/command/make_mirror_command.go#L44-L61", "partition": "test"}
{"repo": "hooklift/govix", "path": "vm.go", "func_name": "Vcpus", "original_string": "func (v *VM) Vcpus() (uint8, error) {\n\tvar err C.VixError = C.VIX_OK\n\tvcpus := C.VIX_PROPERTY_NONE\n\n\terr = C.get_property(v.handle,\n\t\tC.VIX_PROPERTY_VM_NUM_VCPUS,\n\t\tunsafe.Pointer(&vcpus))\n\n\tif C.VIX_OK != err {\n\t\treturn 0, &Error{\n\t\t\tOperation: \"vm.Vcpus\",\n\t\t\tCode:      int(err & 0xFFFF),\n\t\t\tText:      C.GoString(C.Vix_GetErrorText(err, nil)),\n\t\t}\n\t}\n\n\treturn uint8(vcpus), nil\n}", "language": "go", "code": "func (v *VM) Vcpus() (uint8, error) {\n\tvar err C.VixError = C.VIX_OK\n\tvcpus := C.VIX_PROPERTY_NONE\n\n\terr = C.get_property(v.handle,\n\t\tC.VIX_PROPERTY_VM_NUM_VCPUS,\n\t\tunsafe.Pointer(&vcpus))\n\n\tif C.VIX_OK != err {\n\t\treturn 0, &Error{\n\t\t\tOperation: \"vm.Vcpus\",\n\t\t\tCode:      int(err & 0xFFFF),\n\t\t\tText:      C.GoString(C.Vix_GetErrorText(err, nil)),\n\t\t}\n\t}\n\n\treturn uint8(vcpus), nil\n}", "code_tokens": ["func", "(", "v", "*", "VM", ")", "Vcpus", "(", ")", "(", "uint8", ",", "error", ")", "{", "var", "err", "C", ".", "VixError", "=", "C", ".", "VIX_OK", "\n", "vcpus", ":=", "C", ".", "VIX_PROPERTY_NONE", "\n\n", "err", "=", "C", ".", "get_property", "(", "v", ".", "handle", ",", "C", ".", "VIX_PROPERTY_VM_NUM_VCPUS", ",", "unsafe", ".", "Pointer", "(", "&", "vcpus", ")", ")", "\n\n", "if", "C", ".", "VIX_OK", "!=", "err", "{", "return", "0", ",", "&", "Error", "{", "Operation", ":", "\"", "\"", ",", "Code", ":", "int", "(", "err", "&", "0xFFFF", ")", ",", "Text", ":", "C", ".", "GoString", "(", "C", ".", "Vix_GetErrorText", "(", "err", ",", "nil", ")", ")", ",", "}", "\n", "}", "\n\n", "return", "uint8", "(", "vcpus", ")", ",", "nil", "\n", "}"], "docstring": "// Vcpus returns number of virtual CPUs configured for the virtual machine.", "docstring_tokens": ["Vcpus", "returns", "number", "of", "virtual", "CPUs", "configured", "for", "the", "virtual", "machine", "."], "sha": "063702285520a992b920fc1575e305dc9ffd6ffe", "url": "https://github.com/hooklift/govix/blob/063702285520a992b920fc1575e305dc9ffd6ffe/vm.go#L54-L71", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "_metcd/etcd_store.go", "func_name": "proposeInternalRaftRequest", "original_string": "func (s *etcdStore) proposeInternalRaftRequest(req etcdserverpb.InternalRaftRequest) (<-chan proto.Message, <-chan error, error) {\n\tdata, err := req.Marshal()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif len(data) > maxRequestBytes {\n\t\treturn nil, nil, errTooBig\n\t}\n\tmsgc, errc, err := s.registerPending(req.ID)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ts.proposalc <- data\n\treturn msgc, errc, nil\n}", "language": "go", "code": "func (s *etcdStore) proposeInternalRaftRequest(req etcdserverpb.InternalRaftRequest) (<-chan proto.Message, <-chan error, error) {\n\tdata, err := req.Marshal()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif len(data) > maxRequestBytes {\n\t\treturn nil, nil, errTooBig\n\t}\n\tmsgc, errc, err := s.registerPending(req.ID)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ts.proposalc <- data\n\treturn msgc, errc, nil\n}", "code_tokens": ["func", "(", "s", "*", "etcdStore", ")", "proposeInternalRaftRequest", "(", "req", "etcdserverpb", ".", "InternalRaftRequest", ")", "(", "<-", "chan", "proto", ".", "Message", ",", "<-", "chan", "error", ",", "error", ")", "{", "data", ",", "err", ":=", "req", ".", "Marshal", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n", "if", "len", "(", "data", ")", ">", "maxRequestBytes", "{", "return", "nil", ",", "nil", ",", "errTooBig", "\n", "}", "\n", "msgc", ",", "errc", ",", "err", ":=", "s", ".", "registerPending", "(", "req", ".", "ID", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n", "s", ".", "proposalc", "<-", "data", "\n", "return", "msgc", ",", "errc", ",", "nil", "\n", "}"], "docstring": "// From public API method to proposalc.", "docstring_tokens": ["From", "public", "API", "method", "to", "proposalc", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/_metcd/etcd_store.go#L333-L347", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/hashtree/db.go", "func_name": "PutFileHeaderFooter", "original_string": "func (h *dbHashTree) PutFileHeaderFooter(path string, objects []*pfs.Object, size int64) error {\n\treturn h.putFile(path, objects, nil, size, true)\n}", "language": "go", "code": "func (h *dbHashTree) PutFileHeaderFooter(path string, objects []*pfs.Object, size int64) error {\n\treturn h.putFile(path, objects, nil, size, true)\n}", "code_tokens": ["func", "(", "h", "*", "dbHashTree", ")", "PutFileHeaderFooter", "(", "path", "string", ",", "objects", "[", "]", "*", "pfs", ".", "Object", ",", "size", "int64", ")", "error", "{", "return", "h", ".", "putFile", "(", "path", ",", "objects", ",", "nil", ",", "size", ",", "true", ")", "\n", "}"], "docstring": "// PutFileHeaderFooter implements the HashTree PutFileHeaderFooter method", "docstring_tokens": ["PutFileHeaderFooter", "implements", "the", "HashTree", "PutFileHeaderFooter", "method"], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/db.go#L765-L767", "partition": "test"}
{"repo": "golang/appengine", "path": "datastore/key.go", "func_name": "NewKey", "original_string": "func NewKey(c context.Context, kind, stringID string, intID int64, parent *Key) *Key {\n\t// If there's a parent key, use its namespace.\n\t// Otherwise, use any namespace attached to the context.\n\tvar namespace string\n\tif parent != nil {\n\t\tnamespace = parent.namespace\n\t} else {\n\t\tnamespace = internal.NamespaceFromContext(c)\n\t}\n\n\treturn &Key{\n\t\tkind:      kind,\n\t\tstringID:  stringID,\n\t\tintID:     intID,\n\t\tparent:    parent,\n\t\tappID:     internal.FullyQualifiedAppID(c),\n\t\tnamespace: namespace,\n\t}\n}", "language": "go", "code": "func NewKey(c context.Context, kind, stringID string, intID int64, parent *Key) *Key {\n\t// If there's a parent key, use its namespace.\n\t// Otherwise, use any namespace attached to the context.\n\tvar namespace string\n\tif parent != nil {\n\t\tnamespace = parent.namespace\n\t} else {\n\t\tnamespace = internal.NamespaceFromContext(c)\n\t}\n\n\treturn &Key{\n\t\tkind:      kind,\n\t\tstringID:  stringID,\n\t\tintID:     intID,\n\t\tparent:    parent,\n\t\tappID:     internal.FullyQualifiedAppID(c),\n\t\tnamespace: namespace,\n\t}\n}", "code_tokens": ["func", "NewKey", "(", "c", "context", ".", "Context", ",", "kind", ",", "stringID", "string", ",", "intID", "int64", ",", "parent", "*", "Key", ")", "*", "Key", "{", "// If there's a parent key, use its namespace.", "// Otherwise, use any namespace attached to the context.", "var", "namespace", "string", "\n", "if", "parent", "!=", "nil", "{", "namespace", "=", "parent", ".", "namespace", "\n", "}", "else", "{", "namespace", "=", "internal", ".", "NamespaceFromContext", "(", "c", ")", "\n", "}", "\n\n", "return", "&", "Key", "{", "kind", ":", "kind", ",", "stringID", ":", "stringID", ",", "intID", ":", "intID", ",", "parent", ":", "parent", ",", "appID", ":", "internal", ".", "FullyQualifiedAppID", "(", "c", ")", ",", "namespace", ":", "namespace", ",", "}", "\n", "}"], "docstring": "// NewKey creates a new key.\n// kind cannot be empty.\n// Either one or both of stringID and intID must be zero. If both are zero,\n// the key returned is incomplete.\n// parent must either be a complete key or nil.", "docstring_tokens": ["NewKey", "creates", "a", "new", "key", ".", "kind", "cannot", "be", "empty", ".", "Either", "one", "or", "both", "of", "stringID", "and", "intID", "must", "be", "zero", ".", "If", "both", "are", "zero", "the", "key", "returned", "is", "incomplete", ".", "parent", "must", "either", "be", "a", "complete", "key", "or", "nil", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/datastore/key.go#L274-L292", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pfs/fuse/filesystem.go", "func_name": "Mount", "original_string": "func Mount(c *client.APIClient, mountPoint string, opts *Options) error {\n\tnfs := pathfs.NewPathNodeFs(newFileSystem(c, opts.getCommits()), nil)\n\tserver, _, err := nodefs.MountRoot(mountPoint, nfs.Root(), opts.getFuse())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"nodefs.MountRoot: %v\", err)\n\t}\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt)\n\tgo func() {\n\t\tselect {\n\t\tcase <-sigChan:\n\t\tcase <-opts.getUnmount():\n\t\t}\n\t\tserver.Unmount()\n\t}()\n\tserver.Serve()\n\treturn nil\n}", "language": "go", "code": "func Mount(c *client.APIClient, mountPoint string, opts *Options) error {\n\tnfs := pathfs.NewPathNodeFs(newFileSystem(c, opts.getCommits()), nil)\n\tserver, _, err := nodefs.MountRoot(mountPoint, nfs.Root(), opts.getFuse())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"nodefs.MountRoot: %v\", err)\n\t}\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt)\n\tgo func() {\n\t\tselect {\n\t\tcase <-sigChan:\n\t\tcase <-opts.getUnmount():\n\t\t}\n\t\tserver.Unmount()\n\t}()\n\tserver.Serve()\n\treturn nil\n}", "code_tokens": ["func", "Mount", "(", "c", "*", "client", ".", "APIClient", ",", "mountPoint", "string", ",", "opts", "*", "Options", ")", "error", "{", "nfs", ":=", "pathfs", ".", "NewPathNodeFs", "(", "newFileSystem", "(", "c", ",", "opts", ".", "getCommits", "(", ")", ")", ",", "nil", ")", "\n", "server", ",", "_", ",", "err", ":=", "nodefs", ".", "MountRoot", "(", "mountPoint", ",", "nfs", ".", "Root", "(", ")", ",", "opts", ".", "getFuse", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "sigChan", ":=", "make", "(", "chan", "os", ".", "Signal", ",", "1", ")", "\n", "signal", ".", "Notify", "(", "sigChan", ",", "os", ".", "Interrupt", ")", "\n", "go", "func", "(", ")", "{", "select", "{", "case", "<-", "sigChan", ":", "case", "<-", "opts", ".", "getUnmount", "(", ")", ":", "}", "\n", "server", ".", "Unmount", "(", ")", "\n", "}", "(", ")", "\n", "server", ".", "Serve", "(", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// Mount pfs to mountPoint, opts may be left nil.", "docstring_tokens": ["Mount", "pfs", "to", "mountPoint", "opts", "may", "be", "left", "nil", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pfs/fuse/filesystem.go#L25-L42", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/client/version/client.go", "func_name": "PrettyPrintVersionNoAdditional", "original_string": "func PrettyPrintVersionNoAdditional(version *pb.Version) string {\n\treturn fmt.Sprintf(\"%d.%d.%d\", version.Major, version.Minor, version.Micro)\n}", "language": "go", "code": "func PrettyPrintVersionNoAdditional(version *pb.Version) string {\n\treturn fmt.Sprintf(\"%d.%d.%d\", version.Major, version.Minor, version.Micro)\n}", "code_tokens": ["func", "PrettyPrintVersionNoAdditional", "(", "version", "*", "pb", ".", "Version", ")", "string", "{", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "version", ".", "Major", ",", "version", ".", "Minor", ",", "version", ".", "Micro", ")", "\n", "}"], "docstring": "// PrettyPrintVersionNoAdditional returns a version string without\n// version.Additional.", "docstring_tokens": ["PrettyPrintVersionNoAdditional", "returns", "a", "version", "string", "without", "version", ".", "Additional", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/client/version/client.go#L52-L54", "partition": "test"}
{"repo": "akutz/gotil", "path": "gotil.go", "func_name": "FileExistsInPath", "original_string": "func FileExistsInPath(fileName string) bool {\n\t_, err := exec.LookPath(fileName)\n\treturn err == nil\n}", "language": "go", "code": "func FileExistsInPath(fileName string) bool {\n\t_, err := exec.LookPath(fileName)\n\treturn err == nil\n}", "code_tokens": ["func", "FileExistsInPath", "(", "fileName", "string", ")", "bool", "{", "_", ",", "err", ":=", "exec", ".", "LookPath", "(", "fileName", ")", "\n", "return", "err", "==", "nil", "\n", "}"], "docstring": "// FileExistsInPath returns a flag indicating whether the provided file exists\n// in the current path.", "docstring_tokens": ["FileExistsInPath", "returns", "a", "flag", "indicating", "whether", "the", "provided", "file", "exists", "in", "the", "current", "path", "."], "sha": "6fa2e80bd3ac40f15788cfc3d12ebba49a0add92", "url": "https://github.com/akutz/gotil/blob/6fa2e80bd3ac40f15788cfc3d12ebba49a0add92/gotil.go#L165-L168", "partition": "test"}
{"repo": "hashicorp/raft", "path": "net_transport.go", "func_name": "NewNetworkTransportWithConfig", "original_string": "func NewNetworkTransportWithConfig(\n\tconfig *NetworkTransportConfig,\n) *NetworkTransport {\n\tif config.Logger == nil {\n\t\tconfig.Logger = log.New(os.Stderr, \"\", log.LstdFlags)\n\t}\n\ttrans := &NetworkTransport{\n\t\tconnPool:              make(map[ServerAddress][]*netConn),\n\t\tconsumeCh:             make(chan RPC),\n\t\tlogger:                config.Logger,\n\t\tmaxPool:               config.MaxPool,\n\t\tshutdownCh:            make(chan struct{}),\n\t\tstream:                config.Stream,\n\t\ttimeout:               config.Timeout,\n\t\tTimeoutScale:          DefaultTimeoutScale,\n\t\tserverAddressProvider: config.ServerAddressProvider,\n\t}\n\n\t// Create the connection context and then start our listener.\n\ttrans.setupStreamContext()\n\tgo trans.listen()\n\n\treturn trans\n}", "language": "go", "code": "func NewNetworkTransportWithConfig(\n\tconfig *NetworkTransportConfig,\n) *NetworkTransport {\n\tif config.Logger == nil {\n\t\tconfig.Logger = log.New(os.Stderr, \"\", log.LstdFlags)\n\t}\n\ttrans := &NetworkTransport{\n\t\tconnPool:              make(map[ServerAddress][]*netConn),\n\t\tconsumeCh:             make(chan RPC),\n\t\tlogger:                config.Logger,\n\t\tmaxPool:               config.MaxPool,\n\t\tshutdownCh:            make(chan struct{}),\n\t\tstream:                config.Stream,\n\t\ttimeout:               config.Timeout,\n\t\tTimeoutScale:          DefaultTimeoutScale,\n\t\tserverAddressProvider: config.ServerAddressProvider,\n\t}\n\n\t// Create the connection context and then start our listener.\n\ttrans.setupStreamContext()\n\tgo trans.listen()\n\n\treturn trans\n}", "code_tokens": ["func", "NewNetworkTransportWithConfig", "(", "config", "*", "NetworkTransportConfig", ",", ")", "*", "NetworkTransport", "{", "if", "config", ".", "Logger", "==", "nil", "{", "config", ".", "Logger", "=", "log", ".", "New", "(", "os", ".", "Stderr", ",", "\"", "\"", ",", "log", ".", "LstdFlags", ")", "\n", "}", "\n", "trans", ":=", "&", "NetworkTransport", "{", "connPool", ":", "make", "(", "map", "[", "ServerAddress", "]", "[", "]", "*", "netConn", ")", ",", "consumeCh", ":", "make", "(", "chan", "RPC", ")", ",", "logger", ":", "config", ".", "Logger", ",", "maxPool", ":", "config", ".", "MaxPool", ",", "shutdownCh", ":", "make", "(", "chan", "struct", "{", "}", ")", ",", "stream", ":", "config", ".", "Stream", ",", "timeout", ":", "config", ".", "Timeout", ",", "TimeoutScale", ":", "DefaultTimeoutScale", ",", "serverAddressProvider", ":", "config", ".", "ServerAddressProvider", ",", "}", "\n\n", "// Create the connection context and then start our listener.", "trans", ".", "setupStreamContext", "(", ")", "\n", "go", "trans", ".", "listen", "(", ")", "\n\n", "return", "trans", "\n", "}"], "docstring": "// NewNetworkTransportWithConfig creates a new network transport with the given config struct", "docstring_tokens": ["NewNetworkTransportWithConfig", "creates", "a", "new", "network", "transport", "with", "the", "given", "config", "struct"], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/net_transport.go#L146-L169", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/generate/root.go", "func_name": "newRoot", "original_string": "func newRoot() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"lxd-generate\",\n\t\tShort: \"Code generation tool for LXD development\",\n\t\tLong: `This is the entry point for all \"go:generate\" directives\nused in LXD's source code.`,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn fmt.Errorf(\"Not implemented\")\n\t\t},\n\t}\n\tcmd.AddCommand(newDb())\n\n\treturn cmd\n}", "language": "go", "code": "func newRoot() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"lxd-generate\",\n\t\tShort: \"Code generation tool for LXD development\",\n\t\tLong: `This is the entry point for all \"go:generate\" directives\nused in LXD's source code.`,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn fmt.Errorf(\"Not implemented\")\n\t\t},\n\t}\n\tcmd.AddCommand(newDb())\n\n\treturn cmd\n}", "code_tokens": ["func", "newRoot", "(", ")", "*", "cobra", ".", "Command", "{", "cmd", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Long", ":", "`This is the entry point for all \"go:generate\" directives\nused in LXD's source code.`", ",", "RunE", ":", "func", "(", "cmd", "*", "cobra", ".", "Command", ",", "args", "[", "]", "string", ")", "error", "{", "return", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", ",", "}", "\n", "cmd", ".", "AddCommand", "(", "newDb", "(", ")", ")", "\n\n", "return", "cmd", "\n", "}"], "docstring": "// Return a new root command.", "docstring_tokens": ["Return", "a", "new", "root", "command", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/generate/root.go#L10-L23", "partition": "test"}
{"repo": "golang/appengine", "path": "log/log.go", "func_name": "Next", "original_string": "func (qr *Result) Next() (*Record, error) {\n\tif qr.err != nil {\n\t\treturn nil, qr.err\n\t}\n\tif len(qr.logs) > 0 {\n\t\tlr := qr.logs[0]\n\t\tqr.logs = qr.logs[1:]\n\t\treturn lr, nil\n\t}\n\n\tif qr.request.Offset == nil && qr.resultsSeen {\n\t\treturn nil, Done\n\t}\n\n\tif err := qr.run(); err != nil {\n\t\t// Errors here may be retried, so don't store the error.\n\t\treturn nil, err\n\t}\n\n\treturn qr.Next()\n}", "language": "go", "code": "func (qr *Result) Next() (*Record, error) {\n\tif qr.err != nil {\n\t\treturn nil, qr.err\n\t}\n\tif len(qr.logs) > 0 {\n\t\tlr := qr.logs[0]\n\t\tqr.logs = qr.logs[1:]\n\t\treturn lr, nil\n\t}\n\n\tif qr.request.Offset == nil && qr.resultsSeen {\n\t\treturn nil, Done\n\t}\n\n\tif err := qr.run(); err != nil {\n\t\t// Errors here may be retried, so don't store the error.\n\t\treturn nil, err\n\t}\n\n\treturn qr.Next()\n}", "code_tokens": ["func", "(", "qr", "*", "Result", ")", "Next", "(", ")", "(", "*", "Record", ",", "error", ")", "{", "if", "qr", ".", "err", "!=", "nil", "{", "return", "nil", ",", "qr", ".", "err", "\n", "}", "\n", "if", "len", "(", "qr", ".", "logs", ")", ">", "0", "{", "lr", ":=", "qr", ".", "logs", "[", "0", "]", "\n", "qr", ".", "logs", "=", "qr", ".", "logs", "[", "1", ":", "]", "\n", "return", "lr", ",", "nil", "\n", "}", "\n\n", "if", "qr", ".", "request", ".", "Offset", "==", "nil", "&&", "qr", ".", "resultsSeen", "{", "return", "nil", ",", "Done", "\n", "}", "\n\n", "if", "err", ":=", "qr", ".", "run", "(", ")", ";", "err", "!=", "nil", "{", "// Errors here may be retried, so don't store the error.", "return", "nil", ",", "err", "\n", "}", "\n\n", "return", "qr", ".", "Next", "(", ")", "\n", "}"], "docstring": "// Next returns the next log record,", "docstring_tokens": ["Next", "returns", "the", "next", "log", "record"], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/log/log.go#L147-L167", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "pkg/ghclient/wrappers.go", "func_name": "GetCombinedStatus", "original_string": "func (c *Client) GetCombinedStatus(owner, repo, ref string) (*github.CombinedStatus, error) {\n\tvar result *github.CombinedStatus\n\tlistOpts := &github.ListOptions{}\n\n\tstatuses, err := c.depaginate(\n\t\tfmt.Sprintf(\"getting combined status for ref '%s'\", ref),\n\t\tlistOpts,\n\t\tfunc() ([]interface{}, *github.Response, error) {\n\t\t\tcombined, resp, err := c.repoService.GetCombinedStatus(\n\t\t\t\tcontext.Background(),\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t\tref,\n\t\t\t\tlistOpts,\n\t\t\t)\n\t\t\tif result == nil {\n\t\t\t\tresult = combined\n\t\t\t}\n\n\t\t\tvar interfaceList []interface{}\n\t\t\tif err == nil {\n\t\t\t\tinterfaceList = make([]interface{}, 0, len(combined.Statuses))\n\t\t\t\tfor _, status := range combined.Statuses {\n\t\t\t\t\tinterfaceList = append(interfaceList, status)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn interfaceList, resp, err\n\t\t},\n\t)\n\n\tif result != nil {\n\t\tresult.Statuses = make([]github.RepoStatus, 0, len(statuses))\n\t\tfor _, status := range statuses {\n\t\t\tresult.Statuses = append(result.Statuses, status.(github.RepoStatus))\n\t\t}\n\t}\n\n\treturn result, err\n}", "language": "go", "code": "func (c *Client) GetCombinedStatus(owner, repo, ref string) (*github.CombinedStatus, error) {\n\tvar result *github.CombinedStatus\n\tlistOpts := &github.ListOptions{}\n\n\tstatuses, err := c.depaginate(\n\t\tfmt.Sprintf(\"getting combined status for ref '%s'\", ref),\n\t\tlistOpts,\n\t\tfunc() ([]interface{}, *github.Response, error) {\n\t\t\tcombined, resp, err := c.repoService.GetCombinedStatus(\n\t\t\t\tcontext.Background(),\n\t\t\t\towner,\n\t\t\t\trepo,\n\t\t\t\tref,\n\t\t\t\tlistOpts,\n\t\t\t)\n\t\t\tif result == nil {\n\t\t\t\tresult = combined\n\t\t\t}\n\n\t\t\tvar interfaceList []interface{}\n\t\t\tif err == nil {\n\t\t\t\tinterfaceList = make([]interface{}, 0, len(combined.Statuses))\n\t\t\t\tfor _, status := range combined.Statuses {\n\t\t\t\t\tinterfaceList = append(interfaceList, status)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn interfaceList, resp, err\n\t\t},\n\t)\n\n\tif result != nil {\n\t\tresult.Statuses = make([]github.RepoStatus, 0, len(statuses))\n\t\tfor _, status := range statuses {\n\t\t\tresult.Statuses = append(result.Statuses, status.(github.RepoStatus))\n\t\t}\n\t}\n\n\treturn result, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "GetCombinedStatus", "(", "owner", ",", "repo", ",", "ref", "string", ")", "(", "*", "github", ".", "CombinedStatus", ",", "error", ")", "{", "var", "result", "*", "github", ".", "CombinedStatus", "\n", "listOpts", ":=", "&", "github", ".", "ListOptions", "{", "}", "\n\n", "statuses", ",", "err", ":=", "c", ".", "depaginate", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "ref", ")", ",", "listOpts", ",", "func", "(", ")", "(", "[", "]", "interface", "{", "}", ",", "*", "github", ".", "Response", ",", "error", ")", "{", "combined", ",", "resp", ",", "err", ":=", "c", ".", "repoService", ".", "GetCombinedStatus", "(", "context", ".", "Background", "(", ")", ",", "owner", ",", "repo", ",", "ref", ",", "listOpts", ",", ")", "\n", "if", "result", "==", "nil", "{", "result", "=", "combined", "\n", "}", "\n\n", "var", "interfaceList", "[", "]", "interface", "{", "}", "\n", "if", "err", "==", "nil", "{", "interfaceList", "=", "make", "(", "[", "]", "interface", "{", "}", ",", "0", ",", "len", "(", "combined", ".", "Statuses", ")", ")", "\n", "for", "_", ",", "status", ":=", "range", "combined", ".", "Statuses", "{", "interfaceList", "=", "append", "(", "interfaceList", ",", "status", ")", "\n", "}", "\n", "}", "\n", "return", "interfaceList", ",", "resp", ",", "err", "\n", "}", ",", ")", "\n\n", "if", "result", "!=", "nil", "{", "result", ".", "Statuses", "=", "make", "(", "[", "]", "github", ".", "RepoStatus", ",", "0", ",", "len", "(", "statuses", ")", ")", "\n", "for", "_", ",", "status", ":=", "range", "statuses", "{", "result", ".", "Statuses", "=", "append", "(", "result", ".", "Statuses", ",", "status", ".", "(", "github", ".", "RepoStatus", ")", ")", "\n", "}", "\n", "}", "\n\n", "return", "result", ",", "err", "\n", "}"], "docstring": "// GetCombinedStatus retrieves the CombinedStatus for the specified reference.", "docstring_tokens": ["GetCombinedStatus", "retrieves", "the", "CombinedStatus", "for", "the", "specified", "reference", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/pkg/ghclient/wrappers.go#L172-L210", "partition": "test"}
{"repo": "blacksails/cgp", "path": "alias.go", "func_name": "Aliases", "original_string": "func (acc *Account) Aliases() ([]*Alias, error) {\n\tvar vl valueList\n\terr := acc.Domain.cgp.request(listAliases{Param: fmt.Sprintf(\"%s@%s\", acc.Name, acc.Domain.Name)}, &vl)\n\tif err != nil {\n\t\treturn []*Alias{}, err\n\t}\n\tvals := vl.compact()\n\tas := make([]*Alias, len(vals))\n\tfor i, v := range vals {\n\t\tas[i] = acc.Alias(v)\n\t}\n\treturn as, nil\n}", "language": "go", "code": "func (acc *Account) Aliases() ([]*Alias, error) {\n\tvar vl valueList\n\terr := acc.Domain.cgp.request(listAliases{Param: fmt.Sprintf(\"%s@%s\", acc.Name, acc.Domain.Name)}, &vl)\n\tif err != nil {\n\t\treturn []*Alias{}, err\n\t}\n\tvals := vl.compact()\n\tas := make([]*Alias, len(vals))\n\tfor i, v := range vals {\n\t\tas[i] = acc.Alias(v)\n\t}\n\treturn as, nil\n}", "code_tokens": ["func", "(", "acc", "*", "Account", ")", "Aliases", "(", ")", "(", "[", "]", "*", "Alias", ",", "error", ")", "{", "var", "vl", "valueList", "\n", "err", ":=", "acc", ".", "Domain", ".", "cgp", ".", "request", "(", "listAliases", "{", "Param", ":", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "acc", ".", "Name", ",", "acc", ".", "Domain", ".", "Name", ")", "}", ",", "&", "vl", ")", "\n", "if", "err", "!=", "nil", "{", "return", "[", "]", "*", "Alias", "{", "}", ",", "err", "\n", "}", "\n", "vals", ":=", "vl", ".", "compact", "(", ")", "\n", "as", ":=", "make", "(", "[", "]", "*", "Alias", ",", "len", "(", "vals", ")", ")", "\n", "for", "i", ",", "v", ":=", "range", "vals", "{", "as", "[", "i", "]", "=", "acc", ".", "Alias", "(", "v", ")", "\n", "}", "\n", "return", "as", ",", "nil", "\n", "}"], "docstring": "// Aliases lists the aliases of an account", "docstring_tokens": ["Aliases", "lists", "the", "aliases", "of", "an", "account"], "sha": "570ac705cf2d7a9235d911d00b6f976ab3386c2f", "url": "https://github.com/blacksails/cgp/blob/570ac705cf2d7a9235d911d00b6f976ab3386c2f/alias.go#L30-L42", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "profiler/profiler.go", "func_name": "Do", "original_string": "func (p *SetSamplingIntervalParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetSamplingInterval, p, nil)\n}", "language": "go", "code": "func (p *SetSamplingIntervalParams) Do(ctx context.Context) (err error) {\n\treturn cdp.Execute(ctx, CommandSetSamplingInterval, p, nil)\n}", "code_tokens": ["func", "(", "p", "*", "SetSamplingIntervalParams", ")", "Do", "(", "ctx", "context", ".", "Context", ")", "(", "err", "error", ")", "{", "return", "cdp", ".", "Execute", "(", "ctx", ",", "CommandSetSamplingInterval", ",", "p", ",", "nil", ")", "\n", "}"], "docstring": "// Do executes Profiler.setSamplingInterval against the provided context.", "docstring_tokens": ["Do", "executes", "Profiler", ".", "setSamplingInterval", "against", "the", "provided", "context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/profiler/profiler.go#L97-L99", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/config/schema.go", "func_name": "Defaults", "original_string": "func (s Schema) Defaults() map[string]interface{} {\n\tvalues := make(map[string]interface{}, len(s))\n\tfor name, key := range s {\n\t\tvalues[name] = key.Default\n\t}\n\treturn values\n}", "language": "go", "code": "func (s Schema) Defaults() map[string]interface{} {\n\tvalues := make(map[string]interface{}, len(s))\n\tfor name, key := range s {\n\t\tvalues[name] = key.Default\n\t}\n\treturn values\n}", "code_tokens": ["func", "(", "s", "Schema", ")", "Defaults", "(", ")", "map", "[", "string", "]", "interface", "{", "}", "{", "values", ":=", "make", "(", "map", "[", "string", "]", "interface", "{", "}", ",", "len", "(", "s", ")", ")", "\n", "for", "name", ",", "key", ":=", "range", "s", "{", "values", "[", "name", "]", "=", "key", ".", "Default", "\n", "}", "\n", "return", "values", "\n", "}"], "docstring": "// Defaults returns a map of all key names in the schema along with their default\n// values.", "docstring_tokens": ["Defaults", "returns", "a", "map", "of", "all", "key", "names", "in", "the", "schema", "along", "with", "their", "default", "values", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/config/schema.go#L30-L36", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "git/git.go", "func_name": "OpenRepository", "original_string": "func OpenRepository(p string) (*Repository, error) {\n\tif !strings.HasSuffix(p, \".git\") && !strings.HasSuffix(p, \".git/\") {\n\t\tp = filepath.Join(p, \".git\")\n\t}\n\tp = strings.TrimRight(p, \"/\")\n\tfi, err := os.Stat(filepath.Join(p, \"config\"))\n\tif err == nil && !fi.IsDir() {\n\t\treturn &Repository{path: p}, nil\n\t}\n\treturn nil, ErrRepositoryNotFound\n}", "language": "go", "code": "func OpenRepository(p string) (*Repository, error) {\n\tif !strings.HasSuffix(p, \".git\") && !strings.HasSuffix(p, \".git/\") {\n\t\tp = filepath.Join(p, \".git\")\n\t}\n\tp = strings.TrimRight(p, \"/\")\n\tfi, err := os.Stat(filepath.Join(p, \"config\"))\n\tif err == nil && !fi.IsDir() {\n\t\treturn &Repository{path: p}, nil\n\t}\n\treturn nil, ErrRepositoryNotFound\n}", "code_tokens": ["func", "OpenRepository", "(", "p", "string", ")", "(", "*", "Repository", ",", "error", ")", "{", "if", "!", "strings", ".", "HasSuffix", "(", "p", ",", "\"", "\"", ")", "&&", "!", "strings", ".", "HasSuffix", "(", "p", ",", "\"", "\"", ")", "{", "p", "=", "filepath", ".", "Join", "(", "p", ",", "\"", "\"", ")", "\n", "}", "\n", "p", "=", "strings", ".", "TrimRight", "(", "p", ",", "\"", "\"", ")", "\n", "fi", ",", "err", ":=", "os", ".", "Stat", "(", "filepath", ".", "Join", "(", "p", ",", "\"", "\"", ")", ")", "\n", "if", "err", "==", "nil", "&&", "!", "fi", ".", "IsDir", "(", ")", "{", "return", "&", "Repository", "{", "path", ":", "p", "}", ",", "nil", "\n", "}", "\n", "return", "nil", ",", "ErrRepositoryNotFound", "\n", "}"], "docstring": "// OpenRepository opens a repository by its filepath. You can use\n// DiscoverRepositoryPath to discover the repository from any directory, and\n// use the result of this call as parameter for OpenRepository.\n//\n// OpenRepository will return an error if the given path does not appear to be\n// a git repository.", "docstring_tokens": ["OpenRepository", "opens", "a", "repository", "by", "its", "filepath", ".", "You", "can", "use", "DiscoverRepositoryPath", "to", "discover", "the", "repository", "from", "any", "directory", "and", "use", "the", "result", "of", "this", "call", "as", "parameter", "for", "OpenRepository", ".", "OpenRepository", "will", "return", "an", "error", "if", "the", "given", "path", "does", "not", "appear", "to", "be", "a", "git", "repository", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/git/git.go#L54-L64", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "thrift/thrift-gen/wrap.go", "func_name": "ReturnWith", "original_string": "func (m *Method) ReturnWith(respName string, errName string) string {\n\tif !m.HasReturn() {\n\t\treturn errName\n\t}\n\treturn fmt.Sprintf(\"%v, %v\", respName, errName)\n}", "language": "go", "code": "func (m *Method) ReturnWith(respName string, errName string) string {\n\tif !m.HasReturn() {\n\t\treturn errName\n\t}\n\treturn fmt.Sprintf(\"%v, %v\", respName, errName)\n}", "code_tokens": ["func", "(", "m", "*", "Method", ")", "ReturnWith", "(", "respName", "string", ",", "errName", "string", ")", "string", "{", "if", "!", "m", ".", "HasReturn", "(", ")", "{", "return", "errName", "\n", "}", "\n", "return", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "respName", ",", "errName", ")", "\n", "}"], "docstring": "// ReturnWith takes the result name and the error name, and generates the return expression.", "docstring_tokens": ["ReturnWith", "takes", "the", "result", "name", "and", "the", "error", "name", "and", "generates", "the", "return", "expression", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/thrift/thrift-gen/wrap.go#L239-L244", "partition": "test"}
{"repo": "ant0ine/go-json-rest", "path": "rest/middleware.go", "func_name": "WrapMiddlewares", "original_string": "func WrapMiddlewares(middlewares []Middleware, handler HandlerFunc) HandlerFunc {\n\twrapped := handler\n\tfor i := len(middlewares) - 1; i >= 0; i-- {\n\t\twrapped = middlewares[i].MiddlewareFunc(wrapped)\n\t}\n\treturn wrapped\n}", "language": "go", "code": "func WrapMiddlewares(middlewares []Middleware, handler HandlerFunc) HandlerFunc {\n\twrapped := handler\n\tfor i := len(middlewares) - 1; i >= 0; i-- {\n\t\twrapped = middlewares[i].MiddlewareFunc(wrapped)\n\t}\n\treturn wrapped\n}", "code_tokens": ["func", "WrapMiddlewares", "(", "middlewares", "[", "]", "Middleware", ",", "handler", "HandlerFunc", ")", "HandlerFunc", "{", "wrapped", ":=", "handler", "\n", "for", "i", ":=", "len", "(", "middlewares", ")", "-", "1", ";", "i", ">=", "0", ";", "i", "--", "{", "wrapped", "=", "middlewares", "[", "i", "]", ".", "MiddlewareFunc", "(", "wrapped", ")", "\n", "}", "\n", "return", "wrapped", "\n", "}"], "docstring": "// WrapMiddlewares calls the MiddlewareFunc methods in the reverse order and returns an HandlerFunc\n// ready to be executed. This can be used to wrap a set of middlewares, post routing, on a per Route\n// basis.", "docstring_tokens": ["WrapMiddlewares", "calls", "the", "MiddlewareFunc", "methods", "in", "the", "reverse", "order", "and", "returns", "an", "HandlerFunc", "ready", "to", "be", "executed", ".", "This", "can", "be", "used", "to", "wrap", "a", "set", "of", "middlewares", "post", "routing", "on", "a", "per", "Route", "basis", "."], "sha": "ebb33769ae013bd5f518a8bac348c310dea768b8", "url": "https://github.com/ant0ine/go-json-rest/blob/ebb33769ae013bd5f518a8bac348c310dea768b8/rest/middleware.go#L43-L49", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/schema/query.go", "func_name": "DoesSchemaTableExist", "original_string": "func DoesSchemaTableExist(tx *sql.Tx) (bool, error) {\n\tstatement := `\nSELECT COUNT(name) FROM sqlite_master WHERE type = 'table' AND name = 'schema'\n`\n\trows, err := tx.Query(statement)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer rows.Close()\n\n\tif !rows.Next() {\n\t\treturn false, fmt.Errorf(\"schema table query returned no rows\")\n\t}\n\n\tvar count int\n\n\terr = rows.Scan(&count)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn count == 1, nil\n}", "language": "go", "code": "func DoesSchemaTableExist(tx *sql.Tx) (bool, error) {\n\tstatement := `\nSELECT COUNT(name) FROM sqlite_master WHERE type = 'table' AND name = 'schema'\n`\n\trows, err := tx.Query(statement)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer rows.Close()\n\n\tif !rows.Next() {\n\t\treturn false, fmt.Errorf(\"schema table query returned no rows\")\n\t}\n\n\tvar count int\n\n\terr = rows.Scan(&count)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn count == 1, nil\n}", "code_tokens": ["func", "DoesSchemaTableExist", "(", "tx", "*", "sql", ".", "Tx", ")", "(", "bool", ",", "error", ")", "{", "statement", ":=", "`\nSELECT COUNT(name) FROM sqlite_master WHERE type = 'table' AND name = 'schema'\n`", "\n", "rows", ",", "err", ":=", "tx", ".", "Query", "(", "statement", ")", "\n", "if", "err", "!=", "nil", "{", "return", "false", ",", "err", "\n", "}", "\n", "defer", "rows", ".", "Close", "(", ")", "\n\n", "if", "!", "rows", ".", "Next", "(", ")", "{", "return", "false", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n\n", "var", "count", "int", "\n\n", "err", "=", "rows", ".", "Scan", "(", "&", "count", ")", "\n", "if", "err", "!=", "nil", "{", "return", "false", ",", "err", "\n", "}", "\n\n", "return", "count", "==", "1", ",", "nil", "\n", "}"], "docstring": "// DoesSchemaTableExist return whether the schema table is present in the\n// database.", "docstring_tokens": ["DoesSchemaTableExist", "return", "whether", "the", "schema", "table", "is", "present", "in", "the", "database", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/schema/query.go#L16-L38", "partition": "test"}
{"repo": "lxc/lxd", "path": "shared/generate/file/buffer.go", "func_name": "L", "original_string": "func (b *Buffer) L(format string, a ...interface{}) {\n\tfmt.Fprintf(b.buf, format, a...)\n\tb.N()\n}", "language": "go", "code": "func (b *Buffer) L(format string, a ...interface{}) {\n\tfmt.Fprintf(b.buf, format, a...)\n\tb.N()\n}", "code_tokens": ["func", "(", "b", "*", "Buffer", ")", "L", "(", "format", "string", ",", "a", "...", "interface", "{", "}", ")", "{", "fmt", ".", "Fprintf", "(", "b", ".", "buf", ",", "format", ",", "a", "...", ")", "\n", "b", ".", "N", "(", ")", "\n", "}"], "docstring": "// L accumulates a single line of source code.", "docstring_tokens": ["L", "accumulates", "a", "single", "line", "of", "source", "code", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/shared/generate/file/buffer.go#L26-L29", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "provision/docker/container/container.go", "func_name": "Commit", "original_string": "func (c *Container) Commit(client provision.BuilderDockerClient, limiter provision.ActionLimiter, writer io.Writer, isDeploy bool) (string, error) {\n\tlog.Debugf(\"committing container %s\", c.ID)\n\trepository, tag := image.SplitImageName(c.BuildingImage)\n\topts := docker.CommitContainerOptions{Container: c.ID, Repository: repository, Tag: tag}\n\tdone := limiter.Start(c.HostAddr)\n\timage, err := client.CommitContainer(opts)\n\tdone()\n\tif err != nil {\n\t\treturn \"\", log.WrapError(errors.Wrapf(err, \"error in commit container %s\", c.ID))\n\t}\n\ttags := []string{tag}\n\tif isDeploy && tag != \"latest\" {\n\t\ttags = append(tags, \"latest\")\n\t\terr = client.TagImage(fmt.Sprintf(\"%s:%s\", repository, tag), docker.TagImageOptions{\n\t\t\tRepo:  repository,\n\t\t\tTag:   \"latest\",\n\t\t\tForce: true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn \"\", log.WrapError(errors.Wrapf(err, \"error in tag container %s\", c.ID))\n\t\t}\n\t}\n\timgHistory, err := client.ImageHistory(c.BuildingImage)\n\timgSize := \"\"\n\tif err == nil && len(imgHistory) > 0 {\n\t\tfullSize := imgHistory[0].Size\n\t\tif len(imgHistory) > 1 && strings.Contains(imgHistory[1].CreatedBy, \"tail -f /dev/null\") {\n\t\t\tfullSize += imgHistory[1].Size\n\t\t}\n\t\timgSize = fmt.Sprintf(\"(%.02fMB)\", float64(fullSize)/1024/1024)\n\t}\n\tfmt.Fprintf(writer, \" ---> Sending image to repository %s\\n\", imgSize)\n\tlog.Debugf(\"image %s generated from container %s\", image.ID, c.ID)\n\tfor _, tag := range tags {\n\t\tmaxTry, _ := config.GetInt(\"docker:registry-max-try\")\n\t\tif maxTry <= 0 {\n\t\t\tmaxTry = 3\n\t\t}\n\t\tfor i := 0; i < maxTry; i++ {\n\t\t\terr = dockercommon.PushImage(client, repository, tag, dockercommon.RegistryAuthConfig(repository))\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(writer, \"Could not send image, trying again. Original error: %s\\n\", err.Error())\n\t\t\t\tlog.Errorf(\"error in push image %s: %s\", c.BuildingImage, err)\n\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn \"\", log.WrapError(errors.Wrapf(err, \"error in push image %s\", c.BuildingImage))\n\t\t}\n\t}\n\treturn c.BuildingImage, nil\n}", "language": "go", "code": "func (c *Container) Commit(client provision.BuilderDockerClient, limiter provision.ActionLimiter, writer io.Writer, isDeploy bool) (string, error) {\n\tlog.Debugf(\"committing container %s\", c.ID)\n\trepository, tag := image.SplitImageName(c.BuildingImage)\n\topts := docker.CommitContainerOptions{Container: c.ID, Repository: repository, Tag: tag}\n\tdone := limiter.Start(c.HostAddr)\n\timage, err := client.CommitContainer(opts)\n\tdone()\n\tif err != nil {\n\t\treturn \"\", log.WrapError(errors.Wrapf(err, \"error in commit container %s\", c.ID))\n\t}\n\ttags := []string{tag}\n\tif isDeploy && tag != \"latest\" {\n\t\ttags = append(tags, \"latest\")\n\t\terr = client.TagImage(fmt.Sprintf(\"%s:%s\", repository, tag), docker.TagImageOptions{\n\t\t\tRepo:  repository,\n\t\t\tTag:   \"latest\",\n\t\t\tForce: true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn \"\", log.WrapError(errors.Wrapf(err, \"error in tag container %s\", c.ID))\n\t\t}\n\t}\n\timgHistory, err := client.ImageHistory(c.BuildingImage)\n\timgSize := \"\"\n\tif err == nil && len(imgHistory) > 0 {\n\t\tfullSize := imgHistory[0].Size\n\t\tif len(imgHistory) > 1 && strings.Contains(imgHistory[1].CreatedBy, \"tail -f /dev/null\") {\n\t\t\tfullSize += imgHistory[1].Size\n\t\t}\n\t\timgSize = fmt.Sprintf(\"(%.02fMB)\", float64(fullSize)/1024/1024)\n\t}\n\tfmt.Fprintf(writer, \" ---> Sending image to repository %s\\n\", imgSize)\n\tlog.Debugf(\"image %s generated from container %s\", image.ID, c.ID)\n\tfor _, tag := range tags {\n\t\tmaxTry, _ := config.GetInt(\"docker:registry-max-try\")\n\t\tif maxTry <= 0 {\n\t\t\tmaxTry = 3\n\t\t}\n\t\tfor i := 0; i < maxTry; i++ {\n\t\t\terr = dockercommon.PushImage(client, repository, tag, dockercommon.RegistryAuthConfig(repository))\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(writer, \"Could not send image, trying again. Original error: %s\\n\", err.Error())\n\t\t\t\tlog.Errorf(\"error in push image %s: %s\", c.BuildingImage, err)\n\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn \"\", log.WrapError(errors.Wrapf(err, \"error in push image %s\", c.BuildingImage))\n\t\t}\n\t}\n\treturn c.BuildingImage, nil\n}", "code_tokens": ["func", "(", "c", "*", "Container", ")", "Commit", "(", "client", "provision", ".", "BuilderDockerClient", ",", "limiter", "provision", ".", "ActionLimiter", ",", "writer", "io", ".", "Writer", ",", "isDeploy", "bool", ")", "(", "string", ",", "error", ")", "{", "log", ".", "Debugf", "(", "\"", "\"", ",", "c", ".", "ID", ")", "\n", "repository", ",", "tag", ":=", "image", ".", "SplitImageName", "(", "c", ".", "BuildingImage", ")", "\n", "opts", ":=", "docker", ".", "CommitContainerOptions", "{", "Container", ":", "c", ".", "ID", ",", "Repository", ":", "repository", ",", "Tag", ":", "tag", "}", "\n", "done", ":=", "limiter", ".", "Start", "(", "c", ".", "HostAddr", ")", "\n", "image", ",", "err", ":=", "client", ".", "CommitContainer", "(", "opts", ")", "\n", "done", "(", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "log", ".", "WrapError", "(", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ",", "c", ".", "ID", ")", ")", "\n", "}", "\n", "tags", ":=", "[", "]", "string", "{", "tag", "}", "\n", "if", "isDeploy", "&&", "tag", "!=", "\"", "\"", "{", "tags", "=", "append", "(", "tags", ",", "\"", "\"", ")", "\n", "err", "=", "client", ".", "TagImage", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "repository", ",", "tag", ")", ",", "docker", ".", "TagImageOptions", "{", "Repo", ":", "repository", ",", "Tag", ":", "\"", "\"", ",", "Force", ":", "true", ",", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "log", ".", "WrapError", "(", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ",", "c", ".", "ID", ")", ")", "\n", "}", "\n", "}", "\n", "imgHistory", ",", "err", ":=", "client", ".", "ImageHistory", "(", "c", ".", "BuildingImage", ")", "\n", "imgSize", ":=", "\"", "\"", "\n", "if", "err", "==", "nil", "&&", "len", "(", "imgHistory", ")", ">", "0", "{", "fullSize", ":=", "imgHistory", "[", "0", "]", ".", "Size", "\n", "if", "len", "(", "imgHistory", ")", ">", "1", "&&", "strings", ".", "Contains", "(", "imgHistory", "[", "1", "]", ".", "CreatedBy", ",", "\"", "\"", ")", "{", "fullSize", "+=", "imgHistory", "[", "1", "]", ".", "Size", "\n", "}", "\n", "imgSize", "=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "float64", "(", "fullSize", ")", "/", "1024", "/", "1024", ")", "\n", "}", "\n", "fmt", ".", "Fprintf", "(", "writer", ",", "\"", "\\n", "\"", ",", "imgSize", ")", "\n", "log", ".", "Debugf", "(", "\"", "\"", ",", "image", ".", "ID", ",", "c", ".", "ID", ")", "\n", "for", "_", ",", "tag", ":=", "range", "tags", "{", "maxTry", ",", "_", ":=", "config", ".", "GetInt", "(", "\"", "\"", ")", "\n", "if", "maxTry", "<=", "0", "{", "maxTry", "=", "3", "\n", "}", "\n", "for", "i", ":=", "0", ";", "i", "<", "maxTry", ";", "i", "++", "{", "err", "=", "dockercommon", ".", "PushImage", "(", "client", ",", "repository", ",", "tag", ",", "dockercommon", ".", "RegistryAuthConfig", "(", "repository", ")", ")", "\n", "if", "err", "!=", "nil", "{", "fmt", ".", "Fprintf", "(", "writer", ",", "\"", "\\n", "\"", ",", "err", ".", "Error", "(", ")", ")", "\n", "log", ".", "Errorf", "(", "\"", "\"", ",", "c", ".", "BuildingImage", ",", "err", ")", "\n", "time", ".", "Sleep", "(", "time", ".", "Second", ")", "\n", "continue", "\n", "}", "\n", "break", "\n", "}", "\n", "if", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "log", ".", "WrapError", "(", "errors", ".", "Wrapf", "(", "err", ",", "\"", "\"", ",", "c", ".", "BuildingImage", ")", ")", "\n", "}", "\n", "}", "\n", "return", "c", ".", "BuildingImage", ",", "nil", "\n", "}"], "docstring": "// Commits commits the container, creating an image in Docker. It then returns\n// the image identifier for usage in future container creation.", "docstring_tokens": ["Commits", "commits", "the", "container", "creating", "an", "image", "in", "Docker", ".", "It", "then", "returns", "the", "image", "identifier", "for", "usage", "in", "future", "container", "creation", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/docker/container/container.go#L358-L411", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "app/plan.go", "func_name": "Remove", "original_string": "func (s *planService) Remove(planName string) error {\n\treturn s.storage.Delete(appTypes.Plan{Name: planName})\n}", "language": "go", "code": "func (s *planService) Remove(planName string) error {\n\treturn s.storage.Delete(appTypes.Plan{Name: planName})\n}", "code_tokens": ["func", "(", "s", "*", "planService", ")", "Remove", "(", "planName", "string", ")", "error", "{", "return", "s", ".", "storage", ".", "Delete", "(", "appTypes", ".", "Plan", "{", "Name", ":", "planName", "}", ")", "\n", "}"], "docstring": "// Remove implements Remove method of PlanService interface", "docstring_tokens": ["Remove", "implements", "Remove", "method", "of", "PlanService", "interface"], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/app/plan.go#L64-L66", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "tnet/listener.go", "func_name": "Close", "original_string": "func (s *listener) Close() error {\n\tif err := s.Listener.Close(); err != nil {\n\t\treturn err\n\t}\n\n\ts.cond.L.Lock()\n\tfor s.refs > 0 {\n\t\ts.cond.Wait()\n\t}\n\ts.cond.L.Unlock()\n\treturn nil\n}", "language": "go", "code": "func (s *listener) Close() error {\n\tif err := s.Listener.Close(); err != nil {\n\t\treturn err\n\t}\n\n\ts.cond.L.Lock()\n\tfor s.refs > 0 {\n\t\ts.cond.Wait()\n\t}\n\ts.cond.L.Unlock()\n\treturn nil\n}", "code_tokens": ["func", "(", "s", "*", "listener", ")", "Close", "(", ")", "error", "{", "if", "err", ":=", "s", ".", "Listener", ".", "Close", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n\n", "s", ".", "cond", ".", "L", ".", "Lock", "(", ")", "\n", "for", "s", ".", "refs", ">", "0", "{", "s", ".", "cond", ".", "Wait", "(", ")", "\n", "}", "\n", "s", ".", "cond", ".", "L", ".", "Unlock", "(", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// Close closes the listener.\n// Any blocked Accept operations will be unblocked and return errors.", "docstring_tokens": ["Close", "closes", "the", "listener", ".", "Any", "blocked", "Accept", "operations", "will", "be", "unblocked", "and", "return", "errors", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/tnet/listener.go#L85-L96", "partition": "test"}
{"repo": "dgraph-io/badger", "path": "levels.go", "func_name": "doCompact", "original_string": "func (s *levelsController) doCompact(p compactionPriority) error {\n\tl := p.level\n\ty.AssertTrue(l+1 < s.kv.opt.MaxLevels) // Sanity check.\n\n\tcd := compactDef{\n\t\telog:       trace.New(fmt.Sprintf(\"Badger.L%d\", l), \"Compact\"),\n\t\tthisLevel:  s.levels[l],\n\t\tnextLevel:  s.levels[l+1],\n\t\tdropPrefix: p.dropPrefix,\n\t}\n\tcd.elog.SetMaxEvents(100)\n\tdefer cd.elog.Finish()\n\n\ts.kv.opt.Infof(\"Got compaction priority: %+v\", p)\n\n\t// While picking tables to be compacted, both levels' tables are expected to\n\t// remain unchanged.\n\tif l == 0 {\n\t\tif !s.fillTablesL0(&cd) {\n\t\t\treturn errFillTables\n\t\t}\n\n\t} else {\n\t\tif !s.fillTables(&cd) {\n\t\t\treturn errFillTables\n\t\t}\n\t}\n\tdefer s.cstatus.delete(cd) // Remove the ranges from compaction status.\n\n\ts.kv.opt.Infof(\"Running for level: %d\\n\", cd.thisLevel.level)\n\ts.cstatus.toLog(cd.elog)\n\tif err := s.runCompactDef(l, cd); err != nil {\n\t\t// This compaction couldn't be done successfully.\n\t\ts.kv.opt.Warningf(\"LOG Compact FAILED with error: %+v: %+v\", err, cd)\n\t\treturn err\n\t}\n\n\ts.cstatus.toLog(cd.elog)\n\ts.kv.opt.Infof(\"Compaction for level: %d DONE\", cd.thisLevel.level)\n\treturn nil\n}", "language": "go", "code": "func (s *levelsController) doCompact(p compactionPriority) error {\n\tl := p.level\n\ty.AssertTrue(l+1 < s.kv.opt.MaxLevels) // Sanity check.\n\n\tcd := compactDef{\n\t\telog:       trace.New(fmt.Sprintf(\"Badger.L%d\", l), \"Compact\"),\n\t\tthisLevel:  s.levels[l],\n\t\tnextLevel:  s.levels[l+1],\n\t\tdropPrefix: p.dropPrefix,\n\t}\n\tcd.elog.SetMaxEvents(100)\n\tdefer cd.elog.Finish()\n\n\ts.kv.opt.Infof(\"Got compaction priority: %+v\", p)\n\n\t// While picking tables to be compacted, both levels' tables are expected to\n\t// remain unchanged.\n\tif l == 0 {\n\t\tif !s.fillTablesL0(&cd) {\n\t\t\treturn errFillTables\n\t\t}\n\n\t} else {\n\t\tif !s.fillTables(&cd) {\n\t\t\treturn errFillTables\n\t\t}\n\t}\n\tdefer s.cstatus.delete(cd) // Remove the ranges from compaction status.\n\n\ts.kv.opt.Infof(\"Running for level: %d\\n\", cd.thisLevel.level)\n\ts.cstatus.toLog(cd.elog)\n\tif err := s.runCompactDef(l, cd); err != nil {\n\t\t// This compaction couldn't be done successfully.\n\t\ts.kv.opt.Warningf(\"LOG Compact FAILED with error: %+v: %+v\", err, cd)\n\t\treturn err\n\t}\n\n\ts.cstatus.toLog(cd.elog)\n\ts.kv.opt.Infof(\"Compaction for level: %d DONE\", cd.thisLevel.level)\n\treturn nil\n}", "code_tokens": ["func", "(", "s", "*", "levelsController", ")", "doCompact", "(", "p", "compactionPriority", ")", "error", "{", "l", ":=", "p", ".", "level", "\n", "y", ".", "AssertTrue", "(", "l", "+", "1", "<", "s", ".", "kv", ".", "opt", ".", "MaxLevels", ")", "// Sanity check.", "\n\n", "cd", ":=", "compactDef", "{", "elog", ":", "trace", ".", "New", "(", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "l", ")", ",", "\"", "\"", ")", ",", "thisLevel", ":", "s", ".", "levels", "[", "l", "]", ",", "nextLevel", ":", "s", ".", "levels", "[", "l", "+", "1", "]", ",", "dropPrefix", ":", "p", ".", "dropPrefix", ",", "}", "\n", "cd", ".", "elog", ".", "SetMaxEvents", "(", "100", ")", "\n", "defer", "cd", ".", "elog", ".", "Finish", "(", ")", "\n\n", "s", ".", "kv", ".", "opt", ".", "Infof", "(", "\"", "\"", ",", "p", ")", "\n\n", "// While picking tables to be compacted, both levels' tables are expected to", "// remain unchanged.", "if", "l", "==", "0", "{", "if", "!", "s", ".", "fillTablesL0", "(", "&", "cd", ")", "{", "return", "errFillTables", "\n", "}", "\n\n", "}", "else", "{", "if", "!", "s", ".", "fillTables", "(", "&", "cd", ")", "{", "return", "errFillTables", "\n", "}", "\n", "}", "\n", "defer", "s", ".", "cstatus", ".", "delete", "(", "cd", ")", "// Remove the ranges from compaction status.", "\n\n", "s", ".", "kv", ".", "opt", ".", "Infof", "(", "\"", "\\n", "\"", ",", "cd", ".", "thisLevel", ".", "level", ")", "\n", "s", ".", "cstatus", ".", "toLog", "(", "cd", ".", "elog", ")", "\n", "if", "err", ":=", "s", ".", "runCompactDef", "(", "l", ",", "cd", ")", ";", "err", "!=", "nil", "{", "// This compaction couldn't be done successfully.", "s", ".", "kv", ".", "opt", ".", "Warningf", "(", "\"", "\"", ",", "err", ",", "cd", ")", "\n", "return", "err", "\n", "}", "\n\n", "s", ".", "cstatus", ".", "toLog", "(", "cd", ".", "elog", ")", "\n", "s", ".", "kv", ".", "opt", ".", "Infof", "(", "\"", "\"", ",", "cd", ".", "thisLevel", ".", "level", ")", "\n", "return", "nil", "\n", "}"], "docstring": "// doCompact picks some table on level l and compacts it away to the next level.", "docstring_tokens": ["doCompact", "picks", "some", "table", "on", "level", "l", "and", "compacts", "it", "away", "to", "the", "next", "level", "."], "sha": "6b796b3ebec3ff006fcb1b425836cd784651e9fd", "url": "https://github.com/dgraph-io/badger/blob/6b796b3ebec3ff006fcb1b425836cd784651e9fd/levels.go#L798-L838", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "functional/runner/lease_renewer_command.go", "func_name": "NewLeaseRenewerCommand", "original_string": "func NewLeaseRenewerCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"lease-renewer\",\n\t\tShort: \"Performs lease renew operation\",\n\t\tRun:   runLeaseRenewerFunc,\n\t}\n\tcmd.Flags().Int64Var(&leaseTTL, \"ttl\", 5, \"lease's ttl\")\n\treturn cmd\n}", "language": "go", "code": "func NewLeaseRenewerCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"lease-renewer\",\n\t\tShort: \"Performs lease renew operation\",\n\t\tRun:   runLeaseRenewerFunc,\n\t}\n\tcmd.Flags().Int64Var(&leaseTTL, \"ttl\", 5, \"lease's ttl\")\n\treturn cmd\n}", "code_tokens": ["func", "NewLeaseRenewerCommand", "(", ")", "*", "cobra", ".", "Command", "{", "cmd", ":=", "&", "cobra", ".", "Command", "{", "Use", ":", "\"", "\"", ",", "Short", ":", "\"", "\"", ",", "Run", ":", "runLeaseRenewerFunc", ",", "}", "\n", "cmd", ".", "Flags", "(", ")", ".", "Int64Var", "(", "&", "leaseTTL", ",", "\"", "\"", ",", "5", ",", "\"", "\"", ")", "\n", "return", "cmd", "\n", "}"], "docstring": "// NewLeaseRenewerCommand returns the cobra command for \"lease-renewer runner\".", "docstring_tokens": ["NewLeaseRenewerCommand", "returns", "the", "cobra", "command", "for", "lease", "-", "renewer", "runner", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/functional/runner/lease_renewer_command.go#L36-L44", "partition": "test"}
{"repo": "reiver/go-telnet", "path": "tls.go", "func_name": "ListenAndServeTLS", "original_string": "func (server *Server) ListenAndServeTLS(certFile string, keyFile string) error {\n\n\taddr := server.Addr\n\tif \"\" == addr {\n\t\taddr = \":telnets\"\n\t}\n\n\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif nil != err {\n\t\treturn err\n\t}\n\n\n\t// Apparently have to make a copy of the TLS config this way, rather than by\n\t// simple assignment, to prevent some unexported fields from being copied over.\n\t//\n\t// It would be nice if tls.Config had a method that would do this \"safely\".\n\t// (I.e., what happens if in the future more exported fields are added to\n\t// tls.Config?)\n\tvar tlsConfig *tls.Config = nil\n\tif nil == server.TLSConfig {\n\t\ttlsConfig = &tls.Config{}\n\t} else {\n\t\ttlsConfig = &tls.Config{\n\t\t\tRand:                     server.TLSConfig.Rand,\n\t\t\tTime:                     server.TLSConfig.Time,\n\t\t\tCertificates:             server.TLSConfig.Certificates,\n\t\t\tNameToCertificate:        server.TLSConfig.NameToCertificate,\n\t\t\tGetCertificate:           server.TLSConfig.GetCertificate,\n\t\t\tRootCAs:                  server.TLSConfig.RootCAs,\n\t\t\tNextProtos:               server.TLSConfig.NextProtos,\n\t\t\tServerName:               server.TLSConfig.ServerName,\n\t\t\tClientAuth:               server.TLSConfig.ClientAuth,\n\t\t\tClientCAs:                server.TLSConfig.ClientCAs,\n\t\t\tInsecureSkipVerify:       server.TLSConfig.InsecureSkipVerify,\n\t\t\tCipherSuites:             server.TLSConfig.CipherSuites,\n\t\t\tPreferServerCipherSuites: server.TLSConfig.PreferServerCipherSuites,\n\t\t\tSessionTicketsDisabled:   server.TLSConfig.SessionTicketsDisabled,\n\t\t\tSessionTicketKey:         server.TLSConfig.SessionTicketKey,\n\t\t\tClientSessionCache:       server.TLSConfig.ClientSessionCache,\n\t\t\tMinVersion:               server.TLSConfig.MinVersion,\n\t\t\tMaxVersion:               server.TLSConfig.MaxVersion,\n\t\t\tCurvePreferences:         server.TLSConfig.CurvePreferences,\n\t\t}\n\t}\n\n\n\ttlsConfigHasCertificate := len(tlsConfig.Certificates) > 0 || nil != tlsConfig.GetCertificate\n\tif \"\" == certFile || \"\" == keyFile || !tlsConfigHasCertificate {\n\t\ttlsConfig.Certificates = make([]tls.Certificate, 1)\n\n\t\tvar err error\n\t\ttlsConfig.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)\n\t\tif nil != err {\n\t\t\treturn err\n\t\t}\n\t}\n\n\n\ttlsListener := tls.NewListener(listener, tlsConfig)\n\n\n\treturn server.Serve(tlsListener)\n}", "language": "go", "code": "func (server *Server) ListenAndServeTLS(certFile string, keyFile string) error {\n\n\taddr := server.Addr\n\tif \"\" == addr {\n\t\taddr = \":telnets\"\n\t}\n\n\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif nil != err {\n\t\treturn err\n\t}\n\n\n\t// Apparently have to make a copy of the TLS config this way, rather than by\n\t// simple assignment, to prevent some unexported fields from being copied over.\n\t//\n\t// It would be nice if tls.Config had a method that would do this \"safely\".\n\t// (I.e., what happens if in the future more exported fields are added to\n\t// tls.Config?)\n\tvar tlsConfig *tls.Config = nil\n\tif nil == server.TLSConfig {\n\t\ttlsConfig = &tls.Config{}\n\t} else {\n\t\ttlsConfig = &tls.Config{\n\t\t\tRand:                     server.TLSConfig.Rand,\n\t\t\tTime:                     server.TLSConfig.Time,\n\t\t\tCertificates:             server.TLSConfig.Certificates,\n\t\t\tNameToCertificate:        server.TLSConfig.NameToCertificate,\n\t\t\tGetCertificate:           server.TLSConfig.GetCertificate,\n\t\t\tRootCAs:                  server.TLSConfig.RootCAs,\n\t\t\tNextProtos:               server.TLSConfig.NextProtos,\n\t\t\tServerName:               server.TLSConfig.ServerName,\n\t\t\tClientAuth:               server.TLSConfig.ClientAuth,\n\t\t\tClientCAs:                server.TLSConfig.ClientCAs,\n\t\t\tInsecureSkipVerify:       server.TLSConfig.InsecureSkipVerify,\n\t\t\tCipherSuites:             server.TLSConfig.CipherSuites,\n\t\t\tPreferServerCipherSuites: server.TLSConfig.PreferServerCipherSuites,\n\t\t\tSessionTicketsDisabled:   server.TLSConfig.SessionTicketsDisabled,\n\t\t\tSessionTicketKey:         server.TLSConfig.SessionTicketKey,\n\t\t\tClientSessionCache:       server.TLSConfig.ClientSessionCache,\n\t\t\tMinVersion:               server.TLSConfig.MinVersion,\n\t\t\tMaxVersion:               server.TLSConfig.MaxVersion,\n\t\t\tCurvePreferences:         server.TLSConfig.CurvePreferences,\n\t\t}\n\t}\n\n\n\ttlsConfigHasCertificate := len(tlsConfig.Certificates) > 0 || nil != tlsConfig.GetCertificate\n\tif \"\" == certFile || \"\" == keyFile || !tlsConfigHasCertificate {\n\t\ttlsConfig.Certificates = make([]tls.Certificate, 1)\n\n\t\tvar err error\n\t\ttlsConfig.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)\n\t\tif nil != err {\n\t\t\treturn err\n\t\t}\n\t}\n\n\n\ttlsListener := tls.NewListener(listener, tlsConfig)\n\n\n\treturn server.Serve(tlsListener)\n}", "code_tokens": ["func", "(", "server", "*", "Server", ")", "ListenAndServeTLS", "(", "certFile", "string", ",", "keyFile", "string", ")", "error", "{", "addr", ":=", "server", ".", "Addr", "\n", "if", "\"", "\"", "==", "addr", "{", "addr", "=", "\"", "\"", "\n", "}", "\n\n\n", "listener", ",", "err", ":=", "net", ".", "Listen", "(", "\"", "\"", ",", "addr", ")", "\n", "if", "nil", "!=", "err", "{", "return", "err", "\n", "}", "\n\n\n", "// Apparently have to make a copy of the TLS config this way, rather than by", "// simple assignment, to prevent some unexported fields from being copied over.", "//", "// It would be nice if tls.Config had a method that would do this \"safely\".", "// (I.e., what happens if in the future more exported fields are added to", "// tls.Config?)", "var", "tlsConfig", "*", "tls", ".", "Config", "=", "nil", "\n", "if", "nil", "==", "server", ".", "TLSConfig", "{", "tlsConfig", "=", "&", "tls", ".", "Config", "{", "}", "\n", "}", "else", "{", "tlsConfig", "=", "&", "tls", ".", "Config", "{", "Rand", ":", "server", ".", "TLSConfig", ".", "Rand", ",", "Time", ":", "server", ".", "TLSConfig", ".", "Time", ",", "Certificates", ":", "server", ".", "TLSConfig", ".", "Certificates", ",", "NameToCertificate", ":", "server", ".", "TLSConfig", ".", "NameToCertificate", ",", "GetCertificate", ":", "server", ".", "TLSConfig", ".", "GetCertificate", ",", "RootCAs", ":", "server", ".", "TLSConfig", ".", "RootCAs", ",", "NextProtos", ":", "server", ".", "TLSConfig", ".", "NextProtos", ",", "ServerName", ":", "server", ".", "TLSConfig", ".", "ServerName", ",", "ClientAuth", ":", "server", ".", "TLSConfig", ".", "ClientAuth", ",", "ClientCAs", ":", "server", ".", "TLSConfig", ".", "ClientCAs", ",", "InsecureSkipVerify", ":", "server", ".", "TLSConfig", ".", "InsecureSkipVerify", ",", "CipherSuites", ":", "server", ".", "TLSConfig", ".", "CipherSuites", ",", "PreferServerCipherSuites", ":", "server", ".", "TLSConfig", ".", "PreferServerCipherSuites", ",", "SessionTicketsDisabled", ":", "server", ".", "TLSConfig", ".", "SessionTicketsDisabled", ",", "SessionTicketKey", ":", "server", ".", "TLSConfig", ".", "SessionTicketKey", ",", "ClientSessionCache", ":", "server", ".", "TLSConfig", ".", "ClientSessionCache", ",", "MinVersion", ":", "server", ".", "TLSConfig", ".", "MinVersion", ",", "MaxVersion", ":", "server", ".", "TLSConfig", ".", "MaxVersion", ",", "CurvePreferences", ":", "server", ".", "TLSConfig", ".", "CurvePreferences", ",", "}", "\n", "}", "\n\n\n", "tlsConfigHasCertificate", ":=", "len", "(", "tlsConfig", ".", "Certificates", ")", ">", "0", "||", "nil", "!=", "tlsConfig", ".", "GetCertificate", "\n", "if", "\"", "\"", "==", "certFile", "||", "\"", "\"", "==", "keyFile", "||", "!", "tlsConfigHasCertificate", "{", "tlsConfig", ".", "Certificates", "=", "make", "(", "[", "]", "tls", ".", "Certificate", ",", "1", ")", "\n\n", "var", "err", "error", "\n", "tlsConfig", ".", "Certificates", "[", "0", "]", ",", "err", "=", "tls", ".", "LoadX509KeyPair", "(", "certFile", ",", "keyFile", ")", "\n", "if", "nil", "!=", "err", "{", "return", "err", "\n", "}", "\n", "}", "\n\n\n", "tlsListener", ":=", "tls", ".", "NewListener", "(", "listener", ",", "tlsConfig", ")", "\n\n\n", "return", "server", ".", "Serve", "(", "tlsListener", ")", "\n", "}"], "docstring": "// ListenAndServeTLS acts identically to ListenAndServe, except that it\n// uses the TELNET protocol over TLS.\n//\n// From a TELNET protocol point-of-view, it allows for 'secured telnet', also known as TELNETS,\n// which by default listens to port 992.", "docstring_tokens": ["ListenAndServeTLS", "acts", "identically", "to", "ListenAndServe", "except", "that", "it", "uses", "the", "TELNET", "protocol", "over", "TLS", ".", "From", "a", "TELNET", "protocol", "point", "-", "of", "-", "view", "it", "allows", "for", "secured", "telnet", "also", "known", "as", "TELNETS", "which", "by", "default", "listens", "to", "port", "992", "."], "sha": "9ff0b2ab096ebe42bf8e2ffd1366e7ed2223b04c", "url": "https://github.com/reiver/go-telnet/blob/9ff0b2ab096ebe42bf8e2ffd1366e7ed2223b04c/tls.go#L49-L113", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "migration/migration.go", "func_name": "RegisterOptional", "original_string": "func RegisterOptional(name string, fn MigrateFunc) error {\n\treturn register(name, true, fn)\n}", "language": "go", "code": "func RegisterOptional(name string, fn MigrateFunc) error {\n\treturn register(name, true, fn)\n}", "code_tokens": ["func", "RegisterOptional", "(", "name", "string", ",", "fn", "MigrateFunc", ")", "error", "{", "return", "register", "(", "name", ",", "true", ",", "fn", ")", "\n", "}"], "docstring": "// RegisterOptional register a new migration that will not run automatically\n// when calling the Run funcition.", "docstring_tokens": ["RegisterOptional", "register", "a", "new", "migration", "that", "will", "not", "run", "automatically", "when", "calling", "the", "Run", "funcition", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/migration/migration.go#L71-L73", "partition": "test"}
{"repo": "nwaples/rardecode", "path": "archive50.go", "func_name": "checkPassword", "original_string": "func checkPassword(b *readBuf, keys [][]byte) error {\n\tif len(*b) < 12 {\n\t\treturn nil // not enough bytes, ignore for the moment\n\t}\n\tpwcheck := b.bytes(8)\n\tsum := b.bytes(4)\n\tcsum := sha256.Sum256(pwcheck)\n\tif bytes.Equal(sum, csum[:len(sum)]) && !bytes.Equal(pwcheck, keys[2]) {\n\t\treturn errBadPassword\n\t}\n\treturn nil\n}", "language": "go", "code": "func checkPassword(b *readBuf, keys [][]byte) error {\n\tif len(*b) < 12 {\n\t\treturn nil // not enough bytes, ignore for the moment\n\t}\n\tpwcheck := b.bytes(8)\n\tsum := b.bytes(4)\n\tcsum := sha256.Sum256(pwcheck)\n\tif bytes.Equal(sum, csum[:len(sum)]) && !bytes.Equal(pwcheck, keys[2]) {\n\t\treturn errBadPassword\n\t}\n\treturn nil\n}", "code_tokens": ["func", "checkPassword", "(", "b", "*", "readBuf", ",", "keys", "[", "]", "[", "]", "byte", ")", "error", "{", "if", "len", "(", "*", "b", ")", "<", "12", "{", "return", "nil", "// not enough bytes, ignore for the moment", "\n", "}", "\n", "pwcheck", ":=", "b", ".", "bytes", "(", "8", ")", "\n", "sum", ":=", "b", ".", "bytes", "(", "4", ")", "\n", "csum", ":=", "sha256", ".", "Sum256", "(", "pwcheck", ")", "\n", "if", "bytes", ".", "Equal", "(", "sum", ",", "csum", "[", ":", "len", "(", "sum", ")", "]", ")", "&&", "!", "bytes", ".", "Equal", "(", "pwcheck", ",", "keys", "[", "2", "]", ")", "{", "return", "errBadPassword", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// checkPassword calculates if a password is correct given password check data and keys.", "docstring_tokens": ["checkPassword", "calculates", "if", "a", "password", "is", "correct", "given", "password", "check", "data", "and", "keys", "."], "sha": "197ef08ef68c4454ae5970a9c2692d6056ceb8d7", "url": "https://github.com/nwaples/rardecode/blob/197ef08ef68c4454ae5970a9c2692d6056ceb8d7/archive50.go#L211-L222", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "proxy/grpcproxy/watcher.go", "func_name": "post", "original_string": "func (w *watcher) post(wr *pb.WatchResponse) bool {\n\tselect {\n\tcase w.wps.watchCh <- wr:\n\tcase <-time.After(50 * time.Millisecond):\n\t\tw.wps.cancel()\n\t\treturn false\n\t}\n\treturn true\n}", "language": "go", "code": "func (w *watcher) post(wr *pb.WatchResponse) bool {\n\tselect {\n\tcase w.wps.watchCh <- wr:\n\tcase <-time.After(50 * time.Millisecond):\n\t\tw.wps.cancel()\n\t\treturn false\n\t}\n\treturn true\n}", "code_tokens": ["func", "(", "w", "*", "watcher", ")", "post", "(", "wr", "*", "pb", ".", "WatchResponse", ")", "bool", "{", "select", "{", "case", "w", ".", "wps", ".", "watchCh", "<-", "wr", ":", "case", "<-", "time", ".", "After", "(", "50", "*", "time", ".", "Millisecond", ")", ":", "w", ".", "wps", ".", "cancel", "(", ")", "\n", "return", "false", "\n", "}", "\n", "return", "true", "\n", "}"], "docstring": "// post puts a watch response on the watcher's proxy stream channel", "docstring_tokens": ["post", "puts", "a", "watch", "response", "on", "the", "watcher", "s", "proxy", "stream", "channel"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/proxy/grpcproxy/watcher.go#L121-L129", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/task/schedule.go", "func_name": "Every", "original_string": "func Every(interval time.Duration, options ...EveryOption) Schedule {\n\tevery := &every{}\n\tfor _, option := range options {\n\t\toption(every)\n\t}\n\tfirst := true\n\treturn func() (time.Duration, error) {\n\t\tvar err error\n\t\tif first && every.skipFirst {\n\t\t\terr = ErrSkip\n\t\t}\n\t\tfirst = false\n\t\treturn interval, err\n\t}\n}", "language": "go", "code": "func Every(interval time.Duration, options ...EveryOption) Schedule {\n\tevery := &every{}\n\tfor _, option := range options {\n\t\toption(every)\n\t}\n\tfirst := true\n\treturn func() (time.Duration, error) {\n\t\tvar err error\n\t\tif first && every.skipFirst {\n\t\t\terr = ErrSkip\n\t\t}\n\t\tfirst = false\n\t\treturn interval, err\n\t}\n}", "code_tokens": ["func", "Every", "(", "interval", "time", ".", "Duration", ",", "options", "...", "EveryOption", ")", "Schedule", "{", "every", ":=", "&", "every", "{", "}", "\n", "for", "_", ",", "option", ":=", "range", "options", "{", "option", "(", "every", ")", "\n", "}", "\n", "first", ":=", "true", "\n", "return", "func", "(", ")", "(", "time", ".", "Duration", ",", "error", ")", "{", "var", "err", "error", "\n", "if", "first", "&&", "every", ".", "skipFirst", "{", "err", "=", "ErrSkip", "\n", "}", "\n", "first", "=", "false", "\n", "return", "interval", ",", "err", "\n", "}", "\n", "}"], "docstring": "// Every returns a Schedule that always returns the given time interval.", "docstring_tokens": ["Every", "returns", "a", "Schedule", "that", "always", "returns", "the", "given", "time", "interval", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/task/schedule.go#L33-L47", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/db/images.go", "func_name": "ImageAliasGet", "original_string": "func (c *Cluster) ImageAliasGet(project, name string, isTrustedClient bool) (int, api.ImageAliasesEntry, error) {\n\tid := -1\n\tentry := api.ImageAliasesEntry{}\n\n\terr := c.Transaction(func(tx *ClusterTx) error {\n\t\tenabled, err := tx.ProjectHasImages(project)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"Check if project has images\")\n\t\t}\n\t\tif !enabled {\n\t\t\tproject = \"default\"\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn id, entry, err\n\t}\n\n\tq := `SELECT images_aliases.id, images.fingerprint, images_aliases.description\n\t\t\t FROM images_aliases\n\t\t\t INNER JOIN images\n\t\t\t ON images_aliases.image_id=images.id\n                         INNER JOIN projects\n                         ON images_aliases.project_id=projects.id\n\t\t\t WHERE projects.name=? AND images_aliases.name=?`\n\tif !isTrustedClient {\n\t\tq = q + ` AND images.public=1`\n\t}\n\n\tvar fingerprint, description string\n\n\targ1 := []interface{}{project, name}\n\targ2 := []interface{}{&id, &fingerprint, &description}\n\terr = dbQueryRowScan(c.db, q, arg1, arg2)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn -1, entry, ErrNoSuchObject\n\t\t}\n\n\t\treturn -1, entry, err\n\t}\n\n\tentry.Name = name\n\tentry.Target = fingerprint\n\tentry.Description = description\n\n\treturn id, entry, nil\n}", "language": "go", "code": "func (c *Cluster) ImageAliasGet(project, name string, isTrustedClient bool) (int, api.ImageAliasesEntry, error) {\n\tid := -1\n\tentry := api.ImageAliasesEntry{}\n\n\terr := c.Transaction(func(tx *ClusterTx) error {\n\t\tenabled, err := tx.ProjectHasImages(project)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"Check if project has images\")\n\t\t}\n\t\tif !enabled {\n\t\t\tproject = \"default\"\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn id, entry, err\n\t}\n\n\tq := `SELECT images_aliases.id, images.fingerprint, images_aliases.description\n\t\t\t FROM images_aliases\n\t\t\t INNER JOIN images\n\t\t\t ON images_aliases.image_id=images.id\n                         INNER JOIN projects\n                         ON images_aliases.project_id=projects.id\n\t\t\t WHERE projects.name=? AND images_aliases.name=?`\n\tif !isTrustedClient {\n\t\tq = q + ` AND images.public=1`\n\t}\n\n\tvar fingerprint, description string\n\n\targ1 := []interface{}{project, name}\n\targ2 := []interface{}{&id, &fingerprint, &description}\n\terr = dbQueryRowScan(c.db, q, arg1, arg2)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn -1, entry, ErrNoSuchObject\n\t\t}\n\n\t\treturn -1, entry, err\n\t}\n\n\tentry.Name = name\n\tentry.Target = fingerprint\n\tentry.Description = description\n\n\treturn id, entry, nil\n}", "code_tokens": ["func", "(", "c", "*", "Cluster", ")", "ImageAliasGet", "(", "project", ",", "name", "string", ",", "isTrustedClient", "bool", ")", "(", "int", ",", "api", ".", "ImageAliasesEntry", ",", "error", ")", "{", "id", ":=", "-", "1", "\n", "entry", ":=", "api", ".", "ImageAliasesEntry", "{", "}", "\n\n", "err", ":=", "c", ".", "Transaction", "(", "func", "(", "tx", "*", "ClusterTx", ")", "error", "{", "enabled", ",", "err", ":=", "tx", ".", "ProjectHasImages", "(", "project", ")", "\n", "if", "err", "!=", "nil", "{", "return", "errors", ".", "Wrap", "(", "err", ",", "\"", "\"", ")", "\n", "}", "\n", "if", "!", "enabled", "{", "project", "=", "\"", "\"", "\n", "}", "\n", "return", "nil", "\n", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "id", ",", "entry", ",", "err", "\n", "}", "\n\n", "q", ":=", "`SELECT images_aliases.id, images.fingerprint, images_aliases.description\n\t\t\t FROM images_aliases\n\t\t\t INNER JOIN images\n\t\t\t ON images_aliases.image_id=images.id\n                         INNER JOIN projects\n                         ON images_aliases.project_id=projects.id\n\t\t\t WHERE projects.name=? AND images_aliases.name=?`", "\n", "if", "!", "isTrustedClient", "{", "q", "=", "q", "+", "` AND images.public=1`", "\n", "}", "\n\n", "var", "fingerprint", ",", "description", "string", "\n\n", "arg1", ":=", "[", "]", "interface", "{", "}", "{", "project", ",", "name", "}", "\n", "arg2", ":=", "[", "]", "interface", "{", "}", "{", "&", "id", ",", "&", "fingerprint", ",", "&", "description", "}", "\n", "err", "=", "dbQueryRowScan", "(", "c", ".", "db", ",", "q", ",", "arg1", ",", "arg2", ")", "\n", "if", "err", "!=", "nil", "{", "if", "err", "==", "sql", ".", "ErrNoRows", "{", "return", "-", "1", ",", "entry", ",", "ErrNoSuchObject", "\n", "}", "\n\n", "return", "-", "1", ",", "entry", ",", "err", "\n", "}", "\n\n", "entry", ".", "Name", "=", "name", "\n", "entry", ".", "Target", "=", "fingerprint", "\n", "entry", ".", "Description", "=", "description", "\n\n", "return", "id", ",", "entry", ",", "nil", "\n", "}"], "docstring": "// ImageAliasGet returns the alias with the given name in the given project.", "docstring_tokens": ["ImageAliasGet", "returns", "the", "alias", "with", "the", "given", "name", "in", "the", "given", "project", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/db/images.go#L584-L631", "partition": "test"}
{"repo": "bazelbuild/bazel-gazelle", "path": "rule/rule.go", "func_name": "SetAttr", "original_string": "func (r *Rule) SetAttr(key string, value interface{}) {\n\trhs := ExprFromValue(value)\n\tif attr, ok := r.attrs[key]; ok {\n\t\tattr.RHS = rhs\n\t} else {\n\t\tr.attrs[key] = &bzl.AssignExpr{\n\t\t\tLHS: &bzl.Ident{Name: key},\n\t\t\tRHS: rhs,\n\t\t\tOp:  \"=\",\n\t\t}\n\t}\n\tr.updated = true\n}", "language": "go", "code": "func (r *Rule) SetAttr(key string, value interface{}) {\n\trhs := ExprFromValue(value)\n\tif attr, ok := r.attrs[key]; ok {\n\t\tattr.RHS = rhs\n\t} else {\n\t\tr.attrs[key] = &bzl.AssignExpr{\n\t\t\tLHS: &bzl.Ident{Name: key},\n\t\t\tRHS: rhs,\n\t\t\tOp:  \"=\",\n\t\t}\n\t}\n\tr.updated = true\n}", "code_tokens": ["func", "(", "r", "*", "Rule", ")", "SetAttr", "(", "key", "string", ",", "value", "interface", "{", "}", ")", "{", "rhs", ":=", "ExprFromValue", "(", "value", ")", "\n", "if", "attr", ",", "ok", ":=", "r", ".", "attrs", "[", "key", "]", ";", "ok", "{", "attr", ".", "RHS", "=", "rhs", "\n", "}", "else", "{", "r", ".", "attrs", "[", "key", "]", "=", "&", "bzl", ".", "AssignExpr", "{", "LHS", ":", "&", "bzl", ".", "Ident", "{", "Name", ":", "key", "}", ",", "RHS", ":", "rhs", ",", "Op", ":", "\"", "\"", ",", "}", "\n", "}", "\n", "r", ".", "updated", "=", "true", "\n", "}"], "docstring": "// SetAttr adds or replaces the named attribute with an expression produced\n// by ExprFromValue.", "docstring_tokens": ["SetAttr", "adds", "or", "replaces", "the", "named", "attribute", "with", "an", "expression", "produced", "by", "ExprFromValue", "."], "sha": "e3805aaca69a9deb949b47bfc45b9b1870712f4f", "url": "https://github.com/bazelbuild/bazel-gazelle/blob/e3805aaca69a9deb949b47bfc45b9b1870712f4f/rule/rule.go#L700-L712", "partition": "test"}
{"repo": "hooklift/govix", "path": "cddvd.go", "func_name": "BusTypeFromID", "original_string": "func BusTypeFromID(ID string) vmx.BusType {\n\tvar bus vmx.BusType\n\tswitch {\n\tcase strings.HasPrefix(ID, string(vmx.IDE)):\n\t\tbus = vmx.IDE\n\tcase strings.HasPrefix(ID, string(vmx.SCSI)):\n\t\tbus = vmx.SCSI\n\tcase strings.HasPrefix(ID, string(vmx.SATA)):\n\t\tbus = vmx.SATA\n\t}\n\n\treturn bus\n}", "language": "go", "code": "func BusTypeFromID(ID string) vmx.BusType {\n\tvar bus vmx.BusType\n\tswitch {\n\tcase strings.HasPrefix(ID, string(vmx.IDE)):\n\t\tbus = vmx.IDE\n\tcase strings.HasPrefix(ID, string(vmx.SCSI)):\n\t\tbus = vmx.SCSI\n\tcase strings.HasPrefix(ID, string(vmx.SATA)):\n\t\tbus = vmx.SATA\n\t}\n\n\treturn bus\n}", "code_tokens": ["func", "BusTypeFromID", "(", "ID", "string", ")", "vmx", ".", "BusType", "{", "var", "bus", "vmx", ".", "BusType", "\n", "switch", "{", "case", "strings", ".", "HasPrefix", "(", "ID", ",", "string", "(", "vmx", ".", "IDE", ")", ")", ":", "bus", "=", "vmx", ".", "IDE", "\n", "case", "strings", ".", "HasPrefix", "(", "ID", ",", "string", "(", "vmx", ".", "SCSI", ")", ")", ":", "bus", "=", "vmx", ".", "SCSI", "\n", "case", "strings", ".", "HasPrefix", "(", "ID", ",", "string", "(", "vmx", ".", "SATA", ")", ")", ":", "bus", "=", "vmx", ".", "SATA", "\n", "}", "\n\n", "return", "bus", "\n", "}"], "docstring": "// BusTypeFromID gets BusType from device ID.", "docstring_tokens": ["BusTypeFromID", "gets", "BusType", "from", "device", "ID", "."], "sha": "063702285520a992b920fc1575e305dc9ffd6ffe", "url": "https://github.com/hooklift/govix/blob/063702285520a992b920fc1575e305dc9ffd6ffe/cddvd.go#L178-L190", "partition": "test"}
{"repo": "libp2p/go-libp2p-crypto", "path": "ecdsa.go", "func_name": "GenerateECDSAKeyPairWithCurve", "original_string": "func GenerateECDSAKeyPairWithCurve(curve elliptic.Curve, src io.Reader) (PrivKey, PubKey, error) {\n\tpriv, err := ecdsa.GenerateKey(curve, src)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn &ECDSAPrivateKey{priv}, &ECDSAPublicKey{&priv.PublicKey}, nil\n}", "language": "go", "code": "func GenerateECDSAKeyPairWithCurve(curve elliptic.Curve, src io.Reader) (PrivKey, PubKey, error) {\n\tpriv, err := ecdsa.GenerateKey(curve, src)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn &ECDSAPrivateKey{priv}, &ECDSAPublicKey{&priv.PublicKey}, nil\n}", "code_tokens": ["func", "GenerateECDSAKeyPairWithCurve", "(", "curve", "elliptic", ".", "Curve", ",", "src", "io", ".", "Reader", ")", "(", "PrivKey", ",", "PubKey", ",", "error", ")", "{", "priv", ",", "err", ":=", "ecdsa", ".", "GenerateKey", "(", "curve", ",", "src", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "err", "\n", "}", "\n\n", "return", "&", "ECDSAPrivateKey", "{", "priv", "}", ",", "&", "ECDSAPublicKey", "{", "&", "priv", ".", "PublicKey", "}", ",", "nil", "\n", "}"], "docstring": "// GenerateECDSAKeyPairWithCurve generates a new ecdsa private and public key with a speicified curve", "docstring_tokens": ["GenerateECDSAKeyPairWithCurve", "generates", "a", "new", "ecdsa", "private", "and", "public", "key", "with", "a", "speicified", "curve"], "sha": "9d2fed53443f745e6dc4d02bdcc94d9742a0ca84", "url": "https://github.com/libp2p/go-libp2p-crypto/blob/9d2fed53443f745e6dc4d02bdcc94d9742a0ca84/ecdsa.go#L50-L57", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/plugin/vault/pachyderm/revoke.go", "func_name": "revokeUserCredentials", "original_string": "func revokeUserCredentials(ctx context.Context, pachdAddress string, userToken string, adminToken string) error {\n\t// Setup a single use client w the given admin token / address\n\tclient, err := pclient.NewFromAddress(pachdAddress)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer client.Close() // avoid leaking connections\n\n\tclient = client.WithCtx(ctx)\n\tclient.SetAuthToken(adminToken)\n\t_, err = client.AuthAPIClient.RevokeAuthToken(client.Ctx(), &auth.RevokeAuthTokenRequest{\n\t\tToken: userToken,\n\t})\n\treturn err\n}", "language": "go", "code": "func revokeUserCredentials(ctx context.Context, pachdAddress string, userToken string, adminToken string) error {\n\t// Setup a single use client w the given admin token / address\n\tclient, err := pclient.NewFromAddress(pachdAddress)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer client.Close() // avoid leaking connections\n\n\tclient = client.WithCtx(ctx)\n\tclient.SetAuthToken(adminToken)\n\t_, err = client.AuthAPIClient.RevokeAuthToken(client.Ctx(), &auth.RevokeAuthTokenRequest{\n\t\tToken: userToken,\n\t})\n\treturn err\n}", "code_tokens": ["func", "revokeUserCredentials", "(", "ctx", "context", ".", "Context", ",", "pachdAddress", "string", ",", "userToken", "string", ",", "adminToken", "string", ")", "error", "{", "// Setup a single use client w the given admin token / address", "client", ",", "err", ":=", "pclient", ".", "NewFromAddress", "(", "pachdAddress", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "defer", "client", ".", "Close", "(", ")", "// avoid leaking connections", "\n\n", "client", "=", "client", ".", "WithCtx", "(", "ctx", ")", "\n", "client", ".", "SetAuthToken", "(", "adminToken", ")", "\n", "_", ",", "err", "=", "client", ".", "AuthAPIClient", ".", "RevokeAuthToken", "(", "client", ".", "Ctx", "(", ")", ",", "&", "auth", ".", "RevokeAuthTokenRequest", "{", "Token", ":", "userToken", ",", "}", ")", "\n", "return", "err", "\n", "}"], "docstring": "// revokeUserCredentials revokes the Pachyderm authentication token 'userToken'\n// using the vault plugin's Admin credentials.", "docstring_tokens": ["revokeUserCredentials", "revokes", "the", "Pachyderm", "authentication", "token", "userToken", "using", "the", "vault", "plugin", "s", "Admin", "credentials", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/plugin/vault/pachyderm/revoke.go#L57-L71", "partition": "test"}
{"repo": "golang/appengine", "path": "search/struct.go", "func_name": "newStructFLS", "original_string": "func newStructFLS(p interface{}) (FieldLoadSaver, error) {\n\tv := reflect.ValueOf(p)\n\tif v.Kind() != reflect.Ptr || v.IsNil() || v.Elem().Kind() != reflect.Struct {\n\t\treturn nil, ErrInvalidDocumentType\n\t}\n\tcodec, err := loadCodec(v.Elem().Type())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn structFLS{v.Elem(), codec}, nil\n}", "language": "go", "code": "func newStructFLS(p interface{}) (FieldLoadSaver, error) {\n\tv := reflect.ValueOf(p)\n\tif v.Kind() != reflect.Ptr || v.IsNil() || v.Elem().Kind() != reflect.Struct {\n\t\treturn nil, ErrInvalidDocumentType\n\t}\n\tcodec, err := loadCodec(v.Elem().Type())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn structFLS{v.Elem(), codec}, nil\n}", "code_tokens": ["func", "newStructFLS", "(", "p", "interface", "{", "}", ")", "(", "FieldLoadSaver", ",", "error", ")", "{", "v", ":=", "reflect", ".", "ValueOf", "(", "p", ")", "\n", "if", "v", ".", "Kind", "(", ")", "!=", "reflect", ".", "Ptr", "||", "v", ".", "IsNil", "(", ")", "||", "v", ".", "Elem", "(", ")", ".", "Kind", "(", ")", "!=", "reflect", ".", "Struct", "{", "return", "nil", ",", "ErrInvalidDocumentType", "\n", "}", "\n", "codec", ",", "err", ":=", "loadCodec", "(", "v", ".", "Elem", "(", ")", ".", "Type", "(", ")", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "structFLS", "{", "v", ".", "Elem", "(", ")", ",", "codec", "}", ",", "nil", "\n", "}"], "docstring": "// newStructFLS returns a FieldLoadSaver for the struct pointer p.", "docstring_tokens": ["newStructFLS", "returns", "a", "FieldLoadSaver", "for", "the", "struct", "pointer", "p", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/search/struct.go#L213-L223", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/config/config.go", "func_name": "defaultJobBase", "original_string": "func (c *ProwConfig) defaultJobBase(base *JobBase) {\n\tif base.Agent == \"\" { // Use kubernetes by default\n\t\tbase.Agent = string(prowapi.KubernetesAgent)\n\t}\n\tif base.Namespace == nil || *base.Namespace == \"\" {\n\t\ts := c.PodNamespace\n\t\tbase.Namespace = &s\n\t}\n\tif base.Cluster == \"\" {\n\t\tbase.Cluster = kube.DefaultClusterAlias\n\t}\n}", "language": "go", "code": "func (c *ProwConfig) defaultJobBase(base *JobBase) {\n\tif base.Agent == \"\" { // Use kubernetes by default\n\t\tbase.Agent = string(prowapi.KubernetesAgent)\n\t}\n\tif base.Namespace == nil || *base.Namespace == \"\" {\n\t\ts := c.PodNamespace\n\t\tbase.Namespace = &s\n\t}\n\tif base.Cluster == \"\" {\n\t\tbase.Cluster = kube.DefaultClusterAlias\n\t}\n}", "code_tokens": ["func", "(", "c", "*", "ProwConfig", ")", "defaultJobBase", "(", "base", "*", "JobBase", ")", "{", "if", "base", ".", "Agent", "==", "\"", "\"", "{", "// Use kubernetes by default", "base", ".", "Agent", "=", "string", "(", "prowapi", ".", "KubernetesAgent", ")", "\n", "}", "\n", "if", "base", ".", "Namespace", "==", "nil", "||", "*", "base", ".", "Namespace", "==", "\"", "\"", "{", "s", ":=", "c", ".", "PodNamespace", "\n", "base", ".", "Namespace", "=", "&", "s", "\n", "}", "\n", "if", "base", ".", "Cluster", "==", "\"", "\"", "{", "base", ".", "Cluster", "=", "kube", ".", "DefaultClusterAlias", "\n", "}", "\n", "}"], "docstring": "// defaultJobBase configures common parameters, currently Agent and Namespace.", "docstring_tokens": ["defaultJobBase", "configures", "common", "parameters", "currently", "Agent", "and", "Namespace", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/config/config.go#L1343-L1354", "partition": "test"}
{"repo": "pact-foundation/pact-go", "path": "dsl/mock_service.go", "func_name": "DeleteInteractions", "original_string": "func (m *MockService) DeleteInteractions() error {\n\tlog.Println(\"[DEBUG] mock service delete interactions\")\n\turl := fmt.Sprintf(\"%s/interactions\", m.BaseURL)\n\treturn m.call(\"DELETE\", url, nil)\n}", "language": "go", "code": "func (m *MockService) DeleteInteractions() error {\n\tlog.Println(\"[DEBUG] mock service delete interactions\")\n\turl := fmt.Sprintf(\"%s/interactions\", m.BaseURL)\n\treturn m.call(\"DELETE\", url, nil)\n}", "code_tokens": ["func", "(", "m", "*", "MockService", ")", "DeleteInteractions", "(", ")", "error", "{", "log", ".", "Println", "(", "\"", "\"", ")", "\n", "url", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "m", ".", "BaseURL", ")", "\n", "return", "m", ".", "call", "(", "\"", "\"", ",", "url", ",", "nil", ")", "\n", "}"], "docstring": "// DeleteInteractions removes any previous Mock Service Interactions.", "docstring_tokens": ["DeleteInteractions", "removes", "any", "previous", "Mock", "Service", "Interactions", "."], "sha": "467dea56d27e154363e1975f6e9f4dbf66148e79", "url": "https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/dsl/mock_service.go#L71-L75", "partition": "test"}
{"repo": "nwaples/rardecode", "path": "decode_reader.go", "func_name": "fill", "original_string": "func (d *decodeReader) fill() {\n\tif d.err != nil {\n\t\treturn\n\t}\n\tvar fl []*filterBlock\n\tfl, d.err = d.dec.fill(&d.win) // fill window using decoder\n\tfor _, f := range fl {\n\t\terr := d.queueFilter(f)\n\t\tif err != nil {\n\t\t\td.err = err\n\t\t\treturn\n\t\t}\n\t}\n}", "language": "go", "code": "func (d *decodeReader) fill() {\n\tif d.err != nil {\n\t\treturn\n\t}\n\tvar fl []*filterBlock\n\tfl, d.err = d.dec.fill(&d.win) // fill window using decoder\n\tfor _, f := range fl {\n\t\terr := d.queueFilter(f)\n\t\tif err != nil {\n\t\t\td.err = err\n\t\t\treturn\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "d", "*", "decodeReader", ")", "fill", "(", ")", "{", "if", "d", ".", "err", "!=", "nil", "{", "return", "\n", "}", "\n", "var", "fl", "[", "]", "*", "filterBlock", "\n", "fl", ",", "d", ".", "err", "=", "d", ".", "dec", ".", "fill", "(", "&", "d", ".", "win", ")", "// fill window using decoder", "\n", "for", "_", ",", "f", ":=", "range", "fl", "{", "err", ":=", "d", ".", "queueFilter", "(", "f", ")", "\n", "if", "err", "!=", "nil", "{", "d", ".", "err", "=", "err", "\n", "return", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// fill fills the decodeReader's window", "docstring_tokens": ["fill", "fills", "the", "decodeReader", "s", "window"], "sha": "197ef08ef68c4454ae5970a9c2692d6056ceb8d7", "url": "https://github.com/nwaples/rardecode/blob/197ef08ef68c4454ae5970a9c2692d6056ceb8d7/decode_reader.go#L236-L249", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "target/target.go", "func_name": "WithBindingName", "original_string": "func (p ExposeDevToolsProtocolParams) WithBindingName(bindingName string) *ExposeDevToolsProtocolParams {\n\tp.BindingName = bindingName\n\treturn &p\n}", "language": "go", "code": "func (p ExposeDevToolsProtocolParams) WithBindingName(bindingName string) *ExposeDevToolsProtocolParams {\n\tp.BindingName = bindingName\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "ExposeDevToolsProtocolParams", ")", "WithBindingName", "(", "bindingName", "string", ")", "*", "ExposeDevToolsProtocolParams", "{", "p", ".", "BindingName", "=", "bindingName", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithBindingName binding name, 'cdp' if not specified.", "docstring_tokens": ["WithBindingName", "binding", "name", "cdp", "if", "not", "specified", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/target/target.go#L184-L187", "partition": "test"}
{"repo": "lxc/lxd", "path": "lxd/api.go", "func_name": "projectParam", "original_string": "func projectParam(request *http.Request) string {\n\tproject := queryParam(request, \"project\")\n\tif project == \"\" {\n\t\tproject = \"default\"\n\t}\n\treturn project\n}", "language": "go", "code": "func projectParam(request *http.Request) string {\n\tproject := queryParam(request, \"project\")\n\tif project == \"\" {\n\t\tproject = \"default\"\n\t}\n\treturn project\n}", "code_tokens": ["func", "projectParam", "(", "request", "*", "http", ".", "Request", ")", "string", "{", "project", ":=", "queryParam", "(", "request", ",", "\"", "\"", ")", "\n", "if", "project", "==", "\"", "\"", "{", "project", "=", "\"", "\"", "\n", "}", "\n", "return", "project", "\n", "}"], "docstring": "// Extract the project query parameter from the given request.", "docstring_tokens": ["Extract", "the", "project", "query", "parameter", "from", "the", "given", "request", "."], "sha": "7a41d14e4c1a6bc25918aca91004d594774dcdd3", "url": "https://github.com/lxc/lxd/blob/7a41d14e4c1a6bc25918aca91004d594774dcdd3/lxd/api.go#L113-L119", "partition": "test"}
{"repo": "iron-io/functions_go", "path": "client/routes/get_apps_app_routes_route_parameters.go", "func_name": "WithApp", "original_string": "func (o *GetAppsAppRoutesRouteParams) WithApp(app string) *GetAppsAppRoutesRouteParams {\n\to.SetApp(app)\n\treturn o\n}", "language": "go", "code": "func (o *GetAppsAppRoutesRouteParams) WithApp(app string) *GetAppsAppRoutesRouteParams {\n\to.SetApp(app)\n\treturn o\n}", "code_tokens": ["func", "(", "o", "*", "GetAppsAppRoutesRouteParams", ")", "WithApp", "(", "app", "string", ")", "*", "GetAppsAppRoutesRouteParams", "{", "o", ".", "SetApp", "(", "app", ")", "\n", "return", "o", "\n", "}"], "docstring": "// WithApp adds the app to the get apps app routes route params", "docstring_tokens": ["WithApp", "adds", "the", "app", "to", "the", "get", "apps", "app", "routes", "route", "params"], "sha": "91b84f5bbb17095bf1c7028ec6e70a3dc06a5893", "url": "https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/routes/get_apps_app_routes_route_parameters.go#L115-L118", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "MustIpv6", "original_string": "func (u PeerAddressIp) MustIpv6() [16]byte {\n\tval, ok := u.GetIpv6()\n\n\tif !ok {\n\t\tpanic(\"arm Ipv6 is not set\")\n\t}\n\n\treturn val\n}", "language": "go", "code": "func (u PeerAddressIp) MustIpv6() [16]byte {\n\tval, ok := u.GetIpv6()\n\n\tif !ok {\n\t\tpanic(\"arm Ipv6 is not set\")\n\t}\n\n\treturn val\n}", "code_tokens": ["func", "(", "u", "PeerAddressIp", ")", "MustIpv6", "(", ")", "[", "16", "]", "byte", "{", "val", ",", "ok", ":=", "u", ".", "GetIpv6", "(", ")", "\n\n", "if", "!", "ok", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "val", "\n", "}"], "docstring": "// MustIpv6 retrieves the Ipv6 value from the union,\n// panicing if the value is not set.", "docstring_tokens": ["MustIpv6", "retrieves", "the", "Ipv6", "value", "from", "the", "union", "panicing", "if", "the", "value", "is", "not", "set", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6154-L6162", "partition": "test"}
{"repo": "stefantalpalaru/pool", "path": "pool.go", "func_name": "worker", "original_string": "func (pool *Pool) worker(worker_id uint) {\n\tjob_pipe := make(chan *Job)\nWORKER_LOOP:\n\tfor {\n\t\tpool.job_wanted_pipe <- job_pipe\n\t\tjob := <-job_pipe\n\t\tif job == nil {\n\t\t\ttime.Sleep(pool.interval * time.Millisecond)\n\t\t} else {\n\t\t\tjob.Worker_id = worker_id\n\t\t\tpool.subworker(job)\n\t\t\tpool.done_pipe <- job\n\t\t}\n\t\tselect {\n\t\tcase <-pool.worker_kill_pipe:\n\t\t\tbreak WORKER_LOOP\n\t\tdefault:\n\t\t}\n\t}\n\tpool.worker_wg.Done()\n}", "language": "go", "code": "func (pool *Pool) worker(worker_id uint) {\n\tjob_pipe := make(chan *Job)\nWORKER_LOOP:\n\tfor {\n\t\tpool.job_wanted_pipe <- job_pipe\n\t\tjob := <-job_pipe\n\t\tif job == nil {\n\t\t\ttime.Sleep(pool.interval * time.Millisecond)\n\t\t} else {\n\t\t\tjob.Worker_id = worker_id\n\t\t\tpool.subworker(job)\n\t\t\tpool.done_pipe <- job\n\t\t}\n\t\tselect {\n\t\tcase <-pool.worker_kill_pipe:\n\t\t\tbreak WORKER_LOOP\n\t\tdefault:\n\t\t}\n\t}\n\tpool.worker_wg.Done()\n}", "code_tokens": ["func", "(", "pool", "*", "Pool", ")", "worker", "(", "worker_id", "uint", ")", "{", "job_pipe", ":=", "make", "(", "chan", "*", "Job", ")", "\n", "WORKER_LOOP", ":", "for", "{", "pool", ".", "job_wanted_pipe", "<-", "job_pipe", "\n", "job", ":=", "<-", "job_pipe", "\n", "if", "job", "==", "nil", "{", "time", ".", "Sleep", "(", "pool", ".", "interval", "*", "time", ".", "Millisecond", ")", "\n", "}", "else", "{", "job", ".", "Worker_id", "=", "worker_id", "\n", "pool", ".", "subworker", "(", "job", ")", "\n", "pool", ".", "done_pipe", "<-", "job", "\n", "}", "\n", "select", "{", "case", "<-", "pool", ".", "worker_kill_pipe", ":", "break", "WORKER_LOOP", "\n", "default", ":", "}", "\n", "}", "\n", "pool", ".", "worker_wg", ".", "Done", "(", ")", "\n", "}"], "docstring": "// worker gets a job from the job_pipe, passes it to a\n// subworker and puts the job in the done_pipe when finished.", "docstring_tokens": ["worker", "gets", "a", "job", "from", "the", "job_pipe", "passes", "it", "to", "a", "subworker", "and", "puts", "the", "job", "in", "the", "done_pipe", "when", "finished", "."], "sha": "df8b849d27751462526089005979b28064c1e08e", "url": "https://github.com/stefantalpalaru/pool/blob/df8b849d27751462526089005979b28064c1e08e/pool.go#L76-L96", "partition": "test"}
{"repo": "golang/appengine", "path": "search/search.go", "func_name": "Delete", "original_string": "func (x *Index) Delete(c context.Context, id string) error {\n\treturn x.DeleteMulti(c, []string{id})\n}", "language": "go", "code": "func (x *Index) Delete(c context.Context, id string) error {\n\treturn x.DeleteMulti(c, []string{id})\n}", "code_tokens": ["func", "(", "x", "*", "Index", ")", "Delete", "(", "c", "context", ".", "Context", ",", "id", "string", ")", "error", "{", "return", "x", ".", "DeleteMulti", "(", "c", ",", "[", "]", "string", "{", "id", "}", ")", "\n", "}"], "docstring": "// Delete deletes a document from the index.", "docstring_tokens": ["Delete", "deletes", "a", "document", "from", "the", "index", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/search/search.go#L241-L243", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "NewAllowTrustOpAsset", "original_string": "func NewAllowTrustOpAsset(aType AssetType, value interface{}) (result AllowTrustOpAsset, err error) {\n\tresult.Type = aType\n\tswitch AssetType(aType) {\n\tcase AssetTypeAssetTypeCreditAlphanum4:\n\t\ttv, ok := value.([4]byte)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be [4]byte\")\n\t\t\treturn\n\t\t}\n\t\tresult.AssetCode4 = &tv\n\tcase AssetTypeAssetTypeCreditAlphanum12:\n\t\ttv, ok := value.([12]byte)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be [12]byte\")\n\t\t\treturn\n\t\t}\n\t\tresult.AssetCode12 = &tv\n\t}\n\treturn\n}", "language": "go", "code": "func NewAllowTrustOpAsset(aType AssetType, value interface{}) (result AllowTrustOpAsset, err error) {\n\tresult.Type = aType\n\tswitch AssetType(aType) {\n\tcase AssetTypeAssetTypeCreditAlphanum4:\n\t\ttv, ok := value.([4]byte)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be [4]byte\")\n\t\t\treturn\n\t\t}\n\t\tresult.AssetCode4 = &tv\n\tcase AssetTypeAssetTypeCreditAlphanum12:\n\t\ttv, ok := value.([12]byte)\n\t\tif !ok {\n\t\t\terr = fmt.Errorf(\"invalid value, must be [12]byte\")\n\t\t\treturn\n\t\t}\n\t\tresult.AssetCode12 = &tv\n\t}\n\treturn\n}", "code_tokens": ["func", "NewAllowTrustOpAsset", "(", "aType", "AssetType", ",", "value", "interface", "{", "}", ")", "(", "result", "AllowTrustOpAsset", ",", "err", "error", ")", "{", "result", ".", "Type", "=", "aType", "\n", "switch", "AssetType", "(", "aType", ")", "{", "case", "AssetTypeAssetTypeCreditAlphanum4", ":", "tv", ",", "ok", ":=", "value", ".", "(", "[", "4", "]", "byte", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "AssetCode4", "=", "&", "tv", "\n", "case", "AssetTypeAssetTypeCreditAlphanum12", ":", "tv", ",", "ok", ":=", "value", ".", "(", "[", "12", "]", "byte", ")", "\n", "if", "!", "ok", "{", "err", "=", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "return", "\n", "}", "\n", "result", ".", "AssetCode12", "=", "&", "tv", "\n", "}", "\n", "return", "\n", "}"], "docstring": "// NewAllowTrustOpAsset creates a new  AllowTrustOpAsset.", "docstring_tokens": ["NewAllowTrustOpAsset", "creates", "a", "new", "AllowTrustOpAsset", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L1558-L1577", "partition": "test"}
{"repo": "hashicorp/raft", "path": "observer.go", "func_name": "observe", "original_string": "func (r *Raft) observe(o interface{}) {\n\t// In general observers should not block. But in any case this isn't\n\t// disastrous as we only hold a read lock, which merely prevents\n\t// registration / deregistration of observers.\n\tr.observersLock.RLock()\n\tdefer r.observersLock.RUnlock()\n\tfor _, or := range r.observers {\n\t\t// It's wasteful to do this in the loop, but for the common case\n\t\t// where there are no observers we won't create any objects.\n\t\tob := Observation{Raft: r, Data: o}\n\t\tif or.filter != nil && !or.filter(&ob) {\n\t\t\tcontinue\n\t\t}\n\t\tif or.channel == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif or.blocking {\n\t\t\tor.channel <- ob\n\t\t\tatomic.AddUint64(&or.numObserved, 1)\n\t\t} else {\n\t\t\tselect {\n\t\t\tcase or.channel <- ob:\n\t\t\t\tatomic.AddUint64(&or.numObserved, 1)\n\t\t\tdefault:\n\t\t\t\tatomic.AddUint64(&or.numDropped, 1)\n\t\t\t}\n\t\t}\n\t}\n}", "language": "go", "code": "func (r *Raft) observe(o interface{}) {\n\t// In general observers should not block. But in any case this isn't\n\t// disastrous as we only hold a read lock, which merely prevents\n\t// registration / deregistration of observers.\n\tr.observersLock.RLock()\n\tdefer r.observersLock.RUnlock()\n\tfor _, or := range r.observers {\n\t\t// It's wasteful to do this in the loop, but for the common case\n\t\t// where there are no observers we won't create any objects.\n\t\tob := Observation{Raft: r, Data: o}\n\t\tif or.filter != nil && !or.filter(&ob) {\n\t\t\tcontinue\n\t\t}\n\t\tif or.channel == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif or.blocking {\n\t\t\tor.channel <- ob\n\t\t\tatomic.AddUint64(&or.numObserved, 1)\n\t\t} else {\n\t\t\tselect {\n\t\t\tcase or.channel <- ob:\n\t\t\t\tatomic.AddUint64(&or.numObserved, 1)\n\t\t\tdefault:\n\t\t\t\tatomic.AddUint64(&or.numDropped, 1)\n\t\t\t}\n\t\t}\n\t}\n}", "code_tokens": ["func", "(", "r", "*", "Raft", ")", "observe", "(", "o", "interface", "{", "}", ")", "{", "// In general observers should not block. But in any case this isn't", "// disastrous as we only hold a read lock, which merely prevents", "// registration / deregistration of observers.", "r", ".", "observersLock", ".", "RLock", "(", ")", "\n", "defer", "r", ".", "observersLock", ".", "RUnlock", "(", ")", "\n", "for", "_", ",", "or", ":=", "range", "r", ".", "observers", "{", "// It's wasteful to do this in the loop, but for the common case", "// where there are no observers we won't create any objects.", "ob", ":=", "Observation", "{", "Raft", ":", "r", ",", "Data", ":", "o", "}", "\n", "if", "or", ".", "filter", "!=", "nil", "&&", "!", "or", ".", "filter", "(", "&", "ob", ")", "{", "continue", "\n", "}", "\n", "if", "or", ".", "channel", "==", "nil", "{", "continue", "\n", "}", "\n", "if", "or", ".", "blocking", "{", "or", ".", "channel", "<-", "ob", "\n", "atomic", ".", "AddUint64", "(", "&", "or", ".", "numObserved", ",", "1", ")", "\n", "}", "else", "{", "select", "{", "case", "or", ".", "channel", "<-", "ob", ":", "atomic", ".", "AddUint64", "(", "&", "or", ".", "numObserved", ",", "1", ")", "\n", "default", ":", "atomic", ".", "AddUint64", "(", "&", "or", ".", "numDropped", ",", "1", ")", "\n", "}", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// observe sends an observation to every observer.", "docstring_tokens": ["observe", "sends", "an", "observation", "to", "every", "observer", "."], "sha": "773bcaa2009bf059c5c06457b9fccd156d5e91e7", "url": "https://github.com/hashicorp/raft/blob/773bcaa2009bf059c5c06457b9fccd156d5e91e7/observer.go#L94-L122", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "integration/cluster.go", "func_name": "HTTPMembers", "original_string": "func (c *cluster) HTTPMembers() []client.Member {\n\tms := []client.Member{}\n\tfor _, m := range c.Members {\n\t\tpScheme := schemeFromTLSInfo(m.PeerTLSInfo)\n\t\tcScheme := schemeFromTLSInfo(m.ClientTLSInfo)\n\t\tcm := client.Member{Name: m.Name}\n\t\tfor _, ln := range m.PeerListeners {\n\t\t\tcm.PeerURLs = append(cm.PeerURLs, pScheme+\"://\"+ln.Addr().String())\n\t\t}\n\t\tfor _, ln := range m.ClientListeners {\n\t\t\tcm.ClientURLs = append(cm.ClientURLs, cScheme+\"://\"+ln.Addr().String())\n\t\t}\n\t\tms = append(ms, cm)\n\t}\n\treturn ms\n}", "language": "go", "code": "func (c *cluster) HTTPMembers() []client.Member {\n\tms := []client.Member{}\n\tfor _, m := range c.Members {\n\t\tpScheme := schemeFromTLSInfo(m.PeerTLSInfo)\n\t\tcScheme := schemeFromTLSInfo(m.ClientTLSInfo)\n\t\tcm := client.Member{Name: m.Name}\n\t\tfor _, ln := range m.PeerListeners {\n\t\t\tcm.PeerURLs = append(cm.PeerURLs, pScheme+\"://\"+ln.Addr().String())\n\t\t}\n\t\tfor _, ln := range m.ClientListeners {\n\t\t\tcm.ClientURLs = append(cm.ClientURLs, cScheme+\"://\"+ln.Addr().String())\n\t\t}\n\t\tms = append(ms, cm)\n\t}\n\treturn ms\n}", "code_tokens": ["func", "(", "c", "*", "cluster", ")", "HTTPMembers", "(", ")", "[", "]", "client", ".", "Member", "{", "ms", ":=", "[", "]", "client", ".", "Member", "{", "}", "\n", "for", "_", ",", "m", ":=", "range", "c", ".", "Members", "{", "pScheme", ":=", "schemeFromTLSInfo", "(", "m", ".", "PeerTLSInfo", ")", "\n", "cScheme", ":=", "schemeFromTLSInfo", "(", "m", ".", "ClientTLSInfo", ")", "\n", "cm", ":=", "client", ".", "Member", "{", "Name", ":", "m", ".", "Name", "}", "\n", "for", "_", ",", "ln", ":=", "range", "m", ".", "PeerListeners", "{", "cm", ".", "PeerURLs", "=", "append", "(", "cm", ".", "PeerURLs", ",", "pScheme", "+", "\"", "\"", "+", "ln", ".", "Addr", "(", ")", ".", "String", "(", ")", ")", "\n", "}", "\n", "for", "_", ",", "ln", ":=", "range", "m", ".", "ClientListeners", "{", "cm", ".", "ClientURLs", "=", "append", "(", "cm", ".", "ClientURLs", ",", "cScheme", "+", "\"", "\"", "+", "ln", ".", "Addr", "(", ")", ".", "String", "(", ")", ")", "\n", "}", "\n", "ms", "=", "append", "(", "ms", ",", "cm", ")", "\n", "}", "\n", "return", "ms", "\n", "}"], "docstring": "// HTTPMembers returns a list of all active members as client.Members", "docstring_tokens": ["HTTPMembers", "returns", "a", "list", "of", "all", "active", "members", "as", "client", ".", "Members"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/integration/cluster.go#L261-L276", "partition": "test"}
{"repo": "pact-foundation/pact-go", "path": "dsl/message.go", "func_name": "AsType", "original_string": "func (p *Message) AsType(t interface{}) *Message {\n\tfmt.Println(\"[DEBUG] setting Message decoding to type:\", reflect.TypeOf(t))\n\tp.Type = t\n\n\treturn p\n}", "language": "go", "code": "func (p *Message) AsType(t interface{}) *Message {\n\tfmt.Println(\"[DEBUG] setting Message decoding to type:\", reflect.TypeOf(t))\n\tp.Type = t\n\n\treturn p\n}", "code_tokens": ["func", "(", "p", "*", "Message", ")", "AsType", "(", "t", "interface", "{", "}", ")", "*", "Message", "{", "fmt", ".", "Println", "(", "\"", "\"", ",", "reflect", ".", "TypeOf", "(", "t", ")", ")", "\n", "p", ".", "Type", "=", "t", "\n\n", "return", "p", "\n", "}"], "docstring": "// AsType specifies that the content sent through to the\n// consumer handler should be sent as the given type", "docstring_tokens": ["AsType", "specifies", "that", "the", "content", "sent", "through", "to", "the", "consumer", "handler", "should", "be", "sent", "as", "the", "given", "type"], "sha": "467dea56d27e154363e1975f6e9f4dbf66148e79", "url": "https://github.com/pact-foundation/pact-go/blob/467dea56d27e154363e1975f6e9f4dbf66148e79/dsl/message.go#L92-L97", "partition": "test"}
{"repo": "weaveworks/mesh", "path": "_metcd/etcd_store.go", "func_name": "Put", "original_string": "func (s *etcdStore) Put(ctx context.Context, req *etcdserverpb.PutRequest) (*etcdserverpb.PutResponse, error) {\n\tireq := etcdserverpb.InternalRaftRequest{ID: <-s.idgen, Put: req}\n\tmsgc, errc, err := s.proposeInternalRaftRequest(ireq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\ts.cancelInternalRaftRequest(ireq)\n\t\treturn nil, ctx.Err()\n\tcase msg := <-msgc:\n\t\treturn msg.(*etcdserverpb.PutResponse), nil\n\tcase err := <-errc:\n\t\treturn nil, err\n\tcase <-s.quitc:\n\t\treturn nil, errStopped\n\t}\n}", "language": "go", "code": "func (s *etcdStore) Put(ctx context.Context, req *etcdserverpb.PutRequest) (*etcdserverpb.PutResponse, error) {\n\tireq := etcdserverpb.InternalRaftRequest{ID: <-s.idgen, Put: req}\n\tmsgc, errc, err := s.proposeInternalRaftRequest(ireq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\ts.cancelInternalRaftRequest(ireq)\n\t\treturn nil, ctx.Err()\n\tcase msg := <-msgc:\n\t\treturn msg.(*etcdserverpb.PutResponse), nil\n\tcase err := <-errc:\n\t\treturn nil, err\n\tcase <-s.quitc:\n\t\treturn nil, errStopped\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "etcdStore", ")", "Put", "(", "ctx", "context", ".", "Context", ",", "req", "*", "etcdserverpb", ".", "PutRequest", ")", "(", "*", "etcdserverpb", ".", "PutResponse", ",", "error", ")", "{", "ireq", ":=", "etcdserverpb", ".", "InternalRaftRequest", "{", "ID", ":", "<-", "s", ".", "idgen", ",", "Put", ":", "req", "}", "\n", "msgc", ",", "errc", ",", "err", ":=", "s", ".", "proposeInternalRaftRequest", "(", "ireq", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "select", "{", "case", "<-", "ctx", ".", "Done", "(", ")", ":", "s", ".", "cancelInternalRaftRequest", "(", "ireq", ")", "\n", "return", "nil", ",", "ctx", ".", "Err", "(", ")", "\n", "case", "msg", ":=", "<-", "msgc", ":", "return", "msg", ".", "(", "*", "etcdserverpb", ".", "PutResponse", ")", ",", "nil", "\n", "case", "err", ":=", "<-", "errc", ":", "return", "nil", ",", "err", "\n", "case", "<-", "s", ".", "quitc", ":", "return", "nil", ",", "errStopped", "\n", "}", "\n", "}"], "docstring": "// Put implements gRPC KVServer.\n// Put puts the given key into the store.\n// A put request increases the revision of the store,\n// and generates one event in the event history.", "docstring_tokens": ["Put", "implements", "gRPC", "KVServer", ".", "Put", "puts", "the", "given", "key", "into", "the", "store", ".", "A", "put", "request", "increases", "the", "revision", "of", "the", "store", "and", "generates", "one", "event", "in", "the", "event", "history", "."], "sha": "512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39", "url": "https://github.com/weaveworks/mesh/blob/512bdb7b3cb7b2c939fcd0ee434d48b6732ecc39/_metcd/etcd_store.go#L117-L134", "partition": "test"}
{"repo": "iron-io/functions_go", "path": "client/tasks/get_tasks_parameters.go", "func_name": "WithContext", "original_string": "func (o *GetTasksParams) WithContext(ctx context.Context) *GetTasksParams {\n\to.SetContext(ctx)\n\treturn o\n}", "language": "go", "code": "func (o *GetTasksParams) WithContext(ctx context.Context) *GetTasksParams {\n\to.SetContext(ctx)\n\treturn o\n}", "code_tokens": ["func", "(", "o", "*", "GetTasksParams", ")", "WithContext", "(", "ctx", "context", ".", "Context", ")", "*", "GetTasksParams", "{", "o", ".", "SetContext", "(", "ctx", ")", "\n", "return", "o", "\n", "}"], "docstring": "// WithContext adds the context to the get tasks params", "docstring_tokens": ["WithContext", "adds", "the", "context", "to", "the", "get", "tasks", "params"], "sha": "91b84f5bbb17095bf1c7028ec6e70a3dc06a5893", "url": "https://github.com/iron-io/functions_go/blob/91b84f5bbb17095bf1c7028ec6e70a3dc06a5893/client/tasks/get_tasks_parameters.go#L81-L84", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/flagutil/github.go", "func_name": "GitHubClientWithLogFields", "original_string": "func (o *GitHubOptions) GitHubClientWithLogFields(secretAgent *secret.Agent, dryRun bool, fields logrus.Fields) (client *github.Client, err error) {\n\tvar generator *func() []byte\n\tif o.TokenPath == \"\" {\n\t\tgeneratorFunc := func() []byte {\n\t\t\treturn []byte{}\n\t\t}\n\t\tgenerator = &generatorFunc\n\t} else {\n\t\tif secretAgent == nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot store token from %q without a secret agent\", o.TokenPath)\n\t\t}\n\t\tgeneratorFunc := secretAgent.GetTokenGenerator(o.TokenPath)\n\t\tgenerator = &generatorFunc\n\t}\n\n\tif dryRun {\n\t\treturn github.NewDryRunClientWithFields(fields, *generator, o.graphqlEndpoint, o.endpoint.Strings()...), nil\n\t}\n\treturn github.NewClientWithFields(fields, *generator, o.graphqlEndpoint, o.endpoint.Strings()...), nil\n}", "language": "go", "code": "func (o *GitHubOptions) GitHubClientWithLogFields(secretAgent *secret.Agent, dryRun bool, fields logrus.Fields) (client *github.Client, err error) {\n\tvar generator *func() []byte\n\tif o.TokenPath == \"\" {\n\t\tgeneratorFunc := func() []byte {\n\t\t\treturn []byte{}\n\t\t}\n\t\tgenerator = &generatorFunc\n\t} else {\n\t\tif secretAgent == nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot store token from %q without a secret agent\", o.TokenPath)\n\t\t}\n\t\tgeneratorFunc := secretAgent.GetTokenGenerator(o.TokenPath)\n\t\tgenerator = &generatorFunc\n\t}\n\n\tif dryRun {\n\t\treturn github.NewDryRunClientWithFields(fields, *generator, o.graphqlEndpoint, o.endpoint.Strings()...), nil\n\t}\n\treturn github.NewClientWithFields(fields, *generator, o.graphqlEndpoint, o.endpoint.Strings()...), nil\n}", "code_tokens": ["func", "(", "o", "*", "GitHubOptions", ")", "GitHubClientWithLogFields", "(", "secretAgent", "*", "secret", ".", "Agent", ",", "dryRun", "bool", ",", "fields", "logrus", ".", "Fields", ")", "(", "client", "*", "github", ".", "Client", ",", "err", "error", ")", "{", "var", "generator", "*", "func", "(", ")", "[", "]", "byte", "\n", "if", "o", ".", "TokenPath", "==", "\"", "\"", "{", "generatorFunc", ":=", "func", "(", ")", "[", "]", "byte", "{", "return", "[", "]", "byte", "{", "}", "\n", "}", "\n", "generator", "=", "&", "generatorFunc", "\n", "}", "else", "{", "if", "secretAgent", "==", "nil", "{", "return", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "o", ".", "TokenPath", ")", "\n", "}", "\n", "generatorFunc", ":=", "secretAgent", ".", "GetTokenGenerator", "(", "o", ".", "TokenPath", ")", "\n", "generator", "=", "&", "generatorFunc", "\n", "}", "\n\n", "if", "dryRun", "{", "return", "github", ".", "NewDryRunClientWithFields", "(", "fields", ",", "*", "generator", ",", "o", ".", "graphqlEndpoint", ",", "o", ".", "endpoint", ".", "Strings", "(", ")", "...", ")", ",", "nil", "\n", "}", "\n", "return", "github", ".", "NewClientWithFields", "(", "fields", ",", "*", "generator", ",", "o", ".", "graphqlEndpoint", ",", "o", ".", "endpoint", ".", "Strings", "(", ")", "...", ")", ",", "nil", "\n", "}"], "docstring": "// GitHubClientWithLogFields returns a GitHub client with extra logging fields", "docstring_tokens": ["GitHubClientWithLogFields", "returns", "a", "GitHub", "client", "with", "extra", "logging", "fields"], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/flagutil/github.go#L92-L111", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "provision/provision.go", "func_name": "Error", "original_string": "func (e *Error) Error() string {\n\tvar err string\n\tif e.Err != nil {\n\t\terr = e.Err.Error() + \": \" + e.Reason\n\t} else {\n\t\terr = e.Reason\n\t}\n\treturn err\n}", "language": "go", "code": "func (e *Error) Error() string {\n\tvar err string\n\tif e.Err != nil {\n\t\terr = e.Err.Error() + \": \" + e.Reason\n\t} else {\n\t\terr = e.Reason\n\t}\n\treturn err\n}", "code_tokens": ["func", "(", "e", "*", "Error", ")", "Error", "(", ")", "string", "{", "var", "err", "string", "\n", "if", "e", ".", "Err", "!=", "nil", "{", "err", "=", "e", ".", "Err", ".", "Error", "(", ")", "+", "\"", "\"", "+", "e", ".", "Reason", "\n", "}", "else", "{", "err", "=", "e", ".", "Reason", "\n", "}", "\n", "return", "err", "\n", "}"], "docstring": "// Error is the string representation of a provisioning error.", "docstring_tokens": ["Error", "is", "the", "string", "representation", "of", "a", "provisioning", "error", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/provision/provision.go#L679-L687", "partition": "test"}
{"repo": "gobuffalo/buffalo", "path": "mail/internal/mail/message.go", "func_name": "SetPartEncoding", "original_string": "func SetPartEncoding(e Encoding) PartSetting {\n\treturn PartSetting(func(p *part) {\n\t\tp.encoding = e\n\t})\n}", "language": "go", "code": "func SetPartEncoding(e Encoding) PartSetting {\n\treturn PartSetting(func(p *part) {\n\t\tp.encoding = e\n\t})\n}", "code_tokens": ["func", "SetPartEncoding", "(", "e", "Encoding", ")", "PartSetting", "{", "return", "PartSetting", "(", "func", "(", "p", "*", "part", ")", "{", "p", ".", "encoding", "=", "e", "\n", "}", ")", "\n", "}"], "docstring": "// SetPartEncoding sets the encoding of the part added to the message. By\n// default, parts use the same encoding than the message.", "docstring_tokens": ["SetPartEncoding", "sets", "the", "encoding", "of", "the", "part", "added", "to", "the", "message", ".", "By", "default", "parts", "use", "the", "same", "encoding", "than", "the", "message", "."], "sha": "7f360181f4ccd79dcc9dcea2c904a4801f194f04", "url": "https://github.com/gobuffalo/buffalo/blob/7f360181f4ccd79dcc9dcea2c904a4801f194f04/mail/internal/mail/message.go#L247-L251", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "influx/writer.go", "func_name": "NewSinglePointWriter", "original_string": "func NewSinglePointWriter(log ttnlog.Interface, w BatchPointsWriter) *SinglePointWriter {\n\treturn &SinglePointWriter{\n\t\tlog:    log,\n\t\twriter: w,\n\t}\n}", "language": "go", "code": "func NewSinglePointWriter(log ttnlog.Interface, w BatchPointsWriter) *SinglePointWriter {\n\treturn &SinglePointWriter{\n\t\tlog:    log,\n\t\twriter: w,\n\t}\n}", "code_tokens": ["func", "NewSinglePointWriter", "(", "log", "ttnlog", ".", "Interface", ",", "w", "BatchPointsWriter", ")", "*", "SinglePointWriter", "{", "return", "&", "SinglePointWriter", "{", "log", ":", "log", ",", "writer", ":", "w", ",", "}", "\n", "}"], "docstring": "// NewSinglePointWriter creates new SinglePointWriter", "docstring_tokens": ["NewSinglePointWriter", "creates", "new", "SinglePointWriter"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/influx/writer.go#L50-L55", "partition": "test"}
{"repo": "kubicorn/kubicorn", "path": "cloud/digitalocean/droplet/resources/firewall.go", "func_name": "Actual", "original_string": "func (r *Firewall) Actual(immutable *cluster.Cluster) (*cluster.Cluster, cloud.Resource, error) {\n\tlogger.Debug(\"firewall.Actual\")\n\n\tnewResource := defaultFirewallStruct()\n\t// Digital Firewalls.Get requires firewall ID, which we will not always have.thats why using List.\n\tfirewalls, _, err := Sdk.Client.Firewalls.List(context.TODO(), &godo.ListOptions{})\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get firwalls info\")\n\t}\n\tfor _, firewall := range firewalls {\n\t\tif firewall.Name == r.Name { // In digitalOcean Firwall names are unique.\n\t\t\t// gotcha get all details from this firewall and populate actual.\n\t\t\tfirewallBytes, err := json.Marshal(firewall)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to marshal DO firewall details err: %v\", err)\n\t\t\t}\n\t\t\tif err := json.Unmarshal(firewallBytes, newResource); err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to unmarhal DO firewall details err: %v\", err)\n\t\t\t}\n\t\t\t// hack: DO api doesn't take \"0\" as portRange, but returns \"0\" for port range in firewall.List.\n\t\t\tfor i := 0; i < len(newResource.OutboundRules); i++ {\n\t\t\t\tif newResource.OutboundRules[i].PortRange == \"0\" {\n\t\t\t\t\tnewResource.OutboundRules[i].PortRange = \"all\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := 0; i < len(newResource.InboundRules); i++ {\n\t\t\t\tif newResource.InboundRules[i].PortRange == \"0\" {\n\t\t\t\t\tnewResource.InboundRules[i].PortRange = \"all\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnewCluster := r.immutableRender(newResource, immutable)\n\treturn newCluster, newResource, nil\n}", "language": "go", "code": "func (r *Firewall) Actual(immutable *cluster.Cluster) (*cluster.Cluster, cloud.Resource, error) {\n\tlogger.Debug(\"firewall.Actual\")\n\n\tnewResource := defaultFirewallStruct()\n\t// Digital Firewalls.Get requires firewall ID, which we will not always have.thats why using List.\n\tfirewalls, _, err := Sdk.Client.Firewalls.List(context.TODO(), &godo.ListOptions{})\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get firwalls info\")\n\t}\n\tfor _, firewall := range firewalls {\n\t\tif firewall.Name == r.Name { // In digitalOcean Firwall names are unique.\n\t\t\t// gotcha get all details from this firewall and populate actual.\n\t\t\tfirewallBytes, err := json.Marshal(firewall)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to marshal DO firewall details err: %v\", err)\n\t\t\t}\n\t\t\tif err := json.Unmarshal(firewallBytes, newResource); err != nil {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"failed to unmarhal DO firewall details err: %v\", err)\n\t\t\t}\n\t\t\t// hack: DO api doesn't take \"0\" as portRange, but returns \"0\" for port range in firewall.List.\n\t\t\tfor i := 0; i < len(newResource.OutboundRules); i++ {\n\t\t\t\tif newResource.OutboundRules[i].PortRange == \"0\" {\n\t\t\t\t\tnewResource.OutboundRules[i].PortRange = \"all\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i := 0; i < len(newResource.InboundRules); i++ {\n\t\t\t\tif newResource.InboundRules[i].PortRange == \"0\" {\n\t\t\t\t\tnewResource.InboundRules[i].PortRange = \"all\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnewCluster := r.immutableRender(newResource, immutable)\n\treturn newCluster, newResource, nil\n}", "code_tokens": ["func", "(", "r", "*", "Firewall", ")", "Actual", "(", "immutable", "*", "cluster", ".", "Cluster", ")", "(", "*", "cluster", ".", "Cluster", ",", "cloud", ".", "Resource", ",", "error", ")", "{", "logger", ".", "Debug", "(", "\"", "\"", ")", "\n\n", "newResource", ":=", "defaultFirewallStruct", "(", ")", "\n", "// Digital Firewalls.Get requires firewall ID, which we will not always have.thats why using List.", "firewalls", ",", "_", ",", "err", ":=", "Sdk", ".", "Client", ".", "Firewalls", ".", "List", "(", "context", ".", "TODO", "(", ")", ",", "&", "godo", ".", "ListOptions", "{", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ")", "\n", "}", "\n", "for", "_", ",", "firewall", ":=", "range", "firewalls", "{", "if", "firewall", ".", "Name", "==", "r", ".", "Name", "{", "// In digitalOcean Firwall names are unique.", "// gotcha get all details from this firewall and populate actual.", "firewallBytes", ",", "err", ":=", "json", ".", "Marshal", "(", "firewall", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "if", "err", ":=", "json", ".", "Unmarshal", "(", "firewallBytes", ",", "newResource", ")", ";", "err", "!=", "nil", "{", "return", "nil", ",", "nil", ",", "fmt", ".", "Errorf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "\n", "// hack: DO api doesn't take \"0\" as portRange, but returns \"0\" for port range in firewall.List.", "for", "i", ":=", "0", ";", "i", "<", "len", "(", "newResource", ".", "OutboundRules", ")", ";", "i", "++", "{", "if", "newResource", ".", "OutboundRules", "[", "i", "]", ".", "PortRange", "==", "\"", "\"", "{", "newResource", ".", "OutboundRules", "[", "i", "]", ".", "PortRange", "=", "\"", "\"", "\n", "}", "\n", "}", "\n", "for", "i", ":=", "0", ";", "i", "<", "len", "(", "newResource", ".", "InboundRules", ")", ";", "i", "++", "{", "if", "newResource", ".", "InboundRules", "[", "i", "]", ".", "PortRange", "==", "\"", "\"", "{", "newResource", ".", "InboundRules", "[", "i", "]", ".", "PortRange", "=", "\"", "\"", "\n", "}", "\n", "}", "\n", "}", "\n", "}", "\n\n", "newCluster", ":=", "r", ".", "immutableRender", "(", "newResource", ",", "immutable", ")", "\n", "return", "newCluster", ",", "newResource", ",", "nil", "\n", "}"], "docstring": "// Actual calls DO firewall Api and returns the actual state of firewall in the cloud.", "docstring_tokens": ["Actual", "calls", "DO", "firewall", "Api", "and", "returns", "the", "actual", "state", "of", "firewall", "in", "the", "cloud", "."], "sha": "c4a4b80994b4333709c0f8164faabd801866b986", "url": "https://github.com/kubicorn/kubicorn/blob/c4a4b80994b4333709c0f8164faabd801866b986/cloud/digitalocean/droplet/resources/firewall.go#L82-L117", "partition": "test"}
{"repo": "TheThingsNetwork/go-utils", "path": "errors/code.go", "func_name": "parseCode", "original_string": "func parseCode(str string) Code {\n\tcode, err := strconv.Atoi(str)\n\tif err != nil {\n\t\treturn Code(0)\n\t}\n\treturn Code(code)\n}", "language": "go", "code": "func parseCode(str string) Code {\n\tcode, err := strconv.Atoi(str)\n\tif err != nil {\n\t\treturn Code(0)\n\t}\n\treturn Code(code)\n}", "code_tokens": ["func", "parseCode", "(", "str", "string", ")", "Code", "{", "code", ",", "err", ":=", "strconv", ".", "Atoi", "(", "str", ")", "\n", "if", "err", "!=", "nil", "{", "return", "Code", "(", "0", ")", "\n", "}", "\n", "return", "Code", "(", "code", ")", "\n", "}"], "docstring": "// pareCode parses a string into a Code or returns 0 if the parse failed", "docstring_tokens": ["pareCode", "parses", "a", "string", "into", "a", "Code", "or", "returns", "0", "if", "the", "parse", "failed"], "sha": "aa2a11bd59104d2a8609328c2b2b55da61826470", "url": "https://github.com/TheThingsNetwork/go-utils/blob/aa2a11bd59104d2a8609328c2b2b55da61826470/errors/code.go#L23-L29", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/hashtree/db.go", "func_name": "Destroy", "original_string": "func (h *dbHashTree) Destroy() error {\n\tpath := h.Path()\n\tif err := h.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(path)\n}", "language": "go", "code": "func (h *dbHashTree) Destroy() error {\n\tpath := h.Path()\n\tif err := h.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(path)\n}", "code_tokens": ["func", "(", "h", "*", "dbHashTree", ")", "Destroy", "(", ")", "error", "{", "path", ":=", "h", ".", "Path", "(", ")", "\n", "if", "err", ":=", "h", ".", "Close", "(", ")", ";", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "return", "os", ".", "Remove", "(", "path", ")", "\n", "}"], "docstring": "// Destroy cleans up the on disk structures for the hashtree.", "docstring_tokens": ["Destroy", "cleans", "up", "the", "on", "disk", "structures", "for", "the", "hashtree", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/hashtree/db.go#L647-L653", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "GetPeers", "original_string": "func (u StellarMessage) GetPeers() (result []PeerAddress, ok bool) {\n\tarmName, _ := u.ArmForSwitch(int32(u.Type))\n\n\tif armName == \"Peers\" {\n\t\tresult = *u.Peers\n\t\tok = true\n\t}\n\n\treturn\n}", "language": "go", "code": "func (u StellarMessage) GetPeers() (result []PeerAddress, ok bool) {\n\tarmName, _ := u.ArmForSwitch(int32(u.Type))\n\n\tif armName == \"Peers\" {\n\t\tresult = *u.Peers\n\t\tok = true\n\t}\n\n\treturn\n}", "code_tokens": ["func", "(", "u", "StellarMessage", ")", "GetPeers", "(", ")", "(", "result", "[", "]", "PeerAddress", ",", "ok", "bool", ")", "{", "armName", ",", "_", ":=", "u", ".", "ArmForSwitch", "(", "int32", "(", "u", ".", "Type", ")", ")", "\n\n", "if", "armName", "==", "\"", "\"", "{", "result", "=", "*", "u", ".", "Peers", "\n", "ok", "=", "true", "\n", "}", "\n\n", "return", "\n", "}"], "docstring": "// GetPeers retrieves the Peers value from the union,\n// returning ok if the union's switch indicated the value is valid.", "docstring_tokens": ["GetPeers", "retrieves", "the", "Peers", "value", "from", "the", "union", "returning", "ok", "if", "the", "union", "s", "switch", "indicated", "the", "value", "is", "valid", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6585-L6594", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "tracing.go", "func_name": "initFromOpenTracing", "original_string": "func (s *injectableSpan) initFromOpenTracing(span opentracing.Span) error {\n\treturn span.Tracer().Inject(span.Context(), zipkinSpanFormat, s)\n}", "language": "go", "code": "func (s *injectableSpan) initFromOpenTracing(span opentracing.Span) error {\n\treturn span.Tracer().Inject(span.Context(), zipkinSpanFormat, s)\n}", "code_tokens": ["func", "(", "s", "*", "injectableSpan", ")", "initFromOpenTracing", "(", "span", "opentracing", ".", "Span", ")", "error", "{", "return", "span", ".", "Tracer", "(", ")", ".", "Inject", "(", "span", ".", "Context", "(", ")", ",", "zipkinSpanFormat", ",", "s", ")", "\n", "}"], "docstring": "// initFromOpenTracing initializes injectableSpan fields from an OpenTracing Span,\n// assuming the tracing implementation supports Zipkin-style span IDs.", "docstring_tokens": ["initFromOpenTracing", "initializes", "injectableSpan", "fields", "from", "an", "OpenTracing", "Span", "assuming", "the", "tracing", "implementation", "supports", "Zipkin", "-", "style", "span", "IDs", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/tracing.go#L114-L116", "partition": "test"}
{"repo": "profitbricks/profitbricks-sdk-go", "path": "volume.go", "func_name": "GetVolume", "original_string": "func (c *Client) GetVolume(dcid string, volumeID string) (*Volume, error) {\n\turl := volumePath(dcid, volumeID) + `?depth=` + c.client.depth\n\tret := &Volume{}\n\terr := c.client.Get(url, ret, http.StatusOK)\n\treturn ret, err\n}", "language": "go", "code": "func (c *Client) GetVolume(dcid string, volumeID string) (*Volume, error) {\n\turl := volumePath(dcid, volumeID) + `?depth=` + c.client.depth\n\tret := &Volume{}\n\terr := c.client.Get(url, ret, http.StatusOK)\n\treturn ret, err\n}", "code_tokens": ["func", "(", "c", "*", "Client", ")", "GetVolume", "(", "dcid", "string", ",", "volumeID", "string", ")", "(", "*", "Volume", ",", "error", ")", "{", "url", ":=", "volumePath", "(", "dcid", ",", "volumeID", ")", "+", "`?depth=`", "+", "c", ".", "client", ".", "depth", "\n", "ret", ":=", "&", "Volume", "{", "}", "\n", "err", ":=", "c", ".", "client", ".", "Get", "(", "url", ",", "ret", ",", "http", ".", "StatusOK", ")", "\n", "return", "ret", ",", "err", "\n", "}"], "docstring": "//GetVolume gets a volume", "docstring_tokens": ["GetVolume", "gets", "a", "volume"], "sha": "1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4", "url": "https://github.com/profitbricks/profitbricks-sdk-go/blob/1d2db5f00bf5dd0b6c29273541c71c60cdf4d4d4/volume.go#L66-L71", "partition": "test"}
{"repo": "golang/appengine", "path": "datastore/datastore.go", "func_name": "keyToReferenceValue", "original_string": "func keyToReferenceValue(defaultAppID string, k *Key) *pb.PropertyValue_ReferenceValue {\n\tref := keyToProto(defaultAppID, k)\n\tpe := make([]*pb.PropertyValue_ReferenceValue_PathElement, len(ref.Path.Element))\n\tfor i, e := range ref.Path.Element {\n\t\tpe[i] = &pb.PropertyValue_ReferenceValue_PathElement{\n\t\t\tType: e.Type,\n\t\t\tId:   e.Id,\n\t\t\tName: e.Name,\n\t\t}\n\t}\n\treturn &pb.PropertyValue_ReferenceValue{\n\t\tApp:         ref.App,\n\t\tNameSpace:   ref.NameSpace,\n\t\tPathelement: pe,\n\t}\n}", "language": "go", "code": "func keyToReferenceValue(defaultAppID string, k *Key) *pb.PropertyValue_ReferenceValue {\n\tref := keyToProto(defaultAppID, k)\n\tpe := make([]*pb.PropertyValue_ReferenceValue_PathElement, len(ref.Path.Element))\n\tfor i, e := range ref.Path.Element {\n\t\tpe[i] = &pb.PropertyValue_ReferenceValue_PathElement{\n\t\t\tType: e.Type,\n\t\t\tId:   e.Id,\n\t\t\tName: e.Name,\n\t\t}\n\t}\n\treturn &pb.PropertyValue_ReferenceValue{\n\t\tApp:         ref.App,\n\t\tNameSpace:   ref.NameSpace,\n\t\tPathelement: pe,\n\t}\n}", "code_tokens": ["func", "keyToReferenceValue", "(", "defaultAppID", "string", ",", "k", "*", "Key", ")", "*", "pb", ".", "PropertyValue_ReferenceValue", "{", "ref", ":=", "keyToProto", "(", "defaultAppID", ",", "k", ")", "\n", "pe", ":=", "make", "(", "[", "]", "*", "pb", ".", "PropertyValue_ReferenceValue_PathElement", ",", "len", "(", "ref", ".", "Path", ".", "Element", ")", ")", "\n", "for", "i", ",", "e", ":=", "range", "ref", ".", "Path", ".", "Element", "{", "pe", "[", "i", "]", "=", "&", "pb", ".", "PropertyValue_ReferenceValue_PathElement", "{", "Type", ":", "e", ".", "Type", ",", "Id", ":", "e", ".", "Id", ",", "Name", ":", "e", ".", "Name", ",", "}", "\n", "}", "\n", "return", "&", "pb", ".", "PropertyValue_ReferenceValue", "{", "App", ":", "ref", ".", "App", ",", "NameSpace", ":", "ref", ".", "NameSpace", ",", "Pathelement", ":", "pe", ",", "}", "\n", "}"], "docstring": "// keyToReferenceValue is the same as keyToProto except the output is a\n// PropertyValue_ReferenceValue instead of a Reference.", "docstring_tokens": ["keyToReferenceValue", "is", "the", "same", "as", "keyToProto", "except", "the", "output", "is", "a", "PropertyValue_ReferenceValue", "instead", "of", "a", "Reference", "."], "sha": "54a98f90d1c46b7731eb8fb305d2a321c30ef610", "url": "https://github.com/golang/appengine/blob/54a98f90d1c46b7731eb8fb305d2a321c30ef610/datastore/datastore.go#L162-L177", "partition": "test"}
{"repo": "pachyderm/pachyderm", "path": "src/server/pkg/cmdutil/cobra.go", "func_name": "Run", "original_string": "func Run(run func(args []string) error) func(*cobra.Command, []string) {\n\treturn func(_ *cobra.Command, args []string) {\n\t\tif err := run(args); err != nil {\n\t\t\tErrorAndExit(err.Error())\n\t\t}\n\t}\n}", "language": "go", "code": "func Run(run func(args []string) error) func(*cobra.Command, []string) {\n\treturn func(_ *cobra.Command, args []string) {\n\t\tif err := run(args); err != nil {\n\t\t\tErrorAndExit(err.Error())\n\t\t}\n\t}\n}", "code_tokens": ["func", "Run", "(", "run", "func", "(", "args", "[", "]", "string", ")", "error", ")", "func", "(", "*", "cobra", ".", "Command", ",", "[", "]", "string", ")", "{", "return", "func", "(", "_", "*", "cobra", ".", "Command", ",", "args", "[", "]", "string", ")", "{", "if", "err", ":=", "run", "(", "args", ")", ";", "err", "!=", "nil", "{", "ErrorAndExit", "(", "err", ".", "Error", "(", ")", ")", "\n", "}", "\n", "}", "\n", "}"], "docstring": "// Run makes a new cobra run function that wraps the given function.", "docstring_tokens": ["Run", "makes", "a", "new", "cobra", "run", "function", "that", "wraps", "the", "given", "function", "."], "sha": "94fb2d536cb6852a77a49e8f777dc9c1bde2c723", "url": "https://github.com/pachyderm/pachyderm/blob/94fb2d536cb6852a77a49e8f777dc9c1bde2c723/src/server/pkg/cmdutil/cobra.go#L45-L51", "partition": "test"}
{"repo": "insionng/martini", "path": "context.go", "func_name": "WriteString", "original_string": "func (ctx *Cotex) WriteString(content string) {\n\tctx.ResponseWriter.Write([]byte(content))\n}", "language": "go", "code": "func (ctx *Cotex) WriteString(content string) {\n\tctx.ResponseWriter.Write([]byte(content))\n}", "code_tokens": ["func", "(", "ctx", "*", "Cotex", ")", "WriteString", "(", "content", "string", ")", "{", "ctx", ".", "ResponseWriter", ".", "Write", "(", "[", "]", "byte", "(", "content", ")", ")", "\n", "}"], "docstring": "// WriteString writes string data into the response object.", "docstring_tokens": ["WriteString", "writes", "string", "data", "into", "the", "response", "object", "."], "sha": "2d0ba5dc75fe9549c10e2f71927803a11e5e4957", "url": "https://github.com/insionng/martini/blob/2d0ba5dc75fe9549c10e2f71927803a11e5e4957/context.go#L75-L77", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "MustNewMaxTxSetSize", "original_string": "func (u LedgerUpgrade) MustNewMaxTxSetSize() Uint32 {\n\tval, ok := u.GetNewMaxTxSetSize()\n\n\tif !ok {\n\t\tpanic(\"arm NewMaxTxSetSize is not set\")\n\t}\n\n\treturn val\n}", "language": "go", "code": "func (u LedgerUpgrade) MustNewMaxTxSetSize() Uint32 {\n\tval, ok := u.GetNewMaxTxSetSize()\n\n\tif !ok {\n\t\tpanic(\"arm NewMaxTxSetSize is not set\")\n\t}\n\n\treturn val\n}", "code_tokens": ["func", "(", "u", "LedgerUpgrade", ")", "MustNewMaxTxSetSize", "(", ")", "Uint32", "{", "val", ",", "ok", ":=", "u", ".", "GetNewMaxTxSetSize", "(", ")", "\n\n", "if", "!", "ok", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "val", "\n", "}"], "docstring": "// MustNewMaxTxSetSize retrieves the NewMaxTxSetSize value from the union,\n// panicing if the value is not set.", "docstring_tokens": ["MustNewMaxTxSetSize", "retrieves", "the", "NewMaxTxSetSize", "value", "from", "the", "union", "panicing", "if", "the", "value", "is", "not", "set", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L4894-L4902", "partition": "test"}
{"repo": "mikespook/possum", "path": "router.go", "func_name": "Find", "original_string": "func (rs *Routers) Find(path string) (url.Values, HandlerFunc, view.View) {\n\tdefer rs.RUnlock()\n\trs.RLock()\n\tif s, ok := rs.s[path]; ok {\n\t\treturn nil, s.h, s.v\n\t}\n\tfor e := rs.l.Front(); e != nil; e = e.Next() {\n\t\ts := e.Value.(struct {\n\t\t\tr router.Router\n\t\t\tv view.View\n\t\t\th HandlerFunc\n\t\t})\n\t\tif params, ok := s.r.Match(path); ok {\n\t\t\treturn params, s.h, s.v\n\t\t}\n\t}\n\treturn nil, nil, nil\n}", "language": "go", "code": "func (rs *Routers) Find(path string) (url.Values, HandlerFunc, view.View) {\n\tdefer rs.RUnlock()\n\trs.RLock()\n\tif s, ok := rs.s[path]; ok {\n\t\treturn nil, s.h, s.v\n\t}\n\tfor e := rs.l.Front(); e != nil; e = e.Next() {\n\t\ts := e.Value.(struct {\n\t\t\tr router.Router\n\t\t\tv view.View\n\t\t\th HandlerFunc\n\t\t})\n\t\tif params, ok := s.r.Match(path); ok {\n\t\t\treturn params, s.h, s.v\n\t\t}\n\t}\n\treturn nil, nil, nil\n}", "code_tokens": ["func", "(", "rs", "*", "Routers", ")", "Find", "(", "path", "string", ")", "(", "url", ".", "Values", ",", "HandlerFunc", ",", "view", ".", "View", ")", "{", "defer", "rs", ".", "RUnlock", "(", ")", "\n", "rs", ".", "RLock", "(", ")", "\n", "if", "s", ",", "ok", ":=", "rs", ".", "s", "[", "path", "]", ";", "ok", "{", "return", "nil", ",", "s", ".", "h", ",", "s", ".", "v", "\n", "}", "\n", "for", "e", ":=", "rs", ".", "l", ".", "Front", "(", ")", ";", "e", "!=", "nil", ";", "e", "=", "e", ".", "Next", "(", ")", "{", "s", ":=", "e", ".", "Value", ".", "(", "struct", "{", "r", "router", ".", "Router", "\n", "v", "view", ".", "View", "\n", "h", "HandlerFunc", "\n", "}", ")", "\n", "if", "params", ",", "ok", ":=", "s", ".", "r", ".", "Match", "(", "path", ")", ";", "ok", "{", "return", "params", ",", "s", ".", "h", ",", "s", ".", "v", "\n", "}", "\n", "}", "\n", "return", "nil", ",", "nil", ",", "nil", "\n", "}"], "docstring": "// Find a router with the specific path and return it.", "docstring_tokens": ["Find", "a", "router", "with", "the", "specific", "path", "and", "return", "it", "."], "sha": "56d7ebb6470b670001632b11be7fc089038f4dd7", "url": "https://github.com/mikespook/possum/blob/56d7ebb6470b670001632b11be7fc089038f4dd7/router.go#L24-L41", "partition": "test"}
{"repo": "justinfx/gofileseq", "path": "ranges/ranges.go", "func_name": "Max", "original_string": "func (r *InclusiveRange) Max() int {\n\tstart := r.Start()\n\tend := r.End()\n\tif start > end {\n\t\treturn start\n\t}\n\treturn end\n}", "language": "go", "code": "func (r *InclusiveRange) Max() int {\n\tstart := r.Start()\n\tend := r.End()\n\tif start > end {\n\t\treturn start\n\t}\n\treturn end\n}", "code_tokens": ["func", "(", "r", "*", "InclusiveRange", ")", "Max", "(", ")", "int", "{", "start", ":=", "r", ".", "Start", "(", ")", "\n", "end", ":=", "r", ".", "End", "(", ")", "\n", "if", "start", ">", "end", "{", "return", "start", "\n", "}", "\n", "return", "end", "\n", "}"], "docstring": "// Max returns the highest value in the range", "docstring_tokens": ["Max", "returns", "the", "highest", "value", "in", "the", "range"], "sha": "2555f296b4493d1825f5f6fab4aa0ff51a8306cd", "url": "https://github.com/justinfx/gofileseq/blob/2555f296b4493d1825f5f6fab4aa0ff51a8306cd/ranges/ranges.go#L171-L178", "partition": "test"}
{"repo": "chromedp/cdproto", "path": "page/page.go", "func_name": "WithWorldName", "original_string": "func (p CreateIsolatedWorldParams) WithWorldName(worldName string) *CreateIsolatedWorldParams {\n\tp.WorldName = worldName\n\treturn &p\n}", "language": "go", "code": "func (p CreateIsolatedWorldParams) WithWorldName(worldName string) *CreateIsolatedWorldParams {\n\tp.WorldName = worldName\n\treturn &p\n}", "code_tokens": ["func", "(", "p", "CreateIsolatedWorldParams", ")", "WithWorldName", "(", "worldName", "string", ")", "*", "CreateIsolatedWorldParams", "{", "p", ".", "WorldName", "=", "worldName", "\n", "return", "&", "p", "\n", "}"], "docstring": "// WithWorldName an optional name which is reported in the Execution Context.", "docstring_tokens": ["WithWorldName", "an", "optional", "name", "which", "is", "reported", "in", "the", "Execution", "Context", "."], "sha": "d40c70bcdf242660a32f2eadf323662dd75378b5", "url": "https://github.com/chromedp/cdproto/blob/d40c70bcdf242660a32f2eadf323662dd75378b5/page/page.go#L217-L220", "partition": "test"}
{"repo": "DamienFontaine/lunarc", "path": "web/server.go", "func_name": "Handle", "original_string": "func (mux *LoggingServeMux) Handle(pattern string, handler http.Handler) {\n\n\tvar log = logrus.New()\n\n\tlogFile, err := os.OpenFile(mux.conf.Log.File+aFilename, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tlog.Out = os.Stderr\n\t\tlog.Warningf(\"Can't open logfile: %v\", err)\n\t} else {\n\t\tlog.Out = logFile\n\t}\n\tmux.serveMux.Handle(pattern, Logging(handler, log))\n}", "language": "go", "code": "func (mux *LoggingServeMux) Handle(pattern string, handler http.Handler) {\n\n\tvar log = logrus.New()\n\n\tlogFile, err := os.OpenFile(mux.conf.Log.File+aFilename, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tlog.Out = os.Stderr\n\t\tlog.Warningf(\"Can't open logfile: %v\", err)\n\t} else {\n\t\tlog.Out = logFile\n\t}\n\tmux.serveMux.Handle(pattern, Logging(handler, log))\n}", "code_tokens": ["func", "(", "mux", "*", "LoggingServeMux", ")", "Handle", "(", "pattern", "string", ",", "handler", "http", ".", "Handler", ")", "{", "var", "log", "=", "logrus", ".", "New", "(", ")", "\n\n", "logFile", ",", "err", ":=", "os", ".", "OpenFile", "(", "mux", ".", "conf", ".", "Log", ".", "File", "+", "aFilename", ",", "os", ".", "O_WRONLY", "|", "os", ".", "O_CREATE", "|", "os", ".", "O_APPEND", ",", "0666", ")", "\n", "if", "err", "!=", "nil", "{", "log", ".", "Out", "=", "os", ".", "Stderr", "\n", "log", ".", "Warningf", "(", "\"", "\"", ",", "err", ")", "\n", "}", "else", "{", "log", ".", "Out", "=", "logFile", "\n", "}", "\n", "mux", ".", "serveMux", ".", "Handle", "(", "pattern", ",", "Logging", "(", "handler", ",", "log", ")", ")", "\n", "}"], "docstring": "//Handle register handler", "docstring_tokens": ["Handle", "register", "handler"], "sha": "2e7332a51f554794a549a313430eaa7dec8d13cc", "url": "https://github.com/DamienFontaine/lunarc/blob/2e7332a51f554794a549a313430eaa7dec8d13cc/web/server.go#L158-L170", "partition": "test"}
{"repo": "uber/tchannel-go", "path": "examples/keyvalue/server/server.go", "func_name": "Get", "original_string": "func (h *kvHandler) Get(ctx thrift.Context, key string) (string, error) {\n\tif err := isValidKey(key); err != nil {\n\t\treturn \"\", err\n\t}\n\n\th.RLock()\n\tdefer h.RUnlock()\n\n\tif val, ok := h.vals[key]; ok {\n\t\treturn val, nil\n\t}\n\n\treturn \"\", &keyvalue.KeyNotFound{Key: key}\n}", "language": "go", "code": "func (h *kvHandler) Get(ctx thrift.Context, key string) (string, error) {\n\tif err := isValidKey(key); err != nil {\n\t\treturn \"\", err\n\t}\n\n\th.RLock()\n\tdefer h.RUnlock()\n\n\tif val, ok := h.vals[key]; ok {\n\t\treturn val, nil\n\t}\n\n\treturn \"\", &keyvalue.KeyNotFound{Key: key}\n}", "code_tokens": ["func", "(", "h", "*", "kvHandler", ")", "Get", "(", "ctx", "thrift", ".", "Context", ",", "key", "string", ")", "(", "string", ",", "error", ")", "{", "if", "err", ":=", "isValidKey", "(", "key", ")", ";", "err", "!=", "nil", "{", "return", "\"", "\"", ",", "err", "\n", "}", "\n\n", "h", ".", "RLock", "(", ")", "\n", "defer", "h", ".", "RUnlock", "(", ")", "\n\n", "if", "val", ",", "ok", ":=", "h", ".", "vals", "[", "key", "]", ";", "ok", "{", "return", "val", ",", "nil", "\n", "}", "\n\n", "return", "\"", "\"", ",", "&", "keyvalue", ".", "KeyNotFound", "{", "Key", ":", "key", "}", "\n", "}"], "docstring": "// Get returns the value stored for the given key.", "docstring_tokens": ["Get", "returns", "the", "value", "stored", "for", "the", "given", "key", "."], "sha": "3c9ced6d946fe2fec6c915703a533e966c09e07a", "url": "https://github.com/uber/tchannel-go/blob/3c9ced6d946fe2fec6c915703a533e966c09e07a/examples/keyvalue/server/server.go#L91-L104", "partition": "test"}
{"repo": "stellar/go-stellar-base", "path": "xdr/xdr_generated.go", "func_name": "MustQSetHash", "original_string": "func (u StellarMessage) MustQSetHash() Uint256 {\n\tval, ok := u.GetQSetHash()\n\n\tif !ok {\n\t\tpanic(\"arm QSetHash is not set\")\n\t}\n\n\treturn val\n}", "language": "go", "code": "func (u StellarMessage) MustQSetHash() Uint256 {\n\tval, ok := u.GetQSetHash()\n\n\tif !ok {\n\t\tpanic(\"arm QSetHash is not set\")\n\t}\n\n\treturn val\n}", "code_tokens": ["func", "(", "u", "StellarMessage", ")", "MustQSetHash", "(", ")", "Uint256", "{", "val", ",", "ok", ":=", "u", ".", "GetQSetHash", "(", ")", "\n\n", "if", "!", "ok", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n\n", "return", "val", "\n", "}"], "docstring": "// MustQSetHash retrieves the QSetHash value from the union,\n// panicing if the value is not set.", "docstring_tokens": ["MustQSetHash", "retrieves", "the", "QSetHash", "value", "from", "the", "union", "panicing", "if", "the", "value", "is", "not", "set", "."], "sha": "79c570612c0b461db178aa8949d9f13cafc2a7c9", "url": "https://github.com/stellar/go-stellar-base/blob/79c570612c0b461db178aa8949d9f13cafc2a7c9/xdr/xdr_generated.go#L6673-L6681", "partition": "test"}
{"repo": "segmentio/objconv", "path": "encode.go", "func_name": "NewEncoder", "original_string": "func NewEncoder(e Emitter) *Encoder {\n\tif e == nil {\n\t\tpanic(\"objconv: the emitter is nil\")\n\t}\n\treturn &Encoder{Emitter: e}\n}", "language": "go", "code": "func NewEncoder(e Emitter) *Encoder {\n\tif e == nil {\n\t\tpanic(\"objconv: the emitter is nil\")\n\t}\n\treturn &Encoder{Emitter: e}\n}", "code_tokens": ["func", "NewEncoder", "(", "e", "Emitter", ")", "*", "Encoder", "{", "if", "e", "==", "nil", "{", "panic", "(", "\"", "\"", ")", "\n", "}", "\n", "return", "&", "Encoder", "{", "Emitter", ":", "e", "}", "\n", "}"], "docstring": "// NewEncoder returns a new encoder that outputs values to e.\n//\n// Encoders created by this function use the default encoder configuration,\n// which is equivalent to using a zero-value EncoderConfig with only the Emitter\n// field set.\n//\n// The function panics if e is nil.", "docstring_tokens": ["NewEncoder", "returns", "a", "new", "encoder", "that", "outputs", "values", "to", "e", ".", "Encoders", "created", "by", "this", "function", "use", "the", "default", "encoder", "configuration", "which", "is", "equivalent", "to", "using", "a", "zero", "-", "value", "EncoderConfig", "with", "only", "the", "Emitter", "field", "set", ".", "The", "function", "panics", "if", "e", "is", "nil", "."], "sha": "7a1d7b8e6f3551b30751e6b2ea6bae500883870e", "url": "https://github.com/segmentio/objconv/blob/7a1d7b8e6f3551b30751e6b2ea6bae500883870e/encode.go#L30-L35", "partition": "test"}
{"repo": "t3rm1n4l/nitro", "path": "skiplist/access_barrier.go", "func_name": "Acquire", "original_string": "func (ab *AccessBarrier) Acquire() *BarrierSession {\n\tif ab.active {\n\tretry:\n\t\tbs := (*BarrierSession)(atomic.LoadPointer(&ab.session))\n\t\tliveCount := atomic.AddInt32(bs.liveCount, 1)\n\t\tif liveCount > barrierFlushOffset {\n\t\t\tab.Release(bs)\n\t\t\tgoto retry\n\t\t}\n\n\t\treturn bs\n\t}\n\n\treturn nil\n}", "language": "go", "code": "func (ab *AccessBarrier) Acquire() *BarrierSession {\n\tif ab.active {\n\tretry:\n\t\tbs := (*BarrierSession)(atomic.LoadPointer(&ab.session))\n\t\tliveCount := atomic.AddInt32(bs.liveCount, 1)\n\t\tif liveCount > barrierFlushOffset {\n\t\t\tab.Release(bs)\n\t\t\tgoto retry\n\t\t}\n\n\t\treturn bs\n\t}\n\n\treturn nil\n}", "code_tokens": ["func", "(", "ab", "*", "AccessBarrier", ")", "Acquire", "(", ")", "*", "BarrierSession", "{", "if", "ab", ".", "active", "{", "retry", ":", "bs", ":=", "(", "*", "BarrierSession", ")", "(", "atomic", ".", "LoadPointer", "(", "&", "ab", ".", "session", ")", ")", "\n", "liveCount", ":=", "atomic", ".", "AddInt32", "(", "bs", ".", "liveCount", ",", "1", ")", "\n", "if", "liveCount", ">", "barrierFlushOffset", "{", "ab", ".", "Release", "(", "bs", ")", "\n", "goto", "retry", "\n", "}", "\n\n", "return", "bs", "\n", "}", "\n\n", "return", "nil", "\n", "}"], "docstring": "// Acquire marks enter of an accessor in the skiplist", "docstring_tokens": ["Acquire", "marks", "enter", "of", "an", "accessor", "in", "the", "skiplist"], "sha": "937fe99f63a01a8bea7661c49e2f3f8af6541d7c", "url": "https://github.com/t3rm1n4l/nitro/blob/937fe99f63a01a8bea7661c49e2f3f8af6541d7c/skiplist/access_barrier.go#L141-L155", "partition": "test"}
{"repo": "etcd-io/etcd", "path": "etcdctl/ctlv3/command/lease_command.go", "func_name": "leaseListCommandFunc", "original_string": "func leaseListCommandFunc(cmd *cobra.Command, args []string) {\n\tresp, rerr := mustClientFromCmd(cmd).Leases(context.TODO())\n\tif rerr != nil {\n\t\tExitWithError(ExitBadConnection, rerr)\n\t}\n\tdisplay.Leases(*resp)\n}", "language": "go", "code": "func leaseListCommandFunc(cmd *cobra.Command, args []string) {\n\tresp, rerr := mustClientFromCmd(cmd).Leases(context.TODO())\n\tif rerr != nil {\n\t\tExitWithError(ExitBadConnection, rerr)\n\t}\n\tdisplay.Leases(*resp)\n}", "code_tokens": ["func", "leaseListCommandFunc", "(", "cmd", "*", "cobra", ".", "Command", ",", "args", "[", "]", "string", ")", "{", "resp", ",", "rerr", ":=", "mustClientFromCmd", "(", "cmd", ")", ".", "Leases", "(", "context", ".", "TODO", "(", ")", ")", "\n", "if", "rerr", "!=", "nil", "{", "ExitWithError", "(", "ExitBadConnection", ",", "rerr", ")", "\n", "}", "\n", "display", ".", "Leases", "(", "*", "resp", ")", "\n", "}"], "docstring": "// leaseListCommandFunc executes the \"lease list\" command.", "docstring_tokens": ["leaseListCommandFunc", "executes", "the", "lease", "list", "command", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdctl/ctlv3/command/lease_command.go#L145-L151", "partition": "test"}
{"repo": "op/go-logging", "path": "logger.go", "func_name": "Infof", "original_string": "func (l *Logger) Infof(format string, args ...interface{}) {\n\tl.log(INFO, &format, args...)\n}", "language": "go", "code": "func (l *Logger) Infof(format string, args ...interface{}) {\n\tl.log(INFO, &format, args...)\n}", "code_tokens": ["func", "(", "l", "*", "Logger", ")", "Infof", "(", "format", "string", ",", "args", "...", "interface", "{", "}", ")", "{", "l", ".", "log", "(", "INFO", ",", "&", "format", ",", "args", "...", ")", "\n", "}"], "docstring": "// Infof logs a message using INFO as log level.", "docstring_tokens": ["Infof", "logs", "a", "message", "using", "INFO", "as", "log", "level", "."], "sha": "970db520ece77730c7e4724c61121037378659d9", "url": "https://github.com/op/go-logging/blob/970db520ece77730c7e4724c61121037378659d9/logger.go#L243-L245", "partition": "test"}
{"repo": "xwb1989/sqlparser", "path": "parsed_query.go", "func_name": "EncodeValue", "original_string": "func EncodeValue(buf *bytes.Buffer, value *querypb.BindVariable) {\n\tif value.Type != querypb.Type_TUPLE {\n\t\t// Since we already check for TUPLE, we don't expect an error.\n\t\tv, _ := sqltypes.BindVariableToValue(value)\n\t\tv.EncodeSQL(buf)\n\t\treturn\n\t}\n\n\t// It's a TUPLE.\n\tbuf.WriteByte('(')\n\tfor i, bv := range value.Values {\n\t\tif i != 0 {\n\t\t\tbuf.WriteString(\", \")\n\t\t}\n\t\tsqltypes.ProtoToValue(bv).EncodeSQL(buf)\n\t}\n\tbuf.WriteByte(')')\n}", "language": "go", "code": "func EncodeValue(buf *bytes.Buffer, value *querypb.BindVariable) {\n\tif value.Type != querypb.Type_TUPLE {\n\t\t// Since we already check for TUPLE, we don't expect an error.\n\t\tv, _ := sqltypes.BindVariableToValue(value)\n\t\tv.EncodeSQL(buf)\n\t\treturn\n\t}\n\n\t// It's a TUPLE.\n\tbuf.WriteByte('(')\n\tfor i, bv := range value.Values {\n\t\tif i != 0 {\n\t\t\tbuf.WriteString(\", \")\n\t\t}\n\t\tsqltypes.ProtoToValue(bv).EncodeSQL(buf)\n\t}\n\tbuf.WriteByte(')')\n}", "code_tokens": ["func", "EncodeValue", "(", "buf", "*", "bytes", ".", "Buffer", ",", "value", "*", "querypb", ".", "BindVariable", ")", "{", "if", "value", ".", "Type", "!=", "querypb", ".", "Type_TUPLE", "{", "// Since we already check for TUPLE, we don't expect an error.", "v", ",", "_", ":=", "sqltypes", ".", "BindVariableToValue", "(", "value", ")", "\n", "v", ".", "EncodeSQL", "(", "buf", ")", "\n", "return", "\n", "}", "\n\n", "// It's a TUPLE.", "buf", ".", "WriteByte", "(", "'('", ")", "\n", "for", "i", ",", "bv", ":=", "range", "value", ".", "Values", "{", "if", "i", "!=", "0", "{", "buf", ".", "WriteString", "(", "\"", "\"", ")", "\n", "}", "\n", "sqltypes", ".", "ProtoToValue", "(", "bv", ")", ".", "EncodeSQL", "(", "buf", ")", "\n", "}", "\n", "buf", ".", "WriteByte", "(", "')'", ")", "\n", "}"], "docstring": "// EncodeValue encodes one bind variable value into the query.", "docstring_tokens": ["EncodeValue", "encodes", "one", "bind", "variable", "value", "into", "the", "query", "."], "sha": "120387863bf27d04bc07db8015110a6e96d0146c", "url": "https://github.com/xwb1989/sqlparser/blob/120387863bf27d04bc07db8015110a6e96d0146c/parsed_query.go#L73-L90", "partition": "test"}
{"repo": "naoina/genmai", "path": "log.go", "func_name": "SetFormat", "original_string": "func (l *templateLogger) SetFormat(format string) error {\n\tl.m.Lock()\n\tdefer l.m.Unlock()\n\tt, err := template.New(\"genmai\").Parse(format)\n\tif err != nil {\n\t\treturn err\n\t}\n\tl.t = t\n\treturn nil\n}", "language": "go", "code": "func (l *templateLogger) SetFormat(format string) error {\n\tl.m.Lock()\n\tdefer l.m.Unlock()\n\tt, err := template.New(\"genmai\").Parse(format)\n\tif err != nil {\n\t\treturn err\n\t}\n\tl.t = t\n\treturn nil\n}", "code_tokens": ["func", "(", "l", "*", "templateLogger", ")", "SetFormat", "(", "format", "string", ")", "error", "{", "l", ".", "m", ".", "Lock", "(", ")", "\n", "defer", "l", ".", "m", ".", "Unlock", "(", ")", "\n", "t", ",", "err", ":=", "template", ".", "New", "(", "\"", "\"", ")", ".", "Parse", "(", "format", ")", "\n", "if", "err", "!=", "nil", "{", "return", "err", "\n", "}", "\n", "l", ".", "t", "=", "t", "\n", "return", "nil", "\n", "}"], "docstring": "// SetFormat sets the format for logging.", "docstring_tokens": ["SetFormat", "sets", "the", "format", "for", "logging", "."], "sha": "78583835e1e41e3938e1ddfffd7101f8ad27fae0", "url": "https://github.com/naoina/genmai/blob/78583835e1e41e3938e1ddfffd7101f8ad27fae0/log.go#L38-L47", "partition": "test"}
{"repo": "tsuru/tsuru", "path": "log/log.go", "func_name": "GetStdLogger", "original_string": "func (t *Target) GetStdLogger() *log.Logger {\n\tt.mut.RLock()\n\tdefer t.mut.RUnlock()\n\tif t.logger != nil {\n\t\treturn t.logger.GetStdLogger()\n\t}\n\treturn nil\n}", "language": "go", "code": "func (t *Target) GetStdLogger() *log.Logger {\n\tt.mut.RLock()\n\tdefer t.mut.RUnlock()\n\tif t.logger != nil {\n\t\treturn t.logger.GetStdLogger()\n\t}\n\treturn nil\n}", "code_tokens": ["func", "(", "t", "*", "Target", ")", "GetStdLogger", "(", ")", "*", "log", ".", "Logger", "{", "t", ".", "mut", ".", "RLock", "(", ")", "\n", "defer", "t", ".", "mut", ".", "RUnlock", "(", ")", "\n", "if", "t", ".", "logger", "!=", "nil", "{", "return", "t", ".", "logger", ".", "GetStdLogger", "(", ")", "\n", "}", "\n", "return", "nil", "\n", "}"], "docstring": "// GetStdLogger returns a standard Logger instance\n// useful for configuring log in external packages.", "docstring_tokens": ["GetStdLogger", "returns", "a", "standard", "Logger", "instance", "useful", "for", "configuring", "log", "in", "external", "packages", "."], "sha": "2f7fd515c5dc25a58aec80f0e497c49e49581b3e", "url": "https://github.com/tsuru/tsuru/blob/2f7fd515c5dc25a58aec80f0e497c49e49581b3e/log/log.go#L145-L152", "partition": "test"}
{"repo": "llgcode/draw2d", "path": "samples/frameimage/frameimage.go", "func_name": "Main", "original_string": "func Main(gc draw2d.GraphicContext, ext string) (string, error) {\n\t// Margin between the image and the frame\n\tconst margin = 30\n\t// Line width od the frame\n\tconst lineWidth = 3\n\n\t// Gopher image\n\tgopher := samples.Resource(\"image\", \"gopher.png\", ext)\n\n\t// Draw gopher\n\terr := Draw(gc, gopher, 297, 210, margin, lineWidth)\n\n\t// Return the output filename\n\treturn samples.Output(\"frameimage\", ext), err\n}", "language": "go", "code": "func Main(gc draw2d.GraphicContext, ext string) (string, error) {\n\t// Margin between the image and the frame\n\tconst margin = 30\n\t// Line width od the frame\n\tconst lineWidth = 3\n\n\t// Gopher image\n\tgopher := samples.Resource(\"image\", \"gopher.png\", ext)\n\n\t// Draw gopher\n\terr := Draw(gc, gopher, 297, 210, margin, lineWidth)\n\n\t// Return the output filename\n\treturn samples.Output(\"frameimage\", ext), err\n}", "code_tokens": ["func", "Main", "(", "gc", "draw2d", ".", "GraphicContext", ",", "ext", "string", ")", "(", "string", ",", "error", ")", "{", "// Margin between the image and the frame", "const", "margin", "=", "30", "\n", "// Line width od the frame", "const", "lineWidth", "=", "3", "\n\n", "// Gopher image", "gopher", ":=", "samples", ".", "Resource", "(", "\"", "\"", ",", "\"", "\"", ",", "ext", ")", "\n\n", "// Draw gopher", "err", ":=", "Draw", "(", "gc", ",", "gopher", ",", "297", ",", "210", ",", "margin", ",", "lineWidth", ")", "\n\n", "// Return the output filename", "return", "samples", ".", "Output", "(", "\"", "\"", ",", "ext", ")", ",", "err", "\n", "}"], "docstring": "// Main draws the image frame and returns the filename.\n// This should only be used during testing.", "docstring_tokens": ["Main", "draws", "the", "image", "frame", "and", "returns", "the", "filename", ".", "This", "should", "only", "be", "used", "during", "testing", "."], "sha": "f52c8a71aff06ab8df41843d33ab167b36c971cd", "url": "https://github.com/llgcode/draw2d/blob/f52c8a71aff06ab8df41843d33ab167b36c971cd/samples/frameimage/frameimage.go#L18-L32", "partition": "test"}
{"repo": "kubernetes/test-infra", "path": "prow/client/informers/externalversions/prowjobs/v1/interface.go", "func_name": "ProwJobs", "original_string": "func (v *version) ProwJobs() ProwJobInformer {\n\treturn &prowJobInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}\n}", "language": "go", "code": "func (v *version) ProwJobs() ProwJobInformer {\n\treturn &prowJobInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}\n}", "code_tokens": ["func", "(", "v", "*", "version", ")", "ProwJobs", "(", ")", "ProwJobInformer", "{", "return", "&", "prowJobInformer", "{", "factory", ":", "v", ".", "factory", ",", "namespace", ":", "v", ".", "namespace", ",", "tweakListOptions", ":", "v", ".", "tweakListOptions", "}", "\n", "}"], "docstring": "// ProwJobs returns a ProwJobInformer.", "docstring_tokens": ["ProwJobs", "returns", "a", "ProwJobInformer", "."], "sha": "8125fbda10178887be5dff9e901d6a0a519b67bc", "url": "https://github.com/kubernetes/test-infra/blob/8125fbda10178887be5dff9e901d6a0a519b67bc/prow/client/informers/externalversions/prowjobs/v1/interface.go#L43-L45", "partition": "test"}
