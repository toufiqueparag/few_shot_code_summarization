public int getAsByteArrayOffset ( ) { if ( position >= length ) return - 1 ; final int begin = position ; final int size = OBinaryProtocol . bytes2int ( buffer , position ) ; position += OBinaryProtocol . SIZE_INT + size ; return begin ; }	<s> Browse the stream but just return the begin of the byte array . This is used to lazy load the information only when needed . </s>
@ Override public void close ( ) { if ( isClosed ( ) ) return ; checkOpenness ( ) ; if ( ownerPool != null && ownerPool . getConnectionsInCurrentThread ( getURL ( ) , userName ) > 1 ) { ownerPool . release ( this ) ; return ; } try { commit ( true ) ; } catch ( Exception e ) { OLogManager . instance ( ) . error ( this , "Error on releasing database '%s' in pool" , e , getName ( ) ) ; } try { callOnCloseListeners ( ) ; } catch ( Exception e ) { OLogManager . instance ( ) . error ( this , "Error on releasing database '%s' in pool" , e , getName ( ) ) ; } getLocalCache ( ) . clear ( ) ; if ( ownerPool != null ) { final ODatabaseDocumentPool localCopy = ownerPool ; ownerPool = null ; localCopy . release ( this ) ; } ODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; }	<s> Avoid to close it but rather release itself to the owner pool . </s>
public Object execute ( final Map < Object , Object > iArgs ) { if ( className == null ) { throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; } final ODatabaseDocument database = getDatabase ( ) ; if ( ifExists && ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) { return true ; } final OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; if ( cls == null ) { return null ; } final long records = cls . count ( true ) ; if ( records > 0 && ! unsafe ) { // NOT EMPTY, CHECK IF CLASS IS OF VERTEX OR EDGES if ( cls . isSubClassOf ( "V" ) ) { // FOUND VERTEX CLASS throw new OCommandExecutionException ( "'DROP CLASS' command cannot drop class '" + className + "' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it" ) ; } else if ( cls . isSubClassOf ( "E" ) ) { // FOUND EDGE CLASS throw new OCommandExecutionException ( "'DROP CLASS' command cannot drop class '" + className + "' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it" ) ; } } database . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; if ( records > 0 && unsafe ) { // NOT EMPTY, CHECK IF CLASS IS OF VERTEX OR EDGES if ( cls . isSubClassOf ( "V" ) ) { // FOUND VERTICES if ( unsafe ) OLogManager . instance ( ) . warn ( this , "Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges" , className , records ) ; } else if ( cls . isSubClassOf ( "E" ) ) { // FOUND EDGES OLogManager . instance ( ) . warn ( this , "Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices" , className , records ) ; } } return true ; }	<s> Execute the DROP CLASS . </s>
@ SuppressWarnings ( "unchecked" ) public boolean result ( final Object iRecord ) { final ODocument record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; if ( isUpdateEdge ( ) && ! isRecordInstanceOf ( iRecord , "E" ) ) { throw new OCommandExecutionException ( "Using UPDATE EDGE on a record that is not an instance of E" ) ; } if ( compiledFilter != null ) { // ADDITIONAL FILTERING if ( ! ( Boolean ) compiledFilter . evaluate ( record , null , context ) ) return false ; } parameters . reset ( ) ; returnHandler . beforeUpdate ( record ) ; boolean updated = handleContent ( record ) ; updated |= handleMerge ( record ) ; updated |= handleSetEntries ( record ) ; updated |= handleIncrementEntries ( record ) ; updated |= handleAddEntries ( record ) ; updated |= handlePutEntries ( record ) ; updated |= handleRemoveEntries ( record ) ; if ( updated ) { handleUpdateEdge ( record ) ; record . setDirty ( ) ; record . save ( ) ; returnHandler . afterUpdate ( record ) ; this . updated = true ; } return true ; }	<s> Update current record . </s>
public boolean result ( final Object iRecord ) { final ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; if ( record instanceof ODocument && compiledFilter != null && ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) { return true ; } try { if ( record . getIdentity ( ) . isValid ( ) ) { if ( returning . equalsIgnoreCase ( "BEFORE" ) ) allDeletedRecords . add ( record ) ; // RESET VERSION TO DISABLE MVCC AVOIDING THE CONCURRENT EXCEPTION IF LOCAL CACHE IS NOT UPDATED //        ORecordInternal.setVersion(record, -1); if ( ! unsafe && record instanceof ODocument ) { // CHECK IF ARE VERTICES OR EDGES final OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; if ( cls != null ) { if ( cls . isSubClassOf ( "V" ) ) // FOUND VERTEX throw new OCommandExecutionException ( "'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it" ) ; else if ( cls . isSubClassOf ( "E" ) ) // FOUND EDGE throw new OCommandExecutionException ( "'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it" ) ; } } record . delete ( ) ; recordCount ++ ; return true ; } return false ; } finally { if ( lockStrategy . equalsIgnoreCase ( "RECORD" ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; } }	<s> Deletes the current record . </s>
public Object execute ( final Map < Object , Object > iArgs ) { if ( recordIds . isEmpty ( ) && subQuery == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; if ( subQuery != null ) { final List < OIdentifiable > result = new OCommandSQL ( subQuery . toString ( ) ) . execute ( ) ; for ( OIdentifiable id : result ) recordIds . ( id . getIdentity ( ) ) ; } return OFindReferenceHelper . findReferences ( recordIds , classList ) ; }	<s> Execute the FIND REFERENCES . </s>
@ Override public ORecordIteratorClusters < REC > last ( ) { if ( clusterIds . length == 0 ) return this ; browsedRecords = 0 ; currentClusterIdx = clusterIds . length - 1 ; updateClusterRange ( ) ; current . setClusterId ( clusterIds [ currentClusterIdx ] ) ; resetCurrentPosition ( ) ; prevPosition ( ) ; final ORecord record = getRecord ( ) ; currentRecord = readCurrentRecord ( record , 0 ) ; if ( currentRecord != null && ! include ( currentRecord ) ) { currentRecord = null ; hasPrevious ( ) ; } return this ; }	<s> Move the iterator to the end of the range . If no range was specified move to the last record of the cluster . </s>
protected boolean parseStrategy ( final String w ) throws OCommandSQLParsingException { if ( ! w . equals ( KEYWORD_STRATEGY ) ) return false ; final String strategyWord = parserNextWord ( true ) ; try { traverse . setStrategy ( OTraverse . STRATEGY . valueOf ( strategyWord . toUpperCase ( Locale . ENGLISH ) ) ) ; } catch ( IllegalArgumentException ignore ) { throwParsingException ( "Invalid " + KEYWORD_STRATEGY + ". Use one between " + Arrays . toString ( OTraverse . STRATEGY . values ( ) ) ) ; } return true ; }	<s> Parses the strategy keyword if found . </s>
public Object execute ( final Map < Object , Object > iArgs ) { if ( type == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; final ODatabaseDocument database = getDatabase ( ) ; final OClassEmbedded sourceClass = ( OClassEmbedded ) database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; if ( sourceClass == null ) throw new OCommandExecutionException ( "Source class '" + className + "' not found" ) ; OPropertyImpl prop = ( OPropertyImpl ) sourceClass . getProperty ( fieldName ) ; if ( prop != null ) { if ( ifNotExists ) { return sourceClass . properties ( ) . size ( ) ; } throw new OCommandExecutionException ( "Property '" + className + "." + fieldName + "' already exists. Remove it before to retry." ) ; } // CREATE THE PROPERTY OClass linkedClass = null ; OType linkedType = null ; if ( linked != null ) { // FIRST SEARCH BETWEEN CLASSES linkedClass = database . getMetadata ( ) . getSchema ( ) . getClass ( linked ) ; if ( linkedClass == null ) // NOT FOUND: SEARCH BETWEEN TYPES linkedType = OType . valueOf ( linked . toUpperCase ( Locale . ENGLISH ) ) ; } // CREATE IT LOCALLY OPropertyImpl internalProp = sourceClass . addPropertyInternal ( fieldName , type , linkedType , linkedClass , unsafe ) ; if ( readonly ) { internalProp . setReadonly ( true ) ; } if ( mandatory ) { internalProp . setMandatory ( true ) ; } if ( notnull ) { internalProp . setNotNull ( true ) ; } if ( max != null ) { internalProp . setMax ( max ) ; } if ( min != null ) { internalProp . setMin ( min ) ; } if ( defaultValue != null ) { internalProp . setDefaultValue ( defaultValue ) ; } return sourceClass . properties ( ) . size ( ) ; }	<s> Execute the CREATE PROPERTY . </s>
public void bindParameters ( final Map < Object , Object > iArgs ) { if ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; for ( int i = 0 ; i < parameterItems . size ( ) ; i ++ ) { OSQLFilterItemParameter value = parameterItems . get ( i ) ; if ( "?" . equals ( value . getName ( ) ) ) { value . setValue ( iArgs . get ( i ) ) ; } else { value . setValue ( iArgs . get ( value . getName ( ) ) ) ; } } }	<s> Binds parameters . </s>
