{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionRealAbstract.java", "func_name": "OTransactionRealAbstract.addIndexEntry", "original_string": "public void addIndexEntry(final OIndex<?> delegate, final String iIndexName, final OTransactionIndexChanges.OPERATION iOperation,\r\n      final Object key, final OIdentifiable iValue, boolean clientTrackOnly) {\r\n    OTransactionIndexChanges indexEntry = indexEntries.get(iIndexName);\r\n    if (indexEntry == null) {\r\n      indexEntry = new OTransactionIndexChanges();\r\n      indexEntries.put(iIndexName, indexEntry);\r\n    }\r\n\r\n    if (iOperation == OPERATION.CLEAR)\r\n      indexEntry.setCleared();\r\n    else {\r\n      OTransactionIndexChangesPerKey changes = indexEntry.getChangesPerKey(key);\r\n      changes.clientTrackOnly = clientTrackOnly;\r\n      changes.add(iValue, iOperation);\r\n\r\n      if (iValue == null)\r\n        return;\r\n\r\n      List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(iValue.getIdentity());\r\n\r\n      if (transactionIndexOperations == null) {\r\n        transactionIndexOperations = new ArrayList<OTransactionRecordIndexOperation>();\r\n        recordIndexOperations.put(iValue.getIdentity().copy(), transactionIndexOperations);\r\n      }\r\n\r\n      transactionIndexOperations.add(new OTransactionRecordIndexOperation(iIndexName, key, iOperation));\r\n    }\r\n  }", "language": "java", "code": "public void addIndexEntry(final OIndex<?> delegate, final String iIndexName, final OTransactionIndexChanges.OPERATION iOperation,\r\n      final Object key, final OIdentifiable iValue, boolean clientTrackOnly) {\r\n    OTransactionIndexChanges indexEntry = indexEntries.get(iIndexName);\r\n    if (indexEntry == null) {\r\n      indexEntry = new OTransactionIndexChanges();\r\n      indexEntries.put(iIndexName, indexEntry);\r\n    }\r\n\r\n    if (iOperation == OPERATION.CLEAR)\r\n      indexEntry.setCleared();\r\n    else {\r\n      OTransactionIndexChangesPerKey changes = indexEntry.getChangesPerKey(key);\r\n      changes.clientTrackOnly = clientTrackOnly;\r\n      changes.add(iValue, iOperation);\r\n\r\n      if (iValue == null)\r\n        return;\r\n\r\n      List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(iValue.getIdentity());\r\n\r\n      if (transactionIndexOperations == null) {\r\n        transactionIndexOperations = new ArrayList<OTransactionRecordIndexOperation>();\r\n        recordIndexOperations.put(iValue.getIdentity().copy(), transactionIndexOperations);\r\n      }\r\n\r\n      transactionIndexOperations.add(new OTransactionRecordIndexOperation(iIndexName, key, iOperation));\r\n    }\r\n  }", "code_tokens": ["public", "void", "addIndexEntry", "(", "final", "OIndex", "<", "?", ">", "delegate", ",", "final", "String", "iIndexName", ",", "final", "OTransactionIndexChanges", ".", "OPERATION", "iOperation", ",", "final", "Object", "key", ",", "final", "OIdentifiable", "iValue", ",", "boolean", "clientTrackOnly", ")", "{", "OTransactionIndexChanges", "indexEntry", "=", "indexEntries", ".", "get", "(", "iIndexName", ")", ";", "if", "(", "indexEntry", "==", "null", ")", "{", "indexEntry", "=", "new", "OTransactionIndexChanges", "(", ")", ";", "indexEntries", ".", "put", "(", "iIndexName", ",", "indexEntry", ")", ";", "}", "if", "(", "iOperation", "==", "OPERATION", ".", "CLEAR", ")", "indexEntry", ".", "setCleared", "(", ")", ";", "else", "{", "OTransactionIndexChangesPerKey", "changes", "=", "indexEntry", ".", "getChangesPerKey", "(", "key", ")", ";", "changes", ".", "clientTrackOnly", "=", "clientTrackOnly", ";", "changes", ".", "add", "(", "iValue", ",", "iOperation", ")", ";", "if", "(", "iValue", "==", "null", ")", "return", ";", "List", "<", "OTransactionRecordIndexOperation", ">", "transactionIndexOperations", "=", "recordIndexOperations", ".", "get", "(", "iValue", ".", "getIdentity", "(", ")", ")", ";", "if", "(", "transactionIndexOperations", "==", "null", ")", "{", "transactionIndexOperations", "=", "new", "ArrayList", "<", "OTransactionRecordIndexOperation", ">", "(", ")", ";", "recordIndexOperations", ".", "put", "(", "iValue", ".", "getIdentity", "(", ")", ".", "copy", "(", ")", ",", "transactionIndexOperations", ")", ";", "}", "transactionIndexOperations", ".", "add", "(", "new", "OTransactionRecordIndexOperation", "(", "iIndexName", ",", "key", ",", "iOperation", ")", ")", ";", "}", "}"], "docstring": "Bufferizes index changes to be flushed at commit time.", "docstring_tokens": ["Bufferizes", "index", "changes", "to", "be", "flushed", "at", "commit", "time", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionRealAbstract.java#L278-L305", "partition": "test", "index": 3075, "time": "2012-05-02 13:24:24"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionRealAbstract.java", "func_name": "OTransactionRealAbstract.getNewRecordEntriesByClusterIds", "original_string": "public List<ORecordOperation> getNewRecordEntriesByClusterIds(final int[] iIds) {\r\n    final List<ORecordOperation> result = new ArrayList<ORecordOperation>();\r\n\r\n    if (iIds == null)\r\n      // RETURN ALL THE RECORDS\r\n      for (ORecordOperation entry : allEntries.values()) {\r\n        if (entry.type == ORecordOperation.CREATED)\r\n          result.add(entry);\r\n      }\r\n    else\r\n      // FILTER RECORDS BY ID\r\n      for (ORecordOperation entry : allEntries.values()) {\r\n        for (int id : iIds) {\r\n          if (entry.getRecord() != null && entry.getRecord().getIdentity().getClusterId() == id\r\n              && entry.type == ORecordOperation.CREATED) {\r\n            result.add(entry);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n    return result;\r\n  }", "language": "java", "code": "public List<ORecordOperation> getNewRecordEntriesByClusterIds(final int[] iIds) {\r\n    final List<ORecordOperation> result = new ArrayList<ORecordOperation>();\r\n\r\n    if (iIds == null)\r\n      // RETURN ALL THE RECORDS\r\n      for (ORecordOperation entry : allEntries.values()) {\r\n        if (entry.type == ORecordOperation.CREATED)\r\n          result.add(entry);\r\n      }\r\n    else\r\n      // FILTER RECORDS BY ID\r\n      for (ORecordOperation entry : allEntries.values()) {\r\n        for (int id : iIds) {\r\n          if (entry.getRecord() != null && entry.getRecord().getIdentity().getClusterId() == id\r\n              && entry.type == ORecordOperation.CREATED) {\r\n            result.add(entry);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n    return result;\r\n  }", "code_tokens": ["public", "List", "<", "ORecordOperation", ">", "getNewRecordEntriesByClusterIds", "(", "final", "int", "[", "]", "iIds", ")", "{", "final", "List", "<", "ORecordOperation", ">", "result", "=", "new", "ArrayList", "<", "ORecordOperation", ">", "(", ")", ";", "if", "(", "iIds", "==", "null", ")", "// RETURN ALL THE RECORDS\r", "for", "(", "ORecordOperation", "entry", ":", "allEntries", ".", "values", "(", ")", ")", "{", "if", "(", "entry", ".", "type", "==", "ORecordOperation", ".", "CREATED", ")", "result", ".", "add", "(", "entry", ")", ";", "}", "else", "// FILTER RECORDS BY ID\r", "for", "(", "ORecordOperation", "entry", ":", "allEntries", ".", "values", "(", ")", ")", "{", "for", "(", "int", "id", ":", "iIds", ")", "{", "if", "(", "entry", ".", "getRecord", "(", ")", "!=", "null", "&&", "entry", ".", "getRecord", "(", ")", ".", "getIdentity", "(", ")", ".", "getClusterId", "(", ")", "==", "id", "&&", "entry", ".", "type", "==", "ORecordOperation", ".", "CREATED", ")", "{", "result", ".", "add", "(", "entry", ")", ";", "break", ";", "}", "}", "}", "return", "result", ";", "}"], "docstring": "Called by cluster iterator.", "docstring_tokens": ["Called", "by", "cluster", "iterator", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionRealAbstract.java#L182-L204", "partition": "test", "index": 3074, "time": "2012-05-02 13:24:24"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionRealAbstract.java", "func_name": "OTransactionRealAbstract.getNewRecordEntriesByClass", "original_string": "public List<ORecordOperation> getNewRecordEntriesByClass(final OClass iClass, final boolean iPolymorphic) {\r\n    final List<ORecordOperation> result = new ArrayList<ORecordOperation>();\r\n\r\n    if (iClass == null)\r\n      // RETURN ALL THE RECORDS\r\n      for (ORecordOperation entry : allEntries.values()) {\r\n        if (entry.type == ORecordOperation.CREATED)\r\n          result.add(entry);\r\n      }\r\n    else {\r\n      // FILTER RECORDS BY CLASSNAME\r\n      for (ORecordOperation entry : allEntries.values()) {\r\n        if (entry.type == ORecordOperation.CREATED)\r\n          if (entry.getRecord() != null && entry.getRecord() instanceof ODocument) {\r\n            if (iPolymorphic) {\r\n              if (iClass.isSuperClassOf(((ODocument) entry.getRecord()).getSchemaClass()))\r\n                result.add(entry);\r\n            } else if (iClass.getName().equals(((ODocument) entry.getRecord()).getClassName()))\r\n              result.add(entry);\r\n          }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }", "language": "java", "code": "public List<ORecordOperation> getNewRecordEntriesByClass(final OClass iClass, final boolean iPolymorphic) {\r\n    final List<ORecordOperation> result = new ArrayList<ORecordOperation>();\r\n\r\n    if (iClass == null)\r\n      // RETURN ALL THE RECORDS\r\n      for (ORecordOperation entry : allEntries.values()) {\r\n        if (entry.type == ORecordOperation.CREATED)\r\n          result.add(entry);\r\n      }\r\n    else {\r\n      // FILTER RECORDS BY CLASSNAME\r\n      for (ORecordOperation entry : allEntries.values()) {\r\n        if (entry.type == ORecordOperation.CREATED)\r\n          if (entry.getRecord() != null && entry.getRecord() instanceof ODocument) {\r\n            if (iPolymorphic) {\r\n              if (iClass.isSuperClassOf(((ODocument) entry.getRecord()).getSchemaClass()))\r\n                result.add(entry);\r\n            } else if (iClass.getName().equals(((ODocument) entry.getRecord()).getClassName()))\r\n              result.add(entry);\r\n          }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }", "code_tokens": ["public", "List", "<", "ORecordOperation", ">", "getNewRecordEntriesByClass", "(", "final", "OClass", "iClass", ",", "final", "boolean", "iPolymorphic", ")", "{", "final", "List", "<", "ORecordOperation", ">", "result", "=", "new", "ArrayList", "<", "ORecordOperation", ">", "(", ")", ";", "if", "(", "iClass", "==", "null", ")", "// RETURN ALL THE RECORDS\r", "for", "(", "ORecordOperation", "entry", ":", "allEntries", ".", "values", "(", ")", ")", "{", "if", "(", "entry", ".", "type", "==", "ORecordOperation", ".", "CREATED", ")", "result", ".", "add", "(", "entry", ")", ";", "}", "else", "{", "// FILTER RECORDS BY CLASSNAME\r", "for", "(", "ORecordOperation", "entry", ":", "allEntries", ".", "values", "(", ")", ")", "{", "if", "(", "entry", ".", "type", "==", "ORecordOperation", ".", "CREATED", ")", "if", "(", "entry", ".", "getRecord", "(", ")", "!=", "null", "&&", "entry", ".", "getRecord", "(", ")", "instanceof", "ODocument", ")", "{", "if", "(", "iPolymorphic", ")", "{", "if", "(", "iClass", ".", "isSuperClassOf", "(", "(", "(", "ODocument", ")", "entry", ".", "getRecord", "(", ")", ")", ".", "getSchemaClass", "(", ")", ")", ")", "result", ".", "add", "(", "entry", ")", ";", "}", "else", "if", "(", "iClass", ".", "getName", "(", ")", ".", "equals", "(", "(", "(", "ODocument", ")", "entry", ".", "getRecord", "(", ")", ")", ".", "getClassName", "(", ")", ")", ")", "result", ".", "add", "(", "entry", ")", ";", "}", "}", "}", "return", "result", ";", "}"], "docstring": "Called by class iterator.", "docstring_tokens": ["Called", "by", "class", "iterator", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionRealAbstract.java#L153-L177", "partition": "test", "index": 3073, "time": "2012-05-02 13:24:24"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyImpl.java", "func_name": "OPropertyImpl.getLinkedClass", "original_string": "public OClass getLinkedClass() {\r\n    acquireSchemaReadLock();\r\n    try {\r\n      if (linkedClass == null && linkedClassName != null)\r\n        linkedClass = owner.owner.getClass(linkedClassName);\r\n      return linkedClass;\r\n    } finally {\r\n      releaseSchemaReadLock();\r\n    }\r\n  }", "language": "java", "code": "public OClass getLinkedClass() {\r\n    acquireSchemaReadLock();\r\n    try {\r\n      if (linkedClass == null && linkedClassName != null)\r\n        linkedClass = owner.owner.getClass(linkedClassName);\r\n      return linkedClass;\r\n    } finally {\r\n      releaseSchemaReadLock();\r\n    }\r\n  }", "code_tokens": ["public", "OClass", "getLinkedClass", "(", ")", "{", "acquireSchemaReadLock", "(", ")", ";", "try", "{", "if", "(", "linkedClass", "==", "null", "&&", "linkedClassName", "!=", "null", ")", "linkedClass", "=", "owner", ".", "owner", ".", "getClass", "(", "linkedClassName", ")", ";", "return", "linkedClass", ";", "}", "finally", "{", "releaseSchemaReadLock", "(", ")", ";", "}", "}"], "docstring": "Returns the linked class in lazy mode because while unmarshalling the class could be not loaded yet.\n\n@return", "docstring_tokens": ["Returns", "the", "linked", "class", "in", "lazy", "mode", "because", "while", "unmarshalling", "the", "class", "could", "be", "not", "loaded", "yet", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyImpl.java#L280-L289", "partition": "test", "index": 3026, "time": "2012-05-02 18:34:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyImpl.java", "func_name": "OPropertyImpl.dropIndexes", "original_string": "@Deprecated\r\n  public OPropertyImpl dropIndexes() {\r\n    getDatabase().checkSecurity(ORule.ResourceGeneric.SCHEMA, ORole.PERMISSION_DELETE);\r\n\r\n    acquireSchemaReadLock();\r\n    try {\r\n      final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();\r\n\r\n      final ArrayList<OIndex<?>> relatedIndexes = new ArrayList<OIndex<?>>();\r\n      for (final OIndex<?> index : indexManager.getClassIndexes(owner.getName())) {\r\n        final OIndexDefinition definition = index.getDefinition();\r\n\r\n        if (OCollections.indexOf(definition.getFields(), globalRef.getName(), new OCaseInsentiveComparator()) > -1) {\r\n          if (definition instanceof OPropertyIndexDefinition) {\r\n            relatedIndexes.add(index);\r\n          } else {\r\n            throw new IllegalArgumentException(\r\n                \"This operation applicable only for property indexes. \" + index.getName() + \" is \" + index.getDefinition());\r\n          }\r\n        }\r\n      }\r\n\r\n      for (final OIndex<?> index : relatedIndexes)\r\n        getDatabase().getMetadata().getIndexManager().dropIndex(index.getName());\r\n\r\n      return this;\r\n    } finally {\r\n      releaseSchemaReadLock();\r\n    }\r\n  }", "language": "java", "code": "@Deprecated\r\n  public OPropertyImpl dropIndexes() {\r\n    getDatabase().checkSecurity(ORule.ResourceGeneric.SCHEMA, ORole.PERMISSION_DELETE);\r\n\r\n    acquireSchemaReadLock();\r\n    try {\r\n      final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();\r\n\r\n      final ArrayList<OIndex<?>> relatedIndexes = new ArrayList<OIndex<?>>();\r\n      for (final OIndex<?> index : indexManager.getClassIndexes(owner.getName())) {\r\n        final OIndexDefinition definition = index.getDefinition();\r\n\r\n        if (OCollections.indexOf(definition.getFields(), globalRef.getName(), new OCaseInsentiveComparator()) > -1) {\r\n          if (definition instanceof OPropertyIndexDefinition) {\r\n            relatedIndexes.add(index);\r\n          } else {\r\n            throw new IllegalArgumentException(\r\n                \"This operation applicable only for property indexes. \" + index.getName() + \" is \" + index.getDefinition());\r\n          }\r\n        }\r\n      }\r\n\r\n      for (final OIndex<?> index : relatedIndexes)\r\n        getDatabase().getMetadata().getIndexManager().dropIndex(index.getName());\r\n\r\n      return this;\r\n    } finally {\r\n      releaseSchemaReadLock();\r\n    }\r\n  }", "code_tokens": ["@", "Deprecated", "public", "OPropertyImpl", "dropIndexes", "(", ")", "{", "getDatabase", "(", ")", ".", "checkSecurity", "(", "ORule", ".", "ResourceGeneric", ".", "SCHEMA", ",", "ORole", ".", "PERMISSION_DELETE", ")", ";", "acquireSchemaReadLock", "(", ")", ";", "try", "{", "final", "OIndexManager", "indexManager", "=", "getDatabase", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ";", "final", "ArrayList", "<", "OIndex", "<", "?", ">", ">", "relatedIndexes", "=", "new", "ArrayList", "<", "OIndex", "<", "?", ">", ">", "(", ")", ";", "for", "(", "final", "OIndex", "<", "?", ">", "index", ":", "indexManager", ".", "getClassIndexes", "(", "owner", ".", "getName", "(", ")", ")", ")", "{", "final", "OIndexDefinition", "definition", "=", "index", ".", "getDefinition", "(", ")", ";", "if", "(", "OCollections", ".", "indexOf", "(", "definition", ".", "getFields", "(", ")", ",", "globalRef", ".", "getName", "(", ")", ",", "new", "OCaseInsentiveComparator", "(", ")", ")", ">", "-", "1", ")", "{", "if", "(", "definition", "instanceof", "OPropertyIndexDefinition", ")", "{", "relatedIndexes", ".", "add", "(", "index", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"This operation applicable only for property indexes. \"", "+", "index", ".", "getName", "(", ")", "+", "\" is \"", "+", "index", ".", "getDefinition", "(", ")", ")", ";", "}", "}", "}", "for", "(", "final", "OIndex", "<", "?", ">", "index", ":", "relatedIndexes", ")", "getDatabase", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ".", "dropIndex", "(", "index", ".", "getName", "(", ")", ")", ";", "return", "this", ";", "}", "finally", "{", "releaseSchemaReadLock", "(", ")", ";", "}", "}"], "docstring": "Remove the index on property\n\n@deprecated Use {@link OIndexManager#dropIndex(String)} instead.", "docstring_tokens": ["Remove", "the", "index", "on", "property"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyImpl.java#L186-L215", "partition": "test", "index": 3024, "time": "2012-05-02 18:34:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyImpl.java", "func_name": "OPropertyImpl.createIndex", "original_string": "public OIndex<?> createIndex(final String iType) {\r\n    acquireSchemaReadLock();\r\n    try {\r\n      return owner.createIndex(getFullName(), iType, globalRef.getName());\r\n    } finally {\r\n      releaseSchemaReadLock();\r\n    }\r\n  }", "language": "java", "code": "public OIndex<?> createIndex(final String iType) {\r\n    acquireSchemaReadLock();\r\n    try {\r\n      return owner.createIndex(getFullName(), iType, globalRef.getName());\r\n    } finally {\r\n      releaseSchemaReadLock();\r\n    }\r\n  }", "code_tokens": ["public", "OIndex", "<", "?", ">", "createIndex", "(", "final", "String", "iType", ")", "{", "acquireSchemaReadLock", "(", ")", ";", "try", "{", "return", "owner", ".", "createIndex", "(", "getFullName", "(", ")", ",", "iType", ",", "globalRef", ".", "getName", "(", ")", ")", ";", "}", "finally", "{", "releaseSchemaReadLock", "(", ")", ";", "}", "}"], "docstring": "Creates an index on this property. Indexes speed up queries but slow down insert and update operations. For massive inserts we\nsuggest to remove the index, make the massive insert and recreate it.\n\n@param iType\n\n@return\n\n@see {@link OClass#createIndex(String, OClass.INDEX_TYPE, String...)} instead.", "docstring_tokens": ["Creates", "an", "index", "on", "this", "property", ".", "Indexes", "speed", "up", "queries", "but", "slow", "down", "insert", "and", "update", "operations", ".", "For", "massive", "inserts", "we", "suggest", "to", "remove", "the", "index", "make", "the", "massive", "insert", "and", "recreate", "it", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyImpl.java#L157-L164", "partition": "test", "index": 3023, "time": "2012-05-02 18:34:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyImpl.java", "func_name": "OPropertyImpl.getIndex", "original_string": "@Deprecated\r\n  public OIndex<?> getIndex() {\r\n    acquireSchemaReadLock();\r\n    try {\r\n      Set<OIndex<?>> indexes = owner.getInvolvedIndexes(globalRef.getName());\r\n      if (indexes != null && !indexes.isEmpty())\r\n        return indexes.iterator().next();\r\n      return null;\r\n    } finally {\r\n      releaseSchemaReadLock();\r\n    }\r\n  }", "language": "java", "code": "@Deprecated\r\n  public OIndex<?> getIndex() {\r\n    acquireSchemaReadLock();\r\n    try {\r\n      Set<OIndex<?>> indexes = owner.getInvolvedIndexes(globalRef.getName());\r\n      if (indexes != null && !indexes.isEmpty())\r\n        return indexes.iterator().next();\r\n      return null;\r\n    } finally {\r\n      releaseSchemaReadLock();\r\n    }\r\n  }", "code_tokens": ["@", "Deprecated", "public", "OIndex", "<", "?", ">", "getIndex", "(", ")", "{", "acquireSchemaReadLock", "(", ")", ";", "try", "{", "Set", "<", "OIndex", "<", "?", ">", ">", "indexes", "=", "owner", ".", "getInvolvedIndexes", "(", "globalRef", ".", "getName", "(", ")", ")", ";", "if", "(", "indexes", "!=", "null", "&&", "!", "indexes", ".", "isEmpty", "(", ")", ")", "return", "indexes", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "return", "null", ";", "}", "finally", "{", "releaseSchemaReadLock", "(", ")", ";", "}", "}"], "docstring": "Returns the first index defined for the property.\n\n@deprecated Use {@link OClass#getInvolvedIndexes(String...)} instead.", "docstring_tokens": ["Returns", "the", "first", "index", "defined", "for", "the", "property", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyImpl.java#L232-L243", "partition": "test", "index": 3025, "time": "2012-05-02 18:34:38"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java", "func_name": "OServerAdmin.listDatabases", "original_string": "@Deprecated\r\n  public synchronized Map<String, String> listDatabases() throws IOException {\r\n    OListDatabasesRequest request = new OListDatabasesRequest();\r\n    OListDatabasesResponse response = networkAdminOperation(request, \"Cannot retrieve the configuration list\");\r\n    return response.getDatabases();\r\n  }", "language": "java", "code": "@Deprecated\r\n  public synchronized Map<String, String> listDatabases() throws IOException {\r\n    OListDatabasesRequest request = new OListDatabasesRequest();\r\n    OListDatabasesResponse response = networkAdminOperation(request, \"Cannot retrieve the configuration list\");\r\n    return response.getDatabases();\r\n  }", "code_tokens": ["@", "Deprecated", "public", "synchronized", "Map", "<", "String", ",", "String", ">", "listDatabases", "(", ")", "throws", "IOException", "{", "OListDatabasesRequest", "request", "=", "new", "OListDatabasesRequest", "(", ")", ";", "OListDatabasesResponse", "response", "=", "networkAdminOperation", "(", "request", ",", "\"Cannot retrieve the configuration list\"", ")", ";", "return", "response", ".", "getDatabases", "(", ")", ";", "}"], "docstring": "Returns the list of databases on the connected remote server.\n\n@throws IOException", "docstring_tokens": ["Returns", "the", "list", "of", "databases", "on", "the", "connected", "remote", "server", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java#L152-L157", "partition": "test", "index": 3222, "time": "2012-05-07 16:36:35"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java", "func_name": "OServerAdmin.connect", "original_string": "@Deprecated\r\n  public synchronized OServerAdmin connect(final String iUserName, final String iUserPassword) throws IOException {\r\n    final String username;\r\n    final String password;\r\n\r\n    OCredentialInterceptor ci = OSecurityManager.instance().newCredentialInterceptor();\r\n\r\n    if (ci != null) {\r\n      ci.intercept(storage.getURL(), iUserName, iUserPassword);\r\n      username = ci.getUsername();\r\n      password = ci.getPassword();\r\n    } else {\r\n      username = iUserName;\r\n      password = iUserPassword;\r\n    }\r\n    OConnect37Request request = new OConnect37Request(username, password);\r\n\r\n    networkAdminOperation((network, session) -> {\r\n      OStorageRemoteNodeSession nodeSession = session.getOrCreateServerSession(network.getServerURL());\r\n      try {\r\n        network.beginRequest(request.getCommand(), session);\r\n        request.write(network, session);\r\n      } finally {\r\n        network.endRequest();\r\n      }\r\n      OConnectResponse response = request.createResponse();\r\n      try {\r\n        network.beginResponse(nodeSession.getSessionId(), true);\r\n        response.read(network, session);\r\n      } finally {\r\n        storage.endResponse(network);\r\n      }\r\n      return null;\r\n    }, \"Cannot connect to the remote server/database '\" + storage.getURL() + \"'\");\r\n\r\n    return this;\r\n  }", "language": "java", "code": "@Deprecated\r\n  public synchronized OServerAdmin connect(final String iUserName, final String iUserPassword) throws IOException {\r\n    final String username;\r\n    final String password;\r\n\r\n    OCredentialInterceptor ci = OSecurityManager.instance().newCredentialInterceptor();\r\n\r\n    if (ci != null) {\r\n      ci.intercept(storage.getURL(), iUserName, iUserPassword);\r\n      username = ci.getUsername();\r\n      password = ci.getPassword();\r\n    } else {\r\n      username = iUserName;\r\n      password = iUserPassword;\r\n    }\r\n    OConnect37Request request = new OConnect37Request(username, password);\r\n\r\n    networkAdminOperation((network, session) -> {\r\n      OStorageRemoteNodeSession nodeSession = session.getOrCreateServerSession(network.getServerURL());\r\n      try {\r\n        network.beginRequest(request.getCommand(), session);\r\n        request.write(network, session);\r\n      } finally {\r\n        network.endRequest();\r\n      }\r\n      OConnectResponse response = request.createResponse();\r\n      try {\r\n        network.beginResponse(nodeSession.getSessionId(), true);\r\n        response.read(network, session);\r\n      } finally {\r\n        storage.endResponse(network);\r\n      }\r\n      return null;\r\n    }, \"Cannot connect to the remote server/database '\" + storage.getURL() + \"'\");\r\n\r\n    return this;\r\n  }", "code_tokens": ["@", "Deprecated", "public", "synchronized", "OServerAdmin", "connect", "(", "final", "String", "iUserName", ",", "final", "String", "iUserPassword", ")", "throws", "IOException", "{", "final", "String", "username", ";", "final", "String", "password", ";", "OCredentialInterceptor", "ci", "=", "OSecurityManager", ".", "instance", "(", ")", ".", "newCredentialInterceptor", "(", ")", ";", "if", "(", "ci", "!=", "null", ")", "{", "ci", ".", "intercept", "(", "storage", ".", "getURL", "(", ")", ",", "iUserName", ",", "iUserPassword", ")", ";", "username", "=", "ci", ".", "getUsername", "(", ")", ";", "password", "=", "ci", ".", "getPassword", "(", ")", ";", "}", "else", "{", "username", "=", "iUserName", ";", "password", "=", "iUserPassword", ";", "}", "OConnect37Request", "request", "=", "new", "OConnect37Request", "(", "username", ",", "password", ")", ";", "networkAdminOperation", "(", "(", "network", ",", "session", ")", "->", "{", "OStorageRemoteNodeSession", "nodeSession", "=", "session", ".", "getOrCreateServerSession", "(", "network", ".", "getServerURL", "(", ")", ")", ";", "try", "{", "network", ".", "beginRequest", "(", "request", ".", "getCommand", "(", ")", ",", "session", ")", ";", "request", ".", "write", "(", "network", ",", "session", ")", ";", "}", "finally", "{", "network", ".", "endRequest", "(", ")", ";", "}", "OConnectResponse", "response", "=", "request", ".", "createResponse", "(", ")", ";", "try", "{", "network", ".", "beginResponse", "(", "nodeSession", ".", "getSessionId", "(", ")", ",", "true", ")", ";", "response", ".", "read", "(", "network", ",", "session", ")", ";", "}", "finally", "{", "storage", ".", "endResponse", "(", "network", ")", ";", "}", "return", "null", ";", "}", ",", "\"Cannot connect to the remote server/database '\"", "+", "storage", ".", "getURL", "(", ")", "+", "\"'\"", ")", ";", "return", "this", ";", "}"], "docstring": "Connects to a remote server.\n\n@param iUserName     Server's user name\n@param iUserPassword Server's password for the user name used\n\n@return The instance itself. Useful to execute method in chain\n\n@throws IOException", "docstring_tokens": ["Connects", "to", "a", "remote", "server", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java#L109-L145", "partition": "test", "index": 3221, "time": "2012-05-07 16:36:35"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java", "func_name": "OServerAdmin.clusterStatus", "original_string": "public ODocument clusterStatus() {\r\n\r\n    ODistributedStatusRequest request = new ODistributedStatusRequest();\r\n\r\n    ODistributedStatusResponse response = storage.networkOperation(request, \"Error on executing Cluster status \");\r\n\r\n    OLogManager.instance().debug(this, \"Cluster status %s\", response.getClusterConfig().toJSON(\"prettyPrint\"));\r\n    return response.getClusterConfig();\r\n  }", "language": "java", "code": "public ODocument clusterStatus() {\r\n\r\n    ODistributedStatusRequest request = new ODistributedStatusRequest();\r\n\r\n    ODistributedStatusResponse response = storage.networkOperation(request, \"Error on executing Cluster status \");\r\n\r\n    OLogManager.instance().debug(this, \"Cluster status %s\", response.getClusterConfig().toJSON(\"prettyPrint\"));\r\n    return response.getClusterConfig();\r\n  }", "code_tokens": ["public", "ODocument", "clusterStatus", "(", ")", "{", "ODistributedStatusRequest", "request", "=", "new", "ODistributedStatusRequest", "(", ")", ";", "ODistributedStatusResponse", "response", "=", "storage", ".", "networkOperation", "(", "request", ",", "\"Error on executing Cluster status \"", ")", ";", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Cluster status %s\"", ",", "response", ".", "getClusterConfig", "(", ")", ".", "toJSON", "(", "\"prettyPrint\"", ")", ")", ";", "return", "response", ".", "getClusterConfig", "(", ")", ";", "}"], "docstring": "Gets the cluster status.\n\n@return the JSON containing the current cluster structure", "docstring_tokens": ["Gets", "the", "cluster", "status", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java#L376-L384", "partition": "test", "index": 3228, "time": "2012-05-07 16:36:35"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java", "func_name": "OServerAdmin.existsDatabase", "original_string": "public synchronized boolean existsDatabase(final String iDatabaseName, final String storageType) throws IOException {\r\n    OExistsDatabaseRequest request = new OExistsDatabaseRequest(iDatabaseName, storageType);\r\n    OExistsDatabaseResponse response = networkAdminOperation(request,\r\n        \"Error on checking existence of the remote storage: \" + storage.getName());\r\n    return response.isExists();\r\n\r\n  }", "language": "java", "code": "public synchronized boolean existsDatabase(final String iDatabaseName, final String storageType) throws IOException {\r\n    OExistsDatabaseRequest request = new OExistsDatabaseRequest(iDatabaseName, storageType);\r\n    OExistsDatabaseResponse response = networkAdminOperation(request,\r\n        \"Error on checking existence of the remote storage: \" + storage.getName());\r\n    return response.isExists();\r\n\r\n  }", "code_tokens": ["public", "synchronized", "boolean", "existsDatabase", "(", "final", "String", "iDatabaseName", ",", "final", "String", "storageType", ")", "throws", "IOException", "{", "OExistsDatabaseRequest", "request", "=", "new", "OExistsDatabaseRequest", "(", "iDatabaseName", ",", "storageType", ")", ";", "OExistsDatabaseResponse", "response", "=", "networkAdminOperation", "(", "request", ",", "\"Error on checking existence of the remote storage: \"", "+", "storage", ".", "getName", "(", ")", ")", ";", "return", "response", ".", "isExists", "(", ")", ";", "}"], "docstring": "Checks if a database exists in the remote server.\n\n@param iDatabaseName The database name\n@param storageType   Storage type between \"plocal\" or \"memory\".\n\n@return true if exists, otherwise false\n\n@throws IOException", "docstring_tokens": ["Checks", "if", "a", "database", "exists", "in", "the", "remote", "server", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java#L262-L268", "partition": "test", "index": 3224, "time": "2012-05-07 16:36:35"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java", "func_name": "OServerAdmin.freezeDatabase", "original_string": "public synchronized OServerAdmin freezeDatabase(final String storageType) throws IOException {\r\n\r\n    OFreezeDatabaseRequest request = new OFreezeDatabaseRequest(storage.getName(), storageType);\r\n    OFreezeDatabaseResponse response = networkAdminOperation(request, \"Cannot freeze the remote storage: \" + storage.getName());\r\n\r\n    return this;\r\n  }", "language": "java", "code": "public synchronized OServerAdmin freezeDatabase(final String storageType) throws IOException {\r\n\r\n    OFreezeDatabaseRequest request = new OFreezeDatabaseRequest(storage.getName(), storageType);\r\n    OFreezeDatabaseResponse response = networkAdminOperation(request, \"Cannot freeze the remote storage: \" + storage.getName());\r\n\r\n    return this;\r\n  }", "code_tokens": ["public", "synchronized", "OServerAdmin", "freezeDatabase", "(", "final", "String", "storageType", ")", "throws", "IOException", "{", "OFreezeDatabaseRequest", "request", "=", "new", "OFreezeDatabaseRequest", "(", "storage", ".", "getName", "(", ")", ",", "storageType", ")", ";", "OFreezeDatabaseResponse", "response", "=", "networkAdminOperation", "(", "request", ",", "\"Cannot freeze the remote storage: \"", "+", "storage", ".", "getName", "(", ")", ")", ";", "return", "this", ";", "}"], "docstring": "Freezes the database by locking it in exclusive mode.\n\n@param storageType Storage type between \"plocal\" or \"memory\".\n\n@return\n\n@throws IOException\n@see #releaseDatabase(String)", "docstring_tokens": ["Freezes", "the", "database", "by", "locking", "it", "in", "exclusive", "mode", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java#L345-L351", "partition": "test", "index": 3226, "time": "2012-05-07 16:36:35"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/cache/OAbstractRecordCache.java", "func_name": "OAbstractRecordCache.shutdown", "original_string": "public void shutdown() {\r\n    underlying.shutdown();\r\n\r\n    if (Orient.instance().getProfiler() != null) {\r\n      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + \"enabled\");\r\n      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + \"current\");\r\n      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + \"max\");\r\n    }\r\n  }", "language": "java", "code": "public void shutdown() {\r\n    underlying.shutdown();\r\n\r\n    if (Orient.instance().getProfiler() != null) {\r\n      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + \"enabled\");\r\n      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + \"current\");\r\n      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + \"max\");\r\n    }\r\n  }", "code_tokens": ["public", "void", "shutdown", "(", ")", "{", "underlying", ".", "shutdown", "(", ")", ";", "if", "(", "Orient", ".", "instance", "(", ")", ".", "getProfiler", "(", ")", "!=", "null", ")", "{", "Orient", ".", "instance", "(", ")", ".", "getProfiler", "(", ")", ".", "unregisterHookValue", "(", "profilerPrefix", "+", "\"enabled\"", ")", ";", "Orient", ".", "instance", "(", ")", ".", "getProfiler", "(", ")", ".", "unregisterHookValue", "(", "profilerPrefix", "+", "\"current\"", ")", ";", "Orient", ".", "instance", "(", ")", ".", "getProfiler", "(", ")", ".", "unregisterHookValue", "(", "profilerPrefix", "+", "\"max\"", ")", ";", "}", "}"], "docstring": "All operations running at cache destruction stage", "docstring_tokens": ["All", "operations", "running", "at", "cache", "destruction", "stage"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/cache/OAbstractRecordCache.java#L150-L158", "partition": "test", "index": 3014, "time": "2012-05-08 06:51:15"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/cache/OAbstractRecordCache.java", "func_name": "OAbstractRecordCache.startup", "original_string": "public void startup() {\r\n    underlying.startup();\r\n\r\n    Orient.instance().getProfiler()\r\n        .registerHookValue(profilerPrefix + \"current\", \"Number of entries in cache\", METRIC_TYPE.SIZE, new OProfilerHookValue() {\r\n          public Object getValue() {\r\n            return getSize();\r\n          }\r\n        }, profilerMetadataPrefix + \"current\");\r\n\r\n  }", "language": "java", "code": "public void startup() {\r\n    underlying.startup();\r\n\r\n    Orient.instance().getProfiler()\r\n        .registerHookValue(profilerPrefix + \"current\", \"Number of entries in cache\", METRIC_TYPE.SIZE, new OProfilerHookValue() {\r\n          public Object getValue() {\r\n            return getSize();\r\n          }\r\n        }, profilerMetadataPrefix + \"current\");\r\n\r\n  }", "code_tokens": ["public", "void", "startup", "(", ")", "{", "underlying", ".", "startup", "(", ")", ";", "Orient", ".", "instance", "(", ")", ".", "getProfiler", "(", ")", ".", "registerHookValue", "(", "profilerPrefix", "+", "\"current\"", ",", "\"Number of entries in cache\"", ",", "METRIC_TYPE", ".", "SIZE", ",", "new", "OProfilerHookValue", "(", ")", "{", "public", "Object", "getValue", "(", ")", "{", "return", "getSize", "(", ")", ";", "}", "}", ",", "profilerMetadataPrefix", "+", "\"current\"", ")", ";", "}"], "docstring": "All operations running at cache initialization stage", "docstring_tokens": ["All", "operations", "running", "at", "cache", "initialization", "stage"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/cache/OAbstractRecordCache.java#L135-L145", "partition": "test", "index": 3013, "time": "2012-05-08 06:51:15"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/cache/OAbstractRecordCache.java", "func_name": "OAbstractRecordCache.freeCluster", "original_string": "public void freeCluster(final int cid) {\r\n    final Set<ORID> toRemove = new HashSet<ORID>(underlying.size() / 2);\r\n\r\n    final Set<ORID> keys = new HashSet<ORID>(underlying.keys());\r\n    for (final ORID id : keys)\r\n      if (id.getClusterId() == cid)\r\n        toRemove.add(id);\r\n\r\n    for (final ORID ridToRemove : toRemove)\r\n      underlying.remove(ridToRemove);\r\n  }", "language": "java", "code": "public void freeCluster(final int cid) {\r\n    final Set<ORID> toRemove = new HashSet<ORID>(underlying.size() / 2);\r\n\r\n    final Set<ORID> keys = new HashSet<ORID>(underlying.keys());\r\n    for (final ORID id : keys)\r\n      if (id.getClusterId() == cid)\r\n        toRemove.add(id);\r\n\r\n    for (final ORID ridToRemove : toRemove)\r\n      underlying.remove(ridToRemove);\r\n  }", "code_tokens": ["public", "void", "freeCluster", "(", "final", "int", "cid", ")", "{", "final", "Set", "<", "ORID", ">", "toRemove", "=", "new", "HashSet", "<", "ORID", ">", "(", "underlying", ".", "size", "(", ")", "/", "2", ")", ";", "final", "Set", "<", "ORID", ">", "keys", "=", "new", "HashSet", "<", "ORID", ">", "(", "underlying", ".", "keys", "(", ")", ")", ";", "for", "(", "final", "ORID", "id", ":", "keys", ")", "if", "(", "id", ".", "getClusterId", "(", ")", "==", "cid", ")", "toRemove", ".", "add", "(", "id", ")", ";", "for", "(", "final", "ORID", "ridToRemove", ":", "toRemove", ")", "underlying", ".", "remove", "(", "ridToRemove", ")", ";", "}"], "docstring": "Remove all records belonging to specified cluster\n\n@param cid\nidentifier of cluster", "docstring_tokens": ["Remove", "all", "records", "belonging", "to", "specified", "cluster"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/cache/OAbstractRecordCache.java#L93-L103", "partition": "test", "index": 3012, "time": "2012-05-08 06:51:15"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/query/OSQLQuery.java", "func_name": "OSQLQuery.run", "original_string": "@SuppressWarnings(\"unchecked\")\r\n  public List<T> run(final Object... iArgs) {\r\n    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();\r\n    if (database == null)\r\n      throw new OQueryParsingException(\"No database configured\");\r\n\r\n    ((OMetadataInternal) database.getMetadata()).makeThreadLocalSchemaSnapshot();\r\n    try {\r\n      setParameters(iArgs);\r\n      Object o = database.getStorage().command(this);\r\n      if (o instanceof List) {\r\n        return (List<T>) o;\r\n      } else {\r\n        return (List<T>) Collections.singletonList(o);\r\n      }\r\n\r\n    } finally {\r\n      ((OMetadataInternal) database.getMetadata()).clearThreadLocalSchemaSnapshot();\r\n    }\r\n  }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\r\n  public List<T> run(final Object... iArgs) {\r\n    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();\r\n    if (database == null)\r\n      throw new OQueryParsingException(\"No database configured\");\r\n\r\n    ((OMetadataInternal) database.getMetadata()).makeThreadLocalSchemaSnapshot();\r\n    try {\r\n      setParameters(iArgs);\r\n      Object o = database.getStorage().command(this);\r\n      if (o instanceof List) {\r\n        return (List<T>) o;\r\n      } else {\r\n        return (List<T>) Collections.singletonList(o);\r\n      }\r\n\r\n    } finally {\r\n      ((OMetadataInternal) database.getMetadata()).clearThreadLocalSchemaSnapshot();\r\n    }\r\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "List", "<", "T", ">", "run", "(", "final", "Object", "...", "iArgs", ")", "{", "final", "ODatabaseDocumentInternal", "database", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ";", "if", "(", "database", "==", "null", ")", "throw", "new", "OQueryParsingException", "(", "\"No database configured\"", ")", ";", "(", "(", "OMetadataInternal", ")", "database", ".", "getMetadata", "(", ")", ")", ".", "makeThreadLocalSchemaSnapshot", "(", ")", ";", "try", "{", "setParameters", "(", "iArgs", ")", ";", "Object", "o", "=", "database", ".", "getStorage", "(", ")", ".", "command", "(", "this", ")", ";", "if", "(", "o", "instanceof", "List", ")", "{", "return", "(", "List", "<", "T", ">", ")", "o", ";", "}", "else", "{", "return", "(", "List", "<", "T", ">", ")", "Collections", ".", "singletonList", "(", "o", ")", ";", "}", "}", "finally", "{", "(", "(", "OMetadataInternal", ")", "database", ".", "getMetadata", "(", ")", ")", ".", "clearThreadLocalSchemaSnapshot", "(", ")", ";", "}", "}"], "docstring": "Delegates to the OQueryExecutor the query execution.", "docstring_tokens": ["Delegates", "to", "the", "OQueryExecutor", "the", "query", "execution", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/query/OSQLQuery.java#L68-L87", "partition": "test", "index": 2955, "time": "2012-05-08 23:15:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/operator/OQueryOperator.java", "func_name": "OQueryOperator.executeIndexQuery", "original_string": "public OIndexCursor executeIndexQuery(OCommandContext iContext, OIndex<?> index, final List<Object> keyParams,\r\n      boolean ascSortOrder) {\r\n    return null;\r\n  }", "language": "java", "code": "public OIndexCursor executeIndexQuery(OCommandContext iContext, OIndex<?> index, final List<Object> keyParams,\r\n      boolean ascSortOrder) {\r\n    return null;\r\n  }", "code_tokens": ["public", "OIndexCursor", "executeIndexQuery", "(", "OCommandContext", "iContext", ",", "OIndex", "<", "?", ">", "index", ",", "final", "List", "<", "Object", ">", "keyParams", ",", "boolean", "ascSortOrder", ")", "{", "return", "null", ";", "}"], "docstring": "Performs index query and returns index cursor which presents subset of index data which corresponds to result of execution of\ngiven operator.\n\n<p/>\nQuery that should be executed can be presented like: [[property0 = keyParam0] and [property1 = keyParam1] and] propertyN\noperator keyParamN.\n<p/>\nIt is supped that index which passed in as parameter is used to index properties listed above and responsibility of given\nmethod execute query using given parameters.\n<p/>\nMultiple parameters are passed in to implement composite indexes support.\n\n\n@param iContext\n@param index\nInstance of index that will be used to calculate result of operator execution.\n@param keyParams\nParameters of query is used to calculate query result.\n@param ascSortOrder\nData returned by cursors should be sorted in ascending or descending order.\n@return Cursor instance if index can be used to evaluate result of execution of given operator and <code>null</code> otherwise.", "docstring_tokens": ["Performs", "index", "query", "and", "returns", "index", "cursor", "which", "presents", "subset", "of", "index", "data", "which", "corresponds", "to", "result", "of", "execution", "of", "given", "operator", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/operator/OQueryOperator.java#L150-L153", "partition": "test", "index": 3287, "time": "2012-05-08 23:15:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/query/OSQLQuery.java", "func_name": "OSQLQuery.runFirst", "original_string": "public T runFirst(final Object... iArgs) {\r\n    setLimit(1);\r\n    final List<T> result = execute(iArgs);\r\n    return result != null && !result.isEmpty() ? result.get(0) : null;\r\n  }", "language": "java", "code": "public T runFirst(final Object... iArgs) {\r\n    setLimit(1);\r\n    final List<T> result = execute(iArgs);\r\n    return result != null && !result.isEmpty() ? result.get(0) : null;\r\n  }", "code_tokens": ["public", "T", "runFirst", "(", "final", "Object", "...", "iArgs", ")", "{", "setLimit", "(", "1", ")", ";", "final", "List", "<", "T", ">", "result", "=", "execute", "(", "iArgs", ")", ";", "return", "result", "!=", "null", "&&", "!", "result", ".", "isEmpty", "(", ")", "?", "result", ".", "get", "(", "0", ")", ":", "null", ";", "}"], "docstring": "Returns only the first record if any.", "docstring_tokens": ["Returns", "only", "the", "first", "record", "if", "any", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/query/OSQLQuery.java#L92-L96", "partition": "test", "index": 2956, "time": "2012-05-08 23:15:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionNoTx.java", "func_name": "OTransactionNoTx.saveRecord", "original_string": "public ORecord saveRecord(final ORecord iRecord, final String iClusterName, final OPERATION_MODE iMode, boolean iForceCreate,\r\n      final ORecordCallback<? extends Number> iRecordCreatedCallback, ORecordCallback<Integer> iRecordUpdatedCallback) {\r\n    try {\r\n\r\n      return database.saveAll(iRecord, iClusterName, iMode, iForceCreate, iRecordCreatedCallback, iRecordUpdatedCallback);\r\n\r\n    } catch (Exception e) {\r\n      // REMOVE IT FROM THE CACHE TO AVOID DIRTY RECORDS\r\n      final ORecordId rid = (ORecordId) iRecord.getIdentity();\r\n      if (rid.isValid())\r\n        database.getLocalCache().freeRecord(rid);\r\n\r\n      if (e instanceof ONeedRetryException)\r\n        throw (ONeedRetryException) e;\r\n\r\n      throw OException.wrapException(\r\n          new ODatabaseException(\"Error during saving of record\" + (iRecord != null ? \" with rid \" + iRecord.getIdentity() : \"\")),\r\n          e);\r\n    }\r\n  }", "language": "java", "code": "public ORecord saveRecord(final ORecord iRecord, final String iClusterName, final OPERATION_MODE iMode, boolean iForceCreate,\r\n      final ORecordCallback<? extends Number> iRecordCreatedCallback, ORecordCallback<Integer> iRecordUpdatedCallback) {\r\n    try {\r\n\r\n      return database.saveAll(iRecord, iClusterName, iMode, iForceCreate, iRecordCreatedCallback, iRecordUpdatedCallback);\r\n\r\n    } catch (Exception e) {\r\n      // REMOVE IT FROM THE CACHE TO AVOID DIRTY RECORDS\r\n      final ORecordId rid = (ORecordId) iRecord.getIdentity();\r\n      if (rid.isValid())\r\n        database.getLocalCache().freeRecord(rid);\r\n\r\n      if (e instanceof ONeedRetryException)\r\n        throw (ONeedRetryException) e;\r\n\r\n      throw OException.wrapException(\r\n          new ODatabaseException(\"Error during saving of record\" + (iRecord != null ? \" with rid \" + iRecord.getIdentity() : \"\")),\r\n          e);\r\n    }\r\n  }", "code_tokens": ["public", "ORecord", "saveRecord", "(", "final", "ORecord", "iRecord", ",", "final", "String", "iClusterName", ",", "final", "OPERATION_MODE", "iMode", ",", "boolean", "iForceCreate", ",", "final", "ORecordCallback", "<", "?", "extends", "Number", ">", "iRecordCreatedCallback", ",", "ORecordCallback", "<", "Integer", ">", "iRecordUpdatedCallback", ")", "{", "try", "{", "return", "database", ".", "saveAll", "(", "iRecord", ",", "iClusterName", ",", "iMode", ",", "iForceCreate", ",", "iRecordCreatedCallback", ",", "iRecordUpdatedCallback", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "// REMOVE IT FROM THE CACHE TO AVOID DIRTY RECORDS\r", "final", "ORecordId", "rid", "=", "(", "ORecordId", ")", "iRecord", ".", "getIdentity", "(", ")", ";", "if", "(", "rid", ".", "isValid", "(", ")", ")", "database", ".", "getLocalCache", "(", ")", ".", "freeRecord", "(", "rid", ")", ";", "if", "(", "e", "instanceof", "ONeedRetryException", ")", "throw", "(", "ONeedRetryException", ")", "e", ";", "throw", "OException", ".", "wrapException", "(", "new", "ODatabaseException", "(", "\"Error during saving of record\"", "+", "(", "iRecord", "!=", "null", "?", "\" with rid \"", "+", "iRecord", ".", "getIdentity", "(", ")", ":", "\"\"", ")", ")", ",", "e", ")", ";", "}", "}"], "docstring": "Update the record.\n\n@param iRecord\n@param iForceCreate\n@param iRecordCreatedCallback\n@param iRecordUpdatedCallback", "docstring_tokens": ["Update", "the", "record", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionNoTx.java#L158-L177", "partition": "test", "index": 3232, "time": "2012-05-10 16:42:55"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionNoTx.java", "func_name": "OTransactionNoTx.deleteRecord", "original_string": "public void deleteRecord(final ORecord iRecord, final OPERATION_MODE iMode) {\r\n    if (!iRecord.getIdentity().isPersistent())\r\n      return;\r\n\r\n    try {\r\n      database.executeDeleteRecord(iRecord, iRecord.getVersion(), true, iMode, false);\r\n    } catch (Exception e) {\r\n      // REMOVE IT FROM THE CACHE TO AVOID DIRTY RECORDS\r\n      final ORecordId rid = (ORecordId) iRecord.getIdentity();\r\n      if (rid.isValid())\r\n        database.getLocalCache().freeRecord(rid);\r\n\r\n      if (e instanceof RuntimeException)\r\n        throw (RuntimeException) e;\r\n      throw OException.wrapException(\r\n          new ODatabaseException(\"Error during deletion of record\" + (iRecord != null ? \" with rid \" + iRecord.getIdentity() : \"\")),\r\n          e);\r\n    }\r\n  }", "language": "java", "code": "public void deleteRecord(final ORecord iRecord, final OPERATION_MODE iMode) {\r\n    if (!iRecord.getIdentity().isPersistent())\r\n      return;\r\n\r\n    try {\r\n      database.executeDeleteRecord(iRecord, iRecord.getVersion(), true, iMode, false);\r\n    } catch (Exception e) {\r\n      // REMOVE IT FROM THE CACHE TO AVOID DIRTY RECORDS\r\n      final ORecordId rid = (ORecordId) iRecord.getIdentity();\r\n      if (rid.isValid())\r\n        database.getLocalCache().freeRecord(rid);\r\n\r\n      if (e instanceof RuntimeException)\r\n        throw (RuntimeException) e;\r\n      throw OException.wrapException(\r\n          new ODatabaseException(\"Error during deletion of record\" + (iRecord != null ? \" with rid \" + iRecord.getIdentity() : \"\")),\r\n          e);\r\n    }\r\n  }", "code_tokens": ["public", "void", "deleteRecord", "(", "final", "ORecord", "iRecord", ",", "final", "OPERATION_MODE", "iMode", ")", "{", "if", "(", "!", "iRecord", ".", "getIdentity", "(", ")", ".", "isPersistent", "(", ")", ")", "return", ";", "try", "{", "database", ".", "executeDeleteRecord", "(", "iRecord", ",", "iRecord", ".", "getVersion", "(", ")", ",", "true", ",", "iMode", ",", "false", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "// REMOVE IT FROM THE CACHE TO AVOID DIRTY RECORDS\r", "final", "ORecordId", "rid", "=", "(", "ORecordId", ")", "iRecord", ".", "getIdentity", "(", ")", ";", "if", "(", "rid", ".", "isValid", "(", ")", ")", "database", ".", "getLocalCache", "(", ")", ".", "freeRecord", "(", "rid", ")", ";", "if", "(", "e", "instanceof", "RuntimeException", ")", "throw", "(", "RuntimeException", ")", "e", ";", "throw", "OException", ".", "wrapException", "(", "new", "ODatabaseException", "(", "\"Error during deletion of record\"", "+", "(", "iRecord", "!=", "null", "?", "\" with rid \"", "+", "iRecord", ".", "getIdentity", "(", ")", ":", "\"\"", ")", ")", ",", "e", ")", ";", "}", "}"], "docstring": "Deletes the record.", "docstring_tokens": ["Deletes", "the", "record", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionNoTx.java#L189-L207", "partition": "test", "index": 3233, "time": "2012-05-10 16:42:55"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolBase.java", "func_name": "ODatabasePoolBase.acquire", "original_string": "public DB acquire(final String iName, final String iUserName, final String iUserPassword,\r\n      final Map<String, Object> iOptionalParams) {\r\n    setup();\r\n    return dbPool.acquire(iName, iUserName, iUserPassword, iOptionalParams);\r\n  }", "language": "java", "code": "public DB acquire(final String iName, final String iUserName, final String iUserPassword,\r\n      final Map<String, Object> iOptionalParams) {\r\n    setup();\r\n    return dbPool.acquire(iName, iUserName, iUserPassword, iOptionalParams);\r\n  }", "code_tokens": ["public", "DB", "acquire", "(", "final", "String", "iName", ",", "final", "String", "iUserName", ",", "final", "String", "iUserPassword", ",", "final", "Map", "<", "String", ",", "Object", ">", "iOptionalParams", ")", "{", "setup", "(", ")", ";", "return", "dbPool", ".", "acquire", "(", "iName", ",", "iUserName", ",", "iUserPassword", ",", "iOptionalParams", ")", ";", "}"], "docstring": "Acquires a connection from the pool specifying options. If the pool is empty, then the caller thread will wait for it.\n\n@param iName\nDatabase name\n@param iUserName\nUser name\n@param iUserPassword\nUser password\n@return A pooled database instance", "docstring_tokens": ["Acquires", "a", "connection", "from", "the", "pool", "specifying", "options", ".", "If", "the", "pool", "is", "empty", "then", "the", "caller", "thread", "will", "wait", "for", "it", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolBase.java#L162-L166", "partition": "test", "index": 3173, "time": "2012-05-13 18:05:07"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolBase.java", "func_name": "ODatabasePoolBase.acquire", "original_string": "public DB acquire(final String iName, final String iUserName, final String iUserPassword) {\r\n    setup();\r\n    return dbPool.acquire(iName, iUserName, iUserPassword);\r\n  }", "language": "java", "code": "public DB acquire(final String iName, final String iUserName, final String iUserPassword) {\r\n    setup();\r\n    return dbPool.acquire(iName, iUserName, iUserPassword);\r\n  }", "code_tokens": ["public", "DB", "acquire", "(", "final", "String", "iName", ",", "final", "String", "iUserName", ",", "final", "String", "iUserPassword", ")", "{", "setup", "(", ")", ";", "return", "dbPool", ".", "acquire", "(", "iName", ",", "iUserName", ",", "iUserPassword", ")", ";", "}"], "docstring": "Acquires a connection from the pool. If the pool is empty, then the caller thread will wait for it.\n\n@param iName\nDatabase name\n@param iUserName\nUser name\n@param iUserPassword\nUser password\n@return A pooled database instance", "docstring_tokens": ["Acquires", "a", "connection", "from", "the", "pool", ".", "If", "the", "pool", "is", "empty", "then", "the", "caller", "thread", "will", "wait", "for", "it", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolBase.java#L126-L129", "partition": "test", "index": 3171, "time": "2012-05-13 18:05:07"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLDropCluster.java", "func_name": "OCommandExecutorSQLDropCluster.execute", "original_string": "public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clusterName == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final ODatabaseDocumentInternal database = getDatabase();\r\n\r\n    // CHECK IF ANY CLASS IS USING IT\r\n    final int clusterId = database.getStorage().getClusterIdByName(clusterName);\r\n    for (OClass iClass : database.getMetadata().getSchema().getClasses()) {\r\n      for (int i : iClass.getClusterIds()) {\r\n        if (i == clusterId)\r\n          // IN USE\r\n          return false;\r\n      }\r\n    }\r\n\r\n    // REMOVE CACHE OF COMMAND RESULTS IF ACTIVE\r\n    database.getMetadata().getCommandCache().invalidateResultsOfCluster(clusterName);\r\n\r\n    database.dropCluster(clusterId, true);\r\n    return true;\r\n  }", "language": "java", "code": "public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clusterName == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final ODatabaseDocumentInternal database = getDatabase();\r\n\r\n    // CHECK IF ANY CLASS IS USING IT\r\n    final int clusterId = database.getStorage().getClusterIdByName(clusterName);\r\n    for (OClass iClass : database.getMetadata().getSchema().getClasses()) {\r\n      for (int i : iClass.getClusterIds()) {\r\n        if (i == clusterId)\r\n          // IN USE\r\n          return false;\r\n      }\r\n    }\r\n\r\n    // REMOVE CACHE OF COMMAND RESULTS IF ACTIVE\r\n    database.getMetadata().getCommandCache().invalidateResultsOfCluster(clusterName);\r\n\r\n    database.dropCluster(clusterId, true);\r\n    return true;\r\n  }", "code_tokens": ["public", "Object", "execute", "(", "final", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "if", "(", "clusterName", "==", "null", ")", "throw", "new", "OCommandExecutionException", "(", "\"Cannot execute the command because it has not been parsed yet\"", ")", ";", "final", "ODatabaseDocumentInternal", "database", "=", "getDatabase", "(", ")", ";", "// CHECK IF ANY CLASS IS USING IT\r", "final", "int", "clusterId", "=", "database", ".", "getStorage", "(", ")", ".", "getClusterIdByName", "(", "clusterName", ")", ";", "for", "(", "OClass", "iClass", ":", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClasses", "(", ")", ")", "{", "for", "(", "int", "i", ":", "iClass", ".", "getClusterIds", "(", ")", ")", "{", "if", "(", "i", "==", "clusterId", ")", "// IN USE\r", "return", "false", ";", "}", "}", "// REMOVE CACHE OF COMMAND RESULTS IF ACTIVE\r", "database", ".", "getMetadata", "(", ")", ".", "getCommandCache", "(", ")", ".", "invalidateResultsOfCluster", "(", "clusterName", ")", ";", "database", ".", "dropCluster", "(", "clusterId", ",", "true", ")", ";", "return", "true", ";", "}"], "docstring": "Execute the DROP CLUSTER.", "docstring_tokens": ["Execute", "the", "DROP", "CLUSTER", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLDropCluster.java#L86-L107", "partition": "test", "index": 2997, "time": "2012-06-12 01:42:25"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/record/ORecordAbstract.java", "func_name": "ORecordAbstract.removeListener", "original_string": "protected void removeListener(final ORecordListener listener) {\r\n    if (_listeners != null) {\r\n      _listeners.remove(listener);\r\n      if (_listeners.isEmpty())\r\n        _listeners = null;\r\n    }\r\n  }", "language": "java", "code": "protected void removeListener(final ORecordListener listener) {\r\n    if (_listeners != null) {\r\n      _listeners.remove(listener);\r\n      if (_listeners.isEmpty())\r\n        _listeners = null;\r\n    }\r\n  }", "code_tokens": ["protected", "void", "removeListener", "(", "final", "ORecordListener", "listener", ")", "{", "if", "(", "_listeners", "!=", "null", ")", "{", "_listeners", ".", "remove", "(", "listener", ")", ";", "if", "(", "_listeners", ".", "isEmpty", "(", ")", ")", "_listeners", "=", "null", ";", "}", "}"], "docstring": "Remove the current event listener.\n\n@see ORecordListener", "docstring_tokens": ["Remove", "the", "current", "event", "listener", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/record/ORecordAbstract.java#L473-L479", "partition": "test", "index": 3028, "time": "2012-06-14 17:41:36"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/security/ORole.java", "func_name": "ORole.grant", "original_string": "public ORole grant(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {\r\n    ORule rule = rules.get(resourceGeneric);\r\n\r\n    if (rule == null) {\r\n      rule = new ORule(resourceGeneric, null, null);\r\n      rules.put(resourceGeneric, rule);\r\n    }\r\n\r\n    rule.grantAccess(resourceSpecific, iOperation);\r\n\r\n    rules.put(resourceGeneric, rule);\r\n    updateRolesDocumentContent();\r\n    return this;\r\n  }", "language": "java", "code": "public ORole grant(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {\r\n    ORule rule = rules.get(resourceGeneric);\r\n\r\n    if (rule == null) {\r\n      rule = new ORule(resourceGeneric, null, null);\r\n      rules.put(resourceGeneric, rule);\r\n    }\r\n\r\n    rule.grantAccess(resourceSpecific, iOperation);\r\n\r\n    rules.put(resourceGeneric, rule);\r\n    updateRolesDocumentContent();\r\n    return this;\r\n  }", "code_tokens": ["public", "ORole", "grant", "(", "final", "ORule", ".", "ResourceGeneric", "resourceGeneric", ",", "String", "resourceSpecific", ",", "final", "int", "iOperation", ")", "{", "ORule", "rule", "=", "rules", ".", "get", "(", "resourceGeneric", ")", ";", "if", "(", "rule", "==", "null", ")", "{", "rule", "=", "new", "ORule", "(", "resourceGeneric", ",", "null", ",", "null", ")", ";", "rules", ".", "put", "(", "resourceGeneric", ",", "rule", ")", ";", "}", "rule", ".", "grantAccess", "(", "resourceSpecific", ",", "iOperation", ")", ";", "rules", ".", "put", "(", "resourceGeneric", ",", "rule", ")", ";", "updateRolesDocumentContent", "(", ")", ";", "return", "this", ";", "}"], "docstring": "Grant a permission to the resource.\n\n@return", "docstring_tokens": ["Grant", "a", "permission", "to", "the", "resource", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/security/ORole.java#L292-L305", "partition": "test", "index": 3016, "time": "2012-06-18 13:14:14"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/security/ORole.java", "func_name": "ORole.revoke", "original_string": "public ORole revoke(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {\r\n    if (iOperation == PERMISSION_NONE)\r\n      return this;\r\n\r\n    ORule rule = rules.get(resourceGeneric);\r\n\r\n    if (rule == null) {\r\n      rule = new ORule(resourceGeneric, null, null);\r\n      rules.put(resourceGeneric, rule);\r\n    }\r\n\r\n    rule.revokeAccess(resourceSpecific, iOperation);\r\n    rules.put(resourceGeneric, rule);\r\n\r\n    updateRolesDocumentContent();\r\n\r\n    return this;\r\n  }", "language": "java", "code": "public ORole revoke(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {\r\n    if (iOperation == PERMISSION_NONE)\r\n      return this;\r\n\r\n    ORule rule = rules.get(resourceGeneric);\r\n\r\n    if (rule == null) {\r\n      rule = new ORule(resourceGeneric, null, null);\r\n      rules.put(resourceGeneric, rule);\r\n    }\r\n\r\n    rule.revokeAccess(resourceSpecific, iOperation);\r\n    rules.put(resourceGeneric, rule);\r\n\r\n    updateRolesDocumentContent();\r\n\r\n    return this;\r\n  }", "code_tokens": ["public", "ORole", "revoke", "(", "final", "ORule", ".", "ResourceGeneric", "resourceGeneric", ",", "String", "resourceSpecific", ",", "final", "int", "iOperation", ")", "{", "if", "(", "iOperation", "==", "PERMISSION_NONE", ")", "return", "this", ";", "ORule", "rule", "=", "rules", ".", "get", "(", "resourceGeneric", ")", ";", "if", "(", "rule", "==", "null", ")", "{", "rule", "=", "new", "ORule", "(", "resourceGeneric", ",", "null", ",", "null", ")", ";", "rules", ".", "put", "(", "resourceGeneric", ",", "rule", ")", ";", "}", "rule", ".", "revokeAccess", "(", "resourceSpecific", ",", "iOperation", ")", ";", "rules", ".", "put", "(", "resourceGeneric", ",", "rule", ")", ";", "updateRolesDocumentContent", "(", ")", ";", "return", "this", ";", "}"], "docstring": "Revoke a permission to the resource.", "docstring_tokens": ["Revoke", "a", "permission", "to", "the", "resource", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/security/ORole.java#L310-L327", "partition": "test", "index": 3017, "time": "2012-06-18 13:14:14"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/query/OQueryAbstract.java", "func_name": "OQueryAbstract.setFetchPlan", "original_string": "public OQueryAbstract setFetchPlan(final String fetchPlan) {\r\n    OFetchHelper.checkFetchPlanValid(fetchPlan);\r\n    if (fetchPlan != null && fetchPlan.length() == 0)\r\n      this.fetchPlan = null;\r\n    else\r\n      this.fetchPlan = fetchPlan;\r\n    return this;\r\n  }", "language": "java", "code": "public OQueryAbstract setFetchPlan(final String fetchPlan) {\r\n    OFetchHelper.checkFetchPlanValid(fetchPlan);\r\n    if (fetchPlan != null && fetchPlan.length() == 0)\r\n      this.fetchPlan = null;\r\n    else\r\n      this.fetchPlan = fetchPlan;\r\n    return this;\r\n  }", "code_tokens": ["public", "OQueryAbstract", "setFetchPlan", "(", "final", "String", "fetchPlan", ")", "{", "OFetchHelper", ".", "checkFetchPlanValid", "(", "fetchPlan", ")", ";", "if", "(", "fetchPlan", "!=", "null", "&&", "fetchPlan", ".", "length", "(", ")", "==", "0", ")", "this", ".", "fetchPlan", "=", "null", ";", "else", "this", ".", "fetchPlan", "=", "fetchPlan", ";", "return", "this", ";", "}"], "docstring": "Sets the fetch plan to use.", "docstring_tokens": ["Sets", "the", "fetch", "plan", "to", "use", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/query/OQueryAbstract.java#L46-L53", "partition": "test", "index": 3162, "time": "2012-06-20 09:41:48"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java", "func_name": "OServerAdmin.dropDatabase", "original_string": "public synchronized OServerAdmin dropDatabase(final String iDatabaseName, final String storageType) throws IOException {\r\n\r\n    ODropDatabaseRequest request = new ODropDatabaseRequest(iDatabaseName, storageType);\r\n    ODropDatabaseResponse response = networkAdminOperation(request, \"Cannot delete the remote storage: \" + storage.getName());\r\n\r\n    OURLConnection connection = OURLHelper.parse(getURL());\r\n    OrientDBRemote remote = (OrientDBRemote) ODatabaseDocumentTxInternal.getOrCreateRemoteFactory(connection.getPath());\r\n    remote.forceDatabaseClose(iDatabaseName);\r\n\r\n    ODatabaseRecordThreadLocal.instance().remove();\r\n\r\n    return this;\r\n  }", "language": "java", "code": "public synchronized OServerAdmin dropDatabase(final String iDatabaseName, final String storageType) throws IOException {\r\n\r\n    ODropDatabaseRequest request = new ODropDatabaseRequest(iDatabaseName, storageType);\r\n    ODropDatabaseResponse response = networkAdminOperation(request, \"Cannot delete the remote storage: \" + storage.getName());\r\n\r\n    OURLConnection connection = OURLHelper.parse(getURL());\r\n    OrientDBRemote remote = (OrientDBRemote) ODatabaseDocumentTxInternal.getOrCreateRemoteFactory(connection.getPath());\r\n    remote.forceDatabaseClose(iDatabaseName);\r\n\r\n    ODatabaseRecordThreadLocal.instance().remove();\r\n\r\n    return this;\r\n  }", "code_tokens": ["public", "synchronized", "OServerAdmin", "dropDatabase", "(", "final", "String", "iDatabaseName", ",", "final", "String", "storageType", ")", "throws", "IOException", "{", "ODropDatabaseRequest", "request", "=", "new", "ODropDatabaseRequest", "(", "iDatabaseName", ",", "storageType", ")", ";", "ODropDatabaseResponse", "response", "=", "networkAdminOperation", "(", "request", ",", "\"Cannot delete the remote storage: \"", "+", "storage", ".", "getName", "(", ")", ")", ";", "OURLConnection", "connection", "=", "OURLHelper", ".", "parse", "(", "getURL", "(", ")", ")", ";", "OrientDBRemote", "remote", "=", "(", "OrientDBRemote", ")", "ODatabaseDocumentTxInternal", ".", "getOrCreateRemoteFactory", "(", "connection", ".", "getPath", "(", ")", ")", ";", "remote", ".", "forceDatabaseClose", "(", "iDatabaseName", ")", ";", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "remove", "(", ")", ";", "return", "this", ";", "}"], "docstring": "Drops a database from a remote server instance.\n\n@param iDatabaseName The database name\n@param storageType   Storage type between \"plocal\" or \"memory\".\n\n@return The instance itself. Useful to execute method in chain\n\n@throws IOException", "docstring_tokens": ["Drops", "a", "database", "from", "a", "remote", "server", "instance", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java#L308-L320", "partition": "test", "index": 3225, "time": "2012-07-06 14:22:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/index/OCompositeIndexDefinition.java", "func_name": "OCompositeIndexDefinition.addIndex", "original_string": "public void addIndex(final OIndexDefinition indexDefinition) {\r\n    indexDefinitions.add(indexDefinition);\r\n    if (indexDefinition instanceof OIndexDefinitionMultiValue) {\r\n      if (multiValueDefinitionIndex == -1)\r\n        multiValueDefinitionIndex = indexDefinitions.size() - 1;\r\n      else\r\n        throw new OIndexException(\"Composite key cannot contain more than one collection item\");\r\n    }\r\n\r\n    collate.addCollate(indexDefinition.getCollate());\r\n  }", "language": "java", "code": "public void addIndex(final OIndexDefinition indexDefinition) {\r\n    indexDefinitions.add(indexDefinition);\r\n    if (indexDefinition instanceof OIndexDefinitionMultiValue) {\r\n      if (multiValueDefinitionIndex == -1)\r\n        multiValueDefinitionIndex = indexDefinitions.size() - 1;\r\n      else\r\n        throw new OIndexException(\"Composite key cannot contain more than one collection item\");\r\n    }\r\n\r\n    collate.addCollate(indexDefinition.getCollate());\r\n  }", "code_tokens": ["public", "void", "addIndex", "(", "final", "OIndexDefinition", "indexDefinition", ")", "{", "indexDefinitions", ".", "add", "(", "indexDefinition", ")", ";", "if", "(", "indexDefinition", "instanceof", "OIndexDefinitionMultiValue", ")", "{", "if", "(", "multiValueDefinitionIndex", "==", "-", "1", ")", "multiValueDefinitionIndex", "=", "indexDefinitions", ".", "size", "(", ")", "-", "1", ";", "else", "throw", "new", "OIndexException", "(", "\"Composite key cannot contain more than one collection item\"", ")", ";", "}", "collate", ".", "addCollate", "(", "indexDefinition", ".", "getCollate", "(", ")", ")", ";", "}"], "docstring": "Add new indexDefinition in current composite.\n\n@param indexDefinition Index to add.", "docstring_tokens": ["Add", "new", "indexDefinition", "in", "current", "composite", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/index/OCompositeIndexDefinition.java#L96-L106", "partition": "test", "index": 2991, "time": "2012-07-08 06:54:30"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/OMemoryStream.java", "func_name": "OMemoryStream.move", "original_string": "public void move(final int iFrom, final int iPosition) {\r\n    if (iPosition == 0)\r\n      return;\r\n\r\n    final int to = iFrom + iPosition;\r\n    final int size = iPosition > 0 ? buffer.length - to : buffer.length - iFrom;\r\n\r\n    System.arraycopy(buffer, iFrom, buffer, to, size);\r\n  }", "language": "java", "code": "public void move(final int iFrom, final int iPosition) {\r\n    if (iPosition == 0)\r\n      return;\r\n\r\n    final int to = iFrom + iPosition;\r\n    final int size = iPosition > 0 ? buffer.length - to : buffer.length - iFrom;\r\n\r\n    System.arraycopy(buffer, iFrom, buffer, to, size);\r\n  }", "code_tokens": ["public", "void", "move", "(", "final", "int", "iFrom", ",", "final", "int", "iPosition", ")", "{", "if", "(", "iPosition", "==", "0", ")", "return", ";", "final", "int", "to", "=", "iFrom", "+", "iPosition", ";", "final", "int", "size", "=", "iPosition", ">", "0", "?", "buffer", ".", "length", "-", "to", ":", "buffer", ".", "length", "-", "iFrom", ";", "System", ".", "arraycopy", "(", "buffer", ",", "iFrom", ",", "buffer", ",", "to", ",", "size", ")", ";", "}"], "docstring": "Move bytes left or right of an offset.\n\n@param iFrom     Starting position\n@param iPosition Offset to the iFrom value: positive values mean move right, otherwise move left", "docstring_tokens": ["Move", "bytes", "left", "or", "right", "of", "an", "offset", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/OMemoryStream.java#L84-L92", "partition": "test", "index": 2981, "time": "2012-07-19 00:19:33"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/OMemoryStream.java", "func_name": "OMemoryStream.fill", "original_string": "public void fill(final int iLength, final byte iFiller) {\r\n    assureSpaceFor(iLength);\r\n    Arrays.fill(buffer, position, position + iLength, iFiller);\r\n    position += iLength;\r\n  }", "language": "java", "code": "public void fill(final int iLength, final byte iFiller) {\r\n    assureSpaceFor(iLength);\r\n    Arrays.fill(buffer, position, position + iLength, iFiller);\r\n    position += iLength;\r\n  }", "code_tokens": ["public", "void", "fill", "(", "final", "int", "iLength", ",", "final", "byte", "iFiller", ")", "{", "assureSpaceFor", "(", "iLength", ")", ";", "Arrays", ".", "fill", "(", "buffer", ",", "position", ",", "position", "+", "iLength", ",", "iFiller", ")", ";", "position", "+=", "iLength", ";", "}"], "docstring": "Fills the stream from current position writing iLength times the iFiller byte\n\n@param iLength Bytes to jump\n@param iFiller Byte to use to fill the space", "docstring_tokens": ["Fills", "the", "stream", "from", "current", "position", "writing", "iLength", "times", "the", "iFiller", "byte"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/OMemoryStream.java#L314-L318", "partition": "test", "index": 2982, "time": "2012-07-19 00:19:33"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/operator/OQueryTargetOperator.java", "func_name": "OQueryTargetOperator.evaluateRecord", "original_string": "@Override\r\n  public Object evaluateRecord(final OIdentifiable iRecord, ODocument iCurrentResult, final OSQLFilterCondition iCondition,\r\n      final Object iLeft, final Object iRight, OCommandContext iContext, final ODocumentSerializer serializer) {\r\n    return true;\r\n  }", "language": "java", "code": "@Override\r\n  public Object evaluateRecord(final OIdentifiable iRecord, ODocument iCurrentResult, final OSQLFilterCondition iCondition,\r\n      final Object iLeft, final Object iRight, OCommandContext iContext, final ODocumentSerializer serializer) {\r\n    return true;\r\n  }", "code_tokens": ["@", "Override", "public", "Object", "evaluateRecord", "(", "final", "OIdentifiable", "iRecord", ",", "ODocument", "iCurrentResult", ",", "final", "OSQLFilterCondition", "iCondition", ",", "final", "Object", "iLeft", ",", "final", "Object", "iRight", ",", "OCommandContext", "iContext", ",", "final", "ODocumentSerializer", "serializer", ")", "{", "return", "true", ";", "}"], "docstring": "At run-time the evaluation per record must return always true since the recordset are filtered at the beginning unless an\noperator can work in both modes. In this case sub-class must extend it.", "docstring_tokens": ["At", "run", "-", "time", "the", "evaluation", "per", "record", "must", "return", "always", "true", "since", "the", "recordset", "are", "filtered", "at", "the", "beginning", "unless", "an", "operator", "can", "work", "in", "both", "modes", ".", "In", "this", "case", "sub", "-", "class", "must", "extend", "it", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/operator/OQueryTargetOperator.java#L50-L54", "partition": "test", "index": 2985, "time": "2012-07-29 23:12:34"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/OSecurityManager.java", "func_name": "OSecurityManager.createHash", "original_string": "public String createHash(final String iInput, final String iAlgorithm, final boolean iIncludeAlgorithm) {\r\n    if (iInput == null)\r\n      throw new IllegalArgumentException(\"Input string is null\");\r\n\r\n    if (iAlgorithm == null)\r\n      throw new IllegalArgumentException(\"Algorithm is null\");\r\n\r\n    final StringBuilder buffer = new StringBuilder(128);\r\n\r\n    final String algorithm = validateAlgorithm(iAlgorithm);\r\n\r\n    if (iIncludeAlgorithm) {\r\n      buffer.append('{');\r\n      buffer.append(algorithm);\r\n      buffer.append('}');\r\n    }\r\n\r\n    final String transformed;\r\n    if (HASH_ALGORITHM.equalsIgnoreCase(algorithm)) {\r\n      transformed = createSHA256(iInput);\r\n    } else if (PBKDF2_ALGORITHM.equalsIgnoreCase(algorithm)) {\r\n      transformed = createHashWithSalt(iInput, OGlobalConfiguration.SECURITY_USER_PASSWORD_SALT_ITERATIONS.getValueAsInteger(),\r\n          algorithm);\r\n    } else if (PBKDF2_SHA256_ALGORITHM.equalsIgnoreCase(algorithm)) {\r\n      transformed = createHashWithSalt(iInput, OGlobalConfiguration.SECURITY_USER_PASSWORD_SALT_ITERATIONS.getValueAsInteger(),\r\n          algorithm);\r\n    } else\r\n      throw new IllegalArgumentException(\"Algorithm '\" + algorithm + \"' is not supported\");\r\n\r\n    buffer.append(transformed);\r\n\r\n    return buffer.toString();\r\n  }", "language": "java", "code": "public String createHash(final String iInput, final String iAlgorithm, final boolean iIncludeAlgorithm) {\r\n    if (iInput == null)\r\n      throw new IllegalArgumentException(\"Input string is null\");\r\n\r\n    if (iAlgorithm == null)\r\n      throw new IllegalArgumentException(\"Algorithm is null\");\r\n\r\n    final StringBuilder buffer = new StringBuilder(128);\r\n\r\n    final String algorithm = validateAlgorithm(iAlgorithm);\r\n\r\n    if (iIncludeAlgorithm) {\r\n      buffer.append('{');\r\n      buffer.append(algorithm);\r\n      buffer.append('}');\r\n    }\r\n\r\n    final String transformed;\r\n    if (HASH_ALGORITHM.equalsIgnoreCase(algorithm)) {\r\n      transformed = createSHA256(iInput);\r\n    } else if (PBKDF2_ALGORITHM.equalsIgnoreCase(algorithm)) {\r\n      transformed = createHashWithSalt(iInput, OGlobalConfiguration.SECURITY_USER_PASSWORD_SALT_ITERATIONS.getValueAsInteger(),\r\n          algorithm);\r\n    } else if (PBKDF2_SHA256_ALGORITHM.equalsIgnoreCase(algorithm)) {\r\n      transformed = createHashWithSalt(iInput, OGlobalConfiguration.SECURITY_USER_PASSWORD_SALT_ITERATIONS.getValueAsInteger(),\r\n          algorithm);\r\n    } else\r\n      throw new IllegalArgumentException(\"Algorithm '\" + algorithm + \"' is not supported\");\r\n\r\n    buffer.append(transformed);\r\n\r\n    return buffer.toString();\r\n  }", "code_tokens": ["public", "String", "createHash", "(", "final", "String", "iInput", ",", "final", "String", "iAlgorithm", ",", "final", "boolean", "iIncludeAlgorithm", ")", "{", "if", "(", "iInput", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"Input string is null\"", ")", ";", "if", "(", "iAlgorithm", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"Algorithm is null\"", ")", ";", "final", "StringBuilder", "buffer", "=", "new", "StringBuilder", "(", "128", ")", ";", "final", "String", "algorithm", "=", "validateAlgorithm", "(", "iAlgorithm", ")", ";", "if", "(", "iIncludeAlgorithm", ")", "{", "buffer", ".", "append", "(", "'", "'", ")", ";", "buffer", ".", "append", "(", "algorithm", ")", ";", "buffer", ".", "append", "(", "'", "'", ")", ";", "}", "final", "String", "transformed", ";", "if", "(", "HASH_ALGORITHM", ".", "equalsIgnoreCase", "(", "algorithm", ")", ")", "{", "transformed", "=", "createSHA256", "(", "iInput", ")", ";", "}", "else", "if", "(", "PBKDF2_ALGORITHM", ".", "equalsIgnoreCase", "(", "algorithm", ")", ")", "{", "transformed", "=", "createHashWithSalt", "(", "iInput", ",", "OGlobalConfiguration", ".", "SECURITY_USER_PASSWORD_SALT_ITERATIONS", ".", "getValueAsInteger", "(", ")", ",", "algorithm", ")", ";", "}", "else", "if", "(", "PBKDF2_SHA256_ALGORITHM", ".", "equalsIgnoreCase", "(", "algorithm", ")", ")", "{", "transformed", "=", "createHashWithSalt", "(", "iInput", ",", "OGlobalConfiguration", ".", "SECURITY_USER_PASSWORD_SALT_ITERATIONS", ".", "getValueAsInteger", "(", ")", ",", "algorithm", ")", ";", "}", "else", "throw", "new", "IllegalArgumentException", "(", "\"Algorithm '\"", "+", "algorithm", "+", "\"' is not supported\"", ")", ";", "buffer", ".", "append", "(", "transformed", ")", ";", "return", "buffer", ".", "toString", "(", ")", ";", "}"], "docstring": "Hashes the input string.\n\n@param iInput\nString to hash\n@param iIncludeAlgorithm\nInclude the algorithm used or not\n@return", "docstring_tokens": ["Hashes", "the", "input", "string", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/OSecurityManager.java#L130-L162", "partition": "test", "index": 3000, "time": "2012-08-01 15:56:31"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/OSecurityManager.java", "func_name": "OSecurityManager.checkPassword", "original_string": "public boolean checkPassword(final String iPassword, final String iHash) {\r\n    if (iHash.startsWith(HASH_ALGORITHM_PREFIX)) {\r\n      final String s = iHash.substring(HASH_ALGORITHM_PREFIX.length());\r\n      return createSHA256(iPassword).equals(s);\r\n\r\n    } else if (iHash.startsWith(PBKDF2_ALGORITHM_PREFIX)) {\r\n      final String s = iHash.substring(PBKDF2_ALGORITHM_PREFIX.length());\r\n      return checkPasswordWithSalt(iPassword, s, PBKDF2_ALGORITHM);\r\n\r\n    } else if (iHash.startsWith(PBKDF2_SHA256_ALGORITHM_PREFIX)) {\r\n      final String s = iHash.substring(PBKDF2_SHA256_ALGORITHM_PREFIX.length());\r\n      return checkPasswordWithSalt(iPassword, s, PBKDF2_SHA256_ALGORITHM);\r\n    }\r\n\r\n    // Do not compare raw strings against each other, to avoid timing attacks.\r\n    // Instead, hash them both with a cryptographic hash function and\r\n    // compare their hashes with a constant-time comparison method.\r\n    return MessageDigest.isEqual(digestSHA256(iPassword), digestSHA256(iHash));\r\n  }", "language": "java", "code": "public boolean checkPassword(final String iPassword, final String iHash) {\r\n    if (iHash.startsWith(HASH_ALGORITHM_PREFIX)) {\r\n      final String s = iHash.substring(HASH_ALGORITHM_PREFIX.length());\r\n      return createSHA256(iPassword).equals(s);\r\n\r\n    } else if (iHash.startsWith(PBKDF2_ALGORITHM_PREFIX)) {\r\n      final String s = iHash.substring(PBKDF2_ALGORITHM_PREFIX.length());\r\n      return checkPasswordWithSalt(iPassword, s, PBKDF2_ALGORITHM);\r\n\r\n    } else if (iHash.startsWith(PBKDF2_SHA256_ALGORITHM_PREFIX)) {\r\n      final String s = iHash.substring(PBKDF2_SHA256_ALGORITHM_PREFIX.length());\r\n      return checkPasswordWithSalt(iPassword, s, PBKDF2_SHA256_ALGORITHM);\r\n    }\r\n\r\n    // Do not compare raw strings against each other, to avoid timing attacks.\r\n    // Instead, hash them both with a cryptographic hash function and\r\n    // compare their hashes with a constant-time comparison method.\r\n    return MessageDigest.isEqual(digestSHA256(iPassword), digestSHA256(iHash));\r\n  }", "code_tokens": ["public", "boolean", "checkPassword", "(", "final", "String", "iPassword", ",", "final", "String", "iHash", ")", "{", "if", "(", "iHash", ".", "startsWith", "(", "HASH_ALGORITHM_PREFIX", ")", ")", "{", "final", "String", "s", "=", "iHash", ".", "substring", "(", "HASH_ALGORITHM_PREFIX", ".", "length", "(", ")", ")", ";", "return", "createSHA256", "(", "iPassword", ")", ".", "equals", "(", "s", ")", ";", "}", "else", "if", "(", "iHash", ".", "startsWith", "(", "PBKDF2_ALGORITHM_PREFIX", ")", ")", "{", "final", "String", "s", "=", "iHash", ".", "substring", "(", "PBKDF2_ALGORITHM_PREFIX", ".", "length", "(", ")", ")", ";", "return", "checkPasswordWithSalt", "(", "iPassword", ",", "s", ",", "PBKDF2_ALGORITHM", ")", ";", "}", "else", "if", "(", "iHash", ".", "startsWith", "(", "PBKDF2_SHA256_ALGORITHM_PREFIX", ")", ")", "{", "final", "String", "s", "=", "iHash", ".", "substring", "(", "PBKDF2_SHA256_ALGORITHM_PREFIX", ".", "length", "(", ")", ")", ";", "return", "checkPasswordWithSalt", "(", "iPassword", ",", "s", ",", "PBKDF2_SHA256_ALGORITHM", ")", ";", "}", "// Do not compare raw strings against each other, to avoid timing attacks.\r", "// Instead, hash them both with a cryptographic hash function and\r", "// compare their hashes with a constant-time comparison method.\r", "return", "MessageDigest", ".", "isEqual", "(", "digestSHA256", "(", "iPassword", ")", ",", "digestSHA256", "(", "iHash", ")", ")", ";", "}"], "docstring": "Checks if an hash string matches a password, based on the algorithm found on hash string.\n\n@param iHash\nHash string. Can contain the algorithm as prefix in the format <code>{ALGORITHM}-HASH</code>.\n@param iPassword\n@return", "docstring_tokens": ["Checks", "if", "an", "hash", "string", "matches", "a", "password", "based", "on", "the", "algorithm", "found", "on", "hash", "string", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/OSecurityManager.java#L97-L115", "partition": "test", "index": 2999, "time": "2012-08-01 15:56:31"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/iterator/OIdentifiableIterator.java", "func_name": "OIdentifiableIterator.readCurrentRecord", "original_string": "protected ORecord readCurrentRecord(ORecord iRecord, final int iMovement) {\r\n    if (limit > -1 && browsedRecords >= limit)\r\n      // LIMIT REACHED\r\n      return null;\r\n\r\n    do {\r\n      final boolean moveResult;\r\n      switch (iMovement) {\r\n      case 1:\r\n        moveResult = nextPosition();\r\n        break;\r\n      case -1:\r\n        moveResult = prevPosition();\r\n        break;\r\n      case 0:\r\n        moveResult = checkCurrentPosition();\r\n        break;\r\n      default:\r\n        throw new IllegalStateException(\"Invalid movement value : \" + iMovement);\r\n      }\r\n\r\n      if (!moveResult)\r\n        return null;\r\n\r\n      try {\r\n        if (iRecord != null) {\r\n          ORecordInternal.setIdentity(iRecord, new ORecordId(current.getClusterId(), current.getClusterPosition()));\r\n          iRecord = database.load(iRecord, fetchPlan, false);\r\n        } else\r\n          iRecord = database.load(current, fetchPlan, false);\r\n      } catch (ODatabaseException e) {\r\n        if (Thread.interrupted() || database.isClosed())\r\n          // THREAD INTERRUPTED: RETURN\r\n          throw e;\r\n\r\n        if (e.getCause() instanceof OSecurityException)\r\n          throw e;\r\n\r\n        brokenRIDs.add(current.copy());\r\n\r\n        OLogManager.instance().error(this, \"Error on fetching record during browsing. The record has been skipped\", e);\r\n      }\r\n\r\n      if (iRecord != null) {\r\n        browsedRecords++;\r\n        return iRecord;\r\n      }\r\n    } while (iMovement != 0);\r\n\r\n    return null;\r\n  }", "language": "java", "code": "protected ORecord readCurrentRecord(ORecord iRecord, final int iMovement) {\r\n    if (limit > -1 && browsedRecords >= limit)\r\n      // LIMIT REACHED\r\n      return null;\r\n\r\n    do {\r\n      final boolean moveResult;\r\n      switch (iMovement) {\r\n      case 1:\r\n        moveResult = nextPosition();\r\n        break;\r\n      case -1:\r\n        moveResult = prevPosition();\r\n        break;\r\n      case 0:\r\n        moveResult = checkCurrentPosition();\r\n        break;\r\n      default:\r\n        throw new IllegalStateException(\"Invalid movement value : \" + iMovement);\r\n      }\r\n\r\n      if (!moveResult)\r\n        return null;\r\n\r\n      try {\r\n        if (iRecord != null) {\r\n          ORecordInternal.setIdentity(iRecord, new ORecordId(current.getClusterId(), current.getClusterPosition()));\r\n          iRecord = database.load(iRecord, fetchPlan, false);\r\n        } else\r\n          iRecord = database.load(current, fetchPlan, false);\r\n      } catch (ODatabaseException e) {\r\n        if (Thread.interrupted() || database.isClosed())\r\n          // THREAD INTERRUPTED: RETURN\r\n          throw e;\r\n\r\n        if (e.getCause() instanceof OSecurityException)\r\n          throw e;\r\n\r\n        brokenRIDs.add(current.copy());\r\n\r\n        OLogManager.instance().error(this, \"Error on fetching record during browsing. The record has been skipped\", e);\r\n      }\r\n\r\n      if (iRecord != null) {\r\n        browsedRecords++;\r\n        return iRecord;\r\n      }\r\n    } while (iMovement != 0);\r\n\r\n    return null;\r\n  }", "code_tokens": ["protected", "ORecord", "readCurrentRecord", "(", "ORecord", "iRecord", ",", "final", "int", "iMovement", ")", "{", "if", "(", "limit", ">", "-", "1", "&&", "browsedRecords", ">=", "limit", ")", "// LIMIT REACHED\r", "return", "null", ";", "do", "{", "final", "boolean", "moveResult", ";", "switch", "(", "iMovement", ")", "{", "case", "1", ":", "moveResult", "=", "nextPosition", "(", ")", ";", "break", ";", "case", "-", "1", ":", "moveResult", "=", "prevPosition", "(", ")", ";", "break", ";", "case", "0", ":", "moveResult", "=", "checkCurrentPosition", "(", ")", ";", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"Invalid movement value : \"", "+", "iMovement", ")", ";", "}", "if", "(", "!", "moveResult", ")", "return", "null", ";", "try", "{", "if", "(", "iRecord", "!=", "null", ")", "{", "ORecordInternal", ".", "setIdentity", "(", "iRecord", ",", "new", "ORecordId", "(", "current", ".", "getClusterId", "(", ")", ",", "current", ".", "getClusterPosition", "(", ")", ")", ")", ";", "iRecord", "=", "database", ".", "load", "(", "iRecord", ",", "fetchPlan", ",", "false", ")", ";", "}", "else", "iRecord", "=", "database", ".", "load", "(", "current", ",", "fetchPlan", ",", "false", ")", ";", "}", "catch", "(", "ODatabaseException", "e", ")", "{", "if", "(", "Thread", ".", "interrupted", "(", ")", "||", "database", ".", "isClosed", "(", ")", ")", "// THREAD INTERRUPTED: RETURN\r", "throw", "e", ";", "if", "(", "e", ".", "getCause", "(", ")", "instanceof", "OSecurityException", ")", "throw", "e", ";", "brokenRIDs", ".", "add", "(", "current", ".", "copy", "(", ")", ")", ";", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error on fetching record during browsing. The record has been skipped\"", ",", "e", ")", ";", "}", "if", "(", "iRecord", "!=", "null", ")", "{", "browsedRecords", "++", ";", "return", "iRecord", ";", "}", "}", "while", "(", "iMovement", "!=", "0", ")", ";", "return", "null", ";", "}"], "docstring": "Read the current record and increment the counter if the record was found.\n\n@param iRecord to read value from database inside it. If record is null link will be created and stored in it.\n\n@return record which was read from db.", "docstring_tokens": ["Read", "the", "current", "record", "and", "increment", "the", "counter", "if", "the", "record", "was", "found", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/iterator/OIdentifiableIterator.java#L259-L309", "partition": "test", "index": 3197, "time": "2012-08-09 07:23:42"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java", "func_name": "OObjectDatabaseTx.detach", "original_string": "public <RET> RET detach(final Object iPojo, boolean returnNonProxiedInstance) {\r\n    return (RET) OObjectEntitySerializer.detach(iPojo, this, returnNonProxiedInstance);\r\n  }", "language": "java", "code": "public <RET> RET detach(final Object iPojo, boolean returnNonProxiedInstance) {\r\n    return (RET) OObjectEntitySerializer.detach(iPojo, this, returnNonProxiedInstance);\r\n  }", "code_tokens": ["public", "<", "RET", ">", "RET", "detach", "(", "final", "Object", "iPojo", ",", "boolean", "returnNonProxiedInstance", ")", "{", "return", "(", "RET", ")", "OObjectEntitySerializer", ".", "detach", "(", "iPojo", ",", "this", ",", "returnNonProxiedInstance", ")", ";", "}"], "docstring": "Method that detaches all fields contained in the document to the given object.\n\n@param <RET>\n@param iPojo                    :- the object to detach\n@param returnNonProxiedInstance :- defines if the return object will be a proxied instance or not. If set to TRUE and the\nobject does not contains @Id and @Version fields it could procude data replication\n\n@return the object serialized or with detached data", "docstring_tokens": ["Method", "that", "detaches", "all", "fields", "contained", "in", "the", "document", "to", "the", "given", "object", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java#L351-L353", "partition": "test", "index": 3139, "time": "2012-08-30 12:42:12"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java", "func_name": "OObjectDatabaseTx.getVersion", "original_string": "public int getVersion(final Object iPojo) {\r\n    checkOpenness();\r\n    final ODocument record = getRecordByUserObject(iPojo, false);\r\n    if (record != null)\r\n      return record.getVersion();\r\n\r\n    return OObjectSerializerHelper.getObjectVersion(iPojo);\r\n  }", "language": "java", "code": "public int getVersion(final Object iPojo) {\r\n    checkOpenness();\r\n    final ODocument record = getRecordByUserObject(iPojo, false);\r\n    if (record != null)\r\n      return record.getVersion();\r\n\r\n    return OObjectSerializerHelper.getObjectVersion(iPojo);\r\n  }", "code_tokens": ["public", "int", "getVersion", "(", "final", "Object", "iPojo", ")", "{", "checkOpenness", "(", ")", ";", "final", "ODocument", "record", "=", "getRecordByUserObject", "(", "iPojo", ",", "false", ")", ";", "if", "(", "record", "!=", "null", ")", "return", "record", ".", "getVersion", "(", ")", ";", "return", "OObjectSerializerHelper", ".", "getObjectVersion", "(", "iPojo", ")", ";", "}"], "docstring": "Returns the version number of the object. Version starts from 0 assigned on creation.\n\n@param iPojo User object", "docstring_tokens": ["Returns", "the", "version", "number", "of", "the", "object", ".", "Version", "starts", "from", "0", "assigned", "on", "creation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java#L705-L712", "partition": "test", "index": 3140, "time": "2012-08-30 12:42:12"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/script/OScriptManager.java", "func_name": "OScriptManager.releaseDatabaseEngine", "original_string": "public void releaseDatabaseEngine(final String iLanguage, final String iDatabaseName,\r\n      final OPartitionedObjectPool.PoolEntry<ScriptEngine> poolEntry) {\r\n    final ODatabaseScriptManager dbManager = dbManagers.get(iDatabaseName);\r\n    // We check if there is still a valid pool because it could be removed by the function reload\r\n    if (dbManager != null) {\r\n      dbManager.releaseEngine(iLanguage, poolEntry);\r\n    }\r\n\r\n  }", "language": "java", "code": "public void releaseDatabaseEngine(final String iLanguage, final String iDatabaseName,\r\n      final OPartitionedObjectPool.PoolEntry<ScriptEngine> poolEntry) {\r\n    final ODatabaseScriptManager dbManager = dbManagers.get(iDatabaseName);\r\n    // We check if there is still a valid pool because it could be removed by the function reload\r\n    if (dbManager != null) {\r\n      dbManager.releaseEngine(iLanguage, poolEntry);\r\n    }\r\n\r\n  }", "code_tokens": ["public", "void", "releaseDatabaseEngine", "(", "final", "String", "iLanguage", ",", "final", "String", "iDatabaseName", ",", "final", "OPartitionedObjectPool", ".", "PoolEntry", "<", "ScriptEngine", ">", "poolEntry", ")", "{", "final", "ODatabaseScriptManager", "dbManager", "=", "dbManagers", ".", "get", "(", "iDatabaseName", ")", ";", "// We check if there is still a valid pool because it could be removed by the function reload\r", "if", "(", "dbManager", "!=", "null", ")", "{", "dbManager", ".", "releaseEngine", "(", "iLanguage", ",", "poolEntry", ")", ";", "}", "}"], "docstring": "Acquires a database engine from the pool. Once finished using it, the instance MUST be returned in the pool by calling the\nmethod\n\n@param iLanguage     Script language\n@param iDatabaseName Database name\n@param poolEntry     Pool entry to free\n@see #acquireDatabaseEngine(String, String)", "docstring_tokens": ["Acquires", "a", "database", "engine", "from", "the", "pool", ".", "Once", "finished", "using", "it", "the", "instance", "MUST", "be", "returned", "in", "the", "pool", "by", "calling", "the", "method"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/script/OScriptManager.java#L220-L228", "partition": "test", "index": 3154, "time": "2012-09-20 13:09:03"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/script/OScriptManager.java", "func_name": "OScriptManager.getLibrary", "original_string": "public String getLibrary(final ODatabase<?> db, final String iLanguage) {\r\n    if (db == null)\r\n      // NO DB = NO LIBRARY\r\n      return null;\r\n\r\n    final StringBuilder code = new StringBuilder();\r\n\r\n    final Set<String> functions = db.getMetadata().getFunctionLibrary().getFunctionNames();\r\n    for (String fName : functions) {\r\n      final OFunction f = db.getMetadata().getFunctionLibrary().getFunction(fName);\r\n\r\n      if (f.getLanguage() == null)\r\n        throw new OConfigurationException(\"Database function '\" + fName + \"' has no language\");\r\n\r\n      if (f.getLanguage().equalsIgnoreCase(iLanguage)) {\r\n        final String def = getFunctionDefinition(f);\r\n        if (def != null) {\r\n          code.append(def);\r\n          code.append(\"\\n\");\r\n        }\r\n      }\r\n    }\r\n\r\n    return code.length() == 0 ? null : code.toString();\r\n  }", "language": "java", "code": "public String getLibrary(final ODatabase<?> db, final String iLanguage) {\r\n    if (db == null)\r\n      // NO DB = NO LIBRARY\r\n      return null;\r\n\r\n    final StringBuilder code = new StringBuilder();\r\n\r\n    final Set<String> functions = db.getMetadata().getFunctionLibrary().getFunctionNames();\r\n    for (String fName : functions) {\r\n      final OFunction f = db.getMetadata().getFunctionLibrary().getFunction(fName);\r\n\r\n      if (f.getLanguage() == null)\r\n        throw new OConfigurationException(\"Database function '\" + fName + \"' has no language\");\r\n\r\n      if (f.getLanguage().equalsIgnoreCase(iLanguage)) {\r\n        final String def = getFunctionDefinition(f);\r\n        if (def != null) {\r\n          code.append(def);\r\n          code.append(\"\\n\");\r\n        }\r\n      }\r\n    }\r\n\r\n    return code.length() == 0 ? null : code.toString();\r\n  }", "code_tokens": ["public", "String", "getLibrary", "(", "final", "ODatabase", "<", "?", ">", "db", ",", "final", "String", "iLanguage", ")", "{", "if", "(", "db", "==", "null", ")", "// NO DB = NO LIBRARY\r", "return", "null", ";", "final", "StringBuilder", "code", "=", "new", "StringBuilder", "(", ")", ";", "final", "Set", "<", "String", ">", "functions", "=", "db", ".", "getMetadata", "(", ")", ".", "getFunctionLibrary", "(", ")", ".", "getFunctionNames", "(", ")", ";", "for", "(", "String", "fName", ":", "functions", ")", "{", "final", "OFunction", "f", "=", "db", ".", "getMetadata", "(", ")", ".", "getFunctionLibrary", "(", ")", ".", "getFunction", "(", "fName", ")", ";", "if", "(", "f", ".", "getLanguage", "(", ")", "==", "null", ")", "throw", "new", "OConfigurationException", "(", "\"Database function '\"", "+", "fName", "+", "\"' has no language\"", ")", ";", "if", "(", "f", ".", "getLanguage", "(", ")", ".", "equalsIgnoreCase", "(", "iLanguage", ")", ")", "{", "final", "String", "def", "=", "getFunctionDefinition", "(", "f", ")", ";", "if", "(", "def", "!=", "null", ")", "{", "code", ".", "append", "(", "def", ")", ";", "code", ".", "append", "(", "\"\\n\"", ")", ";", "}", "}", "}", "return", "code", ".", "length", "(", ")", "==", "0", "?", "null", ":", "code", ".", "toString", "(", ")", ";", "}"], "docstring": "Formats the library of functions for a language.\n\n@param db        Current database instance\n@param iLanguage Language as filter\n@return String containing all the functions", "docstring_tokens": ["Formats", "the", "library", "of", "functions", "for", "a", "language", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/script/OScriptManager.java#L138-L162", "partition": "test", "index": 3153, "time": "2012-09-20 13:09:03"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/record/impl/ODocumentHelper.java", "func_name": "ODocumentHelper.getMapEntry", "original_string": "@SuppressWarnings(\"unchecked\")\r\n  public static Object getMapEntry(final Map<String, ?> iMap, final Object iKey) {\r\n    if (iMap == null || iKey == null)\r\n      return null;\r\n\r\n    if (iKey instanceof String) {\r\n      String iName = (String) iKey;\r\n      int pos = iName.indexOf('.');\r\n      if (pos > -1)\r\n        iName = iName.substring(0, pos);\r\n\r\n      final Object value = iMap.get(iName);\r\n      if (value == null)\r\n        return null;\r\n\r\n      if (pos > -1) {\r\n        final String restFieldName = iName.substring(pos + 1);\r\n        if (value instanceof ODocument)\r\n          return getFieldValue(value, restFieldName);\r\n        else if (value instanceof Map<?, ?>)\r\n          return getMapEntry((Map<String, ?>) value, restFieldName);\r\n      }\r\n\r\n      return value;\r\n    } else\r\n      return iMap.get(iKey);\r\n  }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\r\n  public static Object getMapEntry(final Map<String, ?> iMap, final Object iKey) {\r\n    if (iMap == null || iKey == null)\r\n      return null;\r\n\r\n    if (iKey instanceof String) {\r\n      String iName = (String) iKey;\r\n      int pos = iName.indexOf('.');\r\n      if (pos > -1)\r\n        iName = iName.substring(0, pos);\r\n\r\n      final Object value = iMap.get(iName);\r\n      if (value == null)\r\n        return null;\r\n\r\n      if (pos > -1) {\r\n        final String restFieldName = iName.substring(pos + 1);\r\n        if (value instanceof ODocument)\r\n          return getFieldValue(value, restFieldName);\r\n        else if (value instanceof Map<?, ?>)\r\n          return getMapEntry((Map<String, ?>) value, restFieldName);\r\n      }\r\n\r\n      return value;\r\n    } else\r\n      return iMap.get(iKey);\r\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "static", "Object", "getMapEntry", "(", "final", "Map", "<", "String", ",", "?", ">", "iMap", ",", "final", "Object", "iKey", ")", "{", "if", "(", "iMap", "==", "null", "||", "iKey", "==", "null", ")", "return", "null", ";", "if", "(", "iKey", "instanceof", "String", ")", "{", "String", "iName", "=", "(", "String", ")", "iKey", ";", "int", "pos", "=", "iName", ".", "indexOf", "(", "'", "'", ")", ";", "if", "(", "pos", ">", "-", "1", ")", "iName", "=", "iName", ".", "substring", "(", "0", ",", "pos", ")", ";", "final", "Object", "value", "=", "iMap", ".", "get", "(", "iName", ")", ";", "if", "(", "value", "==", "null", ")", "return", "null", ";", "if", "(", "pos", ">", "-", "1", ")", "{", "final", "String", "restFieldName", "=", "iName", ".", "substring", "(", "pos", "+", "1", ")", ";", "if", "(", "value", "instanceof", "ODocument", ")", "return", "getFieldValue", "(", "value", ",", "restFieldName", ")", ";", "else", "if", "(", "value", "instanceof", "Map", "<", "?", ",", "?", ">", ")", "return", "getMapEntry", "(", "(", "Map", "<", "String", ",", "?", ">", ")", "value", ",", "restFieldName", ")", ";", "}", "return", "value", ";", "}", "else", "return", "iMap", ".", "get", "(", "iKey", ")", ";", "}"], "docstring": "Retrieves the value crossing the map with the dotted notation\n\n@param iKey Field(s) to retrieve. If are multiple fields, then the dot must be used as separator\n@param iMap\n\n@return", "docstring_tokens": ["Retrieves", "the", "value", "crossing", "the", "map", "with", "the", "dotted", "notation"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/record/impl/ODocumentHelper.java#L724-L750", "partition": "test", "index": 3195, "time": "2012-09-24 17:51:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/OCommandRequestTextAbstract.java", "func_name": "OCommandRequestTextAbstract.execute", "original_string": "@SuppressWarnings(\"unchecked\")\r\n  public <RET> RET execute(final Object... iArgs) {\r\n    setParameters(iArgs);\r\n\r\n    OExecutionThreadLocal.INSTANCE.get().onAsyncReplicationOk = onAsyncReplicationOk;\r\n    OExecutionThreadLocal.INSTANCE.get().onAsyncReplicationError = onAsyncReplicationError;\r\n\r\n    return (RET) ODatabaseRecordThreadLocal.instance().get().getStorage().command(this);\r\n  }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\r\n  public <RET> RET execute(final Object... iArgs) {\r\n    setParameters(iArgs);\r\n\r\n    OExecutionThreadLocal.INSTANCE.get().onAsyncReplicationOk = onAsyncReplicationOk;\r\n    OExecutionThreadLocal.INSTANCE.get().onAsyncReplicationError = onAsyncReplicationError;\r\n\r\n    return (RET) ODatabaseRecordThreadLocal.instance().get().getStorage().command(this);\r\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "<", "RET", ">", "RET", "execute", "(", "final", "Object", "...", "iArgs", ")", "{", "setParameters", "(", "iArgs", ")", ";", "OExecutionThreadLocal", ".", "INSTANCE", ".", "get", "(", ")", ".", "onAsyncReplicationOk", "=", "onAsyncReplicationOk", ";", "OExecutionThreadLocal", ".", "INSTANCE", ".", "get", "(", ")", ".", "onAsyncReplicationError", "=", "onAsyncReplicationError", ";", "return", "(", "RET", ")", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ".", "getStorage", "(", ")", ".", "command", "(", "this", ")", ";", "}"], "docstring": "Delegates the execution to the configured command executor.", "docstring_tokens": ["Delegates", "the", "execution", "to", "the", "configured", "command", "executor", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/OCommandRequestTextAbstract.java#L61-L69", "partition": "test", "index": 3317, "time": "2012-09-27 00:53:57"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/enumerations/OObjectEnumLazyMap.java", "func_name": "OObjectEnumLazyMap.convertAll", "original_string": "protected void convertAll() {\r\n    if (converted)\r\n      return;\r\n\r\n    for (java.util.Map.Entry<Object, Object> e : underlying.entrySet()) {\r\n      if (e.getValue() instanceof Number)\r\n        super.put(e.getKey(), enumClass.getEnumConstants()[((Number) e.getValue()).intValue()]);\r\n      else\r\n        super.put(e.getKey(), Enum.valueOf(enumClass, e.getValue().toString()));\r\n    }\r\n\r\n    converted = true;\r\n  }", "language": "java", "code": "protected void convertAll() {\r\n    if (converted)\r\n      return;\r\n\r\n    for (java.util.Map.Entry<Object, Object> e : underlying.entrySet()) {\r\n      if (e.getValue() instanceof Number)\r\n        super.put(e.getKey(), enumClass.getEnumConstants()[((Number) e.getValue()).intValue()]);\r\n      else\r\n        super.put(e.getKey(), Enum.valueOf(enumClass, e.getValue().toString()));\r\n    }\r\n\r\n    converted = true;\r\n  }", "code_tokens": ["protected", "void", "convertAll", "(", ")", "{", "if", "(", "converted", ")", "return", ";", "for", "(", "java", ".", "util", ".", "Map", ".", "Entry", "<", "Object", ",", "Object", ">", "e", ":", "underlying", ".", "entrySet", "(", ")", ")", "{", "if", "(", "e", ".", "getValue", "(", ")", "instanceof", "Number", ")", "super", ".", "put", "(", "e", ".", "getKey", "(", ")", ",", "enumClass", ".", "getEnumConstants", "(", ")", "[", "(", "(", "Number", ")", "e", ".", "getValue", "(", ")", ")", ".", "intValue", "(", ")", "]", ")", ";", "else", "super", ".", "put", "(", "e", ".", "getKey", "(", ")", ",", "Enum", ".", "valueOf", "(", "enumClass", ",", "e", ".", "getValue", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "}", "converted", "=", "true", ";", "}"], "docstring": "Converts all the items", "docstring_tokens": ["Converts", "all", "the", "items"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/enumerations/OObjectEnumLazyMap.java#L181-L193", "partition": "test", "index": 3260, "time": "2012-09-28 14:12:38"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/enumerations/OObjectEnumLazyMap.java", "func_name": "OObjectEnumLazyMap.convert", "original_string": "private void convert(final Object iKey) {\r\n    if (converted)\r\n      return;\r\n\r\n    if (super.containsKey(iKey))\r\n      return;\r\n\r\n    Object o = underlying.get(String.valueOf(iKey));\r\n    if (o instanceof Number)\r\n      super.put(iKey, enumClass.getEnumConstants()[((Number) o).intValue()]);\r\n    else\r\n      super.put(iKey, Enum.valueOf(enumClass, o.toString()));\r\n  }", "language": "java", "code": "private void convert(final Object iKey) {\r\n    if (converted)\r\n      return;\r\n\r\n    if (super.containsKey(iKey))\r\n      return;\r\n\r\n    Object o = underlying.get(String.valueOf(iKey));\r\n    if (o instanceof Number)\r\n      super.put(iKey, enumClass.getEnumConstants()[((Number) o).intValue()]);\r\n    else\r\n      super.put(iKey, Enum.valueOf(enumClass, o.toString()));\r\n  }", "code_tokens": ["private", "void", "convert", "(", "final", "Object", "iKey", ")", "{", "if", "(", "converted", ")", "return", ";", "if", "(", "super", ".", "containsKey", "(", "iKey", ")", ")", "return", ";", "Object", "o", "=", "underlying", ".", "get", "(", "String", ".", "valueOf", "(", "iKey", ")", ")", ";", "if", "(", "o", "instanceof", "Number", ")", "super", ".", "put", "(", "iKey", ",", "enumClass", ".", "getEnumConstants", "(", ")", "[", "(", "(", "Number", ")", "o", ")", ".", "intValue", "(", ")", "]", ")", ";", "else", "super", ".", "put", "(", "iKey", ",", "Enum", ".", "valueOf", "(", "enumClass", ",", "o", ".", "toString", "(", ")", ")", ")", ";", "}"], "docstring": "Assure that the requested key is converted.", "docstring_tokens": ["Assure", "that", "the", "requested", "key", "is", "converted", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/enumerations/OObjectEnumLazyMap.java#L140-L152", "partition": "test", "index": 3259, "time": "2012-09-28 14:12:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/OJSONReader.java", "func_name": "OJSONReader.nextChar", "original_string": "public int nextChar() throws IOException {\r\n    if (missedChar != null) {\r\n      // RETURNS THE PREVIOUS PARSED CHAR\r\n      c = missedChar.charValue();\r\n      missedChar = null;\r\n\r\n    } else {\r\n      int read = in.read();\r\n      if (read == -1)\r\n        return -1;\r\n\r\n      c = (char) read;\r\n\r\n      if (c == '\\\\') {\r\n        read = in.read();\r\n        if (read == -1)\r\n          return -1;\r\n\r\n        char c2 = (char) read;\r\n        if (c2 == 'u') {\r\n          // DECODE UNICODE CHAR\r\n          final StringBuilder buff = new StringBuilder(8);\r\n          for (int i = 0; i < 4; ++i) {\r\n            read = in.read();\r\n            if (read == -1)\r\n              return -1;\r\n\r\n            buff.append((char) read);\r\n          }\r\n\r\n          cursor += 6;\r\n\r\n          return (char) Integer.parseInt(buff.toString(), 16);\r\n        } else {\r\n          // REMEMBER THE CURRENT CHAR TO RETURN NEXT TIME\r\n          missedChar = c2;\r\n        }\r\n      }\r\n    }\r\n\r\n    cursor++;\r\n\r\n    if (c == NEW_LINE) {\r\n      ++lineNumber;\r\n      columnNumber = 0;\r\n    } else\r\n      ++columnNumber;\r\n\r\n    return (char) c;\r\n  }", "language": "java", "code": "public int nextChar() throws IOException {\r\n    if (missedChar != null) {\r\n      // RETURNS THE PREVIOUS PARSED CHAR\r\n      c = missedChar.charValue();\r\n      missedChar = null;\r\n\r\n    } else {\r\n      int read = in.read();\r\n      if (read == -1)\r\n        return -1;\r\n\r\n      c = (char) read;\r\n\r\n      if (c == '\\\\') {\r\n        read = in.read();\r\n        if (read == -1)\r\n          return -1;\r\n\r\n        char c2 = (char) read;\r\n        if (c2 == 'u') {\r\n          // DECODE UNICODE CHAR\r\n          final StringBuilder buff = new StringBuilder(8);\r\n          for (int i = 0; i < 4; ++i) {\r\n            read = in.read();\r\n            if (read == -1)\r\n              return -1;\r\n\r\n            buff.append((char) read);\r\n          }\r\n\r\n          cursor += 6;\r\n\r\n          return (char) Integer.parseInt(buff.toString(), 16);\r\n        } else {\r\n          // REMEMBER THE CURRENT CHAR TO RETURN NEXT TIME\r\n          missedChar = c2;\r\n        }\r\n      }\r\n    }\r\n\r\n    cursor++;\r\n\r\n    if (c == NEW_LINE) {\r\n      ++lineNumber;\r\n      columnNumber = 0;\r\n    } else\r\n      ++columnNumber;\r\n\r\n    return (char) c;\r\n  }", "code_tokens": ["public", "int", "nextChar", "(", ")", "throws", "IOException", "{", "if", "(", "missedChar", "!=", "null", ")", "{", "// RETURNS THE PREVIOUS PARSED CHAR\r", "c", "=", "missedChar", ".", "charValue", "(", ")", ";", "missedChar", "=", "null", ";", "}", "else", "{", "int", "read", "=", "in", ".", "read", "(", ")", ";", "if", "(", "read", "==", "-", "1", ")", "return", "-", "1", ";", "c", "=", "(", "char", ")", "read", ";", "if", "(", "c", "==", "'", "'", ")", "{", "read", "=", "in", ".", "read", "(", ")", ";", "if", "(", "read", "==", "-", "1", ")", "return", "-", "1", ";", "char", "c2", "=", "(", "char", ")", "read", ";", "if", "(", "c2", "==", "'", "'", ")", "{", "// DECODE UNICODE CHAR\r", "final", "StringBuilder", "buff", "=", "new", "StringBuilder", "(", "8", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "4", ";", "++", "i", ")", "{", "read", "=", "in", ".", "read", "(", ")", ";", "if", "(", "read", "==", "-", "1", ")", "return", "-", "1", ";", "buff", ".", "append", "(", "(", "char", ")", "read", ")", ";", "}", "cursor", "+=", "6", ";", "return", "(", "char", ")", "Integer", ".", "parseInt", "(", "buff", ".", "toString", "(", ")", ",", "16", ")", ";", "}", "else", "{", "// REMEMBER THE CURRENT CHAR TO RETURN NEXT TIME\r", "missedChar", "=", "c2", ";", "}", "}", "}", "cursor", "++", ";", "if", "(", "c", "==", "NEW_LINE", ")", "{", "++", "lineNumber", ";", "columnNumber", "=", "0", ";", "}", "else", "++", "columnNumber", ";", "return", "(", "char", ")", "c", ";", "}"], "docstring": "Returns the next character from the input stream. Handles Unicode decoding.", "docstring_tokens": ["Returns", "the", "next", "character", "from", "the", "input", "stream", ".", "Handles", "Unicode", "decoding", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/OJSONReader.java#L259-L308", "partition": "test", "index": 2975, "time": "2012-09-30 15:23:24"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLCreateClass.java", "func_name": "OCommandExecutorSQLCreateClass.execute", "original_string": "public Object execute(final Map<Object, Object> iArgs) {\r\n    if (className == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    boolean alreadyExists = database.getMetadata().getSchema().existsClass(className);\r\n    if (!alreadyExists || !ifNotExists) {\r\n      if (clusters != null)\r\n        database.getMetadata().getSchema().createClass(className, clusters, superClasses.toArray(new OClass[0]));\r\n      else\r\n        database.getMetadata().getSchema().createClass(className, clusterIds, superClasses.toArray(new OClass[0]));\r\n    }\r\n    return database.getMetadata().getSchema().getClasses().size();\r\n  }", "language": "java", "code": "public Object execute(final Map<Object, Object> iArgs) {\r\n    if (className == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    boolean alreadyExists = database.getMetadata().getSchema().existsClass(className);\r\n    if (!alreadyExists || !ifNotExists) {\r\n      if (clusters != null)\r\n        database.getMetadata().getSchema().createClass(className, clusters, superClasses.toArray(new OClass[0]));\r\n      else\r\n        database.getMetadata().getSchema().createClass(className, clusterIds, superClasses.toArray(new OClass[0]));\r\n    }\r\n    return database.getMetadata().getSchema().getClasses().size();\r\n  }", "code_tokens": ["public", "Object", "execute", "(", "final", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "if", "(", "className", "==", "null", ")", "throw", "new", "OCommandExecutionException", "(", "\"Cannot execute the command because it has not been parsed yet\"", ")", ";", "final", "ODatabaseDocument", "database", "=", "getDatabase", "(", ")", ";", "boolean", "alreadyExists", "=", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "existsClass", "(", "className", ")", ";", "if", "(", "!", "alreadyExists", "||", "!", "ifNotExists", ")", "{", "if", "(", "clusters", "!=", "null", ")", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "createClass", "(", "className", ",", "clusters", ",", "superClasses", ".", "toArray", "(", "new", "OClass", "[", "0", "]", ")", ")", ";", "else", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "createClass", "(", "className", ",", "clusterIds", ",", "superClasses", ".", "toArray", "(", "new", "OClass", "[", "0", "]", ")", ")", ";", "}", "return", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClasses", "(", ")", ".", "size", "(", ")", ";", "}"], "docstring": "Execute the CREATE CLASS.", "docstring_tokens": ["Execute", "the", "CREATE", "CLASS", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLCreateClass.java#L234-L248", "partition": "test", "index": 3324, "time": "2012-10-19 23:35:47"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/security/OUser.java", "func_name": "OUser.allow", "original_string": "public ORole allow(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {\r\n    if (roles == null || roles.isEmpty()) {\r\n      if (document.field(\"roles\") != null && !((Collection<OIdentifiable>) document.field(\"roles\")).isEmpty()) {\r\n        final ODocument doc = document;\r\n        document = null;\r\n        fromStream(doc);\r\n      } else\r\n        throw new OSecurityAccessException(document.getDatabase().getName(),\r\n            \"User '\" + document.field(\"name\") + \"' has no role defined\");\r\n    }\r\n\r\n    final ORole role = checkIfAllowed(resourceGeneric, resourceSpecific, iOperation);\r\n\r\n    if (role == null)\r\n      throw new OSecurityAccessException(document.getDatabase().getName(),\r\n          \"User '\" + document.field(\"name\") + \"' does not have permission to execute the operation '\" + ORole\r\n              .permissionToString(iOperation) + \"' against the resource: \" + resourceGeneric + \".\" + resourceSpecific);\r\n\r\n    return role;\r\n  }", "language": "java", "code": "public ORole allow(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {\r\n    if (roles == null || roles.isEmpty()) {\r\n      if (document.field(\"roles\") != null && !((Collection<OIdentifiable>) document.field(\"roles\")).isEmpty()) {\r\n        final ODocument doc = document;\r\n        document = null;\r\n        fromStream(doc);\r\n      } else\r\n        throw new OSecurityAccessException(document.getDatabase().getName(),\r\n            \"User '\" + document.field(\"name\") + \"' has no role defined\");\r\n    }\r\n\r\n    final ORole role = checkIfAllowed(resourceGeneric, resourceSpecific, iOperation);\r\n\r\n    if (role == null)\r\n      throw new OSecurityAccessException(document.getDatabase().getName(),\r\n          \"User '\" + document.field(\"name\") + \"' does not have permission to execute the operation '\" + ORole\r\n              .permissionToString(iOperation) + \"' against the resource: \" + resourceGeneric + \".\" + resourceSpecific);\r\n\r\n    return role;\r\n  }", "code_tokens": ["public", "ORole", "allow", "(", "final", "ORule", ".", "ResourceGeneric", "resourceGeneric", ",", "String", "resourceSpecific", ",", "final", "int", "iOperation", ")", "{", "if", "(", "roles", "==", "null", "||", "roles", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "document", ".", "field", "(", "\"roles\"", ")", "!=", "null", "&&", "!", "(", "(", "Collection", "<", "OIdentifiable", ">", ")", "document", ".", "field", "(", "\"roles\"", ")", ")", ".", "isEmpty", "(", ")", ")", "{", "final", "ODocument", "doc", "=", "document", ";", "document", "=", "null", ";", "fromStream", "(", "doc", ")", ";", "}", "else", "throw", "new", "OSecurityAccessException", "(", "document", ".", "getDatabase", "(", ")", ".", "getName", "(", ")", ",", "\"User '\"", "+", "document", ".", "field", "(", "\"name\"", ")", "+", "\"' has no role defined\"", ")", ";", "}", "final", "ORole", "role", "=", "checkIfAllowed", "(", "resourceGeneric", ",", "resourceSpecific", ",", "iOperation", ")", ";", "if", "(", "role", "==", "null", ")", "throw", "new", "OSecurityAccessException", "(", "document", ".", "getDatabase", "(", ")", ".", "getName", "(", ")", ",", "\"User '\"", "+", "document", ".", "field", "(", "\"name\"", ")", "+", "\"' does not have permission to execute the operation '\"", "+", "ORole", ".", "permissionToString", "(", "iOperation", ")", "+", "\"' against the resource: \"", "+", "resourceGeneric", "+", "\".\"", "+", "resourceSpecific", ")", ";", "return", "role", ";", "}"], "docstring": "Checks if the user has the permission to access to the requested resource for the requested operation.\n\n@param iOperation Requested operation\n\n@return The role that has granted the permission if any, otherwise a OSecurityAccessException exception is raised\n\n@throws OSecurityAccessException", "docstring_tokens": ["Checks", "if", "the", "user", "has", "the", "permission", "to", "access", "to", "the", "requested", "resource", "for", "the", "requested", "operation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/security/OUser.java#L143-L162", "partition": "test", "index": 2932, "time": "2012-10-24 23:13:58"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/security/OUser.java", "func_name": "OUser.isRuleDefined", "original_string": "public boolean isRuleDefined(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific) {\r\n    for (ORole r : roles)\r\n      if (r == null)\r\n        OLogManager.instance()\r\n            .warn(this, \"User '%s' has a null role, bypass it. Consider to fix this user roles before to continue\", getName());\r\n      else if (r.hasRule(resourceGeneric, resourceSpecific))\r\n        return true;\r\n\r\n    return false;\r\n  }", "language": "java", "code": "public boolean isRuleDefined(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific) {\r\n    for (ORole r : roles)\r\n      if (r == null)\r\n        OLogManager.instance()\r\n            .warn(this, \"User '%s' has a null role, bypass it. Consider to fix this user roles before to continue\", getName());\r\n      else if (r.hasRule(resourceGeneric, resourceSpecific))\r\n        return true;\r\n\r\n    return false;\r\n  }", "code_tokens": ["public", "boolean", "isRuleDefined", "(", "final", "ORule", ".", "ResourceGeneric", "resourceGeneric", ",", "String", "resourceSpecific", ")", "{", "for", "(", "ORole", "r", ":", "roles", ")", "if", "(", "r", "==", "null", ")", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "this", ",", "\"User '%s' has a null role, bypass it. Consider to fix this user roles before to continue\"", ",", "getName", "(", ")", ")", ";", "else", "if", "(", "r", ".", "hasRule", "(", "resourceGeneric", ",", "resourceSpecific", ")", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Checks if a rule was defined for the user.\n\n@return True is a rule is defined, otherwise false", "docstring_tokens": ["Checks", "if", "a", "rule", "was", "defined", "for", "the", "user", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/security/OUser.java#L224-L233", "partition": "test", "index": 2933, "time": "2012-10-24 23:13:58"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/OBasicCommandContext.java", "func_name": "OBasicCommandContext.setChild", "original_string": "public OCommandContext setChild(final OCommandContext iContext) {\r\n    if (iContext == null) {\r\n      if (child != null) {\r\n        // REMOVE IT\r\n        child.setParent(null);\r\n        child = null;\r\n      }\r\n\r\n    } else if (child != iContext) {\r\n      // ADD IT\r\n      child = iContext;\r\n      iContext.setParent(this);\r\n    }\r\n    return this;\r\n  }", "language": "java", "code": "public OCommandContext setChild(final OCommandContext iContext) {\r\n    if (iContext == null) {\r\n      if (child != null) {\r\n        // REMOVE IT\r\n        child.setParent(null);\r\n        child = null;\r\n      }\r\n\r\n    } else if (child != iContext) {\r\n      // ADD IT\r\n      child = iContext;\r\n      iContext.setParent(this);\r\n    }\r\n    return this;\r\n  }", "code_tokens": ["public", "OCommandContext", "setChild", "(", "final", "OCommandContext", "iContext", ")", "{", "if", "(", "iContext", "==", "null", ")", "{", "if", "(", "child", "!=", "null", ")", "{", "// REMOVE IT\r", "child", ".", "setParent", "(", "null", ")", ";", "child", "=", "null", ";", "}", "}", "else", "if", "(", "child", "!=", "iContext", ")", "{", "// ADD IT\r", "child", "=", "iContext", ";", "iContext", ".", "setParent", "(", "this", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Set the inherited context avoiding to copy all the values every time.\n\n@return", "docstring_tokens": ["Set", "the", "inherited", "context", "avoiding", "to", "copy", "all", "the", "values", "every", "time", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/OBasicCommandContext.java#L252-L266", "partition": "test", "index": 3191, "time": "2012-10-29 19:01:41"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java", "func_name": "OCommandExecutorSQLSelect.handleResult", "original_string": "@Override\r\n  protected boolean handleResult(final OIdentifiable iRecord, final OCommandContext iContext) {\r\n    lastRecord = iRecord;\r\n\r\n    if ((orderedFields.isEmpty() || fullySortedByIndex || isRidOnlySort()) && skip > 0 && this.unwindFields == null\r\n        && this.expandTarget == null) {\r\n      lastRecord = null;\r\n      skip--;\r\n      return true;\r\n    }\r\n\r\n    if (!addResult(lastRecord, iContext)) {\r\n      return false;\r\n    }\r\n\r\n    return continueSearching();\r\n  }", "language": "java", "code": "@Override\r\n  protected boolean handleResult(final OIdentifiable iRecord, final OCommandContext iContext) {\r\n    lastRecord = iRecord;\r\n\r\n    if ((orderedFields.isEmpty() || fullySortedByIndex || isRidOnlySort()) && skip > 0 && this.unwindFields == null\r\n        && this.expandTarget == null) {\r\n      lastRecord = null;\r\n      skip--;\r\n      return true;\r\n    }\r\n\r\n    if (!addResult(lastRecord, iContext)) {\r\n      return false;\r\n    }\r\n\r\n    return continueSearching();\r\n  }", "code_tokens": ["@", "Override", "protected", "boolean", "handleResult", "(", "final", "OIdentifiable", "iRecord", ",", "final", "OCommandContext", "iContext", ")", "{", "lastRecord", "=", "iRecord", ";", "if", "(", "(", "orderedFields", ".", "isEmpty", "(", ")", "||", "fullySortedByIndex", "||", "isRidOnlySort", "(", ")", ")", "&&", "skip", ">", "0", "&&", "this", ".", "unwindFields", "==", "null", "&&", "this", ".", "expandTarget", "==", "null", ")", "{", "lastRecord", "=", "null", ";", "skip", "--", ";", "return", "true", ";", "}", "if", "(", "!", "addResult", "(", "lastRecord", ",", "iContext", ")", ")", "{", "return", "false", ";", "}", "return", "continueSearching", "(", ")", ";", "}"], "docstring": "Handles the record in result.\n\n@param iRecord Record to handle\n\n@return false if limit has been reached, otherwise true", "docstring_tokens": ["Handles", "the", "record", "in", "result", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java#L654-L670", "partition": "test", "index": 3310, "time": "2012-10-30 11:45:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java", "func_name": "OCommandExecutorSQLSelect.getInvolvedClusters", "original_string": "@Override\r\n  public Set<String> getInvolvedClusters() {\r\n\r\n    final Set<String> clusters = new HashSet<String>();\r\n\r\n    if (parsedTarget != null) {\r\n      final ODatabaseDocument db = getDatabase();\r\n\r\n      if (parsedTarget.getTargetQuery() != null && parsedTarget\r\n          .getTargetRecords() instanceof OCommandExecutorSQLResultsetDelegate) {\r\n        // SUB-QUERY: EXECUTE IT LOCALLY\r\n        // SUB QUERY, PROPAGATE THE CALL\r\n        final Set<String> clIds = ((OCommandExecutorSQLResultsetDelegate) parsedTarget.getTargetRecords()).getInvolvedClusters();\r\n        for (String c : clIds) {\r\n          // FILTER THE CLUSTER WHERE THE USER HAS THE RIGHT ACCESS\r\n          if (checkClusterAccess(db, c)) {\r\n            clusters.add(c);\r\n          }\r\n        }\r\n\r\n      } else if (parsedTarget.getTargetRecords() != null) {\r\n        // SINGLE RECORDS: BROWSE ALL (COULD BE EXPENSIVE).\r\n        for (OIdentifiable identifiable : parsedTarget.getTargetRecords()) {\r\n          final String c = db.getClusterNameById(identifiable.getIdentity().getClusterId()).toLowerCase(Locale.ENGLISH);\r\n          // FILTER THE CLUSTER WHERE THE USER HAS THE RIGHT ACCESS\r\n          if (checkClusterAccess(db, c)) {\r\n            clusters.add(c);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        return getInvolvedClustersOfClasses(parsedTarget.getTargetClasses().values());\r\n      }\r\n\r\n      if (parsedTarget.getTargetClusters() != null) {\r\n        return getInvolvedClustersOfClusters(parsedTarget.getTargetClusters().keySet());\r\n      }\r\n\r\n      if (parsedTarget.getTargetIndex() != null) {\r\n        // EXTRACT THE CLASS NAME -> CLUSTERS FROM THE INDEX DEFINITION\r\n        return getInvolvedClustersOfIndex(parsedTarget.getTargetIndex());\r\n      }\r\n\r\n    }\r\n    return clusters;\r\n  }", "language": "java", "code": "@Override\r\n  public Set<String> getInvolvedClusters() {\r\n\r\n    final Set<String> clusters = new HashSet<String>();\r\n\r\n    if (parsedTarget != null) {\r\n      final ODatabaseDocument db = getDatabase();\r\n\r\n      if (parsedTarget.getTargetQuery() != null && parsedTarget\r\n          .getTargetRecords() instanceof OCommandExecutorSQLResultsetDelegate) {\r\n        // SUB-QUERY: EXECUTE IT LOCALLY\r\n        // SUB QUERY, PROPAGATE THE CALL\r\n        final Set<String> clIds = ((OCommandExecutorSQLResultsetDelegate) parsedTarget.getTargetRecords()).getInvolvedClusters();\r\n        for (String c : clIds) {\r\n          // FILTER THE CLUSTER WHERE THE USER HAS THE RIGHT ACCESS\r\n          if (checkClusterAccess(db, c)) {\r\n            clusters.add(c);\r\n          }\r\n        }\r\n\r\n      } else if (parsedTarget.getTargetRecords() != null) {\r\n        // SINGLE RECORDS: BROWSE ALL (COULD BE EXPENSIVE).\r\n        for (OIdentifiable identifiable : parsedTarget.getTargetRecords()) {\r\n          final String c = db.getClusterNameById(identifiable.getIdentity().getClusterId()).toLowerCase(Locale.ENGLISH);\r\n          // FILTER THE CLUSTER WHERE THE USER HAS THE RIGHT ACCESS\r\n          if (checkClusterAccess(db, c)) {\r\n            clusters.add(c);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (parsedTarget.getTargetClasses() != null) {\r\n        return getInvolvedClustersOfClasses(parsedTarget.getTargetClasses().values());\r\n      }\r\n\r\n      if (parsedTarget.getTargetClusters() != null) {\r\n        return getInvolvedClustersOfClusters(parsedTarget.getTargetClusters().keySet());\r\n      }\r\n\r\n      if (parsedTarget.getTargetIndex() != null) {\r\n        // EXTRACT THE CLASS NAME -> CLUSTERS FROM THE INDEX DEFINITION\r\n        return getInvolvedClustersOfIndex(parsedTarget.getTargetIndex());\r\n      }\r\n\r\n    }\r\n    return clusters;\r\n  }", "code_tokens": ["@", "Override", "public", "Set", "<", "String", ">", "getInvolvedClusters", "(", ")", "{", "final", "Set", "<", "String", ">", "clusters", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "if", "(", "parsedTarget", "!=", "null", ")", "{", "final", "ODatabaseDocument", "db", "=", "getDatabase", "(", ")", ";", "if", "(", "parsedTarget", ".", "getTargetQuery", "(", ")", "!=", "null", "&&", "parsedTarget", ".", "getTargetRecords", "(", ")", "instanceof", "OCommandExecutorSQLResultsetDelegate", ")", "{", "// SUB-QUERY: EXECUTE IT LOCALLY\r", "// SUB QUERY, PROPAGATE THE CALL\r", "final", "Set", "<", "String", ">", "clIds", "=", "(", "(", "OCommandExecutorSQLResultsetDelegate", ")", "parsedTarget", ".", "getTargetRecords", "(", ")", ")", ".", "getInvolvedClusters", "(", ")", ";", "for", "(", "String", "c", ":", "clIds", ")", "{", "// FILTER THE CLUSTER WHERE THE USER HAS THE RIGHT ACCESS\r", "if", "(", "checkClusterAccess", "(", "db", ",", "c", ")", ")", "{", "clusters", ".", "add", "(", "c", ")", ";", "}", "}", "}", "else", "if", "(", "parsedTarget", ".", "getTargetRecords", "(", ")", "!=", "null", ")", "{", "// SINGLE RECORDS: BROWSE ALL (COULD BE EXPENSIVE).\r", "for", "(", "OIdentifiable", "identifiable", ":", "parsedTarget", ".", "getTargetRecords", "(", ")", ")", "{", "final", "String", "c", "=", "db", ".", "getClusterNameById", "(", "identifiable", ".", "getIdentity", "(", ")", ".", "getClusterId", "(", ")", ")", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ";", "// FILTER THE CLUSTER WHERE THE USER HAS THE RIGHT ACCESS\r", "if", "(", "checkClusterAccess", "(", "db", ",", "c", ")", ")", "{", "clusters", ".", "add", "(", "c", ")", ";", "}", "}", "}", "if", "(", "parsedTarget", ".", "getTargetClasses", "(", ")", "!=", "null", ")", "{", "return", "getInvolvedClustersOfClasses", "(", "parsedTarget", ".", "getTargetClasses", "(", ")", ".", "values", "(", ")", ")", ";", "}", "if", "(", "parsedTarget", ".", "getTargetClusters", "(", ")", "!=", "null", ")", "{", "return", "getInvolvedClustersOfClusters", "(", "parsedTarget", ".", "getTargetClusters", "(", ")", ".", "keySet", "(", ")", ")", ";", "}", "if", "(", "parsedTarget", ".", "getTargetIndex", "(", ")", "!=", "null", ")", "{", "// EXTRACT THE CLASS NAME -> CLUSTERS FROM THE INDEX DEFINITION\r", "return", "getInvolvedClustersOfIndex", "(", "parsedTarget", ".", "getTargetIndex", "(", ")", ")", ";", "}", "}", "return", "clusters", ";", "}"], "docstring": "Determine clusters that are used in select operation\n\n@return set of involved cluster names", "docstring_tokens": ["Determine", "clusters", "that", "are", "used", "in", "select", "operation"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java#L361-L407", "partition": "test", "index": 3309, "time": "2012-10-30 11:45:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLCreateCluster.java", "func_name": "OCommandExecutorSQLCreateCluster.execute", "original_string": "public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clusterName == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    final int clusterId = database.getClusterIdByName(clusterName);\r\n    if (clusterId > -1)\r\n      throw new OCommandSQLParsingException(\"Cluster '\" + clusterName + \"' already exists\");\r\n\r\n    if (blob) {\r\n      if (requestedId == -1) {\r\n        return database.addBlobCluster(clusterName);\r\n      } else {\r\n        throw new OCommandExecutionException(\"Request id not supported by blob cluster creation.\");\r\n      }\r\n    } else {\r\n      if (requestedId == -1) {\r\n        return database.addCluster(clusterName);\r\n      } else {\r\n        return database.addCluster(clusterName, requestedId, null);\r\n      }\r\n    }\r\n  }", "language": "java", "code": "public Object execute(final Map<Object, Object> iArgs) {\r\n    if (clusterName == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    final int clusterId = database.getClusterIdByName(clusterName);\r\n    if (clusterId > -1)\r\n      throw new OCommandSQLParsingException(\"Cluster '\" + clusterName + \"' already exists\");\r\n\r\n    if (blob) {\r\n      if (requestedId == -1) {\r\n        return database.addBlobCluster(clusterName);\r\n      } else {\r\n        throw new OCommandExecutionException(\"Request id not supported by blob cluster creation.\");\r\n      }\r\n    } else {\r\n      if (requestedId == -1) {\r\n        return database.addCluster(clusterName);\r\n      } else {\r\n        return database.addCluster(clusterName, requestedId, null);\r\n      }\r\n    }\r\n  }", "code_tokens": ["public", "Object", "execute", "(", "final", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "if", "(", "clusterName", "==", "null", ")", "throw", "new", "OCommandExecutionException", "(", "\"Cannot execute the command because it has not been parsed yet\"", ")", ";", "final", "ODatabaseDocument", "database", "=", "getDatabase", "(", ")", ";", "final", "int", "clusterId", "=", "database", ".", "getClusterIdByName", "(", "clusterName", ")", ";", "if", "(", "clusterId", ">", "-", "1", ")", "throw", "new", "OCommandSQLParsingException", "(", "\"Cluster '\"", "+", "clusterName", "+", "\"' already exists\"", ")", ";", "if", "(", "blob", ")", "{", "if", "(", "requestedId", "==", "-", "1", ")", "{", "return", "database", ".", "addBlobCluster", "(", "clusterName", ")", ";", "}", "else", "{", "throw", "new", "OCommandExecutionException", "(", "\"Request id not supported by blob cluster creation.\"", ")", ";", "}", "}", "else", "{", "if", "(", "requestedId", "==", "-", "1", ")", "{", "return", "database", ".", "addCluster", "(", "clusterName", ")", ";", "}", "else", "{", "return", "database", ".", "addCluster", "(", "clusterName", ",", "requestedId", ",", "null", ")", ";", "}", "}", "}"], "docstring": "Execute the CREATE CLUSTER.", "docstring_tokens": ["Execute", "the", "CREATE", "CLUSTER", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLCreateCluster.java#L107-L130", "partition": "test", "index": 3035, "time": "2012-10-30 23:26:31"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/operator/OQueryOperatorContainsText.java", "func_name": "OQueryOperatorContainsText.evaluateRecord", "original_string": "@Override\r\n  public Object evaluateRecord(final OIdentifiable iRecord, ODocument iCurrentResult, final OSQLFilterCondition iCondition,\r\n      final Object iLeft, final Object iRight, OCommandContext iContext, final ODocumentSerializer serializer) {\r\n    if (iLeft == null || iRight == null)\r\n      return false;\r\n\r\n    return iLeft.toString().indexOf(iRight.toString()) > -1;\r\n  }", "language": "java", "code": "@Override\r\n  public Object evaluateRecord(final OIdentifiable iRecord, ODocument iCurrentResult, final OSQLFilterCondition iCondition,\r\n      final Object iLeft, final Object iRight, OCommandContext iContext, final ODocumentSerializer serializer) {\r\n    if (iLeft == null || iRight == null)\r\n      return false;\r\n\r\n    return iLeft.toString().indexOf(iRight.toString()) > -1;\r\n  }", "code_tokens": ["@", "Override", "public", "Object", "evaluateRecord", "(", "final", "OIdentifiable", "iRecord", ",", "ODocument", "iCurrentResult", ",", "final", "OSQLFilterCondition", "iCondition", ",", "final", "Object", "iLeft", ",", "final", "Object", "iRight", ",", "OCommandContext", "iContext", ",", "final", "ODocumentSerializer", "serializer", ")", "{", "if", "(", "iLeft", "==", "null", "||", "iRight", "==", "null", ")", "return", "false", ";", "return", "iLeft", ".", "toString", "(", ")", ".", "indexOf", "(", "iRight", ".", "toString", "(", ")", ")", ">", "-", "1", ";", "}"], "docstring": "This is executed on non-indexed fields.", "docstring_tokens": ["This", "is", "executed", "on", "non", "-", "indexed", "fields", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/operator/OQueryOperatorContainsText.java#L69-L76", "partition": "test", "index": 2915, "time": "2013-01-05 16:45:01"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OClassImpl.java", "func_name": "OClassImpl.truncate", "original_string": "public void truncate() throws IOException {\n    ODatabaseDocumentInternal db = getDatabase();\n    db.checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_UPDATE);\n\n    if (isSubClassOf(OSecurityShared.RESTRICTED_CLASSNAME)) {\n      throw new OSecurityException(\n          \"Class '\" + getName() + \"' cannot be truncated because has record level security enabled (extends '\"\n              + OSecurityShared.RESTRICTED_CLASSNAME + \"')\");\n    }\n\n    final OStorage storage = db.getStorage();\n    acquireSchemaReadLock();\n    try {\n\n      for (int id : clusterIds) {\n        OCluster cl = storage.getClusterById(id);\n        db.checkForClusterPermissions(cl.getName());\n        cl.truncate();\n      }\n      for (OIndex<?> index : getClassIndexes())\n        index.clear();\n\n      Set<OIndex<?>> superclassIndexes = new HashSet<OIndex<?>>();\n      superclassIndexes.addAll(getIndexes());\n      superclassIndexes.removeAll(getClassIndexes());\n      for (OIndex index : superclassIndexes) {\n        index.rebuild();\n      }\n    } finally {\n      releaseSchemaReadLock();\n    }\n  }", "language": "java", "code": "public void truncate() throws IOException {\n    ODatabaseDocumentInternal db = getDatabase();\n    db.checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_UPDATE);\n\n    if (isSubClassOf(OSecurityShared.RESTRICTED_CLASSNAME)) {\n      throw new OSecurityException(\n          \"Class '\" + getName() + \"' cannot be truncated because has record level security enabled (extends '\"\n              + OSecurityShared.RESTRICTED_CLASSNAME + \"')\");\n    }\n\n    final OStorage storage = db.getStorage();\n    acquireSchemaReadLock();\n    try {\n\n      for (int id : clusterIds) {\n        OCluster cl = storage.getClusterById(id);\n        db.checkForClusterPermissions(cl.getName());\n        cl.truncate();\n      }\n      for (OIndex<?> index : getClassIndexes())\n        index.clear();\n\n      Set<OIndex<?>> superclassIndexes = new HashSet<OIndex<?>>();\n      superclassIndexes.addAll(getIndexes());\n      superclassIndexes.removeAll(getClassIndexes());\n      for (OIndex index : superclassIndexes) {\n        index.rebuild();\n      }\n    } finally {\n      releaseSchemaReadLock();\n    }\n  }", "code_tokens": ["public", "void", "truncate", "(", ")", "throws", "IOException", "{", "ODatabaseDocumentInternal", "db", "=", "getDatabase", "(", ")", ";", "db", ".", "checkSecurity", "(", "ORule", ".", "ResourceGeneric", ".", "CLASS", ",", "ORole", ".", "PERMISSION_UPDATE", ")", ";", "if", "(", "isSubClassOf", "(", "OSecurityShared", ".", "RESTRICTED_CLASSNAME", ")", ")", "{", "throw", "new", "OSecurityException", "(", "\"Class '\"", "+", "getName", "(", ")", "+", "\"' cannot be truncated because has record level security enabled (extends '\"", "+", "OSecurityShared", ".", "RESTRICTED_CLASSNAME", "+", "\"')\"", ")", ";", "}", "final", "OStorage", "storage", "=", "db", ".", "getStorage", "(", ")", ";", "acquireSchemaReadLock", "(", ")", ";", "try", "{", "for", "(", "int", "id", ":", "clusterIds", ")", "{", "OCluster", "cl", "=", "storage", ".", "getClusterById", "(", "id", ")", ";", "db", ".", "checkForClusterPermissions", "(", "cl", ".", "getName", "(", ")", ")", ";", "cl", ".", "truncate", "(", ")", ";", "}", "for", "(", "OIndex", "<", "?", ">", "index", ":", "getClassIndexes", "(", ")", ")", "index", ".", "clear", "(", ")", ";", "Set", "<", "OIndex", "<", "?", ">", ">", "superclassIndexes", "=", "new", "HashSet", "<", "OIndex", "<", "?", ">", ">", "(", ")", ";", "superclassIndexes", ".", "addAll", "(", "getIndexes", "(", ")", ")", ";", "superclassIndexes", ".", "removeAll", "(", "getClassIndexes", "(", ")", ")", ";", "for", "(", "OIndex", "index", ":", "superclassIndexes", ")", "{", "index", ".", "rebuild", "(", ")", ";", "}", "}", "finally", "{", "releaseSchemaReadLock", "(", ")", ";", "}", "}"], "docstring": "Truncates all the clusters the class uses.", "docstring_tokens": ["Truncates", "all", "the", "clusters", "the", "class", "uses", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OClassImpl.java#L871-L902", "partition": "test", "index": 3296, "time": "2013-03-27 16:10:26"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java", "func_name": "OServerAdmin.releaseDatabase", "original_string": "public synchronized OServerAdmin releaseDatabase(final String storageType) throws IOException {\r\n\r\n    OReleaseDatabaseRequest request = new OReleaseDatabaseRequest(storage.getName(), storageType);\r\n    OReleaseDatabaseResponse response = networkAdminOperation(request, \"Cannot release the remote storage: \" + storage.getName());\r\n\r\n    return this;\r\n  }", "language": "java", "code": "public synchronized OServerAdmin releaseDatabase(final String storageType) throws IOException {\r\n\r\n    OReleaseDatabaseRequest request = new OReleaseDatabaseRequest(storage.getName(), storageType);\r\n    OReleaseDatabaseResponse response = networkAdminOperation(request, \"Cannot release the remote storage: \" + storage.getName());\r\n\r\n    return this;\r\n  }", "code_tokens": ["public", "synchronized", "OServerAdmin", "releaseDatabase", "(", "final", "String", "storageType", ")", "throws", "IOException", "{", "OReleaseDatabaseRequest", "request", "=", "new", "OReleaseDatabaseRequest", "(", "storage", ".", "getName", "(", ")", ",", "storageType", ")", ";", "OReleaseDatabaseResponse", "response", "=", "networkAdminOperation", "(", "request", ",", "\"Cannot release the remote storage: \"", "+", "storage", ".", "getName", "(", ")", ")", ";", "return", "this", ";", "}"], "docstring": "Releases a frozen database.\n\n@param storageType Storage type between \"plocal\" or \"memory\".\n\n@return\n\n@throws IOException\n@see #freezeDatabase(String)", "docstring_tokens": ["Releases", "a", "frozen", "database", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java#L363-L369", "partition": "test", "index": 3227, "time": "2013-04-15 14:02:25"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLAbstract.java", "func_name": "OCommandExecutorSQLAbstract.parseTimeout", "original_string": "protected boolean parseTimeout(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_TIMEOUT))\r\n      return false;\r\n\r\n    String word = parserNextWord(true);\r\n\r\n    try {\r\n      timeoutMs = Long.parseLong(word);\r\n    } catch (NumberFormatException ignore) {\r\n      throwParsingException(\"Invalid \" + KEYWORD_TIMEOUT + \" value set to '\" + word + \"' but it should be a valid long. Example: \"\r\n          + KEYWORD_TIMEOUT + \" 3000\");\r\n    }\r\n\r\n    if (timeoutMs < 0)\r\n      throwParsingException(\"Invalid \" + KEYWORD_TIMEOUT + \": value set minor than ZERO. Example: \" + KEYWORD_TIMEOUT + \" 10000\");\r\n\r\n    word = parserNextWord(true);\r\n\r\n    if (word != null)\r\n      if (word.equals(TIMEOUT_STRATEGY.EXCEPTION.toString()))\r\n        timeoutStrategy = TIMEOUT_STRATEGY.EXCEPTION;\r\n      else if (word.equals(TIMEOUT_STRATEGY.RETURN.toString()))\r\n        timeoutStrategy = TIMEOUT_STRATEGY.RETURN;\r\n      else\r\n        parserGoBack();\r\n\r\n    return true;\r\n  }", "language": "java", "code": "protected boolean parseTimeout(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_TIMEOUT))\r\n      return false;\r\n\r\n    String word = parserNextWord(true);\r\n\r\n    try {\r\n      timeoutMs = Long.parseLong(word);\r\n    } catch (NumberFormatException ignore) {\r\n      throwParsingException(\"Invalid \" + KEYWORD_TIMEOUT + \" value set to '\" + word + \"' but it should be a valid long. Example: \"\r\n          + KEYWORD_TIMEOUT + \" 3000\");\r\n    }\r\n\r\n    if (timeoutMs < 0)\r\n      throwParsingException(\"Invalid \" + KEYWORD_TIMEOUT + \": value set minor than ZERO. Example: \" + KEYWORD_TIMEOUT + \" 10000\");\r\n\r\n    word = parserNextWord(true);\r\n\r\n    if (word != null)\r\n      if (word.equals(TIMEOUT_STRATEGY.EXCEPTION.toString()))\r\n        timeoutStrategy = TIMEOUT_STRATEGY.EXCEPTION;\r\n      else if (word.equals(TIMEOUT_STRATEGY.RETURN.toString()))\r\n        timeoutStrategy = TIMEOUT_STRATEGY.RETURN;\r\n      else\r\n        parserGoBack();\r\n\r\n    return true;\r\n  }", "code_tokens": ["protected", "boolean", "parseTimeout", "(", "final", "String", "w", ")", "throws", "OCommandSQLParsingException", "{", "if", "(", "!", "w", ".", "equals", "(", "KEYWORD_TIMEOUT", ")", ")", "return", "false", ";", "String", "word", "=", "parserNextWord", "(", "true", ")", ";", "try", "{", "timeoutMs", "=", "Long", ".", "parseLong", "(", "word", ")", ";", "}", "catch", "(", "NumberFormatException", "ignore", ")", "{", "throwParsingException", "(", "\"Invalid \"", "+", "KEYWORD_TIMEOUT", "+", "\" value set to '\"", "+", "word", "+", "\"' but it should be a valid long. Example: \"", "+", "KEYWORD_TIMEOUT", "+", "\" 3000\"", ")", ";", "}", "if", "(", "timeoutMs", "<", "0", ")", "throwParsingException", "(", "\"Invalid \"", "+", "KEYWORD_TIMEOUT", "+", "\": value set minor than ZERO. Example: \"", "+", "KEYWORD_TIMEOUT", "+", "\" 10000\"", ")", ";", "word", "=", "parserNextWord", "(", "true", ")", ";", "if", "(", "word", "!=", "null", ")", "if", "(", "word", ".", "equals", "(", "TIMEOUT_STRATEGY", ".", "EXCEPTION", ".", "toString", "(", ")", ")", ")", "timeoutStrategy", "=", "TIMEOUT_STRATEGY", ".", "EXCEPTION", ";", "else", "if", "(", "word", ".", "equals", "(", "TIMEOUT_STRATEGY", ".", "RETURN", ".", "toString", "(", ")", ")", ")", "timeoutStrategy", "=", "TIMEOUT_STRATEGY", ".", "RETURN", ";", "else", "parserGoBack", "(", ")", ";", "return", "true", ";", "}"], "docstring": "Parses the timeout keyword if found.", "docstring_tokens": ["Parses", "the", "timeout", "keyword", "if", "found", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLAbstract.java#L110-L137", "partition": "test", "index": 3009, "time": "2013-04-18 12:41:03"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OSQLEngine.java", "func_name": "OSQLEngine.getCommandNames", "original_string": "public static Set<String> getCommandNames() {\r\n    final Set<String> types = new HashSet<String>();\r\n    final Iterator<OCommandExecutorSQLFactory> ite = getCommandFactories();\r\n    while (ite.hasNext()) {\r\n      types.addAll(ite.next().getCommandNames());\r\n    }\r\n    return types;\r\n  }", "language": "java", "code": "public static Set<String> getCommandNames() {\r\n    final Set<String> types = new HashSet<String>();\r\n    final Iterator<OCommandExecutorSQLFactory> ite = getCommandFactories();\r\n    while (ite.hasNext()) {\r\n      types.addAll(ite.next().getCommandNames());\r\n    }\r\n    return types;\r\n  }", "code_tokens": ["public", "static", "Set", "<", "String", ">", "getCommandNames", "(", ")", "{", "final", "Set", "<", "String", ">", "types", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "final", "Iterator", "<", "OCommandExecutorSQLFactory", ">", "ite", "=", "getCommandFactories", "(", ")", ";", "while", "(", "ite", ".", "hasNext", "(", ")", ")", "{", "types", ".", "addAll", "(", "ite", ".", "next", "(", ")", ".", "getCommandNames", "(", ")", ")", ";", "}", "return", "types", ";", "}"], "docstring": "Iterates on all factories and append all command names.\n\n@return Set of all command names.", "docstring_tokens": ["Iterates", "on", "all", "factories", "and", "append", "all", "command", "names", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OSQLEngine.java#L281-L288", "partition": "test", "index": 3040, "time": "2013-04-26 00:15:11"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OSQLEngine.java", "func_name": "OSQLEngine.getFunctionNames", "original_string": "public static Set<String> getFunctionNames() {\r\n    final Set<String> types = new HashSet<String>();\r\n    final Iterator<OSQLFunctionFactory> ite = getFunctionFactories();\r\n    while (ite.hasNext()) {\r\n      types.addAll(ite.next().getFunctionNames());\r\n    }\r\n    return types;\r\n  }", "language": "java", "code": "public static Set<String> getFunctionNames() {\r\n    final Set<String> types = new HashSet<String>();\r\n    final Iterator<OSQLFunctionFactory> ite = getFunctionFactories();\r\n    while (ite.hasNext()) {\r\n      types.addAll(ite.next().getFunctionNames());\r\n    }\r\n    return types;\r\n  }", "code_tokens": ["public", "static", "Set", "<", "String", ">", "getFunctionNames", "(", ")", "{", "final", "Set", "<", "String", ">", "types", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "final", "Iterator", "<", "OSQLFunctionFactory", ">", "ite", "=", "getFunctionFactories", "(", ")", ";", "while", "(", "ite", ".", "hasNext", "(", ")", ")", "{", "types", ".", "addAll", "(", "ite", ".", "next", "(", ")", ".", "getFunctionNames", "(", ")", ")", ";", "}", "return", "types", ";", "}"], "docstring": "Iterates on all factories and append all function names.\n\n@return Set of all function names.", "docstring_tokens": ["Iterates", "on", "all", "factories", "and", "append", "all", "function", "names", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OSQLEngine.java#L244-L251", "partition": "test", "index": 3038, "time": "2013-04-26 00:15:11"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/core/entity/OEntityManager.java", "func_name": "OEntityManager.setClassHandler", "original_string": "public synchronized void setClassHandler(final OEntityManagerClassHandler iClassHandler) {\r\n    Iterator<Entry<String, Class<?>>> iterator = classHandler.getClassesEntrySet().iterator();\r\n    while (iterator.hasNext()){\r\n      Entry<String, Class<?>> entry = iterator.next();\r\n      boolean forceSchemaReload = !iterator.hasNext();\r\n      iClassHandler.registerEntityClass(entry.getValue(), forceSchemaReload);\r\n    }\r\n    this.classHandler = iClassHandler;\r\n  }", "language": "java", "code": "public synchronized void setClassHandler(final OEntityManagerClassHandler iClassHandler) {\r\n    Iterator<Entry<String, Class<?>>> iterator = classHandler.getClassesEntrySet().iterator();\r\n    while (iterator.hasNext()){\r\n      Entry<String, Class<?>> entry = iterator.next();\r\n      boolean forceSchemaReload = !iterator.hasNext();\r\n      iClassHandler.registerEntityClass(entry.getValue(), forceSchemaReload);\r\n    }\r\n    this.classHandler = iClassHandler;\r\n  }", "code_tokens": ["public", "synchronized", "void", "setClassHandler", "(", "final", "OEntityManagerClassHandler", "iClassHandler", ")", "{", "Iterator", "<", "Entry", "<", "String", ",", "Class", "<", "?", ">", ">", ">", "iterator", "=", "classHandler", ".", "getClassesEntrySet", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iterator", ".", "hasNext", "(", ")", ")", "{", "Entry", "<", "String", ",", "Class", "<", "?", ">", ">", "entry", "=", "iterator", ".", "next", "(", ")", ";", "boolean", "forceSchemaReload", "=", "!", "iterator", ".", "hasNext", "(", ")", ";", "iClassHandler", ".", "registerEntityClass", "(", "entry", ".", "getValue", "(", ")", ",", "forceSchemaReload", ")", ";", "}", "this", ".", "classHandler", "=", "iClassHandler", ";", "}"], "docstring": "Sets the received handler as default and merges the classes all together.\n\n@param iClassHandler", "docstring_tokens": ["Sets", "the", "received", "handler", "as", "default", "and", "merges", "the", "classes", "all", "together", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/core/entity/OEntityManager.java#L241-L249", "partition": "test", "index": 3170, "time": "2013-04-27 14:03:56"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/core/entity/OEntityManager.java", "func_name": "OEntityManager.createPojo", "original_string": "public synchronized Object createPojo(final String iClassName) throws OConfigurationException {\r\n    if (iClassName == null)\r\n      throw new IllegalArgumentException(\"Cannot create the object: class name is empty\");\r\n\r\n    final Class<?> entityClass = classHandler.getEntityClass(iClassName);\r\n\r\n    try {\r\n      if (entityClass != null)\r\n        return createInstance(entityClass);\r\n\r\n    } catch (Exception e) {\r\n      throw OException.wrapException(new OConfigurationException(\"Error while creating new pojo of class '\" + iClassName + \"'\"), e);\r\n    }\r\n\r\n    try {\r\n      // TRY TO INSTANTIATE THE CLASS DIRECTLY BY ITS NAME\r\n      return createInstance(Class.forName(iClassName));\r\n    } catch (Exception e) {\r\n      throw OException.wrapException(new OConfigurationException(\"The class '\" + iClassName\r\n          + \"' was not found between the entity classes. Ensure registerEntityClasses(package) has been called first\"), e);\r\n    }\r\n  }", "language": "java", "code": "public synchronized Object createPojo(final String iClassName) throws OConfigurationException {\r\n    if (iClassName == null)\r\n      throw new IllegalArgumentException(\"Cannot create the object: class name is empty\");\r\n\r\n    final Class<?> entityClass = classHandler.getEntityClass(iClassName);\r\n\r\n    try {\r\n      if (entityClass != null)\r\n        return createInstance(entityClass);\r\n\r\n    } catch (Exception e) {\r\n      throw OException.wrapException(new OConfigurationException(\"Error while creating new pojo of class '\" + iClassName + \"'\"), e);\r\n    }\r\n\r\n    try {\r\n      // TRY TO INSTANTIATE THE CLASS DIRECTLY BY ITS NAME\r\n      return createInstance(Class.forName(iClassName));\r\n    } catch (Exception e) {\r\n      throw OException.wrapException(new OConfigurationException(\"The class '\" + iClassName\r\n          + \"' was not found between the entity classes. Ensure registerEntityClasses(package) has been called first\"), e);\r\n    }\r\n  }", "code_tokens": ["public", "synchronized", "Object", "createPojo", "(", "final", "String", "iClassName", ")", "throws", "OConfigurationException", "{", "if", "(", "iClassName", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cannot create the object: class name is empty\"", ")", ";", "final", "Class", "<", "?", ">", "entityClass", "=", "classHandler", ".", "getEntityClass", "(", "iClassName", ")", ";", "try", "{", "if", "(", "entityClass", "!=", "null", ")", "return", "createInstance", "(", "entityClass", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OConfigurationException", "(", "\"Error while creating new pojo of class '\"", "+", "iClassName", "+", "\"'\"", ")", ",", "e", ")", ";", "}", "try", "{", "// TRY TO INSTANTIATE THE CLASS DIRECTLY BY ITS NAME\r", "return", "createInstance", "(", "Class", ".", "forName", "(", "iClassName", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OConfigurationException", "(", "\"The class '\"", "+", "iClassName", "+", "\"' was not found between the entity classes. Ensure registerEntityClasses(package) has been called first\"", ")", ",", "e", ")", ";", "}", "}"], "docstring": "Create a POJO by its class name.\n\n@see #registerEntityClasses(String)", "docstring_tokens": ["Create", "a", "POJO", "by", "its", "class", "name", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/core/entity/OEntityManager.java#L64-L85", "partition": "test", "index": 3167, "time": "2013-04-27 14:03:56"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/OBinaryProtocol.java", "func_name": "OBinaryProtocol.bytes2int", "original_string": "public static int bytes2int(final byte[] b, final int offset) {\r\n    return (b[offset]) << 24 | (0xff & b[offset + 1]) << 16 | (0xff & b[offset + 2]) << 8 | ((0xff & b[offset + 3]));\r\n  }", "language": "java", "code": "public static int bytes2int(final byte[] b, final int offset) {\r\n    return (b[offset]) << 24 | (0xff & b[offset + 1]) << 16 | (0xff & b[offset + 2]) << 8 | ((0xff & b[offset + 3]));\r\n  }", "code_tokens": ["public", "static", "int", "bytes2int", "(", "final", "byte", "[", "]", "b", ",", "final", "int", "offset", ")", "{", "return", "(", "b", "[", "offset", "]", ")", "<<", "24", "|", "(", "0xff", "&", "b", "[", "offset", "+", "1", "]", ")", "<<", "16", "|", "(", "0xff", "&", "b", "[", "offset", "+", "2", "]", ")", "<<", "8", "|", "(", "(", "0xff", "&", "b", "[", "offset", "+", "3", "]", ")", ")", ";", "}"], "docstring": "Convert the byte array to an int starting from the given offset.\n\n@param b      The byte array\n@param offset The array offset\n@return The integer", "docstring_tokens": ["Convert", "the", "byte", "array", "to", "an", "int", "starting", "from", "the", "given", "offset", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/OBinaryProtocol.java#L153-L155", "partition": "test", "index": 3303, "time": "2013-06-05 14:31:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/index/OIndexAbstract.java", "func_name": "OIndexAbstract.create", "original_string": "public OIndexInternal<?> create(final OIndexDefinition indexDefinition, final String clusterIndexName,\n      final Set<String> clustersToIndex, boolean rebuild, final OProgressListener progressListener,\n      final OBinarySerializer valueSerializer) {\n    acquireExclusiveLock();\n    try {\n      configuration = indexConfigurationInstance(new ODocument().setTrackingChanges(false));\n\n      this.indexDefinition = indexDefinition;\n\n      if (clustersToIndex != null)\n        this.clustersToIndex = new HashSet<>(clustersToIndex);\n      else\n        this.clustersToIndex = new HashSet<>();\n\n      // do not remove this, it is needed to remove index garbage if such one exists\n      try {\n        if (apiVersion == 0) {\n          removeValuesContainer();\n        }\n      } catch (Exception e) {\n        OLogManager.instance().error(this, \"Error during deletion of index '%s'\", e, name);\n      }\n\n      indexId = storage.addIndexEngine(name, algorithm, type, indexDefinition, valueSerializer, isAutomatic(), true, version, 1,\n          this instanceof OIndexMultiValues, getEngineProperties(), clustersToIndex, metadata);\n      apiVersion = OAbstractPaginatedStorage.extractEngineAPIVersion(indexId);\n\n      assert indexId >= 0;\n      assert apiVersion >= 0;\n\n      onIndexEngineChange(indexId);\n\n      if (rebuild)\n        fillIndex(progressListener, false);\n\n      updateConfiguration();\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Exception during index '%s' creation\", e, name);\n\n      while (true)\n        try {\n          if (indexId >= 0)\n            storage.deleteIndexEngine(indexId);\n          break;\n        } catch (OInvalidIndexEngineIdException ignore) {\n          doReloadIndexEngine();\n        } catch (Exception ex) {\n          OLogManager.instance().error(this, \"Exception during index '%s' deletion\", ex, name);\n        }\n\n      if (e instanceof OIndexException)\n        throw (OIndexException) e;\n\n      throw OException.wrapException(new OIndexException(\"Cannot create the index '\" + name + \"'\"), e);\n\n    } finally {\n      releaseExclusiveLock();\n    }\n\n    return this;\n  }", "language": "java", "code": "public OIndexInternal<?> create(final OIndexDefinition indexDefinition, final String clusterIndexName,\n      final Set<String> clustersToIndex, boolean rebuild, final OProgressListener progressListener,\n      final OBinarySerializer valueSerializer) {\n    acquireExclusiveLock();\n    try {\n      configuration = indexConfigurationInstance(new ODocument().setTrackingChanges(false));\n\n      this.indexDefinition = indexDefinition;\n\n      if (clustersToIndex != null)\n        this.clustersToIndex = new HashSet<>(clustersToIndex);\n      else\n        this.clustersToIndex = new HashSet<>();\n\n      // do not remove this, it is needed to remove index garbage if such one exists\n      try {\n        if (apiVersion == 0) {\n          removeValuesContainer();\n        }\n      } catch (Exception e) {\n        OLogManager.instance().error(this, \"Error during deletion of index '%s'\", e, name);\n      }\n\n      indexId = storage.addIndexEngine(name, algorithm, type, indexDefinition, valueSerializer, isAutomatic(), true, version, 1,\n          this instanceof OIndexMultiValues, getEngineProperties(), clustersToIndex, metadata);\n      apiVersion = OAbstractPaginatedStorage.extractEngineAPIVersion(indexId);\n\n      assert indexId >= 0;\n      assert apiVersion >= 0;\n\n      onIndexEngineChange(indexId);\n\n      if (rebuild)\n        fillIndex(progressListener, false);\n\n      updateConfiguration();\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Exception during index '%s' creation\", e, name);\n\n      while (true)\n        try {\n          if (indexId >= 0)\n            storage.deleteIndexEngine(indexId);\n          break;\n        } catch (OInvalidIndexEngineIdException ignore) {\n          doReloadIndexEngine();\n        } catch (Exception ex) {\n          OLogManager.instance().error(this, \"Exception during index '%s' deletion\", ex, name);\n        }\n\n      if (e instanceof OIndexException)\n        throw (OIndexException) e;\n\n      throw OException.wrapException(new OIndexException(\"Cannot create the index '\" + name + \"'\"), e);\n\n    } finally {\n      releaseExclusiveLock();\n    }\n\n    return this;\n  }", "code_tokens": ["public", "OIndexInternal", "<", "?", ">", "create", "(", "final", "OIndexDefinition", "indexDefinition", ",", "final", "String", "clusterIndexName", ",", "final", "Set", "<", "String", ">", "clustersToIndex", ",", "boolean", "rebuild", ",", "final", "OProgressListener", "progressListener", ",", "final", "OBinarySerializer", "valueSerializer", ")", "{", "acquireExclusiveLock", "(", ")", ";", "try", "{", "configuration", "=", "indexConfigurationInstance", "(", "new", "ODocument", "(", ")", ".", "setTrackingChanges", "(", "false", ")", ")", ";", "this", ".", "indexDefinition", "=", "indexDefinition", ";", "if", "(", "clustersToIndex", "!=", "null", ")", "this", ".", "clustersToIndex", "=", "new", "HashSet", "<>", "(", "clustersToIndex", ")", ";", "else", "this", ".", "clustersToIndex", "=", "new", "HashSet", "<>", "(", ")", ";", "// do not remove this, it is needed to remove index garbage if such one exists", "try", "{", "if", "(", "apiVersion", "==", "0", ")", "{", "removeValuesContainer", "(", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error during deletion of index '%s'\"", ",", "e", ",", "name", ")", ";", "}", "indexId", "=", "storage", ".", "addIndexEngine", "(", "name", ",", "algorithm", ",", "type", ",", "indexDefinition", ",", "valueSerializer", ",", "isAutomatic", "(", ")", ",", "true", ",", "version", ",", "1", ",", "this", "instanceof", "OIndexMultiValues", ",", "getEngineProperties", "(", ")", ",", "clustersToIndex", ",", "metadata", ")", ";", "apiVersion", "=", "OAbstractPaginatedStorage", ".", "extractEngineAPIVersion", "(", "indexId", ")", ";", "assert", "indexId", ">=", "0", ";", "assert", "apiVersion", ">=", "0", ";", "onIndexEngineChange", "(", "indexId", ")", ";", "if", "(", "rebuild", ")", "fillIndex", "(", "progressListener", ",", "false", ")", ";", "updateConfiguration", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Exception during index '%s' creation\"", ",", "e", ",", "name", ")", ";", "while", "(", "true", ")", "try", "{", "if", "(", "indexId", ">=", "0", ")", "storage", ".", "deleteIndexEngine", "(", "indexId", ")", ";", "break", ";", "}", "catch", "(", "OInvalidIndexEngineIdException", "ignore", ")", "{", "doReloadIndexEngine", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Exception during index '%s' deletion\"", ",", "ex", ",", "name", ")", ";", "}", "if", "(", "e", "instanceof", "OIndexException", ")", "throw", "(", "OIndexException", ")", "e", ";", "throw", "OException", ".", "wrapException", "(", "new", "OIndexException", "(", "\"Cannot create the index '\"", "+", "name", "+", "\"'\"", ")", ",", "e", ")", ";", "}", "finally", "{", "releaseExclusiveLock", "(", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Creates the index.\n\n@param clusterIndexName Cluster name where to place the TreeMap", "docstring_tokens": ["Creates", "the", "index", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/index/OIndexAbstract.java#L193-L253", "partition": "test", "index": 3002, "time": "2013-07-15 06:36:50"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java", "func_name": "OHttpResponseWrapper.send", "original_string": "public OHttpResponseWrapper send(final int iCode, final String iReason, final String iContentType, final Object iContent)\r\n      throws IOException {\r\n    response.send(iCode, iReason, iContentType, iContent, null);\r\n    return this;\r\n  }", "language": "java", "code": "public OHttpResponseWrapper send(final int iCode, final String iReason, final String iContentType, final Object iContent)\r\n      throws IOException {\r\n    response.send(iCode, iReason, iContentType, iContent, null);\r\n    return this;\r\n  }", "code_tokens": ["public", "OHttpResponseWrapper", "send", "(", "final", "int", "iCode", ",", "final", "String", "iReason", ",", "final", "String", "iContentType", ",", "final", "Object", "iContent", ")", "throws", "IOException", "{", "response", ".", "send", "(", "iCode", ",", "iReason", ",", "iContentType", ",", "iContent", ",", "null", ")", ";", "return", "this", ";", "}"], "docstring": "Sends the complete HTTP response in one call.\n\n@param iCode\nHTTP response's Code\n@param iReason\nResponse's reason\n@param iContentType\nResponse's content type\n@param iContent\nContent to send. Content can be a string for plain text, binary data to return directly binary information,\nOIdentifiable for a single record and Collection<OIdentifiable> for a collection of records\n@return The object itself for fluent chained calls", "docstring_tokens": ["Sends", "the", "complete", "HTTP", "response", "in", "one", "call", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java#L235-L239", "partition": "test", "index": 3046, "time": "2013-07-16 09:24:54"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java", "func_name": "OHttpResponseWrapper.writeRecord", "original_string": "public OHttpResponseWrapper writeRecord(final ORecord iRecord, final String iFetchPlan) throws IOException {\r\n    response.writeRecord(iRecord, iFetchPlan, null);\r\n    return this;\r\n  }", "language": "java", "code": "public OHttpResponseWrapper writeRecord(final ORecord iRecord, final String iFetchPlan) throws IOException {\r\n    response.writeRecord(iRecord, iFetchPlan, null);\r\n    return this;\r\n  }", "code_tokens": ["public", "OHttpResponseWrapper", "writeRecord", "(", "final", "ORecord", "iRecord", ",", "final", "String", "iFetchPlan", ")", "throws", "IOException", "{", "response", ".", "writeRecord", "(", "iRecord", ",", "iFetchPlan", ",", "null", ")", ";", "return", "this", ";", "}"], "docstring": "Writes a record as response. The record is serialized in JSON format.\n\n@param iRecord\nRecord to serialize\n@param iFetchPlan\nFetch plan to specify nested records\n@return The object itself for fluent chained calls", "docstring_tokens": ["Writes", "a", "record", "as", "response", ".", "The", "record", "is", "serialized", "in", "JSON", "format", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java#L216-L219", "partition": "test", "index": 3045, "time": "2013-07-16 09:24:54"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java", "func_name": "OHttpResponseWrapper.writeRecords", "original_string": "public OHttpResponseWrapper writeRecords(final Object iRecords, final String iFetchPlan) throws IOException {\r\n    response.writeRecords(iRecords, iFetchPlan);\r\n    return this;\r\n  }", "language": "java", "code": "public OHttpResponseWrapper writeRecords(final Object iRecords, final String iFetchPlan) throws IOException {\r\n    response.writeRecords(iRecords, iFetchPlan);\r\n    return this;\r\n  }", "code_tokens": ["public", "OHttpResponseWrapper", "writeRecords", "(", "final", "Object", "iRecords", ",", "final", "String", "iFetchPlan", ")", "throws", "IOException", "{", "response", ".", "writeRecords", "(", "iRecords", ",", "iFetchPlan", ")", ";", "return", "this", ";", "}"], "docstring": "Writes records as response specifying a fetch-plan to serialize nested records. The records are serialized in JSON format.\n\n@param iRecords\nList of records to serialize\n@param iFetchPlan\nFetch plan to specify nested records\n@return The object itself for fluent chained calls", "docstring_tokens": ["Writes", "records", "as", "response", "specifying", "a", "fetch", "-", "plan", "to", "serialize", "nested", "records", ".", "The", "records", "are", "serialized", "in", "JSON", "format", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java#L190-L193", "partition": "test", "index": 3044, "time": "2013-07-16 09:24:54"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java", "func_name": "OHttpResponseWrapper.writeHeaders", "original_string": "public OHttpResponseWrapper writeHeaders(final String iContentType, final boolean iKeepAlive) throws IOException {\r\n    response.writeHeaders(iContentType, iKeepAlive);\r\n    return this;\r\n  }", "language": "java", "code": "public OHttpResponseWrapper writeHeaders(final String iContentType, final boolean iKeepAlive) throws IOException {\r\n    response.writeHeaders(iContentType, iKeepAlive);\r\n    return this;\r\n  }", "code_tokens": ["public", "OHttpResponseWrapper", "writeHeaders", "(", "final", "String", "iContentType", ",", "final", "boolean", "iKeepAlive", ")", "throws", "IOException", "{", "response", ".", "writeHeaders", "(", "iContentType", ",", "iKeepAlive", ")", ";", "return", "this", ";", "}"], "docstring": "Sets the response's headers specifying when using the keep-alive or not.\n\n@param iContentType\nResponse's content type\n@param iKeepAlive\nUse the keep-alive of the connection\n@return The object itself for fluent chained calls", "docstring_tokens": ["Sets", "the", "response", "s", "headers", "specifying", "when", "using", "the", "keep", "-", "alive", "or", "not", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java#L140-L143", "partition": "test", "index": 3043, "time": "2013-07-16 09:24:54"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java", "func_name": "OHttpResponseWrapper.writeStatus", "original_string": "public OHttpResponseWrapper writeStatus(final int iHttpCode, final String iReason) throws IOException {\r\n    response.writeStatus(iHttpCode, iReason);\r\n    return this;\r\n  }", "language": "java", "code": "public OHttpResponseWrapper writeStatus(final int iHttpCode, final String iReason) throws IOException {\r\n    response.writeStatus(iHttpCode, iReason);\r\n    return this;\r\n  }", "code_tokens": ["public", "OHttpResponseWrapper", "writeStatus", "(", "final", "int", "iHttpCode", ",", "final", "String", "iReason", ")", "throws", "IOException", "{", "response", ".", "writeStatus", "(", "iHttpCode", ",", "iReason", ")", ";", "return", "this", ";", "}"], "docstring": "Sets the response's status as HTTP code and reason.\n\n@param iHttpCode\nResponse's HTTP code\n@param iReason\nResponse's reason\n@return The object itself for fluent chained calls", "docstring_tokens": ["Sets", "the", "response", "s", "status", "as", "HTTP", "code", "and", "reason", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java#L113-L116", "partition": "test", "index": 3042, "time": "2013-07-16 09:24:54"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java", "func_name": "OHttpResponseWrapper.sendStream", "original_string": "public OHttpResponseWrapper sendStream(final int iCode, final String iReason, final String iContentType,\r\n      final InputStream iContent, final long iSize) throws IOException {\r\n    response.sendStream(iCode, iReason, iContentType, iContent, iSize);\r\n    return this;\r\n  }", "language": "java", "code": "public OHttpResponseWrapper sendStream(final int iCode, final String iReason, final String iContentType,\r\n      final InputStream iContent, final long iSize) throws IOException {\r\n    response.sendStream(iCode, iReason, iContentType, iContent, iSize);\r\n    return this;\r\n  }", "code_tokens": ["public", "OHttpResponseWrapper", "sendStream", "(", "final", "int", "iCode", ",", "final", "String", "iReason", ",", "final", "String", "iContentType", ",", "final", "InputStream", "iContent", ",", "final", "long", "iSize", ")", "throws", "IOException", "{", "response", ".", "sendStream", "(", "iCode", ",", "iReason", ",", "iContentType", ",", "iContent", ",", "iSize", ")", ";", "return", "this", ";", "}"], "docstring": "Sends the complete HTTP response in one call specifying a stream as content.\n\n@param iCode\nHTTP response's Code\n@param iReason\nResponse's reason\n@param iContentType\nResponse's content type\n@param iContent\njava.io.InputStream object\n@param iSize\nContent size in bytes\n@return The object itself for fluent chained calls", "docstring_tokens": ["Sends", "the", "complete", "HTTP", "response", "in", "one", "call", "specifying", "a", "stream", "as", "content", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponseWrapper.java#L278-L282", "partition": "test", "index": 3047, "time": "2013-07-16 09:24:54"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/record/ORecordLazyMap.java", "func_name": "ORecordLazyMap.convertLink2Record", "original_string": "private void convertLink2Record(final Object iKey) {\r\n    if (status == MULTIVALUE_CONTENT_TYPE.ALL_RECORDS)\r\n      return;\r\n\r\n    final Object value;\r\n\r\n    if (iKey instanceof ORID)\r\n      value = iKey;\r\n    else\r\n      value = super.get(iKey);\r\n\r\n    if (value != null && value instanceof ORID) {\r\n      final ORID rid = (ORID) value;\r\n      marshalling = true;\r\n      try {\r\n        try {\r\n          // OVERWRITE IT\r\n          ORecord record = rid.getRecord();\r\n          if(record != null){\r\n              ORecordInternal.unTrack(sourceRecord, rid);\r\n              ORecordInternal.track(sourceRecord, record);\r\n          }\r\n          super.put(iKey, record);\r\n        } catch (ORecordNotFoundException ignore) {\r\n          // IGNORE THIS\r\n        }\r\n      } finally {\r\n        marshalling = false;\r\n      }\r\n    }\r\n  }", "language": "java", "code": "private void convertLink2Record(final Object iKey) {\r\n    if (status == MULTIVALUE_CONTENT_TYPE.ALL_RECORDS)\r\n      return;\r\n\r\n    final Object value;\r\n\r\n    if (iKey instanceof ORID)\r\n      value = iKey;\r\n    else\r\n      value = super.get(iKey);\r\n\r\n    if (value != null && value instanceof ORID) {\r\n      final ORID rid = (ORID) value;\r\n      marshalling = true;\r\n      try {\r\n        try {\r\n          // OVERWRITE IT\r\n          ORecord record = rid.getRecord();\r\n          if(record != null){\r\n              ORecordInternal.unTrack(sourceRecord, rid);\r\n              ORecordInternal.track(sourceRecord, record);\r\n          }\r\n          super.put(iKey, record);\r\n        } catch (ORecordNotFoundException ignore) {\r\n          // IGNORE THIS\r\n        }\r\n      } finally {\r\n        marshalling = false;\r\n      }\r\n    }\r\n  }", "code_tokens": ["private", "void", "convertLink2Record", "(", "final", "Object", "iKey", ")", "{", "if", "(", "status", "==", "MULTIVALUE_CONTENT_TYPE", ".", "ALL_RECORDS", ")", "return", ";", "final", "Object", "value", ";", "if", "(", "iKey", "instanceof", "ORID", ")", "value", "=", "iKey", ";", "else", "value", "=", "super", ".", "get", "(", "iKey", ")", ";", "if", "(", "value", "!=", "null", "&&", "value", "instanceof", "ORID", ")", "{", "final", "ORID", "rid", "=", "(", "ORID", ")", "value", ";", "marshalling", "=", "true", ";", "try", "{", "try", "{", "// OVERWRITE IT\r", "ORecord", "record", "=", "rid", ".", "getRecord", "(", ")", ";", "if", "(", "record", "!=", "null", ")", "{", "ORecordInternal", ".", "unTrack", "(", "sourceRecord", ",", "rid", ")", ";", "ORecordInternal", ".", "track", "(", "sourceRecord", ",", "record", ")", ";", "}", "super", ".", "put", "(", "iKey", ",", "record", ")", ";", "}", "catch", "(", "ORecordNotFoundException", "ignore", ")", "{", "// IGNORE THIS\r", "}", "}", "finally", "{", "marshalling", "=", "false", ";", "}", "}", "}"], "docstring": "Convert the item with the received key to a record.\n\n@param iKey\nKey of the item to convert", "docstring_tokens": ["Convert", "the", "item", "with", "the", "received", "key", "to", "a", "record", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/record/ORecordLazyMap.java#L189-L219", "partition": "test", "index": 3288, "time": "2013-07-24 22:37:32"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cache/local/twoq/O2QCache.java", "func_name": "O2QCache.changeMaximumAmountOfMemory", "original_string": "public void changeMaximumAmountOfMemory(final long readCacheMaxMemory) throws IllegalStateException {\n    MemoryData memoryData;\n    MemoryData newMemoryData;\n\n    final int newMemorySize = normalizeMemory(readCacheMaxMemory, pageSize);\n    do {\n      memoryData = memoryDataContainer.get();\n\n      if (memoryData.maxSize == newMemorySize) {\n        return;\n      }\n\n      if ((100 * memoryData.pinnedPages / newMemorySize) > percentOfPinnedPages) {\n        throw new IllegalStateException(\"Cannot decrease amount of memory used by disk cache \"\n            + \"because limit of pinned pages will be more than allowed limit \" + percentOfPinnedPages);\n      }\n\n      newMemoryData = new MemoryData(newMemorySize, memoryData.pinnedPages);\n    } while (!memoryDataContainer.compareAndSet(memoryData, newMemoryData));\n\n//    if (newMemorySize < memoryData.maxSize)\n//      removeColdestPagesIfNeeded();\n\n    OLogManager.instance()\n        .info(this, \"Disk cache size was changed from \" + memoryData.maxSize + \" pages to \" + newMemorySize + \" pages\");\n  }", "language": "java", "code": "public void changeMaximumAmountOfMemory(final long readCacheMaxMemory) throws IllegalStateException {\n    MemoryData memoryData;\n    MemoryData newMemoryData;\n\n    final int newMemorySize = normalizeMemory(readCacheMaxMemory, pageSize);\n    do {\n      memoryData = memoryDataContainer.get();\n\n      if (memoryData.maxSize == newMemorySize) {\n        return;\n      }\n\n      if ((100 * memoryData.pinnedPages / newMemorySize) > percentOfPinnedPages) {\n        throw new IllegalStateException(\"Cannot decrease amount of memory used by disk cache \"\n            + \"because limit of pinned pages will be more than allowed limit \" + percentOfPinnedPages);\n      }\n\n      newMemoryData = new MemoryData(newMemorySize, memoryData.pinnedPages);\n    } while (!memoryDataContainer.compareAndSet(memoryData, newMemoryData));\n\n//    if (newMemorySize < memoryData.maxSize)\n//      removeColdestPagesIfNeeded();\n\n    OLogManager.instance()\n        .info(this, \"Disk cache size was changed from \" + memoryData.maxSize + \" pages to \" + newMemorySize + \" pages\");\n  }", "code_tokens": ["public", "void", "changeMaximumAmountOfMemory", "(", "final", "long", "readCacheMaxMemory", ")", "throws", "IllegalStateException", "{", "MemoryData", "memoryData", ";", "MemoryData", "newMemoryData", ";", "final", "int", "newMemorySize", "=", "normalizeMemory", "(", "readCacheMaxMemory", ",", "pageSize", ")", ";", "do", "{", "memoryData", "=", "memoryDataContainer", ".", "get", "(", ")", ";", "if", "(", "memoryData", ".", "maxSize", "==", "newMemorySize", ")", "{", "return", ";", "}", "if", "(", "(", "100", "*", "memoryData", ".", "pinnedPages", "/", "newMemorySize", ")", ">", "percentOfPinnedPages", ")", "{", "throw", "new", "IllegalStateException", "(", "\"Cannot decrease amount of memory used by disk cache \"", "+", "\"because limit of pinned pages will be more than allowed limit \"", "+", "percentOfPinnedPages", ")", ";", "}", "newMemoryData", "=", "new", "MemoryData", "(", "newMemorySize", ",", "memoryData", ".", "pinnedPages", ")", ";", "}", "while", "(", "!", "memoryDataContainer", ".", "compareAndSet", "(", "memoryData", ",", "newMemoryData", ")", ")", ";", "//    if (newMemorySize < memoryData.maxSize)", "//      removeColdestPagesIfNeeded();", "OLogManager", ".", "instance", "(", ")", ".", "info", "(", "this", ",", "\"Disk cache size was changed from \"", "+", "memoryData", ".", "maxSize", "+", "\" pages to \"", "+", "newMemorySize", "+", "\" pages\"", ")", ";", "}"], "docstring": "Changes amount of memory which may be used by given cache. This method may consume many resources if amount of memory provided\nin parameter is much less than current amount of memory.\n\n@param readCacheMaxMemory New maximum size of cache in bytes.\n\n@throws IllegalStateException In case of new size of disk cache is too small to hold existing pinned pages.", "docstring_tokens": ["Changes", "amount", "of", "memory", "which", "may", "be", "used", "by", "given", "cache", ".", "This", "method", "may", "consume", "many", "resources", "if", "amount", "of", "memory", "provided", "in", "parameter", "is", "much", "less", "than", "current", "amount", "of", "memory", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/cache/local/twoq/O2QCache.java#L354-L379", "partition": "test", "index": 3243, "time": "2013-08-21 14:45:46"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/metadata/schema/OSchemaProxyObject.java", "func_name": "OSchemaProxyObject.synchronizeSchema", "original_string": "public synchronized void synchronizeSchema() {\n    OObjectDatabaseTx database = ((OObjectDatabaseTx) ODatabaseRecordThreadLocal.instance().get().getDatabaseOwner());\n    Collection<Class<?>> registeredEntities = database.getEntityManager().getRegisteredEntities();\n    boolean automaticSchemaGeneration = database.isAutomaticSchemaGeneration();\n    boolean reloadSchema = false;\n    for (Class<?> iClass : registeredEntities) {\n      if (Proxy.class.isAssignableFrom(iClass) || iClass.isEnum() || OReflectionHelper.isJavaType(iClass) || iClass\n          .isAnonymousClass())\n        return;\n\n      if (!database.getMetadata().getSchema().existsClass(iClass.getSimpleName())) {\n        database.getMetadata().getSchema().createClass(iClass.getSimpleName());\n        reloadSchema = true;\n      }\n\n      for (Class<?> currentClass = iClass; currentClass != Object.class; ) {\n\n        if (automaticSchemaGeneration && !currentClass.equals(Object.class) && !currentClass.equals(ODocument.class)) {\n          ((OSchemaProxyObject) database.getMetadata().getSchema()).generateSchema(currentClass, database.getUnderlying());\n        }\n        String iClassName = currentClass.getSimpleName();\n        currentClass = currentClass.getSuperclass();\n\n        if (currentClass == null || currentClass.equals(ODocument.class))\n          // POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER\n          // ODOCUMENT FIELDS\n          currentClass = Object.class;\n\n        if (database != null && !database.isClosed() && !currentClass.equals(Object.class)) {\n          OClass oSuperClass;\n          OClass currentOClass = database.getMetadata().getSchema().getClass(iClassName);\n          if (!database.getMetadata().getSchema().existsClass(currentClass.getSimpleName())) {\n            oSuperClass = database.getMetadata().getSchema().createClass(currentClass.getSimpleName());\n            reloadSchema = true;\n          } else {\n            oSuperClass = database.getMetadata().getSchema().getClass(currentClass.getSimpleName());\n            reloadSchema = true;\n          }\n\n          if (!currentOClass.getSuperClasses().contains(oSuperClass)) {\n            currentOClass.setSuperClasses(Arrays.asList(oSuperClass));\n            reloadSchema = true;\n          }\n\n        }\n      }\n    }\n    if (database != null && !database.isClosed() && reloadSchema) {\n      database.getMetadata().getSchema().reload();\n    }\n  }", "language": "java", "code": "public synchronized void synchronizeSchema() {\n    OObjectDatabaseTx database = ((OObjectDatabaseTx) ODatabaseRecordThreadLocal.instance().get().getDatabaseOwner());\n    Collection<Class<?>> registeredEntities = database.getEntityManager().getRegisteredEntities();\n    boolean automaticSchemaGeneration = database.isAutomaticSchemaGeneration();\n    boolean reloadSchema = false;\n    for (Class<?> iClass : registeredEntities) {\n      if (Proxy.class.isAssignableFrom(iClass) || iClass.isEnum() || OReflectionHelper.isJavaType(iClass) || iClass\n          .isAnonymousClass())\n        return;\n\n      if (!database.getMetadata().getSchema().existsClass(iClass.getSimpleName())) {\n        database.getMetadata().getSchema().createClass(iClass.getSimpleName());\n        reloadSchema = true;\n      }\n\n      for (Class<?> currentClass = iClass; currentClass != Object.class; ) {\n\n        if (automaticSchemaGeneration && !currentClass.equals(Object.class) && !currentClass.equals(ODocument.class)) {\n          ((OSchemaProxyObject) database.getMetadata().getSchema()).generateSchema(currentClass, database.getUnderlying());\n        }\n        String iClassName = currentClass.getSimpleName();\n        currentClass = currentClass.getSuperclass();\n\n        if (currentClass == null || currentClass.equals(ODocument.class))\n          // POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER\n          // ODOCUMENT FIELDS\n          currentClass = Object.class;\n\n        if (database != null && !database.isClosed() && !currentClass.equals(Object.class)) {\n          OClass oSuperClass;\n          OClass currentOClass = database.getMetadata().getSchema().getClass(iClassName);\n          if (!database.getMetadata().getSchema().existsClass(currentClass.getSimpleName())) {\n            oSuperClass = database.getMetadata().getSchema().createClass(currentClass.getSimpleName());\n            reloadSchema = true;\n          } else {\n            oSuperClass = database.getMetadata().getSchema().getClass(currentClass.getSimpleName());\n            reloadSchema = true;\n          }\n\n          if (!currentOClass.getSuperClasses().contains(oSuperClass)) {\n            currentOClass.setSuperClasses(Arrays.asList(oSuperClass));\n            reloadSchema = true;\n          }\n\n        }\n      }\n    }\n    if (database != null && !database.isClosed() && reloadSchema) {\n      database.getMetadata().getSchema().reload();\n    }\n  }", "code_tokens": ["public", "synchronized", "void", "synchronizeSchema", "(", ")", "{", "OObjectDatabaseTx", "database", "=", "(", "(", "OObjectDatabaseTx", ")", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ".", "getDatabaseOwner", "(", ")", ")", ";", "Collection", "<", "Class", "<", "?", ">", ">", "registeredEntities", "=", "database", ".", "getEntityManager", "(", ")", ".", "getRegisteredEntities", "(", ")", ";", "boolean", "automaticSchemaGeneration", "=", "database", ".", "isAutomaticSchemaGeneration", "(", ")", ";", "boolean", "reloadSchema", "=", "false", ";", "for", "(", "Class", "<", "?", ">", "iClass", ":", "registeredEntities", ")", "{", "if", "(", "Proxy", ".", "class", ".", "isAssignableFrom", "(", "iClass", ")", "||", "iClass", ".", "isEnum", "(", ")", "||", "OReflectionHelper", ".", "isJavaType", "(", "iClass", ")", "||", "iClass", ".", "isAnonymousClass", "(", ")", ")", "return", ";", "if", "(", "!", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "existsClass", "(", "iClass", ".", "getSimpleName", "(", ")", ")", ")", "{", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "createClass", "(", "iClass", ".", "getSimpleName", "(", ")", ")", ";", "reloadSchema", "=", "true", ";", "}", "for", "(", "Class", "<", "?", ">", "currentClass", "=", "iClass", ";", "currentClass", "!=", "Object", ".", "class", ";", ")", "{", "if", "(", "automaticSchemaGeneration", "&&", "!", "currentClass", ".", "equals", "(", "Object", ".", "class", ")", "&&", "!", "currentClass", ".", "equals", "(", "ODocument", ".", "class", ")", ")", "{", "(", "(", "OSchemaProxyObject", ")", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ")", ".", "generateSchema", "(", "currentClass", ",", "database", ".", "getUnderlying", "(", ")", ")", ";", "}", "String", "iClassName", "=", "currentClass", ".", "getSimpleName", "(", ")", ";", "currentClass", "=", "currentClass", ".", "getSuperclass", "(", ")", ";", "if", "(", "currentClass", "==", "null", "||", "currentClass", ".", "equals", "(", "ODocument", ".", "class", ")", ")", "// POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER", "// ODOCUMENT FIELDS", "currentClass", "=", "Object", ".", "class", ";", "if", "(", "database", "!=", "null", "&&", "!", "database", ".", "isClosed", "(", ")", "&&", "!", "currentClass", ".", "equals", "(", "Object", ".", "class", ")", ")", "{", "OClass", "oSuperClass", ";", "OClass", "currentOClass", "=", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "iClassName", ")", ";", "if", "(", "!", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "existsClass", "(", "currentClass", ".", "getSimpleName", "(", ")", ")", ")", "{", "oSuperClass", "=", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "createClass", "(", "currentClass", ".", "getSimpleName", "(", ")", ")", ";", "reloadSchema", "=", "true", ";", "}", "else", "{", "oSuperClass", "=", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "currentClass", ".", "getSimpleName", "(", ")", ")", ";", "reloadSchema", "=", "true", ";", "}", "if", "(", "!", "currentOClass", ".", "getSuperClasses", "(", ")", ".", "contains", "(", "oSuperClass", ")", ")", "{", "currentOClass", ".", "setSuperClasses", "(", "Arrays", ".", "asList", "(", "oSuperClass", ")", ")", ";", "reloadSchema", "=", "true", ";", "}", "}", "}", "}", "if", "(", "database", "!=", "null", "&&", "!", "database", ".", "isClosed", "(", ")", "&&", "reloadSchema", ")", "{", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "reload", "(", ")", ";", "}", "}"], "docstring": "Checks if all registered entities has schema generated, if not it generates it", "docstring_tokens": ["Checks", "if", "all", "registered", "entities", "has", "schema", "generated", "if", "not", "it", "generates", "it"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/metadata/schema/OSchemaProxyObject.java#L383-L433", "partition": "test", "index": 2972, "time": "2013-08-29 18:53:58"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/index/OIndexes.java", "func_name": "OIndexes.getIndexTypes", "original_string": "private static Set<String> getIndexTypes() {\n    final Set<String> types = new HashSet<>();\n    final Iterator<OIndexFactory> ite = getAllFactories();\n    while (ite.hasNext()) {\n      types.addAll(ite.next().getTypes());\n    }\n    return types;\n  }", "language": "java", "code": "private static Set<String> getIndexTypes() {\n    final Set<String> types = new HashSet<>();\n    final Iterator<OIndexFactory> ite = getAllFactories();\n    while (ite.hasNext()) {\n      types.addAll(ite.next().getTypes());\n    }\n    return types;\n  }", "code_tokens": ["private", "static", "Set", "<", "String", ">", "getIndexTypes", "(", ")", "{", "final", "Set", "<", "String", ">", "types", "=", "new", "HashSet", "<>", "(", ")", ";", "final", "Iterator", "<", "OIndexFactory", ">", "ite", "=", "getAllFactories", "(", ")", ";", "while", "(", "ite", ".", "hasNext", "(", ")", ")", "{", "types", ".", "addAll", "(", "ite", ".", "next", "(", ")", ".", "getTypes", "(", ")", ")", ";", "}", "return", "types", ";", "}"], "docstring": "Iterates on all factories and append all index types.\n\n@return Set of all index types.", "docstring_tokens": ["Iterates", "on", "all", "factories", "and", "append", "all", "index", "types", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/index/OIndexes.java#L99-L106", "partition": "test", "index": 3144, "time": "2013-09-11 11:31:08"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.isReplicationActive", "original_string": "public boolean isReplicationActive(final String iClusterName, final String iLocalNode) {\n    final Collection<String> servers = getClusterConfiguration(iClusterName).field(SERVERS);\n    if (servers != null && !servers.isEmpty()) {\n      return true;\n    }\n    return false;\n  }", "language": "java", "code": "public boolean isReplicationActive(final String iClusterName, final String iLocalNode) {\n    final Collection<String> servers = getClusterConfiguration(iClusterName).field(SERVERS);\n    if (servers != null && !servers.isEmpty()) {\n      return true;\n    }\n    return false;\n  }", "code_tokens": ["public", "boolean", "isReplicationActive", "(", "final", "String", "iClusterName", ",", "final", "String", "iLocalNode", ")", "{", "final", "Collection", "<", "String", ">", "servers", "=", "getClusterConfiguration", "(", "iClusterName", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "servers", "!=", "null", "&&", "!", "servers", ".", "isEmpty", "(", ")", ")", "{", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Returns true if the replication is active, otherwise false.\n\n@param iClusterName Cluster name, or null for *", "docstring_tokens": ["Returns", "true", "if", "the", "replication", "is", "active", "otherwise", "false", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L84-L90", "partition": "test", "index": 3084, "time": "2013-09-17 16:07:45"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getServerClusterMap", "original_string": "public Map<String, Collection<String>> getServerClusterMap(Collection<String> iClusterNames, final String iLocalNode,\n      final boolean optimizeForLocalOnly) {\n    if (iClusterNames == null || iClusterNames.isEmpty())\n      iClusterNames = DEFAULT_CLUSTER_NAME;\n\n    final Map<String, Collection<String>> servers = new HashMap<String, Collection<String>>(iClusterNames.size());\n\n    // TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY\n    boolean canUseLocalNode = true;\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null && !serverList.contains(iLocalNode)) {\n        canUseLocalNode = false;\n        break;\n      }\n    }\n\n    if (optimizeForLocalOnly && canUseLocalNode) {\n      // USE LOCAL NODE ONLY (MUCH FASTER)\n      servers.put(iLocalNode, iClusterNames);\n      return servers;\n    }\n\n// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS\n    final Map<String, Collection<String>> serverMap = new HashMap<String, Collection<String>>();\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      for (String s : serverList) {\n        if (NEW_NODE_TAG.equalsIgnoreCase(s))\n          continue;\n\n        Collection<String> clustersInServer = serverMap.get(s);\n        if (clustersInServer == null) {\n          clustersInServer = new HashSet<String>();\n          serverMap.put(s, clustersInServer);\n        }\n        clustersInServer.add(p);\n      }\n    }\n\n    if (serverMap.size() == 1)\n      // RETURN THE ONLY SERVER INVOLVED\n      return serverMap;\n\n    if (!optimizeForLocalOnly)\n      return serverMap;\n\n// ORDER BY NUMBER OF CLUSTERS\n    final List<String> orderedServers = new ArrayList<String>(serverMap.keySet());\n    Collections.sort(orderedServers, new Comparator<String>() {\n      @Override\n      public int compare(final String o1, final String o2) {\n        return ((Integer) serverMap.get(o2).size()).compareTo((Integer) serverMap.get(o1).size());\n      }\n    });\n\n// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS\n    final Set<String> remainingClusters = new HashSet<String>(iClusterNames); // KEEPS THE REMAINING CLUSTER TO ADD IN FINAL\n// RESULT\n    final Set<String> includedClusters = new HashSet<String>(iClusterNames.size()); // KEEPS THE COLLECTION OF ALREADY INCLUDED\n    // CLUSTERS\n    for (String s : orderedServers) {\n      final Collection<String> clusters = serverMap.get(s);\n\n      if (!servers.isEmpty()) {\n        // FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES\n        clusters.removeAll(includedClusters);\n      }\n\n      servers.put(s, clusters);\n      remainingClusters.removeAll(clusters);\n      includedClusters.addAll(clusters);\n\n      if (remainingClusters.isEmpty())\n        // FOUND ALL CLUSTERS\n        break;\n    }\n\n    return servers;\n  }", "language": "java", "code": "public Map<String, Collection<String>> getServerClusterMap(Collection<String> iClusterNames, final String iLocalNode,\n      final boolean optimizeForLocalOnly) {\n    if (iClusterNames == null || iClusterNames.isEmpty())\n      iClusterNames = DEFAULT_CLUSTER_NAME;\n\n    final Map<String, Collection<String>> servers = new HashMap<String, Collection<String>>(iClusterNames.size());\n\n    // TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY\n    boolean canUseLocalNode = true;\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null && !serverList.contains(iLocalNode)) {\n        canUseLocalNode = false;\n        break;\n      }\n    }\n\n    if (optimizeForLocalOnly && canUseLocalNode) {\n      // USE LOCAL NODE ONLY (MUCH FASTER)\n      servers.put(iLocalNode, iClusterNames);\n      return servers;\n    }\n\n// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS\n    final Map<String, Collection<String>> serverMap = new HashMap<String, Collection<String>>();\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      for (String s : serverList) {\n        if (NEW_NODE_TAG.equalsIgnoreCase(s))\n          continue;\n\n        Collection<String> clustersInServer = serverMap.get(s);\n        if (clustersInServer == null) {\n          clustersInServer = new HashSet<String>();\n          serverMap.put(s, clustersInServer);\n        }\n        clustersInServer.add(p);\n      }\n    }\n\n    if (serverMap.size() == 1)\n      // RETURN THE ONLY SERVER INVOLVED\n      return serverMap;\n\n    if (!optimizeForLocalOnly)\n      return serverMap;\n\n// ORDER BY NUMBER OF CLUSTERS\n    final List<String> orderedServers = new ArrayList<String>(serverMap.keySet());\n    Collections.sort(orderedServers, new Comparator<String>() {\n      @Override\n      public int compare(final String o1, final String o2) {\n        return ((Integer) serverMap.get(o2).size()).compareTo((Integer) serverMap.get(o1).size());\n      }\n    });\n\n// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS\n    final Set<String> remainingClusters = new HashSet<String>(iClusterNames); // KEEPS THE REMAINING CLUSTER TO ADD IN FINAL\n// RESULT\n    final Set<String> includedClusters = new HashSet<String>(iClusterNames.size()); // KEEPS THE COLLECTION OF ALREADY INCLUDED\n    // CLUSTERS\n    for (String s : orderedServers) {\n      final Collection<String> clusters = serverMap.get(s);\n\n      if (!servers.isEmpty()) {\n        // FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES\n        clusters.removeAll(includedClusters);\n      }\n\n      servers.put(s, clusters);\n      remainingClusters.removeAll(clusters);\n      includedClusters.addAll(clusters);\n\n      if (remainingClusters.isEmpty())\n        // FOUND ALL CLUSTERS\n        break;\n    }\n\n    return servers;\n  }", "code_tokens": ["public", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "getServerClusterMap", "(", "Collection", "<", "String", ">", "iClusterNames", ",", "final", "String", "iLocalNode", ",", "final", "boolean", "optimizeForLocalOnly", ")", "{", "if", "(", "iClusterNames", "==", "null", "||", "iClusterNames", ".", "isEmpty", "(", ")", ")", "iClusterNames", "=", "DEFAULT_CLUSTER_NAME", ";", "final", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "servers", "=", "new", "HashMap", "<", "String", ",", "Collection", "<", "String", ">", ">", "(", "iClusterNames", ".", "size", "(", ")", ")", ";", "// TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY", "boolean", "canUseLocalNode", "=", "true", ";", "for", "(", "String", "p", ":", "iClusterNames", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "p", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", "&&", "!", "serverList", ".", "contains", "(", "iLocalNode", ")", ")", "{", "canUseLocalNode", "=", "false", ";", "break", ";", "}", "}", "if", "(", "optimizeForLocalOnly", "&&", "canUseLocalNode", ")", "{", "// USE LOCAL NODE ONLY (MUCH FASTER)", "servers", ".", "put", "(", "iLocalNode", ",", "iClusterNames", ")", ";", "return", "servers", ";", "}", "// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS", "final", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "serverMap", "=", "new", "HashMap", "<", "String", ",", "Collection", "<", "String", ">", ">", "(", ")", ";", "for", "(", "String", "p", ":", "iClusterNames", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "p", ")", ".", "field", "(", "SERVERS", ")", ";", "for", "(", "String", "s", ":", "serverList", ")", "{", "if", "(", "NEW_NODE_TAG", ".", "equalsIgnoreCase", "(", "s", ")", ")", "continue", ";", "Collection", "<", "String", ">", "clustersInServer", "=", "serverMap", ".", "get", "(", "s", ")", ";", "if", "(", "clustersInServer", "==", "null", ")", "{", "clustersInServer", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "serverMap", ".", "put", "(", "s", ",", "clustersInServer", ")", ";", "}", "clustersInServer", ".", "add", "(", "p", ")", ";", "}", "}", "if", "(", "serverMap", ".", "size", "(", ")", "==", "1", ")", "// RETURN THE ONLY SERVER INVOLVED", "return", "serverMap", ";", "if", "(", "!", "optimizeForLocalOnly", ")", "return", "serverMap", ";", "// ORDER BY NUMBER OF CLUSTERS", "final", "List", "<", "String", ">", "orderedServers", "=", "new", "ArrayList", "<", "String", ">", "(", "serverMap", ".", "keySet", "(", ")", ")", ";", "Collections", ".", "sort", "(", "orderedServers", ",", "new", "Comparator", "<", "String", ">", "(", ")", "{", "@", "Override", "public", "int", "compare", "(", "final", "String", "o1", ",", "final", "String", "o2", ")", "{", "return", "(", "(", "Integer", ")", "serverMap", ".", "get", "(", "o2", ")", ".", "size", "(", ")", ")", ".", "compareTo", "(", "(", "Integer", ")", "serverMap", ".", "get", "(", "o1", ")", ".", "size", "(", ")", ")", ";", "}", "}", ")", ";", "// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS", "final", "Set", "<", "String", ">", "remainingClusters", "=", "new", "HashSet", "<", "String", ">", "(", "iClusterNames", ")", ";", "// KEEPS THE REMAINING CLUSTER TO ADD IN FINAL", "// RESULT", "final", "Set", "<", "String", ">", "includedClusters", "=", "new", "HashSet", "<", "String", ">", "(", "iClusterNames", ".", "size", "(", ")", ")", ";", "// KEEPS THE COLLECTION OF ALREADY INCLUDED", "// CLUSTERS", "for", "(", "String", "s", ":", "orderedServers", ")", "{", "final", "Collection", "<", "String", ">", "clusters", "=", "serverMap", ".", "get", "(", "s", ")", ";", "if", "(", "!", "servers", ".", "isEmpty", "(", ")", ")", "{", "// FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES", "clusters", ".", "removeAll", "(", "includedClusters", ")", ";", "}", "servers", ".", "put", "(", "s", ",", "clusters", ")", ";", "remainingClusters", ".", "removeAll", "(", "clusters", ")", ";", "includedClusters", ".", "addAll", "(", "clusters", ")", ";", "if", "(", "remainingClusters", ".", "isEmpty", "(", ")", ")", "// FOUND ALL CLUSTERS", "break", ";", "}", "return", "servers", ";", "}"], "docstring": "Returns the list of servers that can manage a list of clusters. The algorithm makes its best to involve the less servers as it\ncan.\n\n@param iClusterNames Set of cluster names to find\n@param iLocalNode    Local node name", "docstring_tokens": ["Returns", "the", "list", "of", "servers", "that", "can", "manage", "a", "list", "of", "clusters", ".", "The", "algorithm", "makes", "its", "best", "to", "involve", "the", "less", "servers", "as", "it", "can", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L163-L242", "partition": "test", "index": 3088, "time": "2013-09-17 16:07:45"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getConfiguredServers", "original_string": "public List<String> getConfiguredServers(final String iClusterName) {\n\n    final Collection<? extends String> list = (Collection<? extends String>) getClusterConfiguration(iClusterName).field(SERVERS);\n    return list != null ? new ArrayList<String>(list) : null;\n  }", "language": "java", "code": "public List<String> getConfiguredServers(final String iClusterName) {\n\n    final Collection<? extends String> list = (Collection<? extends String>) getClusterConfiguration(iClusterName).field(SERVERS);\n    return list != null ? new ArrayList<String>(list) : null;\n  }", "code_tokens": ["public", "List", "<", "String", ">", "getConfiguredServers", "(", "final", "String", "iClusterName", ")", "{", "final", "Collection", "<", "?", "extends", "String", ">", "list", "=", "(", "Collection", "<", "?", "extends", "String", ">", ")", "getClusterConfiguration", "(", "iClusterName", ")", ".", "field", "(", "SERVERS", ")", ";", "return", "list", "!=", "null", "?", "new", "ArrayList", "<", "String", ">", "(", "list", ")", ":", "null", ";", "}"], "docstring": "Returns the configured server list for the requested cluster.\n\n@param iClusterName Cluster name, or null for *", "docstring_tokens": ["Returns", "the", "configured", "server", "list", "for", "the", "requested", "cluster", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L500-L504", "partition": "test", "index": 3098, "time": "2013-09-17 16:07:45"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getServers", "original_string": "public Set<String> getServers(Collection<String> iClusterNames) {\n    if (iClusterNames == null || iClusterNames.isEmpty())\n      return getAllConfiguredServers();\n\n    final Set<String> partitions = new HashSet<String>(iClusterNames.size());\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null) {\n        for (String s : serverList)\n          if (!s.equals(NEW_NODE_TAG))\n            partitions.add(s);\n      }\n    }\n    return partitions;\n  }", "language": "java", "code": "public Set<String> getServers(Collection<String> iClusterNames) {\n    if (iClusterNames == null || iClusterNames.isEmpty())\n      return getAllConfiguredServers();\n\n    final Set<String> partitions = new HashSet<String>(iClusterNames.size());\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null) {\n        for (String s : serverList)\n          if (!s.equals(NEW_NODE_TAG))\n            partitions.add(s);\n      }\n    }\n    return partitions;\n  }", "code_tokens": ["public", "Set", "<", "String", ">", "getServers", "(", "Collection", "<", "String", ">", "iClusterNames", ")", "{", "if", "(", "iClusterNames", "==", "null", "||", "iClusterNames", ".", "isEmpty", "(", ")", ")", "return", "getAllConfiguredServers", "(", ")", ";", "final", "Set", "<", "String", ">", "partitions", "=", "new", "HashSet", "<", "String", ">", "(", "iClusterNames", ".", "size", "(", ")", ")", ";", "for", "(", "String", "p", ":", "iClusterNames", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "p", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", ")", "{", "for", "(", "String", "s", ":", "serverList", ")", "if", "(", "!", "s", ".", "equals", "(", "NEW_NODE_TAG", ")", ")", "partitions", ".", "add", "(", "s", ")", ";", "}", "}", "return", "partitions", ";", "}"], "docstring": "Returns the set of server names involved on the passed cluster collection.\n\n@param iClusterNames Collection of cluster names to find", "docstring_tokens": ["Returns", "the", "set", "of", "server", "names", "involved", "on", "the", "passed", "cluster", "collection", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L288-L302", "partition": "test", "index": 3089, "time": "2013-09-17 16:07:45"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getConfiguredClusterOwner", "original_string": "public String getConfiguredClusterOwner(final String iClusterName) {\n\n    String owner = null;\n\n    final ODocument clusters = getConfiguredClusters();\n\n    // GET THE CLUSTER CFG\n    final ODocument cfg = clusters.field(iClusterName);\n    if (cfg != null)\n      owner = cfg.field(OWNER);\n\n    return owner;\n  }", "language": "java", "code": "public String getConfiguredClusterOwner(final String iClusterName) {\n\n    String owner = null;\n\n    final ODocument clusters = getConfiguredClusters();\n\n    // GET THE CLUSTER CFG\n    final ODocument cfg = clusters.field(iClusterName);\n    if (cfg != null)\n      owner = cfg.field(OWNER);\n\n    return owner;\n  }", "code_tokens": ["public", "String", "getConfiguredClusterOwner", "(", "final", "String", "iClusterName", ")", "{", "String", "owner", "=", "null", ";", "final", "ODocument", "clusters", "=", "getConfiguredClusters", "(", ")", ";", "// GET THE CLUSTER CFG", "final", "ODocument", "cfg", "=", "clusters", ".", "field", "(", "iClusterName", ")", ";", "if", "(", "cfg", "!=", "null", ")", "owner", "=", "cfg", ".", "field", "(", "OWNER", ")", ";", "return", "owner", ";", "}"], "docstring": "Returns the static owner server for the given cluster.\n\n@param iClusterName Cluster name, or null for *", "docstring_tokens": ["Returns", "the", "static", "owner", "server", "for", "the", "given", "cluster", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L481-L493", "partition": "test", "index": 3097, "time": "2013-09-17 16:07:45"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/ODatabaseWrapperAbstract.java", "func_name": "ODatabaseWrapperAbstract.backup", "original_string": "@Override\r\n  public List<String> backup(OutputStream out, Map<String, Object> options, Callable<Object> callable,\r\n      final OCommandOutputListener iListener, int compressionLevel, int bufferSize) throws IOException {\r\n    return underlying.backup(out, options, callable, iListener, compressionLevel, bufferSize);\r\n  }", "language": "java", "code": "@Override\r\n  public List<String> backup(OutputStream out, Map<String, Object> options, Callable<Object> callable,\r\n      final OCommandOutputListener iListener, int compressionLevel, int bufferSize) throws IOException {\r\n    return underlying.backup(out, options, callable, iListener, compressionLevel, bufferSize);\r\n  }", "code_tokens": ["@", "Override", "public", "List", "<", "String", ">", "backup", "(", "OutputStream", "out", ",", "Map", "<", "String", ",", "Object", ">", "options", ",", "Callable", "<", "Object", ">", "callable", ",", "final", "OCommandOutputListener", "iListener", ",", "int", "compressionLevel", ",", "int", "bufferSize", ")", "throws", "IOException", "{", "return", "underlying", ".", "backup", "(", "out", ",", "options", ",", "callable", ",", "iListener", ",", "compressionLevel", ",", "bufferSize", ")", ";", "}"], "docstring": "Executes a backup of the database. During the backup the database will be frozen in read-only mode.\n\n@param out              OutputStream used to write the backup content. Use a FileOutputStream to make the backup persistent on\ndisk\n@param options          Backup options as Map<String, Object> object\n@param callable         Callback to execute when the database is locked\n@param iListener        Listener called for backup messages\n@param compressionLevel ZIP Compression level between 0 (no compression) and 9 (maximum). The bigger is the compression, the\nsmaller will be the final backup content, but will consume more CPU and time to execute\n@param bufferSize       Buffer size in bytes, the bigger is the buffer, the more efficient will be the compression\n\n@throws IOException", "docstring_tokens": ["Executes", "a", "backup", "of", "the", "database", ".", "During", "the", "backup", "the", "database", "will", "be", "frozen", "in", "read", "-", "only", "mode", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/ODatabaseWrapperAbstract.java#L116-L120", "partition": "test", "index": 3217, "time": "2013-09-23 01:35:04"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.isReadYourWrites", "original_string": "public Boolean isReadYourWrites(final String iClusterName) {\n    Object value = getClusterConfiguration(iClusterName).field(READ_YOUR_WRITES);\n    if (value == null) {\n      value = configuration.field(READ_YOUR_WRITES);\n      if (value == null) {\n        OLogManager.instance()\n            .warn(this, \"%s setting not found for cluster=%s in distributed-config.json\", READ_YOUR_WRITES, iClusterName);\n        return true;\n      }\n    }\n    return (Boolean) value;\n  }", "language": "java", "code": "public Boolean isReadYourWrites(final String iClusterName) {\n    Object value = getClusterConfiguration(iClusterName).field(READ_YOUR_WRITES);\n    if (value == null) {\n      value = configuration.field(READ_YOUR_WRITES);\n      if (value == null) {\n        OLogManager.instance()\n            .warn(this, \"%s setting not found for cluster=%s in distributed-config.json\", READ_YOUR_WRITES, iClusterName);\n        return true;\n      }\n    }\n    return (Boolean) value;\n  }", "code_tokens": ["public", "Boolean", "isReadYourWrites", "(", "final", "String", "iClusterName", ")", "{", "Object", "value", "=", "getClusterConfiguration", "(", "iClusterName", ")", ".", "field", "(", "READ_YOUR_WRITES", ")", ";", "if", "(", "value", "==", "null", ")", "{", "value", "=", "configuration", ".", "field", "(", "READ_YOUR_WRITES", ")", ";", "if", "(", "value", "==", "null", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "this", ",", "\"%s setting not found for cluster=%s in distributed-config.json\"", ",", "READ_YOUR_WRITES", ",", "iClusterName", ")", ";", "return", "true", ";", "}", "}", "return", "(", "Boolean", ")", "value", ";", "}"], "docstring": "Reads your writes.\n\n@param iClusterName Cluster name, or null for *", "docstring_tokens": ["Reads", "your", "writes", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L143-L154", "partition": "test", "index": 3087, "time": "2013-09-26 00:48:23"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/core/entity/OEntityManager.java", "func_name": "OEntityManager.registerEntityClasses", "original_string": "public synchronized void registerEntityClasses(final Collection<String> iClassNames, final ClassLoader iClassLoader) {\r\n    OLogManager.instance().debug(this, \"Discovering entity classes for class names: %s\", iClassNames);\r\n\r\n    try {\r\n      registerEntityClasses(OReflectionHelper.getClassesFor(iClassNames, iClassLoader));\r\n    } catch (ClassNotFoundException e) {\r\n      throw OException.wrapException(new ODatabaseException(\"Entity class cannot be found\"), e);\r\n    }\r\n  }", "language": "java", "code": "public synchronized void registerEntityClasses(final Collection<String> iClassNames, final ClassLoader iClassLoader) {\r\n    OLogManager.instance().debug(this, \"Discovering entity classes for class names: %s\", iClassNames);\r\n\r\n    try {\r\n      registerEntityClasses(OReflectionHelper.getClassesFor(iClassNames, iClassLoader));\r\n    } catch (ClassNotFoundException e) {\r\n      throw OException.wrapException(new ODatabaseException(\"Entity class cannot be found\"), e);\r\n    }\r\n  }", "code_tokens": ["public", "synchronized", "void", "registerEntityClasses", "(", "final", "Collection", "<", "String", ">", "iClassNames", ",", "final", "ClassLoader", "iClassLoader", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Discovering entity classes for class names: %s\"", ",", "iClassNames", ")", ";", "try", "{", "registerEntityClasses", "(", "OReflectionHelper", ".", "getClassesFor", "(", "iClassNames", ",", "iClassLoader", ")", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "ODatabaseException", "(", "\"Entity class cannot be found\"", ")", ",", "e", ")", ";", "}", "}"], "docstring": "Registers provided classes\n\n@param iClassNames\nto be registered\n@param iClassLoader", "docstring_tokens": ["Registers", "provided", "classes"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/core/entity/OEntityManager.java#L157-L165", "partition": "test", "index": 3168, "time": "2013-09-28 19:11:13"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/index/sbtreebonsai/local/OBonsaiBucketAbstract.java", "func_name": "OBonsaiBucketAbstract.setBucketPointer", "original_string": "protected void setBucketPointer(int pageOffset, OBonsaiBucketPointer value) throws IOException {\n    setLongValue(pageOffset, value.getPageIndex());\n    setIntValue(pageOffset + OLongSerializer.LONG_SIZE, value.getPageOffset());\n  }", "language": "java", "code": "protected void setBucketPointer(int pageOffset, OBonsaiBucketPointer value) throws IOException {\n    setLongValue(pageOffset, value.getPageIndex());\n    setIntValue(pageOffset + OLongSerializer.LONG_SIZE, value.getPageOffset());\n  }", "code_tokens": ["protected", "void", "setBucketPointer", "(", "int", "pageOffset", ",", "OBonsaiBucketPointer", "value", ")", "throws", "IOException", "{", "setLongValue", "(", "pageOffset", ",", "value", ".", "getPageIndex", "(", ")", ")", ";", "setIntValue", "(", "pageOffset", "+", "OLongSerializer", ".", "LONG_SIZE", ",", "value", ".", "getPageOffset", "(", ")", ")", ";", "}"], "docstring": "Write a bucket pointer to specific location.\n\n@param pageOffset\nwhere to write\n@param value\n- pointer to write\n@throws IOException", "docstring_tokens": ["Write", "a", "bucket", "pointer", "to", "specific", "location", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/index/sbtreebonsai/local/OBonsaiBucketAbstract.java#L54-L57", "partition": "test", "index": 3239, "time": "2013-10-11 18:51:17"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/index/sbtreebonsai/local/OBonsaiBucketAbstract.java", "func_name": "OBonsaiBucketAbstract.getBucketPointer", "original_string": "protected OBonsaiBucketPointer getBucketPointer(int offset) {\n    final long pageIndex = getLongValue(offset);\n    final int pageOffset = getIntValue(offset + OLongSerializer.LONG_SIZE);\n    return new OBonsaiBucketPointer(pageIndex, pageOffset);\n  }", "language": "java", "code": "protected OBonsaiBucketPointer getBucketPointer(int offset) {\n    final long pageIndex = getLongValue(offset);\n    final int pageOffset = getIntValue(offset + OLongSerializer.LONG_SIZE);\n    return new OBonsaiBucketPointer(pageIndex, pageOffset);\n  }", "code_tokens": ["protected", "OBonsaiBucketPointer", "getBucketPointer", "(", "int", "offset", ")", "{", "final", "long", "pageIndex", "=", "getLongValue", "(", "offset", ")", ";", "final", "int", "pageOffset", "=", "getIntValue", "(", "offset", "+", "OLongSerializer", ".", "LONG_SIZE", ")", ";", "return", "new", "OBonsaiBucketPointer", "(", "pageIndex", ",", "pageOffset", ")", ";", "}"], "docstring": "Read bucket pointer from page.\n\n@param offset\nwhere the pointer should be read from\n@return bucket pointer", "docstring_tokens": ["Read", "bucket", "pointer", "from", "page", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/index/sbtreebonsai/local/OBonsaiBucketAbstract.java#L66-L70", "partition": "test", "index": 3240, "time": "2013-10-11 18:51:17"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolAbstract.java", "func_name": "ODatabasePoolAbstract.close", "original_string": "public void close() {\r\n    lock();\r\n    try {\r\n\r\n      if (this.evictionTask != null) {\r\n        this.evictionTask.cancel();\r\n      }\r\n\r\n      for (Entry<String, OReentrantResourcePool<String, DB>> pool : pools.entrySet()) {\r\n        for (DB db : pool.getValue().getResources()) {\r\n          pool.getValue().close();\r\n          try {\r\n            OLogManager.instance().debug(this, \"Closing pooled database '%s'...\", db.getName());\r\n            ((ODatabasePooled) db).forceClose();\r\n            OLogManager.instance().debug(this, \"OK\", db.getName());\r\n          } catch (Exception e) {\r\n            OLogManager.instance().debug(this, \"Error: %d\", e.toString());\r\n          }\r\n        }\r\n      }\r\n\r\n    } finally {\r\n      unlock();\r\n    }\r\n  }", "language": "java", "code": "public void close() {\r\n    lock();\r\n    try {\r\n\r\n      if (this.evictionTask != null) {\r\n        this.evictionTask.cancel();\r\n      }\r\n\r\n      for (Entry<String, OReentrantResourcePool<String, DB>> pool : pools.entrySet()) {\r\n        for (DB db : pool.getValue().getResources()) {\r\n          pool.getValue().close();\r\n          try {\r\n            OLogManager.instance().debug(this, \"Closing pooled database '%s'...\", db.getName());\r\n            ((ODatabasePooled) db).forceClose();\r\n            OLogManager.instance().debug(this, \"OK\", db.getName());\r\n          } catch (Exception e) {\r\n            OLogManager.instance().debug(this, \"Error: %d\", e.toString());\r\n          }\r\n        }\r\n      }\r\n\r\n    } finally {\r\n      unlock();\r\n    }\r\n  }", "code_tokens": ["public", "void", "close", "(", ")", "{", "lock", "(", ")", ";", "try", "{", "if", "(", "this", ".", "evictionTask", "!=", "null", ")", "{", "this", ".", "evictionTask", ".", "cancel", "(", ")", ";", "}", "for", "(", "Entry", "<", "String", ",", "OReentrantResourcePool", "<", "String", ",", "DB", ">", ">", "pool", ":", "pools", ".", "entrySet", "(", ")", ")", "{", "for", "(", "DB", "db", ":", "pool", ".", "getValue", "(", ")", ".", "getResources", "(", ")", ")", "{", "pool", ".", "getValue", "(", ")", ".", "close", "(", ")", ";", "try", "{", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Closing pooled database '%s'...\"", ",", "db", ".", "getName", "(", ")", ")", ";", "(", "(", "ODatabasePooled", ")", "db", ")", ".", "forceClose", "(", ")", ";", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"OK\"", ",", "db", ".", "getName", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Error: %d\"", ",", "e", ".", "toString", "(", ")", ")", ";", "}", "}", "}", "}", "finally", "{", "unlock", "(", ")", ";", "}", "}"], "docstring": "Closes all the databases.", "docstring_tokens": ["Closes", "all", "the", "databases", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolAbstract.java#L256-L280", "partition": "test", "index": 3036, "time": "2013-11-11 19:03:48"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolAbstract.java", "func_name": "ODatabasePoolAbstract.onStorageUnregistered", "original_string": "public void onStorageUnregistered(final OStorage iStorage) {\r\n    final String storageURL = iStorage.getURL();\r\n\r\n    lock();\r\n    try {\r\n      Set<String> poolToClose = null;\r\n\r\n      for (Entry<String, OReentrantResourcePool<String, DB>> e : pools.entrySet()) {\r\n        final int pos = e.getKey().indexOf(\"@\");\r\n        final String dbName = e.getKey().substring(pos + 1);\r\n        if (storageURL.equals(dbName)) {\r\n          if (poolToClose == null)\r\n            poolToClose = new HashSet<String>();\r\n\r\n          poolToClose.add(e.getKey());\r\n        }\r\n      }\r\n\r\n      if (poolToClose != null)\r\n        for (String pool : poolToClose)\r\n          remove(pool);\r\n\r\n    } finally {\r\n      unlock();\r\n    }\r\n  }", "language": "java", "code": "public void onStorageUnregistered(final OStorage iStorage) {\r\n    final String storageURL = iStorage.getURL();\r\n\r\n    lock();\r\n    try {\r\n      Set<String> poolToClose = null;\r\n\r\n      for (Entry<String, OReentrantResourcePool<String, DB>> e : pools.entrySet()) {\r\n        final int pos = e.getKey().indexOf(\"@\");\r\n        final String dbName = e.getKey().substring(pos + 1);\r\n        if (storageURL.equals(dbName)) {\r\n          if (poolToClose == null)\r\n            poolToClose = new HashSet<String>();\r\n\r\n          poolToClose.add(e.getKey());\r\n        }\r\n      }\r\n\r\n      if (poolToClose != null)\r\n        for (String pool : poolToClose)\r\n          remove(pool);\r\n\r\n    } finally {\r\n      unlock();\r\n    }\r\n  }", "code_tokens": ["public", "void", "onStorageUnregistered", "(", "final", "OStorage", "iStorage", ")", "{", "final", "String", "storageURL", "=", "iStorage", ".", "getURL", "(", ")", ";", "lock", "(", ")", ";", "try", "{", "Set", "<", "String", ">", "poolToClose", "=", "null", ";", "for", "(", "Entry", "<", "String", ",", "OReentrantResourcePool", "<", "String", ",", "DB", ">", ">", "e", ":", "pools", ".", "entrySet", "(", ")", ")", "{", "final", "int", "pos", "=", "e", ".", "getKey", "(", ")", ".", "indexOf", "(", "\"@\"", ")", ";", "final", "String", "dbName", "=", "e", ".", "getKey", "(", ")", ".", "substring", "(", "pos", "+", "1", ")", ";", "if", "(", "storageURL", ".", "equals", "(", "dbName", ")", ")", "{", "if", "(", "poolToClose", "==", "null", ")", "poolToClose", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "poolToClose", ".", "add", "(", "e", ".", "getKey", "(", ")", ")", ";", "}", "}", "if", "(", "poolToClose", "!=", "null", ")", "for", "(", "String", "pool", ":", "poolToClose", ")", "remove", "(", "pool", ")", ";", "}", "finally", "{", "unlock", "(", ")", ";", "}", "}"], "docstring": "Removes from memory the pool associated to the closed storage. This avoids pool open against closed storages.", "docstring_tokens": ["Removes", "from", "memory", "the", "pool", "associated", "to", "the", "closed", "storage", ".", "This", "avoids", "pool", "open", "against", "closed", "storages", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolAbstract.java#L324-L349", "partition": "test", "index": 3037, "time": "2013-11-11 19:03:48"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OChainedIndexProxy.java", "func_name": "OChainedIndexProxy.prepareKeys", "original_string": "private Set<Comparable> prepareKeys(OIndex<?> index, Object keys) {\n    final OIndexDefinition indexDefinition = index.getDefinition();\n    if (keys instanceof Collection) {\n      final Set<Comparable> newKeys = new TreeSet<Comparable>();\n      for (Object o : ((Collection) keys)) {\n        newKeys.add((Comparable) indexDefinition.createValue(o));\n      }\n      return newKeys;\n    } else {\n      return Collections.singleton((Comparable) indexDefinition.createValue(keys));\n    }\n  }", "language": "java", "code": "private Set<Comparable> prepareKeys(OIndex<?> index, Object keys) {\n    final OIndexDefinition indexDefinition = index.getDefinition();\n    if (keys instanceof Collection) {\n      final Set<Comparable> newKeys = new TreeSet<Comparable>();\n      for (Object o : ((Collection) keys)) {\n        newKeys.add((Comparable) indexDefinition.createValue(o));\n      }\n      return newKeys;\n    } else {\n      return Collections.singleton((Comparable) indexDefinition.createValue(keys));\n    }\n  }", "code_tokens": ["private", "Set", "<", "Comparable", ">", "prepareKeys", "(", "OIndex", "<", "?", ">", "index", ",", "Object", "keys", ")", "{", "final", "OIndexDefinition", "indexDefinition", "=", "index", ".", "getDefinition", "(", ")", ";", "if", "(", "keys", "instanceof", "Collection", ")", "{", "final", "Set", "<", "Comparable", ">", "newKeys", "=", "new", "TreeSet", "<", "Comparable", ">", "(", ")", ";", "for", "(", "Object", "o", ":", "(", "(", "Collection", ")", "keys", ")", ")", "{", "newKeys", ".", "add", "(", "(", "Comparable", ")", "indexDefinition", ".", "createValue", "(", "o", ")", ")", ";", "}", "return", "newKeys", ";", "}", "else", "{", "return", "Collections", ".", "singleton", "(", "(", "Comparable", ")", "indexDefinition", ".", "createValue", "(", "keys", ")", ")", ";", "}", "}"], "docstring": "Make type conversion of keys for specific index.\n\n@param index - index for which keys prepared for.\n@param keys  - which should be prepared.\n\n@return keys converted to necessary type.", "docstring_tokens": ["Make", "type", "conversion", "of", "keys", "for", "specific", "index", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OChainedIndexProxy.java#L405-L416", "partition": "test", "index": 3079, "time": "2013-11-18 08:05:41"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OSQLEngine.java", "func_name": "OSQLEngine.getCollateNames", "original_string": "public static Set<String> getCollateNames() {\r\n    final Set<String> types = new HashSet<String>();\r\n    final Iterator<OCollateFactory> ite = getCollateFactories();\r\n    while (ite.hasNext()) {\r\n      types.addAll(ite.next().getNames());\r\n    }\r\n    return types;\r\n  }", "language": "java", "code": "public static Set<String> getCollateNames() {\r\n    final Set<String> types = new HashSet<String>();\r\n    final Iterator<OCollateFactory> ite = getCollateFactories();\r\n    while (ite.hasNext()) {\r\n      types.addAll(ite.next().getNames());\r\n    }\r\n    return types;\r\n  }", "code_tokens": ["public", "static", "Set", "<", "String", ">", "getCollateNames", "(", ")", "{", "final", "Set", "<", "String", ">", "types", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "final", "Iterator", "<", "OCollateFactory", ">", "ite", "=", "getCollateFactories", "(", ")", ";", "while", "(", "ite", ".", "hasNext", "(", ")", ")", "{", "types", ".", "addAll", "(", "ite", ".", "next", "(", ")", ".", "getNames", "(", ")", ")", ";", "}", "return", "types", ";", "}"], "docstring": "Iterates on all factories and append all collate names.\n\n@return Set of all colate names.", "docstring_tokens": ["Iterates", "on", "all", "factories", "and", "append", "all", "collate", "names", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OSQLEngine.java#L267-L274", "partition": "test", "index": 3039, "time": "2013-11-25 20:13:11"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/atomicoperations/OAtomicOperationsManager.java", "func_name": "OAtomicOperationsManager.endAtomicOperation", "original_string": "public OLogSequenceNumber endAtomicOperation(boolean rollback) throws IOException {\n    final OAtomicOperation operation = currentOperation.get();\n\n    if (operation == null) {\n      OLogManager.instance().error(this, \"There is no atomic operation active\", null);\n      throw new ODatabaseException(\"There is no atomic operation active\");\n    }\n\n    int counter = operation.getCounter();\n    operation.decrementCounter();\n\n    assert counter > 0;\n\n    final OLogSequenceNumber lsn;\n    try {\n      if (rollback) {\n        operation.rollback();\n      }\n\n      if (counter == 1) {\n        try {\n          final boolean useWal = useWal();\n\n          if (!operation.isRollback()) {\n            lsn = operation.commitChanges(useWal ? writeAheadLog : null);\n          } else {\n            lsn = null;\n          }\n\n          if (trackAtomicOperations) {\n            activeAtomicOperations.remove(operation.getOperationUnitId());\n          }\n        } finally {\n          final Iterator<String> lockedObjectIterator = operation.lockedObjects().iterator();\n\n          while (lockedObjectIterator.hasNext()) {\n            final String lockedObject = lockedObjectIterator.next();\n            lockedObjectIterator.remove();\n\n            lockManager.releaseLock(this, lockedObject, OOneEntryPerKeyLockManager.LOCK.EXCLUSIVE);\n          }\n\n          currentOperation.set(null);\n        }\n      } else {\n        lsn = null;\n      }\n    } catch (Error e) {\n      final OAbstractPaginatedStorage st = storage;\n      if (st != null) {\n        st.handleJVMError(e);\n      }\n\n      counter = 1;\n      throw e;\n    } finally {\n      if (counter == 1) {\n        atomicOperationsCount.decrement();\n      }\n    }\n\n    return lsn;\n  }", "language": "java", "code": "public OLogSequenceNumber endAtomicOperation(boolean rollback) throws IOException {\n    final OAtomicOperation operation = currentOperation.get();\n\n    if (operation == null) {\n      OLogManager.instance().error(this, \"There is no atomic operation active\", null);\n      throw new ODatabaseException(\"There is no atomic operation active\");\n    }\n\n    int counter = operation.getCounter();\n    operation.decrementCounter();\n\n    assert counter > 0;\n\n    final OLogSequenceNumber lsn;\n    try {\n      if (rollback) {\n        operation.rollback();\n      }\n\n      if (counter == 1) {\n        try {\n          final boolean useWal = useWal();\n\n          if (!operation.isRollback()) {\n            lsn = operation.commitChanges(useWal ? writeAheadLog : null);\n          } else {\n            lsn = null;\n          }\n\n          if (trackAtomicOperations) {\n            activeAtomicOperations.remove(operation.getOperationUnitId());\n          }\n        } finally {\n          final Iterator<String> lockedObjectIterator = operation.lockedObjects().iterator();\n\n          while (lockedObjectIterator.hasNext()) {\n            final String lockedObject = lockedObjectIterator.next();\n            lockedObjectIterator.remove();\n\n            lockManager.releaseLock(this, lockedObject, OOneEntryPerKeyLockManager.LOCK.EXCLUSIVE);\n          }\n\n          currentOperation.set(null);\n        }\n      } else {\n        lsn = null;\n      }\n    } catch (Error e) {\n      final OAbstractPaginatedStorage st = storage;\n      if (st != null) {\n        st.handleJVMError(e);\n      }\n\n      counter = 1;\n      throw e;\n    } finally {\n      if (counter == 1) {\n        atomicOperationsCount.decrement();\n      }\n    }\n\n    return lsn;\n  }", "code_tokens": ["public", "OLogSequenceNumber", "endAtomicOperation", "(", "boolean", "rollback", ")", "throws", "IOException", "{", "final", "OAtomicOperation", "operation", "=", "currentOperation", ".", "get", "(", ")", ";", "if", "(", "operation", "==", "null", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"There is no atomic operation active\"", ",", "null", ")", ";", "throw", "new", "ODatabaseException", "(", "\"There is no atomic operation active\"", ")", ";", "}", "int", "counter", "=", "operation", ".", "getCounter", "(", ")", ";", "operation", ".", "decrementCounter", "(", ")", ";", "assert", "counter", ">", "0", ";", "final", "OLogSequenceNumber", "lsn", ";", "try", "{", "if", "(", "rollback", ")", "{", "operation", ".", "rollback", "(", ")", ";", "}", "if", "(", "counter", "==", "1", ")", "{", "try", "{", "final", "boolean", "useWal", "=", "useWal", "(", ")", ";", "if", "(", "!", "operation", ".", "isRollback", "(", ")", ")", "{", "lsn", "=", "operation", ".", "commitChanges", "(", "useWal", "?", "writeAheadLog", ":", "null", ")", ";", "}", "else", "{", "lsn", "=", "null", ";", "}", "if", "(", "trackAtomicOperations", ")", "{", "activeAtomicOperations", ".", "remove", "(", "operation", ".", "getOperationUnitId", "(", ")", ")", ";", "}", "}", "finally", "{", "final", "Iterator", "<", "String", ">", "lockedObjectIterator", "=", "operation", ".", "lockedObjects", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "lockedObjectIterator", ".", "hasNext", "(", ")", ")", "{", "final", "String", "lockedObject", "=", "lockedObjectIterator", ".", "next", "(", ")", ";", "lockedObjectIterator", ".", "remove", "(", ")", ";", "lockManager", ".", "releaseLock", "(", "this", ",", "lockedObject", ",", "OOneEntryPerKeyLockManager", ".", "LOCK", ".", "EXCLUSIVE", ")", ";", "}", "currentOperation", ".", "set", "(", "null", ")", ";", "}", "}", "else", "{", "lsn", "=", "null", ";", "}", "}", "catch", "(", "Error", "e", ")", "{", "final", "OAbstractPaginatedStorage", "st", "=", "storage", ";", "if", "(", "st", "!=", "null", ")", "{", "st", ".", "handleJVMError", "(", "e", ")", ";", "}", "counter", "=", "1", ";", "throw", "e", ";", "}", "finally", "{", "if", "(", "counter", "==", "1", ")", "{", "atomicOperationsCount", ".", "decrement", "(", ")", ";", "}", "}", "return", "lsn", ";", "}"], "docstring": "Ends the current atomic operation on this manager.\n\n@param rollback {@code true} to indicate a rollback, {@code false} for successful commit.\n\n@return the LSN produced by committing the current operation or {@code null} if no commit was done.", "docstring_tokens": ["Ends", "the", "current", "atomic", "operation", "on", "this", "manager", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/atomicoperations/OAtomicOperationsManager.java#L364-L426", "partition": "test", "index": 3241, "time": "2013-12-10 12:13:52"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/atomicoperations/OAtomicOperationsManager.java", "func_name": "OAtomicOperationsManager.acquireExclusiveLockTillOperationComplete", "original_string": "public void acquireExclusiveLockTillOperationComplete(OAtomicOperation operation, String lockName) {\n    if (operation.containsInLockedObjects(lockName)) {\n      return;\n    }\n\n    lockManager.acquireLock(lockName, OOneEntryPerKeyLockManager.LOCK.EXCLUSIVE);\n    operation.addLockedObject(lockName);\n  }", "language": "java", "code": "public void acquireExclusiveLockTillOperationComplete(OAtomicOperation operation, String lockName) {\n    if (operation.containsInLockedObjects(lockName)) {\n      return;\n    }\n\n    lockManager.acquireLock(lockName, OOneEntryPerKeyLockManager.LOCK.EXCLUSIVE);\n    operation.addLockedObject(lockName);\n  }", "code_tokens": ["public", "void", "acquireExclusiveLockTillOperationComplete", "(", "OAtomicOperation", "operation", ",", "String", "lockName", ")", "{", "if", "(", "operation", ".", "containsInLockedObjects", "(", "lockName", ")", ")", "{", "return", ";", "}", "lockManager", ".", "acquireLock", "(", "lockName", ",", "OOneEntryPerKeyLockManager", ".", "LOCK", ".", "EXCLUSIVE", ")", ";", "operation", ".", "addLockedObject", "(", "lockName", ")", ";", "}"], "docstring": "Acquires exclusive lock with the given lock name in the given atomic operation.\n\n@param operation the atomic operation to acquire the lock in.\n@param lockName  the lock name to acquire.", "docstring_tokens": ["Acquires", "exclusive", "lock", "with", "the", "given", "lock", "name", "in", "the", "given", "atomic", "operation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/atomicoperations/OAtomicOperationsManager.java#L448-L455", "partition": "test", "index": 3242, "time": "2013-12-10 12:13:52"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/ridbag/sbtree/OSBTreeRidBag.java", "func_name": "OSBTreeRidBag.updateSize", "original_string": "private int updateSize() {\n    int size = 0;\n    if (collectionPointer != null) {\n      final OSBTreeBonsai<OIdentifiable, Integer> tree = loadTree();\n      if (tree == null) {\n        throw new IllegalStateException(\"RidBag is not properly initialized, can not load tree implementation\");\n      }\n\n      try {\n        size = tree.getRealBagSize(changes);\n      } finally {\n        releaseTree();\n      }\n    } else {\n      for (Change change : changes.values()) {\n        size += change.applyTo(0);\n      }\n    }\n\n    for (OModifiableInteger diff : newEntries.values()) {\n      size += diff.getValue();\n    }\n\n    this.size = size;\n    return size;\n  }", "language": "java", "code": "private int updateSize() {\n    int size = 0;\n    if (collectionPointer != null) {\n      final OSBTreeBonsai<OIdentifiable, Integer> tree = loadTree();\n      if (tree == null) {\n        throw new IllegalStateException(\"RidBag is not properly initialized, can not load tree implementation\");\n      }\n\n      try {\n        size = tree.getRealBagSize(changes);\n      } finally {\n        releaseTree();\n      }\n    } else {\n      for (Change change : changes.values()) {\n        size += change.applyTo(0);\n      }\n    }\n\n    for (OModifiableInteger diff : newEntries.values()) {\n      size += diff.getValue();\n    }\n\n    this.size = size;\n    return size;\n  }", "code_tokens": ["private", "int", "updateSize", "(", ")", "{", "int", "size", "=", "0", ";", "if", "(", "collectionPointer", "!=", "null", ")", "{", "final", "OSBTreeBonsai", "<", "OIdentifiable", ",", "Integer", ">", "tree", "=", "loadTree", "(", ")", ";", "if", "(", "tree", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"RidBag is not properly initialized, can not load tree implementation\"", ")", ";", "}", "try", "{", "size", "=", "tree", ".", "getRealBagSize", "(", "changes", ")", ";", "}", "finally", "{", "releaseTree", "(", ")", ";", "}", "}", "else", "{", "for", "(", "Change", "change", ":", "changes", ".", "values", "(", ")", ")", "{", "size", "+=", "change", ".", "applyTo", "(", "0", ")", ";", "}", "}", "for", "(", "OModifiableInteger", "diff", ":", "newEntries", ".", "values", "(", ")", ")", "{", "size", "+=", "diff", ".", "getValue", "(", ")", ";", "}", "this", ".", "size", "=", "size", ";", "return", "size", ";", "}"], "docstring": "Recalculates real bag size.\n\n@return real size", "docstring_tokens": ["Recalculates", "real", "bag", "size", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/ridbag/sbtree/OSBTreeRidBag.java#L952-L977", "partition": "test", "index": 3156, "time": "2014-01-09 08:54:50"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionAbstract.java", "func_name": "OTransactionAbstract.close", "original_string": "@Override\r\n  public void close() {\r\n    for (Map.Entry<ORID, LockedRecordMetadata> lock : locks.entrySet()) {\r\n      try {\r\n        final LockedRecordMetadata lockedRecordMetadata = lock.getValue();\r\n\r\n        if (lockedRecordMetadata.strategy.equals(OStorage.LOCKING_STRATEGY.EXCLUSIVE_LOCK)) {\r\n          ((OAbstractPaginatedStorage) getDatabase().getStorage().getUnderlying()).releaseWriteLock(lock.getKey());\r\n        } else if (lockedRecordMetadata.strategy.equals(OStorage.LOCKING_STRATEGY.SHARED_LOCK)) {\r\n          ((OAbstractPaginatedStorage) getDatabase().getStorage().getUnderlying()).releaseReadLock(lock.getKey());\r\n        }\r\n      } catch (Exception e) {\r\n        OLogManager.instance().debug(this, \"Error on releasing lock against record \" + lock.getKey(), e);\r\n      }\r\n    }\r\n    locks.clear();\r\n  }", "language": "java", "code": "@Override\r\n  public void close() {\r\n    for (Map.Entry<ORID, LockedRecordMetadata> lock : locks.entrySet()) {\r\n      try {\r\n        final LockedRecordMetadata lockedRecordMetadata = lock.getValue();\r\n\r\n        if (lockedRecordMetadata.strategy.equals(OStorage.LOCKING_STRATEGY.EXCLUSIVE_LOCK)) {\r\n          ((OAbstractPaginatedStorage) getDatabase().getStorage().getUnderlying()).releaseWriteLock(lock.getKey());\r\n        } else if (lockedRecordMetadata.strategy.equals(OStorage.LOCKING_STRATEGY.SHARED_LOCK)) {\r\n          ((OAbstractPaginatedStorage) getDatabase().getStorage().getUnderlying()).releaseReadLock(lock.getKey());\r\n        }\r\n      } catch (Exception e) {\r\n        OLogManager.instance().debug(this, \"Error on releasing lock against record \" + lock.getKey(), e);\r\n      }\r\n    }\r\n    locks.clear();\r\n  }", "code_tokens": ["@", "Override", "public", "void", "close", "(", ")", "{", "for", "(", "Map", ".", "Entry", "<", "ORID", ",", "LockedRecordMetadata", ">", "lock", ":", "locks", ".", "entrySet", "(", ")", ")", "{", "try", "{", "final", "LockedRecordMetadata", "lockedRecordMetadata", "=", "lock", ".", "getValue", "(", ")", ";", "if", "(", "lockedRecordMetadata", ".", "strategy", ".", "equals", "(", "OStorage", ".", "LOCKING_STRATEGY", ".", "EXCLUSIVE_LOCK", ")", ")", "{", "(", "(", "OAbstractPaginatedStorage", ")", "getDatabase", "(", ")", ".", "getStorage", "(", ")", ".", "getUnderlying", "(", ")", ")", ".", "releaseWriteLock", "(", "lock", ".", "getKey", "(", ")", ")", ";", "}", "else", "if", "(", "lockedRecordMetadata", ".", "strategy", ".", "equals", "(", "OStorage", ".", "LOCKING_STRATEGY", ".", "SHARED_LOCK", ")", ")", "{", "(", "(", "OAbstractPaginatedStorage", ")", "getDatabase", "(", ")", ".", "getStorage", "(", ")", ".", "getUnderlying", "(", ")", ")", ".", "releaseReadLock", "(", "lock", ".", "getKey", "(", ")", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Error on releasing lock against record \"", "+", "lock", ".", "getKey", "(", ")", ",", "e", ")", ";", "}", "}", "locks", ".", "clear", "(", ")", ";", "}"], "docstring": "Closes the transaction and releases all the acquired locks.", "docstring_tokens": ["Closes", "the", "transaction", "and", "releases", "all", "the", "acquired", "locks", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/tx/OTransactionAbstract.java#L103-L119", "partition": "test", "index": 2971, "time": "2014-01-10 21:57:50"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/sql/OGraphCommandExecutorSQLFactory.java", "func_name": "OGraphCommandExecutorSQLFactory.getGraph", "original_string": "public static OrientGraph getGraph(final boolean autoStartTx, OModifiableBoolean shouldBeShutDown) {\n    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();\n\n    final OrientBaseGraph result = OrientBaseGraph.getActiveGraph();\n\n    if (result != null && (result instanceof OrientGraph)) {\n      final ODatabaseDocumentInternal graphDb = result.getRawGraph();\n\n      // CHECK IF THE DATABASE + USER IN TL IS THE SAME IN ORDER TO USE IT\n      if (canReuseActiveGraph(graphDb, database)) {\n\n        if (!graphDb.isClosed()) {\n          ODatabaseRecordThreadLocal.instance().set(graphDb);\n          if (autoStartTx && autoTxStartRequired(graphDb))\n            ((OrientGraph) result).begin();\n\n          shouldBeShutDown.setValue(false);\n          return (OrientGraph) result;\n        }\n      }\n    }\n    // Set it again on ThreadLocal because the getRawGraph() may have set a closed db in the thread-local\n    ODatabaseRecordThreadLocal.instance().set(database);\n    shouldBeShutDown.setValue(true);\n\n    final OrientGraph g = (OrientGraph) OrientGraphFactory.getTxGraphImplFactory().getGraph(database, false);\n    if (autoStartTx && autoTxStartRequired(database))\n      g.begin();\n    return g;\n  }", "language": "java", "code": "public static OrientGraph getGraph(final boolean autoStartTx, OModifiableBoolean shouldBeShutDown) {\n    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();\n\n    final OrientBaseGraph result = OrientBaseGraph.getActiveGraph();\n\n    if (result != null && (result instanceof OrientGraph)) {\n      final ODatabaseDocumentInternal graphDb = result.getRawGraph();\n\n      // CHECK IF THE DATABASE + USER IN TL IS THE SAME IN ORDER TO USE IT\n      if (canReuseActiveGraph(graphDb, database)) {\n\n        if (!graphDb.isClosed()) {\n          ODatabaseRecordThreadLocal.instance().set(graphDb);\n          if (autoStartTx && autoTxStartRequired(graphDb))\n            ((OrientGraph) result).begin();\n\n          shouldBeShutDown.setValue(false);\n          return (OrientGraph) result;\n        }\n      }\n    }\n    // Set it again on ThreadLocal because the getRawGraph() may have set a closed db in the thread-local\n    ODatabaseRecordThreadLocal.instance().set(database);\n    shouldBeShutDown.setValue(true);\n\n    final OrientGraph g = (OrientGraph) OrientGraphFactory.getTxGraphImplFactory().getGraph(database, false);\n    if (autoStartTx && autoTxStartRequired(database))\n      g.begin();\n    return g;\n  }", "code_tokens": ["public", "static", "OrientGraph", "getGraph", "(", "final", "boolean", "autoStartTx", ",", "OModifiableBoolean", "shouldBeShutDown", ")", "{", "final", "ODatabaseDocumentInternal", "database", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ";", "final", "OrientBaseGraph", "result", "=", "OrientBaseGraph", ".", "getActiveGraph", "(", ")", ";", "if", "(", "result", "!=", "null", "&&", "(", "result", "instanceof", "OrientGraph", ")", ")", "{", "final", "ODatabaseDocumentInternal", "graphDb", "=", "result", ".", "getRawGraph", "(", ")", ";", "// CHECK IF THE DATABASE + USER IN TL IS THE SAME IN ORDER TO USE IT", "if", "(", "canReuseActiveGraph", "(", "graphDb", ",", "database", ")", ")", "{", "if", "(", "!", "graphDb", ".", "isClosed", "(", ")", ")", "{", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "set", "(", "graphDb", ")", ";", "if", "(", "autoStartTx", "&&", "autoTxStartRequired", "(", "graphDb", ")", ")", "(", "(", "OrientGraph", ")", "result", ")", ".", "begin", "(", ")", ";", "shouldBeShutDown", ".", "setValue", "(", "false", ")", ";", "return", "(", "OrientGraph", ")", "result", ";", "}", "}", "}", "// Set it again on ThreadLocal because the getRawGraph() may have set a closed db in the thread-local", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "set", "(", "database", ")", ";", "shouldBeShutDown", ".", "setValue", "(", "true", ")", ";", "final", "OrientGraph", "g", "=", "(", "OrientGraph", ")", "OrientGraphFactory", ".", "getTxGraphImplFactory", "(", ")", ".", "getGraph", "(", "database", ",", "false", ")", ";", "if", "(", "autoStartTx", "&&", "autoTxStartRequired", "(", "database", ")", ")", "g", ".", "begin", "(", ")", ";", "return", "g", ";", "}"], "docstring": "Returns a Transactional OrientGraph implementation from the current database in thread local.\n\n@param autoStartTx Whether returned graph will start transaction before each operation till commit automatically or user should do it\nexplicitly be calling {@link OrientGraph#getRawGraph()} method {@link ODatabaseDocumentTx#begin()}.\n@return Transactional OrientGraph implementation from the current database in thread local.", "docstring_tokens": ["Returns", "a", "Transactional", "OrientGraph", "implementation", "from", "the", "current", "database", "in", "thread", "local", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/sql/OGraphCommandExecutorSQLFactory.java#L74-L103", "partition": "test", "index": 3230, "time": "2014-01-15 12:54:55"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getIndex", "original_string": "@SuppressWarnings(\"unchecked\")\n  @Override\n  public <T extends Element> Index<T> getIndex(final String indexName, final Class<T> indexClass) {\n    makeActive();\n\n    final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();\n    final OIndex idx = indexManager.getIndex(indexName);\n    if (idx == null || !hasIndexClass(idx))\n      return null;\n\n    final Index<? extends Element> index = new OrientIndex(this, idx);\n\n    if (indexClass.isAssignableFrom(index.getIndexClass()))\n      return (Index<T>) index;\n    else\n      throw ExceptionFactory.indexDoesNotSupportClass(indexName, indexClass);\n  }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\n  @Override\n  public <T extends Element> Index<T> getIndex(final String indexName, final Class<T> indexClass) {\n    makeActive();\n\n    final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();\n    final OIndex idx = indexManager.getIndex(indexName);\n    if (idx == null || !hasIndexClass(idx))\n      return null;\n\n    final Index<? extends Element> index = new OrientIndex(this, idx);\n\n    if (indexClass.isAssignableFrom(index.getIndexClass()))\n      return (Index<T>) index;\n    else\n      throw ExceptionFactory.indexDoesNotSupportClass(indexName, indexClass);\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "@", "Override", "public", "<", "T", "extends", "Element", ">", "Index", "<", "T", ">", "getIndex", "(", "final", "String", "indexName", ",", "final", "Class", "<", "T", ">", "indexClass", ")", "{", "makeActive", "(", ")", ";", "final", "OIndexManager", "indexManager", "=", "getDatabase", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ";", "final", "OIndex", "idx", "=", "indexManager", ".", "getIndex", "(", "indexName", ")", ";", "if", "(", "idx", "==", "null", "||", "!", "hasIndexClass", "(", "idx", ")", ")", "return", "null", ";", "final", "Index", "<", "?", "extends", "Element", ">", "index", "=", "new", "OrientIndex", "(", "this", ",", "idx", ")", ";", "if", "(", "indexClass", ".", "isAssignableFrom", "(", "index", ".", "getIndexClass", "(", ")", ")", ")", "return", "(", "Index", "<", "T", ">", ")", "index", ";", "else", "throw", "ExceptionFactory", ".", "indexDoesNotSupportClass", "(", "indexName", ",", "indexClass", ")", ";", "}"], "docstring": "Returns an index by name and class\n\n@param indexName  Index name\n@param indexClass Class as one or subclass of Vertex.class and Edge.class\n\n@return Index instance", "docstring_tokens": ["Returns", "an", "index", "by", "name", "and", "class"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L461-L477", "partition": "test", "index": 3110, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientElement.java", "func_name": "OrientElement.removeRecord", "original_string": "void removeRecord() {\n    checkIfAttached();\n\n    final OrientBaseGraph graph = getGraph();\n    graph.setCurrentGraphInThreadLocal();\n    graph.autoStartTransaction();\n\n    if (checkDeletedInTx())\n      graph.throwRecordNotFoundException(getIdentity(), \"The graph element with id \" + getIdentity() + \" not found\");\n\n    try {\n      getRecord().load();\n    } catch (ORecordNotFoundException e) {\n      graph.throwRecordNotFoundException(getIdentity(), e.getMessage());\n    }\n    getRecord().delete();\n  }", "language": "java", "code": "void removeRecord() {\n    checkIfAttached();\n\n    final OrientBaseGraph graph = getGraph();\n    graph.setCurrentGraphInThreadLocal();\n    graph.autoStartTransaction();\n\n    if (checkDeletedInTx())\n      graph.throwRecordNotFoundException(getIdentity(), \"The graph element with id \" + getIdentity() + \" not found\");\n\n    try {\n      getRecord().load();\n    } catch (ORecordNotFoundException e) {\n      graph.throwRecordNotFoundException(getIdentity(), e.getMessage());\n    }\n    getRecord().delete();\n  }", "code_tokens": ["void", "removeRecord", "(", ")", "{", "checkIfAttached", "(", ")", ";", "final", "OrientBaseGraph", "graph", "=", "getGraph", "(", ")", ";", "graph", ".", "setCurrentGraphInThreadLocal", "(", ")", ";", "graph", ".", "autoStartTransaction", "(", ")", ";", "if", "(", "checkDeletedInTx", "(", ")", ")", "graph", ".", "throwRecordNotFoundException", "(", "getIdentity", "(", ")", ",", "\"The graph element with id \"", "+", "getIdentity", "(", ")", "+", "\" not found\"", ")", ";", "try", "{", "getRecord", "(", ")", ".", "load", "(", ")", ";", "}", "catch", "(", "ORecordNotFoundException", "e", ")", "{", "graph", ".", "throwRecordNotFoundException", "(", "getIdentity", "(", ")", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "getRecord", "(", ")", ".", "delete", "(", ")", ";", "}"], "docstring": "Removes the Element from the Graph. In case the element is a Vertex, all the incoming and outgoing edges are automatically\nremoved too.", "docstring_tokens": ["Removes", "the", "Element", "from", "the", "Graph", ".", "In", "case", "the", "element", "is", "a", "Vertex", "all", "the", "incoming", "and", "outgoing", "edges", "are", "automatically", "removed", "too", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientElement.java#L106-L122", "partition": "test", "index": 3066, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.dropIndex", "original_string": "public void dropIndex(final String indexName) {\n    makeActive();\n\n    executeOutsideTx(new OCallable<Object, OrientBaseGraph>() {\n      @Override\n      public Object call(OrientBaseGraph g) {\n        try {\n          final OIndexManager indexManager = getRawGraph().getMetadata().getIndexManager();\n          final OIndex index = indexManager.getIndex(indexName);\n          ODocument metadata = index.getConfiguration().field(\"metadata\");\n\n          String recordMapIndexName = null;\n          if (metadata != null) {\n            recordMapIndexName = metadata.field(OrientIndex.CONFIG_RECORD_MAP_NAME);\n          }\n\n          indexManager.dropIndex(indexName);\n          if (recordMapIndexName != null)\n            getRawGraph().getMetadata().getIndexManager().dropIndex(recordMapIndexName);\n\n          saveIndexConfiguration();\n          return null;\n        } catch (Exception e) {\n          g.rollback();\n          throw new RuntimeException(e.getMessage(), e);\n        }\n      }\n    }, \"drop index '\", indexName, \"'\");\n  }", "language": "java", "code": "public void dropIndex(final String indexName) {\n    makeActive();\n\n    executeOutsideTx(new OCallable<Object, OrientBaseGraph>() {\n      @Override\n      public Object call(OrientBaseGraph g) {\n        try {\n          final OIndexManager indexManager = getRawGraph().getMetadata().getIndexManager();\n          final OIndex index = indexManager.getIndex(indexName);\n          ODocument metadata = index.getConfiguration().field(\"metadata\");\n\n          String recordMapIndexName = null;\n          if (metadata != null) {\n            recordMapIndexName = metadata.field(OrientIndex.CONFIG_RECORD_MAP_NAME);\n          }\n\n          indexManager.dropIndex(indexName);\n          if (recordMapIndexName != null)\n            getRawGraph().getMetadata().getIndexManager().dropIndex(recordMapIndexName);\n\n          saveIndexConfiguration();\n          return null;\n        } catch (Exception e) {\n          g.rollback();\n          throw new RuntimeException(e.getMessage(), e);\n        }\n      }\n    }, \"drop index '\", indexName, \"'\");\n  }", "code_tokens": ["public", "void", "dropIndex", "(", "final", "String", "indexName", ")", "{", "makeActive", "(", ")", ";", "executeOutsideTx", "(", "new", "OCallable", "<", "Object", ",", "OrientBaseGraph", ">", "(", ")", "{", "@", "Override", "public", "Object", "call", "(", "OrientBaseGraph", "g", ")", "{", "try", "{", "final", "OIndexManager", "indexManager", "=", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ";", "final", "OIndex", "index", "=", "indexManager", ".", "getIndex", "(", "indexName", ")", ";", "ODocument", "metadata", "=", "index", ".", "getConfiguration", "(", ")", ".", "field", "(", "\"metadata\"", ")", ";", "String", "recordMapIndexName", "=", "null", ";", "if", "(", "metadata", "!=", "null", ")", "{", "recordMapIndexName", "=", "metadata", ".", "field", "(", "OrientIndex", ".", "CONFIG_RECORD_MAP_NAME", ")", ";", "}", "indexManager", ".", "dropIndex", "(", "indexName", ")", ";", "if", "(", "recordMapIndexName", "!=", "null", ")", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ".", "dropIndex", "(", "recordMapIndexName", ")", ";", "saveIndexConfiguration", "(", ")", ";", "return", "null", ";", "}", "catch", "(", "Exception", "e", ")", "{", "g", ".", "rollback", "(", ")", ";", "throw", "new", "RuntimeException", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "}", "}", ",", "\"drop index '\"", ",", "indexName", ",", "\"'\"", ")", ";", "}"], "docstring": "Drops an index by name.\n\n@param indexName Index name", "docstring_tokens": ["Drops", "an", "index", "by", "name", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L495-L523", "partition": "test", "index": 3111, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.addVertex", "original_string": "@Override\n  public OrientVertex addVertex(final Object id) {\n    makeActive();\n\n    return addVertex(id, (Object[]) null);\n  }", "language": "java", "code": "@Override\n  public OrientVertex addVertex(final Object id) {\n    makeActive();\n\n    return addVertex(id, (Object[]) null);\n  }", "code_tokens": ["@", "Override", "public", "OrientVertex", "addVertex", "(", "final", "Object", "id", ")", "{", "makeActive", "(", ")", ";", "return", "addVertex", "(", "id", ",", "(", "Object", "[", "]", ")", "null", ")", ";", "}"], "docstring": "Creates a new unconnected vertex with no fields in the Graph.\n\n@param id Optional, can contains the Vertex's class name by prefixing with \"class:\"\n\n@return The new OrientVertex created", "docstring_tokens": ["Creates", "a", "new", "unconnected", "vertex", "with", "no", "fields", "in", "the", "Graph", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L532-L537", "partition": "test", "index": 3112, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java", "func_name": "OrientVertex.addEdge", "original_string": "public OrientEdge addEdge(final String label, final OrientVertex inVertex, final String iClassName) {\n    return addEdge(label, inVertex, iClassName, null, (Object[]) null);\n  }", "language": "java", "code": "public OrientEdge addEdge(final String label, final OrientVertex inVertex, final String iClassName) {\n    return addEdge(label, inVertex, iClassName, null, (Object[]) null);\n  }", "code_tokens": ["public", "OrientEdge", "addEdge", "(", "final", "String", "label", ",", "final", "OrientVertex", "inVertex", ",", "final", "String", "iClassName", ")", "{", "return", "addEdge", "(", "label", ",", "inVertex", ",", "iClassName", ",", "null", ",", "(", "Object", "[", "]", ")", "null", ")", ";", "}"], "docstring": "Creates an edge between current Vertex and a target Vertex setting label as Edge's label. iClassName is the Edge's class used\nif different by label.\n\n@param label      Edge's label or class\n@param inVertex   Outgoing target vertex\n@param iClassName Edge's class name\n\n@return The new Edge created", "docstring_tokens": ["Creates", "an", "edge", "between", "current", "Vertex", "and", "a", "target", "Vertex", "setting", "label", "as", "Edge", "s", "label", ".", "iClassName", "is", "the", "Edge", "s", "class", "used", "if", "different", "by", "label", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java#L720-L722", "partition": "test", "index": 3210, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java", "func_name": "OrientVertex.addEdge", "original_string": "@Override\n  public Edge addEdge(final String label, Vertex inVertex) {\n    if (inVertex instanceof PartitionVertex)\n      // WRAPPED: GET THE BASE VERTEX\n      inVertex = ((PartitionVertex) inVertex).getBaseVertex();\n\n    return addEdge(label, (OrientVertex) inVertex, null, null, (Object[]) null);\n  }", "language": "java", "code": "@Override\n  public Edge addEdge(final String label, Vertex inVertex) {\n    if (inVertex instanceof PartitionVertex)\n      // WRAPPED: GET THE BASE VERTEX\n      inVertex = ((PartitionVertex) inVertex).getBaseVertex();\n\n    return addEdge(label, (OrientVertex) inVertex, null, null, (Object[]) null);\n  }", "code_tokens": ["@", "Override", "public", "Edge", "addEdge", "(", "final", "String", "label", ",", "Vertex", "inVertex", ")", "{", "if", "(", "inVertex", "instanceof", "PartitionVertex", ")", "// WRAPPED: GET THE BASE VERTEX", "inVertex", "=", "(", "(", "PartitionVertex", ")", "inVertex", ")", ".", "getBaseVertex", "(", ")", ";", "return", "addEdge", "(", "label", ",", "(", "OrientVertex", ")", "inVertex", ",", "null", ",", "null", ",", "(", "Object", "[", "]", ")", "null", ")", ";", "}"], "docstring": "Creates an edge between current Vertex and a target Vertex setting label as Edge's label.\n\n@param label    Edge's label or class\n@param inVertex Outgoing target vertex\n\n@return The new Edge created", "docstring_tokens": ["Creates", "an", "edge", "between", "current", "Vertex", "and", "a", "target", "Vertex", "setting", "label", "as", "Edge", "s", "label", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java#L701-L708", "partition": "test", "index": 3209, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java", "func_name": "OrientVertex.remove", "original_string": "@Override\n  public void remove() {\n    checkClass();\n\n    final OrientBaseGraph graph = checkIfAttached();\n\n    graph.setCurrentGraphInThreadLocal();\n    graph.autoStartTransaction();\n\n    final ODocument doc = getRecord();\n    if (doc == null)\n      throw ExceptionFactory.vertexWithIdDoesNotExist(this.getId());\n\n    Map<String, List<ODocument>> treeRidbagEdgesToRemove = new HashMap<String, List<ODocument>>();\n\n    if (!graph.getRawGraph().getTransaction().isActive()) {\n      for (String fieldName : doc.fieldNames()) {\n        final OPair<Direction, String> connection = getConnection(Direction.BOTH, fieldName);\n        if (connection == null)\n          // SKIP THIS FIELD\n          continue;\n        Object fv = doc.field(fieldName);\n        if (fv instanceof ORidBag && !((ORidBag) fv).isEmbedded()) {\n          List<ODocument> docs = new ArrayList<ODocument>();\n          for (OIdentifiable id : (ORidBag) fv)\n            docs.add(OrientBaseGraph.getDocument(id, true));\n          treeRidbagEdgesToRemove.put(fieldName, docs);\n        }\n      }\n    }\n\n    // REMOVE THE VERTEX RECORD FIRST TO CATCH CME BEFORE EDGES ARE REMOVED\n    super.removeRecord();\n\n    // REMOVE THE VERTEX FROM MANUAL INDEXES\n    final Iterator<Index<? extends Element>> it = graph.getIndices().iterator();\n    if (it.hasNext()) {\n      final Set<Edge> allEdges = new HashSet<Edge>();\n      for (Edge e : getEdges(Direction.BOTH))\n        allEdges.add(e);\n\n      while (it.hasNext()) {\n        final Index<? extends Element> index = it.next();\n\n        if (Vertex.class.isAssignableFrom(index.getIndexClass())) {\n          OrientIndex<OrientVertex> idx = (OrientIndex<OrientVertex>) index;\n          idx.removeElement(this);\n        }\n\n        if (Edge.class.isAssignableFrom(index.getIndexClass())) {\n          OrientIndex<OrientEdge> idx = (OrientIndex<OrientEdge>) index;\n          for (Edge e : allEdges)\n            idx.removeElement((OrientEdge) e);\n        }\n      }\n    }\n\n    for (Map.Entry<String, List<ODocument>> entry : treeRidbagEdgesToRemove.entrySet()) {\n      doc.removeField(entry.getKey());\n      Iterator<ODocument> iter = entry.getValue().iterator();\n      while (iter.hasNext()) {\n        ODocument docEdge = iter.next();\n        OrientBaseGraph.deleteEdgeIfAny(docEdge, false);\n      }\n    }\n\n    graph.removeEdgesInternal(this, doc, null, true, settings.isUseVertexFieldsForEdgeLabels(), settings.isAutoScaleEdgeType());\n  }", "language": "java", "code": "@Override\n  public void remove() {\n    checkClass();\n\n    final OrientBaseGraph graph = checkIfAttached();\n\n    graph.setCurrentGraphInThreadLocal();\n    graph.autoStartTransaction();\n\n    final ODocument doc = getRecord();\n    if (doc == null)\n      throw ExceptionFactory.vertexWithIdDoesNotExist(this.getId());\n\n    Map<String, List<ODocument>> treeRidbagEdgesToRemove = new HashMap<String, List<ODocument>>();\n\n    if (!graph.getRawGraph().getTransaction().isActive()) {\n      for (String fieldName : doc.fieldNames()) {\n        final OPair<Direction, String> connection = getConnection(Direction.BOTH, fieldName);\n        if (connection == null)\n          // SKIP THIS FIELD\n          continue;\n        Object fv = doc.field(fieldName);\n        if (fv instanceof ORidBag && !((ORidBag) fv).isEmbedded()) {\n          List<ODocument> docs = new ArrayList<ODocument>();\n          for (OIdentifiable id : (ORidBag) fv)\n            docs.add(OrientBaseGraph.getDocument(id, true));\n          treeRidbagEdgesToRemove.put(fieldName, docs);\n        }\n      }\n    }\n\n    // REMOVE THE VERTEX RECORD FIRST TO CATCH CME BEFORE EDGES ARE REMOVED\n    super.removeRecord();\n\n    // REMOVE THE VERTEX FROM MANUAL INDEXES\n    final Iterator<Index<? extends Element>> it = graph.getIndices().iterator();\n    if (it.hasNext()) {\n      final Set<Edge> allEdges = new HashSet<Edge>();\n      for (Edge e : getEdges(Direction.BOTH))\n        allEdges.add(e);\n\n      while (it.hasNext()) {\n        final Index<? extends Element> index = it.next();\n\n        if (Vertex.class.isAssignableFrom(index.getIndexClass())) {\n          OrientIndex<OrientVertex> idx = (OrientIndex<OrientVertex>) index;\n          idx.removeElement(this);\n        }\n\n        if (Edge.class.isAssignableFrom(index.getIndexClass())) {\n          OrientIndex<OrientEdge> idx = (OrientIndex<OrientEdge>) index;\n          for (Edge e : allEdges)\n            idx.removeElement((OrientEdge) e);\n        }\n      }\n    }\n\n    for (Map.Entry<String, List<ODocument>> entry : treeRidbagEdgesToRemove.entrySet()) {\n      doc.removeField(entry.getKey());\n      Iterator<ODocument> iter = entry.getValue().iterator();\n      while (iter.hasNext()) {\n        ODocument docEdge = iter.next();\n        OrientBaseGraph.deleteEdgeIfAny(docEdge, false);\n      }\n    }\n\n    graph.removeEdgesInternal(this, doc, null, true, settings.isUseVertexFieldsForEdgeLabels(), settings.isAutoScaleEdgeType());\n  }", "code_tokens": ["@", "Override", "public", "void", "remove", "(", ")", "{", "checkClass", "(", ")", ";", "final", "OrientBaseGraph", "graph", "=", "checkIfAttached", "(", ")", ";", "graph", ".", "setCurrentGraphInThreadLocal", "(", ")", ";", "graph", ".", "autoStartTransaction", "(", ")", ";", "final", "ODocument", "doc", "=", "getRecord", "(", ")", ";", "if", "(", "doc", "==", "null", ")", "throw", "ExceptionFactory", ".", "vertexWithIdDoesNotExist", "(", "this", ".", "getId", "(", ")", ")", ";", "Map", "<", "String", ",", "List", "<", "ODocument", ">", ">", "treeRidbagEdgesToRemove", "=", "new", "HashMap", "<", "String", ",", "List", "<", "ODocument", ">", ">", "(", ")", ";", "if", "(", "!", "graph", ".", "getRawGraph", "(", ")", ".", "getTransaction", "(", ")", ".", "isActive", "(", ")", ")", "{", "for", "(", "String", "fieldName", ":", "doc", ".", "fieldNames", "(", ")", ")", "{", "final", "OPair", "<", "Direction", ",", "String", ">", "connection", "=", "getConnection", "(", "Direction", ".", "BOTH", ",", "fieldName", ")", ";", "if", "(", "connection", "==", "null", ")", "// SKIP THIS FIELD", "continue", ";", "Object", "fv", "=", "doc", ".", "field", "(", "fieldName", ")", ";", "if", "(", "fv", "instanceof", "ORidBag", "&&", "!", "(", "(", "ORidBag", ")", "fv", ")", ".", "isEmbedded", "(", ")", ")", "{", "List", "<", "ODocument", ">", "docs", "=", "new", "ArrayList", "<", "ODocument", ">", "(", ")", ";", "for", "(", "OIdentifiable", "id", ":", "(", "ORidBag", ")", "fv", ")", "docs", ".", "(", "OrientBaseGraph", ".", "getDocument", "(", "id", ",", "true", ")", ")", ";", "treeRidbagEdgesToRemove", ".", "put", "(", "fieldName", ",", "docs", ")", ";", "}", "}", "}", "// REMOVE THE VERTEX RECORD FIRST TO CATCH CME BEFORE EDGES ARE REMOVED", "super", ".", "removeRecord", "(", ")", ";", "// REMOVE THE VERTEX FROM MANUAL INDEXES", "final", "Iterator", "<", "Index", "<", "?", "extends", "Element", ">", ">", "it", "=", "graph", ".", "getIndices", "(", ")", ".", "iterator", "(", ")", ";", "if", "(", "it", ".", "hasNext", "(", ")", ")", "{", "final", "Set", "<", "Edge", ">", "allEdges", "=", "new", "HashSet", "<", "Edge", ">", "(", ")", ";", "for", "(", "Edge", "e", ":", "getEdges", "(", "Direction", ".", "BOTH", ")", ")", "allEdges", ".", "(", ")", ";", "while", "(", "it", ".", "hasNext", "(", ")", ")", "{", "final", "Index", "<", "?", "extends", "Element", ">", "index", "=", "it", ".", "next", "(", ")", ";", "if", "(", "Vertex", ".", "class", ".", "isAssignableFrom", "(", "index", ".", "getIndexClass", "(", ")", ")", ")", "{", "OrientIndex", "<", "OrientVertex", ">", "idx", "=", "(", "OrientIndex", "<", "OrientVertex", ">", ")", "index", ";", "idx", ".", "removeElement", "(", "this", ")", ";", "}", "if", "(", "Edge", ".", "class", ".", "isAssignableFrom", "(", "index", ".", "getIndexClass", "(", ")", ")", ")", "{", "OrientIndex", "<", "OrientEdge", ">", "idx", "=", "(", "OrientIndex", "<", "OrientEdge", ">", ")", "index", ";", "for", "(", "Edge", "e", ":", "allEdges", ")", "idx", ".", "removeElement", "(", "(", "OrientEdge", ")", ")", ";", "}", "}", "}", "for", "(", "Map", ".", "Entry", "<", "String", ",", "List", "<", "ODocument", ">", ">", "entry", ":", "treeRidbagEdgesToRemove", ".", "entrySet", "(", ")", ")", "{", "doc", ".", "removeField", "(", "entry", ".", "getKey", "(", ")", ")", ";", "Iterator", "<", "ODocument", ">", "iter", "=", "entry", ".", "getValue", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "ODocument", "docEdge", "=", "iter", ".", "next", "(", ")", ";", "OrientBaseGraph", ".", "deleteEdgeIfAny", "(", "docEdge", ",", "false", ")", ";", "}", "}", "graph", ".", "removeEdgesInternal", "(", "this", ",", "doc", ",", "null", ",", "true", ",", "settings", ".", "isUseVertexFieldsForEdgeLabels", "(", ")", ",", "settings", ".", "isAutoScaleEdgeType", "(", ")", ")", ";", "}"], "docstring": "Removes the current Vertex from the Graph. all the incoming and outgoing edges are automatically removed too.", "docstring_tokens": ["Removes", "the", "current", "Vertex", "from", "the", "Graph", ".", "all", "the", "incoming", "and", "outgoing", "edges", "are", "automatically", "removed", "too", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java#L472-L539", "partition": "test", "index": 3208, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java", "func_name": "OrientVertex.getVertices", "original_string": "@Override\n  public Iterable<Vertex> getVertices(final Direction iDirection, final String... iLabels) {\n    setCurrentGraphInThreadLocal();\n\n    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);\n    OrientBaseGraph.encodeClassNames(iLabels);\n\n    final ODocument doc = getRecord();\n\n    final OMultiCollectionIterator<Vertex> iterable = new OMultiCollectionIterator<Vertex>();\n\n    for (OTriple<String, Direction, String> connectionField : getConnectionFields(iDirection, iLabels)) {\n      String fieldName = connectionField.getKey();\n      OPair<Direction, String> connection = connectionField.getValue();\n\n      final Object fieldValue = doc.rawField(fieldName);\n      if (fieldValue != null)\n        if (fieldValue instanceof OIdentifiable) {\n          addSingleVertex(doc, iterable, fieldName, connection, fieldValue, iLabels);\n\n        } else if (fieldValue instanceof Collection<?>) {\n          Collection<?> coll = (Collection<?>) fieldValue;\n\n          if (coll.size() == 1) {\n            // SINGLE ITEM: AVOID CALLING ITERATOR\n            if (coll instanceof ORecordLazyMultiValue)\n              addSingleVertex(doc, iterable, fieldName, connection, ((ORecordLazyMultiValue) coll).rawIterator().next(), iLabels);\n            else if (coll instanceof List<?>)\n              addSingleVertex(doc, iterable, fieldName, connection, ((List<?>) coll).get(0), iLabels);\n            else\n              addSingleVertex(doc, iterable, fieldName, connection, coll.iterator().next(), iLabels);\n          } else {\n            // CREATE LAZY Iterable AGAINST COLLECTION FIELD\n            if (coll instanceof ORecordLazyMultiValue)\n              iterable.add(new OrientVertexIterator(this, coll, ((ORecordLazyMultiValue) coll).rawIterator(), connection, iLabels,\n                  coll.size()));\n            else\n              iterable.add(new OrientVertexIterator(this, coll, coll.iterator(), connection, iLabels, -1));\n          }\n        } else if (fieldValue instanceof ORidBag) {\n          iterable.add(new OrientVertexIterator(this, fieldValue, ((ORidBag) fieldValue).rawIterator(), connection, iLabels, -1));\n        }\n    }\n\n    return iterable;\n  }", "language": "java", "code": "@Override\n  public Iterable<Vertex> getVertices(final Direction iDirection, final String... iLabels) {\n    setCurrentGraphInThreadLocal();\n\n    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);\n    OrientBaseGraph.encodeClassNames(iLabels);\n\n    final ODocument doc = getRecord();\n\n    final OMultiCollectionIterator<Vertex> iterable = new OMultiCollectionIterator<Vertex>();\n\n    for (OTriple<String, Direction, String> connectionField : getConnectionFields(iDirection, iLabels)) {\n      String fieldName = connectionField.getKey();\n      OPair<Direction, String> connection = connectionField.getValue();\n\n      final Object fieldValue = doc.rawField(fieldName);\n      if (fieldValue != null)\n        if (fieldValue instanceof OIdentifiable) {\n          addSingleVertex(doc, iterable, fieldName, connection, fieldValue, iLabels);\n\n        } else if (fieldValue instanceof Collection<?>) {\n          Collection<?> coll = (Collection<?>) fieldValue;\n\n          if (coll.size() == 1) {\n            // SINGLE ITEM: AVOID CALLING ITERATOR\n            if (coll instanceof ORecordLazyMultiValue)\n              addSingleVertex(doc, iterable, fieldName, connection, ((ORecordLazyMultiValue) coll).rawIterator().next(), iLabels);\n            else if (coll instanceof List<?>)\n              addSingleVertex(doc, iterable, fieldName, connection, ((List<?>) coll).get(0), iLabels);\n            else\n              addSingleVertex(doc, iterable, fieldName, connection, coll.iterator().next(), iLabels);\n          } else {\n            // CREATE LAZY Iterable AGAINST COLLECTION FIELD\n            if (coll instanceof ORecordLazyMultiValue)\n              iterable.add(new OrientVertexIterator(this, coll, ((ORecordLazyMultiValue) coll).rawIterator(), connection, iLabels,\n                  coll.size()));\n            else\n              iterable.add(new OrientVertexIterator(this, coll, coll.iterator(), connection, iLabels, -1));\n          }\n        } else if (fieldValue instanceof ORidBag) {\n          iterable.add(new OrientVertexIterator(this, fieldValue, ((ORidBag) fieldValue).rawIterator(), connection, iLabels, -1));\n        }\n    }\n\n    return iterable;\n  }", "code_tokens": ["@", "Override", "public", "Iterable", "<", "Vertex", ">", "getVertices", "(", "final", "Direction", "iDirection", ",", "final", "String", "...", "iLabels", ")", "{", "setCurrentGraphInThreadLocal", "(", ")", ";", "OrientBaseGraph", ".", "getEdgeClassNames", "(", "getGraph", "(", ")", ",", "iLabels", ")", ";", "OrientBaseGraph", ".", "encodeClassNames", "(", "iLabels", ")", ";", "final", "ODocument", "doc", "=", "getRecord", "(", ")", ";", "final", "OMultiCollectionIterator", "<", "Vertex", ">", "iterable", "=", "new", "OMultiCollectionIterator", "<", "Vertex", ">", "(", ")", ";", "for", "(", "OTriple", "<", "String", ",", "Direction", ",", "String", ">", "connectionField", ":", "getConnectionFields", "(", "iDirection", ",", "iLabels", ")", ")", "{", "String", "fieldName", "=", "connectionField", ".", "getKey", "(", ")", ";", "OPair", "<", "Direction", ",", "String", ">", "connection", "=", "connectionField", ".", "getValue", "(", ")", ";", "final", "Object", "fieldValue", "=", "doc", ".", "rawField", "(", "fieldName", ")", ";", "if", "(", "fieldValue", "!=", "null", ")", "if", "(", "fieldValue", "instanceof", "OIdentifiable", ")", "{", "addSingleVertex", "(", "doc", ",", "iterable", ",", "fieldName", ",", "connection", ",", "fieldValue", ",", "iLabels", ")", ";", "}", "else", "if", "(", "fieldValue", "instanceof", "Collection", "<", "?", ">", ")", "{", "Collection", "<", "?", ">", "coll", "=", "(", "Collection", "<", "?", ">", ")", "fieldValue", ";", "if", "(", "coll", ".", "size", "(", ")", "==", "1", ")", "{", "// SINGLE ITEM: AVOID CALLING ITERATOR", "if", "(", "coll", "instanceof", "ORecordLazyMultiValue", ")", "addSingleVertex", "(", "doc", ",", "iterable", ",", "fieldName", ",", "connection", ",", "(", "(", "ORecordLazyMultiValue", ")", "coll", ")", ".", "rawIterator", "(", ")", ".", "next", "(", ")", ",", "iLabels", ")", ";", "else", "if", "(", "coll", "instanceof", "List", "<", "?", ">", ")", "addSingleVertex", "(", "doc", ",", "iterable", ",", "fieldName", ",", "connection", ",", "(", "(", "List", "<", "?", ">", ")", "coll", ")", ".", "get", "(", "0", ")", ",", "iLabels", ")", ";", "else", "addSingleVertex", "(", "doc", ",", "iterable", ",", "fieldName", ",", "connection", ",", "coll", ".", "iterator", "(", ")", ".", "next", "(", ")", ",", "iLabels", ")", ";", "}", "else", "{", "// CREATE LAZY Iterable AGAINST COLLECTION FIELD", "if", "(", "coll", "instanceof", "ORecordLazyMultiValue", ")", "iterable", ".", "add", "(", "new", "OrientVertexIterator", "(", "this", ",", "coll", ",", "(", "(", "ORecordLazyMultiValue", ")", "coll", ")", ".", "rawIterator", "(", ")", ",", "connection", ",", "iLabels", ",", "coll", ".", "size", "(", ")", ")", ")", ";", "else", "iterable", ".", "add", "(", "new", "OrientVertexIterator", "(", "this", ",", "coll", ",", "coll", ".", "iterator", "(", ")", ",", "connection", ",", "iLabels", ",", "-", "1", ")", ")", ";", "}", "}", "else", "if", "(", "fieldValue", "instanceof", "ORidBag", ")", "{", "iterable", ".", "add", "(", "new", "OrientVertexIterator", "(", "this", ",", "fieldValue", ",", "(", "(", "ORidBag", ")", "fieldValue", ")", ".", "rawIterator", "(", ")", ",", "connection", ",", "iLabels", ",", "-", "1", ")", ")", ";", "}", "}", "return", "iterable", ";", "}"], "docstring": "Returns a lazy iterable instance against vertices.\n\n@param iDirection The direction between OUT, IN or BOTH\n@param iLabels    Optional varargs of Strings representing edge label to consider", "docstring_tokens": ["Returns", "a", "lazy", "iterable", "instance", "against", "vertices", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java#L405-L450", "partition": "test", "index": 3207, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientElement.java", "func_name": "OrientElement.checkForClassInSchema", "original_string": "protected String checkForClassInSchema(final String className) {\n    if (className == null)\n      return null;\n\n    OrientBaseGraph graph = getGraph();\n    if (graph == null)\n      return className;\n\n    final OSchema schema = graph.getRawGraph().getMetadata().getSchema();\n\n    if (!schema.existsClass(className)) {\n      // CREATE A NEW CLASS AT THE FLY\n      try {\n        graph.executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {\n\n                                 @Override public OClass call(final OrientBaseGraph g) {\n                                   return schema.createClass(className, schema.getClass(getBaseClassName()));\n\n                                 }\n                               }, \"Committing the active transaction to create the new type '\", className, \"' as subclass of '\", getBaseClassName(),\n            \"'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction\");\n\n      } catch (OSchemaException e) {\n        if (!schema.existsClass(className))\n          throw e;\n      }\n    } else {\n      // CHECK THE CLASS INHERITANCE\n      final OClass cls = schema.getClass(className);\n      if (!cls.isSubClassOf(getBaseClassName()))\n        throw new IllegalArgumentException(\"Class '\" + className + \"' is not an instance of \" + getBaseClassName());\n    }\n\n    return className;\n  }", "language": "java", "code": "protected String checkForClassInSchema(final String className) {\n    if (className == null)\n      return null;\n\n    OrientBaseGraph graph = getGraph();\n    if (graph == null)\n      return className;\n\n    final OSchema schema = graph.getRawGraph().getMetadata().getSchema();\n\n    if (!schema.existsClass(className)) {\n      // CREATE A NEW CLASS AT THE FLY\n      try {\n        graph.executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {\n\n                                 @Override public OClass call(final OrientBaseGraph g) {\n                                   return schema.createClass(className, schema.getClass(getBaseClassName()));\n\n                                 }\n                               }, \"Committing the active transaction to create the new type '\", className, \"' as subclass of '\", getBaseClassName(),\n            \"'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction\");\n\n      } catch (OSchemaException e) {\n        if (!schema.existsClass(className))\n          throw e;\n      }\n    } else {\n      // CHECK THE CLASS INHERITANCE\n      final OClass cls = schema.getClass(className);\n      if (!cls.isSubClassOf(getBaseClassName()))\n        throw new IllegalArgumentException(\"Class '\" + className + \"' is not an instance of \" + getBaseClassName());\n    }\n\n    return className;\n  }", "code_tokens": ["protected", "String", "checkForClassInSchema", "(", "final", "String", "className", ")", "{", "if", "(", "className", "==", "null", ")", "return", "null", ";", "OrientBaseGraph", "graph", "=", "getGraph", "(", ")", ";", "if", "(", "graph", "==", "null", ")", "return", "className", ";", "final", "OSchema", "schema", "=", "graph", ".", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ";", "if", "(", "!", "schema", ".", "existsClass", "(", "className", ")", ")", "{", "// CREATE A NEW CLASS AT THE FLY", "try", "{", "graph", ".", "executeOutsideTx", "(", "new", "OCallable", "<", "OClass", ",", "OrientBaseGraph", ">", "(", ")", "{", "@", "Override", "public", "OClass", "call", "(", "final", "OrientBaseGraph", "g", ")", "{", "return", "schema", ".", "createClass", "(", "className", ",", "schema", ".", "getClass", "(", "getBaseClassName", "(", ")", ")", ")", ";", "}", "}", ",", "\"Committing the active transaction to create the new type '\"", ",", "className", ",", "\"' as subclass of '\"", ",", "getBaseClassName", "(", ")", ",", "\"'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction\"", ")", ";", "}", "catch", "(", "OSchemaException", "e", ")", "{", "if", "(", "!", "schema", ".", "existsClass", "(", "className", ")", ")", "throw", "e", ";", "}", "}", "else", "{", "// CHECK THE CLASS INHERITANCE", "final", "OClass", "cls", "=", "schema", ".", "getClass", "(", "className", ")", ";", "if", "(", "!", "cls", ".", "isSubClassOf", "(", "getBaseClassName", "(", ")", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Class '\"", "+", "className", "+", "\"' is not an instance of \"", "+", "getBaseClassName", "(", ")", ")", ";", "}", "return", "className", ";", "}"], "docstring": "Check if a class already exists, otherwise create it at the fly. If a transaction is running commit changes, create the class\nand begin a new transaction.\n\n@param className Class's name", "docstring_tokens": ["Check", "if", "a", "class", "already", "exists", "otherwise", "create", "it", "at", "the", "fly", ".", "If", "a", "transaction", "is", "running", "commit", "changes", "create", "the", "class", "and", "begin", "a", "new", "transaction", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientElement.java#L602-L636", "partition": "test", "index": 3069, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientElement.java", "func_name": "OrientElement.removeProperty", "original_string": "@Override public <T> T removeProperty(final String key) {\n    if (checkDeletedInTx())\n      throw new IllegalStateException(\"The vertex \" + getIdentity() + \" has been deleted\");\n\n    final OrientBaseGraph graph = getGraph();\n\n    if (graph != null)\n      graph.autoStartTransaction();\n\n    final Object oldValue = getRecord().removeField(key);\n    if (graph != null)\n      save();\n    return (T) oldValue;\n  }", "language": "java", "code": "@Override public <T> T removeProperty(final String key) {\n    if (checkDeletedInTx())\n      throw new IllegalStateException(\"The vertex \" + getIdentity() + \" has been deleted\");\n\n    final OrientBaseGraph graph = getGraph();\n\n    if (graph != null)\n      graph.autoStartTransaction();\n\n    final Object oldValue = getRecord().removeField(key);\n    if (graph != null)\n      save();\n    return (T) oldValue;\n  }", "code_tokens": ["@", "Override", "public", "<", "T", ">", "T", "removeProperty", "(", "final", "String", "key", ")", "{", "if", "(", "checkDeletedInTx", "(", ")", ")", "throw", "new", "IllegalStateException", "(", "\"The vertex \"", "+", "getIdentity", "(", ")", "+", "\" has been deleted\"", ")", ";", "final", "OrientBaseGraph", "graph", "=", "getGraph", "(", ")", ";", "if", "(", "graph", "!=", "null", ")", "graph", ".", "autoStartTransaction", "(", ")", ";", "final", "Object", "oldValue", "=", "getRecord", "(", ")", ".", "removeField", "(", "key", ")", ";", "if", "(", "graph", "!=", "null", ")", "save", "(", ")", ";", "return", "(", "T", ")", "oldValue", ";", "}"], "docstring": "Removes a Property.\n\n@param key Property name\n@return Old value if any", "docstring_tokens": ["Removes", "a", "Property", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientElement.java#L223-L236", "partition": "test", "index": 3068, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientElement.java", "func_name": "OrientElement.setProperty", "original_string": "@Override public void setProperty(final String key, final Object value) {\n    if (checkDeletedInTx())\n      graph.throwRecordNotFoundException(getIdentity(), \"The graph element \" + getIdentity() + \" has been deleted\");\n\n    validateProperty(this, key, value);\n    final OrientBaseGraph graph = getGraph();\n\n    if (graph != null)\n      graph.autoStartTransaction();\n    getRecord().field(key, value);\n    if (graph != null)\n      save();\n  }", "language": "java", "code": "@Override public void setProperty(final String key, final Object value) {\n    if (checkDeletedInTx())\n      graph.throwRecordNotFoundException(getIdentity(), \"The graph element \" + getIdentity() + \" has been deleted\");\n\n    validateProperty(this, key, value);\n    final OrientBaseGraph graph = getGraph();\n\n    if (graph != null)\n      graph.autoStartTransaction();\n    getRecord().field(key, value);\n    if (graph != null)\n      save();\n  }", "code_tokens": ["@", "Override", "public", "void", "setProperty", "(", "final", "String", "key", ",", "final", "Object", "value", ")", "{", "if", "(", "checkDeletedInTx", "(", ")", ")", "graph", ".", "throwRecordNotFoundException", "(", "getIdentity", "(", ")", ",", "\"The graph element \"", "+", "getIdentity", "(", ")", "+", "\" has been deleted\"", ")", ";", "validateProperty", "(", "this", ",", "key", ",", "value", ")", ";", "final", "OrientBaseGraph", "graph", "=", "getGraph", "(", ")", ";", "if", "(", "graph", "!=", "null", ")", "graph", ".", "autoStartTransaction", "(", ")", ";", "getRecord", "(", ")", ".", "field", "(", "key", ",", "value", ")", ";", "if", "(", "graph", "!=", "null", ")", "save", "(", ")", ";", "}"], "docstring": "Sets a Property value.\n\n@param key   Property name\n@param value Property value", "docstring_tokens": ["Sets", "a", "Property", "value", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientElement.java#L181-L193", "partition": "test", "index": 3067, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java", "func_name": "OrientVertex.getConnection", "original_string": "protected OPair<Direction, String> getConnection(final Direction iDirection, final String iFieldName, String... iClassNames) {\n    if (iClassNames != null && iClassNames.length == 1 && iClassNames[0].equalsIgnoreCase(\"E\"))\n      // DEFAULT CLASS, TREAT IT AS NO CLASS/LABEL\n      iClassNames = null;\n\n    final OrientBaseGraph graph = getGraph();\n    if (iDirection == Direction.OUT || iDirection == Direction.BOTH) {\n      if (settings.isUseVertexFieldsForEdgeLabels()) {\n        // FIELDS THAT STARTS WITH \"out_\"\n        if (iFieldName.startsWith(CONNECTION_OUT_PREFIX)) {\n          String connClass = getConnectionClass(Direction.OUT, iFieldName);\n          if (iClassNames == null || iClassNames.length == 0)\n            return new OPair<Direction, String>(Direction.OUT, connClass);\n\n          // CHECK AGAINST ALL THE CLASS NAMES\n          OrientEdgeType edgeType = graph.getEdgeType(connClass);\n          if (edgeType != null) {\n            for (String clsName : iClassNames) {\n              if (edgeType.isSubClassOf(clsName))\n                return new OPair<Direction, String>(Direction.OUT, connClass);\n            }\n          }\n        }\n      } else if (iFieldName.equals(OrientBaseGraph.CONNECTION_OUT))\n        // CHECK FOR \"out\"\n        return new OPair<Direction, String>(Direction.OUT, null);\n    }\n\n    if (iDirection == Direction.IN || iDirection == Direction.BOTH) {\n      if (settings.isUseVertexFieldsForEdgeLabels()) {\n        // FIELDS THAT STARTS WITH \"in_\"\n        if (iFieldName.startsWith(CONNECTION_IN_PREFIX)) {\n          String connClass = getConnectionClass(Direction.IN, iFieldName);\n          if (iClassNames == null || iClassNames.length == 0)\n            return new OPair<Direction, String>(Direction.IN, connClass);\n\n          // CHECK AGAINST ALL THE CLASS NAMES\n          OrientEdgeType edgeType = graph.getEdgeType(connClass);\n          if (edgeType != null) {\n            for (String clsName : iClassNames) {\n              if (edgeType.isSubClassOf(clsName))\n                return new OPair<Direction, String>(Direction.IN, connClass);\n            }\n          }\n        }\n      } else if (iFieldName.equals(OrientBaseGraph.CONNECTION_IN))\n        // CHECK FOR \"in\"\n        return new OPair<Direction, String>(Direction.IN, null);\n    }\n\n    // NOT FOUND\n    return null;\n  }", "language": "java", "code": "protected OPair<Direction, String> getConnection(final Direction iDirection, final String iFieldName, String... iClassNames) {\n    if (iClassNames != null && iClassNames.length == 1 && iClassNames[0].equalsIgnoreCase(\"E\"))\n      // DEFAULT CLASS, TREAT IT AS NO CLASS/LABEL\n      iClassNames = null;\n\n    final OrientBaseGraph graph = getGraph();\n    if (iDirection == Direction.OUT || iDirection == Direction.BOTH) {\n      if (settings.isUseVertexFieldsForEdgeLabels()) {\n        // FIELDS THAT STARTS WITH \"out_\"\n        if (iFieldName.startsWith(CONNECTION_OUT_PREFIX)) {\n          String connClass = getConnectionClass(Direction.OUT, iFieldName);\n          if (iClassNames == null || iClassNames.length == 0)\n            return new OPair<Direction, String>(Direction.OUT, connClass);\n\n          // CHECK AGAINST ALL THE CLASS NAMES\n          OrientEdgeType edgeType = graph.getEdgeType(connClass);\n          if (edgeType != null) {\n            for (String clsName : iClassNames) {\n              if (edgeType.isSubClassOf(clsName))\n                return new OPair<Direction, String>(Direction.OUT, connClass);\n            }\n          }\n        }\n      } else if (iFieldName.equals(OrientBaseGraph.CONNECTION_OUT))\n        // CHECK FOR \"out\"\n        return new OPair<Direction, String>(Direction.OUT, null);\n    }\n\n    if (iDirection == Direction.IN || iDirection == Direction.BOTH) {\n      if (settings.isUseVertexFieldsForEdgeLabels()) {\n        // FIELDS THAT STARTS WITH \"in_\"\n        if (iFieldName.startsWith(CONNECTION_IN_PREFIX)) {\n          String connClass = getConnectionClass(Direction.IN, iFieldName);\n          if (iClassNames == null || iClassNames.length == 0)\n            return new OPair<Direction, String>(Direction.IN, connClass);\n\n          // CHECK AGAINST ALL THE CLASS NAMES\n          OrientEdgeType edgeType = graph.getEdgeType(connClass);\n          if (edgeType != null) {\n            for (String clsName : iClassNames) {\n              if (edgeType.isSubClassOf(clsName))\n                return new OPair<Direction, String>(Direction.IN, connClass);\n            }\n          }\n        }\n      } else if (iFieldName.equals(OrientBaseGraph.CONNECTION_IN))\n        // CHECK FOR \"in\"\n        return new OPair<Direction, String>(Direction.IN, null);\n    }\n\n    // NOT FOUND\n    return null;\n  }", "code_tokens": ["protected", "OPair", "<", "Direction", ",", "String", ">", "getConnection", "(", "final", "Direction", "iDirection", ",", "final", "String", "iFieldName", ",", "String", "...", "iClassNames", ")", "{", "if", "(", "iClassNames", "!=", "null", "&&", "iClassNames", ".", "length", "==", "1", "&&", "iClassNames", "[", "0", "]", ".", "equalsIgnoreCase", "(", "\"E\"", ")", ")", "// DEFAULT CLASS, TREAT IT AS NO CLASS/LABEL", "iClassNames", "=", "null", ";", "final", "OrientBaseGraph", "graph", "=", "getGraph", "(", ")", ";", "if", "(", "iDirection", "==", "Direction", ".", "OUT", "||", "iDirection", "==", "Direction", ".", "BOTH", ")", "{", "if", "(", "settings", ".", "isUseVertexFieldsForEdgeLabels", "(", ")", ")", "{", "// FIELDS THAT STARTS WITH \"out_\"", "if", "(", "iFieldName", ".", "startsWith", "(", "CONNECTION_OUT_PREFIX", ")", ")", "{", "String", "connClass", "=", "getConnectionClass", "(", "Direction", ".", "OUT", ",", "iFieldName", ")", ";", "if", "(", "iClassNames", "==", "null", "||", "iClassNames", ".", "length", "==", "0", ")", "return", "new", "OPair", "<", "Direction", ",", "String", ">", "(", "Direction", ".", "OUT", ",", "connClass", ")", ";", "// CHECK AGAINST ALL THE CLASS NAMES", "OrientEdgeType", "edgeType", "=", "graph", ".", "getEdgeType", "(", "connClass", ")", ";", "if", "(", "edgeType", "!=", "null", ")", "{", "for", "(", "String", "clsName", ":", "iClassNames", ")", "{", "if", "(", "edgeType", ".", "isSubClassOf", "(", "clsName", ")", ")", "return", "new", "OPair", "<", "Direction", ",", "String", ">", "(", "Direction", ".", "OUT", ",", "connClass", ")", ";", "}", "}", "}", "}", "else", "if", "(", "iFieldName", ".", "equals", "(", "OrientBaseGraph", ".", "CONNECTION_OUT", ")", ")", "// CHECK FOR \"out\"", "return", "new", "OPair", "<", "Direction", ",", "String", ">", "(", "Direction", ".", "OUT", ",", "null", ")", ";", "}", "if", "(", "iDirection", "==", "Direction", ".", "IN", "||", "iDirection", "==", "Direction", ".", "BOTH", ")", "{", "if", "(", "settings", ".", "isUseVertexFieldsForEdgeLabels", "(", ")", ")", "{", "// FIELDS THAT STARTS WITH \"in_\"", "if", "(", "iFieldName", ".", "startsWith", "(", "CONNECTION_IN_PREFIX", ")", ")", "{", "String", "connClass", "=", "getConnectionClass", "(", "Direction", ".", "IN", ",", "iFieldName", ")", ";", "if", "(", "iClassNames", "==", "null", "||", "iClassNames", ".", "length", "==", "0", ")", "return", "new", "OPair", "<", "Direction", ",", "String", ">", "(", "Direction", ".", "IN", ",", "connClass", ")", ";", "// CHECK AGAINST ALL THE CLASS NAMES", "OrientEdgeType", "edgeType", "=", "graph", ".", "getEdgeType", "(", "connClass", ")", ";", "if", "(", "edgeType", "!=", "null", ")", "{", "for", "(", "String", "clsName", ":", "iClassNames", ")", "{", "if", "(", "edgeType", ".", "isSubClassOf", "(", "clsName", ")", ")", "return", "new", "OPair", "<", "Direction", ",", "String", ">", "(", "Direction", ".", "IN", ",", "connClass", ")", ";", "}", "}", "}", "}", "else", "if", "(", "iFieldName", ".", "equals", "(", "OrientBaseGraph", ".", "CONNECTION_IN", ")", ")", "// CHECK FOR \"in\"", "return", "new", "OPair", "<", "Direction", ",", "String", ">", "(", "Direction", ".", "IN", ",", "null", ")", ";", "}", "// NOT FOUND", "return", "null", ";", "}"], "docstring": "Determines if a field is a connections or not.\n\n@param iDirection  Direction to check\n@param iFieldName  Field name\n@param iClassNames Optional array of class names\n\n@return The found direction if any", "docstring_tokens": ["Determines", "if", "a", "field", "is", "a", "connections", "or", "not", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java#L977-L1029", "partition": "test", "index": 3212, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.addEdge", "original_string": "@Override\n  public OrientEdge addEdge(final Object id, Vertex outVertex, Vertex inVertex, final String label) {\n    makeActive();\n\n    String className = null;\n    String clusterName = null;\n\n    if (id != null) {\n      if (id instanceof String) {\n        // PARSE ARGUMENTS\n        final String[] args = ((String) id).split(\",\");\n        for (String s : args) {\n          if (s.startsWith(CLASS_PREFIX))\n            // GET THE CLASS NAME\n            className = s.substring(CLASS_PREFIX.length());\n          else if (s.startsWith(CLUSTER_PREFIX))\n            // GET THE CLASS NAME\n            clusterName = s.substring(CLUSTER_PREFIX.length());\n        }\n      }\n    }\n\n    // SAVE THE ID TOO?\n    final Object[] fields = isSaveOriginalIds() && id != null ? new Object[] { OrientElement.DEF_ORIGINAL_ID_FIELDNAME, id } : null;\n\n    if (outVertex instanceof PartitionVertex)\n      // WRAPPED: GET THE BASE VERTEX\n      outVertex = ((PartitionVertex) outVertex).getBaseVertex();\n\n    if (inVertex instanceof PartitionVertex)\n      // WRAPPED: GET THE BASE VERTEX\n      inVertex = ((PartitionVertex) inVertex).getBaseVertex();\n\n    return ((OrientVertex) outVertex).addEdge(label, (OrientVertex) inVertex, className, clusterName, fields);\n  }", "language": "java", "code": "@Override\n  public OrientEdge addEdge(final Object id, Vertex outVertex, Vertex inVertex, final String label) {\n    makeActive();\n\n    String className = null;\n    String clusterName = null;\n\n    if (id != null) {\n      if (id instanceof String) {\n        // PARSE ARGUMENTS\n        final String[] args = ((String) id).split(\",\");\n        for (String s : args) {\n          if (s.startsWith(CLASS_PREFIX))\n            // GET THE CLASS NAME\n            className = s.substring(CLASS_PREFIX.length());\n          else if (s.startsWith(CLUSTER_PREFIX))\n            // GET THE CLASS NAME\n            clusterName = s.substring(CLUSTER_PREFIX.length());\n        }\n      }\n    }\n\n    // SAVE THE ID TOO?\n    final Object[] fields = isSaveOriginalIds() && id != null ? new Object[] { OrientElement.DEF_ORIGINAL_ID_FIELDNAME, id } : null;\n\n    if (outVertex instanceof PartitionVertex)\n      // WRAPPED: GET THE BASE VERTEX\n      outVertex = ((PartitionVertex) outVertex).getBaseVertex();\n\n    if (inVertex instanceof PartitionVertex)\n      // WRAPPED: GET THE BASE VERTEX\n      inVertex = ((PartitionVertex) inVertex).getBaseVertex();\n\n    return ((OrientVertex) outVertex).addEdge(label, (OrientVertex) inVertex, className, clusterName, fields);\n  }", "code_tokens": ["@", "Override", "public", "OrientEdge", "addEdge", "(", "final", "Object", "id", ",", "Vertex", "outVertex", ",", "Vertex", "inVertex", ",", "final", "String", "label", ")", "{", "makeActive", "(", ")", ";", "String", "className", "=", "null", ";", "String", "clusterName", "=", "null", ";", "if", "(", "id", "!=", "null", ")", "{", "if", "(", "id", "instanceof", "String", ")", "{", "// PARSE ARGUMENTS", "final", "String", "[", "]", "args", "=", "(", "(", "String", ")", "id", ")", ".", "split", "(", "\",\"", ")", ";", "for", "(", "String", "s", ":", "args", ")", "{", "if", "(", "s", ".", "startsWith", "(", "CLASS_PREFIX", ")", ")", "// GET THE CLASS NAME", "className", "=", "s", ".", "substring", "(", "CLASS_PREFIX", ".", "length", "(", ")", ")", ";", "else", "if", "(", "s", ".", "startsWith", "(", "CLUSTER_PREFIX", ")", ")", "// GET THE CLASS NAME", "clusterName", "=", "s", ".", "substring", "(", "CLUSTER_PREFIX", ".", "length", "(", ")", ")", ";", "}", "}", "}", "// SAVE THE ID TOO?", "final", "Object", "[", "]", "fields", "=", "isSaveOriginalIds", "(", ")", "&&", "id", "!=", "null", "?", "new", "Object", "[", "]", "{", "OrientElement", ".", "DEF_ORIGINAL_ID_FIELDNAME", ",", "id", "}", ":", "null", ";", "if", "(", "outVertex", "instanceof", "PartitionVertex", ")", "// WRAPPED: GET THE BASE VERTEX", "outVertex", "=", "(", "(", "PartitionVertex", ")", "outVertex", ")", ".", "getBaseVertex", "(", ")", ";", "if", "(", "inVertex", "instanceof", "PartitionVertex", ")", "// WRAPPED: GET THE BASE VERTEX", "inVertex", "=", "(", "(", "PartitionVertex", ")", "inVertex", ")", ".", "getBaseVertex", "(", ")", ";", "return", "(", "(", "OrientVertex", ")", "outVertex", ")", ".", "addEdge", "(", "label", ",", "(", "OrientVertex", ")", "inVertex", ",", "className", ",", "clusterName", ",", "fields", ")", ";", "}"], "docstring": "Creates an edge between a source Vertex and a destination Vertex setting label as Edge's label.\n\n@param id        Optional, can contains the Edge's class name by prefixing with \"class:\"\n@param outVertex Source vertex\n@param inVertex  Destination vertex\n@param label     Edge's label", "docstring_tokens": ["Creates", "an", "edge", "between", "a", "source", "Vertex", "and", "a", "destination", "Vertex", "setting", "label", "as", "Edge", "s", "label", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L661-L695", "partition": "test", "index": 3113, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientTransactionalGraph.java", "func_name": "OrientTransactionalGraph.stopTransaction", "original_string": "@SuppressWarnings(\"deprecation\")\n  @Override\n  public void stopTransaction(final Conclusion conclusion) {\n    makeActive();\n\n    if (getDatabase().isClosed() || getDatabase().getTransaction() instanceof OTransactionNoTx\n        || getDatabase().getTransaction().getStatus() != TXSTATUS.BEGUN)\n      return;\n\n    if (Conclusion.SUCCESS == conclusion)\n      commit();\n    else\n      rollback();\n  }", "language": "java", "code": "@SuppressWarnings(\"deprecation\")\n  @Override\n  public void stopTransaction(final Conclusion conclusion) {\n    makeActive();\n\n    if (getDatabase().isClosed() || getDatabase().getTransaction() instanceof OTransactionNoTx\n        || getDatabase().getTransaction().getStatus() != TXSTATUS.BEGUN)\n      return;\n\n    if (Conclusion.SUCCESS == conclusion)\n      commit();\n    else\n      rollback();\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"deprecation\"", ")", "@", "Override", "public", "void", "stopTransaction", "(", "final", "Conclusion", "conclusion", ")", "{", "makeActive", "(", ")", ";", "if", "(", "getDatabase", "(", ")", ".", "isClosed", "(", ")", "||", "getDatabase", "(", ")", ".", "getTransaction", "(", ")", "instanceof", "OTransactionNoTx", "||", "getDatabase", "(", ")", ".", "getTransaction", "(", ")", ".", "getStatus", "(", ")", "!=", "TXSTATUS", ".", "BEGUN", ")", "return", ";", "if", "(", "Conclusion", ".", "SUCCESS", "==", "conclusion", ")", "commit", "(", ")", ";", "else", "rollback", "(", ")", ";", "}"], "docstring": "Closes a transaction.\n\n@param conclusion Can be SUCCESS for commit and FAILURE to rollback.", "docstring_tokens": ["Closes", "a", "transaction", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientTransactionalGraph.java#L160-L173", "partition": "test", "index": 3202, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getVertexBaseType", "original_string": "public OrientVertexType getVertexBaseType() {\n    makeActive();\n\n    return new OrientVertexType(this, getRawGraph().getMetadata().getSchema().getClass(OrientVertexType.CLASS_NAME));\n  }", "language": "java", "code": "public OrientVertexType getVertexBaseType() {\n    makeActive();\n\n    return new OrientVertexType(this, getRawGraph().getMetadata().getSchema().getClass(OrientVertexType.CLASS_NAME));\n  }", "code_tokens": ["public", "OrientVertexType", "getVertexBaseType", "(", ")", "{", "makeActive", "(", ")", ";", "return", "new", "OrientVertexType", "(", "this", ",", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "OrientVertexType", ".", "CLASS_NAME", ")", ")", ";", "}"], "docstring": "Returns the V persistent class as OrientVertexType instance.", "docstring_tokens": ["Returns", "the", "V", "persistent", "class", "as", "OrientVertexType", "instance", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1268-L1272", "partition": "test", "index": 3120, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getVertexType", "original_string": "public OrientVertexType getVertexType(final String iTypeName) {\n    makeActive();\n\n    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iTypeName);\n    if (cls == null)\n      return null;\n\n    OrientVertexType.checkType(cls);\n    return new OrientVertexType(this, cls);\n\n  }", "language": "java", "code": "public OrientVertexType getVertexType(final String iTypeName) {\n    makeActive();\n\n    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iTypeName);\n    if (cls == null)\n      return null;\n\n    OrientVertexType.checkType(cls);\n    return new OrientVertexType(this, cls);\n\n  }", "code_tokens": ["public", "OrientVertexType", "getVertexType", "(", "final", "String", "iTypeName", ")", "{", "makeActive", "(", ")", ";", "final", "OClass", "cls", "=", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "iTypeName", ")", ";", "if", "(", "cls", "==", "null", ")", "return", "null", ";", "OrientVertexType", ".", "checkType", "(", "cls", ")", ";", "return", "new", "OrientVertexType", "(", "this", ",", "cls", ")", ";", "}"], "docstring": "Returns the persistent class for type iTypeName as OrientVertexType instance.\n\n@param iTypeName Vertex class name", "docstring_tokens": ["Returns", "the", "persistent", "class", "for", "type", "iTypeName", "as", "OrientVertexType", "instance", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1279-L1289", "partition": "test", "index": 3121, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraph.java", "func_name": "OrientGraph.getFeatures", "original_string": "public Features getFeatures() {\n    makeActive();\n\n    if (!featuresInitialized) {\n      FEATURES.supportsDuplicateEdges = true;\n      FEATURES.supportsSelfLoops = true;\n      FEATURES.isPersistent = true;\n      FEATURES.supportsVertexIteration = true;\n      FEATURES.supportsVertexIndex = true;\n      FEATURES.ignoresSuppliedIds = true;\n      FEATURES.supportsTransactions = true;\n      FEATURES.supportsVertexKeyIndex = true;\n      FEATURES.supportsKeyIndices = true;\n      FEATURES.isWrapper = false;\n      FEATURES.supportsIndices = true;\n      FEATURES.supportsVertexProperties = true;\n      FEATURES.supportsEdgeProperties = true;\n\n      // For more information on supported types, please see:\n      // http://code.google.com/p/orient/wiki/Types\n      FEATURES.supportsSerializableObjectProperty = true;\n      FEATURES.supportsBooleanProperty = true;\n      FEATURES.supportsDoubleProperty = true;\n      FEATURES.supportsFloatProperty = true;\n      FEATURES.supportsIntegerProperty = true;\n      FEATURES.supportsPrimitiveArrayProperty = true;\n      FEATURES.supportsUniformListProperty = true;\n      FEATURES.supportsMixedListProperty = true;\n      FEATURES.supportsLongProperty = true;\n      FEATURES.supportsMapProperty = true;\n      FEATURES.supportsStringProperty = true;\n      FEATURES.supportsThreadedTransactions = false;\n      FEATURES.supportsThreadIsolatedTransactions = false;\n\n      // DYNAMIC FEATURES BASED ON CONFIGURATION\n      FEATURES.supportsEdgeIndex = !isUseLightweightEdges();\n      FEATURES.supportsEdgeKeyIndex = !isUseLightweightEdges();\n      FEATURES.supportsEdgeIteration = !isUseLightweightEdges();\n      FEATURES.supportsEdgeRetrieval = !isUseLightweightEdges();\n\n      featuresInitialized = true;\n    }\n\n    return FEATURES;\n  }", "language": "java", "code": "public Features getFeatures() {\n    makeActive();\n\n    if (!featuresInitialized) {\n      FEATURES.supportsDuplicateEdges = true;\n      FEATURES.supportsSelfLoops = true;\n      FEATURES.isPersistent = true;\n      FEATURES.supportsVertexIteration = true;\n      FEATURES.supportsVertexIndex = true;\n      FEATURES.ignoresSuppliedIds = true;\n      FEATURES.supportsTransactions = true;\n      FEATURES.supportsVertexKeyIndex = true;\n      FEATURES.supportsKeyIndices = true;\n      FEATURES.isWrapper = false;\n      FEATURES.supportsIndices = true;\n      FEATURES.supportsVertexProperties = true;\n      FEATURES.supportsEdgeProperties = true;\n\n      // For more information on supported types, please see:\n      // http://code.google.com/p/orient/wiki/Types\n      FEATURES.supportsSerializableObjectProperty = true;\n      FEATURES.supportsBooleanProperty = true;\n      FEATURES.supportsDoubleProperty = true;\n      FEATURES.supportsFloatProperty = true;\n      FEATURES.supportsIntegerProperty = true;\n      FEATURES.supportsPrimitiveArrayProperty = true;\n      FEATURES.supportsUniformListProperty = true;\n      FEATURES.supportsMixedListProperty = true;\n      FEATURES.supportsLongProperty = true;\n      FEATURES.supportsMapProperty = true;\n      FEATURES.supportsStringProperty = true;\n      FEATURES.supportsThreadedTransactions = false;\n      FEATURES.supportsThreadIsolatedTransactions = false;\n\n      // DYNAMIC FEATURES BASED ON CONFIGURATION\n      FEATURES.supportsEdgeIndex = !isUseLightweightEdges();\n      FEATURES.supportsEdgeKeyIndex = !isUseLightweightEdges();\n      FEATURES.supportsEdgeIteration = !isUseLightweightEdges();\n      FEATURES.supportsEdgeRetrieval = !isUseLightweightEdges();\n\n      featuresInitialized = true;\n    }\n\n    return FEATURES;\n  }", "code_tokens": ["public", "Features", "getFeatures", "(", ")", "{", "makeActive", "(", ")", ";", "if", "(", "!", "featuresInitialized", ")", "{", "FEATURES", ".", "supportsDuplicateEdges", "=", "true", ";", "FEATURES", ".", "supportsSelfLoops", "=", "true", ";", "FEATURES", ".", "isPersistent", "=", "true", ";", "FEATURES", ".", "supportsVertexIteration", "=", "true", ";", "FEATURES", ".", "supportsVertexIndex", "=", "true", ";", "FEATURES", ".", "ignoresSuppliedIds", "=", "true", ";", "FEATURES", ".", "supportsTransactions", "=", "true", ";", "FEATURES", ".", "supportsVertexKeyIndex", "=", "true", ";", "FEATURES", ".", "supportsKeyIndices", "=", "true", ";", "FEATURES", ".", "isWrapper", "=", "false", ";", "FEATURES", ".", "supportsIndices", "=", "true", ";", "FEATURES", ".", "supportsVertexProperties", "=", "true", ";", "FEATURES", ".", "supportsEdgeProperties", "=", "true", ";", "// For more information on supported types, please see:", "// http://code.google.com/p/orient/wiki/Types", "FEATURES", ".", "supportsSerializableObjectProperty", "=", "true", ";", "FEATURES", ".", "supportsBooleanProperty", "=", "true", ";", "FEATURES", ".", "supportsDoubleProperty", "=", "true", ";", "FEATURES", ".", "supportsFloatProperty", "=", "true", ";", "FEATURES", ".", "supportsIntegerProperty", "=", "true", ";", "FEATURES", ".", "supportsPrimitiveArrayProperty", "=", "true", ";", "FEATURES", ".", "supportsUniformListProperty", "=", "true", ";", "FEATURES", ".", "supportsMixedListProperty", "=", "true", ";", "FEATURES", ".", "supportsLongProperty", "=", "true", ";", "FEATURES", ".", "supportsMapProperty", "=", "true", ";", "FEATURES", ".", "supportsStringProperty", "=", "true", ";", "FEATURES", ".", "supportsThreadedTransactions", "=", "false", ";", "FEATURES", ".", "supportsThreadIsolatedTransactions", "=", "false", ";", "// DYNAMIC FEATURES BASED ON CONFIGURATION", "FEATURES", ".", "supportsEdgeIndex", "=", "!", "isUseLightweightEdges", "(", ")", ";", "FEATURES", ".", "supportsEdgeKeyIndex", "=", "!", "isUseLightweightEdges", "(", ")", ";", "FEATURES", ".", "supportsEdgeIteration", "=", "!", "isUseLightweightEdges", "(", ")", ";", "FEATURES", ".", "supportsEdgeRetrieval", "=", "!", "isUseLightweightEdges", "(", ")", ";", "featuresInitialized", "=", "true", ";", "}", "return", "FEATURES", ";", "}"], "docstring": "Returns the current Graph settings.\n\n@return Features object", "docstring_tokens": ["Returns", "the", "current", "Graph", "settings", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraph.java#L236-L280", "partition": "test", "index": 3007, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getVertex", "original_string": "public OrientVertex getVertex(final Object id) {\n    makeActive();\n\n    if (null == id)\n      throw ExceptionFactory.vertexIdCanNotBeNull();\n\n    if (id instanceof OrientVertex)\n      return (OrientVertex) id;\n    else if (id instanceof ODocument)\n      return getVertexInstance((OIdentifiable) id);\n\n    setCurrentGraphInThreadLocal();\n\n    ORID rid;\n    if (id instanceof OIdentifiable)\n      rid = ((OIdentifiable) id).getIdentity();\n    else {\n      try {\n        rid = new ORecordId(id.toString());\n      } catch (IllegalArgumentException iae) {\n        // orientdb throws IllegalArgumentException: Argument 'xxxx' is\n        // not a RecordId in form of string. Format must be:\n        // <cluster-id>:<cluster-position>\n        return null;\n      }\n    }\n\n    if (!rid.isValid())\n      return null;\n\n    final ORecord rec = rid.getRecord();\n    if (rec == null || !(rec instanceof ODocument))\n      return null;\n\n    final OClass cls = ((ODocument) rec).getSchemaClass();\n    if (cls != null && cls.isEdgeType())\n      throw new IllegalArgumentException(\"Cannot retrieve a vertex with the RID \" + rid + \" because it is an edge\");\n\n    return getVertexInstance(rec);\n  }", "language": "java", "code": "public OrientVertex getVertex(final Object id) {\n    makeActive();\n\n    if (null == id)\n      throw ExceptionFactory.vertexIdCanNotBeNull();\n\n    if (id instanceof OrientVertex)\n      return (OrientVertex) id;\n    else if (id instanceof ODocument)\n      return getVertexInstance((OIdentifiable) id);\n\n    setCurrentGraphInThreadLocal();\n\n    ORID rid;\n    if (id instanceof OIdentifiable)\n      rid = ((OIdentifiable) id).getIdentity();\n    else {\n      try {\n        rid = new ORecordId(id.toString());\n      } catch (IllegalArgumentException iae) {\n        // orientdb throws IllegalArgumentException: Argument 'xxxx' is\n        // not a RecordId in form of string. Format must be:\n        // <cluster-id>:<cluster-position>\n        return null;\n      }\n    }\n\n    if (!rid.isValid())\n      return null;\n\n    final ORecord rec = rid.getRecord();\n    if (rec == null || !(rec instanceof ODocument))\n      return null;\n\n    final OClass cls = ((ODocument) rec).getSchemaClass();\n    if (cls != null && cls.isEdgeType())\n      throw new IllegalArgumentException(\"Cannot retrieve a vertex with the RID \" + rid + \" because it is an edge\");\n\n    return getVertexInstance(rec);\n  }", "code_tokens": ["public", "OrientVertex", "getVertex", "(", "final", "Object", "id", ")", "{", "makeActive", "(", ")", ";", "if", "(", "null", "==", "id", ")", "throw", "ExceptionFactory", ".", "vertexIdCanNotBeNull", "(", ")", ";", "if", "(", "id", "instanceof", "OrientVertex", ")", "return", "(", "OrientVertex", ")", "id", ";", "else", "if", "(", "id", "instanceof", "ODocument", ")", "return", "getVertexInstance", "(", "(", "OIdentifiable", ")", "id", ")", ";", "setCurrentGraphInThreadLocal", "(", ")", ";", "ORID", "rid", ";", "if", "(", "id", "instanceof", "OIdentifiable", ")", "rid", "=", "(", "(", "OIdentifiable", ")", "id", ")", ".", "getIdentity", "(", ")", ";", "else", "{", "try", "{", "rid", "=", "new", "ORecordId", "(", "id", ".", "toString", "(", ")", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "// orientdb throws IllegalArgumentException: Argument 'xxxx' is", "// not a RecordId in form of string. Format must be:", "// <cluster-id>:<cluster-position>", "return", "null", ";", "}", "}", "if", "(", "!", "rid", ".", "isValid", "(", ")", ")", "return", "null", ";", "final", "ORecord", "rec", "=", "rid", ".", "getRecord", "(", ")", ";", "if", "(", "rec", "==", "null", "||", "!", "(", "rec", "instanceof", "ODocument", ")", ")", "return", "null", ";", "final", "OClass", "cls", "=", "(", "(", "ODocument", ")", "rec", ")", ".", "getSchemaClass", "(", ")", ";", "if", "(", "cls", "!=", "null", "&&", "cls", ".", "isEdgeType", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cannot retrieve a vertex with the RID \"", "+", "rid", "+", "\" because it is an edge\"", ")", ";", "return", "getVertexInstance", "(", "rec", ")", ";", "}"], "docstring": "Returns a vertex by an ID.\n\n@param id Can by a String, ODocument or an OIdentifiable object.", "docstring_tokens": ["Returns", "a", "vertex", "by", "an", "ID", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L702-L741", "partition": "test", "index": 3114, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphQuery.java", "func_name": "OrientGraphQuery.edges", "original_string": "@Override\n  public Iterable<Edge> edges() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive() || hasCustomPredicate())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    if (((OrientBaseGraph) graph).isUseLightweightEdges())\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    final StringBuilder text = new StringBuilder(512);\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForEdgeLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Edge>(false, labels);\n      }\n    } else\n      text.append(OrientEdgeType.CLASS_NAME);\n\n    List<Object> queryParams = manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForEdgeLabel())\n      manageLabels(queryParams.size() > 0, text);\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    if (limit > 0 && limit < Integer.MAX_VALUE)\n      query.setLimit(limit);\n\n    return new OrientElementIterable<Edge>(((OrientBaseGraph) graph),\n        ((OrientBaseGraph) graph).getRawGraph().query(query, queryParams.toArray()));\n  }", "language": "java", "code": "@Override\n  public Iterable<Edge> edges() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive() || hasCustomPredicate())\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    if (((OrientBaseGraph) graph).isUseLightweightEdges())\n      return new OrientGraphQueryIterable<Edge>(false, labels);\n\n    final StringBuilder text = new StringBuilder(512);\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForEdgeLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        return new OrientGraphQueryIterable<Edge>(false, labels);\n      }\n    } else\n      text.append(OrientEdgeType.CLASS_NAME);\n\n    List<Object> queryParams = manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForEdgeLabel())\n      manageLabels(queryParams.size() > 0, text);\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    if (limit > 0 && limit < Integer.MAX_VALUE)\n      query.setLimit(limit);\n\n    return new OrientElementIterable<Edge>(((OrientBaseGraph) graph),\n        ((OrientBaseGraph) graph).getRawGraph().query(query, queryParams.toArray()));\n  }", "code_tokens": ["@", "Override", "public", "Iterable", "<", "Edge", ">", "edges", "(", ")", "{", "if", "(", "limit", "==", "0", ")", "return", "Collections", ".", "emptyList", "(", ")", ";", "if", "(", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "getRawGraph", "(", ")", ".", "getTransaction", "(", ")", ".", "isActive", "(", ")", "||", "hasCustomPredicate", "(", ")", ")", "// INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL", "// SUPPORTED USED THE BASIC IMPL", "return", "new", "OrientGraphQueryIterable", "<", "Edge", ">", "(", "false", ",", "labels", ")", ";", "if", "(", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "isUseLightweightEdges", "(", ")", ")", "return", "new", "OrientGraphQueryIterable", "<", "Edge", ">", "(", "false", ",", "labels", ")", ";", "final", "StringBuilder", "text", "=", "new", "StringBuilder", "(", "512", ")", ";", "// GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES", "text", ".", "append", "(", "QUERY_SELECT_FROM", ")", ";", "if", "(", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "isUseClassForEdgeLabel", "(", ")", "&&", "labels", "!=", "null", "&&", "labels", ".", "length", ">", "0", ")", "{", "// FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY", "if", "(", "labels", ".", "length", "==", "1", ")", "// USE THE CLASS NAME", "text", ".", "append", "(", "OrientBaseGraph", ".", "encodeClassName", "(", "labels", "[", "0", "]", ")", ")", ";", "else", "{", "// MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY", "return", "new", "OrientGraphQueryIterable", "<", "Edge", ">", "(", "false", ",", "labels", ")", ";", "}", "}", "else", "text", ".", "append", "(", "OrientEdgeType", ".", "CLASS_NAME", ")", ";", "List", "<", "Object", ">", "queryParams", "=", "manageFilters", "(", "text", ")", ";", "if", "(", "!", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "isUseClassForEdgeLabel", "(", ")", ")", "manageLabels", "(", "queryParams", ".", "size", "(", ")", ">", "0", ",", "text", ")", ";", "final", "OSQLSynchQuery", "<", "OIdentifiable", ">", "query", "=", "new", "OSQLSynchQuery", "<", "OIdentifiable", ">", "(", "text", ".", "toString", "(", ")", ")", ";", "if", "(", "fetchPlan", "!=", "null", ")", "query", ".", "setFetchPlan", "(", "fetchPlan", ")", ";", "if", "(", "limit", ">", "0", "&&", "limit", "<", "Integer", ".", "MAX_VALUE", ")", "query", ".", "setLimit", "(", "limit", ")", ";", "return", "new", "OrientElementIterable", "<", "Edge", ">", "(", "(", "(", "OrientBaseGraph", ")", "graph", ")", ",", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "getRawGraph", "(", ")", ".", "query", "(", "query", ",", "queryParams", ".", "toArray", "(", ")", ")", ")", ";", "}"], "docstring": "Returns the result set of the query as iterable edges.", "docstring_tokens": ["Returns", "the", "result", "set", "of", "the", "query", "as", "iterable", "edges", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphQuery.java#L228-L272", "partition": "test", "index": 3004, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphQuery.java", "func_name": "OrientGraphQuery.vertices", "original_string": "@Override\n  public Iterable<Vertex> vertices() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    OTransaction transaction = ((OrientBaseGraph) graph).getRawGraph().getTransaction();\n    if (transaction.isActive() && transaction.getEntryCount() > 0 || hasCustomPredicate()) {\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      String[] classes = allSubClassesLabels();\n      return new OrientGraphQueryIterable<Vertex>(true, classes);\n    }\n    final StringBuilder text = new StringBuilder(512);\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForVertexLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        String[] classes = allSubClassesLabels();\n        return new OrientGraphQueryIterable<Vertex>(true, classes);\n      }\n    } else\n      text.append(OrientVertexType.CLASS_NAME);\n\n    final List<Object> queryParams = manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForVertexLabel())\n      manageLabels(queryParams.size() > 0, text);\n\n    if (orderBy.length() > 1) {\n      text.append(ORDERBY);\n      text.append(orderBy);\n      text.append(\" \").append(orderByDir).append(\" \");\n    }\n    if (skip > 0 && skip < Integer.MAX_VALUE) {\n      text.append(SKIP);\n      text.append(skip);\n    }\n\n    if (limit > 0 && limit < Integer.MAX_VALUE) {\n      text.append(LIMIT);\n      text.append(limit);\n    }\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    return new OrientElementIterable<Vertex>(((OrientBaseGraph) graph),\n        ((OrientBaseGraph) graph).getRawGraph().query(query, queryParams.toArray()));\n  }", "language": "java", "code": "@Override\n  public Iterable<Vertex> vertices() {\n    if (limit == 0)\n      return Collections.emptyList();\n\n    OTransaction transaction = ((OrientBaseGraph) graph).getRawGraph().getTransaction();\n    if (transaction.isActive() && transaction.getEntryCount() > 0 || hasCustomPredicate()) {\n      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL\n      // SUPPORTED USED THE BASIC IMPL\n      String[] classes = allSubClassesLabels();\n      return new OrientGraphQueryIterable<Vertex>(true, classes);\n    }\n    final StringBuilder text = new StringBuilder(512);\n\n    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES\n    text.append(QUERY_SELECT_FROM);\n\n    if (((OrientBaseGraph) graph).isUseClassForVertexLabel() && labels != null && labels.length > 0) {\n      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY\n      if (labels.length == 1)\n        // USE THE CLASS NAME\n        text.append(OrientBaseGraph.encodeClassName(labels[0]));\n      else {\n        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY\n        String[] classes = allSubClassesLabels();\n        return new OrientGraphQueryIterable<Vertex>(true, classes);\n      }\n    } else\n      text.append(OrientVertexType.CLASS_NAME);\n\n    final List<Object> queryParams = manageFilters(text);\n    if (!((OrientBaseGraph) graph).isUseClassForVertexLabel())\n      manageLabels(queryParams.size() > 0, text);\n\n    if (orderBy.length() > 1) {\n      text.append(ORDERBY);\n      text.append(orderBy);\n      text.append(\" \").append(orderByDir).append(\" \");\n    }\n    if (skip > 0 && skip < Integer.MAX_VALUE) {\n      text.append(SKIP);\n      text.append(skip);\n    }\n\n    if (limit > 0 && limit < Integer.MAX_VALUE) {\n      text.append(LIMIT);\n      text.append(limit);\n    }\n\n    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());\n\n    if (fetchPlan != null)\n      query.setFetchPlan(fetchPlan);\n\n    return new OrientElementIterable<Vertex>(((OrientBaseGraph) graph),\n        ((OrientBaseGraph) graph).getRawGraph().query(query, queryParams.toArray()));\n  }", "code_tokens": ["@", "Override", "public", "Iterable", "<", "Vertex", ">", "vertices", "(", ")", "{", "if", "(", "limit", "==", "0", ")", "return", "Collections", ".", "emptyList", "(", ")", ";", "OTransaction", "transaction", "=", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "getRawGraph", "(", ")", ".", "getTransaction", "(", ")", ";", "if", "(", "transaction", ".", "isActive", "(", ")", "&&", "transaction", ".", "getEntryCount", "(", ")", ">", "0", "||", "hasCustomPredicate", "(", ")", ")", "{", "// INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL", "// SUPPORTED USED THE BASIC IMPL", "String", "[", "]", "classes", "=", "allSubClassesLabels", "(", ")", ";", "return", "new", "OrientGraphQueryIterable", "<", "Vertex", ">", "(", "true", ",", "classes", ")", ";", "}", "final", "StringBuilder", "text", "=", "new", "StringBuilder", "(", "512", ")", ";", "// GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES", "text", ".", "append", "(", "QUERY_SELECT_FROM", ")", ";", "if", "(", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "isUseClassForVertexLabel", "(", ")", "&&", "labels", "!=", "null", "&&", "labels", ".", "length", ">", "0", ")", "{", "// FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY", "if", "(", "labels", ".", "length", "==", "1", ")", "// USE THE CLASS NAME", "text", ".", "append", "(", "OrientBaseGraph", ".", "encodeClassName", "(", "labels", "[", "0", "]", ")", ")", ";", "else", "{", "// MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY", "String", "[", "]", "classes", "=", "allSubClassesLabels", "(", ")", ";", "return", "new", "OrientGraphQueryIterable", "<", "Vertex", ">", "(", "true", ",", "classes", ")", ";", "}", "}", "else", "text", ".", "append", "(", "OrientVertexType", ".", "CLASS_NAME", ")", ";", "final", "List", "<", "Object", ">", "queryParams", "=", "manageFilters", "(", "text", ")", ";", "if", "(", "!", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "isUseClassForVertexLabel", "(", ")", ")", "manageLabels", "(", "queryParams", ".", "size", "(", ")", ">", "0", ",", "text", ")", ";", "if", "(", "orderBy", ".", "length", "(", ")", ">", "1", ")", "{", "text", ".", "append", "(", "ORDERBY", ")", ";", "text", ".", "append", "(", "orderBy", ")", ";", "text", ".", "append", "(", "\" \"", ")", ".", "append", "(", "orderByDir", ")", ".", "append", "(", "\" \"", ")", ";", "}", "if", "(", "skip", ">", "0", "&&", "skip", "<", "Integer", ".", "MAX_VALUE", ")", "{", "text", ".", "append", "(", "SKIP", ")", ";", "text", ".", "append", "(", "skip", ")", ";", "}", "if", "(", "limit", ">", "0", "&&", "limit", "<", "Integer", ".", "MAX_VALUE", ")", "{", "text", ".", "append", "(", "LIMIT", ")", ";", "text", ".", "append", "(", "limit", ")", ";", "}", "final", "OSQLSynchQuery", "<", "OIdentifiable", ">", "query", "=", "new", "OSQLSynchQuery", "<", "OIdentifiable", ">", "(", "text", ".", "toString", "(", ")", ")", ";", "if", "(", "fetchPlan", "!=", "null", ")", "query", ".", "setFetchPlan", "(", "fetchPlan", ")", ";", "return", "new", "OrientElementIterable", "<", "Vertex", ">", "(", "(", "(", "OrientBaseGraph", ")", "graph", ")", ",", "(", "(", "OrientBaseGraph", ")", "graph", ")", ".", "getRawGraph", "(", ")", ".", "query", "(", "query", ",", "queryParams", ".", "toArray", "(", ")", ")", ")", ";", "}"], "docstring": "Returns the result set of the query as iterable vertices.", "docstring_tokens": ["Returns", "the", "result", "set", "of", "the", "query", "as", "iterable", "vertices", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphQuery.java#L147-L203", "partition": "test", "index": 3003, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge.java", "func_name": "OrientEdge.getVertex", "original_string": "@Override\n  public OrientVertex getVertex(final Direction direction) {\n    final OrientBaseGraph graph = setCurrentGraphInThreadLocal();\n\n    if (direction.equals(Direction.OUT))\n      return graph.getVertex(getOutVertex());\n    else if (direction.equals(Direction.IN))\n      return graph.getVertex(getInVertex());\n    else\n      throw ExceptionFactory.bothIsNotSupported();\n  }", "language": "java", "code": "@Override\n  public OrientVertex getVertex(final Direction direction) {\n    final OrientBaseGraph graph = setCurrentGraphInThreadLocal();\n\n    if (direction.equals(Direction.OUT))\n      return graph.getVertex(getOutVertex());\n    else if (direction.equals(Direction.IN))\n      return graph.getVertex(getInVertex());\n    else\n      throw ExceptionFactory.bothIsNotSupported();\n  }", "code_tokens": ["@", "Override", "public", "OrientVertex", "getVertex", "(", "final", "Direction", "direction", ")", "{", "final", "OrientBaseGraph", "graph", "=", "setCurrentGraphInThreadLocal", "(", ")", ";", "if", "(", "direction", ".", "equals", "(", "Direction", ".", "OUT", ")", ")", "return", "graph", ".", "getVertex", "(", "getOutVertex", "(", ")", ")", ";", "else", "if", "(", "direction", ".", "equals", "(", "Direction", ".", "IN", ")", ")", "return", "graph", ".", "getVertex", "(", "getInVertex", "(", ")", ")", ";", "else", "throw", "ExceptionFactory", ".", "bothIsNotSupported", "(", ")", ";", "}"], "docstring": "Returns the connected incoming or outgoing vertex.\n\n@param direction Direction between IN or OUT", "docstring_tokens": ["Returns", "the", "connected", "incoming", "or", "outgoing", "vertex", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge.java#L158-L168", "partition": "test", "index": 3270, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge.java", "func_name": "OrientEdge.getId", "original_string": "@Override\n  public Object getId() {\n    if (rawElement == null)\n      // CREATE A TEMPORARY ID\n      return vOut.getIdentity() + \"->\" + vIn.getIdentity();\n\n    setCurrentGraphInThreadLocal();\n\n    return super.getId();\n  }", "language": "java", "code": "@Override\n  public Object getId() {\n    if (rawElement == null)\n      // CREATE A TEMPORARY ID\n      return vOut.getIdentity() + \"->\" + vIn.getIdentity();\n\n    setCurrentGraphInThreadLocal();\n\n    return super.getId();\n  }", "code_tokens": ["@", "Override", "public", "Object", "getId", "(", ")", "{", "if", "(", "rawElement", "==", "null", ")", "// CREATE A TEMPORARY ID", "return", "vOut", ".", "getIdentity", "(", ")", "+", "\"->\"", "+", "vIn", ".", "getIdentity", "(", ")", ";", "setCurrentGraphInThreadLocal", "(", ")", ";", "return", "super", ".", "getId", "(", ")", ";", "}"], "docstring": "Returns the Edge Id assuring to save it if it's transient yet.", "docstring_tokens": ["Returns", "the", "Edge", "Id", "assuring", "to", "save", "it", "if", "it", "s", "transient", "yet", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge.java#L255-L264", "partition": "test", "index": 3271, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge.java", "func_name": "OrientEdge.setProperty", "original_string": "@Override\n  public void setProperty(final String key, final Object value) {\n    setCurrentGraphInThreadLocal();\n\n    if (rawElement == null)\n      // LIGHTWEIGHT EDGE\n      convertToDocument();\n\n    super.setProperty(key, value);\n  }", "language": "java", "code": "@Override\n  public void setProperty(final String key, final Object value) {\n    setCurrentGraphInThreadLocal();\n\n    if (rawElement == null)\n      // LIGHTWEIGHT EDGE\n      convertToDocument();\n\n    super.setProperty(key, value);\n  }", "code_tokens": ["@", "Override", "public", "void", "setProperty", "(", "final", "String", "key", ",", "final", "Object", "value", ")", "{", "setCurrentGraphInThreadLocal", "(", ")", ";", "if", "(", "rawElement", "==", "null", ")", "// LIGHTWEIGHT EDGE", "convertToDocument", "(", ")", ";", "super", ".", "setProperty", "(", "key", ",", "value", ")", ";", "}"], "docstring": "Set a Property value. If the edge is lightweight, it's transparently transformed into a regular edge.\n\n@param key   Property name\n@param value Property value", "docstring_tokens": ["Set", "a", "Property", "value", ".", "If", "the", "edge", "is", "lightweight", "it", "s", "transparently", "transformed", "into", "a", "regular", "edge", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge.java#L335-L344", "partition": "test", "index": 3272, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge.java", "func_name": "OrientEdge.removeProperty", "original_string": "@Override\n  public <T> T removeProperty(String key) {\n    setCurrentGraphInThreadLocal();\n\n    if (rawElement != null)\n      // NON LIGHTWEIGHT EDGE\n      return super.removeProperty(key);\n    return null;\n  }", "language": "java", "code": "@Override\n  public <T> T removeProperty(String key) {\n    setCurrentGraphInThreadLocal();\n\n    if (rawElement != null)\n      // NON LIGHTWEIGHT EDGE\n      return super.removeProperty(key);\n    return null;\n  }", "code_tokens": ["@", "Override", "public", "<", "T", ">", "T", "removeProperty", "(", "String", "key", ")", "{", "setCurrentGraphInThreadLocal", "(", ")", ";", "if", "(", "rawElement", "!=", "null", ")", "// NON LIGHTWEIGHT EDGE", "return", "super", ".", "removeProperty", "(", "key", ")", ";", "return", "null", ";", "}"], "docstring": "Removed a Property.\n\n@param key Property name\n@return Old value if any", "docstring_tokens": ["Removed", "a", "Property", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge.java#L352-L360", "partition": "test", "index": 3273, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.shutdown", "original_string": "public void shutdown(boolean closeDb, boolean commitTx) {\n    makeActive();\n\n    try {\n      if (!isClosed()) {\n        if (commitTx) {\n          final OStorage storage = getDatabase().getStorage().getUnderlying();\n          if (storage instanceof OAbstractPaginatedStorage) {\n            if (((OAbstractPaginatedStorage) storage).getWALInstance() != null)\n              getDatabase().commit();\n          } else {\n            getDatabase().commit();\n          }\n        } else if (closeDb) {\n          getDatabase().rollback();\n        }\n      }\n\n    } catch (ONeedRetryException e) {\n      throw e;\n    } catch (RuntimeException e) {\n      OLogManager.instance().error(this, \"Error during context close for db \" + url, e);\n      throw e;\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Error during context close for db \" + url, e);\n      throw OException.wrapException(new ODatabaseException(\"Error during context close for db \" + url), e);\n    } finally {\n      try {\n        if (closeDb) {\n          getDatabase().close();\n          if (getDatabase().isPooled()) {\n            database = null;\n          }\n        }\n        pollGraphFromStack(closeDb);\n      } catch (Exception e) {\n        OLogManager.instance().error(this, \"Error during context close for db \" + url, e);\n      }\n    }\n\n    url = null;\n    username = null;\n    password = null;\n\n    if (!closeDb)\n      getDatabase().activateOnCurrentThread();\n  }", "language": "java", "code": "public void shutdown(boolean closeDb, boolean commitTx) {\n    makeActive();\n\n    try {\n      if (!isClosed()) {\n        if (commitTx) {\n          final OStorage storage = getDatabase().getStorage().getUnderlying();\n          if (storage instanceof OAbstractPaginatedStorage) {\n            if (((OAbstractPaginatedStorage) storage).getWALInstance() != null)\n              getDatabase().commit();\n          } else {\n            getDatabase().commit();\n          }\n        } else if (closeDb) {\n          getDatabase().rollback();\n        }\n      }\n\n    } catch (ONeedRetryException e) {\n      throw e;\n    } catch (RuntimeException e) {\n      OLogManager.instance().error(this, \"Error during context close for db \" + url, e);\n      throw e;\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Error during context close for db \" + url, e);\n      throw OException.wrapException(new ODatabaseException(\"Error during context close for db \" + url), e);\n    } finally {\n      try {\n        if (closeDb) {\n          getDatabase().close();\n          if (getDatabase().isPooled()) {\n            database = null;\n          }\n        }\n        pollGraphFromStack(closeDb);\n      } catch (Exception e) {\n        OLogManager.instance().error(this, \"Error during context close for db \" + url, e);\n      }\n    }\n\n    url = null;\n    username = null;\n    password = null;\n\n    if (!closeDb)\n      getDatabase().activateOnCurrentThread();\n  }", "code_tokens": ["public", "void", "shutdown", "(", "boolean", "closeDb", ",", "boolean", "commitTx", ")", "{", "makeActive", "(", ")", ";", "try", "{", "if", "(", "!", "isClosed", "(", ")", ")", "{", "if", "(", "commitTx", ")", "{", "final", "OStorage", "storage", "=", "getDatabase", "(", ")", ".", "getStorage", "(", ")", ".", "getUnderlying", "(", ")", ";", "if", "(", "storage", "instanceof", "OAbstractPaginatedStorage", ")", "{", "if", "(", "(", "(", "OAbstractPaginatedStorage", ")", "storage", ")", ".", "getWALInstance", "(", ")", "!=", "null", ")", "getDatabase", "(", ")", ".", "commit", "(", ")", ";", "}", "else", "{", "getDatabase", "(", ")", ".", "commit", "(", ")", ";", "}", "}", "else", "if", "(", "closeDb", ")", "{", "getDatabase", "(", ")", ".", "rollback", "(", ")", ";", "}", "}", "}", "catch", "(", "ONeedRetryException", "e", ")", "{", "throw", "e", ";", "}", "catch", "(", "RuntimeException", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error during context close for db \"", "+", "url", ",", "e", ")", ";", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error during context close for db \"", "+", "url", ",", "e", ")", ";", "throw", "OException", ".", "wrapException", "(", "new", "ODatabaseException", "(", "\"Error during context close for db \"", "+", "url", ")", ",", "e", ")", ";", "}", "finally", "{", "try", "{", "if", "(", "closeDb", ")", "{", "getDatabase", "(", ")", ".", "close", "(", ")", ";", "if", "(", "getDatabase", "(", ")", ".", "isPooled", "(", ")", ")", "{", "database", "=", "null", ";", "}", "}", "pollGraphFromStack", "(", "closeDb", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error during context close for db \"", "+", "url", ",", "e", ")", ";", "}", "}", "url", "=", "null", ";", "username", "=", "null", ";", "password", "=", "null", ";", "if", "(", "!", "closeDb", ")", "getDatabase", "(", ")", ".", "activateOnCurrentThread", "(", ")", ";", "}"], "docstring": "Closes the Graph. After closing the Graph cannot be used.", "docstring_tokens": ["Closes", "the", "Graph", ".", "After", "closing", "the", "Graph", "cannot", "be", "used", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1179-L1225", "partition": "test", "index": 3119, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getEdgeType", "original_string": "public OrientEdgeType getEdgeType(final String iTypeName) {\n    makeActive();\n\n    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iTypeName);\n    if (cls == null)\n      return null;\n\n    OrientEdgeType.checkType(cls);\n    return new OrientEdgeType(this, cls);\n  }", "language": "java", "code": "public OrientEdgeType getEdgeType(final String iTypeName) {\n    makeActive();\n\n    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iTypeName);\n    if (cls == null)\n      return null;\n\n    OrientEdgeType.checkType(cls);\n    return new OrientEdgeType(this, cls);\n  }", "code_tokens": ["public", "OrientEdgeType", "getEdgeType", "(", "final", "String", "iTypeName", ")", "{", "makeActive", "(", ")", ";", "final", "OClass", "cls", "=", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "iTypeName", ")", ";", "if", "(", "cls", "==", "null", ")", "return", "null", ";", "OrientEdgeType", ".", "checkType", "(", "cls", ")", ";", "return", "new", "OrientEdgeType", "(", "this", ",", "cls", ")", ";", "}"], "docstring": "Returns the persistent class for type iTypeName as OrientEdgeType instance.\n\n@param iTypeName Edge class name", "docstring_tokens": ["Returns", "the", "persistent", "class", "for", "type", "iTypeName", "as", "OrientEdgeType", "instance", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1423-L1432", "partition": "test", "index": 3124, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.dropKeyIndex", "original_string": "public <T extends Element> void dropKeyIndex(final String key, final Class<T> elementClass) {\n    makeActive();\n\n    if (elementClass == null)\n      throw ExceptionFactory.classForElementCannotBeNull();\n\n    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {\n      @Override\n      public OClass call(final OrientBaseGraph g) {\n        final String className = getClassName(elementClass);\n        getRawGraph().getMetadata().getIndexManager().dropIndex(className + \".\" + key);\n        return null;\n      }\n    }, \"drop key index '\", elementClass.getSimpleName(), \".\", key, \"'\");\n\n  }", "language": "java", "code": "public <T extends Element> void dropKeyIndex(final String key, final Class<T> elementClass) {\n    makeActive();\n\n    if (elementClass == null)\n      throw ExceptionFactory.classForElementCannotBeNull();\n\n    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {\n      @Override\n      public OClass call(final OrientBaseGraph g) {\n        final String className = getClassName(elementClass);\n        getRawGraph().getMetadata().getIndexManager().dropIndex(className + \".\" + key);\n        return null;\n      }\n    }, \"drop key index '\", elementClass.getSimpleName(), \".\", key, \"'\");\n\n  }", "code_tokens": ["public", "<", "T", "extends", "Element", ">", "void", "dropKeyIndex", "(", "final", "String", "key", ",", "final", "Class", "<", "T", ">", "elementClass", ")", "{", "makeActive", "(", ")", ";", "if", "(", "elementClass", "==", "null", ")", "throw", "ExceptionFactory", ".", "classForElementCannotBeNull", "(", ")", ";", "executeOutsideTx", "(", "new", "OCallable", "<", "OClass", ",", "OrientBaseGraph", ">", "(", ")", "{", "@", "Override", "public", "OClass", "call", "(", "final", "OrientBaseGraph", "g", ")", "{", "final", "String", "className", "=", "getClassName", "(", "elementClass", ")", ";", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ".", "dropIndex", "(", "className", "+", "\".\"", "+", "key", ")", ";", "return", "null", ";", "}", "}", ",", "\"drop key index '\"", ",", "elementClass", ".", "getSimpleName", "(", ")", ",", "\".\"", ",", "key", ",", "\"'\"", ")", ";", "}"], "docstring": "Drops the index against a field name.\n\n@param key          Field name\n@param elementClass Element class as instances of Vertex and Edge", "docstring_tokens": ["Drops", "the", "index", "against", "a", "field", "name", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1629-L1644", "partition": "test", "index": 3127, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.reuse", "original_string": "public OrientBaseGraph reuse(final ODatabaseDocumentInternal iDatabase) {\n    ODatabaseRecordThreadLocal.instance().set(iDatabase);\n    this.url = iDatabase.getURL();\n    database = iDatabase;\n\n    makeActive();\n\n    return this;\n  }", "language": "java", "code": "public OrientBaseGraph reuse(final ODatabaseDocumentInternal iDatabase) {\n    ODatabaseRecordThreadLocal.instance().set(iDatabase);\n    this.url = iDatabase.getURL();\n    database = iDatabase;\n\n    makeActive();\n\n    return this;\n  }", "code_tokens": ["public", "OrientBaseGraph", "reuse", "(", "final", "ODatabaseDocumentInternal", "iDatabase", ")", "{", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "set", "(", "iDatabase", ")", ";", "this", ".", "url", "=", "iDatabase", ".", "getURL", "(", ")", ";", "database", "=", "iDatabase", ";", "makeActive", "(", ")", ";", "return", "this", ";", "}"], "docstring": "Reuses the underlying database avoiding to create and open it every time.\n\n@param iDatabase Underlying database object", "docstring_tokens": ["Reuses", "the", "underlying", "database", "avoiding", "to", "create", "and", "open", "it", "every", "time", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1143-L1151", "partition": "test", "index": 3118, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getEdge", "original_string": "public OrientEdge getEdge(final Object id) {\n    makeActive();\n\n    if (null == id)\n      throw ExceptionFactory.edgeIdCanNotBeNull();\n\n    if (id instanceof OrientEdge)\n      return (OrientEdge) id;\n    else if (id instanceof ODocument)\n      return new OrientEdge(this, (OIdentifiable) id);\n\n    final OIdentifiable rec;\n    if (id instanceof OIdentifiable)\n      rec = (OIdentifiable) id;\n    else {\n      final String str = id.toString();\n\n      int pos = str.indexOf(\"->\");\n\n      if (pos > -1) {\n        // DUMMY EDGE: CREATE IT IN MEMORY\n        final String from = str.substring(0, pos);\n        final String to = str.substring(pos + 2);\n        return getEdgeInstance(new ORecordId(from), new ORecordId(to), null);\n      }\n\n      try {\n        rec = new ORecordId(str);\n      } catch (IllegalArgumentException iae) {\n        // orientdb throws IllegalArgumentException: Argument 'xxxx' is\n        // not a RecordId in form of string. Format must be:\n        // [#]<cluster-id>:<cluster-position>\n        return null;\n      }\n    }\n\n    final ODocument doc = rec.getRecord();\n    if (doc == null)\n      return null;\n\n    final OClass cls = doc.getSchemaClass();\n    if (cls != null) {\n      if (cls.isVertexType())\n        throw new IllegalArgumentException(\"Cannot retrieve an edge with the RID \" + id + \" because it is a vertex\");\n\n      if (!cls.isEdgeType())\n        throw new IllegalArgumentException(\"Class '\" + doc.getClassName() + \"' is not an edge class\");\n    }\n\n    return new OrientEdge(this, rec);\n  }", "language": "java", "code": "public OrientEdge getEdge(final Object id) {\n    makeActive();\n\n    if (null == id)\n      throw ExceptionFactory.edgeIdCanNotBeNull();\n\n    if (id instanceof OrientEdge)\n      return (OrientEdge) id;\n    else if (id instanceof ODocument)\n      return new OrientEdge(this, (OIdentifiable) id);\n\n    final OIdentifiable rec;\n    if (id instanceof OIdentifiable)\n      rec = (OIdentifiable) id;\n    else {\n      final String str = id.toString();\n\n      int pos = str.indexOf(\"->\");\n\n      if (pos > -1) {\n        // DUMMY EDGE: CREATE IT IN MEMORY\n        final String from = str.substring(0, pos);\n        final String to = str.substring(pos + 2);\n        return getEdgeInstance(new ORecordId(from), new ORecordId(to), null);\n      }\n\n      try {\n        rec = new ORecordId(str);\n      } catch (IllegalArgumentException iae) {\n        // orientdb throws IllegalArgumentException: Argument 'xxxx' is\n        // not a RecordId in form of string. Format must be:\n        // [#]<cluster-id>:<cluster-position>\n        return null;\n      }\n    }\n\n    final ODocument doc = rec.getRecord();\n    if (doc == null)\n      return null;\n\n    final OClass cls = doc.getSchemaClass();\n    if (cls != null) {\n      if (cls.isVertexType())\n        throw new IllegalArgumentException(\"Cannot retrieve an edge with the RID \" + id + \" because it is a vertex\");\n\n      if (!cls.isEdgeType())\n        throw new IllegalArgumentException(\"Class '\" + doc.getClassName() + \"' is not an edge class\");\n    }\n\n    return new OrientEdge(this, rec);\n  }", "code_tokens": ["public", "OrientEdge", "getEdge", "(", "final", "Object", "id", ")", "{", "makeActive", "(", ")", ";", "if", "(", "null", "==", "id", ")", "throw", "ExceptionFactory", ".", "edgeIdCanNotBeNull", "(", ")", ";", "if", "(", "id", "instanceof", "OrientEdge", ")", "return", "(", "OrientEdge", ")", "id", ";", "else", "if", "(", "id", "instanceof", "ODocument", ")", "return", "new", "OrientEdge", "(", "this", ",", "(", "OIdentifiable", ")", "id", ")", ";", "final", "OIdentifiable", "rec", ";", "if", "(", "id", "instanceof", "OIdentifiable", ")", "rec", "=", "(", "OIdentifiable", ")", "id", ";", "else", "{", "final", "String", "str", "=", "id", ".", "toString", "(", ")", ";", "int", "pos", "=", "str", ".", "indexOf", "(", "\"->\"", ")", ";", "if", "(", "pos", ">", "-", "1", ")", "{", "// DUMMY EDGE: CREATE IT IN MEMORY", "final", "String", "from", "=", "str", ".", "substring", "(", "0", ",", "pos", ")", ";", "final", "String", "to", "=", "str", ".", "substring", "(", "pos", "+", "2", ")", ";", "return", "getEdgeInstance", "(", "new", "ORecordId", "(", "from", ")", ",", "new", "ORecordId", "(", "to", ")", ",", "null", ")", ";", "}", "try", "{", "rec", "=", "new", "ORecordId", "(", "str", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "// orientdb throws IllegalArgumentException: Argument 'xxxx' is", "// not a RecordId in form of string. Format must be:", "// [#]<cluster-id>:<cluster-position>", "return", "null", ";", "}", "}", "final", "ODocument", "doc", "=", "rec", ".", "getRecord", "(", ")", ";", "if", "(", "doc", "==", "null", ")", "return", "null", ";", "final", "OClass", "cls", "=", "doc", ".", "getSchemaClass", "(", ")", ";", "if", "(", "cls", "!=", "null", ")", "{", "if", "(", "cls", ".", "isVertexType", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cannot retrieve an edge with the RID \"", "+", "id", "+", "\" because it is a vertex\"", ")", ";", "if", "(", "!", "cls", ".", "isEdgeType", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Class '\"", "+", "doc", ".", "getClassName", "(", ")", "+", "\"' is not an edge class\"", ")", ";", "}", "return", "new", "OrientEdge", "(", "this", ",", "rec", ")", ";", "}"], "docstring": "Returns a edge by an ID.\n\n@param id Can by a String, ODocument or an OIdentifiable object.", "docstring_tokens": ["Returns", "a", "edge", "by", "an", "ID", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1075-L1125", "partition": "test", "index": 3117, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getEdgesOfClass", "original_string": "public Iterable<Edge> getEdgesOfClass(final String iClassName, final boolean iPolymorphic) {\n    makeActive();\n\n    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iClassName);\n    if (cls == null)\n      throw new IllegalArgumentException(\"Cannot find class '\" + iClassName + \"' in database schema\");\n\n    if (!cls.isSubClassOf(OrientEdgeType.CLASS_NAME))\n      throw new IllegalArgumentException(\"Class '\" + iClassName + \"' is not an edge class\");\n\n    return new OrientElementScanIterable<Edge>(this, iClassName, iPolymorphic);\n  }", "language": "java", "code": "public Iterable<Edge> getEdgesOfClass(final String iClassName, final boolean iPolymorphic) {\n    makeActive();\n\n    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iClassName);\n    if (cls == null)\n      throw new IllegalArgumentException(\"Cannot find class '\" + iClassName + \"' in database schema\");\n\n    if (!cls.isSubClassOf(OrientEdgeType.CLASS_NAME))\n      throw new IllegalArgumentException(\"Class '\" + iClassName + \"' is not an edge class\");\n\n    return new OrientElementScanIterable<Edge>(this, iClassName, iPolymorphic);\n  }", "code_tokens": ["public", "Iterable", "<", "Edge", ">", "getEdgesOfClass", "(", "final", "String", "iClassName", ",", "final", "boolean", "iPolymorphic", ")", "{", "makeActive", "(", ")", ";", "final", "OClass", "cls", "=", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "iClassName", ")", ";", "if", "(", "cls", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cannot find class '\"", "+", "iClassName", "+", "\"' in database schema\"", ")", ";", "if", "(", "!", "cls", ".", "isSubClassOf", "(", "OrientEdgeType", ".", "CLASS_NAME", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Class '\"", "+", "iClassName", "+", "\"' is not an edge class\"", ")", ";", "return", "new", "OrientElementScanIterable", "<", "Edge", ">", "(", "this", ",", "iClassName", ",", "iPolymorphic", ")", ";", "}"], "docstring": "Get all the Edges in Graph of a specific edges class and all sub-classes only if iPolymorphic is true.\n\n@param iClassName   Edge class name to filter\n@param iPolymorphic If true consider also iClassName Edge sub-classes\n\n@return Edges as Iterable", "docstring_tokens": ["Get", "all", "the", "Edges", "in", "Graph", "of", "a", "specific", "edges", "class", "and", "all", "sub", "-", "classes", "only", "if", "iPolymorphic", "is", "true", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1015-L1026", "partition": "test", "index": 3116, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getVerticesOfClass", "original_string": "public Iterable<Vertex> getVerticesOfClass(final String iClassName, final boolean iPolymorphic) {\n    makeActive();\n\n    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iClassName);\n    if (cls == null)\n      throw new IllegalArgumentException(\"Cannot find class '\" + iClassName + \"' in database schema\");\n\n    if (!cls.isSubClassOf(OrientVertexType.CLASS_NAME))\n      throw new IllegalArgumentException(\"Class '\" + iClassName + \"' is not a vertex class\");\n\n    return new OrientElementScanIterable<Vertex>(this, iClassName, iPolymorphic);\n  }", "language": "java", "code": "public Iterable<Vertex> getVerticesOfClass(final String iClassName, final boolean iPolymorphic) {\n    makeActive();\n\n    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iClassName);\n    if (cls == null)\n      throw new IllegalArgumentException(\"Cannot find class '\" + iClassName + \"' in database schema\");\n\n    if (!cls.isSubClassOf(OrientVertexType.CLASS_NAME))\n      throw new IllegalArgumentException(\"Class '\" + iClassName + \"' is not a vertex class\");\n\n    return new OrientElementScanIterable<Vertex>(this, iClassName, iPolymorphic);\n  }", "code_tokens": ["public", "Iterable", "<", "Vertex", ">", "getVerticesOfClass", "(", "final", "String", "iClassName", ",", "final", "boolean", "iPolymorphic", ")", "{", "makeActive", "(", ")", ";", "final", "OClass", "cls", "=", "getRawGraph", "(", ")", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "iClassName", ")", ";", "if", "(", "cls", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cannot find class '\"", "+", "iClassName", "+", "\"' in database schema\"", ")", ";", "if", "(", "!", "cls", ".", "isSubClassOf", "(", "OrientVertexType", ".", "CLASS_NAME", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Class '\"", "+", "iClassName", "+", "\"' is not a vertex class\"", ")", ";", "return", "new", "OrientElementScanIterable", "<", "Vertex", ">", "(", "this", ",", "iClassName", ",", "iPolymorphic", ")", ";", "}"], "docstring": "Get all the Vertices in Graph of a specific vertex class and all sub-classes only if iPolymorphic is true.\n\n@param iClassName   Vertex class name to filter\n@param iPolymorphic If true consider also Vertex iClassName sub-classes\n\n@return Vertices as Iterable", "docstring_tokens": ["Get", "all", "the", "Vertices", "in", "Graph", "of", "a", "specific", "vertex", "class", "and", "all", "sub", "-", "classes", "only", "if", "iPolymorphic", "is", "true", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L811-L822", "partition": "test", "index": 3115, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.createKeyIndex", "original_string": "@SuppressWarnings({ \"rawtypes\" })\n  @Override\n  public <T extends Element> void createKeyIndex(final String key, final Class<T> elementClass,\n      final Parameter... indexParameters) {\n    makeActive();\n\n    if (elementClass == null)\n      throw ExceptionFactory.classForElementCannotBeNull();\n\n    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {\n      @Override\n      public OClass call(final OrientBaseGraph g) {\n\n        String indexType = OClass.INDEX_TYPE.NOTUNIQUE.name();\n        OType keyType = OType.STRING;\n        String className = null;\n        String collate = null;\n        ODocument metadata = null;\n\n        final String ancestorClassName = getClassName(elementClass);\n\n        // READ PARAMETERS\n        for (Parameter<?, ?> p : indexParameters) {\n          if (p.getKey().equals(\"type\"))\n            indexType = p.getValue().toString().toUpperCase(Locale.ENGLISH);\n          else if (p.getKey().equals(\"keytype\"))\n            keyType = OType.valueOf(p.getValue().toString().toUpperCase(Locale.ENGLISH));\n          else if (p.getKey().equals(\"class\"))\n            className = p.getValue().toString();\n          else if (p.getKey().equals(\"collate\"))\n            collate = p.getValue().toString();\n          else if (p.getKey().toString().startsWith(\"metadata.\")) {\n            if (metadata == null)\n              metadata = new ODocument();\n            metadata.field(p.getKey().toString().substring(\"metadata.\".length()), p.getValue());\n          }\n        }\n\n        if (className == null)\n          className = ancestorClassName;\n\n        final ODatabaseDocument db = getRawGraph();\n        final OSchema schema = db.getMetadata().getSchema();\n\n        final OClass cls = schema.getOrCreateClass(className, schema.getClass(ancestorClassName));\n        final OProperty property = cls.getProperty(key);\n        if (property != null)\n          keyType = property.getType();\n\n        OPropertyIndexDefinition indexDefinition = new OPropertyIndexDefinition(className, key, keyType);\n        if (collate != null)\n          indexDefinition.setCollate(collate);\n        db.getMetadata().getIndexManager()\n            .createIndex(className + \".\" + key, indexType, indexDefinition, cls.getPolymorphicClusterIds(), null, metadata);\n        return null;\n\n      }\n    }, \"create key index on '\", elementClass.getSimpleName(), \".\", key, \"'\");\n  }", "language": "java", "code": "@SuppressWarnings({ \"rawtypes\" })\n  @Override\n  public <T extends Element> void createKeyIndex(final String key, final Class<T> elementClass,\n      final Parameter... indexParameters) {\n    makeActive();\n\n    if (elementClass == null)\n      throw ExceptionFactory.classForElementCannotBeNull();\n\n    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {\n      @Override\n      public OClass call(final OrientBaseGraph g) {\n\n        String indexType = OClass.INDEX_TYPE.NOTUNIQUE.name();\n        OType keyType = OType.STRING;\n        String className = null;\n        String collate = null;\n        ODocument metadata = null;\n\n        final String ancestorClassName = getClassName(elementClass);\n\n        // READ PARAMETERS\n        for (Parameter<?, ?> p : indexParameters) {\n          if (p.getKey().equals(\"type\"))\n            indexType = p.getValue().toString().toUpperCase(Locale.ENGLISH);\n          else if (p.getKey().equals(\"keytype\"))\n            keyType = OType.valueOf(p.getValue().toString().toUpperCase(Locale.ENGLISH));\n          else if (p.getKey().equals(\"class\"))\n            className = p.getValue().toString();\n          else if (p.getKey().equals(\"collate\"))\n            collate = p.getValue().toString();\n          else if (p.getKey().toString().startsWith(\"metadata.\")) {\n            if (metadata == null)\n              metadata = new ODocument();\n            metadata.field(p.getKey().toString().substring(\"metadata.\".length()), p.getValue());\n          }\n        }\n\n        if (className == null)\n          className = ancestorClassName;\n\n        final ODatabaseDocument db = getRawGraph();\n        final OSchema schema = db.getMetadata().getSchema();\n\n        final OClass cls = schema.getOrCreateClass(className, schema.getClass(ancestorClassName));\n        final OProperty property = cls.getProperty(key);\n        if (property != null)\n          keyType = property.getType();\n\n        OPropertyIndexDefinition indexDefinition = new OPropertyIndexDefinition(className, key, keyType);\n        if (collate != null)\n          indexDefinition.setCollate(collate);\n        db.getMetadata().getIndexManager()\n            .createIndex(className + \".\" + key, indexType, indexDefinition, cls.getPolymorphicClusterIds(), null, metadata);\n        return null;\n\n      }\n    }, \"create key index on '\", elementClass.getSimpleName(), \".\", key, \"'\");\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "{", "\"rawtypes\"", "}", ")", "@", "Override", "public", "<", "T", "extends", "Element", ">", "void", "createKeyIndex", "(", "final", "String", "key", ",", "final", "Class", "<", "T", ">", "elementClass", ",", "final", "Parameter", "...", "indexParameters", ")", "{", "makeActive", "(", ")", ";", "if", "(", "elementClass", "==", "null", ")", "throw", "ExceptionFactory", ".", "classForElementCannotBeNull", "(", ")", ";", "executeOutsideTx", "(", "new", "OCallable", "<", "OClass", ",", "OrientBaseGraph", ">", "(", ")", "{", "@", "Override", "public", "OClass", "call", "(", "final", "OrientBaseGraph", "g", ")", "{", "String", "indexType", "=", "OClass", ".", "INDEX_TYPE", ".", "NOTUNIQUE", ".", "name", "(", ")", ";", "OType", "keyType", "=", "OType", ".", "STRING", ";", "String", "className", "=", "null", ";", "String", "collate", "=", "null", ";", "ODocument", "metadata", "=", "null", ";", "final", "String", "ancestorClassName", "=", "getClassName", "(", "elementClass", ")", ";", "// READ PARAMETERS", "for", "(", "Parameter", "<", "?", ",", "?", ">", "p", ":", "indexParameters", ")", "{", "if", "(", "p", ".", "getKey", "(", ")", ".", "equals", "(", "\"type\"", ")", ")", "indexType", "=", "p", ".", "getValue", "(", ")", ".", "toString", "(", ")", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ";", "else", "if", "(", "p", ".", "getKey", "(", ")", ".", "equals", "(", "\"keytype\"", ")", ")", "keyType", "=", "OType", ".", "valueOf", "(", "p", ".", "getValue", "(", ")", ".", "toString", "(", ")", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ")", ";", "else", "if", "(", "p", ".", "getKey", "(", ")", ".", "equals", "(", "\"class\"", ")", ")", "className", "=", "p", ".", "getValue", "(", ")", ".", "toString", "(", ")", ";", "else", "if", "(", "p", ".", "getKey", "(", ")", ".", "equals", "(", "\"collate\"", ")", ")", "collate", "=", "p", ".", "getValue", "(", ")", ".", "toString", "(", ")", ";", "else", "if", "(", "p", ".", "getKey", "(", ")", ".", "toString", "(", ")", ".", "startsWith", "(", "\"metadata.\"", ")", ")", "{", "if", "(", "metadata", "==", "null", ")", "metadata", "=", "new", "ODocument", "(", ")", ";", "metadata", ".", "field", "(", "p", ".", "getKey", "(", ")", ".", "toString", "(", ")", ".", "substring", "(", "\"metadata.\"", ".", "length", "(", ")", ")", ",", "p", ".", "getValue", "(", ")", ")", ";", "}", "}", "if", "(", "className", "==", "null", ")", "className", "=", "ancestorClassName", ";", "final", "ODatabaseDocument", "db", "=", "getRawGraph", "(", ")", ";", "final", "OSchema", "schema", "=", "db", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ";", "final", "OClass", "cls", "=", "schema", ".", "getOrCreateClass", "(", "className", ",", "schema", ".", "getClass", "(", "ancestorClassName", ")", ")", ";", "final", "OProperty", "property", "=", "cls", ".", "getProperty", "(", "key", ")", ";", "if", "(", "property", "!=", "null", ")", "keyType", "=", "property", ".", "getType", "(", ")", ";", "OPropertyIndexDefinition", "indexDefinition", "=", "new", "OPropertyIndexDefinition", "(", "className", ",", "key", ",", "keyType", ")", ";", "if", "(", "collate", "!=", "null", ")", "indexDefinition", ".", "setCollate", "(", "collate", ")", ";", "db", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ".", "createIndex", "(", "className", "+", "\".\"", "+", "key", ",", "indexType", ",", "indexDefinition", ",", "cls", ".", "getPolymorphicClusterIds", "(", ")", ",", "null", ",", "metadata", ")", ";", "return", "null", ";", "}", "}", ",", "\"create key index on '\"", ",", "elementClass", ".", "getSimpleName", "(", ")", ",", "\".\"", ",", "key", ",", "\"'\"", ")", ";", "}"], "docstring": "Creates an automatic indexing structure for indexing provided key for element class.\n\n@param key             the key to create the index for\n@param elementClass    the element class that the index is for\n@param indexParameters a collection of parameters for the underlying index implementation: <ul> <li>\"type\" is the index type\nbetween the supported types (UNIQUE, NOTUNIQUE, FULLTEXT). The default type is NOT_UNIQUE <li>\"class\" is\nthe class to index when it's a custom type derived by Vertex (V) or Edge (E) <li>\"keytype\" to use a key\ntype different by OType.STRING,</li></li> </ul>\n@param <T>             the element class specification", "docstring_tokens": ["Creates", "an", "automatic", "indexing", "structure", "for", "indexing", "provided", "key", "for", "element", "class", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1657-L1715", "partition": "test", "index": 3128, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.getElement", "original_string": "public OrientElement getElement(final Object id) {\n    makeActive();\n\n    if (null == id)\n      throw new IllegalArgumentException(\"id cannot be null\");\n\n    if (id instanceof OrientElement)\n      return (OrientElement) id;\n\n    OIdentifiable rec;\n    if (id instanceof OIdentifiable)\n      rec = (OIdentifiable) id;\n    else\n      try {\n        rec = new ORecordId(id.toString());\n      } catch (IllegalArgumentException iae) {\n        // orientdb throws IllegalArgumentException: Argument 'xxxx' is\n        // not a RecordId in form of string. Format must be:\n        // <cluster-id>:<cluster-position>\n        return null;\n      }\n\n    final ODocument doc = rec.getRecord();\n    if (doc != null) {\n      final OImmutableClass schemaClass = ODocumentInternal.getImmutableSchemaClass(doc);\n      if (schemaClass != null && schemaClass.isEdgeType())\n        return getEdge(doc);\n      else\n        return getVertexInstance(doc);\n    }\n\n    return null;\n  }", "language": "java", "code": "public OrientElement getElement(final Object id) {\n    makeActive();\n\n    if (null == id)\n      throw new IllegalArgumentException(\"id cannot be null\");\n\n    if (id instanceof OrientElement)\n      return (OrientElement) id;\n\n    OIdentifiable rec;\n    if (id instanceof OIdentifiable)\n      rec = (OIdentifiable) id;\n    else\n      try {\n        rec = new ORecordId(id.toString());\n      } catch (IllegalArgumentException iae) {\n        // orientdb throws IllegalArgumentException: Argument 'xxxx' is\n        // not a RecordId in form of string. Format must be:\n        // <cluster-id>:<cluster-position>\n        return null;\n      }\n\n    final ODocument doc = rec.getRecord();\n    if (doc != null) {\n      final OImmutableClass schemaClass = ODocumentInternal.getImmutableSchemaClass(doc);\n      if (schemaClass != null && schemaClass.isEdgeType())\n        return getEdge(doc);\n      else\n        return getVertexInstance(doc);\n    }\n\n    return null;\n  }", "code_tokens": ["public", "OrientElement", "getElement", "(", "final", "Object", "id", ")", "{", "makeActive", "(", ")", ";", "if", "(", "null", "==", "id", ")", "throw", "new", "IllegalArgumentException", "(", "\"id cannot be null\"", ")", ";", "if", "(", "id", "instanceof", "OrientElement", ")", "return", "(", "OrientElement", ")", "id", ";", "OIdentifiable", "rec", ";", "if", "(", "id", "instanceof", "OIdentifiable", ")", "rec", "=", "(", "OIdentifiable", ")", "id", ";", "else", "try", "{", "rec", "=", "new", "ORecordId", "(", "id", ".", "toString", "(", ")", ")", ";", "}", "catch", "(", "IllegalArgumentException", "iae", ")", "{", "// orientdb throws IllegalArgumentException: Argument 'xxxx' is", "// not a RecordId in form of string. Format must be:", "// <cluster-id>:<cluster-position>", "return", "null", ";", "}", "final", "ODocument", "doc", "=", "rec", ".", "getRecord", "(", ")", ";", "if", "(", "doc", "!=", "null", ")", "{", "final", "OImmutableClass", "schemaClass", "=", "ODocumentInternal", ".", "getImmutableSchemaClass", "(", "doc", ")", ";", "if", "(", "schemaClass", "!=", "null", "&&", "schemaClass", ".", "isEdgeType", "(", ")", ")", "return", "getEdge", "(", "doc", ")", ";", "else", "return", "getVertexInstance", "(", "doc", ")", ";", "}", "return", "null", ";", "}"], "docstring": "Returns a graph element, vertex or edge, starting from an ID.\n\n@param id Can by a String, ODocument or an OIdentifiable object.\n\n@return OrientElement subclass such as OrientVertex or OrientEdge", "docstring_tokens": ["Returns", "a", "graph", "element", "vertex", "or", "edge", "starting", "from", "an", "ID", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1589-L1621", "partition": "test", "index": 3126, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.dropVertexType", "original_string": "public void dropVertexType(final String iTypeName) {\n    makeActive();\n\n    if (getDatabase().countClass(iTypeName) > 0)\n      throw new OCommandExecutionException(\"cannot drop vertex type '\" + iTypeName\n          + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to remove data\");\n\n    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {\n      @Override\n      public OClass call(final OrientBaseGraph g) {\n        ODatabaseDocument rawGraph = getRawGraph();\n        rawGraph.getMetadata().getSchema().dropClass(iTypeName);\n        return null;\n      }\n    }, \"drop vertex type '\", iTypeName, \"'\");\n  }", "language": "java", "code": "public void dropVertexType(final String iTypeName) {\n    makeActive();\n\n    if (getDatabase().countClass(iTypeName) > 0)\n      throw new OCommandExecutionException(\"cannot drop vertex type '\" + iTypeName\n          + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to remove data\");\n\n    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {\n      @Override\n      public OClass call(final OrientBaseGraph g) {\n        ODatabaseDocument rawGraph = getRawGraph();\n        rawGraph.getMetadata().getSchema().dropClass(iTypeName);\n        return null;\n      }\n    }, \"drop vertex type '\", iTypeName, \"'\");\n  }", "code_tokens": ["public", "void", "dropVertexType", "(", "final", "String", "iTypeName", ")", "{", "makeActive", "(", ")", ";", "if", "(", "getDatabase", "(", ")", ".", "countClass", "(", "iTypeName", ")", ">", "0", ")", "throw", "new", "OCommandExecutionException", "(", "\"cannot drop vertex type '\"", "+", "iTypeName", "+", "\"' because it contains Vertices. Use 'DELETE VERTEX' command first to remove data\"", ")", ";", "executeOutsideTx", "(", "new", "OCallable", "<", "OClass", ",", "OrientBaseGraph", ">", "(", ")", "{", "@", "Override", "public", "OClass", "call", "(", "final", "OrientBaseGraph", "g", ")", "{", "ODatabaseDocument", "rawGraph", "=", "getRawGraph", "(", ")", ";", "rawGraph", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "dropClass", "(", "iTypeName", ")", ";", "return", "null", ";", "}", "}", ",", "\"drop vertex type '\"", ",", "iTypeName", ",", "\"'\"", ")", ";", "}"], "docstring": "Drop a vertex class.\n\n@param iTypeName Vertex class name", "docstring_tokens": ["Drop", "a", "vertex", "class", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1392-L1407", "partition": "test", "index": 3123, "time": "2014-01-15 20:37:44"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/index/sbtreebonsai/local/OSBTreeBonsaiLocal.java", "func_name": "OSBTreeBonsaiLocal.clear", "original_string": "@Override\n  public void clear() throws IOException {\n    boolean rollback = false;\n    final OAtomicOperation atomicOperation = startAtomicOperation(true);\n    try {\n      final Lock lock = FILE_LOCK_MANAGER.acquireExclusiveLock(fileId);\n      try {\n        final Queue<OBonsaiBucketPointer> subTreesToDelete = new LinkedList<>();\n\n        final OCacheEntry cacheEntry = loadPageForWrite(atomicOperation, fileId, rootBucketPointer.getPageIndex(), false, true);\n        try {\n          OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<>(cacheEntry, rootBucketPointer.getPageOffset(),\n              keySerializer, valueSerializer, this);\n\n          addChildrenToQueue(subTreesToDelete, rootBucket);\n\n          rootBucket.shrink(0);\n          rootBucket = new OSBTreeBonsaiBucket<>(cacheEntry, rootBucketPointer.getPageOffset(), true, keySerializer,\n              valueSerializer, this);\n\n          rootBucket.setTreeSize(0);\n        } finally {\n          releasePageFromWrite(atomicOperation, cacheEntry);\n        }\n\n        recycleSubTrees(subTreesToDelete, atomicOperation);\n      } finally {\n        lock.unlock();\n      }\n    } catch (final Exception e) {\n      rollback = true;\n      throw e;\n    } finally {\n      endAtomicOperation(rollback);\n    }\n  }", "language": "java", "code": "@Override\n  public void clear() throws IOException {\n    boolean rollback = false;\n    final OAtomicOperation atomicOperation = startAtomicOperation(true);\n    try {\n      final Lock lock = FILE_LOCK_MANAGER.acquireExclusiveLock(fileId);\n      try {\n        final Queue<OBonsaiBucketPointer> subTreesToDelete = new LinkedList<>();\n\n        final OCacheEntry cacheEntry = loadPageForWrite(atomicOperation, fileId, rootBucketPointer.getPageIndex(), false, true);\n        try {\n          OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<>(cacheEntry, rootBucketPointer.getPageOffset(),\n              keySerializer, valueSerializer, this);\n\n          addChildrenToQueue(subTreesToDelete, rootBucket);\n\n          rootBucket.shrink(0);\n          rootBucket = new OSBTreeBonsaiBucket<>(cacheEntry, rootBucketPointer.getPageOffset(), true, keySerializer,\n              valueSerializer, this);\n\n          rootBucket.setTreeSize(0);\n        } finally {\n          releasePageFromWrite(atomicOperation, cacheEntry);\n        }\n\n        recycleSubTrees(subTreesToDelete, atomicOperation);\n      } finally {\n        lock.unlock();\n      }\n    } catch (final Exception e) {\n      rollback = true;\n      throw e;\n    } finally {\n      endAtomicOperation(rollback);\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "clear", "(", ")", "throws", "IOException", "{", "boolean", "rollback", "=", "false", ";", "final", "OAtomicOperation", "atomicOperation", "=", "startAtomicOperation", "(", "true", ")", ";", "try", "{", "final", "Lock", "lock", "=", "FILE_LOCK_MANAGER", ".", "acquireExclusiveLock", "(", "fileId", ")", ";", "try", "{", "final", "Queue", "<", "OBonsaiBucketPointer", ">", "subTreesToDelete", "=", "new", "LinkedList", "<>", "(", ")", ";", "final", "OCacheEntry", "cacheEntry", "=", "loadPageForWrite", "(", "atomicOperation", ",", "fileId", ",", "rootBucketPointer", ".", "getPageIndex", "(", ")", ",", "false", ",", "true", ")", ";", "try", "{", "OSBTreeBonsaiBucket", "<", "K", ",", "V", ">", "rootBucket", "=", "new", "OSBTreeBonsaiBucket", "<>", "(", "cacheEntry", ",", "rootBucketPointer", ".", "getPageOffset", "(", ")", ",", "keySerializer", ",", "valueSerializer", ",", "this", ")", ";", "addChildrenToQueue", "(", "subTreesToDelete", ",", "rootBucket", ")", ";", "rootBucket", ".", "shrink", "(", "0", ")", ";", "rootBucket", "=", "new", "OSBTreeBonsaiBucket", "<>", "(", "cacheEntry", ",", "rootBucketPointer", ".", "getPageOffset", "(", ")", ",", "true", ",", "keySerializer", ",", "valueSerializer", ",", "this", ")", ";", "rootBucket", ".", "setTreeSize", "(", "0", ")", ";", "}", "finally", "{", "releasePageFromWrite", "(", "atomicOperation", ",", "cacheEntry", ")", ";", "}", "recycleSubTrees", "(", "subTreesToDelete", ",", "atomicOperation", ")", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "catch", "(", "final", "Exception", "e", ")", "{", "rollback", "=", "true", ";", "throw", "e", ";", "}", "finally", "{", "endAtomicOperation", "(", "rollback", ")", ";", "}", "}"], "docstring": "Removes all entries from bonsai tree. Put all but the root page to free list for further reuse.", "docstring_tokens": ["Removes", "all", "entries", "from", "bonsai", "tree", ".", "Put", "all", "but", "the", "root", "page", "to", "free", "list", "for", "further", "reuse", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/index/sbtreebonsai/local/OSBTreeBonsaiLocal.java#L272-L307", "partition": "test", "index": 3274, "time": "2014-01-21 12:28:19"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/index/sbtreebonsai/local/OSBTreeBonsaiLocal.java", "func_name": "OSBTreeBonsaiLocal.delete", "original_string": "@Override\n  public void delete() throws IOException {\n    boolean rollback = false;\n    final OAtomicOperation atomicOperation = startAtomicOperation(false);\n    try {\n      final Lock lock = FILE_LOCK_MANAGER.acquireExclusiveLock(fileId);\n      try {\n        final Queue<OBonsaiBucketPointer> subTreesToDelete = new LinkedList<>();\n        subTreesToDelete.add(rootBucketPointer);\n        recycleSubTrees(subTreesToDelete, atomicOperation);\n      } finally {\n        lock.unlock();\n      }\n    } catch (final Exception e) {\n      rollback = true;\n      throw e;\n    } finally {\n      endAtomicOperation(rollback);\n    }\n  }", "language": "java", "code": "@Override\n  public void delete() throws IOException {\n    boolean rollback = false;\n    final OAtomicOperation atomicOperation = startAtomicOperation(false);\n    try {\n      final Lock lock = FILE_LOCK_MANAGER.acquireExclusiveLock(fileId);\n      try {\n        final Queue<OBonsaiBucketPointer> subTreesToDelete = new LinkedList<>();\n        subTreesToDelete.add(rootBucketPointer);\n        recycleSubTrees(subTreesToDelete, atomicOperation);\n      } finally {\n        lock.unlock();\n      }\n    } catch (final Exception e) {\n      rollback = true;\n      throw e;\n    } finally {\n      endAtomicOperation(rollback);\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "delete", "(", ")", "throws", "IOException", "{", "boolean", "rollback", "=", "false", ";", "final", "OAtomicOperation", "atomicOperation", "=", "startAtomicOperation", "(", "false", ")", ";", "try", "{", "final", "Lock", "lock", "=", "FILE_LOCK_MANAGER", ".", "acquireExclusiveLock", "(", "fileId", ")", ";", "try", "{", "final", "Queue", "<", "OBonsaiBucketPointer", ">", "subTreesToDelete", "=", "new", "LinkedList", "<>", "(", ")", ";", "subTreesToDelete", ".", "add", "(", "rootBucketPointer", ")", ";", "recycleSubTrees", "(", "subTreesToDelete", ",", "atomicOperation", ")", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "catch", "(", "final", "Exception", "e", ")", "{", "rollback", "=", "true", ";", "throw", "e", ";", "}", "finally", "{", "endAtomicOperation", "(", "rollback", ")", ";", "}", "}"], "docstring": "Deletes a whole tree. Puts all its pages to free list for further reusage.", "docstring_tokens": ["Deletes", "a", "whole", "tree", ".", "Puts", "all", "its", "pages", "to", "free", "list", "for", "further", "reusage", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/index/sbtreebonsai/local/OSBTreeBonsaiLocal.java#L379-L398", "partition": "test", "index": 3275, "time": "2014-01-21 12:28:19"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/ridbag/sbtree/OSBTreeCollectionManagerShared.java", "func_name": "OSBTreeCollectionManagerShared.listenForChanges", "original_string": "@Override\n  public UUID listenForChanges(ORidBag collection) {\n    UUID ownerUUID = collection.getTemporaryId();\n    if (ownerUUID != null) {\n      final OBonsaiCollectionPointer pointer = collection.getPointer();\n\n      Map<UUID, OBonsaiCollectionPointer> changedPointers = collectionPointerChanges.get();\n      if (pointer != null && pointer.isValid()) {\n        changedPointers.put(ownerUUID, pointer);\n      }\n    }\n\n    return null;\n  }", "language": "java", "code": "@Override\n  public UUID listenForChanges(ORidBag collection) {\n    UUID ownerUUID = collection.getTemporaryId();\n    if (ownerUUID != null) {\n      final OBonsaiCollectionPointer pointer = collection.getPointer();\n\n      Map<UUID, OBonsaiCollectionPointer> changedPointers = collectionPointerChanges.get();\n      if (pointer != null && pointer.isValid()) {\n        changedPointers.put(ownerUUID, pointer);\n      }\n    }\n\n    return null;\n  }", "code_tokens": ["@", "Override", "public", "UUID", "listenForChanges", "(", "ORidBag", "collection", ")", "{", "UUID", "ownerUUID", "=", "collection", ".", "getTemporaryId", "(", ")", ";", "if", "(", "ownerUUID", "!=", "null", ")", "{", "final", "OBonsaiCollectionPointer", "pointer", "=", "collection", ".", "getPointer", "(", ")", ";", "Map", "<", "UUID", ",", "OBonsaiCollectionPointer", ">", "changedPointers", "=", "collectionPointerChanges", ".", "get", "(", ")", ";", "if", "(", "pointer", "!=", "null", "&&", "pointer", ".", "isValid", "(", ")", ")", "{", "changedPointers", ".", "put", "(", "ownerUUID", ",", "pointer", ")", ";", "}", "}", "return", "null", ";", "}"], "docstring": "Change UUID to null to prevent its serialization to disk.", "docstring_tokens": ["Change", "UUID", "to", "null", "to", "prevent", "its", "serialization", "to", "disk", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/ridbag/sbtree/OSBTreeCollectionManagerShared.java#L170-L183", "partition": "test", "index": 3050, "time": "2014-01-29 23:15:36"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphFactory.java", "func_name": "OrientGraphFactory.getTx", "original_string": "public OrientGraph getTx() {\n    final OrientGraph g;\n    if (pool == null) {\n      g = (OrientGraph) getTxGraphImplFactory().getGraph(getDatabase(), user, password, settings);\n    } else {\n      // USE THE POOL\n      g = (OrientGraph) getTxGraphImplFactory().getGraph(pool, settings);\n    }\n\n    initGraph(g);\n    return g;\n  }", "language": "java", "code": "public OrientGraph getTx() {\n    final OrientGraph g;\n    if (pool == null) {\n      g = (OrientGraph) getTxGraphImplFactory().getGraph(getDatabase(), user, password, settings);\n    } else {\n      // USE THE POOL\n      g = (OrientGraph) getTxGraphImplFactory().getGraph(pool, settings);\n    }\n\n    initGraph(g);\n    return g;\n  }", "code_tokens": ["public", "OrientGraph", "getTx", "(", ")", "{", "final", "OrientGraph", "g", ";", "if", "(", "pool", "==", "null", ")", "{", "g", "=", "(", "OrientGraph", ")", "getTxGraphImplFactory", "(", ")", ".", "getGraph", "(", "getDatabase", "(", ")", ",", "user", ",", "password", ",", "settings", ")", ";", "}", "else", "{", "// USE THE POOL", "g", "=", "(", "OrientGraph", ")", "getTxGraphImplFactory", "(", ")", ".", "getGraph", "(", "pool", ",", "settings", ")", ";", "}", "initGraph", "(", "g", ")", ";", "return", "g", ";", "}"], "docstring": "Gets transactional graph with the database from pool if pool is configured. Otherwise creates a graph with new db instance. The\nGraph instance inherits the factory's configuration.\n\n@return transactional graph", "docstring_tokens": ["Gets", "transactional", "graph", "with", "the", "database", "from", "pool", "if", "pool", "is", "configured", ".", "Otherwise", "creates", "a", "graph", "with", "new", "db", "instance", ".", "The", "Graph", "instance", "inherits", "the", "factory", "s", "configuration", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphFactory.java#L218-L229", "partition": "test", "index": 3198, "time": "2014-01-31 12:14:39"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphFactory.java", "func_name": "OrientGraphFactory.getNoTx", "original_string": "public OrientGraphNoTx getNoTx() {\n    final OrientGraphNoTx g;\n\n    if (pool == null) {\n      g = (OrientGraphNoTx) getNoTxGraphImplFactory().getGraph(getDatabase(), user, password, settings);\n    } else {\n      // USE THE POOL\n      g = (OrientGraphNoTx) getNoTxGraphImplFactory().getGraph(pool, settings);\n    }\n\n    initGraph(g);\n    return g;\n  }", "language": "java", "code": "public OrientGraphNoTx getNoTx() {\n    final OrientGraphNoTx g;\n\n    if (pool == null) {\n      g = (OrientGraphNoTx) getNoTxGraphImplFactory().getGraph(getDatabase(), user, password, settings);\n    } else {\n      // USE THE POOL\n      g = (OrientGraphNoTx) getNoTxGraphImplFactory().getGraph(pool, settings);\n    }\n\n    initGraph(g);\n    return g;\n  }", "code_tokens": ["public", "OrientGraphNoTx", "getNoTx", "(", ")", "{", "final", "OrientGraphNoTx", "g", ";", "if", "(", "pool", "==", "null", ")", "{", "g", "=", "(", "OrientGraphNoTx", ")", "getNoTxGraphImplFactory", "(", ")", ".", "getGraph", "(", "getDatabase", "(", ")", ",", "user", ",", "password", ",", "settings", ")", ";", "}", "else", "{", "// USE THE POOL", "g", "=", "(", "OrientGraphNoTx", ")", "getNoTxGraphImplFactory", "(", ")", ".", "getGraph", "(", "pool", ",", "settings", ")", ";", "}", "initGraph", "(", "g", ")", ";", "return", "g", ";", "}"], "docstring": "Gets non transactional graph with the database from pool if pool is configured. Otherwise creates a graph with new db instance.\nThe Graph instance inherits the factory's configuration.\n\n@return non transactional graph", "docstring_tokens": ["Gets", "non", "transactional", "graph", "with", "the", "database", "from", "pool", "if", "pool", "is", "configured", ".", "Otherwise", "creates", "a", "graph", "with", "new", "db", "instance", ".", "The", "Graph", "instance", "inherits", "the", "factory", "s", "configuration", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphFactory.java#L237-L249", "partition": "test", "index": 3199, "time": "2014-01-31 12:14:39"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphFactory.java", "func_name": "OrientGraphFactory.setupPool", "original_string": "public OrientGraphFactory setupPool(final int iMin, final int iMax) {\n    if (pool != null) {\n      pool.close();\n    }\n\n    pool = new OPartitionedDatabasePool(url, user, password, 8, iMax).setAutoCreate(true);\n\n    properties.entrySet().forEach(p -> pool.setProperty(p.getKey(), p.getValue()));\n    return this;\n  }", "language": "java", "code": "public OrientGraphFactory setupPool(final int iMin, final int iMax) {\n    if (pool != null) {\n      pool.close();\n    }\n\n    pool = new OPartitionedDatabasePool(url, user, password, 8, iMax).setAutoCreate(true);\n\n    properties.entrySet().forEach(p -> pool.setProperty(p.getKey(), p.getValue()));\n    return this;\n  }", "code_tokens": ["public", "OrientGraphFactory", "setupPool", "(", "final", "int", "iMin", ",", "final", "int", "iMax", ")", "{", "if", "(", "pool", "!=", "null", ")", "{", "pool", ".", "close", "(", ")", ";", "}", "pool", "=", "new", "OPartitionedDatabasePool", "(", "url", ",", "user", ",", "password", ",", "8", ",", "iMax", ")", ".", "setAutoCreate", "(", "true", ")", ";", "properties", ".", "entrySet", "(", ")", ".", "forEach", "(", "p", "->", "pool", ".", "setProperty", "(", "p", ".", "getKey", "(", ")", ",", "p", ".", "getValue", "(", ")", ")", ")", ";", "return", "this", ";", "}"], "docstring": "Setting up the factory to use database pool instead of creation a new instance of database connection each time.\n\n@param iMin minimum size of pool\n@param iMax maximum size of pool\n\n@return this", "docstring_tokens": ["Setting", "up", "the", "factory", "to", "use", "database", "pool", "instead", "of", "creation", "a", "new", "instance", "of", "database", "connection", "each", "time", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphFactory.java#L334-L343", "partition": "test", "index": 3200, "time": "2014-01-31 12:14:39"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLAbstract.java", "func_name": "OCommandExecutorSQLAbstract.parseLock", "original_string": "protected String parseLock() throws OCommandSQLParsingException {\r\n    final String lockStrategy = parserNextWord(true);\r\n\r\n    if (!lockStrategy.equalsIgnoreCase(\"DEFAULT\") && !lockStrategy.equalsIgnoreCase(\"NONE\")\r\n        && !lockStrategy.equalsIgnoreCase(\"RECORD\"))\r\n      throwParsingException(\"Invalid \" + KEYWORD_LOCK + \" value set to '\" + lockStrategy\r\n          + \"' but it should be NONE (default) or RECORD. Example: \" + KEYWORD_LOCK + \" RECORD\");\r\n\r\n    return lockStrategy;\r\n  }", "language": "java", "code": "protected String parseLock() throws OCommandSQLParsingException {\r\n    final String lockStrategy = parserNextWord(true);\r\n\r\n    if (!lockStrategy.equalsIgnoreCase(\"DEFAULT\") && !lockStrategy.equalsIgnoreCase(\"NONE\")\r\n        && !lockStrategy.equalsIgnoreCase(\"RECORD\"))\r\n      throwParsingException(\"Invalid \" + KEYWORD_LOCK + \" value set to '\" + lockStrategy\r\n          + \"' but it should be NONE (default) or RECORD. Example: \" + KEYWORD_LOCK + \" RECORD\");\r\n\r\n    return lockStrategy;\r\n  }", "code_tokens": ["protected", "String", "parseLock", "(", ")", "throws", "OCommandSQLParsingException", "{", "final", "String", "lockStrategy", "=", "parserNextWord", "(", "true", ")", ";", "if", "(", "!", "lockStrategy", ".", "equalsIgnoreCase", "(", "\"DEFAULT\"", ")", "&&", "!", "lockStrategy", ".", "equalsIgnoreCase", "(", "\"NONE\"", ")", "&&", "!", "lockStrategy", ".", "equalsIgnoreCase", "(", "\"RECORD\"", ")", ")", "throwParsingException", "(", "\"Invalid \"", "+", "KEYWORD_LOCK", "+", "\" value set to '\"", "+", "lockStrategy", "+", "\"' but it should be NONE (default) or RECORD. Example: \"", "+", "KEYWORD_LOCK", "+", "\" RECORD\"", ")", ";", "return", "lockStrategy", ";", "}"], "docstring": "Parses the lock keyword if found.", "docstring_tokens": ["Parses", "the", "lock", "keyword", "if", "found", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLAbstract.java#L142-L151", "partition": "test", "index": 3010, "time": "2014-02-02 04:20:27"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java", "func_name": "OCommandExecutorSQLSelect.parseFetchplan", "original_string": "protected boolean parseFetchplan(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_FETCHPLAN)) {\r\n      return false;\r\n    }\r\n\r\n    parserSkipWhiteSpaces();\r\n    int start = parserGetCurrentPosition();\r\n\r\n    parserNextWord(true);\r\n    int end = parserGetCurrentPosition();\r\n    parserSkipWhiteSpaces();\r\n\r\n    int position = parserGetCurrentPosition();\r\n    while (!parserIsEnded()) {\r\n      final String word = OIOUtils.getStringContent(parserNextWord(true));\r\n      if (!OPatternConst.PATTERN_FETCH_PLAN.matcher(word).matches()) {\r\n        break;\r\n      }\r\n\r\n      end = parserGetCurrentPosition();\r\n      parserSkipWhiteSpaces();\r\n      position = parserGetCurrentPosition();\r\n    }\r\n\r\n    parserSetCurrentPosition(position);\r\n\r\n    if (end < 0) {\r\n      fetchPlan = OIOUtils.getStringContent(parserText.substring(start));\r\n    } else {\r\n      fetchPlan = OIOUtils.getStringContent(parserText.substring(start, end));\r\n    }\r\n\r\n    request.setFetchPlan(fetchPlan);\r\n\r\n    return true;\r\n  }", "language": "java", "code": "protected boolean parseFetchplan(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_FETCHPLAN)) {\r\n      return false;\r\n    }\r\n\r\n    parserSkipWhiteSpaces();\r\n    int start = parserGetCurrentPosition();\r\n\r\n    parserNextWord(true);\r\n    int end = parserGetCurrentPosition();\r\n    parserSkipWhiteSpaces();\r\n\r\n    int position = parserGetCurrentPosition();\r\n    while (!parserIsEnded()) {\r\n      final String word = OIOUtils.getStringContent(parserNextWord(true));\r\n      if (!OPatternConst.PATTERN_FETCH_PLAN.matcher(word).matches()) {\r\n        break;\r\n      }\r\n\r\n      end = parserGetCurrentPosition();\r\n      parserSkipWhiteSpaces();\r\n      position = parserGetCurrentPosition();\r\n    }\r\n\r\n    parserSetCurrentPosition(position);\r\n\r\n    if (end < 0) {\r\n      fetchPlan = OIOUtils.getStringContent(parserText.substring(start));\r\n    } else {\r\n      fetchPlan = OIOUtils.getStringContent(parserText.substring(start, end));\r\n    }\r\n\r\n    request.setFetchPlan(fetchPlan);\r\n\r\n    return true;\r\n  }", "code_tokens": ["protected", "boolean", "parseFetchplan", "(", "final", "String", "w", ")", "throws", "OCommandSQLParsingException", "{", "if", "(", "!", "w", ".", "equals", "(", "KEYWORD_FETCHPLAN", ")", ")", "{", "return", "false", ";", "}", "parserSkipWhiteSpaces", "(", ")", ";", "int", "start", "=", "parserGetCurrentPosition", "(", ")", ";", "parserNextWord", "(", "true", ")", ";", "int", "end", "=", "parserGetCurrentPosition", "(", ")", ";", "parserSkipWhiteSpaces", "(", ")", ";", "int", "position", "=", "parserGetCurrentPosition", "(", ")", ";", "while", "(", "!", "parserIsEnded", "(", ")", ")", "{", "final", "String", "word", "=", "OIOUtils", ".", "getStringContent", "(", "parserNextWord", "(", "true", ")", ")", ";", "if", "(", "!", "OPatternConst", ".", "PATTERN_FETCH_PLAN", ".", "matcher", "(", "word", ")", ".", "matches", "(", ")", ")", "{", "break", ";", "}", "end", "=", "parserGetCurrentPosition", "(", ")", ";", "parserSkipWhiteSpaces", "(", ")", ";", "position", "=", "parserGetCurrentPosition", "(", ")", ";", "}", "parserSetCurrentPosition", "(", "position", ")", ";", "if", "(", "end", "<", "0", ")", "{", "fetchPlan", "=", "OIOUtils", ".", "getStringContent", "(", "parserText", ".", "substring", "(", "start", ")", ")", ";", "}", "else", "{", "fetchPlan", "=", "OIOUtils", ".", "getStringContent", "(", "parserText", ".", "substring", "(", "start", ",", "end", ")", ")", ";", "}", "request", ".", "setFetchPlan", "(", "fetchPlan", ")", ";", "return", "true", ";", "}"], "docstring": "Parses the fetchplan keyword if found.", "docstring_tokens": ["Parses", "the", "fetchplan", "keyword", "if", "found", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java#L1173-L1208", "partition": "test", "index": 3313, "time": "2014-03-20 20:04:54"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolBase.java", "func_name": "ODatabasePoolBase.getAvailableConnections", "original_string": "public int getAvailableConnections(final String name, final String userName) {\r\n    setup();\r\n    return dbPool.getAvailableConnections(name, userName);\r\n  }", "language": "java", "code": "public int getAvailableConnections(final String name, final String userName) {\r\n    setup();\r\n    return dbPool.getAvailableConnections(name, userName);\r\n  }", "code_tokens": ["public", "int", "getAvailableConnections", "(", "final", "String", "name", ",", "final", "String", "userName", ")", "{", "setup", "(", ")", ";", "return", "dbPool", ".", "getAvailableConnections", "(", "name", ",", "userName", ")", ";", "}"], "docstring": "Returns amount of available connections which you can acquire for given source and user name. Source id is consist of\n\"source name\" and \"source user name\".\n\n@param name\nSource name.\n@param userName\nUser name which is used to acquire source.\n@return amount of available connections which you can acquire for given source and user name.", "docstring_tokens": ["Returns", "amount", "of", "available", "connections", "which", "you", "can", "acquire", "for", "given", "source", "and", "user", "name", ".", "Source", "id", "is", "consist", "of", "source", "name", "and", "source", "user", "name", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolBase.java#L141-L144", "partition": "test", "index": 3172, "time": "2014-03-31 17:28:06"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OClassImpl.java", "func_name": "OClassImpl.addBaseClass", "original_string": "protected OClass addBaseClass(final OClassImpl iBaseClass) {\n    checkRecursion(iBaseClass);\n\n    if (subclasses == null)\n      subclasses = new ArrayList<OClass>();\n\n    if (subclasses.contains(iBaseClass))\n      return this;\n\n    subclasses.add(iBaseClass);\n    addPolymorphicClusterIdsWithInheritance(iBaseClass);\n    return this;\n  }", "language": "java", "code": "protected OClass addBaseClass(final OClassImpl iBaseClass) {\n    checkRecursion(iBaseClass);\n\n    if (subclasses == null)\n      subclasses = new ArrayList<OClass>();\n\n    if (subclasses.contains(iBaseClass))\n      return this;\n\n    subclasses.add(iBaseClass);\n    addPolymorphicClusterIdsWithInheritance(iBaseClass);\n    return this;\n  }", "code_tokens": ["protected", "OClass", "addBaseClass", "(", "final", "OClassImpl", "iBaseClass", ")", "{", "checkRecursion", "(", "iBaseClass", ")", ";", "if", "(", "subclasses", "==", "null", ")", "subclasses", "=", "new", "ArrayList", "<", "OClass", ">", "(", ")", ";", "if", "(", "subclasses", ".", "contains", "(", "iBaseClass", ")", ")", "return", "this", ";", "subclasses", ".", "add", "(", "iBaseClass", ")", ";", "addPolymorphicClusterIdsWithInheritance", "(", "iBaseClass", ")", ";", "return", "this", ";", "}"], "docstring": "Adds a base class to the current one. It adds also the base class cluster ids to the polymorphic cluster ids array.\n\n@param iBaseClass The base class to add.", "docstring_tokens": ["Adds", "a", "base", "class", "to", "the", "current", "one", ".", "It", "adds", "also", "the", "base", "class", "cluster", "ids", "to", "the", "polymorphic", "cluster", "ids", "array", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OClassImpl.java#L1525-L1537", "partition": "test", "index": 3297, "time": "2014-04-07 18:47:19"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OClassImpl.java", "func_name": "OClassImpl.addPolymorphicClusterIds", "original_string": "protected void addPolymorphicClusterIds(final OClassImpl iBaseClass) {\n    Set<Integer> clusters = new TreeSet<Integer>();\n\n    for (int clusterId : polymorphicClusterIds) {\n      clusters.add(clusterId);\n    }\n    for (int clusterId : iBaseClass.polymorphicClusterIds) {\n      if (clusters.add(clusterId)) {\n        try {\n          addClusterIdToIndexes(clusterId);\n        } catch (RuntimeException e) {\n          OLogManager.instance().warn(this, \"Error adding clusterId '%d' to index of class '%s'\", e, clusterId, getName());\n          clusters.remove(clusterId);\n        }\n      }\n    }\n    polymorphicClusterIds = new int[clusters.size()];\n    int i = 0;\n    for (Integer cluster : clusters) {\n      polymorphicClusterIds[i] = cluster;\n      i++;\n    }\n  }", "language": "java", "code": "protected void addPolymorphicClusterIds(final OClassImpl iBaseClass) {\n    Set<Integer> clusters = new TreeSet<Integer>();\n\n    for (int clusterId : polymorphicClusterIds) {\n      clusters.add(clusterId);\n    }\n    for (int clusterId : iBaseClass.polymorphicClusterIds) {\n      if (clusters.add(clusterId)) {\n        try {\n          addClusterIdToIndexes(clusterId);\n        } catch (RuntimeException e) {\n          OLogManager.instance().warn(this, \"Error adding clusterId '%d' to index of class '%s'\", e, clusterId, getName());\n          clusters.remove(clusterId);\n        }\n      }\n    }\n    polymorphicClusterIds = new int[clusters.size()];\n    int i = 0;\n    for (Integer cluster : clusters) {\n      polymorphicClusterIds[i] = cluster;\n      i++;\n    }\n  }", "code_tokens": ["protected", "void", "addPolymorphicClusterIds", "(", "final", "OClassImpl", "iBaseClass", ")", "{", "Set", "<", "Integer", ">", "clusters", "=", "new", "TreeSet", "<", "Integer", ">", "(", ")", ";", "for", "(", "int", "clusterId", ":", "polymorphicClusterIds", ")", "{", "clusters", ".", "add", "(", "clusterId", ")", ";", "}", "for", "(", "int", "clusterId", ":", "iBaseClass", ".", "polymorphicClusterIds", ")", "{", "if", "(", "clusters", ".", "add", "(", "clusterId", ")", ")", "{", "try", "{", "addClusterIdToIndexes", "(", "clusterId", ")", ";", "}", "catch", "(", "RuntimeException", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "this", ",", "\"Error adding clusterId '%d' to index of class '%s'\"", ",", "e", ",", "clusterId", ",", "getName", "(", ")", ")", ";", "clusters", ".", "remove", "(", "clusterId", ")", ";", "}", "}", "}", "polymorphicClusterIds", "=", "new", "int", "[", "clusters", ".", "size", "(", ")", "]", ";", "int", "i", "=", "0", ";", "for", "(", "Integer", "cluster", ":", "clusters", ")", "{", "polymorphicClusterIds", "[", "i", "]", "=", "cluster", ";", "i", "++", ";", "}", "}"], "docstring": "Add different cluster id to the \"polymorphic cluster ids\" array.", "docstring_tokens": ["Add", "different", "cluster", "id", "to", "the", "polymorphic", "cluster", "ids", "array", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OClassImpl.java#L1628-L1650", "partition": "test", "index": 3298, "time": "2014-04-07 18:47:19"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java", "func_name": "OrientVertex.getConnectionClass", "original_string": "public String getConnectionClass(final Direction iDirection, final String iFieldName) {\n    if (iDirection == Direction.OUT) {\n      if (iFieldName.length() > CONNECTION_OUT_PREFIX.length())\n        return iFieldName.substring(CONNECTION_OUT_PREFIX.length());\n    } else if (iDirection == Direction.IN) {\n      if (iFieldName.length() > CONNECTION_IN_PREFIX.length())\n        return iFieldName.substring(CONNECTION_IN_PREFIX.length());\n    }\n    return OrientEdgeType.CLASS_NAME;\n  }", "language": "java", "code": "public String getConnectionClass(final Direction iDirection, final String iFieldName) {\n    if (iDirection == Direction.OUT) {\n      if (iFieldName.length() > CONNECTION_OUT_PREFIX.length())\n        return iFieldName.substring(CONNECTION_OUT_PREFIX.length());\n    } else if (iDirection == Direction.IN) {\n      if (iFieldName.length() > CONNECTION_IN_PREFIX.length())\n        return iFieldName.substring(CONNECTION_IN_PREFIX.length());\n    }\n    return OrientEdgeType.CLASS_NAME;\n  }", "code_tokens": ["public", "String", "getConnectionClass", "(", "final", "Direction", "iDirection", ",", "final", "String", "iFieldName", ")", "{", "if", "(", "iDirection", "==", "Direction", ".", "OUT", ")", "{", "if", "(", "iFieldName", ".", "length", "(", ")", ">", "CONNECTION_OUT_PREFIX", ".", "length", "(", ")", ")", "return", "iFieldName", ".", "substring", "(", "CONNECTION_OUT_PREFIX", ".", "length", "(", ")", ")", ";", "}", "else", "if", "(", "iDirection", "==", "Direction", ".", "IN", ")", "{", "if", "(", "iFieldName", ".", "length", "(", ")", ">", "CONNECTION_IN_PREFIX", ".", "length", "(", ")", ")", "return", "iFieldName", ".", "substring", "(", "CONNECTION_IN_PREFIX", ".", "length", "(", ")", ")", ";", "}", "return", "OrientEdgeType", ".", "CLASS_NAME", ";", "}"], "docstring": "Used to extract the class name from the vertex's field.\n\n@param iDirection Direction of connection\n@param iFieldName Full field name\n\n@return Class of the connection if any", "docstring_tokens": ["Used", "to", "extract", "the", "class", "name", "from", "the", "vertex", "s", "field", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex.java#L957-L966", "partition": "test", "index": 3211, "time": "2014-04-10 11:58:09"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLRetryAbstract.java", "func_name": "OCommandExecutorSQLRetryAbstract.parseRetry", "original_string": "protected void parseRetry() throws OCommandSQLParsingException {\n    retry = Integer.parseInt(parserNextWord(true));\n\n    String temp = parseOptionalWord(true);\n\n    if (temp.equals(\"WAIT\")) {\n      wait = Integer.parseInt(parserNextWord(true));\n    } else\n      parserGoBack();\n  }", "language": "java", "code": "protected void parseRetry() throws OCommandSQLParsingException {\n    retry = Integer.parseInt(parserNextWord(true));\n\n    String temp = parseOptionalWord(true);\n\n    if (temp.equals(\"WAIT\")) {\n      wait = Integer.parseInt(parserNextWord(true));\n    } else\n      parserGoBack();\n  }", "code_tokens": ["protected", "void", "parseRetry", "(", ")", "throws", "OCommandSQLParsingException", "{", "retry", "=", "Integer", ".", "parseInt", "(", "parserNextWord", "(", "true", ")", ")", ";", "String", "temp", "=", "parseOptionalWord", "(", "true", ")", ";", "if", "(", "temp", ".", "equals", "(", "\"WAIT\"", ")", ")", "{", "wait", "=", "Integer", ".", "parseInt", "(", "parserNextWord", "(", "true", ")", ")", ";", "}", "else", "parserGoBack", "(", ")", ";", "}"], "docstring": "Parses the RETRY number of times", "docstring_tokens": ["Parses", "the", "RETRY", "number", "of", "times"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLRetryAbstract.java#L36-L45", "partition": "test", "index": 3231, "time": "2014-04-13 22:13:47"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java", "func_name": "OCommandExecutorSQLSelect.optimizeSort", "original_string": "private boolean optimizeSort(OClass iSchemaClass) {\r\n    OIndexCursor cursor = getOptimizedSortCursor(iSchemaClass);\r\n    if (cursor != null) {\r\n      fetchValuesFromIndexCursor(cursor);\r\n      return true;\r\n    }\r\n    return false;\r\n  }", "language": "java", "code": "private boolean optimizeSort(OClass iSchemaClass) {\r\n    OIndexCursor cursor = getOptimizedSortCursor(iSchemaClass);\r\n    if (cursor != null) {\r\n      fetchValuesFromIndexCursor(cursor);\r\n      return true;\r\n    }\r\n    return false;\r\n  }", "code_tokens": ["private", "boolean", "optimizeSort", "(", "OClass", "iSchemaClass", ")", "{", "OIndexCursor", "cursor", "=", "getOptimizedSortCursor", "(", "iSchemaClass", ")", ";", "if", "(", "cursor", "!=", "null", ")", "{", "fetchValuesFromIndexCursor", "(", "cursor", ")", ";", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Use index to order documents by provided fields.\n\n@param iSchemaClass where search for indexes for optimization.\n\n@return true if execution was optimized", "docstring_tokens": ["Use", "index", "to", "order", "documents", "by", "provided", "fields", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java#L2320-L2327", "partition": "test", "index": 3315, "time": "2014-04-29 12:36:29"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/record/string/ORecordSerializerCSVAbstract.java", "func_name": "ORecordSerializerCSVAbstract.linkToStream", "original_string": "private static OIdentifiable linkToStream(final StringBuilder buffer, final ODocument iParentRecord, Object iLinked) {\r\n    if (iLinked == null)\r\n      // NULL REFERENCE\r\n      return null;\r\n\r\n    OIdentifiable resultRid = null;\r\n    ORID rid;\r\n\r\n    if (iLinked instanceof ORID) {\r\n      // JUST THE REFERENCE\r\n      rid = (ORID) iLinked;\r\n\r\n      assert rid.getIdentity().isValid() || (ODatabaseRecordThreadLocal.instance().get().getStorage() instanceof OStorageProxy) :\r\n          \"Impossible to serialize invalid link \" + rid.getIdentity();\r\n      resultRid = rid;\r\n    } else {\r\n      if (iLinked instanceof String)\r\n        iLinked = new ORecordId((String) iLinked);\r\n\r\n      if (!(iLinked instanceof OIdentifiable))\r\n        throw new IllegalArgumentException(\r\n            \"Invalid object received. Expected a OIdentifiable but received type=\" + iLinked.getClass().getName() + \" and value=\"\r\n                + iLinked);\r\n\r\n      // RECORD\r\n      ORecord iLinkedRecord = ((OIdentifiable) iLinked).getRecord();\r\n      rid = iLinkedRecord.getIdentity();\r\n\r\n      assert rid.getIdentity().isValid() || (ODatabaseRecordThreadLocal.instance().get().getStorage() instanceof OStorageProxy) :\r\n          \"Impossible to serialize invalid link \" + rid.getIdentity();\r\n\r\n      final ODatabaseDocument database = ODatabaseRecordThreadLocal.instance().get();\r\n      if (iParentRecord != null) {\r\n        if (!database.isRetainRecords())\r\n          // REPLACE CURRENT RECORD WITH ITS ID: THIS SAVES A LOT OF MEMORY\r\n          resultRid = iLinkedRecord.getIdentity();\r\n      }\r\n    }\r\n\r\n    if (rid.isValid())\r\n      rid.toString(buffer);\r\n\r\n    return resultRid;\r\n  }", "language": "java", "code": "private static OIdentifiable linkToStream(final StringBuilder buffer, final ODocument iParentRecord, Object iLinked) {\r\n    if (iLinked == null)\r\n      // NULL REFERENCE\r\n      return null;\r\n\r\n    OIdentifiable resultRid = null;\r\n    ORID rid;\r\n\r\n    if (iLinked instanceof ORID) {\r\n      // JUST THE REFERENCE\r\n      rid = (ORID) iLinked;\r\n\r\n      assert rid.getIdentity().isValid() || (ODatabaseRecordThreadLocal.instance().get().getStorage() instanceof OStorageProxy) :\r\n          \"Impossible to serialize invalid link \" + rid.getIdentity();\r\n      resultRid = rid;\r\n    } else {\r\n      if (iLinked instanceof String)\r\n        iLinked = new ORecordId((String) iLinked);\r\n\r\n      if (!(iLinked instanceof OIdentifiable))\r\n        throw new IllegalArgumentException(\r\n            \"Invalid object received. Expected a OIdentifiable but received type=\" + iLinked.getClass().getName() + \" and value=\"\r\n                + iLinked);\r\n\r\n      // RECORD\r\n      ORecord iLinkedRecord = ((OIdentifiable) iLinked).getRecord();\r\n      rid = iLinkedRecord.getIdentity();\r\n\r\n      assert rid.getIdentity().isValid() || (ODatabaseRecordThreadLocal.instance().get().getStorage() instanceof OStorageProxy) :\r\n          \"Impossible to serialize invalid link \" + rid.getIdentity();\r\n\r\n      final ODatabaseDocument database = ODatabaseRecordThreadLocal.instance().get();\r\n      if (iParentRecord != null) {\r\n        if (!database.isRetainRecords())\r\n          // REPLACE CURRENT RECORD WITH ITS ID: THIS SAVES A LOT OF MEMORY\r\n          resultRid = iLinkedRecord.getIdentity();\r\n      }\r\n    }\r\n\r\n    if (rid.isValid())\r\n      rid.toString(buffer);\r\n\r\n    return resultRid;\r\n  }", "code_tokens": ["private", "static", "OIdentifiable", "linkToStream", "(", "final", "StringBuilder", "buffer", ",", "final", "ODocument", "iParentRecord", ",", "Object", "iLinked", ")", "{", "if", "(", "iLinked", "==", "null", ")", "// NULL REFERENCE\r", "return", "null", ";", "OIdentifiable", "resultRid", "=", "null", ";", "ORID", "rid", ";", "if", "(", "iLinked", "instanceof", "ORID", ")", "{", "// JUST THE REFERENCE\r", "rid", "=", "(", "ORID", ")", "iLinked", ";", "assert", "rid", ".", "getIdentity", "(", ")", ".", "isValid", "(", ")", "||", "(", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ".", "getStorage", "(", ")", "instanceof", "OStorageProxy", ")", ":", "\"Impossible to serialize invalid link \"", "+", "rid", ".", "getIdentity", "(", ")", ";", "resultRid", "=", "rid", ";", "}", "else", "{", "if", "(", "iLinked", "instanceof", "String", ")", "iLinked", "=", "new", "ORecordId", "(", "(", "String", ")", "iLinked", ")", ";", "if", "(", "!", "(", "iLinked", "instanceof", "OIdentifiable", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Invalid object received. Expected a OIdentifiable but received type=\"", "+", "iLinked", ".", "getClass", "(", ")", ".", "getName", "(", ")", "+", "\" and value=\"", "+", "iLinked", ")", ";", "// RECORD\r", "ORecord", "iLinkedRecord", "=", "(", "(", "OIdentifiable", ")", "iLinked", ")", ".", "getRecord", "(", ")", ";", "rid", "=", "iLinkedRecord", ".", "getIdentity", "(", ")", ";", "assert", "rid", ".", "getIdentity", "(", ")", ".", "isValid", "(", ")", "||", "(", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ".", "getStorage", "(", ")", "instanceof", "OStorageProxy", ")", ":", "\"Impossible to serialize invalid link \"", "+", "rid", ".", "getIdentity", "(", ")", ";", "final", "ODatabaseDocument", "database", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ";", "if", "(", "iParentRecord", "!=", "null", ")", "{", "if", "(", "!", "database", ".", "isRetainRecords", "(", ")", ")", "// REPLACE CURRENT RECORD WITH ITS ID: THIS SAVES A LOT OF MEMORY\r", "resultRid", "=", "iLinkedRecord", ".", "getIdentity", "(", ")", ";", "}", "}", "if", "(", "rid", ".", "isValid", "(", ")", ")", "rid", ".", "toString", "(", "buffer", ")", ";", "return", "resultRid", ";", "}"], "docstring": "Serialize the link.\n\n@param buffer\n@param iParentRecord\n@param iLinked       Can be an instance of ORID or a Record<?>\n\n@return", "docstring_tokens": ["Serialize", "the", "link", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/record/string/ORecordSerializerCSVAbstract.java#L64-L107", "partition": "test", "index": 3299, "time": "2014-05-06 10:11:15"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/script/OCommandExecutorUtility.java", "func_name": "OCommandExecutorUtility.transformResult", "original_string": "public static Object transformResult(Object result) {\n    if (java8MethodIsArray == null || !(result instanceof Map)) {\n      return result;\n    }\n    // PATCH BY MAT ABOUT NASHORN RETURNING VALUE FOR ARRAYS.\n    try {\n      if ((Boolean) java8MethodIsArray.invoke(result)) {\n        List<?> partial = new ArrayList(((Map) result).values());\n        List<Object> finalResult = new ArrayList<Object>();\n        for (Object o : partial) {\n          finalResult.add(transformResult(o));\n        }\n        return finalResult;\n      } else {\n        Map<Object, Object> mapResult = (Map) result;\n        List<Object> keys = new ArrayList<Object>(mapResult.keySet());\n        for (Object key : keys) {\n          mapResult.put(key, transformResult(mapResult.get(key)));\n        }\n        return mapResult;\n      }\n    } catch (Exception e) {\n      OLogManager.instance().error(OCommandExecutorUtility.class, \"\", e);\n    }\n\n    return result;\n  }", "language": "java", "code": "public static Object transformResult(Object result) {\n    if (java8MethodIsArray == null || !(result instanceof Map)) {\n      return result;\n    }\n    // PATCH BY MAT ABOUT NASHORN RETURNING VALUE FOR ARRAYS.\n    try {\n      if ((Boolean) java8MethodIsArray.invoke(result)) {\n        List<?> partial = new ArrayList(((Map) result).values());\n        List<Object> finalResult = new ArrayList<Object>();\n        for (Object o : partial) {\n          finalResult.add(transformResult(o));\n        }\n        return finalResult;\n      } else {\n        Map<Object, Object> mapResult = (Map) result;\n        List<Object> keys = new ArrayList<Object>(mapResult.keySet());\n        for (Object key : keys) {\n          mapResult.put(key, transformResult(mapResult.get(key)));\n        }\n        return mapResult;\n      }\n    } catch (Exception e) {\n      OLogManager.instance().error(OCommandExecutorUtility.class, \"\", e);\n    }\n\n    return result;\n  }", "code_tokens": ["public", "static", "Object", "transformResult", "(", "Object", "result", ")", "{", "if", "(", "java8MethodIsArray", "==", "null", "||", "!", "(", "result", "instanceof", "Map", ")", ")", "{", "return", "result", ";", "}", "// PATCH BY MAT ABOUT NASHORN RETURNING VALUE FOR ARRAYS.", "try", "{", "if", "(", "(", "Boolean", ")", "java8MethodIsArray", ".", "invoke", "(", "result", ")", ")", "{", "List", "<", "?", ">", "partial", "=", "new", "ArrayList", "(", "(", "(", "Map", ")", "result", ")", ".", "values", "(", ")", ")", ";", "List", "<", "Object", ">", "finalResult", "=", "new", "ArrayList", "<", "Object", ">", "(", ")", ";", "for", "(", "Object", "o", ":", "partial", ")", "{", "finalResult", ".", "add", "(", "transformResult", "(", "o", ")", ")", ";", "}", "return", "finalResult", ";", "}", "else", "{", "Map", "<", "Object", ",", "Object", ">", "mapResult", "=", "(", "Map", ")", "result", ";", "List", "<", "Object", ">", "keys", "=", "new", "ArrayList", "<", "Object", ">", "(", "mapResult", ".", "keySet", "(", ")", ")", ";", "for", "(", "Object", "key", ":", "keys", ")", "{", "mapResult", ".", "put", "(", "key", ",", "transformResult", "(", "mapResult", ".", "get", "(", "key", ")", ")", ")", ";", "}", "return", "mapResult", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "OCommandExecutorUtility", ".", "class", ",", "\"\"", ",", "e", ")", ";", "}", "return", "result", ";", "}"], "docstring": "Manages cross compiler compatibility issues.\n\n@param result Result to transform", "docstring_tokens": ["Manages", "cross", "compiler", "compatibility", "issues", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/script/OCommandExecutorUtility.java#L53-L79", "partition": "test", "index": 3034, "time": "2014-05-06 10:11:15"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/record/string/ORecordSerializerJSON.java", "func_name": "ORecordSerializerJSON.getValueAsObjectOrMap", "original_string": "private Object getValueAsObjectOrMap(ODocument iRecord, String iFieldValue, OType iType, OType iLinkedType,\r\n      Map<String, Character> iFieldTypes, boolean iNoMap, String iOptions) {\r\n    final String[] fields = OStringParser.getWords(iFieldValue.substring(1, iFieldValue.length() - 1), \":,\", true);\r\n\r\n    if (fields == null || fields.length == 0)\r\n      if (iNoMap) {\r\n        ODocument res = new ODocument();\r\n        ODocumentInternal.addOwner(res, iRecord);\r\n        return res;\r\n      } else\r\n        return new HashMap<String, Object>();\r\n\r\n    if (iNoMap || hasTypeField(fields)) {\r\n      return getValueAsRecord(iRecord, iFieldValue, iType, iOptions, fields);\r\n    } else {\r\n      return getValueAsMap(iRecord, iFieldValue, iLinkedType, iFieldTypes, false, iOptions, fields);\r\n    }\r\n  }", "language": "java", "code": "private Object getValueAsObjectOrMap(ODocument iRecord, String iFieldValue, OType iType, OType iLinkedType,\r\n      Map<String, Character> iFieldTypes, boolean iNoMap, String iOptions) {\r\n    final String[] fields = OStringParser.getWords(iFieldValue.substring(1, iFieldValue.length() - 1), \":,\", true);\r\n\r\n    if (fields == null || fields.length == 0)\r\n      if (iNoMap) {\r\n        ODocument res = new ODocument();\r\n        ODocumentInternal.addOwner(res, iRecord);\r\n        return res;\r\n      } else\r\n        return new HashMap<String, Object>();\r\n\r\n    if (iNoMap || hasTypeField(fields)) {\r\n      return getValueAsRecord(iRecord, iFieldValue, iType, iOptions, fields);\r\n    } else {\r\n      return getValueAsMap(iRecord, iFieldValue, iLinkedType, iFieldTypes, false, iOptions, fields);\r\n    }\r\n  }", "code_tokens": ["private", "Object", "getValueAsObjectOrMap", "(", "ODocument", "iRecord", ",", "String", "iFieldValue", ",", "OType", "iType", ",", "OType", "iLinkedType", ",", "Map", "<", "String", ",", "Character", ">", "iFieldTypes", ",", "boolean", "iNoMap", ",", "String", "iOptions", ")", "{", "final", "String", "[", "]", "fields", "=", "OStringParser", ".", "getWords", "(", "iFieldValue", ".", "substring", "(", "1", ",", "iFieldValue", ".", "length", "(", ")", "-", "1", ")", ",", "\":,\"", ",", "true", ")", ";", "if", "(", "fields", "==", "null", "||", "fields", ".", "length", "==", "0", ")", "if", "(", "iNoMap", ")", "{", "ODocument", "res", "=", "new", "ODocument", "(", ")", ";", "ODocumentInternal", ".", "addOwner", "(", "res", ",", "iRecord", ")", ";", "return", "res", ";", "}", "else", "return", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "if", "(", "iNoMap", "||", "hasTypeField", "(", "fields", ")", ")", "{", "return", "getValueAsRecord", "(", "iRecord", ",", "iFieldValue", ",", "iType", ",", "iOptions", ",", "fields", ")", ";", "}", "else", "{", "return", "getValueAsMap", "(", "iRecord", ",", "iFieldValue", ",", "iLinkedType", ",", "iFieldTypes", ",", "false", ",", "iOptions", ",", "fields", ")", ";", "}", "}"], "docstring": "OBJECT OR MAP. CHECK THE TYPE ATTRIBUTE TO KNOW IT.", "docstring_tokens": ["OBJECT", "OR", "MAP", ".", "CHECK", "THE", "TYPE", "ATTRIBUTE", "TO", "KNOW", "IT", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/record/string/ORecordSerializerJSON.java#L587-L604", "partition": "test", "index": 3193, "time": "2014-05-21 17:05:29"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OFilterAnalyzer.java", "func_name": "OFilterAnalyzer.analyzeCondition", "original_string": "public List<OIndexSearchResult> analyzeCondition(OSQLFilterCondition condition, final OClass schemaClass,\n      OCommandContext context) {\n\n    final List<OIndexSearchResult> indexSearchResults = new ArrayList<OIndexSearchResult>();\n    OIndexSearchResult lastCondition = analyzeFilterBranch(schemaClass, condition, indexSearchResults, context);\n\n    if (indexSearchResults.isEmpty() && lastCondition != null) {\n      indexSearchResults.add(lastCondition);\n    }\n    Collections.sort(indexSearchResults, new Comparator<OIndexSearchResult>() {\n      public int compare(final OIndexSearchResult searchResultOne, final OIndexSearchResult searchResultTwo) {\n        return searchResultTwo.getFieldCount() - searchResultOne.getFieldCount();\n      }\n    });\n\n    return indexSearchResults;\n  }", "language": "java", "code": "public List<OIndexSearchResult> analyzeCondition(OSQLFilterCondition condition, final OClass schemaClass,\n      OCommandContext context) {\n\n    final List<OIndexSearchResult> indexSearchResults = new ArrayList<OIndexSearchResult>();\n    OIndexSearchResult lastCondition = analyzeFilterBranch(schemaClass, condition, indexSearchResults, context);\n\n    if (indexSearchResults.isEmpty() && lastCondition != null) {\n      indexSearchResults.add(lastCondition);\n    }\n    Collections.sort(indexSearchResults, new Comparator<OIndexSearchResult>() {\n      public int compare(final OIndexSearchResult searchResultOne, final OIndexSearchResult searchResultTwo) {\n        return searchResultTwo.getFieldCount() - searchResultOne.getFieldCount();\n      }\n    });\n\n    return indexSearchResults;\n  }", "code_tokens": ["public", "List", "<", "OIndexSearchResult", ">", "analyzeCondition", "(", "OSQLFilterCondition", "condition", ",", "final", "OClass", "schemaClass", ",", "OCommandContext", "context", ")", "{", "final", "List", "<", "OIndexSearchResult", ">", "indexSearchResults", "=", "new", "ArrayList", "<", "OIndexSearchResult", ">", "(", ")", ";", "OIndexSearchResult", "lastCondition", "=", "analyzeFilterBranch", "(", "schemaClass", ",", "condition", ",", "indexSearchResults", ",", "context", ")", ";", "if", "(", "indexSearchResults", ".", "isEmpty", "(", ")", "&&", "lastCondition", "!=", "null", ")", "{", "indexSearchResults", ".", "add", "(", "lastCondition", ")", ";", "}", "Collections", ".", "sort", "(", "indexSearchResults", ",", "new", "Comparator", "<", "OIndexSearchResult", ">", "(", ")", "{", "public", "int", "compare", "(", "final", "OIndexSearchResult", "searchResultOne", ",", "final", "OIndexSearchResult", "searchResultTwo", ")", "{", "return", "searchResultTwo", ".", "getFieldCount", "(", ")", "-", "searchResultOne", ".", "getFieldCount", "(", ")", ";", "}", "}", ")", ";", "return", "indexSearchResults", ";", "}"], "docstring": "Analyzes a query filter for a possible indexation options. The results are sorted by amount of fields. So the most specific\nitems go first.\n\n@param condition   to analyze\n@param schemaClass the class that is scanned by query\n@param context     of the query\n\n@return list of OIndexSearchResult items", "docstring_tokens": ["Analyzes", "a", "query", "filter", "for", "a", "possible", "indexation", "options", ".", "The", "results", "are", "sorted", "by", "amount", "of", "fields", ".", "So", "the", "most", "specific", "items", "go", "first", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OFilterAnalyzer.java#L97-L113", "partition": "test", "index": 3291, "time": "2014-06-16 22:45:17"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OFilterAnalyzer.java", "func_name": "OFilterAnalyzer.createIndexedProperty", "original_string": "private OIndexSearchResult createIndexedProperty(final OSQLFilterCondition iCondition, final Object iItem, OCommandContext ctx) {\n    if (iItem == null || !(iItem instanceof OSQLFilterItemField)) {\n      return null;\n    }\n\n    if (iCondition.getLeft() instanceof OSQLFilterItemField && iCondition.getRight() instanceof OSQLFilterItemField) {\n      return null;\n    }\n\n    final OSQLFilterItemField item = (OSQLFilterItemField) iItem;\n\n    if (item.hasChainOperators() && !item.isFieldChain()) {\n      return null;\n    }\n\n    boolean inverted = iCondition.getRight() == iItem;\n    final Object origValue = inverted ? iCondition.getLeft() : iCondition.getRight();\n\n    OQueryOperator operator = iCondition.getOperator();\n\n    if (inverted) {\n      if (operator instanceof OQueryOperatorIn) {\n        operator = new OQueryOperatorContains();\n      } else if (operator instanceof OQueryOperatorContains) {\n        operator = new OQueryOperatorIn();\n      } else if (operator instanceof OQueryOperatorMajor) {\n        operator = new OQueryOperatorMinor();\n      } else if (operator instanceof OQueryOperatorMinor) {\n        operator = new OQueryOperatorMajor();\n      } else if (operator instanceof OQueryOperatorMajorEquals) {\n        operator = new OQueryOperatorMinorEquals();\n      } else if (operator instanceof OQueryOperatorMinorEquals) {\n        operator = new OQueryOperatorMajorEquals();\n      }\n    }\n\n    if (iCondition.getOperator() instanceof OQueryOperatorBetween || operator instanceof OQueryOperatorIn) {\n\n      return new OIndexSearchResult(operator, item.getFieldChain(), origValue);\n    }\n\n    final Object value = OSQLHelper.getValue(origValue, null, ctx);\n    return new OIndexSearchResult(operator, item.getFieldChain(), value);\n  }", "language": "java", "code": "private OIndexSearchResult createIndexedProperty(final OSQLFilterCondition iCondition, final Object iItem, OCommandContext ctx) {\n    if (iItem == null || !(iItem instanceof OSQLFilterItemField)) {\n      return null;\n    }\n\n    if (iCondition.getLeft() instanceof OSQLFilterItemField && iCondition.getRight() instanceof OSQLFilterItemField) {\n      return null;\n    }\n\n    final OSQLFilterItemField item = (OSQLFilterItemField) iItem;\n\n    if (item.hasChainOperators() && !item.isFieldChain()) {\n      return null;\n    }\n\n    boolean inverted = iCondition.getRight() == iItem;\n    final Object origValue = inverted ? iCondition.getLeft() : iCondition.getRight();\n\n    OQueryOperator operator = iCondition.getOperator();\n\n    if (inverted) {\n      if (operator instanceof OQueryOperatorIn) {\n        operator = new OQueryOperatorContains();\n      } else if (operator instanceof OQueryOperatorContains) {\n        operator = new OQueryOperatorIn();\n      } else if (operator instanceof OQueryOperatorMajor) {\n        operator = new OQueryOperatorMinor();\n      } else if (operator instanceof OQueryOperatorMinor) {\n        operator = new OQueryOperatorMajor();\n      } else if (operator instanceof OQueryOperatorMajorEquals) {\n        operator = new OQueryOperatorMinorEquals();\n      } else if (operator instanceof OQueryOperatorMinorEquals) {\n        operator = new OQueryOperatorMajorEquals();\n      }\n    }\n\n    if (iCondition.getOperator() instanceof OQueryOperatorBetween || operator instanceof OQueryOperatorIn) {\n\n      return new OIndexSearchResult(operator, item.getFieldChain(), origValue);\n    }\n\n    final Object value = OSQLHelper.getValue(origValue, null, ctx);\n    return new OIndexSearchResult(operator, item.getFieldChain(), value);\n  }", "code_tokens": ["private", "OIndexSearchResult", "createIndexedProperty", "(", "final", "OSQLFilterCondition", "iCondition", ",", "final", "Object", "iItem", ",", "OCommandContext", "ctx", ")", "{", "if", "(", "iItem", "==", "null", "||", "!", "(", "iItem", "instanceof", "OSQLFilterItemField", ")", ")", "{", "return", "null", ";", "}", "if", "(", "iCondition", ".", "getLeft", "(", ")", "instanceof", "OSQLFilterItemField", "&&", "iCondition", ".", "getRight", "(", ")", "instanceof", "OSQLFilterItemField", ")", "{", "return", "null", ";", "}", "final", "OSQLFilterItemField", "item", "=", "(", "OSQLFilterItemField", ")", "iItem", ";", "if", "(", "item", ".", "hasChainOperators", "(", ")", "&&", "!", "item", ".", "isFieldChain", "(", ")", ")", "{", "return", "null", ";", "}", "boolean", "inverted", "=", "iCondition", ".", "getRight", "(", ")", "==", "iItem", ";", "final", "Object", "origValue", "=", "inverted", "?", "iCondition", ".", "getLeft", "(", ")", ":", "iCondition", ".", "getRight", "(", ")", ";", "OQueryOperator", "operator", "=", "iCondition", ".", "getOperator", "(", ")", ";", "if", "(", "inverted", ")", "{", "if", "(", "operator", "instanceof", "OQueryOperatorIn", ")", "{", "operator", "=", "new", "OQueryOperatorContains", "(", ")", ";", "}", "else", "if", "(", "operator", "instanceof", "OQueryOperatorContains", ")", "{", "operator", "=", "new", "OQueryOperatorIn", "(", ")", ";", "}", "else", "if", "(", "operator", "instanceof", "OQueryOperatorMajor", ")", "{", "operator", "=", "new", "OQueryOperatorMinor", "(", ")", ";", "}", "else", "if", "(", "operator", "instanceof", "OQueryOperatorMinor", ")", "{", "operator", "=", "new", "OQueryOperatorMajor", "(", ")", ";", "}", "else", "if", "(", "operator", "instanceof", "OQueryOperatorMajorEquals", ")", "{", "operator", "=", "new", "OQueryOperatorMinorEquals", "(", ")", ";", "}", "else", "if", "(", "operator", "instanceof", "OQueryOperatorMinorEquals", ")", "{", "operator", "=", "new", "OQueryOperatorMajorEquals", "(", ")", ";", "}", "}", "if", "(", "iCondition", ".", "getOperator", "(", ")", "instanceof", "OQueryOperatorBetween", "||", "operator", "instanceof", "OQueryOperatorIn", ")", "{", "return", "new", "OIndexSearchResult", "(", "operator", ",", "item", ".", "getFieldChain", "(", ")", ",", "origValue", ")", ";", "}", "final", "Object", "value", "=", "OSQLHelper", ".", "getValue", "(", "origValue", ",", "null", ",", "ctx", ")", ";", "return", "new", "OIndexSearchResult", "(", "operator", ",", "item", ".", "getFieldChain", "(", ")", ",", "value", ")", ";", "}"], "docstring": "Add SQL filter field to the search candidate list.\n\n@param iCondition Condition item\n@param iItem      Value to search\n\n@return true if the property was indexed and found, otherwise false", "docstring_tokens": ["Add", "SQL", "filter", "field", "to", "the", "search", "candidate", "list", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OFilterAnalyzer.java#L207-L250", "partition": "test", "index": 3292, "time": "2014-06-16 22:45:17"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/cache/OLocalRecordCache.java", "func_name": "OLocalRecordCache.updateRecord", "original_string": "public void updateRecord(final ORecord record) {\n    if (record.getIdentity().getClusterId() != excludedCluster && record.getIdentity().isValid() && !record.isDirty()\n        && !ORecordVersionHelper.isTombstone(record.getVersion())) {\n      if (underlying.get(record.getIdentity()) != record)\n        underlying.put(record);\n    }\n  }", "language": "java", "code": "public void updateRecord(final ORecord record) {\n    if (record.getIdentity().getClusterId() != excludedCluster && record.getIdentity().isValid() && !record.isDirty()\n        && !ORecordVersionHelper.isTombstone(record.getVersion())) {\n      if (underlying.get(record.getIdentity()) != record)\n        underlying.put(record);\n    }\n  }", "code_tokens": ["public", "void", "updateRecord", "(", "final", "ORecord", "record", ")", "{", "if", "(", "record", ".", "getIdentity", "(", ")", ".", "getClusterId", "(", ")", "!=", "excludedCluster", "&&", "record", ".", "getIdentity", "(", ")", ".", "isValid", "(", ")", "&&", "!", "record", ".", "isDirty", "(", ")", "&&", "!", "ORecordVersionHelper", ".", "isTombstone", "(", "record", ".", "getVersion", "(", ")", ")", ")", "{", "if", "(", "underlying", ".", "get", "(", "record", ".", "getIdentity", "(", ")", ")", "!=", "record", ")", "underlying", ".", "put", "(", "record", ")", ";", "}", "}"], "docstring": "Pushes record to cache. Identifier of record used as access key\n\n@param record\nrecord that should be cached", "docstring_tokens": ["Pushes", "record", "to", "cache", ".", "Identifier", "of", "record", "used", "as", "access", "key"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/cache/OLocalRecordCache.java#L63-L69", "partition": "test", "index": 2917, "time": "2014-06-17 17:55:46"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/cache/OLocalRecordCache.java", "func_name": "OLocalRecordCache.findRecord", "original_string": "public ORecord findRecord(final ORID rid) {\n    ORecord record;\n    record = underlying.get(rid);\n\n    if (record != null)\n      Orient.instance().getProfiler().updateCounter(CACHE_HIT, \"Record found in Level1 Cache\", 1L, \"db.*.cache.level1.cache.found\");\n    else\n      Orient.instance().getProfiler().updateCounter(CACHE_MISS, \"Record not found in Level1 Cache\", 1L,\n          \"db.*.cache.level1.cache.notFound\");\n\n    return record;\n  }", "language": "java", "code": "public ORecord findRecord(final ORID rid) {\n    ORecord record;\n    record = underlying.get(rid);\n\n    if (record != null)\n      Orient.instance().getProfiler().updateCounter(CACHE_HIT, \"Record found in Level1 Cache\", 1L, \"db.*.cache.level1.cache.found\");\n    else\n      Orient.instance().getProfiler().updateCounter(CACHE_MISS, \"Record not found in Level1 Cache\", 1L,\n          \"db.*.cache.level1.cache.notFound\");\n\n    return record;\n  }", "code_tokens": ["public", "ORecord", "findRecord", "(", "final", "ORID", "rid", ")", "{", "ORecord", "record", ";", "record", "=", "underlying", ".", "get", "(", "rid", ")", ";", "if", "(", "record", "!=", "null", ")", "Orient", ".", "instance", "(", ")", ".", "getProfiler", "(", ")", ".", "updateCounter", "(", "CACHE_HIT", ",", "\"Record found in Level1 Cache\"", ",", "1L", ",", "\"db.*.cache.level1.cache.found\"", ")", ";", "else", "Orient", ".", "instance", "(", ")", ".", "getProfiler", "(", ")", ".", "updateCounter", "(", "CACHE_MISS", ",", "\"Record not found in Level1 Cache\"", ",", "1L", ",", "\"db.*.cache.level1.cache.notFound\"", ")", ";", "return", "record", ";", "}"], "docstring": "Looks up for record in cache by it's identifier. Optionally look up in secondary cache and update primary with found record\n\n@param rid\nunique identifier of record\n@return record stored in cache if any, otherwise - {@code null}", "docstring_tokens": ["Looks", "up", "for", "record", "in", "cache", "by", "it", "s", "identifier", ".", "Optionally", "look", "up", "in", "secondary", "cache", "and", "update", "primary", "with", "found", "record"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/cache/OLocalRecordCache.java#L78-L89", "partition": "test", "index": 2918, "time": "2014-06-17 17:55:46"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/record/ridbag/ORidBag.java", "func_name": "ORidBag.tryMerge", "original_string": "public boolean tryMerge(final ORidBag otherValue, boolean iMergeSingleItemsOfMultiValueFields) {\n    if (!isEmbedded() && !otherValue.isEmbedded()) {\n      final OSBTreeRidBag thisTree = (OSBTreeRidBag) delegate;\n      final OSBTreeRidBag otherTree = (OSBTreeRidBag) otherValue.delegate;\n      if (thisTree.getCollectionPointer().equals(otherTree.getCollectionPointer())) {\n\n        thisTree.mergeChanges(otherTree);\n\n        uuid = otherValue.uuid;\n\n        return true;\n      }\n    } else if (iMergeSingleItemsOfMultiValueFields) {\n      final Iterator<OIdentifiable> iter = otherValue.rawIterator();\n      while (iter.hasNext()) {\n        final OIdentifiable value = iter.next();\n        if (value != null) {\n          final Iterator<OIdentifiable> localIter = rawIterator();\n          boolean found = false;\n          while (localIter.hasNext()) {\n            final OIdentifiable v = localIter.next();\n            if (value.equals(v)) {\n              found = true;\n              break;\n            }\n          }\n          if (!found)\n            add(value);\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "language": "java", "code": "public boolean tryMerge(final ORidBag otherValue, boolean iMergeSingleItemsOfMultiValueFields) {\n    if (!isEmbedded() && !otherValue.isEmbedded()) {\n      final OSBTreeRidBag thisTree = (OSBTreeRidBag) delegate;\n      final OSBTreeRidBag otherTree = (OSBTreeRidBag) otherValue.delegate;\n      if (thisTree.getCollectionPointer().equals(otherTree.getCollectionPointer())) {\n\n        thisTree.mergeChanges(otherTree);\n\n        uuid = otherValue.uuid;\n\n        return true;\n      }\n    } else if (iMergeSingleItemsOfMultiValueFields) {\n      final Iterator<OIdentifiable> iter = otherValue.rawIterator();\n      while (iter.hasNext()) {\n        final OIdentifiable value = iter.next();\n        if (value != null) {\n          final Iterator<OIdentifiable> localIter = rawIterator();\n          boolean found = false;\n          while (localIter.hasNext()) {\n            final OIdentifiable v = localIter.next();\n            if (value.equals(v)) {\n              found = true;\n              break;\n            }\n          }\n          if (!found)\n            add(value);\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "code_tokens": ["public", "boolean", "tryMerge", "(", "final", "ORidBag", "otherValue", ",", "boolean", "iMergeSingleItemsOfMultiValueFields", ")", "{", "if", "(", "!", "isEmbedded", "(", ")", "&&", "!", "otherValue", ".", "isEmbedded", "(", ")", ")", "{", "final", "OSBTreeRidBag", "thisTree", "=", "(", "OSBTreeRidBag", ")", "delegate", ";", "final", "OSBTreeRidBag", "otherTree", "=", "(", "OSBTreeRidBag", ")", "otherValue", ".", "delegate", ";", "if", "(", "thisTree", ".", "getCollectionPointer", "(", ")", ".", "equals", "(", "otherTree", ".", "getCollectionPointer", "(", ")", ")", ")", "{", "thisTree", ".", "mergeChanges", "(", "otherTree", ")", ";", "uuid", "=", "otherValue", ".", "uuid", ";", "return", "true", ";", "}", "}", "else", "if", "(", "iMergeSingleItemsOfMultiValueFields", ")", "{", "final", "Iterator", "<", "OIdentifiable", ">", "iter", "=", "otherValue", ".", "rawIterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "final", "OIdentifiable", "value", "=", "iter", ".", "next", "(", ")", ";", "if", "(", "value", "!=", "null", ")", "{", "final", "Iterator", "<", "OIdentifiable", ">", "localIter", "=", "rawIterator", "(", ")", ";", "boolean", "found", "=", "false", ";", "while", "(", "localIter", ".", "hasNext", "(", ")", ")", "{", "final", "OIdentifiable", "v", "=", "localIter", ".", "next", "(", ")", ";", "if", "(", "value", ".", "equals", "(", "v", ")", ")", "{", "found", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "found", ")", "add", "(", "value", ")", ";", "}", "}", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "IMPORTANT! Only for internal usage.", "docstring_tokens": ["IMPORTANT!", "Only", "for", "internal", "usage", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/record/ridbag/ORidBag.java#L424-L457", "partition": "test", "index": 3032, "time": "2014-06-27 11:29:31"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/record/ridbag/ORidBag.java", "func_name": "ORidBag.replaceWithSBTree", "original_string": "private void replaceWithSBTree(OBonsaiCollectionPointer pointer) {\n    delegate.requestDelete();\n    final OSBTreeRidBag treeBag = new OSBTreeRidBag();\n    treeBag.setCollectionPointer(pointer);\n    treeBag.setOwner(delegate.getOwner());\n    for (OMultiValueChangeListener<OIdentifiable, OIdentifiable> listener : delegate.getChangeListeners())\n      treeBag.addChangeListener(listener);\n    delegate = treeBag;\n  }", "language": "java", "code": "private void replaceWithSBTree(OBonsaiCollectionPointer pointer) {\n    delegate.requestDelete();\n    final OSBTreeRidBag treeBag = new OSBTreeRidBag();\n    treeBag.setCollectionPointer(pointer);\n    treeBag.setOwner(delegate.getOwner());\n    for (OMultiValueChangeListener<OIdentifiable, OIdentifiable> listener : delegate.getChangeListeners())\n      treeBag.addChangeListener(listener);\n    delegate = treeBag;\n  }", "code_tokens": ["private", "void", "replaceWithSBTree", "(", "OBonsaiCollectionPointer", "pointer", ")", "{", "delegate", ".", "requestDelete", "(", ")", ";", "final", "OSBTreeRidBag", "treeBag", "=", "new", "OSBTreeRidBag", "(", ")", ";", "treeBag", ".", "setCollectionPointer", "(", "pointer", ")", ";", "treeBag", ".", "setOwner", "(", "delegate", ".", "getOwner", "(", ")", ")", ";", "for", "(", "OMultiValueChangeListener", "<", "OIdentifiable", ",", "OIdentifiable", ">", "listener", ":", "delegate", ".", "getChangeListeners", "(", ")", ")", "treeBag", ".", "addChangeListener", "(", "listener", ")", ";", "delegate", "=", "treeBag", ";", "}"], "docstring": "Silently replace delegate by tree implementation.\n\n@param pointer new collection pointer", "docstring_tokens": ["Silently", "replace", "delegate", "by", "tree", "implementation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/record/ridbag/ORidBag.java#L471-L479", "partition": "test", "index": 3033, "time": "2014-08-21 14:20:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/index/OIndexes.java", "func_name": "OIndexes.getIndexEngines", "original_string": "public static Set<String> getIndexEngines() {\n    final Set<String> engines = new HashSet<>();\n    final Iterator<OIndexFactory> ite = getAllFactories();\n    while (ite.hasNext()) {\n      engines.addAll(ite.next().getAlgorithms());\n    }\n    return engines;\n  }", "language": "java", "code": "public static Set<String> getIndexEngines() {\n    final Set<String> engines = new HashSet<>();\n    final Iterator<OIndexFactory> ite = getAllFactories();\n    while (ite.hasNext()) {\n      engines.addAll(ite.next().getAlgorithms());\n    }\n    return engines;\n  }", "code_tokens": ["public", "static", "Set", "<", "String", ">", "getIndexEngines", "(", ")", "{", "final", "Set", "<", "String", ">", "engines", "=", "new", "HashSet", "<>", "(", ")", ";", "final", "Iterator", "<", "OIndexFactory", ">", "ite", "=", "getAllFactories", "(", ")", ";", "while", "(", "ite", ".", "hasNext", "(", ")", ")", "{", "engines", ".", "addAll", "(", "ite", ".", "next", "(", ")", ".", "getAlgorithms", "(", ")", ")", ";", "}", "return", "engines", ";", "}"], "docstring": "Iterates on all factories and append all index engines.\n\n@return Set of all index engines.", "docstring_tokens": ["Iterates", "on", "all", "factories", "and", "append", "all", "index", "engines", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/index/OIndexes.java#L113-L120", "partition": "test", "index": 3145, "time": "2014-09-04 13:07:14"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java", "func_name": "OAbstractPaginatedStorage.registerCluster", "original_string": "private int registerCluster(final OCluster cluster) {\n    final int id;\n\n    if (cluster != null) {\n      // CHECK FOR DUPLICATION OF NAMES\n      if (clusterMap.containsKey(cluster.getName().toLowerCase(configuration.getLocaleInstance()))) {\n        throw new OConfigurationException(\n            \"Cannot add cluster '\" + cluster.getName() + \"' because it is already registered in database '\" + name + \"'\");\n      }\n      // CREATE AND ADD THE NEW REF SEGMENT\n      clusterMap.put(cluster.getName().toLowerCase(configuration.getLocaleInstance()), cluster);\n      id = cluster.getId();\n    } else {\n      id = clusters.size();\n    }\n\n    setCluster(id, cluster);\n\n    return id;\n  }", "language": "java", "code": "private int registerCluster(final OCluster cluster) {\n    final int id;\n\n    if (cluster != null) {\n      // CHECK FOR DUPLICATION OF NAMES\n      if (clusterMap.containsKey(cluster.getName().toLowerCase(configuration.getLocaleInstance()))) {\n        throw new OConfigurationException(\n            \"Cannot add cluster '\" + cluster.getName() + \"' because it is already registered in database '\" + name + \"'\");\n      }\n      // CREATE AND ADD THE NEW REF SEGMENT\n      clusterMap.put(cluster.getName().toLowerCase(configuration.getLocaleInstance()), cluster);\n      id = cluster.getId();\n    } else {\n      id = clusters.size();\n    }\n\n    setCluster(id, cluster);\n\n    return id;\n  }", "code_tokens": ["private", "int", "registerCluster", "(", "final", "OCluster", "cluster", ")", "{", "final", "int", "id", ";", "if", "(", "cluster", "!=", "null", ")", "{", "// CHECK FOR DUPLICATION OF NAMES", "if", "(", "clusterMap", ".", "containsKey", "(", "cluster", ".", "getName", "(", ")", ".", "toLowerCase", "(", "configuration", ".", "getLocaleInstance", "(", ")", ")", ")", ")", "{", "throw", "new", "OConfigurationException", "(", "\"Cannot add cluster '\"", "+", "cluster", ".", "getName", "(", ")", "+", "\"' because it is already registered in database '\"", "+", "name", "+", "\"'\"", ")", ";", "}", "// CREATE AND ADD THE NEW REF SEGMENT", "clusterMap", ".", "put", "(", "cluster", ".", "getName", "(", ")", ".", "toLowerCase", "(", "configuration", ".", "getLocaleInstance", "(", ")", ")", ",", "cluster", ")", ";", "id", "=", "cluster", ".", "getId", "(", ")", ";", "}", "else", "{", "id", "=", "clusters", ".", "size", "(", ")", ";", "}", "setCluster", "(", "id", ",", "cluster", ")", ";", "return", "id", ";", "}"], "docstring": "Register the cluster internally.\n\n@param cluster OCluster implementation\n\n@return The id (physical position into the array) of the new cluster just created. First is 0.", "docstring_tokens": ["Register", "the", "cluster", "internally", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java#L4914-L4933", "partition": "test", "index": 3322, "time": "2014-09-08 19:51:07"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/record/ORecordInternal.java", "func_name": "ORecordInternal.fill", "original_string": "public static ORecordAbstract fill(final ORecord record, final ORID iRid, final int iVersion, final byte[] iBuffer,\n      final boolean iDirty) {\n    final ORecordAbstract rec = (ORecordAbstract) record;\n    rec.fill(iRid, iVersion, iBuffer, iDirty);\n    return rec;\n  }", "language": "java", "code": "public static ORecordAbstract fill(final ORecord record, final ORID iRid, final int iVersion, final byte[] iBuffer,\n      final boolean iDirty) {\n    final ORecordAbstract rec = (ORecordAbstract) record;\n    rec.fill(iRid, iVersion, iBuffer, iDirty);\n    return rec;\n  }", "code_tokens": ["public", "static", "ORecordAbstract", "fill", "(", "final", "ORecord", "record", ",", "final", "ORID", "iRid", ",", "final", "int", "iVersion", ",", "final", "byte", "[", "]", "iBuffer", ",", "final", "boolean", "iDirty", ")", "{", "final", "ORecordAbstract", "rec", "=", "(", "ORecordAbstract", ")", "record", ";", "rec", ".", "fill", "(", "iRid", ",", "iVersion", ",", "iBuffer", ",", "iDirty", ")", ";", "return", "rec", ";", "}"], "docstring": "Internal only. Fills in one shot the record.", "docstring_tokens": ["Internal", "only", ".", "Fills", "in", "one", "shot", "the", "record", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/record/ORecordInternal.java#L35-L40", "partition": "test", "index": 3282, "time": "2014-09-20 16:58:04"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/record/ORecordInternal.java", "func_name": "ORecordInternal.setVersion", "original_string": "public static void setVersion(final ORecord record, final int iVersion) {\n    final ORecordAbstract rec = (ORecordAbstract) record;\n    rec.setVersion(iVersion);\n  }", "language": "java", "code": "public static void setVersion(final ORecord record, final int iVersion) {\n    final ORecordAbstract rec = (ORecordAbstract) record;\n    rec.setVersion(iVersion);\n  }", "code_tokens": ["public", "static", "void", "setVersion", "(", "final", "ORecord", "record", ",", "final", "int", "iVersion", ")", "{", "final", "ORecordAbstract", "rec", "=", "(", "ORecordAbstract", ")", "record", ";", "rec", ".", "setVersion", "(", "iVersion", ")", ";", "}"], "docstring": "Internal only. Sets the version.", "docstring_tokens": ["Internal", "only", ".", "Sets", "the", "version", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/record/ORecordInternal.java#L78-L81", "partition": "test", "index": 3283, "time": "2014-09-20 16:58:04"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/record/ORecordInternal.java", "func_name": "ORecordInternal.getRecordType", "original_string": "public static byte getRecordType(final ORecord record) {\n    if (record instanceof ORecordAbstract) {\n      return ((ORecordAbstract) record).getRecordType();\n    }\n    final ORecordAbstract rec = (ORecordAbstract) record.getRecord();\n    return rec.getRecordType();\n  }", "language": "java", "code": "public static byte getRecordType(final ORecord record) {\n    if (record instanceof ORecordAbstract) {\n      return ((ORecordAbstract) record).getRecordType();\n    }\n    final ORecordAbstract rec = (ORecordAbstract) record.getRecord();\n    return rec.getRecordType();\n  }", "code_tokens": ["public", "static", "byte", "getRecordType", "(", "final", "ORecord", "record", ")", "{", "if", "(", "record", "instanceof", "ORecordAbstract", ")", "{", "return", "(", "(", "ORecordAbstract", ")", "record", ")", ".", "getRecordType", "(", ")", ";", "}", "final", "ORecordAbstract", "rec", "=", "(", "ORecordAbstract", ")", "record", ".", "getRecord", "(", ")", ";", "return", "rec", ".", "getRecordType", "(", ")", ";", "}"], "docstring": "Internal only. Return the record type.", "docstring_tokens": ["Internal", "only", ".", "Return", "the", "record", "type", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/record/ORecordInternal.java#L86-L92", "partition": "test", "index": 3284, "time": "2014-09-20 16:58:04"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/console/OConsoleApplication.java", "func_name": "OConsoleApplication.getConsoleMethods", "original_string": "protected Map<Method, Object> getConsoleMethods() {\n    if (methods != null)\n      return methods;\n\n    // search for declared command collections\n    final Iterator<OConsoleCommandCollection> ite = ServiceLoader.load(OConsoleCommandCollection.class).iterator();\n    final Collection<Object> candidates = new ArrayList<Object>();\n    candidates.add(this);\n    while (ite.hasNext()) {\n      try {\n        // make a copy and set it's context\n        final OConsoleCommandCollection cc = ite.next().getClass().newInstance();\n        cc.setContext(this);\n        candidates.add(cc);\n      } catch (InstantiationException ex) {\n        Logger.getLogger(OConsoleApplication.class.getName()).log(Level.WARNING, ex.getMessage());\n      } catch (IllegalAccessException ex) {\n        Logger.getLogger(OConsoleApplication.class.getName()).log(Level.WARNING, ex.getMessage());\n      }\n    }\n\n    methods = new TreeMap<Method, Object>(new Comparator<Method>() {\n      public int compare(Method o1, Method o2) {\n        final ConsoleCommand ann1 = o1.getAnnotation(ConsoleCommand.class);\n        final ConsoleCommand ann2 = o2.getAnnotation(ConsoleCommand.class);\n\n        if (ann1 != null && ann2 != null) {\n          if (ann1.priority() != ann2.priority())\n            // PRIORITY WINS\n            return ann1.priority() - ann2.priority();\n        }\n\n        int res = o1.getName().compareTo(o2.getName());\n        if (res == 0)\n          res = o1.toString().compareTo(o2.toString());\n        return res;\n      }\n    });\n\n    for (final Object candidate : candidates) {\n      final Method[] classMethods = candidate.getClass().getMethods();\n\n      for (Method m : classMethods) {\n        if (Modifier.isAbstract(m.getModifiers()) || Modifier.isStatic(m.getModifiers()) || !Modifier.isPublic(m.getModifiers())) {\n          continue;\n        }\n        if (m.getReturnType() != Void.TYPE) {\n          continue;\n        }\n        methods.put(m, candidate);\n      }\n    }\n    return methods;\n  }", "language": "java", "code": "protected Map<Method, Object> getConsoleMethods() {\n    if (methods != null)\n      return methods;\n\n    // search for declared command collections\n    final Iterator<OConsoleCommandCollection> ite = ServiceLoader.load(OConsoleCommandCollection.class).iterator();\n    final Collection<Object> candidates = new ArrayList<Object>();\n    candidates.add(this);\n    while (ite.hasNext()) {\n      try {\n        // make a copy and set it's context\n        final OConsoleCommandCollection cc = ite.next().getClass().newInstance();\n        cc.setContext(this);\n        candidates.add(cc);\n      } catch (InstantiationException ex) {\n        Logger.getLogger(OConsoleApplication.class.getName()).log(Level.WARNING, ex.getMessage());\n      } catch (IllegalAccessException ex) {\n        Logger.getLogger(OConsoleApplication.class.getName()).log(Level.WARNING, ex.getMessage());\n      }\n    }\n\n    methods = new TreeMap<Method, Object>(new Comparator<Method>() {\n      public int compare(Method o1, Method o2) {\n        final ConsoleCommand ann1 = o1.getAnnotation(ConsoleCommand.class);\n        final ConsoleCommand ann2 = o2.getAnnotation(ConsoleCommand.class);\n\n        if (ann1 != null && ann2 != null) {\n          if (ann1.priority() != ann2.priority())\n            // PRIORITY WINS\n            return ann1.priority() - ann2.priority();\n        }\n\n        int res = o1.getName().compareTo(o2.getName());\n        if (res == 0)\n          res = o1.toString().compareTo(o2.toString());\n        return res;\n      }\n    });\n\n    for (final Object candidate : candidates) {\n      final Method[] classMethods = candidate.getClass().getMethods();\n\n      for (Method m : classMethods) {\n        if (Modifier.isAbstract(m.getModifiers()) || Modifier.isStatic(m.getModifiers()) || !Modifier.isPublic(m.getModifiers())) {\n          continue;\n        }\n        if (m.getReturnType() != Void.TYPE) {\n          continue;\n        }\n        methods.put(m, candidate);\n      }\n    }\n    return methods;\n  }", "code_tokens": ["protected", "Map", "<", "Method", ",", "Object", ">", "getConsoleMethods", "(", ")", "{", "if", "(", "methods", "!=", "null", ")", "return", "methods", ";", "// search for declared command collections", "final", "Iterator", "<", "OConsoleCommandCollection", ">", "ite", "=", "ServiceLoader", ".", "load", "(", "OConsoleCommandCollection", ".", "class", ")", ".", "iterator", "(", ")", ";", "final", "Collection", "<", "Object", ">", "candidates", "=", "new", "ArrayList", "<", "Object", ">", "(", ")", ";", "candidates", ".", "add", "(", "this", ")", ";", "while", "(", "ite", ".", "hasNext", "(", ")", ")", "{", "try", "{", "// make a copy and set it's context", "final", "OConsoleCommandCollection", "cc", "=", "ite", ".", "next", "(", ")", ".", "getClass", "(", ")", ".", "newInstance", "(", ")", ";", "cc", ".", "setContext", "(", "this", ")", ";", "candidates", ".", "add", "(", "cc", ")", ";", "}", "catch", "(", "InstantiationException", "ex", ")", "{", "Logger", ".", "getLogger", "(", "OConsoleApplication", ".", "class", ".", "getName", "(", ")", ")", ".", "log", "(", "Level", ".", "WARNING", ",", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "catch", "(", "IllegalAccessException", "ex", ")", "{", "Logger", ".", "getLogger", "(", "OConsoleApplication", ".", "class", ".", "getName", "(", ")", ")", ".", "log", "(", "Level", ".", "WARNING", ",", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "}", "methods", "=", "new", "TreeMap", "<", "Method", ",", "Object", ">", "(", "new", "Comparator", "<", "Method", ">", "(", ")", "{", "public", "int", "compare", "(", "Method", "o1", ",", "Method", "o2", ")", "{", "final", "ConsoleCommand", "ann1", "=", "o1", ".", "getAnnotation", "(", "ConsoleCommand", ".", "class", ")", ";", "final", "ConsoleCommand", "ann2", "=", "o2", ".", "getAnnotation", "(", "ConsoleCommand", ".", "class", ")", ";", "if", "(", "ann1", "!=", "null", "&&", "ann2", "!=", "null", ")", "{", "if", "(", "ann1", ".", "priority", "(", ")", "!=", "ann2", ".", "priority", "(", ")", ")", "// PRIORITY WINS", "return", "ann1", ".", "priority", "(", ")", "-", "ann2", ".", "priority", "(", ")", ";", "}", "int", "res", "=", "o1", ".", "getName", "(", ")", ".", "compareTo", "(", "o2", ".", "getName", "(", ")", ")", ";", "if", "(", "res", "==", "0", ")", "res", "=", "o1", ".", "toString", "(", ")", ".", "compareTo", "(", "o2", ".", "toString", "(", ")", ")", ";", "return", "res", ";", "}", "}", ")", ";", "for", "(", "final", "Object", "candidate", ":", "candidates", ")", "{", "final", "Method", "[", "]", "classMethods", "=", "candidate", ".", "getClass", "(", ")", ".", "getMethods", "(", ")", ";", "for", "(", "Method", "m", ":", "classMethods", ")", "{", "if", "(", "Modifier", ".", "isAbstract", "(", "m", ".", "getModifiers", "(", ")", ")", "||", "Modifier", ".", "isStatic", "(", "m", ".", "getModifiers", "(", ")", ")", "||", "!", "Modifier", ".", "isPublic", "(", "m", ".", "getModifiers", "(", ")", ")", ")", "{", "continue", ";", "}", "if", "(", "m", ".", "getReturnType", "(", ")", "!=", "Void", ".", "TYPE", ")", "{", "continue", ";", "}", "methods", ".", "put", "(", "m", ",", "candidate", ")", ";", "}", "}", "return", "methods", ";", "}"], "docstring": "Returns a map of all console method and the object they can be called on.\n\n@return Map&lt;Method,Object&gt;", "docstring_tokens": ["Returns", "a", "map", "of", "all", "console", "method", "and", "the", "object", "they", "can", "be", "called", "on", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/console/OConsoleApplication.java#L619-L672", "partition": "test", "index": 3214, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/profiler/OAbstractProfiler.java", "func_name": "OAbstractProfiler.updateMetadata", "original_string": "protected void updateMetadata(final String iName, final String iDescription, final METRIC_TYPE iType) {\n    if (iDescription != null && dictionary.putIfAbsent(iName, iDescription) == null)\n      types.put(iName, iType);\n  }", "language": "java", "code": "protected void updateMetadata(final String iName, final String iDescription, final METRIC_TYPE iType) {\n    if (iDescription != null && dictionary.putIfAbsent(iName, iDescription) == null)\n      types.put(iName, iType);\n  }", "code_tokens": ["protected", "void", "updateMetadata", "(", "final", "String", "iName", ",", "final", "String", "iDescription", ",", "final", "METRIC_TYPE", "iType", ")", "{", "if", "(", "iDescription", "!=", "null", "&&", "dictionary", ".", "putIfAbsent", "(", "iName", ",", "iDescription", ")", "==", "null", ")", "types", ".", "put", "(", "iName", ",", "iType", ")", ";", "}"], "docstring": "Updates the metric metadata.", "docstring_tokens": ["Updates", "the", "metric", "metadata", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/profiler/OAbstractProfiler.java#L517-L520", "partition": "test", "index": 2973, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/util/OByteBufferUtils.java", "func_name": "OByteBufferUtils.mergeShortFromBuffers", "original_string": "public static short mergeShortFromBuffers(final ByteBuffer buffer, final ByteBuffer buffer1) {\n    short result = 0;\n    result = (short) (result | (buffer.get() & MASK));\n    result = (short) (result << SIZE_OF_BYTE_IN_BITS);\n    result = (short) (result | (buffer1.get() & MASK));\n    return result;\n  }", "language": "java", "code": "public static short mergeShortFromBuffers(final ByteBuffer buffer, final ByteBuffer buffer1) {\n    short result = 0;\n    result = (short) (result | (buffer.get() & MASK));\n    result = (short) (result << SIZE_OF_BYTE_IN_BITS);\n    result = (short) (result | (buffer1.get() & MASK));\n    return result;\n  }", "code_tokens": ["public", "static", "short", "mergeShortFromBuffers", "(", "final", "ByteBuffer", "buffer", ",", "final", "ByteBuffer", "buffer1", ")", "{", "short", "result", "=", "0", ";", "result", "=", "(", "short", ")", "(", "result", "|", "(", "buffer", ".", "get", "(", ")", "&", "MASK", ")", ")", ";", "result", "=", "(", "short", ")", "(", "result", "<<", "SIZE_OF_BYTE_IN_BITS", ")", ";", "result", "=", "(", "short", ")", "(", "result", "|", "(", "buffer1", ".", "get", "(", ")", "&", "MASK", ")", ")", ";", "return", "result", ";", "}"], "docstring": "Merge short value from two byte buffer. First byte of short will be extracted from first byte buffer and second from second\none.\n\n@param buffer\nto read first part of value\n@param buffer1\nto read second part of value\n@return merged value", "docstring_tokens": ["Merge", "short", "value", "from", "two", "byte", "buffer", ".", "First", "byte", "of", "short", "will", "be", "extracted", "from", "first", "byte", "buffer", "and", "second", "from", "second", "one", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/util/OByteBufferUtils.java#L49-L55", "partition": "test", "index": 2950, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java", "func_name": "OBaseParser.parserCheckSeparator", "original_string": "private boolean parserCheckSeparator(final char c, final String iSeparatorChars) {\n    for (int sepIndex = 0; sepIndex < iSeparatorChars.length(); ++sepIndex) {\n      if (iSeparatorChars.charAt(sepIndex) == c) {\n        parserLastSeparator = c;\n        return true;\n      }\n    }\n    return false;\n  }", "language": "java", "code": "private boolean parserCheckSeparator(final char c, final String iSeparatorChars) {\n    for (int sepIndex = 0; sepIndex < iSeparatorChars.length(); ++sepIndex) {\n      if (iSeparatorChars.charAt(sepIndex) == c) {\n        parserLastSeparator = c;\n        return true;\n      }\n    }\n    return false;\n  }", "code_tokens": ["private", "boolean", "parserCheckSeparator", "(", "final", "char", "c", ",", "final", "String", "iSeparatorChars", ")", "{", "for", "(", "int", "sepIndex", "=", "0", ";", "sepIndex", "<", "iSeparatorChars", ".", "length", "(", ")", ";", "++", "sepIndex", ")", "{", "if", "(", "iSeparatorChars", ".", "charAt", "(", "sepIndex", ")", "==", "c", ")", "{", "parserLastSeparator", "=", "c", ";", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "Check for a separator\n\n@param c\n@param iSeparatorChars\n@return", "docstring_tokens": ["Check", "for", "a", "separator"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java#L648-L656", "partition": "test", "index": 3338, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/util/OByteBufferUtils.java", "func_name": "OByteBufferUtils.splitShortToBuffers", "original_string": "public static void splitShortToBuffers(final ByteBuffer buffer, final ByteBuffer buffer1, final short iValue) {\n    buffer.put((byte) (MASK & (iValue >>> SIZE_OF_BYTE_IN_BITS)));\n    buffer1.put((byte) (MASK & iValue));\n  }", "language": "java", "code": "public static void splitShortToBuffers(final ByteBuffer buffer, final ByteBuffer buffer1, final short iValue) {\n    buffer.put((byte) (MASK & (iValue >>> SIZE_OF_BYTE_IN_BITS)));\n    buffer1.put((byte) (MASK & iValue));\n  }", "code_tokens": ["public", "static", "void", "splitShortToBuffers", "(", "final", "ByteBuffer", "buffer", ",", "final", "ByteBuffer", "buffer1", ",", "final", "short", "iValue", ")", "{", "buffer", ".", "put", "(", "(", "byte", ")", "(", "MASK", "&", "(", "iValue", ">>>", "SIZE_OF_BYTE_IN_BITS", ")", ")", ")", ";", "buffer1", ".", "put", "(", "(", "byte", ")", "(", "MASK", "&", "iValue", ")", ")", ";", "}"], "docstring": "Split short value into two byte buffer. First byte of short will be written to first byte buffer and second to second one.\n\n@param buffer\nto write first part of value\n@param buffer1\nto write second part of value", "docstring_tokens": ["Split", "short", "value", "into", "two", "byte", "buffer", ".", "First", "byte", "of", "short", "will", "be", "written", "to", "first", "byte", "buffer", "and", "second", "to", "second", "one", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/util/OByteBufferUtils.java#L115-L118", "partition": "test", "index": 2951, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/parser/OStringParser.java", "func_name": "OStringParser.jumpWhiteSpaces", "original_string": "public static int jumpWhiteSpaces(final CharSequence iText, final int iCurrentPosition, final int iMaxPosition) {\n    return jump(iText, iCurrentPosition, iMaxPosition, COMMON_JUMP);\n  }", "language": "java", "code": "public static int jumpWhiteSpaces(final CharSequence iText, final int iCurrentPosition, final int iMaxPosition) {\n    return jump(iText, iCurrentPosition, iMaxPosition, COMMON_JUMP);\n  }", "code_tokens": ["public", "static", "int", "jumpWhiteSpaces", "(", "final", "CharSequence", "iText", ",", "final", "int", "iCurrentPosition", ",", "final", "int", "iMaxPosition", ")", "{", "return", "jump", "(", "iText", ",", "iCurrentPosition", ",", "iMaxPosition", ",", "COMMON_JUMP", ")", ";", "}"], "docstring": "Jump white spaces.\n\n@param iText\nString to analyze\n@param iCurrentPosition\nCurrent position in text\n@param iMaxPosition\nTODO\n@return The new offset inside the string analyzed", "docstring_tokens": ["Jump", "white", "spaces", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/parser/OStringParser.java#L308-L310", "partition": "test", "index": 3160, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java", "func_name": "OBaseParser.parserNextChars", "original_string": "protected int parserNextChars(final boolean iUpperCase, final boolean iMandatory, final String... iCandidateWords) {\n    parserPreviousPos = parserCurrentPos;\n    parserSkipWhiteSpaces();\n\n    parserEscapeSequenceCount = 0;\n    parserLastWord.setLength(0);\n\n    final String[] processedWords = Arrays.copyOf(iCandidateWords, iCandidateWords.length);\n\n    // PARSE THE CHARS\n    final String text2Use = iUpperCase ? parserTextUpperCase : parserText;\n    final int max = text2Use.length();\n\n    parserCurrentPos = parserCurrentPos + parserTextUpperCase.length() - parserText.length();\n    // PARSE TILL 1 CHAR AFTER THE END TO SIMULATE A SEPARATOR AS EOF\n    for (int i = 0; parserCurrentPos <= max; ++i) {\n      final char ch = parserCurrentPos < max ? text2Use.charAt(parserCurrentPos) : '\\n';\n      final boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(';\n      if (!separator)\n        parserLastWord.append(ch);\n\n      // CLEAR CANDIDATES\n      int candidatesWordsCount = 0;\n      int candidatesWordsPos = -1;\n      for (int c = 0; c < processedWords.length; ++c) {\n        final String w = processedWords[c];\n        if (w != null) {\n          final int wordSize = w.length();\n          if ((separator && wordSize > i) || (!separator && (i > wordSize - 1 || w.charAt(i) != ch)))\n            // DISCARD IT\n            processedWords[c] = null;\n          else {\n            candidatesWordsCount++;\n            if (candidatesWordsCount == 1)\n              // REMEMBER THE POSITION\n              candidatesWordsPos = c;\n          }\n        }\n      }\n\n      if (candidatesWordsCount == 1) {\n        // ONE RESULT, CHECKING IF FOUND\n        final String w = processedWords[candidatesWordsPos];\n        if (w.length() == i + (separator ? 0 : 1) && !Character.isLetter(ch))\n          // FOUND!\n          return candidatesWordsPos;\n      }\n\n      if (candidatesWordsCount == 0 || separator)\n        break;\n\n      parserCurrentPos++;\n    }\n\n    if (iMandatory)\n      throwSyntaxErrorException(\"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\"\n          + Arrays.toString(iCandidateWords) + \"'\");\n\n    return -1;\n  }", "language": "java", "code": "protected int parserNextChars(final boolean iUpperCase, final boolean iMandatory, final String... iCandidateWords) {\n    parserPreviousPos = parserCurrentPos;\n    parserSkipWhiteSpaces();\n\n    parserEscapeSequenceCount = 0;\n    parserLastWord.setLength(0);\n\n    final String[] processedWords = Arrays.copyOf(iCandidateWords, iCandidateWords.length);\n\n    // PARSE THE CHARS\n    final String text2Use = iUpperCase ? parserTextUpperCase : parserText;\n    final int max = text2Use.length();\n\n    parserCurrentPos = parserCurrentPos + parserTextUpperCase.length() - parserText.length();\n    // PARSE TILL 1 CHAR AFTER THE END TO SIMULATE A SEPARATOR AS EOF\n    for (int i = 0; parserCurrentPos <= max; ++i) {\n      final char ch = parserCurrentPos < max ? text2Use.charAt(parserCurrentPos) : '\\n';\n      final boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(';\n      if (!separator)\n        parserLastWord.append(ch);\n\n      // CLEAR CANDIDATES\n      int candidatesWordsCount = 0;\n      int candidatesWordsPos = -1;\n      for (int c = 0; c < processedWords.length; ++c) {\n        final String w = processedWords[c];\n        if (w != null) {\n          final int wordSize = w.length();\n          if ((separator && wordSize > i) || (!separator && (i > wordSize - 1 || w.charAt(i) != ch)))\n            // DISCARD IT\n            processedWords[c] = null;\n          else {\n            candidatesWordsCount++;\n            if (candidatesWordsCount == 1)\n              // REMEMBER THE POSITION\n              candidatesWordsPos = c;\n          }\n        }\n      }\n\n      if (candidatesWordsCount == 1) {\n        // ONE RESULT, CHECKING IF FOUND\n        final String w = processedWords[candidatesWordsPos];\n        if (w.length() == i + (separator ? 0 : 1) && !Character.isLetter(ch))\n          // FOUND!\n          return candidatesWordsPos;\n      }\n\n      if (candidatesWordsCount == 0 || separator)\n        break;\n\n      parserCurrentPos++;\n    }\n\n    if (iMandatory)\n      throwSyntaxErrorException(\"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\"\n          + Arrays.toString(iCandidateWords) + \"'\");\n\n    return -1;\n  }", "code_tokens": ["protected", "int", "parserNextChars", "(", "final", "boolean", "iUpperCase", ",", "final", "boolean", "iMandatory", ",", "final", "String", "...", "iCandidateWords", ")", "{", "parserPreviousPos", "=", "parserCurrentPos", ";", "parserSkipWhiteSpaces", "(", ")", ";", "parserEscapeSequenceCount", "=", "0", ";", "parserLastWord", ".", "setLength", "(", "0", ")", ";", "final", "String", "[", "]", "processedWords", "=", "Arrays", ".", "copyOf", "(", "iCandidateWords", ",", "iCandidateWords", ".", "length", ")", ";", "// PARSE THE CHARS", "final", "String", "text2Use", "=", "iUpperCase", "?", "parserTextUpperCase", ":", "parserText", ";", "final", "int", "max", "=", "text2Use", ".", "length", "(", ")", ";", "parserCurrentPos", "=", "parserCurrentPos", "+", "parserTextUpperCase", ".", "length", "(", ")", "-", "parserText", ".", "length", "(", ")", ";", "// PARSE TILL 1 CHAR AFTER THE END TO SIMULATE A SEPARATOR AS EOF", "for", "(", "int", "i", "=", "0", ";", "parserCurrentPos", "<=", "max", ";", "++", "i", ")", "{", "final", "char", "ch", "=", "parserCurrentPos", "<", "max", "?", "text2Use", ".", "charAt", "(", "parserCurrentPos", ")", ":", "'", "'", ";", "final", "boolean", "separator", "=", "ch", "==", "'", "'", "||", "ch", "==", "'", "'", "||", "ch", "==", "'", "'", "||", "ch", "==", "'", "'", "||", "ch", "==", "'", "'", ";", "if", "(", "!", "separator", ")", "parserLastWord", ".", "append", "(", "ch", ")", ";", "// CLEAR CANDIDATES", "int", "candidatesWordsCount", "=", "0", ";", "int", "candidatesWordsPos", "=", "-", "1", ";", "for", "(", "int", "c", "=", "0", ";", "c", "<", "processedWords", ".", "length", ";", "++", "c", ")", "{", "final", "String", "w", "=", "processedWords", "[", "c", "]", ";", "if", "(", "w", "!=", "null", ")", "{", "final", "int", "wordSize", "=", "w", ".", "length", "(", ")", ";", "if", "(", "(", "separator", "&&", "wordSize", ">", "i", ")", "||", "(", "!", "separator", "&&", "(", "i", ">", "wordSize", "-", "1", "||", "w", ".", "charAt", "(", "i", ")", "!=", "ch", ")", ")", ")", "// DISCARD IT", "processedWords", "[", "c", "]", "=", "null", ";", "else", "{", "candidatesWordsCount", "++", ";", "if", "(", "candidatesWordsCount", "==", "1", ")", "// REMEMBER THE POSITION", "candidatesWordsPos", "=", "c", ";", "}", "}", "}", "if", "(", "candidatesWordsCount", "==", "1", ")", "{", "// ONE RESULT, CHECKING IF FOUND", "final", "String", "w", "=", "processedWords", "[", "candidatesWordsPos", "]", ";", "if", "(", "w", ".", "length", "(", ")", "==", "i", "+", "(", "separator", "?", "0", ":", "1", ")", "&&", "!", "Character", ".", "isLetter", "(", "ch", ")", ")", "// FOUND!", "return", "candidatesWordsPos", ";", "}", "if", "(", "candidatesWordsCount", "==", "0", "||", "separator", ")", "break", ";", "parserCurrentPos", "++", ";", "}", "if", "(", "iMandatory", ")", "throwSyntaxErrorException", "(", "\"Found unexpected keyword '\"", "+", "parserLastWord", "+", "\"' while it was expected '\"", "+", "Arrays", ".", "toString", "(", "iCandidateWords", ")", "+", "\"'\"", ")", ";", "return", "-", "1", ";", "}"], "docstring": "Parses the next sequence of chars.\n\n@return The position of the word matched if any, otherwise -1 or an exception if iMandatory is true", "docstring_tokens": ["Parses", "the", "next", "sequence", "of", "chars", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java#L339-L398", "partition": "test", "index": 3336, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java", "func_name": "OBaseParser.parserOptionalWord", "original_string": "protected String parserOptionalWord(final boolean iUpperCase) {\n    parserPreviousPos = parserCurrentPos;\n\n    parserNextWord(iUpperCase);\n    if (parserLastWord.length() == 0)\n      return null;\n    return parserLastWord.toString();\n  }", "language": "java", "code": "protected String parserOptionalWord(final boolean iUpperCase) {\n    parserPreviousPos = parserCurrentPos;\n\n    parserNextWord(iUpperCase);\n    if (parserLastWord.length() == 0)\n      return null;\n    return parserLastWord.toString();\n  }", "code_tokens": ["protected", "String", "parserOptionalWord", "(", "final", "boolean", "iUpperCase", ")", "{", "parserPreviousPos", "=", "parserCurrentPos", ";", "parserNextWord", "(", "iUpperCase", ")", ";", "if", "(", "parserLastWord", ".", "length", "(", ")", "==", "0", ")", "return", "null", ";", "return", "parserLastWord", ".", "toString", "(", ")", ";", "}"], "docstring": "Parses the next word. It returns the word parsed if any.\n\n@param iUpperCase\nTrue if must return UPPERCASE, otherwise false\n@return The word parsed if any, otherwise null", "docstring_tokens": ["Parses", "the", "next", "word", ".", "It", "returns", "the", "word", "parsed", "if", "any", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java#L205-L212", "partition": "test", "index": 3334, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/parser/OStringParser.java", "func_name": "OStringParser.indexOfOutsideStrings", "original_string": "public static int indexOfOutsideStrings(final String iText, final char iToFind, int iFrom, int iTo) {\n    if (iTo == -1)\n      iTo = iText.length() - 1;\n    if (iFrom == -1)\n      iFrom = iText.length() - 1;\n\n    char c;\n    char stringChar = ' ';\n    boolean escape = false;\n\n    final StringBuilder buffer = new StringBuilder(1024);\n\n    int i = iFrom;\n    while (true) {\n      c = iText.charAt(i);\n\n      if (!escape && c == '\\\\' && ((i + 1) < iText.length())) {\n        if (iText.charAt(i + 1) == 'u') {\n          i = readUnicode(iText, i + 2, buffer);\n        } else\n          escape = true;\n      } else {\n        if (c == '\\'' || c == '\"') {\n          // BEGIN/END STRING\n          if (stringChar == ' ') {\n            // BEGIN\n            stringChar = c;\n          } else {\n            // END\n            if (!escape && c == stringChar)\n              stringChar = ' ';\n          }\n        }\n\n        if (c == iToFind && stringChar == ' ')\n          return i;\n\n        if (escape)\n          escape = false;\n      }\n\n      if (iFrom < iTo) {\n        // MOVE FORWARD\n        if (++i > iTo)\n          break;\n      } else {\n        // MOVE BACKWARD\n        if (--i < iFrom)\n          break;\n      }\n    }\n    return -1;\n  }", "language": "java", "code": "public static int indexOfOutsideStrings(final String iText, final char iToFind, int iFrom, int iTo) {\n    if (iTo == -1)\n      iTo = iText.length() - 1;\n    if (iFrom == -1)\n      iFrom = iText.length() - 1;\n\n    char c;\n    char stringChar = ' ';\n    boolean escape = false;\n\n    final StringBuilder buffer = new StringBuilder(1024);\n\n    int i = iFrom;\n    while (true) {\n      c = iText.charAt(i);\n\n      if (!escape && c == '\\\\' && ((i + 1) < iText.length())) {\n        if (iText.charAt(i + 1) == 'u') {\n          i = readUnicode(iText, i + 2, buffer);\n        } else\n          escape = true;\n      } else {\n        if (c == '\\'' || c == '\"') {\n          // BEGIN/END STRING\n          if (stringChar == ' ') {\n            // BEGIN\n            stringChar = c;\n          } else {\n            // END\n            if (!escape && c == stringChar)\n              stringChar = ' ';\n          }\n        }\n\n        if (c == iToFind && stringChar == ' ')\n          return i;\n\n        if (escape)\n          escape = false;\n      }\n\n      if (iFrom < iTo) {\n        // MOVE FORWARD\n        if (++i > iTo)\n          break;\n      } else {\n        // MOVE BACKWARD\n        if (--i < iFrom)\n          break;\n      }\n    }\n    return -1;\n  }", "code_tokens": ["public", "static", "int", "indexOfOutsideStrings", "(", "final", "String", "iText", ",", "final", "char", "iToFind", ",", "int", "iFrom", ",", "int", "iTo", ")", "{", "if", "(", "iTo", "==", "-", "1", ")", "iTo", "=", "iText", ".", "length", "(", ")", "-", "1", ";", "if", "(", "iFrom", "==", "-", "1", ")", "iFrom", "=", "iText", ".", "length", "(", ")", "-", "1", ";", "char", "c", ";", "char", "stringChar", "=", "'", "'", ";", "boolean", "escape", "=", "false", ";", "final", "StringBuilder", "buffer", "=", "new", "StringBuilder", "(", "1024", ")", ";", "int", "i", "=", "iFrom", ";", "while", "(", "true", ")", "{", "c", "=", "iText", ".", "charAt", "(", "i", ")", ";", "if", "(", "!", "escape", "&&", "c", "==", "'", "'", "&&", "(", "(", "i", "+", "1", ")", "<", "iText", ".", "length", "(", ")", ")", ")", "{", "if", "(", "iText", ".", "charAt", "(", "i", "+", "1", ")", "==", "'", "'", ")", "{", "i", "=", "readUnicode", "(", "iText", ",", "i", "+", "2", ",", "buffer", ")", ";", "}", "else", "escape", "=", "true", ";", "}", "else", "{", "if", "(", "c", "==", "'", "'", "||", "c", "==", "'", "'", ")", "{", "// BEGIN/END STRING", "if", "(", "stringChar", "==", "'", "'", ")", "{", "// BEGIN", "stringChar", "=", "c", ";", "}", "else", "{", "// END", "if", "(", "!", "escape", "&&", "c", "==", "stringChar", ")", "stringChar", "=", "'", "'", ";", "}", "}", "if", "(", "c", "==", "iToFind", "&&", "stringChar", "==", "'", "'", ")", "return", "i", ";", "if", "(", "escape", ")", "escape", "=", "false", ";", "}", "if", "(", "iFrom", "<", "iTo", ")", "{", "// MOVE FORWARD", "if", "(", "++", "i", ">", "iTo", ")", "break", ";", "}", "else", "{", "// MOVE BACKWARD", "if", "(", "--", "i", "<", "iFrom", ")", "break", ";", "}", "}", "return", "-", "1", ";", "}"], "docstring": "Finds a character inside a string specyfing the limits and direction. If iFrom is minor than iTo, then it moves forward,\notherwise backward.", "docstring_tokens": ["Finds", "a", "character", "inside", "a", "string", "specyfing", "the", "limits", "and", "direction", ".", "If", "iFrom", "is", "minor", "than", "iTo", "then", "it", "moves", "forward", "otherwise", "backward", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/parser/OStringParser.java#L243-L295", "partition": "test", "index": 3159, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/common/reflection/OReflectionHelper.java", "func_name": "OReflectionHelper.findClasses", "original_string": "private static List<Class<?>> findClasses(final File iDirectory, String iPackageName, ClassLoader iClassLoader)\n      throws ClassNotFoundException {\n    final List<Class<?>> classes = new ArrayList<Class<?>>();\n    if (!iDirectory.exists())\n      return classes;\n\n    iPackageName += \".\" + iDirectory.getName();\n\n    String className;\n    final File[] files = iDirectory.listFiles();\n    if (files != null)\n      for (File file : files) {\n        if (file.isDirectory()) {\n          if (file.getName().contains(\".\"))\n            continue;\n          classes.addAll(findClasses(file, iPackageName, iClassLoader));\n        } else if (file.getName().endsWith(CLASS_EXTENSION)) {\n          className = file.getName().substring(0, file.getName().length() - CLASS_EXTENSION.length());\n          classes.add(Class.forName(iPackageName + '.' + className, true, iClassLoader));\n        }\n      }\n    return classes;\n  }", "language": "java", "code": "private static List<Class<?>> findClasses(final File iDirectory, String iPackageName, ClassLoader iClassLoader)\n      throws ClassNotFoundException {\n    final List<Class<?>> classes = new ArrayList<Class<?>>();\n    if (!iDirectory.exists())\n      return classes;\n\n    iPackageName += \".\" + iDirectory.getName();\n\n    String className;\n    final File[] files = iDirectory.listFiles();\n    if (files != null)\n      for (File file : files) {\n        if (file.isDirectory()) {\n          if (file.getName().contains(\".\"))\n            continue;\n          classes.addAll(findClasses(file, iPackageName, iClassLoader));\n        } else if (file.getName().endsWith(CLASS_EXTENSION)) {\n          className = file.getName().substring(0, file.getName().length() - CLASS_EXTENSION.length());\n          classes.add(Class.forName(iPackageName + '.' + className, true, iClassLoader));\n        }\n      }\n    return classes;\n  }", "code_tokens": ["private", "static", "List", "<", "Class", "<", "?", ">", ">", "findClasses", "(", "final", "File", "iDirectory", ",", "String", "iPackageName", ",", "ClassLoader", "iClassLoader", ")", "throws", "ClassNotFoundException", "{", "final", "List", "<", "Class", "<", "?", ">", ">", "classes", "=", "new", "ArrayList", "<", "Class", "<", "?", ">", ">", "(", ")", ";", "if", "(", "!", "iDirectory", ".", "exists", "(", ")", ")", "return", "classes", ";", "iPackageName", "+=", "\".\"", "+", "iDirectory", ".", "getName", "(", ")", ";", "String", "className", ";", "final", "File", "[", "]", "files", "=", "iDirectory", ".", "listFiles", "(", ")", ";", "if", "(", "files", "!=", "null", ")", "for", "(", "File", "file", ":", "files", ")", "{", "if", "(", "file", ".", "isDirectory", "(", ")", ")", "{", "if", "(", "file", ".", "getName", "(", ")", ".", "contains", "(", "\".\"", ")", ")", "continue", ";", "classes", ".", "addAll", "(", "findClasses", "(", "file", ",", "iPackageName", ",", "iClassLoader", ")", ")", ";", "}", "else", "if", "(", "file", ".", "getName", "(", ")", ".", "endsWith", "(", "CLASS_EXTENSION", ")", ")", "{", "className", "=", "file", ".", "getName", "(", ")", ".", "substring", "(", "0", ",", "file", ".", "getName", "(", ")", ".", "length", "(", ")", "-", "CLASS_EXTENSION", ".", "length", "(", ")", ")", ";", "classes", ".", "add", "(", "Class", ".", "forName", "(", "iPackageName", "+", "'", "'", "+", "className", ",", "true", ",", "iClassLoader", ")", ")", ";", "}", "}", "return", "classes", ";", "}"], "docstring": "Recursive method used to find all classes in a given directory and subdirs.\n\n@param iDirectory\nThe base directory\n@param iPackageName\nThe package name for classes found inside the base directory\n@return The classes\n@throws ClassNotFoundException", "docstring_tokens": ["Recursive", "method", "used", "to", "find", "all", "classes", "in", "a", "given", "directory", "and", "subdirs", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/common/reflection/OReflectionHelper.java#L135-L157", "partition": "test", "index": 2912, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/common/reflection/OReflectionHelper.java", "func_name": "OReflectionHelper.getClassessOfInterface", "original_string": "public static List<Class<?>> getClassessOfInterface(String thePackage, Class<?> theInterface, final ClassLoader iClassLoader) {\n    List<Class<?>> classList = new ArrayList<Class<?>>();\n    try {\n      for (Class<?> discovered : getClassesFor(thePackage, iClassLoader)) {\n        if (Arrays.asList(discovered.getInterfaces()).contains(theInterface)) {\n          classList.add(discovered);\n        }\n      }\n    } catch (ClassNotFoundException ex) {\n      OLogManager.instance().error(null, \"Error finding classes\", ex);\n    }\n\n    return classList;\n  }", "language": "java", "code": "public static List<Class<?>> getClassessOfInterface(String thePackage, Class<?> theInterface, final ClassLoader iClassLoader) {\n    List<Class<?>> classList = new ArrayList<Class<?>>();\n    try {\n      for (Class<?> discovered : getClassesFor(thePackage, iClassLoader)) {\n        if (Arrays.asList(discovered.getInterfaces()).contains(theInterface)) {\n          classList.add(discovered);\n        }\n      }\n    } catch (ClassNotFoundException ex) {\n      OLogManager.instance().error(null, \"Error finding classes\", ex);\n    }\n\n    return classList;\n  }", "code_tokens": ["public", "static", "List", "<", "Class", "<", "?", ">", ">", "getClassessOfInterface", "(", "String", "thePackage", ",", "Class", "<", "?", ">", "theInterface", ",", "final", "ClassLoader", "iClassLoader", ")", "{", "List", "<", "Class", "<", "?", ">", ">", "classList", "=", "new", "ArrayList", "<", "Class", "<", "?", ">", ">", "(", ")", ";", "try", "{", "for", "(", "Class", "<", "?", ">", "discovered", ":", "getClassesFor", "(", "thePackage", ",", "iClassLoader", ")", ")", "{", "if", "(", "Arrays", ".", "asList", "(", "discovered", ".", "getInterfaces", "(", ")", ")", ".", "contains", "(", "theInterface", ")", ")", "{", "classList", ".", "add", "(", "discovered", ")", ";", "}", "}", "}", "catch", "(", "ClassNotFoundException", "ex", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "null", ",", "\"Error finding classes\"", ",", "ex", ")", ";", "}", "return", "classList", ";", "}"], "docstring": "Filters discovered classes to see if they implement a given interface.\n\n@param thePackage\n@param theInterface\n@param iClassLoader\n@return The list of classes that implements the requested interface", "docstring_tokens": ["Filters", "discovered", "classes", "to", "see", "if", "they", "implement", "a", "given", "interface", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/common/reflection/OReflectionHelper.java#L167-L180", "partition": "test", "index": 2913, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/common/reflection/OReflectionHelper.java", "func_name": "OReflectionHelper.getGenericMultivalueType", "original_string": "public static Class<?> getGenericMultivalueType(final Field p) {\n    if (p.getType() instanceof Class<?>) {\n      final Type genericType = p.getGenericType();\n      if (genericType != null && genericType instanceof ParameterizedType) {\n        final ParameterizedType pt = (ParameterizedType) genericType;\n        if (pt.getActualTypeArguments() != null && pt.getActualTypeArguments().length > 0) {\n          if (((Class<?>) pt.getRawType()).isAssignableFrom(Map.class)) {\n            if (pt.getActualTypeArguments()[1] instanceof Class<?>) {\n              return (Class<?>) pt.getActualTypeArguments()[1];\n            } else if (pt.getActualTypeArguments()[1] instanceof ParameterizedType)\n              return (Class<?>) ((ParameterizedType) pt.getActualTypeArguments()[1]).getRawType();\n          } else if (pt.getActualTypeArguments()[0] instanceof Class<?>) {\n            return (Class<?>) pt.getActualTypeArguments()[0];\n          } else if (pt.getActualTypeArguments()[0] instanceof ParameterizedType)\n            return (Class<?>) ((ParameterizedType) pt.getActualTypeArguments()[0]).getRawType();\n        }\n      } else if (p.getType().isArray())\n        return p.getType().getComponentType();\n    }\n    return null;\n  }", "language": "java", "code": "public static Class<?> getGenericMultivalueType(final Field p) {\n    if (p.getType() instanceof Class<?>) {\n      final Type genericType = p.getGenericType();\n      if (genericType != null && genericType instanceof ParameterizedType) {\n        final ParameterizedType pt = (ParameterizedType) genericType;\n        if (pt.getActualTypeArguments() != null && pt.getActualTypeArguments().length > 0) {\n          if (((Class<?>) pt.getRawType()).isAssignableFrom(Map.class)) {\n            if (pt.getActualTypeArguments()[1] instanceof Class<?>) {\n              return (Class<?>) pt.getActualTypeArguments()[1];\n            } else if (pt.getActualTypeArguments()[1] instanceof ParameterizedType)\n              return (Class<?>) ((ParameterizedType) pt.getActualTypeArguments()[1]).getRawType();\n          } else if (pt.getActualTypeArguments()[0] instanceof Class<?>) {\n            return (Class<?>) pt.getActualTypeArguments()[0];\n          } else if (pt.getActualTypeArguments()[0] instanceof ParameterizedType)\n            return (Class<?>) ((ParameterizedType) pt.getActualTypeArguments()[0]).getRawType();\n        }\n      } else if (p.getType().isArray())\n        return p.getType().getComponentType();\n    }\n    return null;\n  }", "code_tokens": ["public", "static", "Class", "<", "?", ">", "getGenericMultivalueType", "(", "final", "Field", "p", ")", "{", "if", "(", "p", ".", "getType", "(", ")", "instanceof", "Class", "<", "?", ">", ")", "{", "final", "Type", "genericType", "=", "p", ".", "getGenericType", "(", ")", ";", "if", "(", "genericType", "!=", "null", "&&", "genericType", "instanceof", "ParameterizedType", ")", "{", "final", "ParameterizedType", "pt", "=", "(", "ParameterizedType", ")", "genericType", ";", "if", "(", "pt", ".", "getActualTypeArguments", "(", ")", "!=", "null", "&&", "pt", ".", "getActualTypeArguments", "(", ")", ".", "length", ">", "0", ")", "{", "if", "(", "(", "(", "Class", "<", "?", ">", ")", "pt", ".", "getRawType", "(", ")", ")", ".", "isAssignableFrom", "(", "Map", ".", "class", ")", ")", "{", "if", "(", "pt", ".", "getActualTypeArguments", "(", ")", "[", "1", "]", "instanceof", "Class", "<", "?", ">", ")", "{", "return", "(", "Class", "<", "?", ">", ")", "pt", ".", "getActualTypeArguments", "(", ")", "[", "1", "]", ";", "}", "else", "if", "(", "pt", ".", "getActualTypeArguments", "(", ")", "[", "1", "]", "instanceof", "ParameterizedType", ")", "return", "(", "Class", "<", "?", ">", ")", "(", "(", "ParameterizedType", ")", "pt", ".", "getActualTypeArguments", "(", ")", "[", "1", "]", ")", ".", "getRawType", "(", ")", ";", "}", "else", "if", "(", "pt", ".", "getActualTypeArguments", "(", ")", "[", "0", "]", "instanceof", "Class", "<", "?", ">", ")", "{", "return", "(", "Class", "<", "?", ">", ")", "pt", ".", "getActualTypeArguments", "(", ")", "[", "0", "]", ";", "}", "else", "if", "(", "pt", ".", "getActualTypeArguments", "(", ")", "[", "0", "]", "instanceof", "ParameterizedType", ")", "return", "(", "Class", "<", "?", ">", ")", "(", "(", "ParameterizedType", ")", "pt", ".", "getActualTypeArguments", "(", ")", "[", "0", "]", ")", ".", "getRawType", "(", ")", ";", "}", "}", "else", "if", "(", "p", ".", "getType", "(", ")", ".", "isArray", "(", ")", ")", "return", "p", ".", "getType", "(", ")", ".", "getComponentType", "(", ")", ";", "}", "return", "null", ";", "}"], "docstring": "Returns the generic class of multi-value objects.\n\n@param p\nField to examine\n@return The Class<?> of generic type if any, otherwise null", "docstring_tokens": ["Returns", "the", "generic", "class", "of", "multi", "-", "value", "objects", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/common/reflection/OReflectionHelper.java#L206-L226", "partition": "test", "index": 2914, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java", "func_name": "OBaseParser.parserOptionalKeyword", "original_string": "protected boolean parserOptionalKeyword(final String... iWords) {\n    parserNextWord(true, \" \\r\\n,\");\n    if (parserLastWord.length() == 0)\n      return false;\n\n    // FOUND: CHECK IF IT'S IN RANGE\n    boolean found = iWords.length == 0;\n    for (String w : iWords) {\n      if (parserLastWord.toString().equals(w)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found)\n      throwSyntaxErrorException(\"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\"\n          + Arrays.toString(iWords) + \"'\");\n\n    return true;\n  }", "language": "java", "code": "protected boolean parserOptionalKeyword(final String... iWords) {\n    parserNextWord(true, \" \\r\\n,\");\n    if (parserLastWord.length() == 0)\n      return false;\n\n    // FOUND: CHECK IF IT'S IN RANGE\n    boolean found = iWords.length == 0;\n    for (String w : iWords) {\n      if (parserLastWord.toString().equals(w)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found)\n      throwSyntaxErrorException(\"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\"\n          + Arrays.toString(iWords) + \"'\");\n\n    return true;\n  }", "code_tokens": ["protected", "boolean", "parserOptionalKeyword", "(", "final", "String", "...", "iWords", ")", "{", "parserNextWord", "(", "true", ",", "\" \\r\\n,\"", ")", ";", "if", "(", "parserLastWord", ".", "length", "(", ")", "==", "0", ")", "return", "false", ";", "// FOUND: CHECK IF IT'S IN RANGE", "boolean", "found", "=", "iWords", ".", "length", "==", "0", ";", "for", "(", "String", "w", ":", "iWords", ")", "{", "if", "(", "parserLastWord", ".", "toString", "(", ")", ".", "equals", "(", "w", ")", ")", "{", "found", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "found", ")", "throwSyntaxErrorException", "(", "\"Found unexpected keyword '\"", "+", "parserLastWord", "+", "\"' while it was expected '\"", "+", "Arrays", ".", "toString", "(", "iWords", ")", "+", "\"'\"", ")", ";", "return", "true", ";", "}"], "docstring": "Parses optional keywords between the iWords. If a keyword is found but doesn't match with iWords then a SyntaxError is raised.\n\n@param iWords\nOptional words to match as keyword. If at least one is passed, then the check is made\n@return true if a keyword was found, otherwise false", "docstring_tokens": ["Parses", "optional", "keywords", "between", "the", "iWords", ".", "If", "a", "keyword", "is", "found", "but", "doesn", "t", "match", "with", "iWords", "then", "a", "SyntaxError", "is", "raised", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java#L407-L426", "partition": "test", "index": 3337, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/parser/OStringParser.java", "func_name": "OStringParser.jump", "original_string": "public static int jump(final CharSequence iText, int iCurrentPosition, final int iMaxPosition, final String iJumpChars) {\n    if (iCurrentPosition < 0)\n      return -1;\n\n    final int size = iMaxPosition > -1 ? Math.min(iMaxPosition, iText.length()) : iText.length();\n    final int jumpCharSize = iJumpChars.length();\n    boolean found = true;\n    char c;\n    for (; iCurrentPosition < size; ++iCurrentPosition) {\n      found = false;\n      c = iText.charAt(iCurrentPosition);\n      for (int jumpIndex = 0; jumpIndex < jumpCharSize; ++jumpIndex) {\n        if (iJumpChars.charAt(jumpIndex) == c) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found)\n        break;\n    }\n\n    return iCurrentPosition >= size ? -1 : iCurrentPosition;\n  }", "language": "java", "code": "public static int jump(final CharSequence iText, int iCurrentPosition, final int iMaxPosition, final String iJumpChars) {\n    if (iCurrentPosition < 0)\n      return -1;\n\n    final int size = iMaxPosition > -1 ? Math.min(iMaxPosition, iText.length()) : iText.length();\n    final int jumpCharSize = iJumpChars.length();\n    boolean found = true;\n    char c;\n    for (; iCurrentPosition < size; ++iCurrentPosition) {\n      found = false;\n      c = iText.charAt(iCurrentPosition);\n      for (int jumpIndex = 0; jumpIndex < jumpCharSize; ++jumpIndex) {\n        if (iJumpChars.charAt(jumpIndex) == c) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found)\n        break;\n    }\n\n    return iCurrentPosition >= size ? -1 : iCurrentPosition;\n  }", "code_tokens": ["public", "static", "int", "jump", "(", "final", "CharSequence", "iText", ",", "int", "iCurrentPosition", ",", "final", "int", "iMaxPosition", ",", "final", "String", "iJumpChars", ")", "{", "if", "(", "iCurrentPosition", "<", "0", ")", "return", "-", "1", ";", "final", "int", "size", "=", "iMaxPosition", ">", "-", "1", "?", "Math", ".", "min", "(", "iMaxPosition", ",", "iText", ".", "length", "(", ")", ")", ":", "iText", ".", "length", "(", ")", ";", "final", "int", "jumpCharSize", "=", "iJumpChars", ".", "length", "(", ")", ";", "boolean", "found", "=", "true", ";", "char", "c", ";", "for", "(", ";", "iCurrentPosition", "<", "size", ";", "++", "iCurrentPosition", ")", "{", "found", "=", "false", ";", "c", "=", "iText", ".", "charAt", "(", "iCurrentPosition", ")", ";", "for", "(", "int", "jumpIndex", "=", "0", ";", "jumpIndex", "<", "jumpCharSize", ";", "++", "jumpIndex", ")", "{", "if", "(", "iJumpChars", ".", "charAt", "(", "jumpIndex", ")", "==", "c", ")", "{", "found", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "found", ")", "break", ";", "}", "return", "iCurrentPosition", ">=", "size", "?", "-", "1", ":", "iCurrentPosition", ";", "}"], "docstring": "Jump some characters reading from an offset of a String.\n\n@param iText\nString to analyze\n@param iCurrentPosition\nCurrent position in text\n@param iMaxPosition\nMaximum position to read\n@param iJumpChars\nString as char array of chars to jump\n@return The new offset inside the string analyzed", "docstring_tokens": ["Jump", "some", "characters", "reading", "from", "an", "offset", "of", "a", "String", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/parser/OStringParser.java#L325-L348", "partition": "test", "index": 3161, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java", "func_name": "OBaseParser.parserRequiredWord", "original_string": "protected String parserRequiredWord(final boolean iUpperCase, final String iCustomMessage, String iSeparators) {\n    if (iSeparators == null)\n      iSeparators = \" ()=><,\\r\\n\";\n\n    parserNextWord(iUpperCase, iSeparators);\n    if (parserLastWord.length() == 0)\n      throwSyntaxErrorException(iCustomMessage);\n    if (parserLastWord.charAt(0) == '`' && parserLastWord.charAt(parserLastWord.length() - 1) == '`') {\n      return parserLastWord.substring(1, parserLastWord.length() - 1);\n    }\n    return parserLastWord.toString();\n  }", "language": "java", "code": "protected String parserRequiredWord(final boolean iUpperCase, final String iCustomMessage, String iSeparators) {\n    if (iSeparators == null)\n      iSeparators = \" ()=><,\\r\\n\";\n\n    parserNextWord(iUpperCase, iSeparators);\n    if (parserLastWord.length() == 0)\n      throwSyntaxErrorException(iCustomMessage);\n    if (parserLastWord.charAt(0) == '`' && parserLastWord.charAt(parserLastWord.length() - 1) == '`') {\n      return parserLastWord.substring(1, parserLastWord.length() - 1);\n    }\n    return parserLastWord.toString();\n  }", "code_tokens": ["protected", "String", "parserRequiredWord", "(", "final", "boolean", "iUpperCase", ",", "final", "String", "iCustomMessage", ",", "String", "iSeparators", ")", "{", "if", "(", "iSeparators", "==", "null", ")", "iSeparators", "=", "\" ()=><,\\r\\n\"", ";", "parserNextWord", "(", "iUpperCase", ",", "iSeparators", ")", ";", "if", "(", "parserLastWord", ".", "length", "(", ")", "==", "0", ")", "throwSyntaxErrorException", "(", "iCustomMessage", ")", ";", "if", "(", "parserLastWord", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "parserLastWord", ".", "charAt", "(", "parserLastWord", ".", "length", "(", ")", "-", "1", ")", "==", "'", "'", ")", "{", "return", "parserLastWord", ".", "substring", "(", "1", ",", "parserLastWord", ".", "length", "(", ")", "-", "1", ")", ";", "}", "return", "parserLastWord", ".", "toString", "(", ")", ";", "}"], "docstring": "Parses the next word. If no word is found or the parsed word is not present in the word array received as parameter then a\nSyntaxError exception with the custom message received as parameter is thrown. It returns the word parsed if any.\n\n@param iUpperCase\nTrue if must return UPPERCASE, otherwise false\n@param iCustomMessage\nCustom message to include in case of SyntaxError exception\n@param iSeparators\nSeparator characters\n@return The word parsed", "docstring_tokens": ["Parses", "the", "next", "word", ".", "If", "no", "word", "is", "found", "or", "the", "parsed", "word", "is", "not", "present", "in", "the", "word", "array", "received", "as", "parameter", "then", "a", "SyntaxError", "exception", "with", "the", "custom", "message", "received", "as", "parameter", "is", "thrown", ".", "It", "returns", "the", "word", "parsed", "if", "any", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/parser/OBaseParser.java#L296-L307", "partition": "test", "index": 3335, "time": "2014-09-23 12:15:59"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.isExecutionModeSynchronous", "original_string": "public Boolean isExecutionModeSynchronous(final String iClusterName) {\n    Object value = getClusterConfiguration(iClusterName).field(EXECUTION_MODE);\n    if (value == null) {\n      value = configuration.field(EXECUTION_MODE);\n      if (value == null)\n        return null;\n    }\n\n    if (value.toString().equalsIgnoreCase(\"undefined\"))\n      return null;\n\n    return value.toString().equalsIgnoreCase(EXECUTION_MODE_SYNCHRONOUS);\n  }", "language": "java", "code": "public Boolean isExecutionModeSynchronous(final String iClusterName) {\n    Object value = getClusterConfiguration(iClusterName).field(EXECUTION_MODE);\n    if (value == null) {\n      value = configuration.field(EXECUTION_MODE);\n      if (value == null)\n        return null;\n    }\n\n    if (value.toString().equalsIgnoreCase(\"undefined\"))\n      return null;\n\n    return value.toString().equalsIgnoreCase(EXECUTION_MODE_SYNCHRONOUS);\n  }", "code_tokens": ["public", "Boolean", "isExecutionModeSynchronous", "(", "final", "String", "iClusterName", ")", "{", "Object", "value", "=", "getClusterConfiguration", "(", "iClusterName", ")", ".", "field", "(", "EXECUTION_MODE", ")", ";", "if", "(", "value", "==", "null", ")", "{", "value", "=", "configuration", ".", "field", "(", "EXECUTION_MODE", ")", ";", "if", "(", "value", "==", "null", ")", "return", "null", ";", "}", "if", "(", "value", ".", "toString", "(", ")", ".", "equalsIgnoreCase", "(", "\"undefined\"", ")", ")", "return", "null", ";", "return", "value", ".", "toString", "(", ")", ".", "equalsIgnoreCase", "(", "EXECUTION_MODE_SYNCHRONOUS", ")", ";", "}"], "docstring": "Returns the execution mode if synchronous.\n\n@param iClusterName Cluster name, or null for *\n\n@return true = synchronous, false = asynchronous, null = undefined", "docstring_tokens": ["Returns", "the", "execution", "mode", "if", "synchronous", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L124-L136", "partition": "test", "index": 3086, "time": "2014-09-24 01:21:28"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpRequestWrapper.java", "func_name": "OHttpRequestWrapper.getArgument", "original_string": "public String getArgument(final int iPosition) {\r\n     return args != null && args.length > iPosition ? args[iPosition] : null;\r\n   }", "language": "java", "code": "public String getArgument(final int iPosition) {\r\n     return args != null && args.length > iPosition ? args[iPosition] : null;\r\n   }", "code_tokens": ["public", "String", "getArgument", "(", "final", "int", "iPosition", ")", "{", "return", "args", "!=", "null", "&&", "args", ".", "length", ">", "iPosition", "?", "args", "[", "iPosition", "]", ":", "null", ";", "}"], "docstring": "Returns the argument by position\n\n@return Array of arguments", "docstring_tokens": ["Returns", "the", "argument", "by", "position"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpRequestWrapper.java#L130-L132", "partition": "test", "index": 3219, "time": "2014-09-29 20:09:54"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpRequestWrapper.java", "func_name": "OHttpRequestWrapper.hasParameters", "original_string": "public int hasParameters(final String... iNames) {\r\n     int found = 0;\r\n\r\n     if (iNames != null && request.parameters != null)\r\n       for (String name : iNames)\r\n         found += request.parameters.containsKey(name) ? 1 : 0;\r\n\r\n     return found;\r\n   }", "language": "java", "code": "public int hasParameters(final String... iNames) {\r\n     int found = 0;\r\n\r\n     if (iNames != null && request.parameters != null)\r\n       for (String name : iNames)\r\n         found += request.parameters.containsKey(name) ? 1 : 0;\r\n\r\n     return found;\r\n   }", "code_tokens": ["public", "int", "hasParameters", "(", "final", "String", "...", "iNames", ")", "{", "int", "found", "=", "0", ";", "if", "(", "iNames", "!=", "null", "&&", "request", ".", "parameters", "!=", "null", ")", "for", "(", "String", "name", ":", "iNames", ")", "found", "+=", "request", ".", "parameters", ".", "containsKey", "(", "name", ")", "?", "1", ":", "0", ";", "return", "found", ";", "}"], "docstring": "Checks how many parameters have been received.\n\n@return The number of parameters found between the passed ones", "docstring_tokens": ["Checks", "how", "many", "parameters", "have", "been", "received", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpRequestWrapper.java#L157-L165", "partition": "test", "index": 3220, "time": "2014-09-29 20:09:54"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OrientSql.java", "func_name": "OrientSql.generateParseException", "original_string": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[279];\n    if (jj_kind >= 0) {\n      la1tokens[jj_kind] = true;\n      jj_kind = -1;\n    }\n    for (int i = 0; i < 424; i++) {\n      if (jj_la1[i] == jj_gen) {\n        for (int j = 0; j < 32; j++) {\n          if ((jj_la1_0[i] & (1<<j)) != 0) {\n            la1tokens[j] = true;\n          }\n          if ((jj_la1_1[i] & (1<<j)) != 0) {\n            la1tokens[32+j] = true;\n          }\n          if ((jj_la1_2[i] & (1<<j)) != 0) {\n            la1tokens[64+j] = true;\n          }\n          if ((jj_la1_3[i] & (1<<j)) != 0) {\n            la1tokens[96+j] = true;\n          }\n          if ((jj_la1_4[i] & (1<<j)) != 0) {\n            la1tokens[128+j] = true;\n          }\n          if ((jj_la1_5[i] & (1<<j)) != 0) {\n            la1tokens[160+j] = true;\n          }\n          if ((jj_la1_6[i] & (1<<j)) != 0) {\n            la1tokens[192+j] = true;\n          }\n          if ((jj_la1_7[i] & (1<<j)) != 0) {\n            la1tokens[224+j] = true;\n          }\n          if ((jj_la1_8[i] & (1<<j)) != 0) {\n            la1tokens[256+j] = true;\n          }\n        }\n      }\n    }\n    for (int i = 0; i < 279; i++) {\n      if (la1tokens[i]) {\n        jj_expentry = new int[1];\n        jj_expentry[0] = i;\n        jj_expentries.add(jj_expentry);\n      }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n      exptokseq[i] = jj_expentries.get(i);\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n  }", "language": "java", "code": "public ParseException generateParseException() {\n    jj_expentries.clear();\n    boolean[] la1tokens = new boolean[279];\n    if (jj_kind >= 0) {\n      la1tokens[jj_kind] = true;\n      jj_kind = -1;\n    }\n    for (int i = 0; i < 424; i++) {\n      if (jj_la1[i] == jj_gen) {\n        for (int j = 0; j < 32; j++) {\n          if ((jj_la1_0[i] & (1<<j)) != 0) {\n            la1tokens[j] = true;\n          }\n          if ((jj_la1_1[i] & (1<<j)) != 0) {\n            la1tokens[32+j] = true;\n          }\n          if ((jj_la1_2[i] & (1<<j)) != 0) {\n            la1tokens[64+j] = true;\n          }\n          if ((jj_la1_3[i] & (1<<j)) != 0) {\n            la1tokens[96+j] = true;\n          }\n          if ((jj_la1_4[i] & (1<<j)) != 0) {\n            la1tokens[128+j] = true;\n          }\n          if ((jj_la1_5[i] & (1<<j)) != 0) {\n            la1tokens[160+j] = true;\n          }\n          if ((jj_la1_6[i] & (1<<j)) != 0) {\n            la1tokens[192+j] = true;\n          }\n          if ((jj_la1_7[i] & (1<<j)) != 0) {\n            la1tokens[224+j] = true;\n          }\n          if ((jj_la1_8[i] & (1<<j)) != 0) {\n            la1tokens[256+j] = true;\n          }\n        }\n      }\n    }\n    for (int i = 0; i < 279; i++) {\n      if (la1tokens[i]) {\n        jj_expentry = new int[1];\n        jj_expentry[0] = i;\n        jj_expentries.add(jj_expentry);\n      }\n    }\n    jj_endpos = 0;\n    jj_rescan_token();\n    jj_add_error_token(0, 0);\n    int[][] exptokseq = new int[jj_expentries.size()][];\n    for (int i = 0; i < jj_expentries.size(); i++) {\n      exptokseq[i] = jj_expentries.get(i);\n    }\n    return new ParseException(token, exptokseq, tokenImage);\n  }", "code_tokens": ["public", "ParseException", "generateParseException", "(", ")", "{", "jj_expentries", ".", "clear", "(", ")", ";", "boolean", "[", "]", "la1tokens", "=", "new", "boolean", "[", "279", "]", ";", "if", "(", "jj_kind", ">=", "0", ")", "{", "la1tokens", "[", "jj_kind", "]", "=", "true", ";", "jj_kind", "=", "-", "1", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "424", ";", "i", "++", ")", "{", "if", "(", "jj_la1", "[", "i", "]", "==", "jj_gen", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "32", ";", "j", "++", ")", "{", "if", "(", "(", "jj_la1_0", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "j", "]", "=", "true", ";", "}", "if", "(", "(", "jj_la1_1", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "32", "+", "j", "]", "=", "true", ";", "}", "if", "(", "(", "jj_la1_2", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "64", "+", "j", "]", "=", "true", ";", "}", "if", "(", "(", "jj_la1_3", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "96", "+", "j", "]", "=", "true", ";", "}", "if", "(", "(", "jj_la1_4", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "128", "+", "j", "]", "=", "true", ";", "}", "if", "(", "(", "jj_la1_5", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "160", "+", "j", "]", "=", "true", ";", "}", "if", "(", "(", "jj_la1_6", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "192", "+", "j", "]", "=", "true", ";", "}", "if", "(", "(", "jj_la1_7", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "224", "+", "j", "]", "=", "true", ";", "}", "if", "(", "(", "jj_la1_8", "[", "i", "]", "&", "(", "1", "<<", "j", ")", ")", "!=", "0", ")", "{", "la1tokens", "[", "256", "+", "j", "]", "=", "true", ";", "}", "}", "}", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "279", ";", "i", "++", ")", "{", "if", "(", "la1tokens", "[", "i", "]", ")", "{", "jj_expentry", "=", "new", "int", "[", "1", "]", ";", "jj_expentry", "[", "0", "]", "=", "i", ";", "jj_expentries", ".", "add", "(", "jj_expentry", ")", ";", "}", "}", "jj_endpos", "=", "0", ";", "jj_rescan_token", "(", ")", ";", "jj_add_error_token", "(", "0", ",", "0", ")", ";", "int", "[", "]", "[", "]", "exptokseq", "=", "new", "int", "[", "jj_expentries", ".", "size", "(", ")", "]", "[", "", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "jj_expentries", ".", "size", "(", ")", ";", "i", "++", ")", "{", "exptokseq", "[", "i", "]", "=", "jj_expentries", ".", "get", "(", "i", ")", ";", "}", "return", "new", "ParseException", "(", "token", ",", "exptokseq", ",", "tokenImage", ")", ";", "}"], "docstring": "Generate ParseException.", "docstring_tokens": ["Generate", "ParseException", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OrientSql.java#L31594-L31649", "partition": "test", "index": 3206, "time": "2014-10-07 15:04:14"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OrientSql.java", "func_name": "OrientSql.getToken", "original_string": "final public Token getToken(int index) {\n    Token t = token;\n    for (int i = 0; i < index; i++) {\n      if (t.next != null) t = t.next;\n      else t = t.next = token_source.getNextToken();\n    }\n    return t;\n  }", "language": "java", "code": "final public Token getToken(int index) {\n    Token t = token;\n    for (int i = 0; i < index; i++) {\n      if (t.next != null) t = t.next;\n      else t = t.next = token_source.getNextToken();\n    }\n    return t;\n  }", "code_tokens": ["final", "public", "Token", "getToken", "(", "int", "index", ")", "{", "Token", "t", "=", "token", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "index", ";", "i", "++", ")", "{", "if", "(", "t", ".", "next", "!=", "null", ")", "t", "=", "t", ".", "next", ";", "else", "t", "=", "t", ".", "next", "=", "token_source", ".", "getNextToken", "(", ")", ";", "}", "return", "t", ";", "}"], "docstring": "Get the specific Token.", "docstring_tokens": ["Get", "the", "specific", "Token", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OrientSql.java#L31546-L31553", "partition": "test", "index": 3205, "time": "2014-10-07 15:04:14"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OrientSql.java", "func_name": "OrientSql.getNextToken", "original_string": "final public Token getNextToken() {\n    if (token.next != null) token = token.next;\n    else token = token.next = token_source.getNextToken();\n    jj_ntk = -1;\n    jj_gen++;\n    return token;\n  }", "language": "java", "code": "final public Token getNextToken() {\n    if (token.next != null) token = token.next;\n    else token = token.next = token_source.getNextToken();\n    jj_ntk = -1;\n    jj_gen++;\n    return token;\n  }", "code_tokens": ["final", "public", "Token", "getNextToken", "(", ")", "{", "if", "(", "token", ".", "next", "!=", "null", ")", "token", "=", "token", ".", "next", ";", "else", "token", "=", "token", ".", "next", "=", "token_source", ".", "getNextToken", "(", ")", ";", "jj_ntk", "=", "-", "1", ";", "jj_gen", "++", ";", "return", "token", ";", "}"], "docstring": "Get the next Token.", "docstring_tokens": ["Get", "the", "next", "Token", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OrientSql.java#L31537-L31543", "partition": "test", "index": 3204, "time": "2014-10-07 15:04:14"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OrientSql.java", "func_name": "OrientSql.parse", "original_string": "final public OStatement parse() throws ParseException {\n /*@bgen(jjtree) parse */\n Oparse jjtn000 = new Oparse(JJTPARSE);\n boolean jjtc000 = true;\n jjtree.openNodeScope(jjtn000);\n jjtn000.jjtSetFirstToken(getToken(1));OStatement result;\n    try {\n      result = Statement();\n      jj_consume_token(0);\n    jjtree.closeNodeScope(jjtn000, true);\n    jjtc000 = false;\n    jjtn000.jjtSetLastToken(getToken(0));\n    {if (true) return result;}\n    } catch (Throwable jjte000) {\n    if (jjtc000) {\n      jjtree.clearNodeScope(jjtn000);\n      jjtc000 = false;\n    } else {\n      jjtree.popNode();\n    }\n    if (jjte000 instanceof RuntimeException) {\n      {if (true) throw (RuntimeException)jjte000;}\n    }\n    if (jjte000 instanceof ParseException) {\n      {if (true) throw (ParseException)jjte000;}\n    }\n    {if (true) throw (Error)jjte000;}\n    } finally {\n    if (jjtc000) {\n      jjtree.closeNodeScope(jjtn000, true);\n      jjtn000.jjtSetLastToken(getToken(0));\n    }\n    }\n    throw new Error(\"Missing return statement in function\");\n  }", "language": "java", "code": "final public OStatement parse() throws ParseException {\n /*@bgen(jjtree) parse */\n Oparse jjtn000 = new Oparse(JJTPARSE);\n boolean jjtc000 = true;\n jjtree.openNodeScope(jjtn000);\n jjtn000.jjtSetFirstToken(getToken(1));OStatement result;\n    try {\n      result = Statement();\n      jj_consume_token(0);\n    jjtree.closeNodeScope(jjtn000, true);\n    jjtc000 = false;\n    jjtn000.jjtSetLastToken(getToken(0));\n    {if (true) return result;}\n    } catch (Throwable jjte000) {\n    if (jjtc000) {\n      jjtree.clearNodeScope(jjtn000);\n      jjtc000 = false;\n    } else {\n      jjtree.popNode();\n    }\n    if (jjte000 instanceof RuntimeException) {\n      {if (true) throw (RuntimeException)jjte000;}\n    }\n    if (jjte000 instanceof ParseException) {\n      {if (true) throw (ParseException)jjte000;}\n    }\n    {if (true) throw (Error)jjte000;}\n    } finally {\n    if (jjtc000) {\n      jjtree.closeNodeScope(jjtn000, true);\n      jjtn000.jjtSetLastToken(getToken(0));\n    }\n    }\n    throw new Error(\"Missing return statement in function\");\n  }", "code_tokens": ["final", "public", "OStatement", "parse", "(", ")", "throws", "ParseException", "{", "/*@bgen(jjtree) parse */", "Oparse", "jjtn000", "=", "new", "Oparse", "(", "JJTPARSE", ")", ";", "boolean", "jjtc000", "=", "true", ";", "jjtree", ".", "openNodeScope", "(", "jjtn000", ")", ";", "jjtn000", ".", "jjtSetFirstToken", "(", "getToken", "(", "1", ")", ")", ";", "OStatement", "result", ";", "try", "{", "result", "=", "Statement", "(", ")", ";", "jj_consume_token", "(", "0", ")", ";", "jjtree", ".", "closeNodeScope", "(", "jjtn000", ",", "true", ")", ";", "jjtc000", "=", "false", ";", "jjtn000", ".", "jjtSetLastToken", "(", "getToken", "(", "0", ")", ")", ";", "{", "if", "(", "true", ")", "return", "result", ";", "}", "}", "catch", "(", "Throwable", "jjte000", ")", "{", "if", "(", "jjtc000", ")", "{", "jjtree", ".", "clearNodeScope", "(", "jjtn000", ")", ";", "jjtc000", "=", "false", ";", "}", "else", "{", "jjtree", ".", "popNode", "(", ")", ";", "}", "if", "(", "jjte000", "instanceof", "RuntimeException", ")", "{", "{", "if", "(", "true", ")", "throw", "(", "RuntimeException", ")", "jjte000", ";", "}", "}", "if", "(", "jjte000", "instanceof", "ParseException", ")", "{", "{", "if", "(", "true", ")", "throw", "(", "ParseException", ")", "jjte000", ";", "}", "}", "{", "if", "(", "true", ")", "throw", "(", "Error", ")", "jjte000", ";", "}", "}", "finally", "{", "if", "(", "jjtc000", ")", "{", "jjtree", ".", "closeNodeScope", "(", "jjtn000", ",", "true", ")", ";", "jjtn000", ".", "jjtSetLastToken", "(", "getToken", "(", "0", ")", ")", ";", "}", "}", "throw", "new", "Error", "(", "\"Missing return statement in function\"", ")", ";", "}"], "docstring": "Root productions.", "docstring_tokens": ["Root", "productions", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OrientSql.java#L97-L131", "partition": "test", "index": 3203, "time": "2014-10-07 15:04:14"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/OServerNetworkListener.java", "func_name": "OServerNetworkListener.listen", "original_string": "private void listen(final String iHostName, final String iHostPortRange, final String iProtocolName,\r\n      Class<? extends ONetworkProtocol> protocolClass) {\r\n\r\n    for (int port : getPorts(iHostPortRange)) {\r\n      inboundAddr = new InetSocketAddress(iHostName, port);\r\n      try {\r\n        serverSocket = socketFactory.createServerSocket(port, 0, InetAddress.getByName(iHostName));\r\n\r\n        if (serverSocket.isBound()) {\r\n          OLogManager.instance().info(this,\r\n              \"Listening $ANSI{green \" + iProtocolName + \"} connections on $ANSI{green \" + inboundAddr.getAddress().getHostAddress()\r\n                  + \":\" + inboundAddr.getPort() + \"} (protocol v.\" + protocolVersion + \", socket=\" + socketFactory.getName() + \")\");\r\n\r\n          return;\r\n        }\r\n      } catch (BindException be) {\r\n        OLogManager.instance().warn(this, \"Port %s:%d busy, trying the next available...\", iHostName, port);\r\n      } catch (SocketException se) {\r\n        OLogManager.instance().error(this, \"Unable to create socket\", se);\r\n        throw new RuntimeException(se);\r\n      } catch (IOException ioe) {\r\n        OLogManager.instance().error(this, \"Unable to read data from an open socket\", ioe);\r\n        System.err.println(\"Unable to read data from an open socket.\");\r\n        throw new RuntimeException(ioe);\r\n      }\r\n    }\r\n\r\n    OLogManager.instance()\r\n        .error(this, \"Unable to listen for connections using the configured ports '%s' on host '%s'\", null, iHostPortRange,\r\n            iHostName);\r\n    throw new OSystemException(\"Unable to listen for connections using the configured ports '%s' on host '%s'\");\r\n  }", "language": "java", "code": "private void listen(final String iHostName, final String iHostPortRange, final String iProtocolName,\r\n      Class<? extends ONetworkProtocol> protocolClass) {\r\n\r\n    for (int port : getPorts(iHostPortRange)) {\r\n      inboundAddr = new InetSocketAddress(iHostName, port);\r\n      try {\r\n        serverSocket = socketFactory.createServerSocket(port, 0, InetAddress.getByName(iHostName));\r\n\r\n        if (serverSocket.isBound()) {\r\n          OLogManager.instance().info(this,\r\n              \"Listening $ANSI{green \" + iProtocolName + \"} connections on $ANSI{green \" + inboundAddr.getAddress().getHostAddress()\r\n                  + \":\" + inboundAddr.getPort() + \"} (protocol v.\" + protocolVersion + \", socket=\" + socketFactory.getName() + \")\");\r\n\r\n          return;\r\n        }\r\n      } catch (BindException be) {\r\n        OLogManager.instance().warn(this, \"Port %s:%d busy, trying the next available...\", iHostName, port);\r\n      } catch (SocketException se) {\r\n        OLogManager.instance().error(this, \"Unable to create socket\", se);\r\n        throw new RuntimeException(se);\r\n      } catch (IOException ioe) {\r\n        OLogManager.instance().error(this, \"Unable to read data from an open socket\", ioe);\r\n        System.err.println(\"Unable to read data from an open socket.\");\r\n        throw new RuntimeException(ioe);\r\n      }\r\n    }\r\n\r\n    OLogManager.instance()\r\n        .error(this, \"Unable to listen for connections using the configured ports '%s' on host '%s'\", null, iHostPortRange,\r\n            iHostName);\r\n    throw new OSystemException(\"Unable to listen for connections using the configured ports '%s' on host '%s'\");\r\n  }", "code_tokens": ["private", "void", "listen", "(", "final", "String", "iHostName", ",", "final", "String", "iHostPortRange", ",", "final", "String", "iProtocolName", ",", "Class", "<", "?", "extends", "ONetworkProtocol", ">", "protocolClass", ")", "{", "for", "(", "int", "port", ":", "getPorts", "(", "iHostPortRange", ")", ")", "{", "inboundAddr", "=", "new", "InetSocketAddress", "(", "iHostName", ",", "port", ")", ";", "try", "{", "serverSocket", "=", "socketFactory", ".", "createServerSocket", "(", "port", ",", "0", ",", "InetAddress", ".", "getByName", "(", "iHostName", ")", ")", ";", "if", "(", "serverSocket", ".", "isBound", "(", ")", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "info", "(", "this", ",", "\"Listening $ANSI{green \"", "+", "iProtocolName", "+", "\"} connections on $ANSI{green \"", "+", "inboundAddr", ".", "getAddress", "(", ")", ".", "getHostAddress", "(", ")", "+", "\":\"", "+", "inboundAddr", ".", "getPort", "(", ")", "+", "\"} (protocol v.\"", "+", "protocolVersion", "+", "\", socket=\"", "+", "socketFactory", ".", "getName", "(", ")", "+", "\")\"", ")", ";", "return", ";", "}", "}", "catch", "(", "BindException", "be", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "this", ",", "\"Port %s:%d busy, trying the next available...\"", ",", "iHostName", ",", "port", ")", ";", "}", "catch", "(", "SocketException", "se", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Unable to create socket\"", ",", "se", ")", ";", "throw", "new", "RuntimeException", "(", "se", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Unable to read data from an open socket\"", ",", "ioe", ")", ";", "System", ".", "err", ".", "println", "(", "\"Unable to read data from an open socket.\"", ")", ";", "throw", "new", "RuntimeException", "(", "ioe", ")", ";", "}", "}", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Unable to listen for connections using the configured ports '%s' on host '%s'\"", ",", "null", ",", "iHostPortRange", ",", "iHostName", ")", ";", "throw", "new", "OSystemException", "(", "\"Unable to listen for connections using the configured ports '%s' on host '%s'\"", ")", ";", "}"], "docstring": "Initialize a server socket for communicating with the client.\n\n@param iHostPortRange\n@param iHostName", "docstring_tokens": ["Initialize", "a", "server", "socket", "for", "communicating", "with", "the", "client", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/OServerNetworkListener.java#L329-L360", "partition": "test", "index": 3244, "time": "2014-10-21 12:30:21"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/OServerNetworkListener.java", "func_name": "OServerNetworkListener.readParameters", "original_string": "private void readParameters(final OContextConfiguration iServerConfig, final OServerParameterConfiguration[] iParameters) {\r\n    configuration = new OContextConfiguration(iServerConfig);\r\n\r\n    // SET PARAMETERS\r\n    if (iParameters != null && iParameters.length > 0) {\r\n      // CONVERT PARAMETERS IN MAP TO INTIALIZE THE CONTEXT-CONFIGURATION\r\n      for (OServerParameterConfiguration param : iParameters)\r\n        configuration.setValue(param.name, param.value);\r\n    }\r\n\r\n    socketBufferSize = configuration.getValueAsInteger(OGlobalConfiguration.NETWORK_SOCKET_BUFFER_SIZE);\r\n  }", "language": "java", "code": "private void readParameters(final OContextConfiguration iServerConfig, final OServerParameterConfiguration[] iParameters) {\r\n    configuration = new OContextConfiguration(iServerConfig);\r\n\r\n    // SET PARAMETERS\r\n    if (iParameters != null && iParameters.length > 0) {\r\n      // CONVERT PARAMETERS IN MAP TO INTIALIZE THE CONTEXT-CONFIGURATION\r\n      for (OServerParameterConfiguration param : iParameters)\r\n        configuration.setValue(param.name, param.value);\r\n    }\r\n\r\n    socketBufferSize = configuration.getValueAsInteger(OGlobalConfiguration.NETWORK_SOCKET_BUFFER_SIZE);\r\n  }", "code_tokens": ["private", "void", "readParameters", "(", "final", "OContextConfiguration", "iServerConfig", ",", "final", "OServerParameterConfiguration", "[", "]", "iParameters", ")", "{", "configuration", "=", "new", "OContextConfiguration", "(", "iServerConfig", ")", ";", "// SET PARAMETERS\r", "if", "(", "iParameters", "!=", "null", "&&", "iParameters", ".", "length", ">", "0", ")", "{", "// CONVERT PARAMETERS IN MAP TO INTIALIZE THE CONTEXT-CONFIGURATION\r", "for", "(", "OServerParameterConfiguration", "param", ":", "iParameters", ")", "configuration", ".", "setValue", "(", "param", ".", "name", ",", "param", ".", "value", ")", ";", "}", "socketBufferSize", "=", "configuration", ".", "getValueAsInteger", "(", "OGlobalConfiguration", ".", "NETWORK_SOCKET_BUFFER_SIZE", ")", ";", "}"], "docstring": "Initializes connection parameters by the reading XML configuration. If not specified, get the parameters defined as global\nconfiguration.\n\n@param iServerConfig", "docstring_tokens": ["Initializes", "connection", "parameters", "by", "the", "reading", "XML", "configuration", ".", "If", "not", "specified", "get", "the", "parameters", "defined", "as", "global", "configuration", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/OServerNetworkListener.java#L368-L379", "partition": "test", "index": 3245, "time": "2014-10-21 12:30:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/iterator/OIdentifiableIterator.java", "func_name": "OIdentifiableIterator.getRecord", "original_string": "protected ORecord getRecord() {\r\n    final ORecord record;\r\n    if (reusedRecord != null) {\r\n      // REUSE THE SAME RECORD AFTER HAVING RESETTED IT\r\n      record = reusedRecord;\r\n      record.reset();\r\n    } else\r\n      record = null;\r\n    return record;\r\n  }", "language": "java", "code": "protected ORecord getRecord() {\r\n    final ORecord record;\r\n    if (reusedRecord != null) {\r\n      // REUSE THE SAME RECORD AFTER HAVING RESETTED IT\r\n      record = reusedRecord;\r\n      record.reset();\r\n    } else\r\n      record = null;\r\n    return record;\r\n  }", "code_tokens": ["protected", "ORecord", "getRecord", "(", ")", "{", "final", "ORecord", "record", ";", "if", "(", "reusedRecord", "!=", "null", ")", "{", "// REUSE THE SAME RECORD AFTER HAVING RESETTED IT\r", "record", "=", "reusedRecord", ";", "record", ".", "reset", "(", ")", ";", "}", "else", "record", "=", "null", ";", "return", "record", ";", "}"], "docstring": "Return the record to use for the operation.\n\n@return the record to use for the operation.", "docstring_tokens": ["Return", "the", "record", "to", "use", "for", "the", "operation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/iterator/OIdentifiableIterator.java#L233-L242", "partition": "test", "index": 3196, "time": "2014-10-29 17:49:31"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/db/OLazyCollectionUtil.java", "func_name": "OLazyCollectionUtil.getDatabase", "original_string": "protected static OObjectDatabaseTx getDatabase() {\n    ODatabaseInternal<?> databaseOwner = ODatabaseRecordThreadLocal.instance().get().getDatabaseOwner();\n    if (databaseOwner instanceof OObjectDatabaseTx) {\n      return (OObjectDatabaseTx) databaseOwner;\n    } else if (databaseOwner instanceof ODatabaseDocumentInternal) {\n      return new OObjectDatabaseTx((ODatabaseDocumentInternal) databaseOwner);\n    }\n    throw new IllegalStateException(\"Current database not of expected type\");\n  }", "language": "java", "code": "protected static OObjectDatabaseTx getDatabase() {\n    ODatabaseInternal<?> databaseOwner = ODatabaseRecordThreadLocal.instance().get().getDatabaseOwner();\n    if (databaseOwner instanceof OObjectDatabaseTx) {\n      return (OObjectDatabaseTx) databaseOwner;\n    } else if (databaseOwner instanceof ODatabaseDocumentInternal) {\n      return new OObjectDatabaseTx((ODatabaseDocumentInternal) databaseOwner);\n    }\n    throw new IllegalStateException(\"Current database not of expected type\");\n  }", "code_tokens": ["protected", "static", "OObjectDatabaseTx", "getDatabase", "(", ")", "{", "ODatabaseInternal", "<", "?", ">", "databaseOwner", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ".", "getDatabaseOwner", "(", ")", ";", "if", "(", "databaseOwner", "instanceof", "OObjectDatabaseTx", ")", "{", "return", "(", "OObjectDatabaseTx", ")", "databaseOwner", ";", "}", "else", "if", "(", "databaseOwner", "instanceof", "ODatabaseDocumentInternal", ")", "{", "return", "new", "OObjectDatabaseTx", "(", "(", "ODatabaseDocumentInternal", ")", "databaseOwner", ")", ";", "}", "throw", "new", "IllegalStateException", "(", "\"Current database not of expected type\"", ")", ";", "}"], "docstring": "Gets the current thread database as a ODatabasePojoAbstract, wrapping it where necessary.", "docstring_tokens": ["Gets", "the", "current", "thread", "database", "as", "a", "ODatabasePojoAbstract", "wrapping", "it", "where", "necessary", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/db/OLazyCollectionUtil.java#L16-L24", "partition": "test", "index": 2964, "time": "2014-11-05 09:15:57"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/command/post/OServerCommandPostAuthToken.java", "func_name": "OServerCommandPostAuthToken.authenticate", "original_string": "protected String authenticate(final String username, final String password, final String iDatabaseName) throws IOException {\n    ODatabaseDocument db = null;\n    String userRid = null;\n    try {\n      db = (ODatabaseDocument) server.openDatabase(iDatabaseName, username, password);\n\n      userRid = (db.getUser() == null ? \"<server user>\" : db.getUser().getDocument().getIdentity().toString());\n    } catch (OSecurityAccessException e) {\n      // WRONG USER/PASSWD\n    } catch (OLockException e) {\n      OLogManager.instance().error(this, \"Cannot access to the database '\" + iDatabaseName + \"'\", e);\n    } finally {\n      if (db != null) {\n        db.close();\n      }\n    }\n    return userRid;\n  }", "language": "java", "code": "protected String authenticate(final String username, final String password, final String iDatabaseName) throws IOException {\n    ODatabaseDocument db = null;\n    String userRid = null;\n    try {\n      db = (ODatabaseDocument) server.openDatabase(iDatabaseName, username, password);\n\n      userRid = (db.getUser() == null ? \"<server user>\" : db.getUser().getDocument().getIdentity().toString());\n    } catch (OSecurityAccessException e) {\n      // WRONG USER/PASSWD\n    } catch (OLockException e) {\n      OLogManager.instance().error(this, \"Cannot access to the database '\" + iDatabaseName + \"'\", e);\n    } finally {\n      if (db != null) {\n        db.close();\n      }\n    }\n    return userRid;\n  }", "code_tokens": ["protected", "String", "authenticate", "(", "final", "String", "username", ",", "final", "String", "password", ",", "final", "String", "iDatabaseName", ")", "throws", "IOException", "{", "ODatabaseDocument", "db", "=", "null", ";", "String", "userRid", "=", "null", ";", "try", "{", "db", "=", "(", "ODatabaseDocument", ")", "server", ".", "openDatabase", "(", "iDatabaseName", ",", "username", ",", "password", ")", ";", "userRid", "=", "(", "db", ".", "getUser", "(", ")", "==", "null", "?", "\"<server user>\"", ":", "db", ".", "getUser", "(", ")", ".", "getDocument", "(", ")", ".", "getIdentity", "(", ")", ".", "toString", "(", ")", ")", ";", "}", "catch", "(", "OSecurityAccessException", "e", ")", "{", "// WRONG USER/PASSWD", "}", "catch", "(", "OLockException", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Cannot access to the database '\"", "+", "iDatabaseName", "+", "\"'\"", ",", "e", ")", ";", "}", "finally", "{", "if", "(", "db", "!=", "null", ")", "{", "db", ".", "close", "(", ")", ";", "}", "}", "return", "userRid", ";", "}"], "docstring": "null is returned in all other cases and means authentication was unsuccessful.", "docstring_tokens": ["null", "is", "returned", "in", "all", "other", "cases", "and", "means", "authentication", "was", "unsuccessful", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/command/post/OServerCommandPostAuthToken.java#L115-L132", "partition": "test", "index": 3194, "time": "2014-11-07 00:50:37"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/batch/OGraphBatchInsertBasic.java", "func_name": "OGraphBatchInsertBasic.createVertex", "original_string": "public void createVertex(final Long v) {\n    last = last < v ? v : last;\n    final List<Long> outList = out.get(v);\n    if (outList == null) {\n      out.put(v, new ArrayList<Long>(averageEdgeNumberPerNode <= 0 ? 4 : averageEdgeNumberPerNode));\n    }\n  }", "language": "java", "code": "public void createVertex(final Long v) {\n    last = last < v ? v : last;\n    final List<Long> outList = out.get(v);\n    if (outList == null) {\n      out.put(v, new ArrayList<Long>(averageEdgeNumberPerNode <= 0 ? 4 : averageEdgeNumberPerNode));\n    }\n  }", "code_tokens": ["public", "void", "createVertex", "(", "final", "Long", "v", ")", "{", "last", "=", "last", "<", "v", "?", "v", ":", "last", ";", "final", "List", "<", "Long", ">", "outList", "=", "out", ".", "get", "(", "v", ")", ";", "if", "(", "outList", "==", "null", ")", "{", "out", ".", "put", "(", "v", ",", "new", "ArrayList", "<", "Long", ">", "(", "averageEdgeNumberPerNode", "<=", "0", "?", "4", ":", "averageEdgeNumberPerNode", ")", ")", ";", "}", "}"], "docstring": "Creates a new vertex\n\n@param v\nthe vertex ID", "docstring_tokens": ["Creates", "a", "new", "vertex"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/batch/OGraphBatchInsertBasic.java#L258-L264", "partition": "test", "index": 3277, "time": "2014-11-16 09:18:38"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/batch/OGraphBatchInsertBasic.java", "func_name": "OGraphBatchInsertBasic.end", "original_string": "public void end() {\n    final OClass vClass = db.getMetadata().getSchema().getClass(vertexClass);\n\n    try {\n\n      runningThreads = new AtomicInteger(parallel);\n      for (int i = 0; i < parallel - 1; i++) {\n        Thread t = new BatchImporterJob(i, vClass);\n        t.start();\n      }\n      Thread t = new BatchImporterJob(parallel - 1, vClass);\n      t.run();\n\n      if (runningThreads.get() > 0) {\n        synchronized (runningThreads) {\n          while (runningThreads.get() > 0) {\n            try {\n              runningThreads.wait();\n            } catch (InterruptedException e) {\n            }\n          }\n        }\n      }\n\n    } finally {\n      db.activateOnCurrentThread();\n      db.declareIntent(null);\n      db.close();\n      if (walActive)\n        OGlobalConfiguration.USE_WAL.setValue(true);\n    }\n  }", "language": "java", "code": "public void end() {\n    final OClass vClass = db.getMetadata().getSchema().getClass(vertexClass);\n\n    try {\n\n      runningThreads = new AtomicInteger(parallel);\n      for (int i = 0; i < parallel - 1; i++) {\n        Thread t = new BatchImporterJob(i, vClass);\n        t.start();\n      }\n      Thread t = new BatchImporterJob(parallel - 1, vClass);\n      t.run();\n\n      if (runningThreads.get() > 0) {\n        synchronized (runningThreads) {\n          while (runningThreads.get() > 0) {\n            try {\n              runningThreads.wait();\n            } catch (InterruptedException e) {\n            }\n          }\n        }\n      }\n\n    } finally {\n      db.activateOnCurrentThread();\n      db.declareIntent(null);\n      db.close();\n      if (walActive)\n        OGlobalConfiguration.USE_WAL.setValue(true);\n    }\n  }", "code_tokens": ["public", "void", "end", "(", ")", "{", "final", "OClass", "vClass", "=", "db", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "vertexClass", ")", ";", "try", "{", "runningThreads", "=", "new", "AtomicInteger", "(", "parallel", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "parallel", "-", "1", ";", "i", "++", ")", "{", "Thread", "t", "=", "new", "BatchImporterJob", "(", "i", ",", "vClass", ")", ";", "t", ".", "start", "(", ")", ";", "}", "Thread", "t", "=", "new", "BatchImporterJob", "(", "parallel", "-", "1", ",", "vClass", ")", ";", "t", ".", "run", "(", ")", ";", "if", "(", "runningThreads", ".", "get", "(", ")", ">", "0", ")", "{", "synchronized", "(", "runningThreads", ")", "{", "while", "(", "runningThreads", ".", "get", "(", ")", ">", "0", ")", "{", "try", "{", "runningThreads", ".", "wait", "(", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "}", "}", "}", "}", "}", "finally", "{", "db", ".", "activateOnCurrentThread", "(", ")", ";", "db", ".", "declareIntent", "(", "null", ")", ";", "db", ".", "close", "(", ")", ";", "if", "(", "walActive", ")", "OGlobalConfiguration", ".", "USE_WAL", ".", "setValue", "(", "true", ")", ";", "}", "}"], "docstring": "Flushes data to db and closes the db. Call this once, after vertices and edges creation.", "docstring_tokens": ["Flushes", "data", "to", "db", "and", "closes", "the", "db", ".", "Call", "this", "once", "after", "vertices", "and", "edges", "creation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/batch/OGraphBatchInsertBasic.java#L219-L250", "partition": "test", "index": 3276, "time": "2014-11-16 09:18:38"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.clearInitStack", "original_string": "public static void clearInitStack() {\n    final ThreadLocal<Deque<OrientBaseGraph>> is = initializationStack;\n    if (is != null)\n      is.get().clear();\n\n    final ThreadLocal<OrientBaseGraph> ag = activeGraph;\n    if (ag != null)\n      ag.remove();\n\n  }", "language": "java", "code": "public static void clearInitStack() {\n    final ThreadLocal<Deque<OrientBaseGraph>> is = initializationStack;\n    if (is != null)\n      is.get().clear();\n\n    final ThreadLocal<OrientBaseGraph> ag = activeGraph;\n    if (ag != null)\n      ag.remove();\n\n  }", "code_tokens": ["public", "static", "void", "clearInitStack", "(", ")", "{", "final", "ThreadLocal", "<", "Deque", "<", "OrientBaseGraph", ">", ">", "is", "=", "initializationStack", ";", "if", "(", "is", "!=", "null", ")", "is", ".", "get", "(", ")", ".", "clear", "(", ")", ";", "final", "ThreadLocal", "<", "OrientBaseGraph", ">", "ag", "=", "activeGraph", ";", "if", "(", "ag", "!=", "null", ")", "ag", ".", "remove", "(", ")", ";", "}"], "docstring": "Internal use only.", "docstring_tokens": ["Internal", "use", "only", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L293-L302", "partition": "test", "index": 3109, "time": "2014-11-24 18:04:01"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java", "func_name": "OAbstractPaginatedStorage.command", "original_string": "@Override\n  public final Object command(final OCommandRequestText iCommand) {\n    try {\n      while (true) {\n        try {\n          final OCommandExecutor executor = OCommandManager.instance().getExecutor(iCommand);\n\n          // COPY THE CONTEXT FROM THE REQUEST\n          executor.setContext(iCommand.getContext());\n\n          executor.setProgressListener(iCommand.getProgressListener());\n          executor.parse(iCommand);\n\n          return executeCommand(iCommand, executor);\n        } catch (final ORetryQueryException ignore) {\n\n          if (iCommand instanceof OQueryAbstract) {\n            final OQueryAbstract query = (OQueryAbstract) iCommand;\n            query.reset();\n          }\n\n        }\n      }\n    } catch (final RuntimeException ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Error ee) {\n      throw logAndPrepareForRethrow(ee, false);\n    } catch (final Throwable t) {\n      throw logAndPrepareForRethrow(t);\n    }\n  }", "language": "java", "code": "@Override\n  public final Object command(final OCommandRequestText iCommand) {\n    try {\n      while (true) {\n        try {\n          final OCommandExecutor executor = OCommandManager.instance().getExecutor(iCommand);\n\n          // COPY THE CONTEXT FROM THE REQUEST\n          executor.setContext(iCommand.getContext());\n\n          executor.setProgressListener(iCommand.getProgressListener());\n          executor.parse(iCommand);\n\n          return executeCommand(iCommand, executor);\n        } catch (final ORetryQueryException ignore) {\n\n          if (iCommand instanceof OQueryAbstract) {\n            final OQueryAbstract query = (OQueryAbstract) iCommand;\n            query.reset();\n          }\n\n        }\n      }\n    } catch (final RuntimeException ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Error ee) {\n      throw logAndPrepareForRethrow(ee, false);\n    } catch (final Throwable t) {\n      throw logAndPrepareForRethrow(t);\n    }\n  }", "code_tokens": ["@", "Override", "public", "final", "Object", "command", "(", "final", "OCommandRequestText", "iCommand", ")", "{", "try", "{", "while", "(", "true", ")", "{", "try", "{", "final", "OCommandExecutor", "executor", "=", "OCommandManager", ".", "instance", "(", ")", ".", "getExecutor", "(", "iCommand", ")", ";", "// COPY THE CONTEXT FROM THE REQUEST", "executor", ".", "setContext", "(", "iCommand", ".", "getContext", "(", ")", ")", ";", "executor", ".", "setProgressListener", "(", "iCommand", ".", "getProgressListener", "(", ")", ")", ";", "executor", ".", "parse", "(", "iCommand", ")", ";", "return", "executeCommand", "(", "iCommand", ",", "executor", ")", ";", "}", "catch", "(", "final", "ORetryQueryException", "ignore", ")", "{", "if", "(", "iCommand", "instanceof", "OQueryAbstract", ")", "{", "final", "OQueryAbstract", "query", "=", "(", "OQueryAbstract", ")", "iCommand", ";", "query", ".", "reset", "(", ")", ";", "}", "}", "}", "}", "catch", "(", "final", "RuntimeException", "ee", ")", "{", "throw", "logAndPrepareForRethrow", "(", "ee", ")", ";", "}", "catch", "(", "final", "Error", "ee", ")", "{", "throw", "logAndPrepareForRethrow", "(", "ee", ",", "false", ")", ";", "}", "catch", "(", "final", "Throwable", "t", ")", "{", "throw", "logAndPrepareForRethrow", "(", "t", ")", ";", "}", "}"], "docstring": "Executes the command request and return the result back.", "docstring_tokens": ["Executes", "the", "command", "request", "and", "return", "the", "result", "back", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java#L3908-L3938", "partition": "test", "index": 3321, "time": "2014-12-03 11:43:15"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java", "func_name": "OCommandExecutorSQLSelect.parseNoCache", "original_string": "protected boolean parseNoCache(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_NOCACHE))\r\n      return false;\r\n\r\n    noCache = true;\r\n    return true;\r\n  }", "language": "java", "code": "protected boolean parseNoCache(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_NOCACHE))\r\n      return false;\r\n\r\n    noCache = true;\r\n    return true;\r\n  }", "code_tokens": ["protected", "boolean", "parseNoCache", "(", "final", "String", "w", ")", "throws", "OCommandSQLParsingException", "{", "if", "(", "!", "w", ".", "equals", "(", "KEYWORD_NOCACHE", ")", ")", "return", "false", ";", "noCache", "=", "true", ";", "return", "true", ";", "}"], "docstring": "Parses the NOCACHE keyword if found.", "docstring_tokens": ["Parses", "the", "NOCACHE", "keyword", "if", "found", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java#L1322-L1328", "partition": "test", "index": 3314, "time": "2014-12-19 03:55:44"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/util/OClassLoaderHelper.java", "func_name": "OClassLoaderHelper.lookupProviderWithOrientClassLoader", "original_string": "public static synchronized <T extends Object> Iterator<T> lookupProviderWithOrientClassLoader(Class<T> clazz) {\n\n    return lookupProviderWithOrientClassLoader(clazz, OClassLoaderHelper.class.getClassLoader());\n  }", "language": "java", "code": "public static synchronized <T extends Object> Iterator<T> lookupProviderWithOrientClassLoader(Class<T> clazz) {\n\n    return lookupProviderWithOrientClassLoader(clazz, OClassLoaderHelper.class.getClassLoader());\n  }", "code_tokens": ["public", "static", "synchronized", "<", "T", "extends", "Object", ">", "Iterator", "<", "T", ">", "lookupProviderWithOrientClassLoader", "(", "Class", "<", "T", ">", "clazz", ")", "{", "return", "lookupProviderWithOrientClassLoader", "(", "clazz", ",", "OClassLoaderHelper", ".", "class", ".", "getClassLoader", "(", ")", ")", ";", "}"], "docstring": "Switch to the OrientDb classloader before lookups on ServiceRegistry for implementation of the given Class. Useful under OSGI\nand generally under applications where jars are loaded by another class loader\n\n@param clazz\nthe class to lookup foor\n@return an Iterator on the class implementation", "docstring_tokens": ["Switch", "to", "the", "OrientDb", "classloader", "before", "lookups", "on", "ServiceRegistry", "for", "implementation", "of", "the", "given", "Class", ".", "Useful", "under", "OSGI", "and", "generally", "under", "applications", "where", "jars", "are", "loaded", "by", "another", "class", "loader"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/util/OClassLoaderHelper.java#L40-L43", "partition": "test", "index": 3175, "time": "2014-12-26 20:49:51"}
{"repo": "orientechnologies/orientdb", "path": "jdbc/src/main/java/com/orientechnologies/orient/jdbc/OrientBlob.java", "func_name": "OrientBlob.getRelativeIndex", "original_string": "private int getRelativeIndex(long pos) {\r\n    int currentSize = 0;\r\n    currentChunkIndex = 0;\r\n\r\n    // loop until we find the chuks holding the given position\r\n    while (pos >= (currentSize += binaryDataChunks.get(currentChunkIndex).length))\r\n      currentChunkIndex++;\r\n\r\n    currentChunk = binaryDataChunks.get(currentChunkIndex);\r\n    currentSize -= currentChunk.length;\r\n    // the position referred to the target binary chunk\r\n    int relativePosition = (int) (pos - currentSize);\r\n    // the index of the first byte to be returned\r\n    return relativePosition - 1;\r\n  }", "language": "java", "code": "private int getRelativeIndex(long pos) {\r\n    int currentSize = 0;\r\n    currentChunkIndex = 0;\r\n\r\n    // loop until we find the chuks holding the given position\r\n    while (pos >= (currentSize += binaryDataChunks.get(currentChunkIndex).length))\r\n      currentChunkIndex++;\r\n\r\n    currentChunk = binaryDataChunks.get(currentChunkIndex);\r\n    currentSize -= currentChunk.length;\r\n    // the position referred to the target binary chunk\r\n    int relativePosition = (int) (pos - currentSize);\r\n    // the index of the first byte to be returned\r\n    return relativePosition - 1;\r\n  }", "code_tokens": ["private", "int", "getRelativeIndex", "(", "long", "pos", ")", "{", "int", "currentSize", "=", "0", ";", "currentChunkIndex", "=", "0", ";", "// loop until we find the chuks holding the given position\r", "while", "(", "pos", ">=", "(", "currentSize", "+=", "binaryDataChunks", ".", "get", "(", "currentChunkIndex", ")", ".", "length", ")", ")", "currentChunkIndex", "++", ";", "currentChunk", "=", "binaryDataChunks", ".", "get", "(", "currentChunkIndex", ")", ";", "currentSize", "-=", "currentChunk", ".", "length", ";", "// the position referred to the target binary chunk\r", "int", "relativePosition", "=", "(", "int", ")", "(", "pos", "-", "currentSize", ")", ";", "// the index of the first byte to be returned\r", "return", "relativePosition", "-", "1", ";", "}"], "docstring": "Calculates the index within a binary chunk corresponding to the given absolute position within this BLOB\n\n@param pos\n@return", "docstring_tokens": ["Calculates", "the", "index", "within", "a", "binary", "chunk", "corresponding", "to", "the", "given", "absolute", "position", "within", "this", "BLOB"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/jdbc/src/main/java/com/orientechnologies/orient/jdbc/OrientBlob.java#L127-L141", "partition": "test", "index": 3333, "time": "2014-12-31 09:38:43"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java", "func_name": "OCommandExecutorSQLSelect.reportTip", "original_string": "protected void reportTip(final String iMessage) {\r\n    Orient.instance().getProfiler().reportTip(iMessage);\r\n    List<String> tips = (List<String>) context.getVariable(\"tips\");\r\n    if (tips == null) {\r\n      tips = new ArrayList<String>(3);\r\n      context.setVariable(\"tips\", tips);\r\n    }\r\n    tips.add(iMessage);\r\n  }", "language": "java", "code": "protected void reportTip(final String iMessage) {\r\n    Orient.instance().getProfiler().reportTip(iMessage);\r\n    List<String> tips = (List<String>) context.getVariable(\"tips\");\r\n    if (tips == null) {\r\n      tips = new ArrayList<String>(3);\r\n      context.setVariable(\"tips\", tips);\r\n    }\r\n    tips.add(iMessage);\r\n  }", "code_tokens": ["protected", "void", "reportTip", "(", "final", "String", "iMessage", ")", "{", "Orient", ".", "instance", "(", ")", ".", "getProfiler", "(", ")", ".", "reportTip", "(", "iMessage", ")", ";", "List", "<", "String", ">", "tips", "=", "(", "List", "<", "String", ">", ")", "context", ".", "getVariable", "(", "\"tips\"", ")", ";", "if", "(", "tips", "==", "null", ")", "{", "tips", "=", "new", "ArrayList", "<", "String", ">", "(", "3", ")", ";", "context", ".", "setVariable", "(", "\"tips\"", ",", "tips", ")", ";", "}", "tips", ".", "add", "(", "iMessage", ")", ";", "}"], "docstring": "Report the tip to the profiler and collect it in context to be reported by tools like Studio", "docstring_tokens": ["Report", "the", "tip", "to", "the", "profiler", "and", "collect", "it", "in", "context", "to", "be", "reported", "by", "tools", "like", "Studio"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java#L853-L861", "partition": "test", "index": 3312, "time": "2015-01-15 10:21:00"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/core/entity/OEntityManager.java", "func_name": "OEntityManager.registerEntityClasses", "original_string": "public synchronized void registerEntityClasses(Class<?> aClass, boolean recursive) {\r\n    if (recursive) {\r\n      classHandler.registerEntityClass(aClass);\r\n      Field[] declaredFields = aClass.getDeclaredFields();\r\n      for (Field declaredField : declaredFields) {\r\n        Class<?> declaredFieldType = declaredField.getType();\r\n        if (!classHandler.containsEntityClass(declaredFieldType)) {\r\n          registerEntityClasses(declaredFieldType, recursive);\r\n        }\r\n      }\r\n    } else {\r\n      classHandler.registerEntityClass(aClass);\r\n    }\r\n  }", "language": "java", "code": "public synchronized void registerEntityClasses(Class<?> aClass, boolean recursive) {\r\n    if (recursive) {\r\n      classHandler.registerEntityClass(aClass);\r\n      Field[] declaredFields = aClass.getDeclaredFields();\r\n      for (Field declaredField : declaredFields) {\r\n        Class<?> declaredFieldType = declaredField.getType();\r\n        if (!classHandler.containsEntityClass(declaredFieldType)) {\r\n          registerEntityClasses(declaredFieldType, recursive);\r\n        }\r\n      }\r\n    } else {\r\n      classHandler.registerEntityClass(aClass);\r\n    }\r\n  }", "code_tokens": ["public", "synchronized", "void", "registerEntityClasses", "(", "Class", "<", "?", ">", "aClass", ",", "boolean", "recursive", ")", "{", "if", "(", "recursive", ")", "{", "classHandler", ".", "registerEntityClass", "(", "aClass", ")", ";", "Field", "[", "]", "declaredFields", "=", "aClass", ".", "getDeclaredFields", "(", ")", ";", "for", "(", "Field", "declaredField", ":", "declaredFields", ")", "{", "Class", "<", "?", ">", "declaredFieldType", "=", "declaredField", ".", "getType", "(", ")", ";", "if", "(", "!", "classHandler", ".", "containsEntityClass", "(", "declaredFieldType", ")", ")", "{", "registerEntityClasses", "(", "declaredFieldType", ",", "recursive", ")", ";", "}", "}", "}", "else", "{", "classHandler", ".", "registerEntityClass", "(", "aClass", ")", ";", "}", "}"], "docstring": "Scans all classes accessible from the context class loader which belong to the given class and all it's attributes - classes.\n\n@param aClass\nThe class to start from\n@param recursive\nBeginning from the class, it will register all classes that are direct or indirect a attribute class", "docstring_tokens": ["Scans", "all", "classes", "accessible", "from", "the", "context", "class", "loader", "which", "belong", "to", "the", "given", "class", "and", "all", "it", "s", "attributes", "-", "classes", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/core/entity/OEntityManager.java#L221-L234", "partition": "test", "index": 3169, "time": "2015-01-16 12:54:03"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java", "func_name": "OCommandExecutorSQLSelect.getTemporaryRIDCounter", "original_string": "public int getTemporaryRIDCounter(final OCommandContext iContext) {\r\n    final OTemporaryRidGenerator parentQuery = (OTemporaryRidGenerator) iContext.getVariable(\"parentQuery\");\r\n    return parentQuery != null && parentQuery != this ?\r\n        parentQuery.getTemporaryRIDCounter(iContext) :\r\n        serialTempRID.getAndIncrement();\r\n  }", "language": "java", "code": "public int getTemporaryRIDCounter(final OCommandContext iContext) {\r\n    final OTemporaryRidGenerator parentQuery = (OTemporaryRidGenerator) iContext.getVariable(\"parentQuery\");\r\n    return parentQuery != null && parentQuery != this ?\r\n        parentQuery.getTemporaryRIDCounter(iContext) :\r\n        serialTempRID.getAndIncrement();\r\n  }", "code_tokens": ["public", "int", "getTemporaryRIDCounter", "(", "final", "OCommandContext", "iContext", ")", "{", "final", "OTemporaryRidGenerator", "parentQuery", "=", "(", "OTemporaryRidGenerator", ")", "iContext", ".", "getVariable", "(", "\"parentQuery\"", ")", ";", "return", "parentQuery", "!=", "null", "&&", "parentQuery", "!=", "this", "?", "parentQuery", ".", "getTemporaryRIDCounter", "(", "iContext", ")", ":", "serialTempRID", ".", "getAndIncrement", "(", ")", ";", "}"], "docstring": "Returns the temporary RID counter assuring it's unique per query tree.\n\n@return Serial as integer", "docstring_tokens": ["Returns", "the", "temporary", "RID", "counter", "assuring", "it", "s", "unique", "per", "query", "tree", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLSelect.java#L682-L687", "partition": "test", "index": 3311, "time": "2015-01-21 19:24:09"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/JavaCharStream.java", "func_name": "JavaCharStream.adjustBeginLineColumn", "original_string": "public void adjustBeginLineColumn(int newLine, int newCol)\n  {\n    int start = tokenBegin;\n    int len;\n\n    if (bufpos >= tokenBegin)\n    {\n      len = bufpos - tokenBegin + inBuf + 1;\n    }\n    else\n    {\n      len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n    }\n\n    int i = 0, j = 0, k = 0;\n    int nextColDiff = 0, columnDiff = 0;\n\n    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n    {\n      bufline[j] = newLine;\n      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n      bufcolumn[j] = newCol + columnDiff;\n      columnDiff = nextColDiff;\n      i++;\n    }\n\n    if (i < len)\n    {\n      bufline[j] = newLine++;\n      bufcolumn[j] = newCol + columnDiff;\n\n      while (i++ < len)\n      {\n        if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n          bufline[j] = newLine++;\n        else\n          bufline[j] = newLine;\n      }\n    }\n\n    line = bufline[j];\n    column = bufcolumn[j];\n  }", "language": "java", "code": "public void adjustBeginLineColumn(int newLine, int newCol)\n  {\n    int start = tokenBegin;\n    int len;\n\n    if (bufpos >= tokenBegin)\n    {\n      len = bufpos - tokenBegin + inBuf + 1;\n    }\n    else\n    {\n      len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n    }\n\n    int i = 0, j = 0, k = 0;\n    int nextColDiff = 0, columnDiff = 0;\n\n    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n    {\n      bufline[j] = newLine;\n      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n      bufcolumn[j] = newCol + columnDiff;\n      columnDiff = nextColDiff;\n      i++;\n    }\n\n    if (i < len)\n    {\n      bufline[j] = newLine++;\n      bufcolumn[j] = newCol + columnDiff;\n\n      while (i++ < len)\n      {\n        if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n          bufline[j] = newLine++;\n        else\n          bufline[j] = newLine;\n      }\n    }\n\n    line = bufline[j];\n    column = bufcolumn[j];\n  }", "code_tokens": ["public", "void", "adjustBeginLineColumn", "(", "int", "newLine", ",", "int", "newCol", ")", "{", "int", "start", "=", "tokenBegin", ";", "int", "len", ";", "if", "(", "bufpos", ">=", "tokenBegin", ")", "{", "len", "=", "bufpos", "-", "tokenBegin", "+", "inBuf", "+", "1", ";", "}", "else", "{", "len", "=", "bufsize", "-", "tokenBegin", "+", "bufpos", "+", "1", "+", "inBuf", ";", "}", "int", "i", "=", "0", ",", "j", "=", "0", ",", "k", "=", "0", ";", "int", "nextColDiff", "=", "0", ",", "columnDiff", "=", "0", ";", "while", "(", "i", "<", "len", "&&", "bufline", "[", "j", "=", "start", "%", "bufsize", "]", "==", "bufline", "[", "k", "=", "++", "start", "%", "bufsize", "]", ")", "{", "bufline", "[", "j", "]", "=", "newLine", ";", "nextColDiff", "=", "columnDiff", "+", "bufcolumn", "[", "k", "]", "-", "bufcolumn", "[", "j", "]", ";", "bufcolumn", "[", "j", "]", "=", "newCol", "+", "columnDiff", ";", "columnDiff", "=", "nextColDiff", ";", "i", "++", ";", "}", "if", "(", "i", "<", "len", ")", "{", "bufline", "[", "j", "]", "=", "newLine", "++", ";", "bufcolumn", "[", "j", "]", "=", "newCol", "+", "columnDiff", ";", "while", "(", "i", "++", "<", "len", ")", "{", "if", "(", "bufline", "[", "j", "=", "start", "%", "bufsize", "]", "!=", "bufline", "[", "++", "start", "%", "bufsize", "]", ")", "bufline", "[", "j", "]", "=", "newLine", "++", ";", "else", "bufline", "[", "j", "]", "=", "newLine", ";", "}", "}", "line", "=", "bufline", "[", "j", "]", ";", "column", "=", "bufcolumn", "[", "j", "]", ";", "}"], "docstring": "Method to adjust line and column numbers for the start of a token.", "docstring_tokens": ["Method", "to", "adjust", "line", "and", "column", "numbers", "for", "the", "start", "of", "a", "token", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/JavaCharStream.java#L572-L614", "partition": "test", "index": 3238, "time": "2015-01-26 12:40:12"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/script/OCommandExecutorScript.java", "func_name": "OCommandExecutorScript.waitForNextRetry", "original_string": "protected void waitForNextRetry() {\r\n    try {\r\n      Thread.sleep(new Random().nextInt(MAX_DELAY - 1) + 1);\r\n    } catch (InterruptedException e) {\r\n      OLogManager.instance().error(this, \"Wait was interrupted\", e);\r\n    }\r\n  }", "language": "java", "code": "protected void waitForNextRetry() {\r\n    try {\r\n      Thread.sleep(new Random().nextInt(MAX_DELAY - 1) + 1);\r\n    } catch (InterruptedException e) {\r\n      OLogManager.instance().error(this, \"Wait was interrupted\", e);\r\n    }\r\n  }", "code_tokens": ["protected", "void", "waitForNextRetry", "(", ")", "{", "try", "{", "Thread", ".", "sleep", "(", "new", "Random", "(", ")", ".", "nextInt", "(", "MAX_DELAY", "-", "1", ")", "+", "1", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Wait was interrupted\"", ",", "e", ")", ";", "}", "}"], "docstring": "Wait before to retry", "docstring_tokens": ["Wait", "before", "to", "retry"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/script/OCommandExecutorScript.java#L507-L513", "partition": "test", "index": 3218, "time": "2015-05-28 12:37:55"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OMatchStatement.java", "func_name": "OMatchStatement.parse", "original_string": "@Override\n  public <RET extends OCommandExecutor> RET parse(OCommandRequest iRequest) {\n    final OCommandRequestText textRequest = (OCommandRequestText) iRequest;\n    if (iRequest instanceof OSQLSynchQuery) {\n      request = (OSQLSynchQuery<ODocument>) iRequest;\n    } else if (iRequest instanceof OSQLAsynchQuery) {\n      request = (OSQLAsynchQuery<ODocument>) iRequest;\n    } else {\n      // BUILD A QUERY OBJECT FROM THE COMMAND REQUEST\n      request = new OSQLSynchQuery<ODocument>(textRequest.getText());\n      if (textRequest.getResultListener() != null) {\n        request.setResultListener(textRequest.getResultListener());\n      }\n    }\n    String queryText = textRequest.getText();\n\n    // please, do not look at this... refactor this ASAP with new executor structure\n    final InputStream is = new ByteArrayInputStream(queryText.getBytes());\n    OrientSql osql = null;\n    try {\n      ODatabaseDocumentInternal db = getDatabase();\n      if (db == null) {\n        osql = new OrientSql(is);\n      } else {\n        osql = new OrientSql(is, db.getStorage().getConfiguration().getCharset());\n      }\n    } catch (UnsupportedEncodingException e) {\n      OLogManager.instance().warn(this,\n          \"Invalid charset for database \" + getDatabase() + \" \" + getDatabase().getStorage().getConfiguration().getCharset());\n      osql = new OrientSql(is);\n    }\n\n    try {\n      OMatchStatement result = (OMatchStatement) osql.parse();\n      this.matchExpressions = result.matchExpressions;\n      this.notMatchExpressions = result.notMatchExpressions;\n      this.returnItems = result.returnItems;\n      this.returnAliases = result.returnAliases;\n      this.limit = result.limit;\n    } catch (ParseException e) {\n      OCommandSQLParsingException ex = new OCommandSQLParsingException(e, queryText);\n      OErrorCode.QUERY_PARSE_ERROR.throwException(ex.getMessage(), ex);\n    }\n\n    buildPatterns();\n    pattern.validate();\n    return (RET) this;\n  }", "language": "java", "code": "@Override\n  public <RET extends OCommandExecutor> RET parse(OCommandRequest iRequest) {\n    final OCommandRequestText textRequest = (OCommandRequestText) iRequest;\n    if (iRequest instanceof OSQLSynchQuery) {\n      request = (OSQLSynchQuery<ODocument>) iRequest;\n    } else if (iRequest instanceof OSQLAsynchQuery) {\n      request = (OSQLAsynchQuery<ODocument>) iRequest;\n    } else {\n      // BUILD A QUERY OBJECT FROM THE COMMAND REQUEST\n      request = new OSQLSynchQuery<ODocument>(textRequest.getText());\n      if (textRequest.getResultListener() != null) {\n        request.setResultListener(textRequest.getResultListener());\n      }\n    }\n    String queryText = textRequest.getText();\n\n    // please, do not look at this... refactor this ASAP with new executor structure\n    final InputStream is = new ByteArrayInputStream(queryText.getBytes());\n    OrientSql osql = null;\n    try {\n      ODatabaseDocumentInternal db = getDatabase();\n      if (db == null) {\n        osql = new OrientSql(is);\n      } else {\n        osql = new OrientSql(is, db.getStorage().getConfiguration().getCharset());\n      }\n    } catch (UnsupportedEncodingException e) {\n      OLogManager.instance().warn(this,\n          \"Invalid charset for database \" + getDatabase() + \" \" + getDatabase().getStorage().getConfiguration().getCharset());\n      osql = new OrientSql(is);\n    }\n\n    try {\n      OMatchStatement result = (OMatchStatement) osql.parse();\n      this.matchExpressions = result.matchExpressions;\n      this.notMatchExpressions = result.notMatchExpressions;\n      this.returnItems = result.returnItems;\n      this.returnAliases = result.returnAliases;\n      this.limit = result.limit;\n    } catch (ParseException e) {\n      OCommandSQLParsingException ex = new OCommandSQLParsingException(e, queryText);\n      OErrorCode.QUERY_PARSE_ERROR.throwException(ex.getMessage(), ex);\n    }\n\n    buildPatterns();\n    pattern.validate();\n    return (RET) this;\n  }", "code_tokens": ["@", "Override", "public", "<", "RET", "extends", "OCommandExecutor", ">", "RET", "parse", "(", "OCommandRequest", "iRequest", ")", "{", "final", "OCommandRequestText", "textRequest", "=", "(", "OCommandRequestText", ")", "iRequest", ";", "if", "(", "iRequest", "instanceof", "OSQLSynchQuery", ")", "{", "request", "=", "(", "OSQLSynchQuery", "<", "ODocument", ">", ")", "iRequest", ";", "}", "else", "if", "(", "iRequest", "instanceof", "OSQLAsynchQuery", ")", "{", "request", "=", "(", "OSQLAsynchQuery", "<", "ODocument", ">", ")", "iRequest", ";", "}", "else", "{", "// BUILD A QUERY OBJECT FROM THE COMMAND REQUEST", "request", "=", "new", "OSQLSynchQuery", "<", "ODocument", ">", "(", "textRequest", ".", "getText", "(", ")", ")", ";", "if", "(", "textRequest", ".", "getResultListener", "(", ")", "!=", "null", ")", "{", "request", ".", "setResultListener", "(", "textRequest", ".", "getResultListener", "(", ")", ")", ";", "}", "}", "String", "queryText", "=", "textRequest", ".", "getText", "(", ")", ";", "// please, do not look at this... refactor this ASAP with new executor structure", "final", "InputStream", "is", "=", "new", "ByteArrayInputStream", "(", "queryText", ".", "getBytes", "(", ")", ")", ";", "OrientSql", "osql", "=", "null", ";", "try", "{", "ODatabaseDocumentInternal", "db", "=", "getDatabase", "(", ")", ";", "if", "(", "db", "==", "null", ")", "{", "osql", "=", "new", "OrientSql", "(", "is", ")", ";", "}", "else", "{", "osql", "=", "new", "OrientSql", "(", "is", ",", "db", ".", "getStorage", "(", ")", ".", "getConfiguration", "(", ")", ".", "getCharset", "(", ")", ")", ";", "}", "}", "catch", "(", "UnsupportedEncodingException", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "this", ",", "\"Invalid charset for database \"", "+", "getDatabase", "(", ")", "+", "\" \"", "+", "getDatabase", "(", ")", ".", "getStorage", "(", ")", ".", "getConfiguration", "(", ")", ".", "getCharset", "(", ")", ")", ";", "osql", "=", "new", "OrientSql", "(", "is", ")", ";", "}", "try", "{", "OMatchStatement", "result", "=", "(", "OMatchStatement", ")", "osql", ".", "parse", "(", ")", ";", "this", ".", "matchExpressions", "=", "result", ".", "matchExpressions", ";", "this", ".", "notMatchExpressions", "=", "result", ".", "notMatchExpressions", ";", "this", ".", "returnItems", "=", "result", ".", "returnItems", ";", "this", ".", "returnAliases", "=", "result", ".", "returnAliases", ";", "this", ".", "limit", "=", "result", ".", "limit", ";", "}", "catch", "(", "ParseException", "e", ")", "{", "OCommandSQLParsingException", "ex", "=", "new", "OCommandSQLParsingException", "(", "e", ",", "queryText", ")", ";", "OErrorCode", ".", "QUERY_PARSE_ERROR", ".", "throwException", "(", "ex", ".", "getMessage", "(", ")", ",", "ex", ")", ";", "}", "buildPatterns", "(", ")", ";", "pattern", ".", "validate", "(", ")", ";", "return", "(", "RET", ")", "this", ";", "}"], "docstring": "this method parses the statement\n\n@param iRequest Command request implementation.\n@param <RET>\n\n@return", "docstring_tokens": ["this", "method", "parses", "the", "statement"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OMatchStatement.java#L204-L251", "partition": "test", "index": 2988, "time": "2015-06-04 18:23:22"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OMatchStatement.java", "func_name": "OMatchStatement.execute", "original_string": "@Override\n  public Object execute(Map<Object, Object> iArgs) {\n    this.context.setInputParameters(iArgs);\n    return execute(this.request, this.context, this.progressListener);\n  }", "language": "java", "code": "@Override\n  public Object execute(Map<Object, Object> iArgs) {\n    this.context.setInputParameters(iArgs);\n    return execute(this.request, this.context, this.progressListener);\n  }", "code_tokens": ["@", "Override", "public", "Object", "execute", "(", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "this", ".", "context", ".", "setInputParameters", "(", "iArgs", ")", ";", "return", "execute", "(", "this", ".", "request", ",", "this", ".", "context", ",", "this", ".", "progressListener", ")", ";", "}"], "docstring": "this method works statefully, using request and context variables from current Match statement. This method will be deprecated\nin next releases\n\n@param iArgs Optional variable arguments to pass to the command.\n\n@return", "docstring_tokens": ["this", "method", "works", "statefully", "using", "request", "and", "context", "variables", "from", "current", "Match", "statement", ".", "This", "method", "will", "be", "deprecated", "in", "next", "releases"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OMatchStatement.java#L324-L328", "partition": "test", "index": 2989, "time": "2015-06-18 07:41:54"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/sql/OCommandExecutorSQLHASyncDatabase.java", "func_name": "OCommandExecutorSQLHASyncDatabase.execute", "original_string": "public Object execute(final Map<Object, Object> iArgs) {\n    final ODatabaseDocumentInternal database = getDatabase();\n    database.checkSecurity(ORule.ResourceGeneric.DATABASE, \"sync\", ORole.PERMISSION_UPDATE);\n\n    final OStorage stg = database.getStorage();\n    if (!(stg instanceof ODistributedStorage))\n      throw new ODistributedException(\"SYNC DATABASE command cannot be executed against a non distributed server\");\n\n    final ODistributedStorage dStg = (ODistributedStorage) stg;\n\n    final OHazelcastPlugin dManager = (OHazelcastPlugin) dStg.getDistributedManager();\n    if (dManager == null || !dManager.isEnabled())\n      throw new OCommandExecutionException(\"OrientDB is not started in distributed mode\");\n\n    final String databaseName = database.getName();\n\n    return dManager.installDatabase(true, databaseName, parsedStatement.isForce(), !parsedStatement.isFull());\n  }", "language": "java", "code": "public Object execute(final Map<Object, Object> iArgs) {\n    final ODatabaseDocumentInternal database = getDatabase();\n    database.checkSecurity(ORule.ResourceGeneric.DATABASE, \"sync\", ORole.PERMISSION_UPDATE);\n\n    final OStorage stg = database.getStorage();\n    if (!(stg instanceof ODistributedStorage))\n      throw new ODistributedException(\"SYNC DATABASE command cannot be executed against a non distributed server\");\n\n    final ODistributedStorage dStg = (ODistributedStorage) stg;\n\n    final OHazelcastPlugin dManager = (OHazelcastPlugin) dStg.getDistributedManager();\n    if (dManager == null || !dManager.isEnabled())\n      throw new OCommandExecutionException(\"OrientDB is not started in distributed mode\");\n\n    final String databaseName = database.getName();\n\n    return dManager.installDatabase(true, databaseName, parsedStatement.isForce(), !parsedStatement.isFull());\n  }", "code_tokens": ["public", "Object", "execute", "(", "final", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "final", "ODatabaseDocumentInternal", "database", "=", "getDatabase", "(", ")", ";", "database", ".", "checkSecurity", "(", "ORule", ".", "ResourceGeneric", ".", "DATABASE", ",", "\"sync\"", ",", "ORole", ".", "PERMISSION_UPDATE", ")", ";", "final", "OStorage", "stg", "=", "database", ".", "getStorage", "(", ")", ";", "if", "(", "!", "(", "stg", "instanceof", "ODistributedStorage", ")", ")", "throw", "new", "ODistributedException", "(", "\"SYNC DATABASE command cannot be executed against a non distributed server\"", ")", ";", "final", "ODistributedStorage", "dStg", "=", "(", "ODistributedStorage", ")", "stg", ";", "final", "OHazelcastPlugin", "dManager", "=", "(", "OHazelcastPlugin", ")", "dStg", ".", "getDistributedManager", "(", ")", ";", "if", "(", "dManager", "==", "null", "||", "!", "dManager", ".", "isEnabled", "(", ")", ")", "throw", "new", "OCommandExecutionException", "(", "\"OrientDB is not started in distributed mode\"", ")", ";", "final", "String", "databaseName", "=", "database", ".", "getName", "(", ")", ";", "return", "dManager", ".", "installDatabase", "(", "true", ",", "databaseName", ",", "parsedStatement", ".", "isForce", "(", ")", ",", "!", "parsedStatement", ".", "isFull", "(", ")", ")", ";", "}"], "docstring": "Execute the SYNC DATABASE.", "docstring_tokens": ["Execute", "the", "SYNC", "DATABASE", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/sql/OCommandExecutorSQLHASyncDatabase.java#L69-L86", "partition": "test", "index": 3325, "time": "2015-06-21 13:23:23"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/sql/OCommandExecutorSQLHASyncCluster.java", "func_name": "OCommandExecutorSQLHASyncCluster.execute", "original_string": "public Object execute(final Map<Object, Object> iArgs) {\n    final ODatabaseDocumentInternal database = getDatabase();\n    database.checkSecurity(ORule.ResourceGeneric.CLUSTER, \"sync\", ORole.PERMISSION_UPDATE);\n\n    if (!(database instanceof ODatabaseDocumentDistributed)) {\n      throw new OCommandExecutionException(\"OrientDB is not started in distributed mode\");\n    }\n\n    final OHazelcastPlugin dManager = (OHazelcastPlugin) ((ODatabaseDocumentDistributed) database).getDistributedManager();\n    if (dManager == null || !dManager.isEnabled())\n      throw new OCommandExecutionException(\"OrientDB is not started in distributed mode\");\n\n    final String databaseName = database.getName();\n\n    try {\n      if (this.parsedStatement.modeFull) {\n        return replaceCluster(dManager, database, dManager.getServerInstance(), databaseName, this.parsedStatement.clusterName.getStringValue());\n      }\n      // else {\n      // int merged = 0;\n      // return String.format(\"Merged %d records\", merged);\n      // }\n    } catch (Exception e) {\n      throw OException.wrapException(new OCommandExecutionException(\"Cannot execute synchronization of cluster\"), e);\n    }\n\n    return \"Mode not supported\";\n  }", "language": "java", "code": "public Object execute(final Map<Object, Object> iArgs) {\n    final ODatabaseDocumentInternal database = getDatabase();\n    database.checkSecurity(ORule.ResourceGeneric.CLUSTER, \"sync\", ORole.PERMISSION_UPDATE);\n\n    if (!(database instanceof ODatabaseDocumentDistributed)) {\n      throw new OCommandExecutionException(\"OrientDB is not started in distributed mode\");\n    }\n\n    final OHazelcastPlugin dManager = (OHazelcastPlugin) ((ODatabaseDocumentDistributed) database).getDistributedManager();\n    if (dManager == null || !dManager.isEnabled())\n      throw new OCommandExecutionException(\"OrientDB is not started in distributed mode\");\n\n    final String databaseName = database.getName();\n\n    try {\n      if (this.parsedStatement.modeFull) {\n        return replaceCluster(dManager, database, dManager.getServerInstance(), databaseName, this.parsedStatement.clusterName.getStringValue());\n      }\n      // else {\n      // int merged = 0;\n      // return String.format(\"Merged %d records\", merged);\n      // }\n    } catch (Exception e) {\n      throw OException.wrapException(new OCommandExecutionException(\"Cannot execute synchronization of cluster\"), e);\n    }\n\n    return \"Mode not supported\";\n  }", "code_tokens": ["public", "Object", "execute", "(", "final", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "final", "ODatabaseDocumentInternal", "database", "=", "getDatabase", "(", ")", ";", "database", ".", "checkSecurity", "(", "ORule", ".", "ResourceGeneric", ".", "CLUSTER", ",", "\"sync\"", ",", "ORole", ".", "PERMISSION_UPDATE", ")", ";", "if", "(", "!", "(", "database", "instanceof", "ODatabaseDocumentDistributed", ")", ")", "{", "throw", "new", "OCommandExecutionException", "(", "\"OrientDB is not started in distributed mode\"", ")", ";", "}", "final", "OHazelcastPlugin", "dManager", "=", "(", "OHazelcastPlugin", ")", "(", "(", "ODatabaseDocumentDistributed", ")", "database", ")", ".", "getDistributedManager", "(", ")", ";", "if", "(", "dManager", "==", "null", "||", "!", "dManager", ".", "isEnabled", "(", ")", ")", "throw", "new", "OCommandExecutionException", "(", "\"OrientDB is not started in distributed mode\"", ")", ";", "final", "String", "databaseName", "=", "database", ".", "getName", "(", ")", ";", "try", "{", "if", "(", "this", ".", "parsedStatement", ".", "modeFull", ")", "{", "return", "replaceCluster", "(", "dManager", ",", "database", ",", "dManager", ".", "getServerInstance", "(", ")", ",", "databaseName", ",", "this", ".", "parsedStatement", ".", "clusterName", ".", "getStringValue", "(", ")", ")", ";", "}", "// else {", "// int merged = 0;", "// return String.format(\"Merged %d records\", merged);", "// }", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OCommandExecutionException", "(", "\"Cannot execute synchronization of cluster\"", ")", ",", "e", ")", ";", "}", "return", "\"Mode not supported\"", ";", "}"], "docstring": "Execute the SYNC CLUSTER.", "docstring_tokens": ["Execute", "the", "SYNC", "CLUSTER", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/sql/OCommandExecutorSQLHASyncCluster.java#L92-L119", "partition": "test", "index": 3174, "time": "2015-06-21 13:23:23"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getClustersOnServer", "original_string": "public Set<String> getClustersOnServer(final String iNodeName) {\n    final Set<String> clusters = new HashSet<String>();\n    for (String cl : getClusterNames()) {\n      final List<String> servers = getServers(cl, null);\n      if (servers.contains(iNodeName))\n        clusters.add(cl);\n    }\n    return clusters;\n  }", "language": "java", "code": "public Set<String> getClustersOnServer(final String iNodeName) {\n    final Set<String> clusters = new HashSet<String>();\n    for (String cl : getClusterNames()) {\n      final List<String> servers = getServers(cl, null);\n      if (servers.contains(iNodeName))\n        clusters.add(cl);\n    }\n    return clusters;\n  }", "code_tokens": ["public", "Set", "<", "String", ">", "getClustersOnServer", "(", "final", "String", "iNodeName", ")", "{", "final", "Set", "<", "String", ">", "clusters", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "for", "(", "String", "cl", ":", "getClusterNames", "(", ")", ")", "{", "final", "List", "<", "String", ">", "servers", "=", "getServers", "(", "cl", ",", "null", ")", ";", "if", "(", "servers", ".", "contains", "(", "iNodeName", ")", ")", "clusters", ".", "add", "(", "cl", ")", ";", "}", "return", "clusters", ";", "}"], "docstring": "Returns the set of clusters managed by a server.\n\n@param iNodeName Server name", "docstring_tokens": ["Returns", "the", "set", "of", "clusters", "managed", "by", "a", "server", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L419-L427", "partition": "test", "index": 3094, "time": "2015-06-22 01:50:36"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpNetworkCommandManager.java", "func_name": "OHttpNetworkCommandManager.registerCommand", "original_string": "public void registerCommand(final OServerCommand iServerCommandInstance) {\r\n    for (String name : iServerCommandInstance.getNames())\r\n      if (OStringSerializerHelper.contains(name, '{')) {\r\n        restCommands.put(name, iServerCommandInstance);\r\n      } else if (OStringSerializerHelper.contains(name, '*'))\r\n        wildcardCommands.put(name, iServerCommandInstance);\r\n      else\r\n        exactCommands.put(name, iServerCommandInstance);\r\n    iServerCommandInstance.configure(server);\r\n  }", "language": "java", "code": "public void registerCommand(final OServerCommand iServerCommandInstance) {\r\n    for (String name : iServerCommandInstance.getNames())\r\n      if (OStringSerializerHelper.contains(name, '{')) {\r\n        restCommands.put(name, iServerCommandInstance);\r\n      } else if (OStringSerializerHelper.contains(name, '*'))\r\n        wildcardCommands.put(name, iServerCommandInstance);\r\n      else\r\n        exactCommands.put(name, iServerCommandInstance);\r\n    iServerCommandInstance.configure(server);\r\n  }", "code_tokens": ["public", "void", "registerCommand", "(", "final", "OServerCommand", "iServerCommandInstance", ")", "{", "for", "(", "String", "name", ":", "iServerCommandInstance", ".", "getNames", "(", ")", ")", "if", "(", "OStringSerializerHelper", ".", "contains", "(", "name", ",", "'", "'", ")", ")", "{", "restCommands", ".", "put", "(", "name", ",", "iServerCommandInstance", ")", ";", "}", "else", "if", "(", "OStringSerializerHelper", ".", "contains", "(", "name", ",", "'", "'", ")", ")", "wildcardCommands", ".", "put", "(", "name", ",", "iServerCommandInstance", ")", ";", "else", "exactCommands", ".", "put", "(", "name", ",", "iServerCommandInstance", ")", ";", "iServerCommandInstance", ".", "configure", "(", "server", ")", ";", "}"], "docstring": "Register all the names for the same instance.\n\n@param iServerCommandInstance", "docstring_tokens": ["Register", "all", "the", "names", "for", "the", "same", "instance", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpNetworkCommandManager.java#L87-L96", "partition": "test", "index": 3289, "time": "2015-07-17 10:44:24"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphMLReader.java", "func_name": "OGraphMLReader.defineEdgeAttributeStrategy", "original_string": "public OGraphMLReader defineEdgeAttributeStrategy(final String iAttributeName, final OGraphMLImportStrategy iStrategy) {\n    edgePropsStrategy.put(iAttributeName, iStrategy);\n    return this;\n  }", "language": "java", "code": "public OGraphMLReader defineEdgeAttributeStrategy(final String iAttributeName, final OGraphMLImportStrategy iStrategy) {\n    edgePropsStrategy.put(iAttributeName, iStrategy);\n    return this;\n  }", "code_tokens": ["public", "OGraphMLReader", "defineEdgeAttributeStrategy", "(", "final", "String", "iAttributeName", ",", "final", "OGraphMLImportStrategy", "iStrategy", ")", "{", "edgePropsStrategy", ".", "put", "(", "iAttributeName", ",", "iStrategy", ")", ";", "return", "this", ";", "}"], "docstring": "Define custom strategy to use for edge attribute.\n\n@param iAttributeName\nattribute name\n@param iStrategy\nstrategy implementation", "docstring_tokens": ["Define", "custom", "strategy", "to", "use", "for", "edge", "attribute", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphMLReader.java#L96-L99", "partition": "test", "index": 3072, "time": "2015-07-23 17:35:50"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphMLReader.java", "func_name": "OGraphMLReader.defineVertexAttributeStrategy", "original_string": "public OGraphMLReader defineVertexAttributeStrategy(final String iAttributeName, final OGraphMLImportStrategy iStrategy) {\n    vertexPropsStrategy.put(iAttributeName, iStrategy);\n    return this;\n  }", "language": "java", "code": "public OGraphMLReader defineVertexAttributeStrategy(final String iAttributeName, final OGraphMLImportStrategy iStrategy) {\n    vertexPropsStrategy.put(iAttributeName, iStrategy);\n    return this;\n  }", "code_tokens": ["public", "OGraphMLReader", "defineVertexAttributeStrategy", "(", "final", "String", "iAttributeName", ",", "final", "OGraphMLImportStrategy", "iStrategy", ")", "{", "vertexPropsStrategy", ".", "put", "(", "iAttributeName", ",", "iStrategy", ")", ";", "return", "this", ";", "}"], "docstring": "Define custom strategy to use for vertex attribute.\n\n@param iAttributeName\nattribute name\n@param iStrategy\nstrategy implementation", "docstring_tokens": ["Define", "custom", "strategy", "to", "use", "for", "vertex", "attribute", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphMLReader.java#L83-L86", "partition": "test", "index": 3071, "time": "2015-07-23 17:35:50"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OWhereClause.java", "func_name": "OWhereClause.estimate", "original_string": "public long estimate(OClass oClass, long threshold, OCommandContext ctx) {\n    long count = oClass.count();\n    if (count > 1) {\n      count = count / 2;\n    }\n    if (count < threshold) {\n      return count;\n    }\n\n    long indexesCount = 0l;\n    List<OAndBlock> flattenedConditions = flatten();\n    Set<OIndex<?>> indexes = oClass.getIndexes();\n    for (OAndBlock condition : flattenedConditions) {\n\n      List<OBinaryCondition> indexedFunctConditions = condition\n          .getIndexedFunctionConditions(oClass, (ODatabaseDocumentInternal) ctx.getDatabase());\n\n      long conditionEstimation = Long.MAX_VALUE;\n\n      if (indexedFunctConditions != null) {\n        for (OBinaryCondition cond : indexedFunctConditions) {\n          OFromClause from = new OFromClause(-1);\n          OFromItem item = new OFromItem(-1);\n          from.item = item;\n          from.item.setIdentifier(new OIdentifier(oClass.getName()));\n          long newCount = cond.estimateIndexed(from, ctx);\n          if (newCount < conditionEstimation) {\n            conditionEstimation = newCount;\n          }\n        }\n      } else {\n        Map<String, Object> conditions = getEqualityOperations(condition, ctx);\n\n        for (OIndex index : indexes) {\n          if (index.getType().equals(OClass.INDEX_TYPE.FULLTEXT.name()) || index.getType()\n              .equals(OClass.INDEX_TYPE.FULLTEXT_HASH_INDEX.name())) {\n            continue;\n          }\n          List<String> indexedFields = index.getDefinition().getFields();\n          int nMatchingKeys = 0;\n          for (String indexedField : indexedFields) {\n            if (conditions.containsKey(indexedField)) {\n              nMatchingKeys++;\n            } else {\n              break;\n            }\n          }\n          if (nMatchingKeys > 0) {\n            long newCount = estimateFromIndex(index, conditions, nMatchingKeys);\n            if (newCount < conditionEstimation) {\n              conditionEstimation = newCount;\n            }\n          }\n        }\n      }\n      if (conditionEstimation > count) {\n        return count;\n      }\n      indexesCount += conditionEstimation;\n    }\n    return Math.min(indexesCount, count);\n  }", "language": "java", "code": "public long estimate(OClass oClass, long threshold, OCommandContext ctx) {\n    long count = oClass.count();\n    if (count > 1) {\n      count = count / 2;\n    }\n    if (count < threshold) {\n      return count;\n    }\n\n    long indexesCount = 0l;\n    List<OAndBlock> flattenedConditions = flatten();\n    Set<OIndex<?>> indexes = oClass.getIndexes();\n    for (OAndBlock condition : flattenedConditions) {\n\n      List<OBinaryCondition> indexedFunctConditions = condition\n          .getIndexedFunctionConditions(oClass, (ODatabaseDocumentInternal) ctx.getDatabase());\n\n      long conditionEstimation = Long.MAX_VALUE;\n\n      if (indexedFunctConditions != null) {\n        for (OBinaryCondition cond : indexedFunctConditions) {\n          OFromClause from = new OFromClause(-1);\n          OFromItem item = new OFromItem(-1);\n          from.item = item;\n          from.item.setIdentifier(new OIdentifier(oClass.getName()));\n          long newCount = cond.estimateIndexed(from, ctx);\n          if (newCount < conditionEstimation) {\n            conditionEstimation = newCount;\n          }\n        }\n      } else {\n        Map<String, Object> conditions = getEqualityOperations(condition, ctx);\n\n        for (OIndex index : indexes) {\n          if (index.getType().equals(OClass.INDEX_TYPE.FULLTEXT.name()) || index.getType()\n              .equals(OClass.INDEX_TYPE.FULLTEXT_HASH_INDEX.name())) {\n            continue;\n          }\n          List<String> indexedFields = index.getDefinition().getFields();\n          int nMatchingKeys = 0;\n          for (String indexedField : indexedFields) {\n            if (conditions.containsKey(indexedField)) {\n              nMatchingKeys++;\n            } else {\n              break;\n            }\n          }\n          if (nMatchingKeys > 0) {\n            long newCount = estimateFromIndex(index, conditions, nMatchingKeys);\n            if (newCount < conditionEstimation) {\n              conditionEstimation = newCount;\n            }\n          }\n        }\n      }\n      if (conditionEstimation > count) {\n        return count;\n      }\n      indexesCount += conditionEstimation;\n    }\n    return Math.min(indexesCount, count);\n  }", "code_tokens": ["public", "long", "estimate", "(", "OClass", "oClass", ",", "long", "threshold", ",", "OCommandContext", "ctx", ")", "{", "long", "count", "=", "oClass", ".", "count", "(", ")", ";", "if", "(", "count", ">", "1", ")", "{", "count", "=", "count", "/", "2", ";", "}", "if", "(", "count", "<", "threshold", ")", "{", "return", "count", ";", "}", "long", "indexesCount", "=", "0l", ";", "List", "<", "OAndBlock", ">", "flattenedConditions", "=", "flatten", "(", ")", ";", "Set", "<", "OIndex", "<", "?", ">", ">", "indexes", "=", "oClass", ".", "getIndexes", "(", ")", ";", "for", "(", "OAndBlock", "condition", ":", "flattenedConditions", ")", "{", "List", "<", "OBinaryCondition", ">", "indexedFunctConditions", "=", "condition", ".", "getIndexedFunctionConditions", "(", "oClass", ",", "(", "ODatabaseDocumentInternal", ")", "ctx", ".", "getDatabase", "(", ")", ")", ";", "long", "conditionEstimation", "=", "Long", ".", "MAX_VALUE", ";", "if", "(", "indexedFunctConditions", "!=", "null", ")", "{", "for", "(", "OBinaryCondition", "cond", ":", "indexedFunctConditions", ")", "{", "OFromClause", "from", "=", "new", "OFromClause", "(", "-", "1", ")", ";", "OFromItem", "item", "=", "new", "OFromItem", "(", "-", "1", ")", ";", "from", ".", "item", "=", "item", ";", "from", ".", "item", ".", "setIdentifier", "(", "new", "OIdentifier", "(", "oClass", ".", "getName", "(", ")", ")", ")", ";", "long", "newCount", "=", "cond", ".", "estimateIndexed", "(", "from", ",", "ctx", ")", ";", "if", "(", "newCount", "<", "conditionEstimation", ")", "{", "conditionEstimation", "=", "newCount", ";", "}", "}", "}", "else", "{", "Map", "<", "String", ",", "Object", ">", "conditions", "=", "getEqualityOperations", "(", "condition", ",", "ctx", ")", ";", "for", "(", "OIndex", "index", ":", "indexes", ")", "{", "if", "(", "index", ".", "getType", "(", ")", ".", "equals", "(", "OClass", ".", "INDEX_TYPE", ".", "FULLTEXT", ".", "name", "(", ")", ")", "||", "index", ".", "getType", "(", ")", ".", "equals", "(", "OClass", ".", "INDEX_TYPE", ".", "FULLTEXT_HASH_INDEX", ".", "name", "(", ")", ")", ")", "{", "continue", ";", "}", "List", "<", "String", ">", "indexedFields", "=", "index", ".", "getDefinition", "(", ")", ".", "getFields", "(", ")", ";", "int", "nMatchingKeys", "=", "0", ";", "for", "(", "String", "indexedField", ":", "indexedFields", ")", "{", "if", "(", "conditions", ".", "containsKey", "(", "indexedField", ")", ")", "{", "nMatchingKeys", "++", ";", "}", "else", "{", "break", ";", "}", "}", "if", "(", "nMatchingKeys", ">", "0", ")", "{", "long", "newCount", "=", "estimateFromIndex", "(", "index", ",", "conditions", ",", "nMatchingKeys", ")", ";", "if", "(", "newCount", "<", "conditionEstimation", ")", "{", "conditionEstimation", "=", "newCount", ";", "}", "}", "}", "}", "if", "(", "conditionEstimation", ">", "count", ")", "{", "return", "count", ";", "}", "indexesCount", "+=", "conditionEstimation", ";", "}", "return", "Math", ".", "min", "(", "indexesCount", ",", "count", ")", ";", "}"], "docstring": "estimates how many items of this class will be returned applying this filter\n\n@param oClass\n\n@return an estimation of the number of records of this class returned applying this filter, 0 if and only if sure that no\nrecords are returned", "docstring_tokens": ["estimates", "how", "many", "items", "of", "this", "class", "will", "be", "returned", "applying", "this", "filter"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OWhereClause.java#L68-L129", "partition": "test", "index": 2911, "time": "2015-07-27 08:53:07"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OMatchStatement.java", "func_name": "OMatchStatement.updateScheduleStartingAt", "original_string": "private void updateScheduleStartingAt(PatternNode startNode, Set<PatternNode> visitedNodes, Set<PatternEdge> visitedEdges,\n      Map<String, Set<String>> remainingDependencies, List<EdgeTraversal> resultingSchedule) {\n    // OrientDB requires the schedule to contain all edges present in the query, which is a stronger condition\n    // than simply visiting all nodes in the query. Consider the following example query:\n    //     MATCH {\n    //         class: A,\n    //         as: foo\n    //     }.in() {\n    //         as: bar\n    //     }, {\n    //         class: B,\n    //         as: bar\n    //     }.out() {\n    //         as: foo\n    //     } RETURN $matches\n    // The schedule for the above query must have two edges, even though there are only two nodes and they can both\n    // be visited with the traversal of a single edge.\n    //\n    // To satisfy it, we obey the following for each non-optional node:\n    // - ignore edges to neighboring nodes which have unsatisfied dependencies;\n    // - for visited neighboring nodes, add their edge if it wasn't already present in the schedule, but do not\n    //   recurse into the neighboring node;\n    // - for unvisited neighboring nodes with satisfied dependencies, add their edge and recurse into them.\n    visitedNodes.add(startNode);\n    for (Set<String> dependencies : remainingDependencies.values()) {\n      dependencies.remove(startNode.alias);\n    }\n\n    Map<PatternEdge, Boolean> edges = new LinkedHashMap<PatternEdge, Boolean>();\n    for (PatternEdge outEdge : startNode.out) {\n      edges.put(outEdge, true);\n    }\n    for (PatternEdge inEdge : startNode.in) {\n      edges.put(inEdge, false);\n    }\n\n    for (Map.Entry<PatternEdge, Boolean> edgeData : edges.entrySet()) {\n      PatternEdge edge = edgeData.getKey();\n      boolean isOutbound = edgeData.getValue();\n      PatternNode neighboringNode = isOutbound ? edge.in : edge.out;\n\n      if (!remainingDependencies.get(neighboringNode.alias).isEmpty()) {\n        // Unsatisfied dependencies, ignore this neighboring node.\n        continue;\n      }\n\n      if (visitedNodes.contains(neighboringNode)) {\n        if (!visitedEdges.contains(edge)) {\n          // If we are executing in this block, we are in the following situation:\n          // - the startNode has not been visited yet;\n          // - it has a neighboringNode that has already been visited;\n          // - the edge between the startNode and the neighboringNode has not been scheduled yet.\n          //\n          // The isOutbound value shows us whether the edge is outbound from the point of view of the startNode.\n          // However, if there are edges to the startNode, we must visit the startNode from an already-visited\n          // neighbor, to preserve the validity of the traversal. Therefore, we negate the value of isOutbound\n          // to ensure that the edge is always scheduled in the direction from the already-visited neighbor\n          // toward the startNode. Notably, this is also the case when evaluating \"optional\" nodes -- we always\n          // visit the optional node from its non-optional and already-visited neighbor.\n          //\n          // The only exception to the above is when we have edges with \"while\" conditions. We are not allowed\n          // to flip their directionality, so we leave them as-is.\n          boolean traversalDirection;\n          if (startNode.optional || edge.item.isBidirectional()) {\n            traversalDirection = !isOutbound;\n          } else {\n            traversalDirection = isOutbound;\n          }\n\n          visitedEdges.add(edge);\n          resultingSchedule.add(new EdgeTraversal(edge, traversalDirection));\n        }\n      } else if (!startNode.optional) {\n        // If the neighboring node wasn't visited, we don't expand the optional node into it, hence the above check.\n        // Instead, we'll allow the neighboring node to add the edge we failed to visit, via the above block.\n        if (visitedEdges.contains(edge)) {\n          // Should never happen.\n          throw new AssertionError(\"The edge was visited, but the neighboring vertex was not: \" + edge + \" \" + neighboringNode);\n        }\n\n        visitedEdges.add(edge);\n        resultingSchedule.add(new EdgeTraversal(edge, isOutbound));\n        updateScheduleStartingAt(neighboringNode, visitedNodes, visitedEdges, remainingDependencies, resultingSchedule);\n      }\n    }\n  }", "language": "java", "code": "private void updateScheduleStartingAt(PatternNode startNode, Set<PatternNode> visitedNodes, Set<PatternEdge> visitedEdges,\n      Map<String, Set<String>> remainingDependencies, List<EdgeTraversal> resultingSchedule) {\n    // OrientDB requires the schedule to contain all edges present in the query, which is a stronger condition\n    // than simply visiting all nodes in the query. Consider the following example query:\n    //     MATCH {\n    //         class: A,\n    //         as: foo\n    //     }.in() {\n    //         as: bar\n    //     }, {\n    //         class: B,\n    //         as: bar\n    //     }.out() {\n    //         as: foo\n    //     } RETURN $matches\n    // The schedule for the above query must have two edges, even though there are only two nodes and they can both\n    // be visited with the traversal of a single edge.\n    //\n    // To satisfy it, we obey the following for each non-optional node:\n    // - ignore edges to neighboring nodes which have unsatisfied dependencies;\n    // - for visited neighboring nodes, add their edge if it wasn't already present in the schedule, but do not\n    //   recurse into the neighboring node;\n    // - for unvisited neighboring nodes with satisfied dependencies, add their edge and recurse into them.\n    visitedNodes.add(startNode);\n    for (Set<String> dependencies : remainingDependencies.values()) {\n      dependencies.remove(startNode.alias);\n    }\n\n    Map<PatternEdge, Boolean> edges = new LinkedHashMap<PatternEdge, Boolean>();\n    for (PatternEdge outEdge : startNode.out) {\n      edges.put(outEdge, true);\n    }\n    for (PatternEdge inEdge : startNode.in) {\n      edges.put(inEdge, false);\n    }\n\n    for (Map.Entry<PatternEdge, Boolean> edgeData : edges.entrySet()) {\n      PatternEdge edge = edgeData.getKey();\n      boolean isOutbound = edgeData.getValue();\n      PatternNode neighboringNode = isOutbound ? edge.in : edge.out;\n\n      if (!remainingDependencies.get(neighboringNode.alias).isEmpty()) {\n        // Unsatisfied dependencies, ignore this neighboring node.\n        continue;\n      }\n\n      if (visitedNodes.contains(neighboringNode)) {\n        if (!visitedEdges.contains(edge)) {\n          // If we are executing in this block, we are in the following situation:\n          // - the startNode has not been visited yet;\n          // - it has a neighboringNode that has already been visited;\n          // - the edge between the startNode and the neighboringNode has not been scheduled yet.\n          //\n          // The isOutbound value shows us whether the edge is outbound from the point of view of the startNode.\n          // However, if there are edges to the startNode, we must visit the startNode from an already-visited\n          // neighbor, to preserve the validity of the traversal. Therefore, we negate the value of isOutbound\n          // to ensure that the edge is always scheduled in the direction from the already-visited neighbor\n          // toward the startNode. Notably, this is also the case when evaluating \"optional\" nodes -- we always\n          // visit the optional node from its non-optional and already-visited neighbor.\n          //\n          // The only exception to the above is when we have edges with \"while\" conditions. We are not allowed\n          // to flip their directionality, so we leave them as-is.\n          boolean traversalDirection;\n          if (startNode.optional || edge.item.isBidirectional()) {\n            traversalDirection = !isOutbound;\n          } else {\n            traversalDirection = isOutbound;\n          }\n\n          visitedEdges.add(edge);\n          resultingSchedule.add(new EdgeTraversal(edge, traversalDirection));\n        }\n      } else if (!startNode.optional) {\n        // If the neighboring node wasn't visited, we don't expand the optional node into it, hence the above check.\n        // Instead, we'll allow the neighboring node to add the edge we failed to visit, via the above block.\n        if (visitedEdges.contains(edge)) {\n          // Should never happen.\n          throw new AssertionError(\"The edge was visited, but the neighboring vertex was not: \" + edge + \" \" + neighboringNode);\n        }\n\n        visitedEdges.add(edge);\n        resultingSchedule.add(new EdgeTraversal(edge, isOutbound));\n        updateScheduleStartingAt(neighboringNode, visitedNodes, visitedEdges, remainingDependencies, resultingSchedule);\n      }\n    }\n  }", "code_tokens": ["private", "void", "updateScheduleStartingAt", "(", "PatternNode", "startNode", ",", "Set", "<", "PatternNode", ">", "visitedNodes", ",", "Set", "<", "PatternEdge", ">", "visitedEdges", ",", "Map", "<", "String", ",", "Set", "<", "String", ">", ">", "remainingDependencies", ",", "List", "<", "EdgeTraversal", ">", "resultingSchedule", ")", "{", "// OrientDB requires the schedule to contain all edges present in the query, which is a stronger condition", "// than simply visiting all nodes in the query. Consider the following example query:", "//     MATCH {", "//         class: A,", "//         as: foo", "//     }.in() {", "//         as: bar", "//     }, {", "//         class: B,", "//         as: bar", "//     }.out() {", "//         as: foo", "//     } RETURN $matches", "// The schedule for the above query must have two edges, even though there are only two nodes and they can both", "// be visited with the traversal of a single edge.", "//", "// To satisfy it, we obey the following for each non-optional node:", "// - ignore edges to neighboring nodes which have unsatisfied dependencies;", "// - for visited neighboring nodes, add their edge if it wasn't already present in the schedule, but do not", "//   recurse into the neighboring node;", "// - for unvisited neighboring nodes with satisfied dependencies, add their edge and recurse into them.", "visitedNodes", ".", "add", "(", "startNode", ")", ";", "for", "(", "Set", "<", "String", ">", "dependencies", ":", "remainingDependencies", ".", "values", "(", ")", ")", "{", "dependencies", ".", "remove", "(", "startNode", ".", "alias", ")", ";", "}", "Map", "<", "PatternEdge", ",", "Boolean", ">", "edges", "=", "new", "LinkedHashMap", "<", "PatternEdge", ",", "Boolean", ">", "(", ")", ";", "for", "(", "PatternEdge", "outEdge", ":", "startNode", ".", "out", ")", "{", "edges", ".", "put", "(", "outEdge", ",", "true", ")", ";", "}", "for", "(", "PatternEdge", "inEdge", ":", "startNode", ".", "in", ")", "{", "edges", ".", "put", "(", "inEdge", ",", "false", ")", ";", "}", "for", "(", "Map", ".", "Entry", "<", "PatternEdge", ",", "Boolean", ">", "edgeData", ":", "edges", ".", "entrySet", "(", ")", ")", "{", "PatternEdge", "edge", "=", "edgeData", ".", "getKey", "(", ")", ";", "boolean", "isOutbound", "=", "edgeData", ".", "getValue", "(", ")", ";", "PatternNode", "neighboringNode", "=", "isOutbound", "?", "edge", ".", "in", ":", "edge", ".", "out", ";", "if", "(", "!", "remainingDependencies", ".", "get", "(", "neighboringNode", ".", "alias", ")", ".", "isEmpty", "(", ")", ")", "{", "// Unsatisfied dependencies, ignore this neighboring node.", "continue", ";", "}", "if", "(", "visitedNodes", ".", "contains", "(", "neighboringNode", ")", ")", "{", "if", "(", "!", "visitedEdges", ".", "contains", "(", "edge", ")", ")", "{", "// If we are executing in this block, we are in the following situation:", "// - the startNode has not been visited yet;", "// - it has a neighboringNode that has already been visited;", "// - the edge between the startNode and the neighboringNode has not been scheduled yet.", "//", "// The isOutbound value shows us whether the edge is outbound from the point of view of the startNode.", "// However, if there are edges to the startNode, we must visit the startNode from an already-visited", "// neighbor, to preserve the validity of the traversal. Therefore, we negate the value of isOutbound", "// to ensure that the edge is always scheduled in the direction from the already-visited neighbor", "// toward the startNode. Notably, this is also the case when evaluating \"optional\" nodes -- we always", "// visit the optional node from its non-optional and already-visited neighbor.", "//", "// The only exception to the above is when we have edges with \"while\" conditions. We are not allowed", "// to flip their directionality, so we leave them as-is.", "boolean", "traversalDirection", ";", "if", "(", "startNode", ".", "optional", "||", "edge", ".", "item", ".", "isBidirectional", "(", ")", ")", "{", "traversalDirection", "=", "!", "isOutbound", ";", "}", "else", "{", "traversalDirection", "=", "isOutbound", ";", "}", "visitedEdges", ".", "add", "(", "edge", ")", ";", "resultingSchedule", ".", "add", "(", "new", "EdgeTraversal", "(", "edge", ",", "traversalDirection", ")", ")", ";", "}", "}", "else", "if", "(", "!", "startNode", ".", "optional", ")", "{", "// If the neighboring node wasn't visited, we don't expand the optional node into it, hence the above check.", "// Instead, we'll allow the neighboring node to add the edge we failed to visit, via the above block.", "if", "(", "visitedEdges", ".", "contains", "(", "edge", ")", ")", "{", "// Should never happen.", "throw", "new", "AssertionError", "(", "\"The edge was visited, but the neighboring vertex was not: \"", "+", "edge", "+", "\" \"", "+", "neighboringNode", ")", ";", "}", "visitedEdges", ".", "add", "(", "edge", ")", ";", "resultingSchedule", ".", "add", "(", "new", "EdgeTraversal", "(", "edge", ",", "isOutbound", ")", ")", ";", "updateScheduleStartingAt", "(", "neighboringNode", ",", "visitedNodes", ",", "visitedEdges", ",", "remainingDependencies", ",", "resultingSchedule", ")", ";", "}", "}", "}"], "docstring": "Start a depth-first traversal from the starting node, adding all viable unscheduled edges and vertices.\n\n@param startNode             the node from which to start the depth-first traversal\n@param visitedNodes          set of nodes that are already visited (mutated in this function)\n@param visitedEdges          set of edges that are already visited and therefore don't need to be scheduled (mutated in this\nfunction)\n@param remainingDependencies dependency map including only the dependencies that haven't yet been satisfied (mutated in this\nfunction)\n@param resultingSchedule     the schedule being computed i.e. appended to (mutated in this function)", "docstring_tokens": ["Start", "a", "depth", "-", "first", "traversal", "from", "the", "starting", "node", "adding", "all", "viable", "unscheduled", "edges", "and", "vertices", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OMatchStatement.java#L388-L473", "partition": "test", "index": 2990, "time": "2015-07-27 11:53:07"}
{"repo": "orientechnologies/orientdb", "path": "tools/src/main/java/com/orientechnologies/orient/server/config/OServerConfiguration.java", "func_name": "OServerConfiguration.getProperty", "original_string": "public String getProperty(final String iName, final String iDefaultValue) {\n    if (properties == null)\n      return null;\n\n    for (OServerEntryConfiguration p : properties) {\n      if (p.name.equals(iName))\n        return p.value;\n    }\n\n    return null;\n  }", "language": "java", "code": "public String getProperty(final String iName, final String iDefaultValue) {\n    if (properties == null)\n      return null;\n\n    for (OServerEntryConfiguration p : properties) {\n      if (p.name.equals(iName))\n        return p.value;\n    }\n\n    return null;\n  }", "code_tokens": ["public", "String", "getProperty", "(", "final", "String", "iName", ",", "final", "String", "iDefaultValue", ")", "{", "if", "(", "properties", "==", "null", ")", "return", "null", ";", "for", "(", "OServerEntryConfiguration", "p", ":", "properties", ")", "{", "if", "(", "p", ".", "name", ".", "equals", "(", "iName", ")", ")", "return", "p", ".", "value", ";", "}", "return", "null", ";", "}"], "docstring": "Returns the property value configured, if any.\n\n@param iName\nProperty name to find\n@param iDefaultValue\nDefault value returned if not found", "docstring_tokens": ["Returns", "the", "property", "value", "configured", "if", "any", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/tools/src/main/java/com/orientechnologies/orient/server/config/OServerConfiguration.java#L113-L123", "partition": "test", "index": 3138, "time": "2015-08-08 15:33:18"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OStatementCache.java", "func_name": "OStatementCache.parse", "original_string": "protected static OStatement parse(String statement) throws OCommandSQLParsingException {\n    try {\n      ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.instance().getIfDefined();\n      InputStream is;\n\n      if (db == null) {\n        is = new ByteArrayInputStream(statement.getBytes());\n      } else {\n        try {\n          is = new ByteArrayInputStream(statement.getBytes(db.getStorage().getConfiguration().getCharset()));\n        } catch (UnsupportedEncodingException e2) {\n          OLogManager.instance()\n              .warn(null, \"Unsupported charset for database \" + db + \" \" + db.getStorage().getConfiguration().getCharset());\n          is = new ByteArrayInputStream(statement.getBytes());\n        }\n      }\n\n      OrientSql osql = null;\n      if (db == null) {\n        osql = new OrientSql(is);\n      } else {\n        try {\n          osql = new OrientSql(is, db.getStorage().getConfiguration().getCharset());\n        } catch (UnsupportedEncodingException e2) {\n          OLogManager.instance()\n              .warn(null, \"Unsupported charset for database \" + db + \" \" + db.getStorage().getConfiguration().getCharset());\n          osql = new OrientSql(is);\n        }\n      }\n      OStatement result = osql.parse();\n      result.originalStatement = statement;\n\n      return result;\n    } catch (ParseException e) {\n      throwParsingException(e, statement);\n    } catch (TokenMgrError e2) {\n      throwParsingException(e2, statement);\n    }\n    return null;\n  }", "language": "java", "code": "protected static OStatement parse(String statement) throws OCommandSQLParsingException {\n    try {\n      ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.instance().getIfDefined();\n      InputStream is;\n\n      if (db == null) {\n        is = new ByteArrayInputStream(statement.getBytes());\n      } else {\n        try {\n          is = new ByteArrayInputStream(statement.getBytes(db.getStorage().getConfiguration().getCharset()));\n        } catch (UnsupportedEncodingException e2) {\n          OLogManager.instance()\n              .warn(null, \"Unsupported charset for database \" + db + \" \" + db.getStorage().getConfiguration().getCharset());\n          is = new ByteArrayInputStream(statement.getBytes());\n        }\n      }\n\n      OrientSql osql = null;\n      if (db == null) {\n        osql = new OrientSql(is);\n      } else {\n        try {\n          osql = new OrientSql(is, db.getStorage().getConfiguration().getCharset());\n        } catch (UnsupportedEncodingException e2) {\n          OLogManager.instance()\n              .warn(null, \"Unsupported charset for database \" + db + \" \" + db.getStorage().getConfiguration().getCharset());\n          osql = new OrientSql(is);\n        }\n      }\n      OStatement result = osql.parse();\n      result.originalStatement = statement;\n\n      return result;\n    } catch (ParseException e) {\n      throwParsingException(e, statement);\n    } catch (TokenMgrError e2) {\n      throwParsingException(e2, statement);\n    }\n    return null;\n  }", "code_tokens": ["protected", "static", "OStatement", "parse", "(", "String", "statement", ")", "throws", "OCommandSQLParsingException", "{", "try", "{", "ODatabaseDocumentInternal", "db", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "getIfDefined", "(", ")", ";", "InputStream", "is", ";", "if", "(", "db", "==", "null", ")", "{", "is", "=", "new", "ByteArrayInputStream", "(", "statement", ".", "getBytes", "(", ")", ")", ";", "}", "else", "{", "try", "{", "is", "=", "new", "ByteArrayInputStream", "(", "statement", ".", "getBytes", "(", "db", ".", "getStorage", "(", ")", ".", "getConfiguration", "(", ")", ".", "getCharset", "(", ")", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e2", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "null", ",", "\"Unsupported charset for database \"", "+", "db", "+", "\" \"", "+", "db", ".", "getStorage", "(", ")", ".", "getConfiguration", "(", ")", ".", "getCharset", "(", ")", ")", ";", "is", "=", "new", "ByteArrayInputStream", "(", "statement", ".", "getBytes", "(", ")", ")", ";", "}", "}", "OrientSql", "osql", "=", "null", ";", "if", "(", "db", "==", "null", ")", "{", "osql", "=", "new", "OrientSql", "(", "is", ")", ";", "}", "else", "{", "try", "{", "osql", "=", "new", "OrientSql", "(", "is", ",", "db", ".", "getStorage", "(", ")", ".", "getConfiguration", "(", ")", ".", "getCharset", "(", ")", ")", ";", "}", "catch", "(", "UnsupportedEncodingException", "e2", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "null", ",", "\"Unsupported charset for database \"", "+", "db", "+", "\" \"", "+", "db", ".", "getStorage", "(", ")", ".", "getConfiguration", "(", ")", ".", "getCharset", "(", ")", ")", ";", "osql", "=", "new", "OrientSql", "(", "is", ")", ";", "}", "}", "OStatement", "result", "=", "osql", ".", "parse", "(", ")", ";", "result", ".", "originalStatement", "=", "statement", ";", "return", "result", ";", "}", "catch", "(", "ParseException", "e", ")", "{", "throwParsingException", "(", "e", ",", "statement", ")", ";", "}", "catch", "(", "TokenMgrError", "e2", ")", "{", "throwParsingException", "(", "e2", ",", "statement", ")", ";", "}", "return", "null", ";", "}"], "docstring": "parses an SQL statement and returns the corresponding executor\n\n@param statement the SQL statement\n\n@return the corresponding executor\n\n@throws OCommandSQLParsingException if the input parameter is not a valid SQL statement", "docstring_tokens": ["parses", "an", "SQL", "statement", "and", "returns", "the", "corresponding", "executor"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OStatementCache.java#L98-L137", "partition": "test", "index": 3063, "time": "2015-08-11 10:45:11"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/encryption/OEncryptionFactory.java", "func_name": "OEncryptionFactory.register", "original_string": "public void register(final OEncryption iEncryption) {\n    try {\n      final String name = iEncryption.name();\n\n      if (instances.containsKey(name))\n        throw new IllegalArgumentException(\"Encryption with name '\" + name + \"' was already registered\");\n\n      if (classes.containsKey(name))\n        throw new IllegalArgumentException(\"Encryption with name '\" + name + \"' was already registered\");\n\n      instances.put(name, iEncryption);\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Cannot register storage encryption algorithm '%s'\", e, iEncryption);\n    }\n  }", "language": "java", "code": "public void register(final OEncryption iEncryption) {\n    try {\n      final String name = iEncryption.name();\n\n      if (instances.containsKey(name))\n        throw new IllegalArgumentException(\"Encryption with name '\" + name + \"' was already registered\");\n\n      if (classes.containsKey(name))\n        throw new IllegalArgumentException(\"Encryption with name '\" + name + \"' was already registered\");\n\n      instances.put(name, iEncryption);\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Cannot register storage encryption algorithm '%s'\", e, iEncryption);\n    }\n  }", "code_tokens": ["public", "void", "register", "(", "final", "OEncryption", "iEncryption", ")", "{", "try", "{", "final", "String", "name", "=", "iEncryption", ".", "name", "(", ")", ";", "if", "(", "instances", ".", "containsKey", "(", "name", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Encryption with name '\"", "+", "name", "+", "\"' was already registered\"", ")", ";", "if", "(", "classes", ".", "containsKey", "(", "name", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Encryption with name '\"", "+", "name", "+", "\"' was already registered\"", ")", ";", "instances", ".", "put", "(", "name", ",", "iEncryption", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Cannot register storage encryption algorithm '%s'\"", ",", "e", ",", "iEncryption", ")", ";", "}", "}"], "docstring": "Registers a stateful implementations, a new instance will be created for each storage.\n\n@param iEncryption\nEncryption instance", "docstring_tokens": ["Registers", "a", "stateful", "implementations", "a", "new", "instance", "will", "be", "created", "for", "each", "storage", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/encryption/OEncryptionFactory.java#L87-L101", "partition": "test", "index": 3332, "time": "2015-08-14 20:54:49"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getAllConfiguredServers", "original_string": "public Set<String> getAllConfiguredServers() {\n\n    final Set<String> servers = new HashSet<String>();\n\n    for (String p : getClusterNames()) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null) {\n        for (String s : serverList)\n          if (!s.equals(NEW_NODE_TAG))\n            servers.add(s);\n      }\n    }\n    return servers;\n  }", "language": "java", "code": "public Set<String> getAllConfiguredServers() {\n\n    final Set<String> servers = new HashSet<String>();\n\n    for (String p : getClusterNames()) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null) {\n        for (String s : serverList)\n          if (!s.equals(NEW_NODE_TAG))\n            servers.add(s);\n      }\n    }\n    return servers;\n  }", "code_tokens": ["public", "Set", "<", "String", ">", "getAllConfiguredServers", "(", ")", "{", "final", "Set", "<", "String", ">", "servers", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "for", "(", "String", "p", ":", "getClusterNames", "(", ")", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "p", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", ")", "{", "for", "(", "String", "s", ":", "serverList", ")", "if", "(", "!", "s", ".", "equals", "(", "NEW_NODE_TAG", ")", ")", "servers", ".", "add", "(", "s", ")", ";", "}", "}", "return", "servers", ";", "}"], "docstring": "Returns the complete list of servers found in configuration.", "docstring_tokens": ["Returns", "the", "complete", "list", "of", "servers", "found", "in", "configuration", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L399-L412", "partition": "test", "index": 3093, "time": "2015-10-02 15:42:58"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java", "func_name": "OServerAdmin.getServerInfo", "original_string": "@Deprecated\r\n  public synchronized ODocument getServerInfo() throws IOException {\r\n    OServerInfoRequest request = new OServerInfoRequest();\r\n    OServerInfoResponse response = networkAdminOperation(request, \"Cannot retrieve server information\");\r\n    ODocument res = new ODocument();\r\n    res.fromJSON(response.getResult());\r\n    return res;\r\n  }", "language": "java", "code": "@Deprecated\r\n  public synchronized ODocument getServerInfo() throws IOException {\r\n    OServerInfoRequest request = new OServerInfoRequest();\r\n    OServerInfoResponse response = networkAdminOperation(request, \"Cannot retrieve server information\");\r\n    ODocument res = new ODocument();\r\n    res.fromJSON(response.getResult());\r\n    return res;\r\n  }", "code_tokens": ["@", "Deprecated", "public", "synchronized", "ODocument", "getServerInfo", "(", ")", "throws", "IOException", "{", "OServerInfoRequest", "request", "=", "new", "OServerInfoRequest", "(", ")", ";", "OServerInfoResponse", "response", "=", "networkAdminOperation", "(", "request", ",", "\"Cannot retrieve server information\"", ")", ";", "ODocument", "res", "=", "new", "ODocument", "(", ")", ";", "res", ".", "fromJSON", "(", "response", ".", "getResult", "(", ")", ")", ";", "return", "res", ";", "}"], "docstring": "Returns the server information in form of document.\n\n@throws IOException", "docstring_tokens": ["Returns", "the", "server", "information", "in", "form", "of", "document", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OServerAdmin.java#L164-L171", "partition": "test", "index": 3223, "time": "2015-10-12 18:47:45"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/OBasicCommandContext.java", "func_name": "OBasicCommandContext.addToUniqueResult", "original_string": "public synchronized boolean addToUniqueResult(Object o) {\r\n    Object toAdd = o;\r\n    if (o instanceof ODocument && ((ODocument) o).getIdentity().isNew()) {\r\n      toAdd = new ODocumentEqualityWrapper((ODocument) o);\r\n    }\r\n    return this.uniqueResult.add(toAdd);\r\n  }", "language": "java", "code": "public synchronized boolean addToUniqueResult(Object o) {\r\n    Object toAdd = o;\r\n    if (o instanceof ODocument && ((ODocument) o).getIdentity().isNew()) {\r\n      toAdd = new ODocumentEqualityWrapper((ODocument) o);\r\n    }\r\n    return this.uniqueResult.add(toAdd);\r\n  }", "code_tokens": ["public", "synchronized", "boolean", "addToUniqueResult", "(", "Object", "o", ")", "{", "Object", "toAdd", "=", "o", ";", "if", "(", "o", "instanceof", "ODocument", "&&", "(", "(", "ODocument", ")", "o", ")", ".", "getIdentity", "(", ")", ".", "isNew", "(", ")", ")", "{", "toAdd", "=", "new", "ODocumentEqualityWrapper", "(", "(", "ODocument", ")", "o", ")", ";", "}", "return", "this", ".", "uniqueResult", ".", "add", "(", "toAdd", ")", ";", "}"], "docstring": "adds an item to the unique result set\n\n@param o the result item to add\n\n@return true if the element is successfully added (it was not present yet), false otherwise (it was already present)", "docstring_tokens": ["adds", "an", "item", "to", "the", "unique", "result", "set"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/OBasicCommandContext.java#L382-L388", "partition": "test", "index": 3192, "time": "2015-11-17 17:21:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/OCommandRequestAbstract.java", "func_name": "OCommandRequestAbstract.onAsyncReplicationError", "original_string": "@Override\r\n  public OCommandRequestAbstract onAsyncReplicationError(final OAsyncReplicationError iCallback) {\r\n    if (iCallback != null) {\r\n      onAsyncReplicationError = new OAsyncReplicationError() {\r\n        int retry = 0;\r\n\r\n        @Override\r\n        public ACTION onAsyncReplicationError(Throwable iException, final int iRetry) {\r\n          switch (iCallback.onAsyncReplicationError(iException, ++retry)) {\r\n          case RETRY:\r\n            execute();\r\n            break;\r\n\r\n          case IGNORE:\r\n\r\n          }\r\n\r\n          return ACTION.IGNORE;\r\n        }\r\n      };\r\n    } else\r\n      onAsyncReplicationError = null;\r\n    return this;\r\n  }", "language": "java", "code": "@Override\r\n  public OCommandRequestAbstract onAsyncReplicationError(final OAsyncReplicationError iCallback) {\r\n    if (iCallback != null) {\r\n      onAsyncReplicationError = new OAsyncReplicationError() {\r\n        int retry = 0;\r\n\r\n        @Override\r\n        public ACTION onAsyncReplicationError(Throwable iException, final int iRetry) {\r\n          switch (iCallback.onAsyncReplicationError(iException, ++retry)) {\r\n          case RETRY:\r\n            execute();\r\n            break;\r\n\r\n          case IGNORE:\r\n\r\n          }\r\n\r\n          return ACTION.IGNORE;\r\n        }\r\n      };\r\n    } else\r\n      onAsyncReplicationError = null;\r\n    return this;\r\n  }", "code_tokens": ["@", "Override", "public", "OCommandRequestAbstract", "onAsyncReplicationError", "(", "final", "OAsyncReplicationError", "iCallback", ")", "{", "if", "(", "iCallback", "!=", "null", ")", "{", "onAsyncReplicationError", "=", "new", "OAsyncReplicationError", "(", ")", "{", "int", "retry", "=", "0", ";", "@", "Override", "public", "ACTION", "onAsyncReplicationError", "(", "Throwable", "iException", ",", "final", "int", "iRetry", ")", "{", "switch", "(", "iCallback", ".", "onAsyncReplicationError", "(", "iException", ",", "++", "retry", ")", ")", "{", "case", "RETRY", ":", "execute", "(", ")", ";", "break", ";", "case", "IGNORE", ":", "}", "return", "ACTION", ".", "IGNORE", ";", "}", "}", ";", "}", "else", "onAsyncReplicationError", "=", "null", ";", "return", "this", ";", "}"], "docstring": "Defines a callback to call in case of error during the asynchronous replication.", "docstring_tokens": ["Defines", "a", "callback", "to", "call", "in", "case", "of", "error", "during", "the", "asynchronous", "replication", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/OCommandRequestAbstract.java#L116-L139", "partition": "test", "index": 2977, "time": "2015-11-19 23:24:47"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/tool/ODatabaseRepair.java", "func_name": "ODatabaseRepair.fixLink", "original_string": "protected boolean fixLink(final Object fieldValue) {\n    if (fieldValue instanceof OIdentifiable) {\n      final ORID id = ((OIdentifiable) fieldValue).getIdentity();\n\n      if (id.getClusterId() == 0 && id.getClusterPosition() == 0)\n        return true;\n\n      if (id.isValid())\n        if (id.isPersistent()) {\n          final ORecord connected = ((OIdentifiable) fieldValue).getRecord();\n          if (connected == null)\n            return true;\n        } else\n          return true;\n    }\n    return false;\n  }", "language": "java", "code": "protected boolean fixLink(final Object fieldValue) {\n    if (fieldValue instanceof OIdentifiable) {\n      final ORID id = ((OIdentifiable) fieldValue).getIdentity();\n\n      if (id.getClusterId() == 0 && id.getClusterPosition() == 0)\n        return true;\n\n      if (id.isValid())\n        if (id.isPersistent()) {\n          final ORecord connected = ((OIdentifiable) fieldValue).getRecord();\n          if (connected == null)\n            return true;\n        } else\n          return true;\n    }\n    return false;\n  }", "code_tokens": ["protected", "boolean", "fixLink", "(", "final", "Object", "fieldValue", ")", "{", "if", "(", "fieldValue", "instanceof", "OIdentifiable", ")", "{", "final", "ORID", "id", "=", "(", "(", "OIdentifiable", ")", "fieldValue", ")", ".", "getIdentity", "(", ")", ";", "if", "(", "id", ".", "getClusterId", "(", ")", "==", "0", "&&", "id", ".", "getClusterPosition", "(", ")", "==", "0", ")", "return", "true", ";", "if", "(", "id", ".", "isValid", "(", ")", ")", "if", "(", "id", ".", "isPersistent", "(", ")", ")", "{", "final", "ORecord", "connected", "=", "(", "(", "OIdentifiable", ")", "fieldValue", ")", ".", "getRecord", "(", ")", ";", "if", "(", "connected", "==", "null", ")", "return", "true", ";", "}", "else", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Checks if the link must be fixed.\n\n@param fieldValue\nField containing the OIdentifiable (RID or Record)\n@return true to fix it, otherwise false", "docstring_tokens": ["Checks", "if", "the", "link", "must", "be", "fixed", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/tool/ODatabaseRepair.java#L131-L147", "partition": "test", "index": 3281, "time": "2015-12-01 18:21:25"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.stopCommitTimer", "original_string": "public void stopCommitTimer() {\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    performanceCountersHolder.commitTime += timeDiff;\n    performanceCountersHolder.commitCount++;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "language": "java", "code": "public void stopCommitTimer() {\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    performanceCountersHolder.commitTime += timeDiff;\n    performanceCountersHolder.commitCount++;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "code_tokens": ["public", "void", "stopCommitTimer", "(", ")", "{", "final", "long", "endTs", "=", "nanoTimer", ".", "getNano", "(", ")", ";", "final", "long", "timeDiff", "=", "(", "endTs", "-", "timeStamps", ".", "pop", "(", ")", ")", ";", "performanceCountersHolder", ".", "commitTime", "+=", "timeDiff", ";", "performanceCountersHolder", ".", "commitCount", "++", ";", "makeSnapshotIfNeeded", "(", "endTs", ")", ";", "}"], "docstring": "Stops and records results of timer which counts how much time was spent on atomic operation commit.", "docstring_tokens": ["Stops", "and", "records", "results", "of", "timer", "which", "counts", "how", "much", "time", "was", "spent", "on", "atomic", "operation", "commit", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L1092-L1100", "partition": "test", "index": 3060, "time": "2015-12-14 15:01:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.completeComponentOperation", "original_string": "public void completeComponentOperation() {\n    final Component currentComponent = componentsStack.peek();\n    if (currentComponent == null)\n      return;\n\n    currentComponent.operationCount--;\n\n    if (currentComponent.operationCount == 0) {\n      final String componentName = currentComponent.name;\n\n      PerformanceCountersHolder cHolder = countersByComponent\n          .computeIfAbsent(componentName, k -> currentComponent.type.newCountersHolder());\n\n      cHolder.operationsCount++;\n\n      componentsStack.pop();\n\n      makeSnapshotIfNeeded(-1);\n    }\n  }", "language": "java", "code": "public void completeComponentOperation() {\n    final Component currentComponent = componentsStack.peek();\n    if (currentComponent == null)\n      return;\n\n    currentComponent.operationCount--;\n\n    if (currentComponent.operationCount == 0) {\n      final String componentName = currentComponent.name;\n\n      PerformanceCountersHolder cHolder = countersByComponent\n          .computeIfAbsent(componentName, k -> currentComponent.type.newCountersHolder());\n\n      cHolder.operationsCount++;\n\n      componentsStack.pop();\n\n      makeSnapshotIfNeeded(-1);\n    }\n  }", "code_tokens": ["public", "void", "completeComponentOperation", "(", ")", "{", "final", "Component", "currentComponent", "=", "componentsStack", ".", "peek", "(", ")", ";", "if", "(", "currentComponent", "==", "null", ")", "return", ";", "currentComponent", ".", "operationCount", "--", ";", "if", "(", "currentComponent", ".", "operationCount", "==", "0", ")", "{", "final", "String", "componentName", "=", "currentComponent", ".", "name", ";", "PerformanceCountersHolder", "cHolder", "=", "countersByComponent", ".", "computeIfAbsent", "(", "componentName", ",", "k", "->", "currentComponent", ".", "type", ".", "newCountersHolder", "(", ")", ")", ";", "cHolder", ".", "operationsCount", "++", ";", "componentsStack", ".", "pop", "(", ")", ";", "makeSnapshotIfNeeded", "(", "-", "1", ")", ";", "}", "}"], "docstring": "Indicates that the most earliest component in stack of components has completed it's operation, so performance data for this\ncomponent is stopped to be gathered.\n\n@see #startComponentOperation(String, ComponentType)", "docstring_tokens": ["Indicates", "that", "the", "most", "earliest", "component", "in", "stack", "of", "components", "has", "completed", "it", "s", "operation", "so", "performance", "data", "for", "this", "component", "is", "stopped", "to", "be", "gathered", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L188-L207", "partition": "test", "index": 3051, "time": "2015-12-14 15:01:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OProfileStorageStatement.java", "func_name": "OProfileStorageStatement.execute", "original_string": "@Override public Object execute(OSQLAsynchQuery<ODocument> request, OCommandContext context, OProgressListener progressListener) {\n    try {\n      ODatabaseDocumentInternal db = getDatabase();\n\n      final OStorage storage = db.getStorage();\n      if (on) {\n        // activate the profiler\n        ((OAbstractPaginatedStorage) storage).startGatheringPerformanceStatisticForCurrentThread();\n        ODocument result = new ODocument();\n        result.field(\"result\", \"OK\");\n        request.getResultListener().result(result);\n      } else {\n        // stop the profiler and return the stats\n        final OSessionStoragePerformanceStatistic performanceStatistic = ((OAbstractPaginatedStorage) storage)\n            .completeGatheringPerformanceStatisticForCurrentThread();\n\n        if (performanceStatistic != null)\n          request.getResultListener().result(performanceStatistic.toDocument());\n        else {\n          ODocument result = new ODocument();\n          result.field(\"result\", \"Error: profiling of storage was not started.\");\n          request.getResultListener().result(result);\n        }\n\n      }\n      return getResult(request);\n    } finally {\n      if (request.getResultListener() != null) {\n        request.getResultListener().end();\n      }\n    }\n  }", "language": "java", "code": "@Override public Object execute(OSQLAsynchQuery<ODocument> request, OCommandContext context, OProgressListener progressListener) {\n    try {\n      ODatabaseDocumentInternal db = getDatabase();\n\n      final OStorage storage = db.getStorage();\n      if (on) {\n        // activate the profiler\n        ((OAbstractPaginatedStorage) storage).startGatheringPerformanceStatisticForCurrentThread();\n        ODocument result = new ODocument();\n        result.field(\"result\", \"OK\");\n        request.getResultListener().result(result);\n      } else {\n        // stop the profiler and return the stats\n        final OSessionStoragePerformanceStatistic performanceStatistic = ((OAbstractPaginatedStorage) storage)\n            .completeGatheringPerformanceStatisticForCurrentThread();\n\n        if (performanceStatistic != null)\n          request.getResultListener().result(performanceStatistic.toDocument());\n        else {\n          ODocument result = new ODocument();\n          result.field(\"result\", \"Error: profiling of storage was not started.\");\n          request.getResultListener().result(result);\n        }\n\n      }\n      return getResult(request);\n    } finally {\n      if (request.getResultListener() != null) {\n        request.getResultListener().end();\n      }\n    }\n  }", "code_tokens": ["@", "Override", "public", "Object", "execute", "(", "OSQLAsynchQuery", "<", "ODocument", ">", "request", ",", "OCommandContext", "context", ",", "OProgressListener", "progressListener", ")", "{", "try", "{", "ODatabaseDocumentInternal", "db", "=", "getDatabase", "(", ")", ";", "final", "OStorage", "storage", "=", "db", ".", "getStorage", "(", ")", ";", "if", "(", "on", ")", "{", "// activate the profiler", "(", "(", "OAbstractPaginatedStorage", ")", "storage", ")", ".", "startGatheringPerformanceStatisticForCurrentThread", "(", ")", ";", "ODocument", "result", "=", "new", "ODocument", "(", ")", ";", "result", ".", "field", "(", "\"result\"", ",", "\"OK\"", ")", ";", "request", ".", "getResultListener", "(", ")", ".", "result", "(", "result", ")", ";", "}", "else", "{", "// stop the profiler and return the stats", "final", "OSessionStoragePerformanceStatistic", "performanceStatistic", "=", "(", "(", "OAbstractPaginatedStorage", ")", "storage", ")", ".", "completeGatheringPerformanceStatisticForCurrentThread", "(", ")", ";", "if", "(", "performanceStatistic", "!=", "null", ")", "request", ".", "getResultListener", "(", ")", ".", "result", "(", "performanceStatistic", ".", "toDocument", "(", ")", ")", ";", "else", "{", "ODocument", "result", "=", "new", "ODocument", "(", ")", ";", "result", ".", "field", "(", "\"result\"", ",", "\"Error: profiling of storage was not started.\"", ")", ";", "request", ".", "getResultListener", "(", ")", ".", "result", "(", "result", ")", ";", "}", "}", "return", "getResult", "(", "request", ")", ";", "}", "finally", "{", "if", "(", "request", ".", "getResultListener", "(", ")", "!=", "null", ")", "{", "request", ".", "getResultListener", "(", ")", ".", "end", "(", ")", ";", "}", "}", "}"], "docstring": "old execution logic", "docstring_tokens": ["old", "execution", "logic"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OProfileStorageStatement.java#L66-L97", "partition": "test", "index": 3265, "time": "2015-12-14 16:54:54"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getClusterOwner", "original_string": "public String getClusterOwner(final String iClusterName) {\n    String owner;\n\n    final ODocument clusters = getConfiguredClusters();\n\n    // GET THE CLUSTER CFG\n    final ODocument cfg = iClusterName != null ? (ODocument) clusters.field(iClusterName) : null;\n\n    if (cfg != null) {\n      owner = cfg.field(OWNER);\n      if (owner != null)\n        return owner;\n\n      final List<String> serverList = cfg.field(SERVERS);\n      if (serverList != null && !serverList.isEmpty()) {\n        // RETURN THE FIRST ONE\n        owner = serverList.get(0);\n        if (NEW_NODE_TAG.equals(owner) && serverList.size() > 1)\n          // DON'T RETURN <NEW_NODE>\n          owner = serverList.get(1);\n      }\n    } else\n      // RETURN THE OWNER OF *\n      return getClusterOwner(ALL_WILDCARD);\n\n    return owner;\n  }", "language": "java", "code": "public String getClusterOwner(final String iClusterName) {\n    String owner;\n\n    final ODocument clusters = getConfiguredClusters();\n\n    // GET THE CLUSTER CFG\n    final ODocument cfg = iClusterName != null ? (ODocument) clusters.field(iClusterName) : null;\n\n    if (cfg != null) {\n      owner = cfg.field(OWNER);\n      if (owner != null)\n        return owner;\n\n      final List<String> serverList = cfg.field(SERVERS);\n      if (serverList != null && !serverList.isEmpty()) {\n        // RETURN THE FIRST ONE\n        owner = serverList.get(0);\n        if (NEW_NODE_TAG.equals(owner) && serverList.size() > 1)\n          // DON'T RETURN <NEW_NODE>\n          owner = serverList.get(1);\n      }\n    } else\n      // RETURN THE OWNER OF *\n      return getClusterOwner(ALL_WILDCARD);\n\n    return owner;\n  }", "code_tokens": ["public", "String", "getClusterOwner", "(", "final", "String", "iClusterName", ")", "{", "String", "owner", ";", "final", "ODocument", "clusters", "=", "getConfiguredClusters", "(", ")", ";", "// GET THE CLUSTER CFG", "final", "ODocument", "cfg", "=", "iClusterName", "!=", "null", "?", "(", "ODocument", ")", "clusters", ".", "field", "(", "iClusterName", ")", ":", "null", ";", "if", "(", "cfg", "!=", "null", ")", "{", "owner", "=", "cfg", ".", "field", "(", "OWNER", ")", ";", "if", "(", "owner", "!=", "null", ")", "return", "owner", ";", "final", "List", "<", "String", ">", "serverList", "=", "cfg", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", "&&", "!", "serverList", ".", "isEmpty", "(", ")", ")", "{", "// RETURN THE FIRST ONE", "owner", "=", "serverList", ".", "get", "(", "0", ")", ";", "if", "(", "NEW_NODE_TAG", ".", "equals", "(", "owner", ")", "&&", "serverList", ".", "size", "(", ")", ">", "1", ")", "// DON'T RETURN <NEW_NODE>", "owner", "=", "serverList", ".", "get", "(", "1", ")", ";", "}", "}", "else", "// RETURN THE OWNER OF *", "return", "getClusterOwner", "(", "ALL_WILDCARD", ")", ";", "return", "owner", ";", "}"], "docstring": "Returns the owner server for the given cluster excluding the passed node. The Owner server is the first in server list.\n\n@param iClusterName Cluster name, or null for *", "docstring_tokens": ["Returns", "the", "owner", "server", "for", "the", "given", "cluster", "excluding", "the", "passed", "node", ".", "The", "Owner", "server", "is", "the", "first", "in", "server", "list", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L448-L474", "partition": "test", "index": 3096, "time": "2016-02-08 13:14:15"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OOrderByOptimizer.java", "func_name": "OOrderByOptimizer.canBeUsedByOrderByAfterFilter", "original_string": "boolean canBeUsedByOrderByAfterFilter(OIndex<?> index, List<String> equalsFilterFields,\n      List<OPair<String, String>> orderedFields) {\n    if (orderedFields.isEmpty())\n      return false;\n\n    if (!index.supportsOrderedIterations())\n      return false;\n\n    final OIndexDefinition definition = index.getDefinition();\n    final List<String> indexFields = definition.getFields();\n    int endIndex = Math.min(indexFields.size(), equalsFilterFields.size());\n\n    final String firstOrder = orderedFields.get(0).getValue();\n\n    //check that all the \"equals\" clauses are a prefix for the index\n    for (int i = 0; i < endIndex; i++) {\n      final String equalsFieldName = equalsFilterFields.get(i);\n      final String indexFieldName = indexFields.get(i);\n      if (!equalsFieldName.equals(indexFieldName))\n        return false;\n    }\n\n    endIndex = Math.min(indexFields.size(), orderedFields.size() + equalsFilterFields.size());\n    if (endIndex == equalsFilterFields.size()) {\n      //the index is used only for filtering\n      return false;\n    }\n    //check that after that prefix there all the Order By fields in the right order\n    for (int i = equalsFilterFields.size(); i < endIndex; i++) {\n      int fieldOrderInOrderByClause = i - equalsFilterFields.size();\n      final OPair<String, String> pair = orderedFields.get(fieldOrderInOrderByClause);\n\n      if (!firstOrder.equals(pair.getValue()))\n        return false;\n\n      final String orderFieldName = pair.getKey();\n      final String indexFieldName = indexFields.get(i);\n\n      if (!orderFieldName.equals(indexFieldName))\n        return false;\n    }\n\n    return true;\n  }", "language": "java", "code": "boolean canBeUsedByOrderByAfterFilter(OIndex<?> index, List<String> equalsFilterFields,\n      List<OPair<String, String>> orderedFields) {\n    if (orderedFields.isEmpty())\n      return false;\n\n    if (!index.supportsOrderedIterations())\n      return false;\n\n    final OIndexDefinition definition = index.getDefinition();\n    final List<String> indexFields = definition.getFields();\n    int endIndex = Math.min(indexFields.size(), equalsFilterFields.size());\n\n    final String firstOrder = orderedFields.get(0).getValue();\n\n    //check that all the \"equals\" clauses are a prefix for the index\n    for (int i = 0; i < endIndex; i++) {\n      final String equalsFieldName = equalsFilterFields.get(i);\n      final String indexFieldName = indexFields.get(i);\n      if (!equalsFieldName.equals(indexFieldName))\n        return false;\n    }\n\n    endIndex = Math.min(indexFields.size(), orderedFields.size() + equalsFilterFields.size());\n    if (endIndex == equalsFilterFields.size()) {\n      //the index is used only for filtering\n      return false;\n    }\n    //check that after that prefix there all the Order By fields in the right order\n    for (int i = equalsFilterFields.size(); i < endIndex; i++) {\n      int fieldOrderInOrderByClause = i - equalsFilterFields.size();\n      final OPair<String, String> pair = orderedFields.get(fieldOrderInOrderByClause);\n\n      if (!firstOrder.equals(pair.getValue()))\n        return false;\n\n      final String orderFieldName = pair.getKey();\n      final String indexFieldName = indexFields.get(i);\n\n      if (!orderFieldName.equals(indexFieldName))\n        return false;\n    }\n\n    return true;\n  }", "code_tokens": ["boolean", "canBeUsedByOrderByAfterFilter", "(", "OIndex", "<", "?", ">", "index", ",", "List", "<", "String", ">", "equalsFilterFields", ",", "List", "<", "OPair", "<", "String", ",", "String", ">", ">", "orderedFields", ")", "{", "if", "(", "orderedFields", ".", "isEmpty", "(", ")", ")", "return", "false", ";", "if", "(", "!", "index", ".", "supportsOrderedIterations", "(", ")", ")", "return", "false", ";", "final", "OIndexDefinition", "definition", "=", "index", ".", "getDefinition", "(", ")", ";", "final", "List", "<", "String", ">", "indexFields", "=", "definition", ".", "getFields", "(", ")", ";", "int", "endIndex", "=", "Math", ".", "min", "(", "indexFields", ".", "size", "(", ")", ",", "equalsFilterFields", ".", "size", "(", ")", ")", ";", "final", "String", "firstOrder", "=", "orderedFields", ".", "get", "(", "0", ")", ".", "getValue", "(", ")", ";", "//check that all the \"equals\" clauses are a prefix for the index", "for", "(", "int", "i", "=", "0", ";", "i", "<", "endIndex", ";", "i", "++", ")", "{", "final", "String", "equalsFieldName", "=", "equalsFilterFields", ".", "get", "(", "i", ")", ";", "final", "String", "indexFieldName", "=", "indexFields", ".", "get", "(", "i", ")", ";", "if", "(", "!", "equalsFieldName", ".", "equals", "(", "indexFieldName", ")", ")", "return", "false", ";", "}", "endIndex", "=", "Math", ".", "min", "(", "indexFields", ".", "size", "(", ")", ",", "orderedFields", ".", "size", "(", ")", "+", "equalsFilterFields", ".", "size", "(", ")", ")", ";", "if", "(", "endIndex", "==", "equalsFilterFields", ".", "size", "(", ")", ")", "{", "//the index is used only for filtering", "return", "false", ";", "}", "//check that after that prefix there all the Order By fields in the right order", "for", "(", "int", "i", "=", "equalsFilterFields", ".", "size", "(", ")", ";", "i", "<", "endIndex", ";", "i", "++", ")", "{", "int", "fieldOrderInOrderByClause", "=", "i", "-", "equalsFilterFields", ".", "size", "(", ")", ";", "final", "OPair", "<", "String", ",", "String", ">", "pair", "=", "orderedFields", ".", "get", "(", "fieldOrderInOrderByClause", ")", ";", "if", "(", "!", "firstOrder", ".", "equals", "(", "pair", ".", "getValue", "(", ")", ")", ")", "return", "false", ";", "final", "String", "orderFieldName", "=", "pair", ".", "getKey", "(", ")", ";", "final", "String", "indexFieldName", "=", "indexFields", ".", "get", "(", "i", ")", ";", "if", "(", "!", "orderFieldName", ".", "equals", "(", "indexFieldName", ")", ")", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "checks if, given a list of \"=\" conditions and a set of ORDER BY fields\n\n@param index\n@param equalsFilterFields\n@param orderedFields\n@return", "docstring_tokens": ["checks", "if", "given", "a", "list", "of", "=", "conditions", "and", "a", "set", "of", "ORDER", "BY", "fields"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OOrderByOptimizer.java#L69-L112", "partition": "test", "index": 3158, "time": "2016-02-11 12:28:06"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/index/OIndexChangesWrapper.java", "func_name": "OIndexChangesWrapper.wrap", "original_string": "public static OIndexCursor wrap(OIndex<?> source, OIndexCursor cursor, long indexRebuildVersion) {\n    if (cursor instanceof OIndexChangesWrapper)\n      return cursor;\n\n    if (cursor instanceof OSizeable) {\n      return new OIndexChangesSizeable(source, cursor, indexRebuildVersion);\n    }\n\n    return new OIndexChangesWrapper(source, cursor, indexRebuildVersion);\n  }", "language": "java", "code": "public static OIndexCursor wrap(OIndex<?> source, OIndexCursor cursor, long indexRebuildVersion) {\n    if (cursor instanceof OIndexChangesWrapper)\n      return cursor;\n\n    if (cursor instanceof OSizeable) {\n      return new OIndexChangesSizeable(source, cursor, indexRebuildVersion);\n    }\n\n    return new OIndexChangesWrapper(source, cursor, indexRebuildVersion);\n  }", "code_tokens": ["public", "static", "OIndexCursor", "wrap", "(", "OIndex", "<", "?", ">", "source", ",", "OIndexCursor", "cursor", ",", "long", "indexRebuildVersion", ")", "{", "if", "(", "cursor", "instanceof", "OIndexChangesWrapper", ")", "return", "cursor", ";", "if", "(", "cursor", "instanceof", "OSizeable", ")", "{", "return", "new", "OIndexChangesSizeable", "(", "source", ",", "cursor", ",", "indexRebuildVersion", ")", ";", "}", "return", "new", "OIndexChangesWrapper", "(", "source", ",", "cursor", ",", "indexRebuildVersion", ")", ";", "}"], "docstring": "Wraps courser only if it is not already wrapped.\n\n@param source              Index which is used to create given cursor.\n@param cursor              Cursor to wrap.\n@param indexRebuildVersion Rebuild version of index <b>before</b> cursor was created.\n@return Wrapped cursor.\n@see OIndex#getRebuildVersion()", "docstring_tokens": ["Wraps", "courser", "only", "if", "it", "is", "not", "already", "wrapped", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/index/OIndexChangesWrapper.java#L39-L48", "partition": "test", "index": 3070, "time": "2016-03-09 14:04:28"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getWriteQuorum", "original_string": "public int getWriteQuorum(final String clusterName, final int totalConfiguredMasterServers, final String server) {\n    Integer overWrite = overwriteWriteQuorum.get();\n    if (overWrite != null)\n      return overWrite.intValue();\n    else\n      return getQuorum(\"writeQuorum\", clusterName, totalConfiguredMasterServers, DEFAULT_WRITE_QUORUM, server);\n  }", "language": "java", "code": "public int getWriteQuorum(final String clusterName, final int totalConfiguredMasterServers, final String server) {\n    Integer overWrite = overwriteWriteQuorum.get();\n    if (overWrite != null)\n      return overWrite.intValue();\n    else\n      return getQuorum(\"writeQuorum\", clusterName, totalConfiguredMasterServers, DEFAULT_WRITE_QUORUM, server);\n  }", "code_tokens": ["public", "int", "getWriteQuorum", "(", "final", "String", "clusterName", ",", "final", "int", "totalConfiguredMasterServers", ",", "final", "String", "server", ")", "{", "Integer", "overWrite", "=", "overwriteWriteQuorum", ".", "get", "(", ")", ";", "if", "(", "overWrite", "!=", "null", ")", "return", "overWrite", ".", "intValue", "(", ")", ";", "else", "return", "getQuorum", "(", "\"writeQuorum\"", ",", "clusterName", ",", "totalConfiguredMasterServers", ",", "DEFAULT_WRITE_QUORUM", ",", "server", ")", ";", "}"], "docstring": "Returns the write quorum.\n\n@param clusterName                  Cluster name, or null for *\n@param totalConfiguredMasterServers Total node available", "docstring_tokens": ["Returns", "the", "write", "quorum", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L716-L722", "partition": "test", "index": 3106, "time": "2016-03-10 11:00:14"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getClustersOwnedByServer", "original_string": "public Set<String> getClustersOwnedByServer(final String iNodeName) {\n    final Set<String> clusters = new HashSet<String>();\n    for (String cl : getClusterNames()) {\n      if (iNodeName.equals(getClusterOwner(cl)))\n        clusters.add(cl);\n    }\n    return clusters;\n  }", "language": "java", "code": "public Set<String> getClustersOwnedByServer(final String iNodeName) {\n    final Set<String> clusters = new HashSet<String>();\n    for (String cl : getClusterNames()) {\n      if (iNodeName.equals(getClusterOwner(cl)))\n        clusters.add(cl);\n    }\n    return clusters;\n  }", "code_tokens": ["public", "Set", "<", "String", ">", "getClustersOwnedByServer", "(", "final", "String", "iNodeName", ")", "{", "final", "Set", "<", "String", ">", "clusters", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "for", "(", "String", "cl", ":", "getClusterNames", "(", ")", ")", "{", "if", "(", "iNodeName", ".", "equals", "(", "getClusterOwner", "(", "cl", ")", ")", ")", "clusters", ".", "add", "(", "cl", ")", ";", "}", "return", "clusters", ";", "}"], "docstring": "Returns the set of clusters where server is the owner.\n\n@param iNodeName Server name", "docstring_tokens": ["Returns", "the", "set", "of", "clusters", "where", "server", "is", "the", "owner", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L434-L441", "partition": "test", "index": 3095, "time": "2016-03-11 20:06:42"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageConfigurationSegment.java", "func_name": "OStorageConfigurationSegment.clearConfigurationFiles", "original_string": "private void clearConfigurationFiles() throws IOException {\r\n    final Path file = storagePath.resolve(NAME);\r\n    Files.deleteIfExists(file);\r\n\r\n    final Path backupFile = storagePath.resolve(BACKUP_NAME);\r\n    Files.deleteIfExists(backupFile);\r\n  }", "language": "java", "code": "private void clearConfigurationFiles() throws IOException {\r\n    final Path file = storagePath.resolve(NAME);\r\n    Files.deleteIfExists(file);\r\n\r\n    final Path backupFile = storagePath.resolve(BACKUP_NAME);\r\n    Files.deleteIfExists(backupFile);\r\n  }", "code_tokens": ["private", "void", "clearConfigurationFiles", "(", ")", "throws", "IOException", "{", "final", "Path", "file", "=", "storagePath", ".", "resolve", "(", "NAME", ")", ";", "Files", ".", "deleteIfExists", "(", "file", ")", ";", "final", "Path", "backupFile", "=", "storagePath", ".", "resolve", "(", "BACKUP_NAME", ")", ";", "Files", ".", "deleteIfExists", "(", "backupFile", ")", ";", "}"], "docstring": "Remove both backup and primary configuration files on delete\n\n@see #update()", "docstring_tokens": ["Remove", "both", "backup", "and", "primary", "configuration", "files", "on", "delete"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageConfigurationSegment.java#L99-L105", "partition": "test", "index": 3340, "time": "2016-03-14 01:41:53"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/binary/OChannelBinaryAsynchClient.java", "func_name": "OChannelBinaryAsynchClient.isConnected", "original_string": "public boolean isConnected() {\n    final Socket s = socket;\n    return s != null && !s.isClosed() && s.isConnected() && !s.isInputShutdown() && !s.isOutputShutdown();\n  }", "language": "java", "code": "public boolean isConnected() {\n    final Socket s = socket;\n    return s != null && !s.isClosed() && s.isConnected() && !s.isInputShutdown() && !s.isOutputShutdown();\n  }", "code_tokens": ["public", "boolean", "isConnected", "(", ")", "{", "final", "Socket", "s", "=", "socket", ";", "return", "s", "!=", "null", "&&", "!", "s", ".", "isClosed", "(", ")", "&&", "s", ".", "isConnected", "(", ")", "&&", "!", "s", ".", "isInputShutdown", "(", ")", "&&", "!", "s", ".", "isOutputShutdown", "(", ")", ";", "}"], "docstring": "Tells if the channel is connected.\n\n@return true if it's connected, otherwise false.", "docstring_tokens": ["Tells", "if", "the", "channel", "is", "connected", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/binary/OChannelBinaryAsynchClient.java#L246-L249", "partition": "test", "index": 2949, "time": "2016-03-24 02:44:02"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java", "func_name": "OPerformanceStatisticManager.stopMonitoring", "original_string": "public void stopMonitoring() {\n    switchLock.acquireWriteLock();\n    try {\n      enabled = false;\n\n      final PerformanceCountersHolder countersHolder = ComponentType.GENERAL.newCountersHolder();\n      final Map<String, PerformanceCountersHolder> componentCountersHolder = new HashMap<>();\n\n      WritCacheCountersHolder writCacheCountersHolder = deadThreadsStatistic.writCacheCountersHolder;\n      StorageCountersHolder storageCountersHolder = deadThreadsStatistic.storageCountersHolder;\n      WALCountersHolder walCountersHolder = deadThreadsStatistic.walCountersHolder;\n\n      deadThreadsStatistic.countersHolder.pushData(countersHolder);\n      componentCountersHolder.putAll(deadThreadsStatistic.countersByComponents);\n\n      deadThreadsStatistic = null;\n\n      for (OSessionStoragePerformanceStatistic statistic : statistics.values()) {\n        statistic.pushSystemCounters(countersHolder);\n        statistic.pushComponentCounters(componentCountersHolder);\n        writCacheCountersHolder = statistic.pushWriteCacheCounters(writCacheCountersHolder);\n        storageCountersHolder = statistic.pushStorageCounters(storageCountersHolder);\n        walCountersHolder = statistic.pushWALCounters(walCountersHolder);\n      }\n\n      statistics.clear();\n\n      postMeasurementStatistic = new ImmutableStatistic(countersHolder, componentCountersHolder, writCacheCountersHolder,\n          storageCountersHolder, walCountersHolder);\n    } finally {\n      switchLock.releaseWriteLock();\n    }\n  }", "language": "java", "code": "public void stopMonitoring() {\n    switchLock.acquireWriteLock();\n    try {\n      enabled = false;\n\n      final PerformanceCountersHolder countersHolder = ComponentType.GENERAL.newCountersHolder();\n      final Map<String, PerformanceCountersHolder> componentCountersHolder = new HashMap<>();\n\n      WritCacheCountersHolder writCacheCountersHolder = deadThreadsStatistic.writCacheCountersHolder;\n      StorageCountersHolder storageCountersHolder = deadThreadsStatistic.storageCountersHolder;\n      WALCountersHolder walCountersHolder = deadThreadsStatistic.walCountersHolder;\n\n      deadThreadsStatistic.countersHolder.pushData(countersHolder);\n      componentCountersHolder.putAll(deadThreadsStatistic.countersByComponents);\n\n      deadThreadsStatistic = null;\n\n      for (OSessionStoragePerformanceStatistic statistic : statistics.values()) {\n        statistic.pushSystemCounters(countersHolder);\n        statistic.pushComponentCounters(componentCountersHolder);\n        writCacheCountersHolder = statistic.pushWriteCacheCounters(writCacheCountersHolder);\n        storageCountersHolder = statistic.pushStorageCounters(storageCountersHolder);\n        walCountersHolder = statistic.pushWALCounters(walCountersHolder);\n      }\n\n      statistics.clear();\n\n      postMeasurementStatistic = new ImmutableStatistic(countersHolder, componentCountersHolder, writCacheCountersHolder,\n          storageCountersHolder, walCountersHolder);\n    } finally {\n      switchLock.releaseWriteLock();\n    }\n  }", "code_tokens": ["public", "void", "stopMonitoring", "(", ")", "{", "switchLock", ".", "acquireWriteLock", "(", ")", ";", "try", "{", "enabled", "=", "false", ";", "final", "PerformanceCountersHolder", "countersHolder", "=", "ComponentType", ".", "GENERAL", ".", "newCountersHolder", "(", ")", ";", "final", "Map", "<", "String", ",", "PerformanceCountersHolder", ">", "componentCountersHolder", "=", "new", "HashMap", "<>", "(", ")", ";", "WritCacheCountersHolder", "writCacheCountersHolder", "=", "deadThreadsStatistic", ".", "writCacheCountersHolder", ";", "StorageCountersHolder", "storageCountersHolder", "=", "deadThreadsStatistic", ".", "storageCountersHolder", ";", "WALCountersHolder", "walCountersHolder", "=", "deadThreadsStatistic", ".", "walCountersHolder", ";", "deadThreadsStatistic", ".", "countersHolder", ".", "pushData", "(", "countersHolder", ")", ";", "componentCountersHolder", ".", "putAll", "(", "deadThreadsStatistic", ".", "countersByComponents", ")", ";", "deadThreadsStatistic", "=", "null", ";", "for", "(", "OSessionStoragePerformanceStatistic", "statistic", ":", "statistics", ".", "values", "(", ")", ")", "{", "statistic", ".", "pushSystemCounters", "(", "countersHolder", ")", ";", "statistic", ".", "pushComponentCounters", "(", "componentCountersHolder", ")", ";", "writCacheCountersHolder", "=", "statistic", ".", "pushWriteCacheCounters", "(", "writCacheCountersHolder", ")", ";", "storageCountersHolder", "=", "statistic", ".", "pushStorageCounters", "(", "storageCountersHolder", ")", ";", "walCountersHolder", "=", "statistic", ".", "pushWALCounters", "(", "walCountersHolder", ")", ";", "}", "statistics", ".", "clear", "(", ")", ";", "postMeasurementStatistic", "=", "new", "ImmutableStatistic", "(", "countersHolder", ",", "componentCountersHolder", ",", "writCacheCountersHolder", ",", "storageCountersHolder", ",", "walCountersHolder", ")", ";", "}", "finally", "{", "switchLock", ".", "releaseWriteLock", "(", ")", ";", "}", "}"], "docstring": "Stops monitoring of performance statistic for whole system.", "docstring_tokens": ["Stops", "monitoring", "of", "performance", "statistic", "for", "whole", "system", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java#L354-L386", "partition": "test", "index": 3131, "time": "2016-03-24 10:40:01"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.pushComponentCounters", "original_string": "public void pushComponentCounters(Map<String, PerformanceCountersHolder> counters) {\n    if (snapshot == null)\n      return;\n\n    for (Map.Entry<String, PerformanceCountersHolder> entry : snapshot.countersByComponent.entrySet()) {\n      final String componentName = entry.getKey();\n\n      PerformanceCountersHolder holder = counters.computeIfAbsent(componentName, k -> entry.getValue().newInstance());\n\n      entry.getValue().pushData(holder);\n    }\n  }", "language": "java", "code": "public void pushComponentCounters(Map<String, PerformanceCountersHolder> counters) {\n    if (snapshot == null)\n      return;\n\n    for (Map.Entry<String, PerformanceCountersHolder> entry : snapshot.countersByComponent.entrySet()) {\n      final String componentName = entry.getKey();\n\n      PerformanceCountersHolder holder = counters.computeIfAbsent(componentName, k -> entry.getValue().newInstance());\n\n      entry.getValue().pushData(holder);\n    }\n  }", "code_tokens": ["public", "void", "pushComponentCounters", "(", "Map", "<", "String", ",", "PerformanceCountersHolder", ">", "counters", ")", "{", "if", "(", "snapshot", "==", "null", ")", "return", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "PerformanceCountersHolder", ">", "entry", ":", "snapshot", ".", "countersByComponent", ".", "entrySet", "(", ")", ")", "{", "final", "String", "componentName", "=", "entry", ".", "getKey", "(", ")", ";", "PerformanceCountersHolder", "holder", "=", "counters", ".", "computeIfAbsent", "(", "componentName", ",", "k", "->", "entry", ".", "getValue", "(", ")", ".", "newInstance", "(", ")", ")", ";", "entry", ".", "getValue", "(", ")", ".", "pushData", "(", "holder", ")", ";", "}", "}"], "docstring": "Takes performance data are split by components from last snapshot and aggregates them with data passed inside method as\nparameter. Result of aggregation of performance data is returned inside of passed in performance data.\n\n@param counters Performance data for each component.", "docstring_tokens": ["Takes", "performance", "data", "are", "split", "by", "components", "from", "last", "snapshot", "and", "aggregates", "them", "with", "data", "passed", "inside", "method", "as", "parameter", ".", "Result", "of", "aggregation", "of", "performance", "data", "is", "returned", "inside", "of", "passed", "in", "performance", "data", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L446-L457", "partition": "test", "index": 3052, "time": "2016-03-24 10:40:01"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.pushComponentCounters", "original_string": "public void pushComponentCounters(String name, PerformanceCountersHolder holder) {\n    if (snapshot == null)\n      return;\n\n    final PerformanceCountersHolder countersHolder = snapshot.countersByComponent.get(name);\n\n    if (countersHolder != null) {\n      countersHolder.pushData(holder);\n    }\n  }", "language": "java", "code": "public void pushComponentCounters(String name, PerformanceCountersHolder holder) {\n    if (snapshot == null)\n      return;\n\n    final PerformanceCountersHolder countersHolder = snapshot.countersByComponent.get(name);\n\n    if (countersHolder != null) {\n      countersHolder.pushData(holder);\n    }\n  }", "code_tokens": ["public", "void", "pushComponentCounters", "(", "String", "name", ",", "PerformanceCountersHolder", "holder", ")", "{", "if", "(", "snapshot", "==", "null", ")", "return", ";", "final", "PerformanceCountersHolder", "countersHolder", "=", "snapshot", ".", "countersByComponent", ".", "get", "(", "name", ")", ";", "if", "(", "countersHolder", "!=", "null", ")", "{", "countersHolder", ".", "pushData", "(", "holder", ")", ";", "}", "}"], "docstring": "Takes performance data for component from last snapshot and aggregates them with data passed inside method as parameter. Result\nof aggregation of performance data is returned inside of passed in performance data.\n\n@param name   Name of component for which performance data are gathered.\n@param holder Performance data for given component.", "docstring_tokens": ["Takes", "performance", "data", "for", "component", "from", "last", "snapshot", "and", "aggregates", "them", "with", "data", "passed", "inside", "method", "as", "parameter", ".", "Result", "of", "aggregation", "of", "performance", "data", "is", "returned", "inside", "of", "passed", "in", "performance", "data", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L549-L558", "partition": "test", "index": 3056, "time": "2016-03-24 10:40:01"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java", "func_name": "OPerformanceStatisticManager.fetchComponentCounters", "original_string": "private void fetchComponentCounters(String componentName, PerformanceCountersHolder componentCountersHolder) {\n    //go through all threads and accumulate statistic only for live threads\n    //all dead threads will be removed and statistics from them will be\n    //later accumulated in #deadThreadsStatistic field, then result statistic from this field\n    //will be aggregated to componentCountersHolder\n\n    //To decrease inter thread communication delay we fetch snapshots first\n    //and only after that we aggregate data from immutable snapshots\n    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());\n\n    final List<Thread> threadsToRemove = new ArrayList<>();\n    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {\n      final Thread thread = entry.getKey();\n      final OSessionStoragePerformanceStatistic statistic = entry.getValue();\n      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));\n    }\n\n    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {\n      final Thread thread = pair.getFirst();\n      if (thread.isAlive()) {\n        final PerformanceSnapshot snapshot = pair.getSecond();\n        final PerformanceCountersHolder holder = snapshot.countersByComponent.get(componentName);\n        if (holder != null)\n          holder.pushData(componentCountersHolder);\n      } else {\n        threadsToRemove.add(thread);\n      }\n    }\n\n    if (!threadsToRemove.isEmpty()) {\n      updateDeadThreadsStatistic(threadsToRemove);\n    }\n\n    final ImmutableStatistic ds = deadThreadsStatistic;\n    if (ds != null) {\n      final PerformanceCountersHolder dch = ds.countersByComponents.get(componentName);\n      if (dch != null) {\n        dch.pushData(componentCountersHolder);\n      }\n    }\n  }", "language": "java", "code": "private void fetchComponentCounters(String componentName, PerformanceCountersHolder componentCountersHolder) {\n    //go through all threads and accumulate statistic only for live threads\n    //all dead threads will be removed and statistics from them will be\n    //later accumulated in #deadThreadsStatistic field, then result statistic from this field\n    //will be aggregated to componentCountersHolder\n\n    //To decrease inter thread communication delay we fetch snapshots first\n    //and only after that we aggregate data from immutable snapshots\n    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());\n\n    final List<Thread> threadsToRemove = new ArrayList<>();\n    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {\n      final Thread thread = entry.getKey();\n      final OSessionStoragePerformanceStatistic statistic = entry.getValue();\n      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));\n    }\n\n    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {\n      final Thread thread = pair.getFirst();\n      if (thread.isAlive()) {\n        final PerformanceSnapshot snapshot = pair.getSecond();\n        final PerformanceCountersHolder holder = snapshot.countersByComponent.get(componentName);\n        if (holder != null)\n          holder.pushData(componentCountersHolder);\n      } else {\n        threadsToRemove.add(thread);\n      }\n    }\n\n    if (!threadsToRemove.isEmpty()) {\n      updateDeadThreadsStatistic(threadsToRemove);\n    }\n\n    final ImmutableStatistic ds = deadThreadsStatistic;\n    if (ds != null) {\n      final PerformanceCountersHolder dch = ds.countersByComponents.get(componentName);\n      if (dch != null) {\n        dch.pushData(componentCountersHolder);\n      }\n    }\n  }", "code_tokens": ["private", "void", "fetchComponentCounters", "(", "String", "componentName", ",", "PerformanceCountersHolder", "componentCountersHolder", ")", "{", "//go through all threads and accumulate statistic only for live threads", "//all dead threads will be removed and statistics from them will be", "//later accumulated in #deadThreadsStatistic field, then result statistic from this field", "//will be aggregated to componentCountersHolder", "//To decrease inter thread communication delay we fetch snapshots first", "//and only after that we aggregate data from immutable snapshots", "final", "Collection", "<", "ORawPair", "<", "Thread", ",", "PerformanceSnapshot", ">", ">", "snapshots", "=", "new", "ArrayList", "<>", "(", "statistics", ".", "size", "(", ")", ")", ";", "final", "List", "<", "Thread", ">", "threadsToRemove", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "Thread", ",", "OSessionStoragePerformanceStatistic", ">", "entry", ":", "statistics", ".", "entrySet", "(", ")", ")", "{", "final", "Thread", "thread", "=", "entry", ".", "getKey", "(", ")", ";", "final", "OSessionStoragePerformanceStatistic", "statistic", "=", "entry", ".", "getValue", "(", ")", ";", "snapshots", ".", "add", "(", "new", "ORawPair", "<>", "(", "thread", ",", "statistic", ".", "getSnapshot", "(", ")", ")", ")", ";", "}", "for", "(", "ORawPair", "<", "Thread", ",", "PerformanceSnapshot", ">", "pair", ":", "snapshots", ")", "{", "final", "Thread", "thread", "=", "pair", ".", "getFirst", "(", ")", ";", "if", "(", "thread", ".", "isAlive", "(", ")", ")", "{", "final", "PerformanceSnapshot", "snapshot", "=", "pair", ".", "getSecond", "(", ")", ";", "final", "PerformanceCountersHolder", "holder", "=", "snapshot", ".", "countersByComponent", ".", "get", "(", "componentName", ")", ";", "if", "(", "holder", "!=", "null", ")", "holder", ".", "pushData", "(", "componentCountersHolder", ")", ";", "}", "else", "{", "threadsToRemove", ".", "add", "(", "thread", ")", ";", "}", "}", "if", "(", "!", "threadsToRemove", ".", "isEmpty", "(", ")", ")", "{", "updateDeadThreadsStatistic", "(", "threadsToRemove", ")", ";", "}", "final", "ImmutableStatistic", "ds", "=", "deadThreadsStatistic", ";", "if", "(", "ds", "!=", "null", ")", "{", "final", "PerformanceCountersHolder", "dch", "=", "ds", ".", "countersByComponents", ".", "get", "(", "componentName", ")", ";", "if", "(", "dch", "!=", "null", ")", "{", "dch", ".", "pushData", "(", "componentCountersHolder", ")", ";", "}", "}", "}"], "docstring": "Iterates over all live threads and accumulates performance statics gathered form threads for provided component,\nalso accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.\n\n@param componentCountersHolder Holder which is used to accumulate all performance statistic data for given component\n@param componentName           Name of component", "docstring_tokens": ["Iterates", "over", "all", "live", "threads", "and", "accumulates", "performance", "statics", "gathered", "form", "threads", "for", "provided", "component", "also", "accumulates", "statistic", "from", "dead", "threads", "which", "were", "alive", "when", "when", "gathering", "of", "performance", "measurements", "is", "started", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java#L1335-L1375", "partition": "test", "index": 3136, "time": "2016-03-24 10:40:01"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.createEdgeType", "original_string": "public OrientEdgeType createEdgeType(final String iClassName, final int clusters) {\n    makeActive();\n    return createEdgeType(iClassName, (String) null, clusters);\n  }", "language": "java", "code": "public OrientEdgeType createEdgeType(final String iClassName, final int clusters) {\n    makeActive();\n    return createEdgeType(iClassName, (String) null, clusters);\n  }", "code_tokens": ["public", "OrientEdgeType", "createEdgeType", "(", "final", "String", "iClassName", ",", "final", "int", "clusters", ")", "{", "makeActive", "(", ")", ";", "return", "createEdgeType", "(", "iClassName", ",", "(", "String", ")", "null", ",", "clusters", ")", ";", "}"], "docstring": "Creates a new Edge persistent class.\n\n@param iClassName Edge class name\n@param clusters   The number of clusters to create for the new class. By default the MINIMUMCLUSTERS database setting is used.\nIn v2.2 and later, the number of clusters are proportioned to the amount of cores found on the machine\n\n@return OrientEdgeType instance representing the persistent class", "docstring_tokens": ["Creates", "a", "new", "Edge", "persistent", "class", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1455-L1458", "partition": "test", "index": 3125, "time": "2016-03-25 12:43:24"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java", "func_name": "OrientBaseGraph.createVertexType", "original_string": "public OrientVertexType createVertexType(final String iClassName, final int clusters) {\n    makeActive();\n    return createVertexType(iClassName, (String) null, clusters);\n  }", "language": "java", "code": "public OrientVertexType createVertexType(final String iClassName, final int clusters) {\n    makeActive();\n    return createVertexType(iClassName, (String) null, clusters);\n  }", "code_tokens": ["public", "OrientVertexType", "createVertexType", "(", "final", "String", "iClassName", ",", "final", "int", "clusters", ")", "{", "makeActive", "(", ")", ";", "return", "createVertexType", "(", "iClassName", ",", "(", "String", ")", "null", ",", "clusters", ")", ";", "}"], "docstring": "Creates a new Vertex persistent class.\n\n@param iClassName Vertex class name\n@param clusters   The number of clusters to create for the new class. By default the MINIMUMCLUSTERS database setting is used.\nIn v2.2 and later, the number of clusters are proportioned to the amount of cores found on the machine\n\n@return OrientVertexType instance representing the persistent class", "docstring_tokens": ["Creates", "a", "new", "Vertex", "persistent", "class", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientBaseGraph.java#L1313-L1316", "partition": "test", "index": 3122, "time": "2016-03-25 12:43:24"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java", "func_name": "OPerformanceStatisticManager.fetchSystemCounters", "original_string": "private void fetchSystemCounters(PerformanceCountersHolder countersHolder) {\n    //go through all threads and accumulate statistic only for live threads\n    //all dead threads will be removed and statistics from them will be\n    //later accumulated in #deadThreadsStatistic field, then result statistic from this field\n    //will be aggregated to countersHolder\n\n    //To decrease inter thread communication delay we fetch snapshots first\n    //and only after that we aggregate data from immutable snapshots\n    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());\n\n    final Collection<Thread> threadsToRemove = new ArrayList<>();\n    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {\n      final Thread thread = entry.getKey();\n      final OSessionStoragePerformanceStatistic statistic = entry.getValue();\n      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));\n    }\n\n    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {\n      final Thread thread = pair.getFirst();\n\n      if (thread.isAlive()) {\n        final PerformanceSnapshot snapshot = pair.getSecond();\n        snapshot.performanceCountersHolder.pushData(countersHolder);\n      } else {\n        threadsToRemove.add(thread);\n      }\n    }\n\n    if (!threadsToRemove.isEmpty()) {\n      updateDeadThreadsStatistic(threadsToRemove);\n    }\n\n    final ImmutableStatistic ds = deadThreadsStatistic;\n    if (ds != null) {\n      final PerformanceCountersHolder dch = ds.countersHolder;\n      dch.pushData(countersHolder);\n    }\n  }", "language": "java", "code": "private void fetchSystemCounters(PerformanceCountersHolder countersHolder) {\n    //go through all threads and accumulate statistic only for live threads\n    //all dead threads will be removed and statistics from them will be\n    //later accumulated in #deadThreadsStatistic field, then result statistic from this field\n    //will be aggregated to countersHolder\n\n    //To decrease inter thread communication delay we fetch snapshots first\n    //and only after that we aggregate data from immutable snapshots\n    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());\n\n    final Collection<Thread> threadsToRemove = new ArrayList<>();\n    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {\n      final Thread thread = entry.getKey();\n      final OSessionStoragePerformanceStatistic statistic = entry.getValue();\n      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));\n    }\n\n    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {\n      final Thread thread = pair.getFirst();\n\n      if (thread.isAlive()) {\n        final PerformanceSnapshot snapshot = pair.getSecond();\n        snapshot.performanceCountersHolder.pushData(countersHolder);\n      } else {\n        threadsToRemove.add(thread);\n      }\n    }\n\n    if (!threadsToRemove.isEmpty()) {\n      updateDeadThreadsStatistic(threadsToRemove);\n    }\n\n    final ImmutableStatistic ds = deadThreadsStatistic;\n    if (ds != null) {\n      final PerformanceCountersHolder dch = ds.countersHolder;\n      dch.pushData(countersHolder);\n    }\n  }", "code_tokens": ["private", "void", "fetchSystemCounters", "(", "PerformanceCountersHolder", "countersHolder", ")", "{", "//go through all threads and accumulate statistic only for live threads", "//all dead threads will be removed and statistics from them will be", "//later accumulated in #deadThreadsStatistic field, then result statistic from this field", "//will be aggregated to countersHolder", "//To decrease inter thread communication delay we fetch snapshots first", "//and only after that we aggregate data from immutable snapshots", "final", "Collection", "<", "ORawPair", "<", "Thread", ",", "PerformanceSnapshot", ">", ">", "snapshots", "=", "new", "ArrayList", "<>", "(", "statistics", ".", "size", "(", ")", ")", ";", "final", "Collection", "<", "Thread", ">", "threadsToRemove", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "Thread", ",", "OSessionStoragePerformanceStatistic", ">", "entry", ":", "statistics", ".", "entrySet", "(", ")", ")", "{", "final", "Thread", "thread", "=", "entry", ".", "getKey", "(", ")", ";", "final", "OSessionStoragePerformanceStatistic", "statistic", "=", "entry", ".", "getValue", "(", ")", ";", "snapshots", ".", "add", "(", "new", "ORawPair", "<>", "(", "thread", ",", "statistic", ".", "getSnapshot", "(", ")", ")", ")", ";", "}", "for", "(", "ORawPair", "<", "Thread", ",", "PerformanceSnapshot", ">", "pair", ":", "snapshots", ")", "{", "final", "Thread", "thread", "=", "pair", ".", "getFirst", "(", ")", ";", "if", "(", "thread", ".", "isAlive", "(", ")", ")", "{", "final", "PerformanceSnapshot", "snapshot", "=", "pair", ".", "getSecond", "(", ")", ";", "snapshot", ".", "performanceCountersHolder", ".", "pushData", "(", "countersHolder", ")", ";", "}", "else", "{", "threadsToRemove", ".", "add", "(", "thread", ")", ";", "}", "}", "if", "(", "!", "threadsToRemove", ".", "isEmpty", "(", ")", ")", "{", "updateDeadThreadsStatistic", "(", "threadsToRemove", ")", ";", "}", "final", "ImmutableStatistic", "ds", "=", "deadThreadsStatistic", ";", "if", "(", "ds", "!=", "null", ")", "{", "final", "PerformanceCountersHolder", "dch", "=", "ds", ".", "countersHolder", ";", "dch", ".", "pushData", "(", "countersHolder", ")", ";", "}", "}"], "docstring": "Iterates over all live threads and accumulates performance statics gathered form threads on system level,\nalso accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.\n\n@param countersHolder Holder which is used to accumulate all performance statistic data", "docstring_tokens": ["Iterates", "over", "all", "live", "threads", "and", "accumulates", "performance", "statics", "gathered", "form", "threads", "on", "system", "level", "also", "accumulates", "statistic", "from", "dead", "threads", "which", "were", "alive", "when", "when", "gathering", "of", "performance", "measurements", "is", "started", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java#L1289-L1326", "partition": "test", "index": 3135, "time": "2016-03-25 13:01:39"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedMessageServiceImpl.java", "func_name": "ODistributedMessageServiceImpl.registerDatabase", "original_string": "public ODistributedDatabaseImpl registerDatabase(final String iDatabaseName, ODistributedConfiguration cfg) {\n    final ODistributedDatabaseImpl ddb = databases.get(iDatabaseName);\n    if (ddb != null)\n      return ddb;\n\n    return new ODistributedDatabaseImpl(manager, this, iDatabaseName, cfg, manager.getServerInstance());\n  }", "language": "java", "code": "public ODistributedDatabaseImpl registerDatabase(final String iDatabaseName, ODistributedConfiguration cfg) {\n    final ODistributedDatabaseImpl ddb = databases.get(iDatabaseName);\n    if (ddb != null)\n      return ddb;\n\n    return new ODistributedDatabaseImpl(manager, this, iDatabaseName, cfg, manager.getServerInstance());\n  }", "code_tokens": ["public", "ODistributedDatabaseImpl", "registerDatabase", "(", "final", "String", "iDatabaseName", ",", "ODistributedConfiguration", "cfg", ")", "{", "final", "ODistributedDatabaseImpl", "ddb", "=", "databases", ".", "get", "(", "iDatabaseName", ")", ";", "if", "(", "ddb", "!=", "null", ")", "return", "ddb", ";", "return", "new", "ODistributedDatabaseImpl", "(", "manager", ",", "this", ",", "iDatabaseName", ",", "cfg", ",", "manager", ".", "getServerInstance", "(", ")", ")", ";", "}"], "docstring": "Creates a distributed database instance if not defined yet.", "docstring_tokens": ["Creates", "a", "distributed", "database", "instance", "if", "not", "defined", "yet", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedMessageServiceImpl.java#L144-L150", "partition": "test", "index": 3029, "time": "2016-03-28 03:20:04"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedAbstractPlugin.java", "func_name": "ODistributedAbstractPlugin.onOpen", "original_string": "@Override\n  public void onOpen(final ODatabaseInternal iDatabase) {\n    if (!isRelatedToLocalServer(iDatabase))\n      return;\n\n    if (isOffline() && status != NODE_STATUS.STARTING)\n      return;\n\n    final ODatabaseDocumentInternal currDb = ODatabaseRecordThreadLocal.instance().getIfDefined();\n    try {\n      final String dbName = iDatabase.getName();\n\n      final ODistributedConfiguration cfg = getDatabaseConfiguration(dbName);\n      if (cfg == null)\n        return;\n\n    } catch (HazelcastException e) {\n      throw OException.wrapException(new OOfflineNodeException(\"Hazelcast instance is not available\"), e);\n\n    } catch (HazelcastInstanceNotActiveException e) {\n      throw OException.wrapException(new OOfflineNodeException(\"Hazelcast instance is not available\"), e);\n\n    } finally {\n      // RESTORE ORIGINAL DATABASE INSTANCE IN TL\n      ODatabaseRecordThreadLocal.instance().set(currDb);\n    }\n  }", "language": "java", "code": "@Override\n  public void onOpen(final ODatabaseInternal iDatabase) {\n    if (!isRelatedToLocalServer(iDatabase))\n      return;\n\n    if (isOffline() && status != NODE_STATUS.STARTING)\n      return;\n\n    final ODatabaseDocumentInternal currDb = ODatabaseRecordThreadLocal.instance().getIfDefined();\n    try {\n      final String dbName = iDatabase.getName();\n\n      final ODistributedConfiguration cfg = getDatabaseConfiguration(dbName);\n      if (cfg == null)\n        return;\n\n    } catch (HazelcastException e) {\n      throw OException.wrapException(new OOfflineNodeException(\"Hazelcast instance is not available\"), e);\n\n    } catch (HazelcastInstanceNotActiveException e) {\n      throw OException.wrapException(new OOfflineNodeException(\"Hazelcast instance is not available\"), e);\n\n    } finally {\n      // RESTORE ORIGINAL DATABASE INSTANCE IN TL\n      ODatabaseRecordThreadLocal.instance().set(currDb);\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "onOpen", "(", "final", "ODatabaseInternal", "iDatabase", ")", "{", "if", "(", "!", "isRelatedToLocalServer", "(", "iDatabase", ")", ")", "return", ";", "if", "(", "isOffline", "(", ")", "&&", "status", "!=", "NODE_STATUS", ".", "STARTING", ")", "return", ";", "final", "ODatabaseDocumentInternal", "currDb", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "getIfDefined", "(", ")", ";", "try", "{", "final", "String", "dbName", "=", "iDatabase", ".", "getName", "(", ")", ";", "final", "ODistributedConfiguration", "cfg", "=", "getDatabaseConfiguration", "(", "dbName", ")", ";", "if", "(", "cfg", "==", "null", ")", "return", ";", "}", "catch", "(", "HazelcastException", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OOfflineNodeException", "(", "\"Hazelcast instance is not available\"", ")", ",", "e", ")", ";", "}", "catch", "(", "HazelcastInstanceNotActiveException", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OOfflineNodeException", "(", "\"Hazelcast instance is not available\"", ")", ",", "e", ")", ";", "}", "finally", "{", "// RESTORE ORIGINAL DATABASE INSTANCE IN TL", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "set", "(", "currDb", ")", ";", "}", "}"], "docstring": "Auto register myself as hook.", "docstring_tokens": ["Auto", "register", "myself", "as", "hook", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedAbstractPlugin.java#L348-L374", "partition": "test", "index": 3304, "time": "2016-03-28 03:20:04"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/OSecurityManager.java", "func_name": "OSecurityManager.isAlgorithmSupported", "original_string": "private static boolean isAlgorithmSupported(final String algorithm) {\r\n    // Java 7 specific checks.\r\n    if (Runtime.class.getPackage() != null && Runtime.class.getPackage().getImplementationVersion() != null) {\r\n      if (Runtime.class.getPackage().getImplementationVersion().startsWith(\"1.7\")) {\r\n        // Java 7 does not support the PBKDF2_SHA256_ALGORITHM.\r\n        if (algorithm != null && algorithm.equals(PBKDF2_SHA256_ALGORITHM)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }", "language": "java", "code": "private static boolean isAlgorithmSupported(final String algorithm) {\r\n    // Java 7 specific checks.\r\n    if (Runtime.class.getPackage() != null && Runtime.class.getPackage().getImplementationVersion() != null) {\r\n      if (Runtime.class.getPackage().getImplementationVersion().startsWith(\"1.7\")) {\r\n        // Java 7 does not support the PBKDF2_SHA256_ALGORITHM.\r\n        if (algorithm != null && algorithm.equals(PBKDF2_SHA256_ALGORITHM)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }", "code_tokens": ["private", "static", "boolean", "isAlgorithmSupported", "(", "final", "String", "algorithm", ")", "{", "// Java 7 specific checks.\r", "if", "(", "Runtime", ".", "class", ".", "getPackage", "(", ")", "!=", "null", "&&", "Runtime", ".", "class", ".", "getPackage", "(", ")", ".", "getImplementationVersion", "(", ")", "!=", "null", ")", "{", "if", "(", "Runtime", ".", "class", ".", "getPackage", "(", ")", ".", "getImplementationVersion", "(", ")", ".", "startsWith", "(", "\"1.7\"", ")", ")", "{", "// Java 7 does not support the PBKDF2_SHA256_ALGORITHM.\r", "if", "(", "algorithm", "!=", "null", "&&", "algorithm", ".", "equals", "(", "PBKDF2_SHA256_ALGORITHM", ")", ")", "{", "return", "false", ";", "}", "}", "}", "return", "true", ";", "}"], "docstring": "Returns true if the algorithm is supported by the current version of Java", "docstring_tokens": ["Returns", "true", "if", "the", "algorithm", "is", "supported", "by", "the", "current", "version", "of", "Java"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/OSecurityManager.java#L253-L265", "partition": "test", "index": 3001, "time": "2016-03-31 14:05:04"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java", "func_name": "OPerformanceStatisticManager.unregisterMBean", "original_string": "public void unregisterMBean(String storageName, int storageId) {\n    if (storageName == null) {\n      OLogManager.instance().warnNoDb(this, \"Can not unregister MBean for performance statistics, storage name is null\");\n    }\n    if (mbeanIsRegistered.compareAndSet(true, false)) {\n      try {\n        final MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        final ObjectName mbeanName = new ObjectName(getMBeanName(storageName, storageId));\n        server.unregisterMBean(mbeanName);\n      } catch (MalformedObjectNameException | InstanceNotFoundException | MBeanRegistrationException e) {\n        throw OException.wrapException(new OStorageException(\"Error during unregistration of profiler MBean\"), e);\n      }\n    }\n  }", "language": "java", "code": "public void unregisterMBean(String storageName, int storageId) {\n    if (storageName == null) {\n      OLogManager.instance().warnNoDb(this, \"Can not unregister MBean for performance statistics, storage name is null\");\n    }\n    if (mbeanIsRegistered.compareAndSet(true, false)) {\n      try {\n        final MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        final ObjectName mbeanName = new ObjectName(getMBeanName(storageName, storageId));\n        server.unregisterMBean(mbeanName);\n      } catch (MalformedObjectNameException | InstanceNotFoundException | MBeanRegistrationException e) {\n        throw OException.wrapException(new OStorageException(\"Error during unregistration of profiler MBean\"), e);\n      }\n    }\n  }", "code_tokens": ["public", "void", "unregisterMBean", "(", "String", "storageName", ",", "int", "storageId", ")", "{", "if", "(", "storageName", "==", "null", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warnNoDb", "(", "this", ",", "\"Can not unregister MBean for performance statistics, storage name is null\"", ")", ";", "}", "if", "(", "mbeanIsRegistered", ".", "compareAndSet", "(", "true", ",", "false", ")", ")", "{", "try", "{", "final", "MBeanServer", "server", "=", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ";", "final", "ObjectName", "mbeanName", "=", "new", "ObjectName", "(", "getMBeanName", "(", "storageName", ",", "storageId", ")", ")", ";", "server", ".", "unregisterMBean", "(", "mbeanName", ")", ";", "}", "catch", "(", "MalformedObjectNameException", "|", "InstanceNotFoundException", "|", "MBeanRegistrationException", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OStorageException", "(", "\"Error during unregistration of profiler MBean\"", ")", ",", "e", ")", ";", "}", "}", "}"], "docstring": "Deregisters JMX bean for current manager.\n\n@param storageName Name of storage of given manager\n@param storageId   Id of storage of given manager\n\n@see OStorage#getName()\n@see OIdentifiableStorage#getId()", "docstring_tokens": ["Deregisters", "JMX", "bean", "for", "current", "manager", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java#L430-L443", "partition": "test", "index": 3133, "time": "2016-04-01 15:34:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java", "func_name": "OPerformanceStatisticManager.registerMBean", "original_string": "public void registerMBean(String storageName, int storageId) {\n    if (mbeanIsRegistered.compareAndSet(false, true)) {\n      try {\n        final MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        final ObjectName mbeanName = new ObjectName(getMBeanName(storageName, storageId));\n        if (!server.isRegistered(mbeanName)) {\n          server.registerMBean(new OPerformanceStatisticManagerMBean(this), mbeanName);\n        } else {\n          mbeanIsRegistered.set(false);\n          OLogManager.instance().warn(this,\n              \"MBean with name %s has already registered. Probably your system was not shutdown correctly\"\n                  + \" or you have several running applications which use OrientDB engine inside\", mbeanName.getCanonicalName());\n        }\n\n      } catch (MalformedObjectNameException | InstanceAlreadyExistsException | NotCompliantMBeanException | MBeanRegistrationException e) {\n        throw OException.wrapException(new OStorageException(\"Error during registration of profiler MBean\"), e);\n      }\n    }\n  }", "language": "java", "code": "public void registerMBean(String storageName, int storageId) {\n    if (mbeanIsRegistered.compareAndSet(false, true)) {\n      try {\n        final MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        final ObjectName mbeanName = new ObjectName(getMBeanName(storageName, storageId));\n        if (!server.isRegistered(mbeanName)) {\n          server.registerMBean(new OPerformanceStatisticManagerMBean(this), mbeanName);\n        } else {\n          mbeanIsRegistered.set(false);\n          OLogManager.instance().warn(this,\n              \"MBean with name %s has already registered. Probably your system was not shutdown correctly\"\n                  + \" or you have several running applications which use OrientDB engine inside\", mbeanName.getCanonicalName());\n        }\n\n      } catch (MalformedObjectNameException | InstanceAlreadyExistsException | NotCompliantMBeanException | MBeanRegistrationException e) {\n        throw OException.wrapException(new OStorageException(\"Error during registration of profiler MBean\"), e);\n      }\n    }\n  }", "code_tokens": ["public", "void", "registerMBean", "(", "String", "storageName", ",", "int", "storageId", ")", "{", "if", "(", "mbeanIsRegistered", ".", "compareAndSet", "(", "false", ",", "true", ")", ")", "{", "try", "{", "final", "MBeanServer", "server", "=", "ManagementFactory", ".", "getPlatformMBeanServer", "(", ")", ";", "final", "ObjectName", "mbeanName", "=", "new", "ObjectName", "(", "getMBeanName", "(", "storageName", ",", "storageId", ")", ")", ";", "if", "(", "!", "server", ".", "isRegistered", "(", "mbeanName", ")", ")", "{", "server", ".", "registerMBean", "(", "new", "OPerformanceStatisticManagerMBean", "(", "this", ")", ",", "mbeanName", ")", ";", "}", "else", "{", "mbeanIsRegistered", ".", "set", "(", "false", ")", ";", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "this", ",", "\"MBean with name %s has already registered. Probably your system was not shutdown correctly\"", "+", "\" or you have several running applications which use OrientDB engine inside\"", ",", "mbeanName", ".", "getCanonicalName", "(", ")", ")", ";", "}", "}", "catch", "(", "MalformedObjectNameException", "|", "InstanceAlreadyExistsException", "|", "NotCompliantMBeanException", "|", "MBeanRegistrationException", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OStorageException", "(", "\"Error during registration of profiler MBean\"", ")", ",", "e", ")", ";", "}", "}", "}"], "docstring": "Registers JMX bean for current manager.\n\n@param storageName Name of storage of given manager\n@param storageId   Id of storage of given manager\n\n@see OStorage#getName()\n@see OIdentifiableStorage#getId()", "docstring_tokens": ["Registers", "JMX", "bean", "for", "current", "manager", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java#L397-L415", "partition": "test", "index": 3132, "time": "2016-04-01 15:34:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/filter/OSQLFilterItemField.java", "func_name": "OSQLFilterItemField.getCollate", "original_string": "public OCollate getCollate(Object doc) {\r\n    if (collate != null || operationsChain == null || !isFieldChain()) {\r\n      return collate;\r\n    }\r\n    if (!(doc instanceof OIdentifiable)) {\r\n      return null;\r\n    }\r\n    FieldChain chain = getFieldChain();\r\n    ODocument lastDoc = ((OIdentifiable) doc).getRecord();\r\n    for (int i = 0; i < chain.getItemCount() - 1; i++) {\r\n      if (lastDoc == null) {\r\n        return null;\r\n      }\r\n      Object nextDoc = lastDoc.field(chain.getItemName(i));\r\n      if (nextDoc == null || !(nextDoc instanceof OIdentifiable)) {\r\n        return null;\r\n      }\r\n      lastDoc = ((OIdentifiable) nextDoc).getRecord();\r\n    }\r\n    if (lastDoc == null) {\r\n      return null;\r\n    }\r\n    OClass schemaClass = lastDoc.getSchemaClass();\r\n    if (schemaClass == null) {\r\n      return null;\r\n    }\r\n    OProperty property = schemaClass.getProperty(chain.getItemName(chain.getItemCount() - 1));\r\n    if (property == null) {\r\n      return null;\r\n    }\r\n    return property.getCollate();\r\n  }", "language": "java", "code": "public OCollate getCollate(Object doc) {\r\n    if (collate != null || operationsChain == null || !isFieldChain()) {\r\n      return collate;\r\n    }\r\n    if (!(doc instanceof OIdentifiable)) {\r\n      return null;\r\n    }\r\n    FieldChain chain = getFieldChain();\r\n    ODocument lastDoc = ((OIdentifiable) doc).getRecord();\r\n    for (int i = 0; i < chain.getItemCount() - 1; i++) {\r\n      if (lastDoc == null) {\r\n        return null;\r\n      }\r\n      Object nextDoc = lastDoc.field(chain.getItemName(i));\r\n      if (nextDoc == null || !(nextDoc instanceof OIdentifiable)) {\r\n        return null;\r\n      }\r\n      lastDoc = ((OIdentifiable) nextDoc).getRecord();\r\n    }\r\n    if (lastDoc == null) {\r\n      return null;\r\n    }\r\n    OClass schemaClass = lastDoc.getSchemaClass();\r\n    if (schemaClass == null) {\r\n      return null;\r\n    }\r\n    OProperty property = schemaClass.getProperty(chain.getItemName(chain.getItemCount() - 1));\r\n    if (property == null) {\r\n      return null;\r\n    }\r\n    return property.getCollate();\r\n  }", "code_tokens": ["public", "OCollate", "getCollate", "(", "Object", "doc", ")", "{", "if", "(", "collate", "!=", "null", "||", "operationsChain", "==", "null", "||", "!", "isFieldChain", "(", ")", ")", "{", "return", "collate", ";", "}", "if", "(", "!", "(", "doc", "instanceof", "OIdentifiable", ")", ")", "{", "return", "null", ";", "}", "FieldChain", "chain", "=", "getFieldChain", "(", ")", ";", "ODocument", "lastDoc", "=", "(", "(", "OIdentifiable", ")", "doc", ")", ".", "getRecord", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "chain", ".", "getItemCount", "(", ")", "-", "1", ";", "i", "++", ")", "{", "if", "(", "lastDoc", "==", "null", ")", "{", "return", "null", ";", "}", "Object", "nextDoc", "=", "lastDoc", ".", "field", "(", "chain", ".", "getItemName", "(", "i", ")", ")", ";", "if", "(", "nextDoc", "==", "null", "||", "!", "(", "nextDoc", "instanceof", "OIdentifiable", ")", ")", "{", "return", "null", ";", "}", "lastDoc", "=", "(", "(", "OIdentifiable", ")", "nextDoc", ")", ".", "getRecord", "(", ")", ";", "}", "if", "(", "lastDoc", "==", "null", ")", "{", "return", "null", ";", "}", "OClass", "schemaClass", "=", "lastDoc", ".", "getSchemaClass", "(", ")", ";", "if", "(", "schemaClass", "==", "null", ")", "{", "return", "null", ";", "}", "OProperty", "property", "=", "schemaClass", ".", "getProperty", "(", "chain", ".", "getItemName", "(", "chain", ".", "getItemCount", "(", ")", "-", "1", ")", ")", ";", "if", "(", "property", "==", "null", ")", "{", "return", "null", ";", "}", "return", "property", ".", "getCollate", "(", ")", ";", "}"], "docstring": "get the collate of this expression, based on the fully evaluated field chain starting from the passed object.\n\n@param doc the root element (document?) of this field chain\n@return the collate, null if no collate is defined", "docstring_tokens": ["get", "the", "collate", "of", "this", "expression", "based", "on", "the", "fully", "evaluated", "field", "chain", "starting", "from", "the", "passed", "object", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/filter/OSQLFilterItemField.java#L237-L268", "partition": "test", "index": 2994, "time": "2016-04-05 14:29:34"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/security/authenticator/ODefaultPasswordAuthenticator.java", "func_name": "ODefaultPasswordAuthenticator.createServerUser", "original_string": "protected OServerUserConfiguration createServerUser(final ODocument userDoc) {\n    OServerUserConfiguration userCfg = null;\n    \n    if (userDoc.containsField(\"username\") && userDoc.containsField(\"resources\")) {\n      final String user = userDoc.field(\"username\");\n      final String resources = userDoc.field(\"resources\");\n      String password = userDoc.field(\"password\");    \n    \n      if (password == null) password = \"\";\n    \n      userCfg = new OServerUserConfiguration(user, password, resources);\n    }\n   \n    return userCfg;\n  }", "language": "java", "code": "protected OServerUserConfiguration createServerUser(final ODocument userDoc) {\n    OServerUserConfiguration userCfg = null;\n    \n    if (userDoc.containsField(\"username\") && userDoc.containsField(\"resources\")) {\n      final String user = userDoc.field(\"username\");\n      final String resources = userDoc.field(\"resources\");\n      String password = userDoc.field(\"password\");    \n    \n      if (password == null) password = \"\";\n    \n      userCfg = new OServerUserConfiguration(user, password, resources);\n    }\n   \n    return userCfg;\n  }", "code_tokens": ["protected", "OServerUserConfiguration", "createServerUser", "(", "final", "ODocument", "userDoc", ")", "{", "OServerUserConfiguration", "userCfg", "=", "null", ";", "if", "(", "userDoc", ".", "containsField", "(", "\"username\"", ")", "&&", "userDoc", ".", "containsField", "(", "\"resources\"", ")", ")", "{", "final", "String", "user", "=", "userDoc", ".", "field", "(", "\"username\"", ")", ";", "final", "String", "resources", "=", "userDoc", ".", "field", "(", "\"resources\"", ")", ";", "String", "password", "=", "userDoc", ".", "field", "(", "\"password\"", ")", ";", "if", "(", "password", "==", "null", ")", "password", "=", "\"\"", ";", "userCfg", "=", "new", "OServerUserConfiguration", "(", "user", ",", "password", ",", "resources", ")", ";", "}", "return", "userCfg", ";", "}"], "docstring": "Derived implementations can override this method to provide new server user implementations.", "docstring_tokens": ["Derived", "implementations", "can", "override", "this", "method", "to", "provide", "new", "server", "user", "implementations", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/security/authenticator/ODefaultPasswordAuthenticator.java#L77-L91", "partition": "test", "index": 3290, "time": "2016-04-07 15:11:51"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/security/OSecurityAuthenticatorAbstract.java", "func_name": "OSecurityAuthenticatorAbstract.getAuthenticationHeader", "original_string": "public String getAuthenticationHeader(String databaseName) {\n    String header;\n\n    // Default to Basic.\n    if (databaseName != null)\n      header = \"WWW-Authenticate: Basic realm=\\\"OrientDB db-\" + databaseName + \"\\\"\";\n    else\n      header = \"WWW-Authenticate: Basic realm=\\\"OrientDB Server\\\"\";\n\n    return header;\n  }", "language": "java", "code": "public String getAuthenticationHeader(String databaseName) {\n    String header;\n\n    // Default to Basic.\n    if (databaseName != null)\n      header = \"WWW-Authenticate: Basic realm=\\\"OrientDB db-\" + databaseName + \"\\\"\";\n    else\n      header = \"WWW-Authenticate: Basic realm=\\\"OrientDB Server\\\"\";\n\n    return header;\n  }", "code_tokens": ["public", "String", "getAuthenticationHeader", "(", "String", "databaseName", ")", "{", "String", "header", ";", "// Default to Basic.", "if", "(", "databaseName", "!=", "null", ")", "header", "=", "\"WWW-Authenticate: Basic realm=\\\"OrientDB db-\"", "+", "databaseName", "+", "\"\\\"\"", ";", "else", "header", "=", "\"WWW-Authenticate: Basic realm=\\\"OrientDB Server\\\"\"", ";", "return", "header", ";", "}"], "docstring": "databaseName may be null.", "docstring_tokens": ["databaseName", "may", "be", "null", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/security/OSecurityAuthenticatorAbstract.java#L96-L106", "partition": "test", "index": 3234, "time": "2016-04-07 15:11:51"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.stopWriteCacheFlushTimer", "original_string": "public void stopWriteCacheFlushTimer(int pagesFlushed) {\n    // lazy initialization to prevent memory consumption\n    if (writCacheCountersHolder == null)\n      writCacheCountersHolder = new WritCacheCountersHolder();\n\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    writCacheCountersHolder.flushOperationsCount++;\n\n    writCacheCountersHolder.amountOfPagesFlushed += pagesFlushed;\n    writCacheCountersHolder.flushOperationsTime += timeDiff;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "language": "java", "code": "public void stopWriteCacheFlushTimer(int pagesFlushed) {\n    // lazy initialization to prevent memory consumption\n    if (writCacheCountersHolder == null)\n      writCacheCountersHolder = new WritCacheCountersHolder();\n\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    writCacheCountersHolder.flushOperationsCount++;\n\n    writCacheCountersHolder.amountOfPagesFlushed += pagesFlushed;\n    writCacheCountersHolder.flushOperationsTime += timeDiff;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "code_tokens": ["public", "void", "stopWriteCacheFlushTimer", "(", "int", "pagesFlushed", ")", "{", "// lazy initialization to prevent memory consumption", "if", "(", "writCacheCountersHolder", "==", "null", ")", "writCacheCountersHolder", "=", "new", "WritCacheCountersHolder", "(", ")", ";", "final", "long", "endTs", "=", "nanoTimer", ".", "getNano", "(", ")", ";", "final", "long", "timeDiff", "=", "(", "endTs", "-", "timeStamps", ".", "pop", "(", ")", ")", ";", "writCacheCountersHolder", ".", "flushOperationsCount", "++", ";", "writCacheCountersHolder", ".", "amountOfPagesFlushed", "+=", "pagesFlushed", ";", "writCacheCountersHolder", ".", "flushOperationsTime", "+=", "timeDiff", ";", "makeSnapshotIfNeeded", "(", "endTs", ")", ";", "}"], "docstring": "Stops and records results of timer which counts how much time was spent on operation of flush pages in write cache.\n\n@param pagesFlushed Amount of pages were flushed during this operation.", "docstring_tokens": ["Stops", "and", "records", "results", "of", "timer", "which", "counts", "how", "much", "time", "was", "spent", "on", "operation", "of", "flush", "pages", "in", "write", "cache", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L674-L688", "partition": "test", "index": 3057, "time": "2016-04-08 19:12:29"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.stopFuzzyCheckpointTimer", "original_string": "public void stopFuzzyCheckpointTimer() {\n    if (writCacheCountersHolder == null)\n      writCacheCountersHolder = new WritCacheCountersHolder();\n\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    writCacheCountersHolder.fuzzyCheckpointCount++;\n    writCacheCountersHolder.fuzzyCheckpointTime += timeDiff;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "language": "java", "code": "public void stopFuzzyCheckpointTimer() {\n    if (writCacheCountersHolder == null)\n      writCacheCountersHolder = new WritCacheCountersHolder();\n\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    writCacheCountersHolder.fuzzyCheckpointCount++;\n    writCacheCountersHolder.fuzzyCheckpointTime += timeDiff;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "code_tokens": ["public", "void", "stopFuzzyCheckpointTimer", "(", ")", "{", "if", "(", "writCacheCountersHolder", "==", "null", ")", "writCacheCountersHolder", "=", "new", "WritCacheCountersHolder", "(", ")", ";", "final", "long", "endTs", "=", "nanoTimer", ".", "getNano", "(", ")", ";", "final", "long", "timeDiff", "=", "(", "endTs", "-", "timeStamps", ".", "pop", "(", ")", ")", ";", "writCacheCountersHolder", ".", "fuzzyCheckpointCount", "++", ";", "writCacheCountersHolder", ".", "fuzzyCheckpointTime", "+=", "timeDiff", ";", "makeSnapshotIfNeeded", "(", "endTs", ")", ";", "}"], "docstring": "Stops and records results of timer which counts how much time was spent on fuzzy checkpoint operation.", "docstring_tokens": ["Stops", "and", "records", "results", "of", "timer", "which", "counts", "how", "much", "time", "was", "spent", "on", "fuzzy", "checkpoint", "operation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L700-L711", "partition": "test", "index": 3058, "time": "2016-04-08 19:12:29"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.stopWALRecordTimer", "original_string": "public void stopWALRecordTimer(boolean isStartRecord, boolean isStopRecord) {\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    if (walCountersHolder == null)\n      walCountersHolder = new WALCountersHolder();\n\n    walCountersHolder.logRecordCount++;\n    walCountersHolder.logRecordTime += timeDiff;\n\n    if (isStartRecord) {\n      walCountersHolder.startRecordCount++;\n      walCountersHolder.startRecordTime += timeDiff;\n    } else if (isStopRecord) {\n      walCountersHolder.stopRecordCount++;\n      walCountersHolder.stopRecordTime += timeDiff;\n    }\n\n    makeSnapshotIfNeeded(endTs);\n  }", "language": "java", "code": "public void stopWALRecordTimer(boolean isStartRecord, boolean isStopRecord) {\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    if (walCountersHolder == null)\n      walCountersHolder = new WALCountersHolder();\n\n    walCountersHolder.logRecordCount++;\n    walCountersHolder.logRecordTime += timeDiff;\n\n    if (isStartRecord) {\n      walCountersHolder.startRecordCount++;\n      walCountersHolder.startRecordTime += timeDiff;\n    } else if (isStopRecord) {\n      walCountersHolder.stopRecordCount++;\n      walCountersHolder.stopRecordTime += timeDiff;\n    }\n\n    makeSnapshotIfNeeded(endTs);\n  }", "code_tokens": ["public", "void", "stopWALRecordTimer", "(", "boolean", "isStartRecord", ",", "boolean", "isStopRecord", ")", "{", "final", "long", "endTs", "=", "nanoTimer", ".", "getNano", "(", ")", ";", "final", "long", "timeDiff", "=", "(", "endTs", "-", "timeStamps", ".", "pop", "(", ")", ")", ";", "if", "(", "walCountersHolder", "==", "null", ")", "walCountersHolder", "=", "new", "WALCountersHolder", "(", ")", ";", "walCountersHolder", ".", "logRecordCount", "++", ";", "walCountersHolder", ".", "logRecordTime", "+=", "timeDiff", ";", "if", "(", "isStartRecord", ")", "{", "walCountersHolder", ".", "startRecordCount", "++", ";", "walCountersHolder", ".", "startRecordTime", "+=", "timeDiff", ";", "}", "else", "if", "(", "isStopRecord", ")", "{", "walCountersHolder", ".", "stopRecordCount", "++", ";", "walCountersHolder", ".", "stopRecordTime", "+=", "timeDiff", ";", "}", "makeSnapshotIfNeeded", "(", "endTs", ")", ";", "}"], "docstring": "Stops and records results of timer which counts how much time was spent on logging of single write ahead log record.\n\n@param isStartRecord Indicates whether we logged \"start atomic operation\" record\n@param isStopRecord  Indicates whether we logged \"stop atomic operation\" record", "docstring_tokens": ["Stops", "and", "records", "results", "of", "timer", "which", "counts", "how", "much", "time", "was", "spent", "on", "logging", "of", "single", "write", "ahead", "log", "record", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L1115-L1134", "partition": "test", "index": 3061, "time": "2016-04-15 16:57:49"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.pushWALCounters", "original_string": "public WALCountersHolder pushWALCounters(WALCountersHolder holder) {\n    if (snapshot == null)\n      return holder;\n\n    if (snapshot.walCountersHolder == null)\n      return holder;\n\n    if (holder == null)\n      holder = new WALCountersHolder();\n\n    snapshot.walCountersHolder.pushData(holder);\n\n    return holder;\n  }", "language": "java", "code": "public WALCountersHolder pushWALCounters(WALCountersHolder holder) {\n    if (snapshot == null)\n      return holder;\n\n    if (snapshot.walCountersHolder == null)\n      return holder;\n\n    if (holder == null)\n      holder = new WALCountersHolder();\n\n    snapshot.walCountersHolder.pushData(holder);\n\n    return holder;\n  }", "code_tokens": ["public", "WALCountersHolder", "pushWALCounters", "(", "WALCountersHolder", "holder", ")", "{", "if", "(", "snapshot", "==", "null", ")", "return", "holder", ";", "if", "(", "snapshot", ".", "walCountersHolder", "==", "null", ")", "return", "holder", ";", "if", "(", "holder", "==", "null", ")", "holder", "=", "new", "WALCountersHolder", "(", ")", ";", "snapshot", ".", "walCountersHolder", ".", "pushData", "(", "holder", ")", ";", "return", "holder", ";", "}"], "docstring": "Takes write ahead log data from last snapshot and aggregates them with data passed inside method as parameter. Result of\naggregation of performance data is returned inside of passed in performance data and as result of this method call.\n\n@param holder Performance data for write ahead log may be <code>null</code>\n\n@return Result of aggregation of performance data", "docstring_tokens": ["Takes", "write", "ahead", "log", "data", "from", "last", "snapshot", "and", "aggregates", "them", "with", "data", "passed", "inside", "method", "as", "parameter", ".", "Result", "of", "aggregation", "of", "performance", "data", "is", "returned", "inside", "of", "passed", "in", "performance", "data", "and", "as", "result", "of", "this", "method", "call", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L513-L526", "partition": "test", "index": 3055, "time": "2016-04-15 16:57:49"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.stopWALFlushTimer", "original_string": "public void stopWALFlushTimer() {\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    if (walCountersHolder == null)\n      walCountersHolder = new WALCountersHolder();\n\n    walCountersHolder.flushCount++;\n    walCountersHolder.flushTime += timeDiff;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "language": "java", "code": "public void stopWALFlushTimer() {\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    if (walCountersHolder == null)\n      walCountersHolder = new WALCountersHolder();\n\n    walCountersHolder.flushCount++;\n    walCountersHolder.flushTime += timeDiff;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "code_tokens": ["public", "void", "stopWALFlushTimer", "(", ")", "{", "final", "long", "endTs", "=", "nanoTimer", ".", "getNano", "(", ")", ";", "final", "long", "timeDiff", "=", "(", "endTs", "-", "timeStamps", ".", "pop", "(", ")", ")", ";", "if", "(", "walCountersHolder", "==", "null", ")", "walCountersHolder", "=", "new", "WALCountersHolder", "(", ")", ";", "walCountersHolder", ".", "flushCount", "++", ";", "walCountersHolder", ".", "flushTime", "+=", "timeDiff", ";", "makeSnapshotIfNeeded", "(", "endTs", ")", ";", "}"], "docstring": "Stops timer and records how much time was spent on flushing of data from write ahead log cache.", "docstring_tokens": ["Stops", "timer", "and", "records", "how", "much", "time", "was", "spent", "on", "flushing", "of", "data", "from", "write", "ahead", "log", "cache", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L1146-L1157", "partition": "test", "index": 3062, "time": "2016-04-15 16:57:49"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.pushStorageCounters", "original_string": "public StorageCountersHolder pushStorageCounters(StorageCountersHolder holder) {\n    if (snapshot == null)\n      return holder;\n\n    if (snapshot.storageCountersHolder == null)\n      return holder;\n\n    if (holder == null)\n      holder = new StorageCountersHolder();\n\n    snapshot.storageCountersHolder.pushData(holder);\n\n    return holder;\n  }", "language": "java", "code": "public StorageCountersHolder pushStorageCounters(StorageCountersHolder holder) {\n    if (snapshot == null)\n      return holder;\n\n    if (snapshot.storageCountersHolder == null)\n      return holder;\n\n    if (holder == null)\n      holder = new StorageCountersHolder();\n\n    snapshot.storageCountersHolder.pushData(holder);\n\n    return holder;\n  }", "code_tokens": ["public", "StorageCountersHolder", "pushStorageCounters", "(", "StorageCountersHolder", "holder", ")", "{", "if", "(", "snapshot", "==", "null", ")", "return", "holder", ";", "if", "(", "snapshot", ".", "storageCountersHolder", "==", "null", ")", "return", "holder", ";", "if", "(", "holder", "==", "null", ")", "holder", "=", "new", "StorageCountersHolder", "(", ")", ";", "snapshot", ".", "storageCountersHolder", ".", "pushData", "(", "holder", ")", ";", "return", "holder", ";", "}"], "docstring": "Takes storage performance data from last snapshot and aggregates them with data passed inside method as parameter. Result of\naggregation of performance data is returned inside of passed in performance data and as result of this method call.\n\n@param holder Performance data for storage may be <code>null</code>\n\n@return Result of aggregation of performance data", "docstring_tokens": ["Takes", "storage", "performance", "data", "from", "last", "snapshot", "and", "aggregates", "them", "with", "data", "passed", "inside", "method", "as", "parameter", ".", "Result", "of", "aggregation", "of", "performance", "data", "is", "returned", "inside", "of", "passed", "in", "performance", "data", "and", "as", "result", "of", "this", "method", "call", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L490-L503", "partition": "test", "index": 3054, "time": "2016-04-15 16:57:49"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.stopFullCheckpointTimer", "original_string": "public void stopFullCheckpointTimer() {\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    if (storageCountersHolder == null)\n      storageCountersHolder = new StorageCountersHolder();\n\n    storageCountersHolder.fullCheckpointOperationsCount++;\n    storageCountersHolder.fullCheckpointOperationsTime += timeDiff;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "language": "java", "code": "public void stopFullCheckpointTimer() {\n    final long endTs = nanoTimer.getNano();\n    final long timeDiff = (endTs - timeStamps.pop());\n\n    if (storageCountersHolder == null)\n      storageCountersHolder = new StorageCountersHolder();\n\n    storageCountersHolder.fullCheckpointOperationsCount++;\n    storageCountersHolder.fullCheckpointOperationsTime += timeDiff;\n\n    makeSnapshotIfNeeded(endTs);\n  }", "code_tokens": ["public", "void", "stopFullCheckpointTimer", "(", ")", "{", "final", "long", "endTs", "=", "nanoTimer", ".", "getNano", "(", ")", ";", "final", "long", "timeDiff", "=", "(", "endTs", "-", "timeStamps", ".", "pop", "(", ")", ")", ";", "if", "(", "storageCountersHolder", "==", "null", ")", "storageCountersHolder", "=", "new", "StorageCountersHolder", "(", ")", ";", "storageCountersHolder", ".", "fullCheckpointOperationsCount", "++", ";", "storageCountersHolder", ".", "fullCheckpointOperationsTime", "+=", "timeDiff", ";", "makeSnapshotIfNeeded", "(", "endTs", ")", ";", "}"], "docstring": "Stops and records results of timer which counts how much time was spent on full checkpoint operation.", "docstring_tokens": ["Stops", "and", "records", "results", "of", "timer", "which", "counts", "how", "much", "time", "was", "spent", "on", "full", "checkpoint", "operation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L772-L783", "partition": "test", "index": 3059, "time": "2016-04-15 16:57:49"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java", "func_name": "OSessionStoragePerformanceStatistic.pushWriteCacheCounters", "original_string": "public WritCacheCountersHolder pushWriteCacheCounters(WritCacheCountersHolder holder) {\n    if (snapshot == null)\n      return holder;\n\n    if (snapshot.writCacheCountersHolder == null)\n      return holder;\n\n    if (holder == null)\n      holder = new WritCacheCountersHolder();\n\n    snapshot.writCacheCountersHolder.pushData(holder);\n\n    return holder;\n  }", "language": "java", "code": "public WritCacheCountersHolder pushWriteCacheCounters(WritCacheCountersHolder holder) {\n    if (snapshot == null)\n      return holder;\n\n    if (snapshot.writCacheCountersHolder == null)\n      return holder;\n\n    if (holder == null)\n      holder = new WritCacheCountersHolder();\n\n    snapshot.writCacheCountersHolder.pushData(holder);\n\n    return holder;\n  }", "code_tokens": ["public", "WritCacheCountersHolder", "pushWriteCacheCounters", "(", "WritCacheCountersHolder", "holder", ")", "{", "if", "(", "snapshot", "==", "null", ")", "return", "holder", ";", "if", "(", "snapshot", ".", "writCacheCountersHolder", "==", "null", ")", "return", "holder", ";", "if", "(", "holder", "==", "null", ")", "holder", "=", "new", "WritCacheCountersHolder", "(", ")", ";", "snapshot", ".", "writCacheCountersHolder", ".", "pushData", "(", "holder", ")", ";", "return", "holder", ";", "}"], "docstring": "Takes write cache performance data from last snapshot and aggregates them with data passed inside method as parameter. Result\nof aggregation of performance data is returned inside of passed in performance data and as result of this method call.\n\n@param holder Performance data for write cache may be <code>null</code>\n\n@return Result of aggregation of performance data", "docstring_tokens": ["Takes", "write", "cache", "performance", "data", "from", "last", "snapshot", "and", "aggregates", "them", "with", "data", "passed", "inside", "method", "as", "parameter", ".", "Result", "of", "aggregation", "of", "performance", "data", "is", "returned", "inside", "of", "passed", "in", "performance", "data", "and", "as", "result", "of", "this", "method", "call", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OSessionStoragePerformanceStatistic.java#L467-L480", "partition": "test", "index": 3053, "time": "2016-04-15 16:57:49"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java", "func_name": "OPerformanceStatisticManager.fetchWriteCacheCounters", "original_string": "private WritCacheCountersHolder fetchWriteCacheCounters() {\n    //go through all threads and accumulate statistic only for live threads\n    //all dead threads will be removed and statistics from them will be\n    //later accumulated in #deadThreadsStatistic field, then result statistic from this field\n    //will be aggregated to countersHolder\n\n    //To decrease inter thread communication delay we fetch snapshots first\n    //and only after that we aggregate data from immutable snapshots\n    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());\n\n    final Collection<Thread> threadsToRemove = new ArrayList<>();\n    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {\n      final Thread thread = entry.getKey();\n\n      final OSessionStoragePerformanceStatistic statistic = entry.getValue();\n      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));\n    }\n\n    WritCacheCountersHolder holder = null;\n    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {\n      final Thread thread = pair.getFirst();\n\n      if (thread.isAlive()) {\n        final PerformanceSnapshot snapshot = pair.getSecond();\n\n        if (snapshot.writCacheCountersHolder != null) {\n          if (holder == null)\n            holder = new WritCacheCountersHolder();\n\n          snapshot.writCacheCountersHolder.pushData(holder);\n        }\n      } else {\n        threadsToRemove.add(thread);\n      }\n    }\n\n    if (!threadsToRemove.isEmpty()) {\n      updateDeadThreadsStatistic(threadsToRemove);\n    }\n\n    final ImmutableStatistic ds = deadThreadsStatistic;\n    if (ds != null) {\n      final WritCacheCountersHolder wch = ds.writCacheCountersHolder;\n      if (wch != null) {\n        if (holder == null)\n          holder = new WritCacheCountersHolder();\n\n        wch.pushData(holder);\n      }\n    }\n\n    return holder;\n  }", "language": "java", "code": "private WritCacheCountersHolder fetchWriteCacheCounters() {\n    //go through all threads and accumulate statistic only for live threads\n    //all dead threads will be removed and statistics from them will be\n    //later accumulated in #deadThreadsStatistic field, then result statistic from this field\n    //will be aggregated to countersHolder\n\n    //To decrease inter thread communication delay we fetch snapshots first\n    //and only after that we aggregate data from immutable snapshots\n    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());\n\n    final Collection<Thread> threadsToRemove = new ArrayList<>();\n    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {\n      final Thread thread = entry.getKey();\n\n      final OSessionStoragePerformanceStatistic statistic = entry.getValue();\n      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));\n    }\n\n    WritCacheCountersHolder holder = null;\n    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {\n      final Thread thread = pair.getFirst();\n\n      if (thread.isAlive()) {\n        final PerformanceSnapshot snapshot = pair.getSecond();\n\n        if (snapshot.writCacheCountersHolder != null) {\n          if (holder == null)\n            holder = new WritCacheCountersHolder();\n\n          snapshot.writCacheCountersHolder.pushData(holder);\n        }\n      } else {\n        threadsToRemove.add(thread);\n      }\n    }\n\n    if (!threadsToRemove.isEmpty()) {\n      updateDeadThreadsStatistic(threadsToRemove);\n    }\n\n    final ImmutableStatistic ds = deadThreadsStatistic;\n    if (ds != null) {\n      final WritCacheCountersHolder wch = ds.writCacheCountersHolder;\n      if (wch != null) {\n        if (holder == null)\n          holder = new WritCacheCountersHolder();\n\n        wch.pushData(holder);\n      }\n    }\n\n    return holder;\n  }", "code_tokens": ["private", "WritCacheCountersHolder", "fetchWriteCacheCounters", "(", ")", "{", "//go through all threads and accumulate statistic only for live threads", "//all dead threads will be removed and statistics from them will be", "//later accumulated in #deadThreadsStatistic field, then result statistic from this field", "//will be aggregated to countersHolder", "//To decrease inter thread communication delay we fetch snapshots first", "//and only after that we aggregate data from immutable snapshots", "final", "Collection", "<", "ORawPair", "<", "Thread", ",", "PerformanceSnapshot", ">", ">", "snapshots", "=", "new", "ArrayList", "<>", "(", "statistics", ".", "size", "(", ")", ")", ";", "final", "Collection", "<", "Thread", ">", "threadsToRemove", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "Thread", ",", "OSessionStoragePerformanceStatistic", ">", "entry", ":", "statistics", ".", "entrySet", "(", ")", ")", "{", "final", "Thread", "thread", "=", "entry", ".", "getKey", "(", ")", ";", "final", "OSessionStoragePerformanceStatistic", "statistic", "=", "entry", ".", "getValue", "(", ")", ";", "snapshots", ".", "add", "(", "new", "ORawPair", "<>", "(", "thread", ",", "statistic", ".", "getSnapshot", "(", ")", ")", ")", ";", "}", "WritCacheCountersHolder", "holder", "=", "null", ";", "for", "(", "ORawPair", "<", "Thread", ",", "PerformanceSnapshot", ">", "pair", ":", "snapshots", ")", "{", "final", "Thread", "thread", "=", "pair", ".", "getFirst", "(", ")", ";", "if", "(", "thread", ".", "isAlive", "(", ")", ")", "{", "final", "PerformanceSnapshot", "snapshot", "=", "pair", ".", "getSecond", "(", ")", ";", "if", "(", "snapshot", ".", "writCacheCountersHolder", "!=", "null", ")", "{", "if", "(", "holder", "==", "null", ")", "holder", "=", "new", "WritCacheCountersHolder", "(", ")", ";", "snapshot", ".", "writCacheCountersHolder", ".", "pushData", "(", "holder", ")", ";", "}", "}", "else", "{", "threadsToRemove", ".", "add", "(", "thread", ")", ";", "}", "}", "if", "(", "!", "threadsToRemove", ".", "isEmpty", "(", ")", ")", "{", "updateDeadThreadsStatistic", "(", "threadsToRemove", ")", ";", "}", "final", "ImmutableStatistic", "ds", "=", "deadThreadsStatistic", ";", "if", "(", "ds", "!=", "null", ")", "{", "final", "WritCacheCountersHolder", "wch", "=", "ds", ".", "writCacheCountersHolder", ";", "if", "(", "wch", "!=", "null", ")", "{", "if", "(", "holder", "==", "null", ")", "holder", "=", "new", "WritCacheCountersHolder", "(", ")", ";", "wch", ".", "pushData", "(", "holder", ")", ";", "}", "}", "return", "holder", ";", "}"], "docstring": "Iterates over all live threads and accumulates write performance statics gathered form threads,\nalso accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.\n\n@return Aggregated write cache performance statistic", "docstring_tokens": ["Iterates", "over", "all", "live", "threads", "and", "accumulates", "write", "performance", "statics", "gathered", "form", "threads", "also", "accumulates", "statistic", "from", "dead", "threads", "which", "were", "alive", "when", "when", "gathering", "of", "performance", "measurements", "is", "started", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/statistic/OPerformanceStatisticManager.java#L1109-L1161", "partition": "test", "index": 3134, "time": "2016-04-15 16:57:49"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/util/OMemory.java", "func_name": "OMemory.checkCacheMemoryConfiguration", "original_string": "public static void checkCacheMemoryConfiguration() {\n    final long maxHeapSize = Runtime.getRuntime().maxMemory();\n    final long maxCacheSize = getMaxCacheMemorySize();\n    final ONative.MemoryLimitResult physicalMemory = ONative.instance().getMemoryLimit(false);\n\n    if (maxHeapSize != Long.MAX_VALUE && physicalMemory != null && maxHeapSize + maxCacheSize > physicalMemory.memoryLimit)\n      OLogManager.instance().warnNoDb(OMemory.class,\n          \"The sum of the configured JVM maximum heap size (\" + maxHeapSize + \" bytes) \" + \"and the OrientDB maximum cache size (\"\n              + maxCacheSize + \" bytes) is larger than the available physical memory size \" + \"(\" + physicalMemory\n              + \" bytes). That may cause out of memory errors, please tune the configuration up. Use the \"\n              + \"-Xmx JVM option to lower the JVM maximum heap memory size or storage.diskCache.bufferSize OrientDB option to \"\n              + \"lower memory requirements of the cache.\");\n  }", "language": "java", "code": "public static void checkCacheMemoryConfiguration() {\n    final long maxHeapSize = Runtime.getRuntime().maxMemory();\n    final long maxCacheSize = getMaxCacheMemorySize();\n    final ONative.MemoryLimitResult physicalMemory = ONative.instance().getMemoryLimit(false);\n\n    if (maxHeapSize != Long.MAX_VALUE && physicalMemory != null && maxHeapSize + maxCacheSize > physicalMemory.memoryLimit)\n      OLogManager.instance().warnNoDb(OMemory.class,\n          \"The sum of the configured JVM maximum heap size (\" + maxHeapSize + \" bytes) \" + \"and the OrientDB maximum cache size (\"\n              + maxCacheSize + \" bytes) is larger than the available physical memory size \" + \"(\" + physicalMemory\n              + \" bytes). That may cause out of memory errors, please tune the configuration up. Use the \"\n              + \"-Xmx JVM option to lower the JVM maximum heap memory size or storage.diskCache.bufferSize OrientDB option to \"\n              + \"lower memory requirements of the cache.\");\n  }", "code_tokens": ["public", "static", "void", "checkCacheMemoryConfiguration", "(", ")", "{", "final", "long", "maxHeapSize", "=", "Runtime", ".", "getRuntime", "(", ")", ".", "maxMemory", "(", ")", ";", "final", "long", "maxCacheSize", "=", "getMaxCacheMemorySize", "(", ")", ";", "final", "ONative", ".", "MemoryLimitResult", "physicalMemory", "=", "ONative", ".", "instance", "(", ")", ".", "getMemoryLimit", "(", "false", ")", ";", "if", "(", "maxHeapSize", "!=", "Long", ".", "MAX_VALUE", "&&", "physicalMemory", "!=", "null", "&&", "maxHeapSize", "+", "maxCacheSize", ">", "physicalMemory", ".", "memoryLimit", ")", "OLogManager", ".", "instance", "(", ")", ".", "warnNoDb", "(", "OMemory", ".", "class", ",", "\"The sum of the configured JVM maximum heap size (\"", "+", "maxHeapSize", "+", "\" bytes) \"", "+", "\"and the OrientDB maximum cache size (\"", "+", "maxCacheSize", "+", "\" bytes) is larger than the available physical memory size \"", "+", "\"(\"", "+", "physicalMemory", "+", "\" bytes). That may cause out of memory errors, please tune the configuration up. Use the \"", "+", "\"-Xmx JVM option to lower the JVM maximum heap memory size or storage.diskCache.bufferSize OrientDB option to \"", "+", "\"lower memory requirements of the cache.\"", ")", ";", "}"], "docstring": "Checks the OrientDB cache memory configuration and emits a warning if configuration is invalid.", "docstring_tokens": ["Checks", "the", "OrientDB", "cache", "memory", "configuration", "and", "emits", "a", "warning", "if", "configuration", "is", "invalid", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/util/OMemory.java#L55-L67", "partition": "test", "index": 3176, "time": "2016-04-20 17:51:54"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OIdentifier.java", "func_name": "OIdentifier.getStringValue", "original_string": "public String getStringValue() {\n    if (value == null) {\n      return null;\n    }\n    if (value.contains(\"`\")) {\n      return value.replaceAll(\"\\\\\\\\`\", \"`\");\n    }\n    return value;\n  }", "language": "java", "code": "public String getStringValue() {\n    if (value == null) {\n      return null;\n    }\n    if (value.contains(\"`\")) {\n      return value.replaceAll(\"\\\\\\\\`\", \"`\");\n    }\n    return value;\n  }", "code_tokens": ["public", "String", "getStringValue", "(", ")", "{", "if", "(", "value", "==", "null", ")", "{", "return", "null", ";", "}", "if", "(", "value", ".", "contains", "(", "\"`\"", ")", ")", "{", "return", "value", ".", "replaceAll", "(", "\"\\\\\\\\`\"", ",", "\"`\"", ")", ";", "}", "return", "value", ";", "}"], "docstring": "returns the plain string representation of this identifier, with quoting removed from back-ticks\n\n@return", "docstring_tokens": ["returns", "the", "plain", "string", "representation", "of", "this", "identifier", "with", "quoting", "removed", "from", "back", "-", "ticks"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OIdentifier.java#L83-L91", "partition": "test", "index": 2995, "time": "2016-04-26 16:36:25"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java", "func_name": "OHazelcastPlugin.memberRemoved", "original_string": "@Override\n  public void memberRemoved(final MembershipEvent iEvent) {\n    try {\n      updateLastClusterChange();\n\n      if (iEvent.getMember() == null)\n        return;\n\n      final String nodeLeftName = getNodeName(iEvent.getMember());\n      if (nodeLeftName == null)\n        return;\n\n      removeServer(nodeLeftName, true);\n\n    } catch (HazelcastInstanceNotActiveException | RetryableHazelcastException e) {\n      OLogManager.instance().error(this, \"Hazelcast is not running\", e);\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Error on removing the server '%s'\", e, getNodeName(iEvent.getMember()));\n    }\n  }", "language": "java", "code": "@Override\n  public void memberRemoved(final MembershipEvent iEvent) {\n    try {\n      updateLastClusterChange();\n\n      if (iEvent.getMember() == null)\n        return;\n\n      final String nodeLeftName = getNodeName(iEvent.getMember());\n      if (nodeLeftName == null)\n        return;\n\n      removeServer(nodeLeftName, true);\n\n    } catch (HazelcastInstanceNotActiveException | RetryableHazelcastException e) {\n      OLogManager.instance().error(this, \"Hazelcast is not running\", e);\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Error on removing the server '%s'\", e, getNodeName(iEvent.getMember()));\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "memberRemoved", "(", "final", "MembershipEvent", "iEvent", ")", "{", "try", "{", "updateLastClusterChange", "(", ")", ";", "if", "(", "iEvent", ".", "getMember", "(", ")", "==", "null", ")", "return", ";", "final", "String", "nodeLeftName", "=", "getNodeName", "(", "iEvent", ".", "getMember", "(", ")", ")", ";", "if", "(", "nodeLeftName", "==", "null", ")", "return", ";", "removeServer", "(", "nodeLeftName", ",", "true", ")", ";", "}", "catch", "(", "HazelcastInstanceNotActiveException", "|", "RetryableHazelcastException", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Hazelcast is not running\"", ",", "e", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error on removing the server '%s'\"", ",", "e", ",", "getNodeName", "(", "iEvent", ".", "getMember", "(", ")", ")", ")", ";", "}", "}"], "docstring": "Removes the node map entry.", "docstring_tokens": ["Removes", "the", "node", "map", "entry", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java#L1046-L1065", "partition": "test", "index": 2937, "time": "2016-04-28 15:52:20"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedAbstractPlugin.java", "func_name": "ODistributedAbstractPlugin.installClustersOfClass", "original_string": "public boolean installClustersOfClass(final ODatabaseInternal iDatabase, final OClass iClass,\n      OModifiableDistributedConfiguration cfg) {\n\n    final String databaseName = iDatabase.getName();\n    if (iClass.isAbstract())\n      return false;\n\n    // INIT THE DATABASE IF NEEDED\n    getMessageService().registerDatabase(databaseName, cfg);\n\n    return executeInDistributedDatabaseLock(databaseName, 20000, cfg,\n        new OCallable<Boolean, OModifiableDistributedConfiguration>() {\n          @Override\n          public Boolean call(final OModifiableDistributedConfiguration lastCfg) {\n            final Set<String> availableNodes = getAvailableNodeNames(iDatabase.getName());\n\n            final List<String> cluster2Create = clusterAssignmentStrategy\n                .assignClusterOwnershipOfClass(iDatabase, lastCfg, iClass, availableNodes, true);\n\n            final Map<OClass, List<String>> cluster2CreateMap = new HashMap<OClass, List<String>>(1);\n            cluster2CreateMap.put(iClass, cluster2Create);\n\n            createClusters(iDatabase, cluster2CreateMap, lastCfg);\n            return true;\n          }\n        });\n  }", "language": "java", "code": "public boolean installClustersOfClass(final ODatabaseInternal iDatabase, final OClass iClass,\n      OModifiableDistributedConfiguration cfg) {\n\n    final String databaseName = iDatabase.getName();\n    if (iClass.isAbstract())\n      return false;\n\n    // INIT THE DATABASE IF NEEDED\n    getMessageService().registerDatabase(databaseName, cfg);\n\n    return executeInDistributedDatabaseLock(databaseName, 20000, cfg,\n        new OCallable<Boolean, OModifiableDistributedConfiguration>() {\n          @Override\n          public Boolean call(final OModifiableDistributedConfiguration lastCfg) {\n            final Set<String> availableNodes = getAvailableNodeNames(iDatabase.getName());\n\n            final List<String> cluster2Create = clusterAssignmentStrategy\n                .assignClusterOwnershipOfClass(iDatabase, lastCfg, iClass, availableNodes, true);\n\n            final Map<OClass, List<String>> cluster2CreateMap = new HashMap<OClass, List<String>>(1);\n            cluster2CreateMap.put(iClass, cluster2Create);\n\n            createClusters(iDatabase, cluster2CreateMap, lastCfg);\n            return true;\n          }\n        });\n  }", "code_tokens": ["public", "boolean", "installClustersOfClass", "(", "final", "ODatabaseInternal", "iDatabase", ",", "final", "OClass", "iClass", ",", "OModifiableDistributedConfiguration", "cfg", ")", "{", "final", "String", "databaseName", "=", "iDatabase", ".", "getName", "(", ")", ";", "if", "(", "iClass", ".", "isAbstract", "(", ")", ")", "return", "false", ";", "// INIT THE DATABASE IF NEEDED", "getMessageService", "(", ")", ".", "registerDatabase", "(", "databaseName", ",", "cfg", ")", ";", "return", "executeInDistributedDatabaseLock", "(", "databaseName", ",", "20000", ",", "cfg", ",", "new", "OCallable", "<", "Boolean", ",", "OModifiableDistributedConfiguration", ">", "(", ")", "{", "@", "Override", "public", "Boolean", "call", "(", "final", "OModifiableDistributedConfiguration", "lastCfg", ")", "{", "final", "Set", "<", "String", ">", "availableNodes", "=", "getAvailableNodeNames", "(", "iDatabase", ".", "getName", "(", ")", ")", ";", "final", "List", "<", "String", ">", "cluster2Create", "=", "clusterAssignmentStrategy", ".", "assignClusterOwnershipOfClass", "(", "iDatabase", ",", "lastCfg", ",", "iClass", ",", "availableNodes", ",", "true", ")", ";", "final", "Map", "<", "OClass", ",", "List", "<", "String", ">", ">", "cluster2CreateMap", "=", "new", "HashMap", "<", "OClass", ",", "List", "<", "String", ">", ">", "(", "1", ")", ";", "cluster2CreateMap", ".", "put", "(", "iClass", ",", "cluster2Create", ")", ";", "createClusters", "(", "iDatabase", ",", "cluster2CreateMap", ",", "lastCfg", ")", ";", "return", "true", ";", "}", "}", ")", ";", "}"], "docstring": "Guarantees that each class has own master cluster.", "docstring_tokens": ["Guarantees", "that", "each", "class", "has", "own", "master", "cluster", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedAbstractPlugin.java#L1676-L1702", "partition": "test", "index": 3305, "time": "2016-04-28 15:52:20"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java", "func_name": "OHazelcastPlugin.loadLocalDatabases", "original_string": "protected void loadLocalDatabases() {\n    final List<String> dbs = new ArrayList<String>(serverInstance.getAvailableStorageNames().keySet());\n    Collections.sort(dbs);\n\n    for (final String databaseName : dbs) {\n      if (messageService.getDatabase(databaseName) == null) {\n        ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, \"Opening database '%s'...\", databaseName);\n\n        // INIT THE STORAGE\n        final ODistributedStorage stg = getStorage(databaseName);\n\n        executeInDistributedDatabaseLock(databaseName, 60000, null, new OCallable<Object, OModifiableDistributedConfiguration>() {\n          @Override\n          public Object call(OModifiableDistributedConfiguration cfg) {\n            ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, \"Current node started as %s for database '%s'\",\n                cfg.getServerRole(nodeName), databaseName);\n\n            final ODistributedDatabaseImpl ddb = messageService.registerDatabase(databaseName, cfg);\n            ddb.resume();\n\n            // 1ST NODE TO HAVE THE DATABASE\n            cfg.addNewNodeInServerList(nodeName);\n\n            // COLLECT ALL THE CLUSTERS WITH REMOVED NODE AS OWNER\n            reassignClustersOwnership(nodeName, databaseName, cfg, true);\n\n            try {\n              ddb.getSyncConfiguration().setLastLSN(nodeName, ((OAbstractPaginatedStorage) stg.getUnderlying()).getLSN(), false);\n            } catch (IOException e) {\n              ODistributedServerLog\n                  .error(this, nodeName, null, DIRECTION.NONE, \"Error on saving distributed LSN for database '%s' (err=%s).\",\n                      databaseName, e.getMessage());\n            }\n            ddb.setOnline();\n\n            return null;\n          }\n        });\n      }\n    }\n  }", "language": "java", "code": "protected void loadLocalDatabases() {\n    final List<String> dbs = new ArrayList<String>(serverInstance.getAvailableStorageNames().keySet());\n    Collections.sort(dbs);\n\n    for (final String databaseName : dbs) {\n      if (messageService.getDatabase(databaseName) == null) {\n        ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, \"Opening database '%s'...\", databaseName);\n\n        // INIT THE STORAGE\n        final ODistributedStorage stg = getStorage(databaseName);\n\n        executeInDistributedDatabaseLock(databaseName, 60000, null, new OCallable<Object, OModifiableDistributedConfiguration>() {\n          @Override\n          public Object call(OModifiableDistributedConfiguration cfg) {\n            ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, \"Current node started as %s for database '%s'\",\n                cfg.getServerRole(nodeName), databaseName);\n\n            final ODistributedDatabaseImpl ddb = messageService.registerDatabase(databaseName, cfg);\n            ddb.resume();\n\n            // 1ST NODE TO HAVE THE DATABASE\n            cfg.addNewNodeInServerList(nodeName);\n\n            // COLLECT ALL THE CLUSTERS WITH REMOVED NODE AS OWNER\n            reassignClustersOwnership(nodeName, databaseName, cfg, true);\n\n            try {\n              ddb.getSyncConfiguration().setLastLSN(nodeName, ((OAbstractPaginatedStorage) stg.getUnderlying()).getLSN(), false);\n            } catch (IOException e) {\n              ODistributedServerLog\n                  .error(this, nodeName, null, DIRECTION.NONE, \"Error on saving distributed LSN for database '%s' (err=%s).\",\n                      databaseName, e.getMessage());\n            }\n            ddb.setOnline();\n\n            return null;\n          }\n        });\n      }\n    }\n  }", "code_tokens": ["protected", "void", "loadLocalDatabases", "(", ")", "{", "final", "List", "<", "String", ">", "dbs", "=", "new", "ArrayList", "<", "String", ">", "(", "serverInstance", ".", "getAvailableStorageNames", "(", ")", ".", "keySet", "(", ")", ")", ";", "Collections", ".", "sort", "(", "dbs", ")", ";", "for", "(", "final", "String", "databaseName", ":", "dbs", ")", "{", "if", "(", "messageService", ".", "getDatabase", "(", "databaseName", ")", "==", "null", ")", "{", "ODistributedServerLog", ".", "info", "(", "this", ",", "nodeName", ",", "null", ",", "DIRECTION", ".", "NONE", ",", "\"Opening database '%s'...\"", ",", "databaseName", ")", ";", "// INIT THE STORAGE", "final", "ODistributedStorage", "stg", "=", "getStorage", "(", "databaseName", ")", ";", "executeInDistributedDatabaseLock", "(", "databaseName", ",", "60000", ",", "null", ",", "new", "OCallable", "<", "Object", ",", "OModifiableDistributedConfiguration", ">", "(", ")", "{", "@", "Override", "public", "Object", "call", "(", "OModifiableDistributedConfiguration", "cfg", ")", "{", "ODistributedServerLog", ".", "info", "(", "this", ",", "nodeName", ",", "null", ",", "DIRECTION", ".", "NONE", ",", "\"Current node started as %s for database '%s'\"", ",", "cfg", ".", "getServerRole", "(", "nodeName", ")", ",", "databaseName", ")", ";", "final", "ODistributedDatabaseImpl", "ddb", "=", "messageService", ".", "registerDatabase", "(", "databaseName", ",", "cfg", ")", ";", "ddb", ".", "resume", "(", ")", ";", "// 1ST NODE TO HAVE THE DATABASE", "cfg", ".", "addNewNodeInServerList", "(", "nodeName", ")", ";", "// COLLECT ALL THE CLUSTERS WITH REMOVED NODE AS OWNER", "reassignClustersOwnership", "(", "nodeName", ",", "databaseName", ",", "cfg", ",", "true", ")", ";", "try", "{", "ddb", ".", "getSyncConfiguration", "(", ")", ".", "setLastLSN", "(", "nodeName", ",", "(", "(", "OAbstractPaginatedStorage", ")", "stg", ".", "getUnderlying", "(", ")", ")", ".", "getLSN", "(", ")", ",", "false", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "ODistributedServerLog", ".", "error", "(", "this", ",", "nodeName", ",", "null", ",", "DIRECTION", ".", "NONE", ",", "\"Error on saving distributed LSN for database '%s' (err=%s).\"", ",", "databaseName", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "ddb", ".", "setOnline", "(", ")", ";", "return", "null", ";", "}", "}", ")", ";", "}", "}", "}"], "docstring": "Initializes all the available server's databases as distributed.", "docstring_tokens": ["Initializes", "all", "the", "available", "server", "s", "databases", "as", "distributed", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java#L735-L775", "partition": "test", "index": 2936, "time": "2016-04-28 15:52:20"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedAbstractPlugin.java", "func_name": "ODistributedAbstractPlugin.dumpServersStatus", "original_string": "protected void dumpServersStatus() {\n    final ODocument cfg = getClusterConfiguration();\n\n    final String compactStatus = ODistributedOutput.getCompactServerStatus(this, cfg);\n\n    if (!lastServerDump.equals(compactStatus)) {\n      lastServerDump = compactStatus;\n\n      ODistributedServerLog\n          .info(this, getLocalNodeName(), null, DIRECTION.NONE, \"Distributed servers status (*=current @=lockmgr[%s]):\\n%s\",\n              getLockManagerServer(), ODistributedOutput.formatServerStatus(this, cfg));\n    }\n  }", "language": "java", "code": "protected void dumpServersStatus() {\n    final ODocument cfg = getClusterConfiguration();\n\n    final String compactStatus = ODistributedOutput.getCompactServerStatus(this, cfg);\n\n    if (!lastServerDump.equals(compactStatus)) {\n      lastServerDump = compactStatus;\n\n      ODistributedServerLog\n          .info(this, getLocalNodeName(), null, DIRECTION.NONE, \"Distributed servers status (*=current @=lockmgr[%s]):\\n%s\",\n              getLockManagerServer(), ODistributedOutput.formatServerStatus(this, cfg));\n    }\n  }", "code_tokens": ["protected", "void", "dumpServersStatus", "(", ")", "{", "final", "ODocument", "cfg", "=", "getClusterConfiguration", "(", ")", ";", "final", "String", "compactStatus", "=", "ODistributedOutput", ".", "getCompactServerStatus", "(", "this", ",", "cfg", ")", ";", "if", "(", "!", "lastServerDump", ".", "equals", "(", "compactStatus", ")", ")", "{", "lastServerDump", "=", "compactStatus", ";", "ODistributedServerLog", ".", "info", "(", "this", ",", "getLocalNodeName", "(", ")", ",", "null", ",", "DIRECTION", ".", "NONE", ",", "\"Distributed servers status (*=current @=lockmgr[%s]):\\n%s\"", ",", "getLockManagerServer", "(", ")", ",", "ODistributedOutput", ".", "formatServerStatus", "(", "this", ",", "cfg", ")", ")", ";", "}", "}"], "docstring": "Avoids to dump the same configuration twice if it's unchanged since the last time.", "docstring_tokens": ["Avoids", "to", "dump", "the", "same", "configuration", "twice", "if", "it", "s", "unchanged", "since", "the", "last", "time", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedAbstractPlugin.java#L2118-L2130", "partition": "test", "index": 3306, "time": "2016-04-29 11:11:50"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/security/authenticator/OSystemUserAuthenticator.java", "func_name": "OSystemUserAuthenticator.authenticate", "original_string": "public String authenticate(final String username, final String password) {\n    String principal = null;\n\n    try {\n      if (getServer() != null) {\n        // dbName parameter is null because we don't need to filter any roles for this.\n        OUser user = getServer().getSecurity().getSystemUser(username, null);\n\n        if (user != null && user.getAccountStatus() == OSecurityUser.STATUSES.ACTIVE) {\n          if (user.checkPassword(password))\n            principal = username;\n        }\n      }\n    } catch (Exception ex) {\n      OLogManager.instance().error(this, \"authenticate()\", ex);\n    }\n\n    return principal;\n  }", "language": "java", "code": "public String authenticate(final String username, final String password) {\n    String principal = null;\n\n    try {\n      if (getServer() != null) {\n        // dbName parameter is null because we don't need to filter any roles for this.\n        OUser user = getServer().getSecurity().getSystemUser(username, null);\n\n        if (user != null && user.getAccountStatus() == OSecurityUser.STATUSES.ACTIVE) {\n          if (user.checkPassword(password))\n            principal = username;\n        }\n      }\n    } catch (Exception ex) {\n      OLogManager.instance().error(this, \"authenticate()\", ex);\n    }\n\n    return principal;\n  }", "code_tokens": ["public", "String", "authenticate", "(", "final", "String", "username", ",", "final", "String", "password", ")", "{", "String", "principal", "=", "null", ";", "try", "{", "if", "(", "getServer", "(", ")", "!=", "null", ")", "{", "// dbName parameter is null because we don't need to filter any roles for this.", "OUser", "user", "=", "getServer", "(", ")", ".", "getSecurity", "(", ")", ".", "getSystemUser", "(", "username", ",", "null", ")", ";", "if", "(", "user", "!=", "null", "&&", "user", ".", "getAccountStatus", "(", ")", "==", "OSecurityUser", ".", "STATUSES", ".", "ACTIVE", ")", "{", "if", "(", "user", ".", "checkPassword", "(", "password", ")", ")", "principal", "=", "username", ";", "}", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"authenticate()\"", ",", "ex", ")", ";", "}", "return", "principal", ";", "}"], "docstring": "This will authenticate username using the system database.", "docstring_tokens": ["This", "will", "authenticate", "username", "using", "the", "system", "database", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/security/authenticator/OSystemUserAuthenticator.java#L64-L82", "partition": "test", "index": 3235, "time": "2016-05-04 01:55:53"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/security/authenticator/OSystemUserAuthenticator.java", "func_name": "OSystemUserAuthenticator.isAuthorized", "original_string": "public boolean isAuthorized(final String username, final String resource) {\n    if (username == null || resource == null)\n      return false;\n\n    try {\n      if (getServer() != null) {\n        OUser user = getServer().getSecurity().getSystemUser(username, null);\n\n        if (user != null && user.getAccountStatus() == OSecurityUser.STATUSES.ACTIVE) {\n          ORole role = null;\n\n          ORule.ResourceGeneric rg = ORule.mapLegacyResourceToGenericResource(resource);\n\n          if (rg != null) {\n            String specificResource = ORule.mapLegacyResourceToSpecificResource(resource);\n\n            if (specificResource == null || specificResource.equals(\"*\")) {\n              specificResource = null;\n            }\n\n            role = user.checkIfAllowed(rg, specificResource, ORole.PERMISSION_EXECUTE);\n          }\n\n          return role != null;\n        }\n      }\n    } catch (Exception ex) {\n      OLogManager.instance().error(this, \"isAuthorized()\", ex);\n    }\n\n    return false;\n  }", "language": "java", "code": "public boolean isAuthorized(final String username, final String resource) {\n    if (username == null || resource == null)\n      return false;\n\n    try {\n      if (getServer() != null) {\n        OUser user = getServer().getSecurity().getSystemUser(username, null);\n\n        if (user != null && user.getAccountStatus() == OSecurityUser.STATUSES.ACTIVE) {\n          ORole role = null;\n\n          ORule.ResourceGeneric rg = ORule.mapLegacyResourceToGenericResource(resource);\n\n          if (rg != null) {\n            String specificResource = ORule.mapLegacyResourceToSpecificResource(resource);\n\n            if (specificResource == null || specificResource.equals(\"*\")) {\n              specificResource = null;\n            }\n\n            role = user.checkIfAllowed(rg, specificResource, ORole.PERMISSION_EXECUTE);\n          }\n\n          return role != null;\n        }\n      }\n    } catch (Exception ex) {\n      OLogManager.instance().error(this, \"isAuthorized()\", ex);\n    }\n\n    return false;\n  }", "code_tokens": ["public", "boolean", "isAuthorized", "(", "final", "String", "username", ",", "final", "String", "resource", ")", "{", "if", "(", "username", "==", "null", "||", "resource", "==", "null", ")", "return", "false", ";", "try", "{", "if", "(", "getServer", "(", ")", "!=", "null", ")", "{", "OUser", "user", "=", "getServer", "(", ")", ".", "getSecurity", "(", ")", ".", "getSystemUser", "(", "username", ",", "null", ")", ";", "if", "(", "user", "!=", "null", "&&", "user", ".", "getAccountStatus", "(", ")", "==", "OSecurityUser", ".", "STATUSES", ".", "ACTIVE", ")", "{", "ORole", "role", "=", "null", ";", "ORule", ".", "ResourceGeneric", "rg", "=", "ORule", ".", "mapLegacyResourceToGenericResource", "(", "resource", ")", ";", "if", "(", "rg", "!=", "null", ")", "{", "String", "specificResource", "=", "ORule", ".", "mapLegacyResourceToSpecificResource", "(", "resource", ")", ";", "if", "(", "specificResource", "==", "null", "||", "specificResource", ".", "equals", "(", "\"*\"", ")", ")", "{", "specificResource", "=", "null", ";", "}", "role", "=", "user", ".", "checkIfAllowed", "(", "rg", ",", "specificResource", ",", "ORole", ".", "PERMISSION_EXECUTE", ")", ";", "}", "return", "role", "!=", "null", ";", "}", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"isAuthorized()\"", ",", "ex", ")", ";", "}", "return", "false", ";", "}"], "docstring": "Checks to see if a", "docstring_tokens": ["Checks", "to", "see", "if", "a"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/security/authenticator/OSystemUserAuthenticator.java#L87-L118", "partition": "test", "index": 3236, "time": "2016-05-04 01:55:53"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getClusterConfiguration", "original_string": "protected ODocument getClusterConfiguration(String iClusterName) {\n    final ODocument clusters = getConfiguredClusters();\n\n    if (iClusterName == null)\n      iClusterName = ALL_WILDCARD;\n\n    final ODocument cfg;\n    if (!clusters.containsField(iClusterName))\n      // NO CLUSTER IN CFG: GET THE DEFAULT ONE\n      cfg = clusters.field(ALL_WILDCARD);\n    else\n      // GET THE CLUSTER CFG\n      cfg = clusters.field(iClusterName);\n\n    if (cfg == null)\n      return new ODocument();\n\n    return cfg;\n  }", "language": "java", "code": "protected ODocument getClusterConfiguration(String iClusterName) {\n    final ODocument clusters = getConfiguredClusters();\n\n    if (iClusterName == null)\n      iClusterName = ALL_WILDCARD;\n\n    final ODocument cfg;\n    if (!clusters.containsField(iClusterName))\n      // NO CLUSTER IN CFG: GET THE DEFAULT ONE\n      cfg = clusters.field(ALL_WILDCARD);\n    else\n      // GET THE CLUSTER CFG\n      cfg = clusters.field(iClusterName);\n\n    if (cfg == null)\n      return new ODocument();\n\n    return cfg;\n  }", "code_tokens": ["protected", "ODocument", "getClusterConfiguration", "(", "String", "iClusterName", ")", "{", "final", "ODocument", "clusters", "=", "getConfiguredClusters", "(", ")", ";", "if", "(", "iClusterName", "==", "null", ")", "iClusterName", "=", "ALL_WILDCARD", ";", "final", "ODocument", "cfg", ";", "if", "(", "!", "clusters", ".", "containsField", "(", "iClusterName", ")", ")", "// NO CLUSTER IN CFG: GET THE DEFAULT ONE", "cfg", "=", "clusters", ".", "field", "(", "ALL_WILDCARD", ")", ";", "else", "// GET THE CLUSTER CFG", "cfg", "=", "clusters", ".", "field", "(", "iClusterName", ")", ";", "if", "(", "cfg", "==", "null", ")", "return", "new", "ODocument", "(", ")", ";", "return", "cfg", ";", "}"], "docstring": "Gets the document representing the cluster configuration.\n\n@param iClusterName Cluster name, or null for *\n\n@return Always a ODocument\n\n@throws OConfigurationException in case \"clusters\" field is not found in configuration", "docstring_tokens": ["Gets", "the", "document", "representing", "the", "cluster", "configuration", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L745-L763", "partition": "test", "index": 3107, "time": "2016-05-04 02:01:48"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/OSystemDatabase.java", "func_name": "OSystemDatabase.createCluster", "original_string": "public void createCluster(final String className, final String clusterName) {\n    final ODatabaseDocumentInternal currentDB = ODatabaseRecordThreadLocal.instance().getIfDefined();\n    try {\n      final ODatabaseDocumentInternal sysdb = openSystemDatabase();\n      try {\n\n        if (!sysdb.existsCluster(clusterName)) {\n          OSchema schema = sysdb.getMetadata().getSchema();\n          OClass cls = schema.getClass(className);\n\n          if (cls != null) {\n            cls.addCluster(clusterName);\n          } else {\n            OLogManager.instance().error(this, \"createCluster() Class name %s does not exist\", null, className);\n          }\n        }\n\n      } finally {\n        sysdb.close();\n      }\n\n    } finally {\n      if (currentDB != null)\n        ODatabaseRecordThreadLocal.instance().set(currentDB);\n      else\n        ODatabaseRecordThreadLocal.instance().remove();\n    }\n  }", "language": "java", "code": "public void createCluster(final String className, final String clusterName) {\n    final ODatabaseDocumentInternal currentDB = ODatabaseRecordThreadLocal.instance().getIfDefined();\n    try {\n      final ODatabaseDocumentInternal sysdb = openSystemDatabase();\n      try {\n\n        if (!sysdb.existsCluster(clusterName)) {\n          OSchema schema = sysdb.getMetadata().getSchema();\n          OClass cls = schema.getClass(className);\n\n          if (cls != null) {\n            cls.addCluster(clusterName);\n          } else {\n            OLogManager.instance().error(this, \"createCluster() Class name %s does not exist\", null, className);\n          }\n        }\n\n      } finally {\n        sysdb.close();\n      }\n\n    } finally {\n      if (currentDB != null)\n        ODatabaseRecordThreadLocal.instance().set(currentDB);\n      else\n        ODatabaseRecordThreadLocal.instance().remove();\n    }\n  }", "code_tokens": ["public", "void", "createCluster", "(", "final", "String", "className", ",", "final", "String", "clusterName", ")", "{", "final", "ODatabaseDocumentInternal", "currentDB", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "getIfDefined", "(", ")", ";", "try", "{", "final", "ODatabaseDocumentInternal", "sysdb", "=", "openSystemDatabase", "(", ")", ";", "try", "{", "if", "(", "!", "sysdb", ".", "existsCluster", "(", "clusterName", ")", ")", "{", "OSchema", "schema", "=", "sysdb", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ";", "OClass", "cls", "=", "schema", ".", "getClass", "(", "className", ")", ";", "if", "(", "cls", "!=", "null", ")", "{", "cls", ".", "addCluster", "(", "clusterName", ")", ";", "}", "else", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"createCluster() Class name %s does not exist\"", ",", "null", ",", "className", ")", ";", "}", "}", "}", "finally", "{", "sysdb", ".", "close", "(", ")", ";", "}", "}", "finally", "{", "if", "(", "currentDB", "!=", "null", ")", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "set", "(", "currentDB", ")", ";", "else", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "remove", "(", ")", ";", "}", "}"], "docstring": "Adds the specified cluster to the class, if it doesn't already exist.", "docstring_tokens": ["Adds", "the", "specified", "cluster", "to", "the", "class", "if", "it", "doesn", "t", "already", "exist", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/OSystemDatabase.java#L55-L82", "partition": "test", "index": 3011, "time": "2016-05-24 15:43:55"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedOutput.java", "func_name": "ODistributedOutput.getCompactServerStatus", "original_string": "public static String getCompactServerStatus(final ODistributedServerManager manager, final ODocument distribCfg) {\n    final StringBuilder buffer = new StringBuilder();\n\n    final Collection<ODocument> members = distribCfg.field(\"members\");\n\n    if (members != null) {\n      buffer.append(members.size());\n      buffer.append(\":[\");\n\n      int memberCount = 0;\n      for (ODocument m : members) {\n        if (m == null)\n          continue;\n\n        if (memberCount++ > 0)\n          buffer.append(\",\");\n\n        final String serverName = m.field(\"name\");\n        buffer.append(serverName);\n        buffer.append((Object)m.field(\"status\"));\n\n        final Collection<String> databases = m.field(\"databases\");\n        if (databases != null) {\n          buffer.append(\"{\");\n          int dbCount = 0;\n          for (String dbName : databases) {\n            final ODistributedConfiguration dbCfg = manager.getDatabaseConfiguration(dbName, false);\n\n            if (dbCfg == null)\n              continue;\n\n            if (dbCount++ > 0)\n              buffer.append(\",\");\n\n            buffer.append(dbName);\n            buffer.append(\"=\");\n            buffer.append(manager.getDatabaseStatus(serverName, dbName));\n            buffer.append(\" (\");\n            buffer.append(dbCfg.getServerRole(serverName));\n            buffer.append(\")\");\n          }\n          buffer.append(\"}\");\n        }\n      }\n      buffer.append(\"]\");\n    }\n\n    return buffer.toString();\n  }", "language": "java", "code": "public static String getCompactServerStatus(final ODistributedServerManager manager, final ODocument distribCfg) {\n    final StringBuilder buffer = new StringBuilder();\n\n    final Collection<ODocument> members = distribCfg.field(\"members\");\n\n    if (members != null) {\n      buffer.append(members.size());\n      buffer.append(\":[\");\n\n      int memberCount = 0;\n      for (ODocument m : members) {\n        if (m == null)\n          continue;\n\n        if (memberCount++ > 0)\n          buffer.append(\",\");\n\n        final String serverName = m.field(\"name\");\n        buffer.append(serverName);\n        buffer.append((Object)m.field(\"status\"));\n\n        final Collection<String> databases = m.field(\"databases\");\n        if (databases != null) {\n          buffer.append(\"{\");\n          int dbCount = 0;\n          for (String dbName : databases) {\n            final ODistributedConfiguration dbCfg = manager.getDatabaseConfiguration(dbName, false);\n\n            if (dbCfg == null)\n              continue;\n\n            if (dbCount++ > 0)\n              buffer.append(\",\");\n\n            buffer.append(dbName);\n            buffer.append(\"=\");\n            buffer.append(manager.getDatabaseStatus(serverName, dbName));\n            buffer.append(\" (\");\n            buffer.append(dbCfg.getServerRole(serverName));\n            buffer.append(\")\");\n          }\n          buffer.append(\"}\");\n        }\n      }\n      buffer.append(\"]\");\n    }\n\n    return buffer.toString();\n  }", "code_tokens": ["public", "static", "String", "getCompactServerStatus", "(", "final", "ODistributedServerManager", "manager", ",", "final", "ODocument", "distribCfg", ")", "{", "final", "StringBuilder", "buffer", "=", "new", "StringBuilder", "(", ")", ";", "final", "Collection", "<", "ODocument", ">", "members", "=", "distribCfg", ".", "field", "(", "\"members\"", ")", ";", "if", "(", "members", "!=", "null", ")", "{", "buffer", ".", "append", "(", "members", ".", "size", "(", ")", ")", ";", "buffer", ".", "append", "(", "\":[\"", ")", ";", "int", "memberCount", "=", "0", ";", "for", "(", "ODocument", "m", ":", "members", ")", "{", "if", "(", "m", "==", "null", ")", "continue", ";", "if", "(", "memberCount", "++", ">", "0", ")", "buffer", ".", "append", "(", "\",\"", ")", ";", "final", "String", "serverName", "=", "m", ".", "field", "(", "\"name\"", ")", ";", "buffer", ".", "append", "(", "serverName", ")", ";", "buffer", ".", "append", "(", "(", "Object", ")", "m", ".", "field", "(", "\"status\"", ")", ")", ";", "final", "Collection", "<", "String", ">", "databases", "=", "m", ".", "field", "(", "\"databases\"", ")", ";", "if", "(", "databases", "!=", "null", ")", "{", "buffer", ".", "append", "(", "\"{\"", ")", ";", "int", "dbCount", "=", "0", ";", "for", "(", "String", "dbName", ":", "databases", ")", "{", "final", "ODistributedConfiguration", "dbCfg", "=", "manager", ".", "getDatabaseConfiguration", "(", "dbName", ",", "false", ")", ";", "if", "(", "dbCfg", "==", "null", ")", "continue", ";", "if", "(", "dbCount", "++", ">", "0", ")", "buffer", ".", "append", "(", "\",\"", ")", ";", "buffer", ".", "append", "(", "dbName", ")", ";", "buffer", ".", "append", "(", "\"=\"", ")", ";", "buffer", ".", "append", "(", "manager", ".", "getDatabaseStatus", "(", "serverName", ",", "dbName", ")", ")", ";", "buffer", ".", "append", "(", "\" (\"", ")", ";", "buffer", ".", "append", "(", "dbCfg", ".", "getServerRole", "(", "serverName", ")", ")", ";", "buffer", ".", "append", "(", "\")\"", ")", ";", "}", "buffer", ".", "append", "(", "\"}\"", ")", ";", "}", "}", "buffer", ".", "append", "(", "\"]\"", ")", ";", "}", "return", "buffer", ".", "toString", "(", ")", ";", "}"], "docstring": "Create a compact string with all the relevant information.\n\n@param manager\n@param distribCfg\n\n@return", "docstring_tokens": ["Create", "a", "compact", "string", "with", "all", "the", "relevant", "information", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedOutput.java#L432-L480", "partition": "test", "index": 2934, "time": "2016-06-03 19:22:05"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentEmbedded.java", "func_name": "ODatabaseDocumentEmbedded.copy", "original_string": "public ODatabaseDocumentInternal copy() {\n    ODatabaseDocumentEmbedded database = new ODatabaseDocumentEmbedded(getSharedContext().getStorage());\n    database.init(config, this.sharedContext);\n    String user;\n    if (getUser() != null) {\n      user = getUser().getName();\n    } else {\n      user = null;\n    }\n    database.internalOpen(user, null, false);\n    database.callOnOpenListeners();\n    this.activateOnCurrentThread();\n    return database;\n  }", "language": "java", "code": "public ODatabaseDocumentInternal copy() {\n    ODatabaseDocumentEmbedded database = new ODatabaseDocumentEmbedded(getSharedContext().getStorage());\n    database.init(config, this.sharedContext);\n    String user;\n    if (getUser() != null) {\n      user = getUser().getName();\n    } else {\n      user = null;\n    }\n    database.internalOpen(user, null, false);\n    database.callOnOpenListeners();\n    this.activateOnCurrentThread();\n    return database;\n  }", "code_tokens": ["public", "ODatabaseDocumentInternal", "copy", "(", ")", "{", "ODatabaseDocumentEmbedded", "database", "=", "new", "ODatabaseDocumentEmbedded", "(", "getSharedContext", "(", ")", ".", "getStorage", "(", ")", ")", ";", "database", ".", "init", "(", "config", ",", "this", ".", "sharedContext", ")", ";", "String", "user", ";", "if", "(", "getUser", "(", ")", "!=", "null", ")", "{", "user", "=", "getUser", "(", ")", ".", "getName", "(", ")", ";", "}", "else", "{", "user", "=", "null", ";", "}", "database", ".", "internalOpen", "(", "user", ",", "null", ",", "false", ")", ";", "database", ".", "callOnOpenListeners", "(", ")", ";", "this", ".", "activateOnCurrentThread", "(", ")", ";", "return", "database", ";", "}"], "docstring": "Returns a copy of current database if it's open. The returned instance can be used by another thread without affecting current\ninstance. The database copy is not set in thread local.", "docstring_tokens": ["Returns", "a", "copy", "of", "current", "database", "if", "it", "s", "open", ".", "The", "returned", "instance", "can", "be", "used", "by", "another", "thread", "without", "affecting", "current", "instance", ".", "The", "database", "copy", "is", "not", "set", "in", "thread", "local", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentEmbedded.java#L488-L501", "partition": "test", "index": 3031, "time": "2016-06-28 17:56:11"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.acquire", "original_string": "public OClosableEntry<K, V> acquire(K key) throws InterruptedException {\n    checkOpenFilesLimit();\n\n    final OClosableEntry<K, V> entry = data.get(key);\n\n    if (entry == null)\n      return null;\n\n    boolean logOpen = false;\n    entry.acquireStateLock();\n    try {\n      if (entry.isRetired() || entry.isDead()) {\n        return null;\n      } else if (entry.isClosed()) {\n        entry.makeAcquiredFromClosed(entry.get());\n        logOpen = true;\n      } else if (entry.isOpen()) {\n        entry.makeAcquiredFromOpen();\n      } else {\n        entry.incrementAcquired();\n      }\n    } finally {\n      entry.releaseStateLock();\n    }\n\n    if (logOpen) {\n      logOpen(entry);\n    } else {\n      logAcquire(entry);\n    }\n\n    assert entry.get().isOpen();\n    return entry;\n  }", "language": "java", "code": "public OClosableEntry<K, V> acquire(K key) throws InterruptedException {\n    checkOpenFilesLimit();\n\n    final OClosableEntry<K, V> entry = data.get(key);\n\n    if (entry == null)\n      return null;\n\n    boolean logOpen = false;\n    entry.acquireStateLock();\n    try {\n      if (entry.isRetired() || entry.isDead()) {\n        return null;\n      } else if (entry.isClosed()) {\n        entry.makeAcquiredFromClosed(entry.get());\n        logOpen = true;\n      } else if (entry.isOpen()) {\n        entry.makeAcquiredFromOpen();\n      } else {\n        entry.incrementAcquired();\n      }\n    } finally {\n      entry.releaseStateLock();\n    }\n\n    if (logOpen) {\n      logOpen(entry);\n    } else {\n      logAcquire(entry);\n    }\n\n    assert entry.get().isOpen();\n    return entry;\n  }", "code_tokens": ["public", "OClosableEntry", "<", "K", ",", "V", ">", "acquire", "(", "K", "key", ")", "throws", "InterruptedException", "{", "checkOpenFilesLimit", "(", ")", ";", "final", "OClosableEntry", "<", "K", ",", "V", ">", "entry", "=", "data", ".", "get", "(", "key", ")", ";", "if", "(", "entry", "==", "null", ")", "return", "null", ";", "boolean", "logOpen", "=", "false", ";", "entry", ".", "acquireStateLock", "(", ")", ";", "try", "{", "if", "(", "entry", ".", "isRetired", "(", ")", "||", "entry", ".", "isDead", "(", ")", ")", "{", "return", "null", ";", "}", "else", "if", "(", "entry", ".", "isClosed", "(", ")", ")", "{", "entry", ".", "makeAcquiredFromClosed", "(", "entry", ".", "get", "(", ")", ")", ";", "logOpen", "=", "true", ";", "}", "else", "if", "(", "entry", ".", "isOpen", "(", ")", ")", "{", "entry", ".", "makeAcquiredFromOpen", "(", ")", ";", "}", "else", "{", "entry", ".", "incrementAcquired", "(", ")", ";", "}", "}", "finally", "{", "entry", ".", "releaseStateLock", "(", ")", ";", "}", "if", "(", "logOpen", ")", "{", "logOpen", "(", "entry", ")", ";", "}", "else", "{", "logAcquire", "(", "entry", ")", ";", "}", "assert", "entry", ".", "get", "(", ")", ".", "isOpen", "(", ")", ";", "return", "entry", ";", "}"], "docstring": "Acquires item associated with passed in key in container.\nIt is guarantied that item will not be closed if limit of open items will be exceeded and container will close rarely used\nitems.\n\n@param key Key associated with item\n\n@return Acquired item if key exists into container or <code>null</code> if there is no item associated with given container", "docstring_tokens": ["Acquires", "item", "associated", "with", "passed", "in", "key", "in", "container", ".", "It", "is", "guarantied", "that", "item", "will", "not", "be", "closed", "if", "limit", "of", "open", "items", "will", "be", "exceeded", "and", "container", "will", "close", "rarely", "used", "items", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L280-L313", "partition": "test", "index": 3249, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.closestPowerOfTwo", "original_string": "private static int closestPowerOfTwo(int value) {\n    int n = value - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= (1 << 30)) ? 1 << 30 : n + 1;\n  }", "language": "java", "code": "private static int closestPowerOfTwo(int value) {\n    int n = value - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= (1 << 30)) ? 1 << 30 : n + 1;\n  }", "code_tokens": ["private", "static", "int", "closestPowerOfTwo", "(", "int", "value", ")", "{", "int", "n", "=", "value", "-", "1", ";", "n", "|=", "n", ">>>", "1", ";", "n", "|=", "n", ">>>", "2", ";", "n", "|=", "n", ">>>", "4", ";", "n", "|=", "n", ">>>", "8", ";", "n", "|=", "n", ">>>", "16", ";", "return", "(", "n", "<", "0", ")", "?", "1", ":", "(", "n", ">=", "(", "1", "<<", "30", ")", ")", "?", "1", "<<", "30", ":", "n", "+", "1", ";", "}"], "docstring": "Finds closest power of two for given integer value. Idea is simple duplicate the most significant bit to the lowest bits for\nthe smallest number of iterations possible and then increment result value by 1.\n\n@param value Integer the most significant power of 2 should be found.\n\n@return The most significant power of 2.", "docstring_tokens": ["Finds", "closest", "power", "of", "two", "for", "given", "integer", "value", ".", "Idea", "is", "simple", "duplicate", "the", "most", "significant", "bit", "to", "the", "lowest", "bits", "for", "the", "smallest", "number", "of", "iterations", "possible", "and", "then", "increment", "result", "value", "by", "1", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L749-L757", "partition": "test", "index": 3257, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.remove", "original_string": "public V remove(K key) {\n    final OClosableEntry<K, V> removed = data.remove(key);\n\n    if (removed != null) {\n      long preStatus = removed.makeRetired();\n\n      if (OClosableEntry.isOpen(preStatus)) {\n        countClosedFiles();\n      }\n\n      logRemoved(removed);\n      return removed.get();\n    }\n\n    return null;\n  }", "language": "java", "code": "public V remove(K key) {\n    final OClosableEntry<K, V> removed = data.remove(key);\n\n    if (removed != null) {\n      long preStatus = removed.makeRetired();\n\n      if (OClosableEntry.isOpen(preStatus)) {\n        countClosedFiles();\n      }\n\n      logRemoved(removed);\n      return removed.get();\n    }\n\n    return null;\n  }", "code_tokens": ["public", "V", "remove", "(", "K", "key", ")", "{", "final", "OClosableEntry", "<", "K", ",", "V", ">", "removed", "=", "data", ".", "remove", "(", "key", ")", ";", "if", "(", "removed", "!=", "null", ")", "{", "long", "preStatus", "=", "removed", ".", "makeRetired", "(", ")", ";", "if", "(", "OClosableEntry", ".", "isOpen", "(", "preStatus", ")", ")", "{", "countClosedFiles", "(", ")", ";", "}", "logRemoved", "(", "removed", ")", ";", "return", "removed", ".", "get", "(", ")", ";", "}", "return", "null", ";", "}"], "docstring": "Removes item associated with passed in key.\n\n@param key Key associated with item to remove.\n\n@return Removed item.", "docstring_tokens": ["Removes", "item", "associated", "with", "passed", "in", "key", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L254-L269", "partition": "test", "index": 3248, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.afterWrite", "original_string": "private void afterWrite(Runnable task) {\n    stateBuffer.add(task);\n    drainStatus.lazySet(DrainStatus.REQUIRED);\n    tryToDrainBuffers();\n  }", "language": "java", "code": "private void afterWrite(Runnable task) {\n    stateBuffer.add(task);\n    drainStatus.lazySet(DrainStatus.REQUIRED);\n    tryToDrainBuffers();\n  }", "code_tokens": ["private", "void", "afterWrite", "(", "Runnable", "task", ")", "{", "stateBuffer", ".", "add", "(", "task", ")", ";", "drainStatus", ".", "lazySet", "(", "DrainStatus", ".", "REQUIRED", ")", ";", "tryToDrainBuffers", "(", ")", ";", "}"], "docstring": "Method is used to log operations which change content of the container.\nSuch changes should be flushed immediately to update content of LRU list.\n\n@param task Task which contains code is used to manipulate LRU list", "docstring_tokens": ["Method", "is", "used", "to", "log", "operations", "which", "change", "content", "of", "the", "container", ".", "Such", "changes", "should", "be", "flushed", "immediately", "to", "update", "content", "of", "LRU", "list", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L608-L612", "partition": "test", "index": 3254, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.putEntryInReadBuffer", "original_string": "private long putEntryInReadBuffer(OClosableEntry<K, V> entry, int bufferIndex) {\n    //next index to write for this buffer\n    AtomicLong writeCounter = readBufferWriteCount[bufferIndex];\n    final long counter = writeCounter.get();\n\n    //we do not use CAS operations to limit contention between threads\n    //it is normal that because of duplications of indexes some of items will be lost\n    writeCounter.lazySet(counter + 1);\n\n    final AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[bufferIndex];\n    AtomicReference<OClosableEntry<K, V>> bufferEntry = buffer[(int) (counter & READ_BUFFER_INDEX_MASK)];\n    bufferEntry.lazySet(entry);\n\n    return counter + 1;\n  }", "language": "java", "code": "private long putEntryInReadBuffer(OClosableEntry<K, V> entry, int bufferIndex) {\n    //next index to write for this buffer\n    AtomicLong writeCounter = readBufferWriteCount[bufferIndex];\n    final long counter = writeCounter.get();\n\n    //we do not use CAS operations to limit contention between threads\n    //it is normal that because of duplications of indexes some of items will be lost\n    writeCounter.lazySet(counter + 1);\n\n    final AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[bufferIndex];\n    AtomicReference<OClosableEntry<K, V>> bufferEntry = buffer[(int) (counter & READ_BUFFER_INDEX_MASK)];\n    bufferEntry.lazySet(entry);\n\n    return counter + 1;\n  }", "code_tokens": ["private", "long", "putEntryInReadBuffer", "(", "OClosableEntry", "<", "K", ",", "V", ">", "entry", ",", "int", "bufferIndex", ")", "{", "//next index to write for this buffer", "AtomicLong", "writeCounter", "=", "readBufferWriteCount", "[", "bufferIndex", "]", ";", "final", "long", "counter", "=", "writeCounter", ".", "get", "(", ")", ";", "//we do not use CAS operations to limit contention between threads", "//it is normal that because of duplications of indexes some of items will be lost", "writeCounter", ".", "lazySet", "(", "counter", "+", "1", ")", ";", "final", "AtomicReference", "<", "OClosableEntry", "<", "K", ",", "V", ">", ">", "[", "]", "buffer", "=", "readBuffers", "[", "bufferIndex", "]", ";", "AtomicReference", "<", "OClosableEntry", "<", "K", ",", "V", ">", ">", "bufferEntry", "=", "buffer", "[", "(", "int", ")", "(", "counter", "&", "READ_BUFFER_INDEX_MASK", ")", "]", ";", "bufferEntry", ".", "lazySet", "(", "entry", ")", ";", "return", "counter", "+", "1", ";", "}"], "docstring": "Adds entry to the read buffer with selected index and returns amount of writes to this buffer since creation of this container.\n\n@param entry       LRU entry to add.\n@param bufferIndex Index of buffer\n\n@return Amount of writes to the buffer since creation of this container.", "docstring_tokens": ["Adds", "entry", "to", "the", "read", "buffer", "with", "selected", "index", "and", "returns", "amount", "of", "writes", "to", "this", "buffer", "since", "creation", "of", "this", "container", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L634-L648", "partition": "test", "index": 3256, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.afterRead", "original_string": "private void afterRead(OClosableEntry<K, V> entry) {\n    final int bufferIndex = readBufferIndex();\n    final long writeCount = putEntryInReadBuffer(entry, bufferIndex);\n    drainReadBuffersIfNeeded(bufferIndex, writeCount);\n  }", "language": "java", "code": "private void afterRead(OClosableEntry<K, V> entry) {\n    final int bufferIndex = readBufferIndex();\n    final long writeCount = putEntryInReadBuffer(entry, bufferIndex);\n    drainReadBuffersIfNeeded(bufferIndex, writeCount);\n  }", "code_tokens": ["private", "void", "afterRead", "(", "OClosableEntry", "<", "K", ",", "V", ">", "entry", ")", "{", "final", "int", "bufferIndex", "=", "readBufferIndex", "(", ")", ";", "final", "long", "writeCount", "=", "putEntryInReadBuffer", "(", "entry", ",", "bufferIndex", ")", ";", "drainReadBuffersIfNeeded", "(", "bufferIndex", ",", "writeCount", ")", ";", "}"], "docstring": "Method is used to log operations which do not change LRU list content but affect order of items inside of LRU list.\nSuch changes may be delayed till buffer will be full.\n\n@param entry Entry which was affected by operation.", "docstring_tokens": ["Method", "is", "used", "to", "log", "operations", "which", "do", "not", "change", "LRU", "list", "content", "but", "affect", "order", "of", "items", "inside", "of", "LRU", "list", ".", "Such", "changes", "may", "be", "delayed", "till", "buffer", "will", "be", "full", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L620-L624", "partition": "test", "index": 3255, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.emptyReadBuffers", "original_string": "private void emptyReadBuffers() {\n    for (int n = 0; n < NUMBER_OF_READ_BUFFERS; n++) {\n      AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[n];\n\n      long writeCount = readBufferDrainAtWriteCount[n].get();\n      long counter = readBufferReadCount[n];\n\n      while (true) {\n        final int bufferIndex = (int) (counter & READ_BUFFER_INDEX_MASK);\n        final AtomicReference<OClosableEntry<K, V>> eref = buffer[bufferIndex];\n        final OClosableEntry<K, V> entry = eref.get();\n\n        if (entry == null)\n          break;\n\n        applyRead(entry);\n        counter++;\n\n        eref.lazySet(null);\n      }\n\n      readBufferReadCount[n] = counter;\n      readBufferDrainAtWriteCount[n].lazySet(writeCount);\n    }\n  }", "language": "java", "code": "private void emptyReadBuffers() {\n    for (int n = 0; n < NUMBER_OF_READ_BUFFERS; n++) {\n      AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[n];\n\n      long writeCount = readBufferDrainAtWriteCount[n].get();\n      long counter = readBufferReadCount[n];\n\n      while (true) {\n        final int bufferIndex = (int) (counter & READ_BUFFER_INDEX_MASK);\n        final AtomicReference<OClosableEntry<K, V>> eref = buffer[bufferIndex];\n        final OClosableEntry<K, V> entry = eref.get();\n\n        if (entry == null)\n          break;\n\n        applyRead(entry);\n        counter++;\n\n        eref.lazySet(null);\n      }\n\n      readBufferReadCount[n] = counter;\n      readBufferDrainAtWriteCount[n].lazySet(writeCount);\n    }\n  }", "code_tokens": ["private", "void", "emptyReadBuffers", "(", ")", "{", "for", "(", "int", "n", "=", "0", ";", "n", "<", "NUMBER_OF_READ_BUFFERS", ";", "n", "++", ")", "{", "AtomicReference", "<", "OClosableEntry", "<", "K", ",", "V", ">", ">", "[", "]", "buffer", "=", "readBuffers", "[", "n", "]", ";", "long", "writeCount", "=", "readBufferDrainAtWriteCount", "[", "n", "]", ".", "get", "(", ")", ";", "long", "counter", "=", "readBufferReadCount", "[", "n", "]", ";", "while", "(", "true", ")", "{", "final", "int", "bufferIndex", "=", "(", "int", ")", "(", "counter", "&", "READ_BUFFER_INDEX_MASK", ")", ";", "final", "AtomicReference", "<", "OClosableEntry", "<", "K", ",", "V", ">", ">", "eref", "=", "buffer", "[", "bufferIndex", "]", ";", "final", "OClosableEntry", "<", "K", ",", "V", ">", "entry", "=", "eref", ".", "get", "(", ")", ";", "if", "(", "entry", "==", "null", ")", "break", ";", "applyRead", "(", "entry", ")", ";", "counter", "++", ";", "eref", ".", "lazySet", "(", "null", ")", ";", "}", "readBufferReadCount", "[", "n", "]", "=", "counter", ";", "readBufferDrainAtWriteCount", "[", "n", "]", ".", "lazySet", "(", "writeCount", ")", ";", "}", "}"], "docstring": "Read content of all read buffers and reorder elements inside of LRU list to update internal statistic.\nMethod has to be wrapped by LRU lock.", "docstring_tokens": ["Read", "content", "of", "all", "read", "buffers", "and", "reorder", "elements", "inside", "of", "LRU", "list", "to", "update", "internal", "statistic", ".", "Method", "has", "to", "be", "wrapped", "by", "LRU", "lock", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L525-L549", "partition": "test", "index": 3253, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.close", "original_string": "public boolean close(K key) {\n    emptyBuffers();\n\n    final OClosableEntry<K, V> entry = data.get(key);\n    if (entry == null)\n      return true;\n\n    if (entry.makeClosed()) {\n      countClosedFiles();\n\n      return true;\n    }\n\n    return false;\n  }", "language": "java", "code": "public boolean close(K key) {\n    emptyBuffers();\n\n    final OClosableEntry<K, V> entry = data.get(key);\n    if (entry == null)\n      return true;\n\n    if (entry.makeClosed()) {\n      countClosedFiles();\n\n      return true;\n    }\n\n    return false;\n  }", "code_tokens": ["public", "boolean", "close", "(", "K", "key", ")", "{", "emptyBuffers", "(", ")", ";", "final", "OClosableEntry", "<", "K", ",", "V", ">", "entry", "=", "data", ".", "get", "(", "key", ")", ";", "if", "(", "entry", "==", "null", ")", "return", "true", ";", "if", "(", "entry", ".", "makeClosed", "(", ")", ")", "{", "countClosedFiles", "(", ")", ";", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Closes item related to passed in key.\nItem will be closed if it exists and is not acquired.\n\n@param key Key related to item that has going to be closed.\n\n@return <code>true</code> if item was closed and <code>false</code> otherwise.", "docstring_tokens": ["Closes", "item", "related", "to", "passed", "in", "key", ".", "Item", "will", "be", "closed", "if", "it", "exists", "and", "is", "not", "acquired", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L410-L424", "partition": "test", "index": 3252, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.clear", "original_string": "public void clear() {\n    lruLock.lock();\n    try {\n      data.clear();\n      openFiles.set(0);\n\n      for (int n = 0; n < NUMBER_OF_READ_BUFFERS; n++) {\n        final AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[n];\n        for (int i = 0; i < READ_BUFFER_SIZE; i++) {\n          buffer[i].set(null);\n        }\n\n        readBufferReadCount[n] = 0;\n        readBufferWriteCount[n].set(0);\n        readBufferDrainAtWriteCount[n].set(0);\n      }\n\n      stateBuffer.clear();\n\n      while (lruList.poll() != null)\n        ;\n    } finally {\n      lruLock.unlock();\n    }\n  }", "language": "java", "code": "public void clear() {\n    lruLock.lock();\n    try {\n      data.clear();\n      openFiles.set(0);\n\n      for (int n = 0; n < NUMBER_OF_READ_BUFFERS; n++) {\n        final AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[n];\n        for (int i = 0; i < READ_BUFFER_SIZE; i++) {\n          buffer[i].set(null);\n        }\n\n        readBufferReadCount[n] = 0;\n        readBufferWriteCount[n].set(0);\n        readBufferDrainAtWriteCount[n].set(0);\n      }\n\n      stateBuffer.clear();\n\n      while (lruList.poll() != null)\n        ;\n    } finally {\n      lruLock.unlock();\n    }\n  }", "code_tokens": ["public", "void", "clear", "(", ")", "{", "lruLock", ".", "lock", "(", ")", ";", "try", "{", "data", ".", "clear", "(", ")", ";", "openFiles", ".", "set", "(", "0", ")", ";", "for", "(", "int", "n", "=", "0", ";", "n", "<", "NUMBER_OF_READ_BUFFERS", ";", "n", "++", ")", "{", "final", "AtomicReference", "<", "OClosableEntry", "<", "K", ",", "V", ">", ">", "[", "]", "buffer", "=", "readBuffers", "[", "n", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "READ_BUFFER_SIZE", ";", "i", "++", ")", "{", "buffer", "[", "i", "]", ".", "set", "(", "null", ")", ";", "}", "readBufferReadCount", "[", "n", "]", "=", "0", ";", "readBufferWriteCount", "[", "n", "]", ".", "set", "(", "0", ")", ";", "readBufferDrainAtWriteCount", "[", "n", "]", ".", "set", "(", "0", ")", ";", "}", "stateBuffer", ".", "clear", "(", ")", ";", "while", "(", "lruList", ".", "poll", "(", ")", "!=", "null", ")", ";", "}", "finally", "{", "lruLock", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Clears all content.", "docstring_tokens": ["Clears", "all", "content", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L376-L400", "partition": "test", "index": 3251, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.add", "original_string": "public void add(K key, V item) throws InterruptedException {\n    if (!item.isOpen())\n      throw new IllegalArgumentException(\"All passed in items should be in open state\");\n\n    checkOpenFilesLimit();\n\n    final OClosableEntry<K, V> closableEntry = new OClosableEntry<K, V>(item);\n    final OClosableEntry<K, V> oldEntry = data.putIfAbsent(key, closableEntry);\n\n    if (oldEntry != null) {\n      throw new IllegalStateException(\"Item with key \" + key + \" already exists\");\n    }\n\n    logAdd(closableEntry);\n  }", "language": "java", "code": "public void add(K key, V item) throws InterruptedException {\n    if (!item.isOpen())\n      throw new IllegalArgumentException(\"All passed in items should be in open state\");\n\n    checkOpenFilesLimit();\n\n    final OClosableEntry<K, V> closableEntry = new OClosableEntry<K, V>(item);\n    final OClosableEntry<K, V> oldEntry = data.putIfAbsent(key, closableEntry);\n\n    if (oldEntry != null) {\n      throw new IllegalStateException(\"Item with key \" + key + \" already exists\");\n    }\n\n    logAdd(closableEntry);\n  }", "code_tokens": ["public", "void", "add", "(", "K", "key", ",", "V", "item", ")", "throws", "InterruptedException", "{", "if", "(", "!", "item", ".", "isOpen", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"All passed in items should be in open state\"", ")", ";", "checkOpenFilesLimit", "(", ")", ";", "final", "OClosableEntry", "<", "K", ",", "V", ">", "closableEntry", "=", "new", "OClosableEntry", "<", "K", ",", "V", ">", "(", "item", ")", ";", "final", "OClosableEntry", "<", "K", ",", "V", ">", "oldEntry", "=", "data", ".", "putIfAbsent", "(", "key", ",", "closableEntry", ")", ";", "if", "(", "oldEntry", "!=", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"Item with key \"", "+", "key", "+", "\" already exists\"", ")", ";", "}", "logAdd", "(", "closableEntry", ")", ";", "}"], "docstring": "Adds item to the container.\nItem should be in open state.\n\n@param key  Key associated with given item.\n@param item Item associated with passed in key.", "docstring_tokens": ["Adds", "item", "to", "the", "container", ".", "Item", "should", "be", "in", "open", "state", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L231-L245", "partition": "test", "index": 3247, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java", "func_name": "OClosableLinkedContainer.get", "original_string": "public V get(K key) {\n    final OClosableEntry<K, V> entry = data.get(key);\n    if (entry != null)\n      return entry.get();\n\n    return null;\n  }", "language": "java", "code": "public V get(K key) {\n    final OClosableEntry<K, V> entry = data.get(key);\n    if (entry != null)\n      return entry.get();\n\n    return null;\n  }", "code_tokens": ["public", "V", "get", "(", "K", "key", ")", "{", "final", "OClosableEntry", "<", "K", ",", "V", ">", "entry", "=", "data", ".", "get", "(", "key", ")", ";", "if", "(", "entry", "!=", "null", ")", "return", "entry", ".", "get", "(", ")", ";", "return", "null", ";", "}"], "docstring": "Returns item without acquiring it. State of item is not guarantied in such case.\n\n@param key Key associated with required item.\n\n@return Item associated with given key.", "docstring_tokens": ["Returns", "item", "without", "acquiring", "it", ".", "State", "of", "item", "is", "not", "guarantied", "in", "such", "case", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/collection/closabledictionary/OClosableLinkedContainer.java#L365-L371", "partition": "test", "index": 3250, "time": "2016-07-04 17:47:53"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.isServerContainingAllClusters", "original_string": "public boolean isServerContainingAllClusters(final String server, Collection<String> clusters) {\n\n    if (clusters == null || clusters.isEmpty())\n      clusters = DEFAULT_CLUSTER_NAME;\n\n    for (String cluster : clusters) {\n      final List<String> serverList = getClusterConfiguration(cluster).field(SERVERS);\n      if (serverList != null) {\n        if (!serverList.contains(server))\n          return false;\n      }\n    }\n    return true;\n  }", "language": "java", "code": "public boolean isServerContainingAllClusters(final String server, Collection<String> clusters) {\n\n    if (clusters == null || clusters.isEmpty())\n      clusters = DEFAULT_CLUSTER_NAME;\n\n    for (String cluster : clusters) {\n      final List<String> serverList = getClusterConfiguration(cluster).field(SERVERS);\n      if (serverList != null) {\n        if (!serverList.contains(server))\n          return false;\n      }\n    }\n    return true;\n  }", "code_tokens": ["public", "boolean", "isServerContainingAllClusters", "(", "final", "String", "server", ",", "Collection", "<", "String", ">", "clusters", ")", "{", "if", "(", "clusters", "==", "null", "||", "clusters", ".", "isEmpty", "(", ")", ")", "clusters", "=", "DEFAULT_CLUSTER_NAME", ";", "for", "(", "String", "cluster", ":", "clusters", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "cluster", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", ")", "{", "if", "(", "!", "serverList", ".", "contains", "(", "server", ")", ")", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "docstring": "Returns true if the local server has all the requested clusters.\n\n@param server   Server name\n@param clusters Collection of cluster names to find", "docstring_tokens": ["Returns", "true", "if", "the", "local", "server", "has", "all", "the", "requested", "clusters", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L310-L323", "partition": "test", "index": 3090, "time": "2016-07-04 19:59:43"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getDataCenters", "original_string": "public Set<String> getDataCenters() {\n\n    final ODocument dcs = configuration.field(DCS);\n    if (dcs == null)\n      return Collections.EMPTY_SET;\n\n    final Set<String> result = new HashSet<String>();\n    for (String dc : dcs.fieldNames()) {\n      result.add(dc);\n    }\n    return result;\n  }", "language": "java", "code": "public Set<String> getDataCenters() {\n\n    final ODocument dcs = configuration.field(DCS);\n    if (dcs == null)\n      return Collections.EMPTY_SET;\n\n    final Set<String> result = new HashSet<String>();\n    for (String dc : dcs.fieldNames()) {\n      result.add(dc);\n    }\n    return result;\n  }", "code_tokens": ["public", "Set", "<", "String", ">", "getDataCenters", "(", ")", "{", "final", "ODocument", "dcs", "=", "configuration", ".", "field", "(", "DCS", ")", ";", "if", "(", "dcs", "==", "null", ")", "return", "Collections", ".", "EMPTY_SET", ";", "final", "Set", "<", "String", ">", "result", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "for", "(", "String", "dc", ":", "dcs", ".", "fieldNames", "(", ")", ")", "{", "result", ".", "add", "(", "dc", ")", ";", "}", "return", "result", ";", "}"], "docstring": "Returns all the configured data centers' names, if any.", "docstring_tokens": ["Returns", "all", "the", "configured", "data", "centers", "names", "if", "any", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L574-L585", "partition": "test", "index": 3100, "time": "2016-07-04 19:59:43"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getDataCenterWriteQuorum", "original_string": "public int getDataCenterWriteQuorum(final String dataCenter) {\n\n    final ODocument dc = getDataCenterConfiguration(dataCenter);\n\n    Object wq = dc.field(WRITE_QUORUM);\n    if (wq instanceof String) {\n      if (wq.toString().equalsIgnoreCase(ODistributedConfiguration.QUORUM_MAJORITY)) {\n        final List<String> servers = dc.field(SERVERS);\n        wq = servers.size() / 2 + 1;\n      } else if (wq.toString().equalsIgnoreCase(ODistributedConfiguration.QUORUM_ALL)) {\n        final List<String> servers = dc.field(SERVERS);\n        wq = servers.size();\n      }\n    }\n\n    return (Integer) wq;\n  }", "language": "java", "code": "public int getDataCenterWriteQuorum(final String dataCenter) {\n\n    final ODocument dc = getDataCenterConfiguration(dataCenter);\n\n    Object wq = dc.field(WRITE_QUORUM);\n    if (wq instanceof String) {\n      if (wq.toString().equalsIgnoreCase(ODistributedConfiguration.QUORUM_MAJORITY)) {\n        final List<String> servers = dc.field(SERVERS);\n        wq = servers.size() / 2 + 1;\n      } else if (wq.toString().equalsIgnoreCase(ODistributedConfiguration.QUORUM_ALL)) {\n        final List<String> servers = dc.field(SERVERS);\n        wq = servers.size();\n      }\n    }\n\n    return (Integer) wq;\n  }", "code_tokens": ["public", "int", "getDataCenterWriteQuorum", "(", "final", "String", "dataCenter", ")", "{", "final", "ODocument", "dc", "=", "getDataCenterConfiguration", "(", "dataCenter", ")", ";", "Object", "wq", "=", "dc", ".", "field", "(", "WRITE_QUORUM", ")", ";", "if", "(", "wq", "instanceof", "String", ")", "{", "if", "(", "wq", ".", "toString", "(", ")", ".", "equalsIgnoreCase", "(", "ODistributedConfiguration", ".", "QUORUM_MAJORITY", ")", ")", "{", "final", "List", "<", "String", ">", "servers", "=", "dc", ".", "field", "(", "SERVERS", ")", ";", "wq", "=", "servers", ".", "size", "(", ")", "/", "2", "+", "1", ";", "}", "else", "if", "(", "wq", ".", "toString", "(", ")", ".", "equalsIgnoreCase", "(", "ODistributedConfiguration", ".", "QUORUM_ALL", ")", ")", "{", "final", "List", "<", "String", ">", "servers", "=", "dc", ".", "field", "(", "SERVERS", ")", ";", "wq", "=", "servers", ".", "size", "(", ")", ";", "}", "}", "return", "(", "Integer", ")", "wq", ";", "}"], "docstring": "Returns the data center write quorum.\n\n@param dataCenter Data center name", "docstring_tokens": ["Returns", "the", "data", "center", "write", "quorum", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L592-L608", "partition": "test", "index": 3101, "time": "2016-07-04 19:59:43"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getDataCenterServers", "original_string": "public List<String> getDataCenterServers(final String dataCenter) {\n\n    final ODocument dc = getDataCenterConfiguration(dataCenter);\n\n    final List<String> servers = dc.field(SERVERS);\n    if (servers == null || servers.isEmpty())\n      throw new OConfigurationException(\n          \"Data center '\" + dataCenter + \"' does not contain any server in distributed database configuration\");\n\n    return new ArrayList<String>(servers);\n  }", "language": "java", "code": "public List<String> getDataCenterServers(final String dataCenter) {\n\n    final ODocument dc = getDataCenterConfiguration(dataCenter);\n\n    final List<String> servers = dc.field(SERVERS);\n    if (servers == null || servers.isEmpty())\n      throw new OConfigurationException(\n          \"Data center '\" + dataCenter + \"' does not contain any server in distributed database configuration\");\n\n    return new ArrayList<String>(servers);\n  }", "code_tokens": ["public", "List", "<", "String", ">", "getDataCenterServers", "(", "final", "String", "dataCenter", ")", "{", "final", "ODocument", "dc", "=", "getDataCenterConfiguration", "(", "dataCenter", ")", ";", "final", "List", "<", "String", ">", "servers", "=", "dc", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "servers", "==", "null", "||", "servers", ".", "isEmpty", "(", ")", ")", "throw", "new", "OConfigurationException", "(", "\"Data center '\"", "+", "dataCenter", "+", "\"' does not contain any server in distributed database configuration\"", ")", ";", "return", "new", "ArrayList", "<", "String", ">", "(", "servers", ")", ";", "}"], "docstring": "Returns the list of servers in a data center.\n\n@param dataCenter Data center name\n\n@throws OConfigurationException if the list of servers is not found in data center configuration", "docstring_tokens": ["Returns", "the", "list", "of", "servers", "in", "a", "data", "center", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L636-L646", "partition": "test", "index": 3103, "time": "2016-07-04 19:59:43"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getDataCenterOfServer", "original_string": "public String getDataCenterOfServer(final String server) {\n\n    final ODocument dcs = configuration.field(DCS);\n    if (dcs != null) {\n      for (String dc : dcs.fieldNames()) {\n        final ODocument dcConfig = dcs.field(dc);\n        if (dcConfig != null) {\n          final List<String> dcServers = dcConfig.field(\"servers\");\n          if (dcServers != null && !dcServers.isEmpty()) {\n            if (dcServers.contains(server))\n              // FOUND\n              return dc;\n          }\n        }\n      }\n    }\n\n// NOT FOUND\n    return null;\n  }", "language": "java", "code": "public String getDataCenterOfServer(final String server) {\n\n    final ODocument dcs = configuration.field(DCS);\n    if (dcs != null) {\n      for (String dc : dcs.fieldNames()) {\n        final ODocument dcConfig = dcs.field(dc);\n        if (dcConfig != null) {\n          final List<String> dcServers = dcConfig.field(\"servers\");\n          if (dcServers != null && !dcServers.isEmpty()) {\n            if (dcServers.contains(server))\n              // FOUND\n              return dc;\n          }\n        }\n      }\n    }\n\n// NOT FOUND\n    return null;\n  }", "code_tokens": ["public", "String", "getDataCenterOfServer", "(", "final", "String", "server", ")", "{", "final", "ODocument", "dcs", "=", "configuration", ".", "field", "(", "DCS", ")", ";", "if", "(", "dcs", "!=", "null", ")", "{", "for", "(", "String", "dc", ":", "dcs", ".", "fieldNames", "(", ")", ")", "{", "final", "ODocument", "dcConfig", "=", "dcs", ".", "field", "(", "dc", ")", ";", "if", "(", "dcConfig", "!=", "null", ")", "{", "final", "List", "<", "String", ">", "dcServers", "=", "dcConfig", ".", "field", "(", "\"servers\"", ")", ";", "if", "(", "dcServers", "!=", "null", "&&", "!", "dcServers", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "dcServers", ".", "contains", "(", "server", ")", ")", "// FOUND", "return", "dc", ";", "}", "}", "}", "}", "// NOT FOUND", "return", "null", ";", "}"], "docstring": "Returns the data center where the server belongs.\n\n@param server Server name", "docstring_tokens": ["Returns", "the", "data", "center", "where", "the", "server", "belongs", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L653-L672", "partition": "test", "index": 3104, "time": "2016-07-04 19:59:43"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getGlobalReadQuorum", "original_string": "public Object getGlobalReadQuorum(final String iClusterName) {\n    Object value = getClusterConfiguration(iClusterName).field(READ_QUORUM);\n    if (value == null)\n      value = configuration.field(READ_QUORUM);\n    return value;\n  }", "language": "java", "code": "public Object getGlobalReadQuorum(final String iClusterName) {\n    Object value = getClusterConfiguration(iClusterName).field(READ_QUORUM);\n    if (value == null)\n      value = configuration.field(READ_QUORUM);\n    return value;\n  }", "code_tokens": ["public", "Object", "getGlobalReadQuorum", "(", "final", "String", "iClusterName", ")", "{", "Object", "value", "=", "getClusterConfiguration", "(", "iClusterName", ")", ".", "field", "(", "READ_QUORUM", ")", ";", "if", "(", "value", "==", "null", ")", "value", "=", "configuration", ".", "field", "(", "READ_QUORUM", ")", ";", "return", "value", ";", "}"], "docstring": "Returns the global read quorum.\n\n@param iClusterName Cluster name, or null for *", "docstring_tokens": ["Returns", "the", "global", "read", "quorum", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L693-L698", "partition": "test", "index": 3105, "time": "2016-07-04 19:59:43"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getDataCenterConfiguration", "original_string": "private ODocument getDataCenterConfiguration(final String dataCenter) {\n    final ODocument dcs = configuration.field(DCS);\n    if (dcs != null)\n      return dcs.field(dataCenter);\n    throw new OConfigurationException(\"Cannot find the data center '\" + dataCenter + \"' in distributed database configuration\");\n\n  }", "language": "java", "code": "private ODocument getDataCenterConfiguration(final String dataCenter) {\n    final ODocument dcs = configuration.field(DCS);\n    if (dcs != null)\n      return dcs.field(dataCenter);\n    throw new OConfigurationException(\"Cannot find the data center '\" + dataCenter + \"' in distributed database configuration\");\n\n  }", "code_tokens": ["private", "ODocument", "getDataCenterConfiguration", "(", "final", "String", "dataCenter", ")", "{", "final", "ODocument", "dcs", "=", "configuration", ".", "field", "(", "DCS", ")", ";", "if", "(", "dcs", "!=", "null", ")", "return", "dcs", ".", "field", "(", "dataCenter", ")", ";", "throw", "new", "OConfigurationException", "(", "\"Cannot find the data center '\"", "+", "dataCenter", "+", "\"' in distributed database configuration\"", ")", ";", "}"], "docstring": "Gets the document representing the dc configuration.\n\n@param dataCenter Data center name\n\n@return Always a ODocument\n\n@throws OConfigurationException if the data center configuration is not found", "docstring_tokens": ["Gets", "the", "document", "representing", "the", "dc", "configuration", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L774-L780", "partition": "test", "index": 3108, "time": "2016-07-04 19:59:43"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cache/local/OWOWCache.java", "func_name": "OWOWCache.removeBackgroundExceptionListener", "original_string": "@Override\n  public void removeBackgroundExceptionListener(final OBackgroundExceptionListener listener) {\n    final List<WeakReference<OBackgroundExceptionListener>> itemsToRemove = new ArrayList<>(1);\n\n    for (final WeakReference<OBackgroundExceptionListener> ref : backgroundExceptionListeners) {\n      final OBackgroundExceptionListener l = ref.get();\n      if (l != null && l.equals(listener)) {\n        itemsToRemove.add(ref);\n      }\n    }\n\n    backgroundExceptionListeners.removeAll(itemsToRemove);\n  }", "language": "java", "code": "@Override\n  public void removeBackgroundExceptionListener(final OBackgroundExceptionListener listener) {\n    final List<WeakReference<OBackgroundExceptionListener>> itemsToRemove = new ArrayList<>(1);\n\n    for (final WeakReference<OBackgroundExceptionListener> ref : backgroundExceptionListeners) {\n      final OBackgroundExceptionListener l = ref.get();\n      if (l != null && l.equals(listener)) {\n        itemsToRemove.add(ref);\n      }\n    }\n\n    backgroundExceptionListeners.removeAll(itemsToRemove);\n  }", "code_tokens": ["@", "Override", "public", "void", "removeBackgroundExceptionListener", "(", "final", "OBackgroundExceptionListener", "listener", ")", "{", "final", "List", "<", "WeakReference", "<", "OBackgroundExceptionListener", ">", ">", "itemsToRemove", "=", "new", "ArrayList", "<>", "(", "1", ")", ";", "for", "(", "final", "WeakReference", "<", "OBackgroundExceptionListener", ">", "ref", ":", "backgroundExceptionListeners", ")", "{", "final", "OBackgroundExceptionListener", "l", "=", "ref", ".", "get", "(", ")", ";", "if", "(", "l", "!=", "null", "&&", "l", ".", "equals", "(", "listener", ")", ")", "{", "itemsToRemove", ".", "add", "(", "ref", ")", ";", "}", "}", "backgroundExceptionListeners", ".", "removeAll", "(", "itemsToRemove", ")", ";", "}"], "docstring": "Removes listener which is triggered if exception is cast inside background flush data thread.\n\n@param listener Listener to remove", "docstring_tokens": ["Removes", "listener", "which", "is", "triggered", "if", "exception", "is", "cast", "inside", "background", "flush", "data", "thread", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/cache/local/OWOWCache.java#L503-L515", "partition": "test", "index": 3129, "time": "2016-07-05 11:04:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cache/local/OWOWCache.java", "func_name": "OWOWCache.fireBackgroundDataFlushExceptionEvent", "original_string": "private void fireBackgroundDataFlushExceptionEvent(final Throwable e) {\n    for (final WeakReference<OBackgroundExceptionListener> ref : backgroundExceptionListeners) {\n      final OBackgroundExceptionListener listener = ref.get();\n      if (listener != null) {\n        listener.onException(e);\n      }\n    }\n  }", "language": "java", "code": "private void fireBackgroundDataFlushExceptionEvent(final Throwable e) {\n    for (final WeakReference<OBackgroundExceptionListener> ref : backgroundExceptionListeners) {\n      final OBackgroundExceptionListener listener = ref.get();\n      if (listener != null) {\n        listener.onException(e);\n      }\n    }\n  }", "code_tokens": ["private", "void", "fireBackgroundDataFlushExceptionEvent", "(", "final", "Throwable", "e", ")", "{", "for", "(", "final", "WeakReference", "<", "OBackgroundExceptionListener", ">", "ref", ":", "backgroundExceptionListeners", ")", "{", "final", "OBackgroundExceptionListener", "listener", "=", "ref", ".", "get", "(", ")", ";", "if", "(", "listener", "!=", "null", ")", "{", "listener", ".", "onException", "(", "e", ")", ";", "}", "}", "}"], "docstring": "Fires event about exception is thrown in data flush thread", "docstring_tokens": ["Fires", "event", "about", "exception", "is", "thrown", "in", "data", "flush", "thread"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/cache/local/OWOWCache.java#L520-L527", "partition": "test", "index": 3130, "time": "2016-07-05 11:04:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.extractSubQueries", "original_string": "private static void extractSubQueries(QueryPlanningInfo info) {\n    SubQueryCollector collector = new SubQueryCollector();\n    if (info.perRecordLetClause != null) {\n      info.perRecordLetClause.extractSubQueries(collector);\n    }\n    int i = 0;\n    int j = 0;\n    for (Map.Entry<OIdentifier, OStatement> entry : collector.getSubQueries().entrySet()) {\n      OIdentifier alias = entry.getKey();\n      OStatement query = entry.getValue();\n      if (query.refersToParent()) {\n        addRecordLevelLet(info, alias, query, j++);\n      } else {\n        addGlobalLet(info, alias, query, i++);\n      }\n    }\n    collector.reset();\n\n    if (info.whereClause != null) {\n      info.whereClause.extractSubQueries(collector);\n    }\n    if (info.projection != null) {\n      info.projection.extractSubQueries(collector);\n    }\n    if (info.orderBy != null) {\n      info.orderBy.extractSubQueries(collector);\n    }\n    if (info.groupBy != null) {\n      info.groupBy.extractSubQueries(collector);\n    }\n\n    for (Map.Entry<OIdentifier, OStatement> entry : collector.getSubQueries().entrySet()) {\n      OIdentifier alias = entry.getKey();\n      OStatement query = entry.getValue();\n      if (query.refersToParent()) {\n        addRecordLevelLet(info, alias, query);\n      } else {\n        addGlobalLet(info, alias, query);\n      }\n    }\n  }", "language": "java", "code": "private static void extractSubQueries(QueryPlanningInfo info) {\n    SubQueryCollector collector = new SubQueryCollector();\n    if (info.perRecordLetClause != null) {\n      info.perRecordLetClause.extractSubQueries(collector);\n    }\n    int i = 0;\n    int j = 0;\n    for (Map.Entry<OIdentifier, OStatement> entry : collector.getSubQueries().entrySet()) {\n      OIdentifier alias = entry.getKey();\n      OStatement query = entry.getValue();\n      if (query.refersToParent()) {\n        addRecordLevelLet(info, alias, query, j++);\n      } else {\n        addGlobalLet(info, alias, query, i++);\n      }\n    }\n    collector.reset();\n\n    if (info.whereClause != null) {\n      info.whereClause.extractSubQueries(collector);\n    }\n    if (info.projection != null) {\n      info.projection.extractSubQueries(collector);\n    }\n    if (info.orderBy != null) {\n      info.orderBy.extractSubQueries(collector);\n    }\n    if (info.groupBy != null) {\n      info.groupBy.extractSubQueries(collector);\n    }\n\n    for (Map.Entry<OIdentifier, OStatement> entry : collector.getSubQueries().entrySet()) {\n      OIdentifier alias = entry.getKey();\n      OStatement query = entry.getValue();\n      if (query.refersToParent()) {\n        addRecordLevelLet(info, alias, query);\n      } else {\n        addGlobalLet(info, alias, query);\n      }\n    }\n  }", "code_tokens": ["private", "static", "void", "extractSubQueries", "(", "QueryPlanningInfo", "info", ")", "{", "SubQueryCollector", "collector", "=", "new", "SubQueryCollector", "(", ")", ";", "if", "(", "info", ".", "perRecordLetClause", "!=", "null", ")", "{", "info", ".", "perRecordLetClause", ".", "extractSubQueries", "(", "collector", ")", ";", "}", "int", "i", "=", "0", ";", "int", "j", "=", "0", ";", "for", "(", "Map", ".", "Entry", "<", "OIdentifier", ",", "OStatement", ">", "entry", ":", "collector", ".", "getSubQueries", "(", ")", ".", "entrySet", "(", ")", ")", "{", "OIdentifier", "alias", "=", "entry", ".", "getKey", "(", ")", ";", "OStatement", "query", "=", "entry", ".", "getValue", "(", ")", ";", "if", "(", "query", ".", "refersToParent", "(", ")", ")", "{", "addRecordLevelLet", "(", "info", ",", "alias", ",", "query", ",", "j", "++", ")", ";", "}", "else", "{", "addGlobalLet", "(", "info", ",", "alias", ",", "query", ",", "i", "++", ")", ";", "}", "}", "collector", ".", "reset", "(", ")", ";", "if", "(", "info", ".", "whereClause", "!=", "null", ")", "{", "info", ".", "whereClause", ".", "extractSubQueries", "(", "collector", ")", ";", "}", "if", "(", "info", ".", "projection", "!=", "null", ")", "{", "info", ".", "projection", ".", "extractSubQueries", "(", "collector", ")", ";", "}", "if", "(", "info", ".", "orderBy", "!=", "null", ")", "{", "info", ".", "orderBy", ".", "extractSubQueries", "(", "collector", ")", ";", "}", "if", "(", "info", ".", "groupBy", "!=", "null", ")", "{", "info", ".", "groupBy", ".", "extractSubQueries", "(", "collector", ")", ";", "}", "for", "(", "Map", ".", "Entry", "<", "OIdentifier", ",", "OStatement", ">", "entry", ":", "collector", ".", "getSubQueries", "(", ")", ".", "entrySet", "(", ")", ")", "{", "OIdentifier", "alias", "=", "entry", ".", "getKey", "(", ")", ";", "OStatement", "query", "=", "entry", ".", "getValue", "(", ")", ";", "if", "(", "query", ".", "refersToParent", "(", ")", ")", "{", "addRecordLevelLet", "(", "info", ",", "alias", ",", "query", ")", ";", "}", "else", "{", "addGlobalLet", "(", "info", ",", "alias", ",", "query", ")", ";", "}", "}", "}"], "docstring": "translates subqueries to LET statements", "docstring_tokens": ["translates", "subqueries", "to", "LET", "statements"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L957-L997", "partition": "test", "index": 2922, "time": "2016-07-12 17:13:24"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.isServerContainingCluster", "original_string": "public boolean isServerContainingCluster(final String server, String cluster) {\n    if (cluster == null)\n      cluster = ALL_WILDCARD;\n\n    final List<String> serverList = getClusterConfiguration(cluster).field(SERVERS);\n    if (serverList != null) {\n      return serverList.contains(server);\n    }\n    return true;\n  }", "language": "java", "code": "public boolean isServerContainingCluster(final String server, String cluster) {\n    if (cluster == null)\n      cluster = ALL_WILDCARD;\n\n    final List<String> serverList = getClusterConfiguration(cluster).field(SERVERS);\n    if (serverList != null) {\n      return serverList.contains(server);\n    }\n    return true;\n  }", "code_tokens": ["public", "boolean", "isServerContainingCluster", "(", "final", "String", "server", ",", "String", "cluster", ")", "{", "if", "(", "cluster", "==", "null", ")", "cluster", "=", "ALL_WILDCARD", ";", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "cluster", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", ")", "{", "return", "serverList", ".", "contains", "(", "server", ")", ";", "}", "return", "true", ";", "}"], "docstring": "Returns true if the local server has the requested cluster.\n\n@param server  Server name\n@param cluster cluster names to find", "docstring_tokens": ["Returns", "true", "if", "the", "local", "server", "has", "the", "requested", "cluster", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L331-L340", "partition": "test", "index": 3091, "time": "2016-07-13 12:58:05"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OProjectionItem.java", "func_name": "OProjectionItem.splitForAggregation", "original_string": "public OProjectionItem splitForAggregation(AggregateProjectionSplit aggregateSplit, OCommandContext ctx) {\n    if (isAggregate()) {\n      OProjectionItem result = new OProjectionItem(-1);\n      result.alias = getProjectionAlias();\n      result.expression = expression.splitForAggregation(aggregateSplit, ctx);\n      result.nestedProjection = nestedProjection;\n      return result;\n    } else {\n      return this;\n    }\n  }", "language": "java", "code": "public OProjectionItem splitForAggregation(AggregateProjectionSplit aggregateSplit, OCommandContext ctx) {\n    if (isAggregate()) {\n      OProjectionItem result = new OProjectionItem(-1);\n      result.alias = getProjectionAlias();\n      result.expression = expression.splitForAggregation(aggregateSplit, ctx);\n      result.nestedProjection = nestedProjection;\n      return result;\n    } else {\n      return this;\n    }\n  }", "code_tokens": ["public", "OProjectionItem", "splitForAggregation", "(", "AggregateProjectionSplit", "aggregateSplit", ",", "OCommandContext", "ctx", ")", "{", "if", "(", "isAggregate", "(", ")", ")", "{", "OProjectionItem", "result", "=", "new", "OProjectionItem", "(", "-", "1", ")", ";", "result", ".", "alias", "=", "getProjectionAlias", "(", ")", ";", "result", ".", "expression", "=", "expression", ".", "splitForAggregation", "(", "aggregateSplit", ",", "ctx", ")", ";", "result", ".", "nestedProjection", "=", "nestedProjection", ";", "return", "result", ";", "}", "else", "{", "return", "this", ";", "}", "}"], "docstring": "INTERNAL USE ONLY this has to be invoked ONLY if the item is aggregate!!!\n\n@param aggregateSplit", "docstring_tokens": ["INTERNAL", "USE", "ONLY", "this", "has", "to", "be", "invoked", "ONLY", "if", "the", "item", "is", "aggregate!!!"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OProjectionItem.java#L211-L221", "partition": "test", "index": 2992, "time": "2016-07-16 15:51:15"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/OPartitionedDatabasePool.java", "func_name": "OPartitionedDatabasePool.setProperty", "original_string": "public Object setProperty(final String iName, final Object iValue) {\n    if (iValue != null) {\n      return properties.put(iName.toLowerCase(Locale.ENGLISH), iValue);\n    } else {\n      return properties.remove(iName.toLowerCase(Locale.ENGLISH));\n    }\n  }", "language": "java", "code": "public Object setProperty(final String iName, final Object iValue) {\n    if (iValue != null) {\n      return properties.put(iName.toLowerCase(Locale.ENGLISH), iValue);\n    } else {\n      return properties.remove(iName.toLowerCase(Locale.ENGLISH));\n    }\n  }", "code_tokens": ["public", "Object", "setProperty", "(", "final", "String", "iName", ",", "final", "Object", "iValue", ")", "{", "if", "(", "iValue", "!=", "null", ")", "{", "return", "properties", ".", "put", "(", "iName", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ",", "iValue", ")", ";", "}", "else", "{", "return", "properties", ".", "remove", "(", "iName", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ")", ";", "}", "}"], "docstring": "Sets a property value\n\n@param iName  Property name\n@param iValue new value to set\n\n@return The previous value if any, otherwise null", "docstring_tokens": ["Sets", "a", "property", "value"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/OPartitionedDatabasePool.java#L371-L377", "partition": "test", "index": 3323, "time": "2016-07-22 11:39:42"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphFactory.java", "func_name": "OrientGraphFactory.getProperty", "original_string": "public Object getProperty(final String iName) {\n    return properties.get(iName.toLowerCase(Locale.ENGLISH));\n  }", "language": "java", "code": "public Object getProperty(final String iName) {\n    return properties.get(iName.toLowerCase(Locale.ENGLISH));\n  }", "code_tokens": ["public", "Object", "getProperty", "(", "final", "String", "iName", ")", "{", "return", "properties", ".", "get", "(", "iName", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ")", ";", "}"], "docstring": "Gets the property value.\n\n@param iName Property name\n\n@return The previous value if any, otherwise null", "docstring_tokens": ["Gets", "the", "property", "value", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientGraphFactory.java#L417-L419", "partition": "test", "index": 3201, "time": "2016-07-22 11:43:07"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.isSharded", "original_string": "public boolean isSharded() {\n\n    final ODocument allCluster = getClusterConfiguration(ALL_WILDCARD);\n    if (allCluster != null) {\n      final List<String> allServers = allCluster.field(SERVERS);\n      if (allServers != null && !allServers.isEmpty()) {\n        for (String cl : getClusterNames()) {\n          final List<String> servers = getServers(cl, null);\n          if (servers != null && !servers.isEmpty() && !allServers.containsAll(servers))\n            return false;\n        }\n      }\n    }\n    return false;\n  }", "language": "java", "code": "public boolean isSharded() {\n\n    final ODocument allCluster = getClusterConfiguration(ALL_WILDCARD);\n    if (allCluster != null) {\n      final List<String> allServers = allCluster.field(SERVERS);\n      if (allServers != null && !allServers.isEmpty()) {\n        for (String cl : getClusterNames()) {\n          final List<String> servers = getServers(cl, null);\n          if (servers != null && !servers.isEmpty() && !allServers.containsAll(servers))\n            return false;\n        }\n      }\n    }\n    return false;\n  }", "code_tokens": ["public", "boolean", "isSharded", "(", ")", "{", "final", "ODocument", "allCluster", "=", "getClusterConfiguration", "(", "ALL_WILDCARD", ")", ";", "if", "(", "allCluster", "!=", "null", ")", "{", "final", "List", "<", "String", ">", "allServers", "=", "allCluster", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "allServers", "!=", "null", "&&", "!", "allServers", ".", "isEmpty", "(", ")", ")", "{", "for", "(", "String", "cl", ":", "getClusterNames", "(", ")", ")", "{", "final", "List", "<", "String", ">", "servers", "=", "getServers", "(", "cl", ",", "null", ")", ";", "if", "(", "servers", "!=", "null", "&&", "!", "servers", ".", "isEmpty", "(", ")", "&&", "!", "allServers", ".", "containsAll", "(", "servers", ")", ")", "return", "false", ";", "}", "}", "}", "return", "false", ";", "}"], "docstring": "Returns true if the database is sharded across servers. False if it's completely replicated.", "docstring_tokens": ["Returns", "true", "if", "the", "database", "is", "sharded", "across", "servers", ".", "False", "if", "it", "s", "completely", "replicated", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L613-L627", "partition": "test", "index": 3102, "time": "2016-07-24 01:30:36"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.commonFactor", "original_string": "private List<IndexSearchDescriptor> commonFactor(List<IndexSearchDescriptor> indexSearchDescriptors) {\n    //index, key condition, additional filter (to aggregate in OR)\n    Map<OIndex, Map<IndexCondPair, OOrBlock>> aggregation = new HashMap<>();\n    for (IndexSearchDescriptor item : indexSearchDescriptors) {\n      Map<IndexCondPair, OOrBlock> filtersForIndex = aggregation.get(item.idx);\n      if (filtersForIndex == null) {\n        filtersForIndex = new HashMap<>();\n        aggregation.put(item.idx, filtersForIndex);\n      }\n      IndexCondPair extendedCond = new IndexCondPair(item.keyCondition, item.additionalRangeCondition);\n\n      OOrBlock existingAdditionalConditions = filtersForIndex.get(extendedCond);\n      if (existingAdditionalConditions == null) {\n        existingAdditionalConditions = new OOrBlock(-1);\n        filtersForIndex.put(extendedCond, existingAdditionalConditions);\n      }\n      existingAdditionalConditions.getSubBlocks().add(item.remainingCondition);\n    }\n    List<IndexSearchDescriptor> result = new ArrayList<>();\n    for (Map.Entry<OIndex, Map<IndexCondPair, OOrBlock>> item : aggregation.entrySet()) {\n      for (Map.Entry<IndexCondPair, OOrBlock> filters : item.getValue().entrySet()) {\n        result.add(new IndexSearchDescriptor(item.getKey(), filters.getKey().mainCondition, filters.getKey().additionalRange,\n            filters.getValue()));\n      }\n    }\n    return result;\n  }", "language": "java", "code": "private List<IndexSearchDescriptor> commonFactor(List<IndexSearchDescriptor> indexSearchDescriptors) {\n    //index, key condition, additional filter (to aggregate in OR)\n    Map<OIndex, Map<IndexCondPair, OOrBlock>> aggregation = new HashMap<>();\n    for (IndexSearchDescriptor item : indexSearchDescriptors) {\n      Map<IndexCondPair, OOrBlock> filtersForIndex = aggregation.get(item.idx);\n      if (filtersForIndex == null) {\n        filtersForIndex = new HashMap<>();\n        aggregation.put(item.idx, filtersForIndex);\n      }\n      IndexCondPair extendedCond = new IndexCondPair(item.keyCondition, item.additionalRangeCondition);\n\n      OOrBlock existingAdditionalConditions = filtersForIndex.get(extendedCond);\n      if (existingAdditionalConditions == null) {\n        existingAdditionalConditions = new OOrBlock(-1);\n        filtersForIndex.put(extendedCond, existingAdditionalConditions);\n      }\n      existingAdditionalConditions.getSubBlocks().add(item.remainingCondition);\n    }\n    List<IndexSearchDescriptor> result = new ArrayList<>();\n    for (Map.Entry<OIndex, Map<IndexCondPair, OOrBlock>> item : aggregation.entrySet()) {\n      for (Map.Entry<IndexCondPair, OOrBlock> filters : item.getValue().entrySet()) {\n        result.add(new IndexSearchDescriptor(item.getKey(), filters.getKey().mainCondition, filters.getKey().additionalRange,\n            filters.getValue()));\n      }\n    }\n    return result;\n  }", "code_tokens": ["private", "List", "<", "IndexSearchDescriptor", ">", "commonFactor", "(", "List", "<", "IndexSearchDescriptor", ">", "indexSearchDescriptors", ")", "{", "//index, key condition, additional filter (to aggregate in OR)", "Map", "<", "OIndex", ",", "Map", "<", "IndexCondPair", ",", "OOrBlock", ">", ">", "aggregation", "=", "new", "HashMap", "<>", "(", ")", ";", "for", "(", "IndexSearchDescriptor", "item", ":", "indexSearchDescriptors", ")", "{", "Map", "<", "IndexCondPair", ",", "OOrBlock", ">", "filtersForIndex", "=", "aggregation", ".", "get", "(", "item", ".", "idx", ")", ";", "if", "(", "filtersForIndex", "==", "null", ")", "{", "filtersForIndex", "=", "new", "HashMap", "<>", "(", ")", ";", "aggregation", ".", "put", "(", "item", ".", "idx", ",", "filtersForIndex", ")", ";", "}", "IndexCondPair", "extendedCond", "=", "new", "IndexCondPair", "(", "item", ".", "keyCondition", ",", "item", ".", "additionalRangeCondition", ")", ";", "OOrBlock", "existingAdditionalConditions", "=", "filtersForIndex", ".", "get", "(", "extendedCond", ")", ";", "if", "(", "existingAdditionalConditions", "==", "null", ")", "{", "existingAdditionalConditions", "=", "new", "OOrBlock", "(", "-", "1", ")", ";", "filtersForIndex", ".", "put", "(", "extendedCond", ",", "existingAdditionalConditions", ")", ";", "}", "existingAdditionalConditions", ".", "getSubBlocks", "(", ")", ".", "add", "(", "item", ".", "remainingCondition", ")", ";", "}", "List", "<", "IndexSearchDescriptor", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "OIndex", ",", "Map", "<", "IndexCondPair", ",", "OOrBlock", ">", ">", "item", ":", "aggregation", ".", "entrySet", "(", ")", ")", "{", "for", "(", "Map", ".", "Entry", "<", "IndexCondPair", ",", "OOrBlock", ">", "filters", ":", "item", ".", "getValue", "(", ")", ".", "entrySet", "(", ")", ")", "{", "result", ".", "add", "(", "new", "IndexSearchDescriptor", "(", "item", ".", "getKey", "(", ")", ",", "filters", ".", "getKey", "(", ")", ".", "mainCondition", ",", "filters", ".", "getKey", "(", ")", ".", "additionalRange", ",", "filters", ".", "getValue", "(", ")", ")", ")", ";", "}", "}", "return", "result", ";", "}"], "docstring": "aggregates multiple index conditions that refer to the same key search\n\n@param indexSearchDescriptors\n\n@return", "docstring_tokens": ["aggregates", "multiple", "index", "conditions", "that", "refer", "to", "the", "same", "key", "search"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L2565-L2591", "partition": "test", "index": 2930, "time": "2016-07-25 17:38:52"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.addOrderByProjections", "original_string": "private static void addOrderByProjections(QueryPlanningInfo info) {\n    if (info.orderApplied || info.expand || info.unwind != null || info.orderBy == null || info.orderBy.getItems().size() == 0\n        || info.projection == null || info.projection.getItems() == null || (info.projection.getItems().size() == 1\n        && info.projection.getItems().get(0).isAll())) {\n      return;\n    }\n\n    OOrderBy newOrderBy = info.orderBy == null ? null : info.orderBy.copy();\n    List<OProjectionItem> additionalOrderByProjections = calculateAdditionalOrderByProjections(info.projection.getAllAliases(),\n        newOrderBy);\n    if (additionalOrderByProjections.size() > 0) {\n      info.orderBy = newOrderBy;//the ORDER BY has changed\n    }\n    if (additionalOrderByProjections.size() > 0) {\n      info.projectionAfterOrderBy = new OProjection(-1);\n      info.projectionAfterOrderBy.setItems(new ArrayList<>());\n      for (String alias : info.projection.getAllAliases()) {\n        info.projectionAfterOrderBy.getItems().add(projectionFromAlias(new OIdentifier(alias)));\n      }\n\n      for (OProjectionItem item : additionalOrderByProjections) {\n        if (info.preAggregateProjection != null) {\n          info.preAggregateProjection.getItems().add(item);\n          info.aggregateProjection.getItems().add(projectionFromAlias(item.getAlias()));\n          info.projection.getItems().add(projectionFromAlias(item.getAlias()));\n        } else {\n          info.projection.getItems().add(item);\n        }\n      }\n    }\n  }", "language": "java", "code": "private static void addOrderByProjections(QueryPlanningInfo info) {\n    if (info.orderApplied || info.expand || info.unwind != null || info.orderBy == null || info.orderBy.getItems().size() == 0\n        || info.projection == null || info.projection.getItems() == null || (info.projection.getItems().size() == 1\n        && info.projection.getItems().get(0).isAll())) {\n      return;\n    }\n\n    OOrderBy newOrderBy = info.orderBy == null ? null : info.orderBy.copy();\n    List<OProjectionItem> additionalOrderByProjections = calculateAdditionalOrderByProjections(info.projection.getAllAliases(),\n        newOrderBy);\n    if (additionalOrderByProjections.size() > 0) {\n      info.orderBy = newOrderBy;//the ORDER BY has changed\n    }\n    if (additionalOrderByProjections.size() > 0) {\n      info.projectionAfterOrderBy = new OProjection(-1);\n      info.projectionAfterOrderBy.setItems(new ArrayList<>());\n      for (String alias : info.projection.getAllAliases()) {\n        info.projectionAfterOrderBy.getItems().add(projectionFromAlias(new OIdentifier(alias)));\n      }\n\n      for (OProjectionItem item : additionalOrderByProjections) {\n        if (info.preAggregateProjection != null) {\n          info.preAggregateProjection.getItems().add(item);\n          info.aggregateProjection.getItems().add(projectionFromAlias(item.getAlias()));\n          info.projection.getItems().add(projectionFromAlias(item.getAlias()));\n        } else {\n          info.projection.getItems().add(item);\n        }\n      }\n    }\n  }", "code_tokens": ["private", "static", "void", "addOrderByProjections", "(", "QueryPlanningInfo", "info", ")", "{", "if", "(", "info", ".", "orderApplied", "||", "info", ".", "expand", "||", "info", ".", "unwind", "!=", "null", "||", "info", ".", "orderBy", "==", "null", "||", "info", ".", "orderBy", ".", "getItems", "(", ")", ".", "size", "(", ")", "==", "0", "||", "info", ".", "projection", "==", "null", "||", "info", ".", "projection", ".", "getItems", "(", ")", "==", "null", "||", "(", "info", ".", "projection", ".", "getItems", "(", ")", ".", "size", "(", ")", "==", "1", "&&", "info", ".", "projection", ".", "getItems", "(", ")", ".", "get", "(", "0", ")", ".", "isAll", "(", ")", ")", ")", "{", "return", ";", "}", "OOrderBy", "newOrderBy", "=", "info", ".", "orderBy", "==", "null", "?", "null", ":", "info", ".", "orderBy", ".", "copy", "(", ")", ";", "List", "<", "OProjectionItem", ">", "additionalOrderByProjections", "=", "calculateAdditionalOrderByProjections", "(", "info", ".", "projection", ".", "getAllAliases", "(", ")", ",", "newOrderBy", ")", ";", "if", "(", "additionalOrderByProjections", ".", "size", "(", ")", ">", "0", ")", "{", "info", ".", "orderBy", "=", "newOrderBy", ";", "//the ORDER BY has changed", "}", "if", "(", "additionalOrderByProjections", ".", "size", "(", ")", ">", "0", ")", "{", "info", ".", "projectionAfterOrderBy", "=", "new", "OProjection", "(", "-", "1", ")", ";", "info", ".", "projectionAfterOrderBy", ".", "setItems", "(", "new", "ArrayList", "<>", "(", ")", ")", ";", "for", "(", "String", "alias", ":", "info", ".", "projection", ".", "getAllAliases", "(", ")", ")", "{", "info", ".", "projectionAfterOrderBy", ".", "getItems", "(", ")", ".", "add", "(", "projectionFromAlias", "(", "new", "OIdentifier", "(", "alias", ")", ")", ")", ";", "}", "for", "(", "OProjectionItem", "item", ":", "additionalOrderByProjections", ")", "{", "if", "(", "info", ".", "preAggregateProjection", "!=", "null", ")", "{", "info", ".", "preAggregateProjection", ".", "getItems", "(", ")", ".", "add", "(", "item", ")", ";", "info", ".", "aggregateProjection", ".", "getItems", "(", ")", ".", "add", "(", "projectionFromAlias", "(", "item", ".", "getAlias", "(", ")", ")", ")", ";", "info", ".", "projection", ".", "getItems", "(", ")", ".", "add", "(", "projectionFromAlias", "(", "item", ".", "getAlias", "(", ")", ")", ")", ";", "}", "else", "{", "info", ".", "projection", ".", "getItems", "(", ")", ".", "add", "(", "item", ")", ";", "}", "}", "}", "}"], "docstring": "creates additional projections for ORDER BY", "docstring_tokens": ["creates", "additional", "projections", "for", "ORDER", "BY"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L771-L801", "partition": "test", "index": 2921, "time": "2016-07-29 16:12:01"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.moveFlattededEqualitiesLeft", "original_string": "private static List<OAndBlock> moveFlattededEqualitiesLeft(List<OAndBlock> flattenedWhereClause) {\n    if (flattenedWhereClause == null) {\n      return null;\n    }\n\n    List<OAndBlock> result = new ArrayList<>();\n    for (OAndBlock block : flattenedWhereClause) {\n      List<OBooleanExpression> equalityExpressions = new ArrayList<>();\n      List<OBooleanExpression> nonEqualityExpressions = new ArrayList<>();\n      OAndBlock newBlock = block.copy();\n      for (OBooleanExpression exp : newBlock.getSubBlocks()) {\n        if (exp instanceof OBinaryCondition) {\n          if (((OBinaryCondition) exp).getOperator() instanceof OEqualsCompareOperator) {\n            equalityExpressions.add(exp);\n          } else {\n            nonEqualityExpressions.add(exp);\n          }\n        } else {\n          nonEqualityExpressions.add(exp);\n        }\n      }\n      OAndBlock newAnd = new OAndBlock(-1);\n      newAnd.getSubBlocks().addAll(equalityExpressions);\n      newAnd.getSubBlocks().addAll(nonEqualityExpressions);\n      result.add(newAnd);\n    }\n\n    return result;\n  }", "language": "java", "code": "private static List<OAndBlock> moveFlattededEqualitiesLeft(List<OAndBlock> flattenedWhereClause) {\n    if (flattenedWhereClause == null) {\n      return null;\n    }\n\n    List<OAndBlock> result = new ArrayList<>();\n    for (OAndBlock block : flattenedWhereClause) {\n      List<OBooleanExpression> equalityExpressions = new ArrayList<>();\n      List<OBooleanExpression> nonEqualityExpressions = new ArrayList<>();\n      OAndBlock newBlock = block.copy();\n      for (OBooleanExpression exp : newBlock.getSubBlocks()) {\n        if (exp instanceof OBinaryCondition) {\n          if (((OBinaryCondition) exp).getOperator() instanceof OEqualsCompareOperator) {\n            equalityExpressions.add(exp);\n          } else {\n            nonEqualityExpressions.add(exp);\n          }\n        } else {\n          nonEqualityExpressions.add(exp);\n        }\n      }\n      OAndBlock newAnd = new OAndBlock(-1);\n      newAnd.getSubBlocks().addAll(equalityExpressions);\n      newAnd.getSubBlocks().addAll(nonEqualityExpressions);\n      result.add(newAnd);\n    }\n\n    return result;\n  }", "code_tokens": ["private", "static", "List", "<", "OAndBlock", ">", "moveFlattededEqualitiesLeft", "(", "List", "<", "OAndBlock", ">", "flattenedWhereClause", ")", "{", "if", "(", "flattenedWhereClause", "==", "null", ")", "{", "return", "null", ";", "}", "List", "<", "OAndBlock", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "OAndBlock", "block", ":", "flattenedWhereClause", ")", "{", "List", "<", "OBooleanExpression", ">", "equalityExpressions", "=", "new", "ArrayList", "<>", "(", ")", ";", "List", "<", "OBooleanExpression", ">", "nonEqualityExpressions", "=", "new", "ArrayList", "<>", "(", ")", ";", "OAndBlock", "newBlock", "=", "block", ".", "copy", "(", ")", ";", "for", "(", "OBooleanExpression", "exp", ":", "newBlock", ".", "getSubBlocks", "(", ")", ")", "{", "if", "(", "exp", "instanceof", "OBinaryCondition", ")", "{", "if", "(", "(", "(", "OBinaryCondition", ")", "exp", ")", ".", "getOperator", "(", ")", "instanceof", "OEqualsCompareOperator", ")", "{", "equalityExpressions", ".", "add", "(", "exp", ")", ";", "}", "else", "{", "nonEqualityExpressions", ".", "add", "(", "exp", ")", ";", "}", "}", "else", "{", "nonEqualityExpressions", ".", "add", "(", "exp", ")", ";", "}", "}", "OAndBlock", "newAnd", "=", "new", "OAndBlock", "(", "-", "1", ")", ";", "newAnd", ".", "getSubBlocks", "(", ")", ".", "addAll", "(", "equalityExpressions", ")", ";", "newAnd", ".", "getSubBlocks", "(", ")", ".", "addAll", "(", "nonEqualityExpressions", ")", ";", "result", ".", "add", "(", "newAnd", ")", ";", "}", "return", "result", ";", "}"], "docstring": "re-writes a list of flat AND conditions, moving left all the equality operations\n\n@param flattenedWhereClause\n\n@return", "docstring_tokens": ["re", "-", "writes", "a", "list", "of", "flat", "AND", "conditions", "moving", "left", "all", "the", "equality", "operations"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L738-L766", "partition": "test", "index": 2920, "time": "2016-07-29 16:12:01"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.isDiamondHierarchy", "original_string": "private boolean isDiamondHierarchy(OClass clazz) {\n    Set<OClass> traversed = new HashSet<>();\n    List<OClass> stack = new ArrayList<>();\n    stack.add(clazz);\n    while (!stack.isEmpty()) {\n      OClass current = stack.remove(0);\n      traversed.add(current);\n      for (OClass sub : current.getSubclasses()) {\n        if (traversed.contains(sub)) {\n          return true;\n        }\n        stack.add(sub);\n        traversed.add(sub);\n      }\n    }\n    return false;\n  }", "language": "java", "code": "private boolean isDiamondHierarchy(OClass clazz) {\n    Set<OClass> traversed = new HashSet<>();\n    List<OClass> stack = new ArrayList<>();\n    stack.add(clazz);\n    while (!stack.isEmpty()) {\n      OClass current = stack.remove(0);\n      traversed.add(current);\n      for (OClass sub : current.getSubclasses()) {\n        if (traversed.contains(sub)) {\n          return true;\n        }\n        stack.add(sub);\n        traversed.add(sub);\n      }\n    }\n    return false;\n  }", "code_tokens": ["private", "boolean", "isDiamondHierarchy", "(", "OClass", "clazz", ")", "{", "Set", "<", "OClass", ">", "traversed", "=", "new", "HashSet", "<>", "(", ")", ";", "List", "<", "OClass", ">", "stack", "=", "new", "ArrayList", "<>", "(", ")", ";", "stack", ".", "add", "(", "clazz", ")", ";", "while", "(", "!", "stack", ".", "isEmpty", "(", ")", ")", "{", "OClass", "current", "=", "stack", ".", "remove", "(", "0", ")", ";", "traversed", ".", "add", "(", "current", ")", ";", "for", "(", "OClass", "sub", ":", "current", ".", "getSubclasses", "(", ")", ")", "{", "if", "(", "traversed", ".", "contains", "(", "sub", ")", ")", "{", "return", "true", ";", "}", "stack", ".", "add", "(", "sub", ")", ";", "traversed", ".", "add", "(", "sub", ")", ";", "}", "}", "return", "false", ";", "}"], "docstring": "checks if a class is the top of a diamond hierarchy\n\n@param clazz\n\n@return", "docstring_tokens": ["checks", "if", "a", "class", "is", "the", "top", "of", "a", "diamond", "hierarchy"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L1890-L1906", "partition": "test", "index": 2925, "time": "2016-08-05 14:28:32"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.getOrderDirection", "original_string": "private Boolean getOrderDirection(QueryPlanningInfo info) {\n    if (info.orderBy == null) {\n      return null;\n    }\n    String result = null;\n    for (OOrderByItem item : info.orderBy.getItems()) {\n      if (result == null) {\n        result = item.getType() == null ? OOrderByItem.ASC : item.getType();\n      } else {\n        String newType = item.getType() == null ? OOrderByItem.ASC : item.getType();\n        if (!newType.equals(result)) {\n          return null;\n        }\n      }\n    }\n    return result == null || result.equals(OOrderByItem.ASC);\n  }", "language": "java", "code": "private Boolean getOrderDirection(QueryPlanningInfo info) {\n    if (info.orderBy == null) {\n      return null;\n    }\n    String result = null;\n    for (OOrderByItem item : info.orderBy.getItems()) {\n      if (result == null) {\n        result = item.getType() == null ? OOrderByItem.ASC : item.getType();\n      } else {\n        String newType = item.getType() == null ? OOrderByItem.ASC : item.getType();\n        if (!newType.equals(result)) {\n          return null;\n        }\n      }\n    }\n    return result == null || result.equals(OOrderByItem.ASC);\n  }", "code_tokens": ["private", "Boolean", "getOrderDirection", "(", "QueryPlanningInfo", "info", ")", "{", "if", "(", "info", ".", "orderBy", "==", "null", ")", "{", "return", "null", ";", "}", "String", "result", "=", "null", ";", "for", "(", "OOrderByItem", "item", ":", "info", ".", "orderBy", ".", "getItems", "(", ")", ")", "{", "if", "(", "result", "==", "null", ")", "{", "result", "=", "item", ".", "getType", "(", ")", "==", "null", "?", "OOrderByItem", ".", "ASC", ":", "item", ".", "getType", "(", ")", ";", "}", "else", "{", "String", "newType", "=", "item", ".", "getType", "(", ")", "==", "null", "?", "OOrderByItem", ".", "ASC", ":", "item", ".", "getType", "(", ")", ";", "if", "(", "!", "newType", ".", "equals", "(", "result", ")", ")", "{", "return", "null", ";", "}", "}", "}", "return", "result", "==", "null", "||", "result", ".", "equals", "(", "OOrderByItem", ".", "ASC", ")", ";", "}"], "docstring": "returns TRUE if all the order clauses are ASC, FALSE if all are DESC, null otherwise\n\n@return TRUE if all the order clauses are ASC, FALSE if all are DESC, null otherwise", "docstring_tokens": ["returns", "TRUE", "if", "all", "the", "order", "clauses", "are", "ASC", "FALSE", "if", "all", "are", "DESC", "null", "otherwise"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L2091-L2107", "partition": "test", "index": 2926, "time": "2016-08-05 16:56:32"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.handleClassWithIndexForSortOnly", "original_string": "private boolean handleClassWithIndexForSortOnly(OSelectExecutionPlan plan, OIdentifier queryTarget, Set<String> filterClusters,\n      QueryPlanningInfo info, OCommandContext ctx, boolean profilingEnabled) {\n    OSchema schema = getSchemaFromContext(ctx);\n    OClass clazz = schema.getClass(queryTarget.getStringValue());\n    if (clazz == null) {\n      clazz = schema.getView(queryTarget.getStringValue());\n      if (clazz == null) {\n        throw new OCommandExecutionException(\"Class not found: \" + queryTarget);\n      }\n    }\n\n    for (OIndex idx : clazz.getIndexes().stream().filter(i -> i.supportsOrderedIterations()).filter(i -> i.getDefinition() != null)\n        .collect(Collectors.toList())) {\n      List<String> indexFields = idx.getDefinition().getFields();\n      if (indexFields.size() < info.orderBy.getItems().size()) {\n        continue;\n      }\n      boolean indexFound = true;\n      String orderType = null;\n      for (int i = 0; i < info.orderBy.getItems().size(); i++) {\n        OOrderByItem orderItem = info.orderBy.getItems().get(i);\n        if (orderItem.getCollate() != null) {\n          return false;\n        }\n        String indexField = indexFields.get(i);\n        if (i == 0) {\n          orderType = orderItem.getType();\n        } else {\n          if (orderType == null || !orderType.equals(orderItem.getType())) {\n            indexFound = false;\n            break;//ASC/DESC interleaved, cannot be used with index.\n          }\n        }\n        if (!(indexField.equals(orderItem.getAlias()) || isInOriginalProjection(indexField, orderItem.getAlias()))) {\n          indexFound = false;\n          break;\n        }\n      }\n      if (indexFound && orderType != null) {\n        plan.chain(new FetchFromIndexValuesStep(idx, orderType.equals(OOrderByItem.ASC), ctx, profilingEnabled));\n        int[] filterClusterIds = null;\n        if (filterClusters != null) {\n          filterClusterIds = filterClusters.stream().map(name -> ctx.getDatabase().getClusterIdByName(name)).mapToInt(i -> i)\n              .toArray();\n        }\n        plan.chain(new GetValueFromIndexEntryStep(ctx, filterClusterIds, profilingEnabled));\n        if (info.serverToClusters.size() == 1) {\n          info.orderApplied = true;\n        }\n        return true;\n      }\n    }\n    return false;\n  }", "language": "java", "code": "private boolean handleClassWithIndexForSortOnly(OSelectExecutionPlan plan, OIdentifier queryTarget, Set<String> filterClusters,\n      QueryPlanningInfo info, OCommandContext ctx, boolean profilingEnabled) {\n    OSchema schema = getSchemaFromContext(ctx);\n    OClass clazz = schema.getClass(queryTarget.getStringValue());\n    if (clazz == null) {\n      clazz = schema.getView(queryTarget.getStringValue());\n      if (clazz == null) {\n        throw new OCommandExecutionException(\"Class not found: \" + queryTarget);\n      }\n    }\n\n    for (OIndex idx : clazz.getIndexes().stream().filter(i -> i.supportsOrderedIterations()).filter(i -> i.getDefinition() != null)\n        .collect(Collectors.toList())) {\n      List<String> indexFields = idx.getDefinition().getFields();\n      if (indexFields.size() < info.orderBy.getItems().size()) {\n        continue;\n      }\n      boolean indexFound = true;\n      String orderType = null;\n      for (int i = 0; i < info.orderBy.getItems().size(); i++) {\n        OOrderByItem orderItem = info.orderBy.getItems().get(i);\n        if (orderItem.getCollate() != null) {\n          return false;\n        }\n        String indexField = indexFields.get(i);\n        if (i == 0) {\n          orderType = orderItem.getType();\n        } else {\n          if (orderType == null || !orderType.equals(orderItem.getType())) {\n            indexFound = false;\n            break;//ASC/DESC interleaved, cannot be used with index.\n          }\n        }\n        if (!(indexField.equals(orderItem.getAlias()) || isInOriginalProjection(indexField, orderItem.getAlias()))) {\n          indexFound = false;\n          break;\n        }\n      }\n      if (indexFound && orderType != null) {\n        plan.chain(new FetchFromIndexValuesStep(idx, orderType.equals(OOrderByItem.ASC), ctx, profilingEnabled));\n        int[] filterClusterIds = null;\n        if (filterClusters != null) {\n          filterClusterIds = filterClusters.stream().map(name -> ctx.getDatabase().getClusterIdByName(name)).mapToInt(i -> i)\n              .toArray();\n        }\n        plan.chain(new GetValueFromIndexEntryStep(ctx, filterClusterIds, profilingEnabled));\n        if (info.serverToClusters.size() == 1) {\n          info.orderApplied = true;\n        }\n        return true;\n      }\n    }\n    return false;\n  }", "code_tokens": ["private", "boolean", "handleClassWithIndexForSortOnly", "(", "OSelectExecutionPlan", "plan", ",", "OIdentifier", "queryTarget", ",", "Set", "<", "String", ">", "filterClusters", ",", "QueryPlanningInfo", "info", ",", "OCommandContext", "ctx", ",", "boolean", "profilingEnabled", ")", "{", "OSchema", "schema", "=", "getSchemaFromContext", "(", "ctx", ")", ";", "OClass", "clazz", "=", "schema", ".", "getClass", "(", "queryTarget", ".", "getStringValue", "(", ")", ")", ";", "if", "(", "clazz", "==", "null", ")", "{", "clazz", "=", "schema", ".", "getView", "(", "queryTarget", ".", "getStringValue", "(", ")", ")", ";", "if", "(", "clazz", "==", "null", ")", "{", "throw", "new", "OCommandExecutionException", "(", "\"Class not found: \"", "+", "queryTarget", ")", ";", "}", "}", "for", "(", "OIndex", "idx", ":", "clazz", ".", "getIndexes", "(", ")", ".", "stream", "(", ")", ".", "filter", "(", "i", "->", "i", ".", "supportsOrderedIterations", "(", ")", ")", ".", "filter", "(", "i", "->", "i", ".", "getDefinition", "(", ")", "!=", "null", ")", ".", "collect", "(", "Collectors", ".", "toList", "(", ")", ")", ")", "{", "List", "<", "String", ">", "indexFields", "=", "idx", ".", "getDefinition", "(", ")", ".", "getFields", "(", ")", ";", "if", "(", "indexFields", ".", "size", "(", ")", "<", "info", ".", "orderBy", ".", "getItems", "(", ")", ".", "size", "(", ")", ")", "{", "continue", ";", "}", "boolean", "indexFound", "=", "true", ";", "String", "orderType", "=", "null", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "info", ".", "orderBy", ".", "getItems", "(", ")", ".", "size", "(", ")", ";", "i", "++", ")", "{", "OOrderByItem", "orderItem", "=", "info", ".", "orderBy", ".", "getItems", "(", ")", ".", "get", "(", "i", ")", ";", "if", "(", "orderItem", ".", "getCollate", "(", ")", "!=", "null", ")", "{", "return", "false", ";", "}", "String", "indexField", "=", "indexFields", ".", "get", "(", "i", ")", ";", "if", "(", "i", "==", "0", ")", "{", "orderType", "=", "orderItem", ".", "getType", "(", ")", ";", "}", "else", "{", "if", "(", "orderType", "==", "null", "||", "!", "orderType", ".", "equals", "(", "orderItem", ".", "getType", "(", ")", ")", ")", "{", "indexFound", "=", "false", ";", "break", ";", "//ASC/DESC interleaved, cannot be used with index.", "}", "}", "if", "(", "!", "(", "indexField", ".", "equals", "(", "orderItem", ".", "getAlias", "(", ")", ")", "||", "isInOriginalProjection", "(", "indexField", ",", "orderItem", ".", "getAlias", "(", ")", ")", ")", ")", "{", "indexFound", "=", "false", ";", "break", ";", "}", "}", "if", "(", "indexFound", "&&", "orderType", "!=", "null", ")", "{", "plan", ".", "chain", "(", "new", "FetchFromIndexValuesStep", "(", "idx", ",", "orderType", ".", "equals", "(", "OOrderByItem", ".", "ASC", ")", ",", "ctx", ",", "profilingEnabled", ")", ")", ";", "int", "[", "]", "filterClusterIds", "=", "null", ";", "if", "(", "filterClusters", "!=", "null", ")", "{", "filterClusterIds", "=", "filterClusters", ".", "stream", "(", ")", ".", "map", "(", "name", "->", "ctx", ".", "getDatabase", "(", ")", ".", "getClusterIdByName", "(", "name", ")", ")", ".", "mapToInt", "(", "i", "->", "i", ")", ".", "toArray", "(", ")", ";", "}", "plan", ".", "chain", "(", "new", "GetValueFromIndexEntryStep", "(", "ctx", ",", "filterClusterIds", ",", "profilingEnabled", ")", ")", ";", "if", "(", "info", ".", "serverToClusters", ".", "size", "(", ")", "==", "1", ")", "{", "info", ".", "orderApplied", "=", "true", ";", "}", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "tries to use an index for sorting only. Also adds the fetch step to the execution plan\n\n@param plan current execution plan\n@param info the query planning information\n@param ctx  the current context\n\n@return true if it succeeded to use an index to sort, false otherwise.", "docstring_tokens": ["tries", "to", "use", "an", "index", "for", "sorting", "only", ".", "Also", "adds", "the", "fetch", "step", "to", "the", "execution", "plan"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L1770-L1823", "partition": "test", "index": 2924, "time": "2016-08-05 17:23:32"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OMathExpression.java", "func_name": "OMathExpression.allowsIndexedFunctionExecutionOnTarget", "original_string": "public boolean allowsIndexedFunctionExecutionOnTarget(OFromClause target, OCommandContext context,\n      OBinaryCompareOperator operator, Object right) {\n    if (this.childExpressions.size() != 1) {\n      return false;\n    }\n    return this.childExpressions.get(0).allowsIndexedFunctionExecutionOnTarget(target, context, operator, right);\n  }", "language": "java", "code": "public boolean allowsIndexedFunctionExecutionOnTarget(OFromClause target, OCommandContext context,\n      OBinaryCompareOperator operator, Object right) {\n    if (this.childExpressions.size() != 1) {\n      return false;\n    }\n    return this.childExpressions.get(0).allowsIndexedFunctionExecutionOnTarget(target, context, operator, right);\n  }", "code_tokens": ["public", "boolean", "allowsIndexedFunctionExecutionOnTarget", "(", "OFromClause", "target", ",", "OCommandContext", "context", ",", "OBinaryCompareOperator", "operator", ",", "Object", "right", ")", "{", "if", "(", "this", ".", "childExpressions", ".", "size", "(", ")", "!=", "1", ")", "{", "return", "false", ";", "}", "return", "this", ".", "childExpressions", ".", "get", "(", "0", ")", ".", "allowsIndexedFunctionExecutionOnTarget", "(", "target", ",", "context", ",", "operator", ",", "right", ")", ";", "}"], "docstring": "tests if current expression is an indexed function AND that function can be used on this target\n\n@param target  the query target\n@param context the execution context\n\n@return true if current expression is an indexed function AND that function can be used on this target, false otherwise", "docstring_tokens": ["tests", "if", "current", "expression", "is", "an", "indexed", "function", "AND", "that", "function", "can", "be", "used", "on", "this", "target"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OMathExpression.java#L843-L849", "partition": "test", "index": 2980, "time": "2016-08-06 10:47:04"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OBaseExpression.java", "func_name": "OBaseExpression.canExecuteIndexedFunctionWithoutIndex", "original_string": "public boolean canExecuteIndexedFunctionWithoutIndex(OFromClause target, OCommandContext context, OBinaryCompareOperator operator,\n      Object right) {\n    if (this.identifier == null) {\n      return false;\n    }\n    return identifier.canExecuteIndexedFunctionWithoutIndex(target, context, operator, right);\n  }", "language": "java", "code": "public boolean canExecuteIndexedFunctionWithoutIndex(OFromClause target, OCommandContext context, OBinaryCompareOperator operator,\n      Object right) {\n    if (this.identifier == null) {\n      return false;\n    }\n    return identifier.canExecuteIndexedFunctionWithoutIndex(target, context, operator, right);\n  }", "code_tokens": ["public", "boolean", "canExecuteIndexedFunctionWithoutIndex", "(", "OFromClause", "target", ",", "OCommandContext", "context", ",", "OBinaryCompareOperator", "operator", ",", "Object", "right", ")", "{", "if", "(", "this", ".", "identifier", "==", "null", ")", "{", "return", "false", ";", "}", "return", "identifier", ".", "canExecuteIndexedFunctionWithoutIndex", "(", "target", ",", "context", ",", "operator", ",", "right", ")", ";", "}"], "docstring": "tests if current expression is an indexed funciton AND that function can also be executed without using the index\n\n@param target   the query target\n@param context  the execution context\n@param operator\n@param right\n\n@return true if current expression is an indexed funciton AND that function can also be executed without using the index, false\notherwise", "docstring_tokens": ["tests", "if", "current", "expression", "is", "an", "indexed", "funciton", "AND", "that", "function", "can", "also", "be", "executed", "without", "using", "the", "index"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OBaseExpression.java#L179-L185", "partition": "test", "index": 2910, "time": "2016-08-06 10:47:04"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OBinaryCondition.java", "func_name": "OBinaryCondition.allowsIndexedFunctionExecutionOnTarget", "original_string": "public boolean allowsIndexedFunctionExecutionOnTarget(OFromClause target, OCommandContext context) {\n    return left.allowsIndexedFunctionExecutionOnTarget(target, context, operator, right.execute((OResult) null, context));\n  }", "language": "java", "code": "public boolean allowsIndexedFunctionExecutionOnTarget(OFromClause target, OCommandContext context) {\n    return left.allowsIndexedFunctionExecutionOnTarget(target, context, operator, right.execute((OResult) null, context));\n  }", "code_tokens": ["public", "boolean", "allowsIndexedFunctionExecutionOnTarget", "(", "OFromClause", "target", ",", "OCommandContext", "context", ")", "{", "return", "left", ".", "allowsIndexedFunctionExecutionOnTarget", "(", "target", ",", "context", ",", "operator", ",", "right", ".", "execute", "(", "(", "OResult", ")", "null", ",", "context", ")", ")", ";", "}"], "docstring": "tests if current expression involves an indexed function AND that function can be used on this target\n\n@param target  the query target\n@param context the execution context\n\n@return true if current expression involves an indexed function AND that function can be used on this target, false otherwise", "docstring_tokens": ["tests", "if", "current", "expression", "involves", "an", "indexed", "function", "AND", "that", "function", "can", "be", "used", "on", "this", "target"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OBinaryCondition.java#L155-L157", "partition": "test", "index": 3152, "time": "2016-08-06 10:47:04"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OFunctionCall.java", "func_name": "OFunctionCall.canExecuteIndexedFunctionWithoutIndex", "original_string": "public boolean canExecuteIndexedFunctionWithoutIndex(OFromClause target, OCommandContext context, OBinaryCompareOperator operator,\n      Object right) {\n    OSQLFunction function = OSQLEngine.getInstance().getFunction(name.getStringValue());\n    if (function instanceof OIndexableSQLFunction) {\n      return ((OIndexableSQLFunction) function)\n          .canExecuteInline(target, operator, right, context, this.getParams().toArray(new OExpression[] {}));\n    }\n    return false;\n  }", "language": "java", "code": "public boolean canExecuteIndexedFunctionWithoutIndex(OFromClause target, OCommandContext context, OBinaryCompareOperator operator,\n      Object right) {\n    OSQLFunction function = OSQLEngine.getInstance().getFunction(name.getStringValue());\n    if (function instanceof OIndexableSQLFunction) {\n      return ((OIndexableSQLFunction) function)\n          .canExecuteInline(target, operator, right, context, this.getParams().toArray(new OExpression[] {}));\n    }\n    return false;\n  }", "code_tokens": ["public", "boolean", "canExecuteIndexedFunctionWithoutIndex", "(", "OFromClause", "target", ",", "OCommandContext", "context", ",", "OBinaryCompareOperator", "operator", ",", "Object", "right", ")", "{", "OSQLFunction", "function", "=", "OSQLEngine", ".", "getInstance", "(", ")", ".", "getFunction", "(", "name", ".", "getStringValue", "(", ")", ")", ";", "if", "(", "function", "instanceof", "OIndexableSQLFunction", ")", "{", "return", "(", "(", "OIndexableSQLFunction", ")", "function", ")", ".", "canExecuteInline", "(", "target", ",", "operator", ",", "right", ",", "context", ",", "this", ".", "getParams", "(", ")", ".", "toArray", "(", "new", "OExpression", "[", "]", "{", "}", ")", ")", ";", "}", "return", "false", ";", "}"], "docstring": "tests if current function is an indexed function AND that function can also be executed without using the index\n\n@param target   the query target\n@param context  the execution context\n@param operator\n@param right\n\n@return true if current function is an indexed funciton AND that function can also be executed without using the index, false\notherwise", "docstring_tokens": ["tests", "if", "current", "function", "is", "an", "indexed", "function", "AND", "that", "function", "can", "also", "be", "executed", "without", "using", "the", "index"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OFunctionCall.java#L202-L210", "partition": "test", "index": 3078, "time": "2016-08-06 10:47:04"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/task/OAbstract2pcTask.java", "func_name": "OAbstract2pcTask.getPartitionKey", "original_string": "@Override\n  public int[] getPartitionKey() {\n    if (tasks.size() == 1)\n      // ONE TASK, USE THE INNER TASK'S PARTITION KEY\n      return tasks.get(0).getPartitionKey();\n\n    // MULTIPLE PARTITIONS\n    final int[] partitions = new int[tasks.size()];\n    for (int i = 0; i < tasks.size(); ++i) {\n      final OAbstractRecordReplicatedTask task = tasks.get(i);\n      partitions[i] = task.getPartitionKey()[0];\n    }\n\n    return partitions;\n  }", "language": "java", "code": "@Override\n  public int[] getPartitionKey() {\n    if (tasks.size() == 1)\n      // ONE TASK, USE THE INNER TASK'S PARTITION KEY\n      return tasks.get(0).getPartitionKey();\n\n    // MULTIPLE PARTITIONS\n    final int[] partitions = new int[tasks.size()];\n    for (int i = 0; i < tasks.size(); ++i) {\n      final OAbstractRecordReplicatedTask task = tasks.get(i);\n      partitions[i] = task.getPartitionKey()[0];\n    }\n\n    return partitions;\n  }", "code_tokens": ["@", "Override", "public", "int", "[", "]", "getPartitionKey", "(", ")", "{", "if", "(", "tasks", ".", "size", "(", ")", "==", "1", ")", "// ONE TASK, USE THE INNER TASK'S PARTITION KEY", "return", "tasks", ".", "get", "(", "0", ")", ".", "getPartitionKey", "(", ")", ";", "// MULTIPLE PARTITIONS", "final", "int", "[", "]", "partitions", "=", "new", "int", "[", "tasks", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "tasks", ".", "size", "(", ")", ";", "++", "i", ")", "{", "final", "OAbstractRecordReplicatedTask", "task", "=", "tasks", ".", "get", "(", "i", ")", ";", "partitions", "[", "i", "]", "=", "task", ".", "getPartitionKey", "(", ")", "[", "0", "]", ";", "}", "return", "partitions", ";", "}"], "docstring": "Return the partition keys of all the sub-tasks.", "docstring_tokens": ["Return", "the", "partition", "keys", "of", "all", "the", "sub", "-", "tasks", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/task/OAbstract2pcTask.java#L71-L85", "partition": "test", "index": 3005, "time": "2016-08-09 00:49:22"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/task/OAbstract2pcTask.java", "func_name": "OAbstract2pcTask.getDistributedTimeout", "original_string": "@Override\n  public long getDistributedTimeout() {\n    final long to = OGlobalConfiguration.DISTRIBUTED_CRUD_TASK_SYNCH_TIMEOUT.getValueAsLong();\n    return to + ((to / 2) * tasks.size());\n  }", "language": "java", "code": "@Override\n  public long getDistributedTimeout() {\n    final long to = OGlobalConfiguration.DISTRIBUTED_CRUD_TASK_SYNCH_TIMEOUT.getValueAsLong();\n    return to + ((to / 2) * tasks.size());\n  }", "code_tokens": ["@", "Override", "public", "long", "getDistributedTimeout", "(", ")", "{", "final", "long", "to", "=", "OGlobalConfiguration", ".", "DISTRIBUTED_CRUD_TASK_SYNCH_TIMEOUT", ".", "getValueAsLong", "(", ")", ";", "return", "to", "+", "(", "(", "to", "/", "2", ")", "*", "tasks", ".", "size", "(", ")", ")", ";", "}"], "docstring": "Computes the timeout according to the transaction size.\n\n@return", "docstring_tokens": ["Computes", "the", "timeout", "according", "to", "the", "transaction", "size", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/task/OAbstract2pcTask.java#L124-L128", "partition": "test", "index": 3006, "time": "2016-08-09 00:49:22"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cluster/v0/OClusterPositionMapV0.java", "func_name": "OClusterPositionMapV0.getNextPosition", "original_string": "long getNextPosition(final OAtomicOperation atomicOperation) throws IOException {\n    final long filledUpTo = getFilledUpTo(atomicOperation, fileId);\n\n    final long pageIndex = filledUpTo - 1;\n    final OCacheEntry cacheEntry = loadPageForRead(atomicOperation, fileId, pageIndex, false, 1);\n    try {\n      final OClusterPositionMapBucket bucket = new OClusterPositionMapBucket(cacheEntry, false);\n      final int bucketSize = bucket.getSize();\n      return pageIndex * OClusterPositionMapBucket.MAX_ENTRIES + bucketSize;\n    } finally {\n      releasePageFromRead(atomicOperation, cacheEntry);\n    }\n  }", "language": "java", "code": "long getNextPosition(final OAtomicOperation atomicOperation) throws IOException {\n    final long filledUpTo = getFilledUpTo(atomicOperation, fileId);\n\n    final long pageIndex = filledUpTo - 1;\n    final OCacheEntry cacheEntry = loadPageForRead(atomicOperation, fileId, pageIndex, false, 1);\n    try {\n      final OClusterPositionMapBucket bucket = new OClusterPositionMapBucket(cacheEntry, false);\n      final int bucketSize = bucket.getSize();\n      return pageIndex * OClusterPositionMapBucket.MAX_ENTRIES + bucketSize;\n    } finally {\n      releasePageFromRead(atomicOperation, cacheEntry);\n    }\n  }", "code_tokens": ["long", "getNextPosition", "(", "final", "OAtomicOperation", "atomicOperation", ")", "throws", "IOException", "{", "final", "long", "filledUpTo", "=", "getFilledUpTo", "(", "atomicOperation", ",", "fileId", ")", ";", "final", "long", "pageIndex", "=", "filledUpTo", "-", "1", ";", "final", "OCacheEntry", "cacheEntry", "=", "loadPageForRead", "(", "atomicOperation", ",", "fileId", ",", "pageIndex", ",", "false", ",", "1", ")", ";", "try", "{", "final", "OClusterPositionMapBucket", "bucket", "=", "new", "OClusterPositionMapBucket", "(", "cacheEntry", ",", "false", ")", ";", "final", "int", "bucketSize", "=", "bucket", ".", "getSize", "(", ")", ";", "return", "pageIndex", "*", "OClusterPositionMapBucket", ".", "MAX_ENTRIES", "+", "bucketSize", ";", "}", "finally", "{", "releasePageFromRead", "(", "atomicOperation", ",", "cacheEntry", ")", ";", "}", "}"], "docstring": "Returns the next position available.", "docstring_tokens": ["Returns", "the", "next", "position", "available", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/cluster/v0/OClusterPositionMapV0.java#L463-L475", "partition": "test", "index": 3155, "time": "2016-08-10 01:43:45"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/directmemory/OByteBufferPool.java", "func_name": "OByteBufferPool.checkMemoryLeaks", "original_string": "public void checkMemoryLeaks() {\n    boolean detected = false;\n    if (TRACK) {\n      for (Map.Entry<OPointer, PointerTracker> entry : pointerMapping.entrySet()) {\n        OLogManager.instance()\n            .errorNoDb(this, \"DIRECT-TRACK: unreleased direct memory pointer `%X` detected.\", entry.getValue().allocation,\n                System.identityHashCode(entry.getKey()));\n        detected = true;\n      }\n    }\n\n    assert !detected;\n  }", "language": "java", "code": "public void checkMemoryLeaks() {\n    boolean detected = false;\n    if (TRACK) {\n      for (Map.Entry<OPointer, PointerTracker> entry : pointerMapping.entrySet()) {\n        OLogManager.instance()\n            .errorNoDb(this, \"DIRECT-TRACK: unreleased direct memory pointer `%X` detected.\", entry.getValue().allocation,\n                System.identityHashCode(entry.getKey()));\n        detected = true;\n      }\n    }\n\n    assert !detected;\n  }", "code_tokens": ["public", "void", "checkMemoryLeaks", "(", ")", "{", "boolean", "detected", "=", "false", ";", "if", "(", "TRACK", ")", "{", "for", "(", "Map", ".", "Entry", "<", "OPointer", ",", "PointerTracker", ">", "entry", ":", "pointerMapping", ".", "entrySet", "(", ")", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "errorNoDb", "(", "this", ",", "\"DIRECT-TRACK: unreleased direct memory pointer `%X` detected.\"", ",", "entry", ".", "getValue", "(", ")", ".", "allocation", ",", "System", ".", "identityHashCode", "(", "entry", ".", "getKey", "(", ")", ")", ")", ";", "detected", "=", "true", ";", "}", "}", "assert", "!", "detected", ";", "}"], "docstring": "Checks whether there are not released buffers in the pool", "docstring_tokens": ["Checks", "whether", "there", "are", "not", "released", "buffers", "in", "the", "pool"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/directmemory/OByteBufferPool.java#L192-L204", "partition": "test", "index": 3301, "time": "2016-08-11 21:03:33"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/directmemory/OByteBufferPool.java", "func_name": "OByteBufferPool.clear", "original_string": "public void clear() {\n    for (OPointer pointer : pointersPool) {\n      allocator.deallocate(pointer);\n    }\n\n    pointersPool.clear();\n    pointersPoolSize.set(0);\n\n    for (OPointer pointer : pointerMapping.keySet()) {\n      allocator.deallocate(pointer);\n    }\n\n    pointerMapping.clear();\n  }", "language": "java", "code": "public void clear() {\n    for (OPointer pointer : pointersPool) {\n      allocator.deallocate(pointer);\n    }\n\n    pointersPool.clear();\n    pointersPoolSize.set(0);\n\n    for (OPointer pointer : pointerMapping.keySet()) {\n      allocator.deallocate(pointer);\n    }\n\n    pointerMapping.clear();\n  }", "code_tokens": ["public", "void", "clear", "(", ")", "{", "for", "(", "OPointer", "pointer", ":", "pointersPool", ")", "{", "allocator", ".", "deallocate", "(", "pointer", ")", ";", "}", "pointersPool", ".", "clear", "(", ")", ";", "pointersPoolSize", ".", "set", "(", "0", ")", ";", "for", "(", "OPointer", "pointer", ":", "pointerMapping", ".", "keySet", "(", ")", ")", "{", "allocator", ".", "deallocate", "(", "pointer", ")", ";", "}", "pointerMapping", ".", "clear", "(", ")", ";", "}"], "docstring": "Clears pool and dealocates memory.", "docstring_tokens": ["Clears", "pool", "and", "dealocates", "memory", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/directmemory/OByteBufferPool.java#L209-L222", "partition": "test", "index": 3302, "time": "2016-08-11 21:03:33"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/log/OLogManager.java", "func_name": "OLogManager.shutdown", "original_string": "public void shutdown() {\n    if (shutdownFlag.compareAndSet(false, true)) {\n      try {\n        if (LogManager.getLogManager() instanceof ShutdownLogManager)\n          ((ShutdownLogManager) LogManager.getLogManager()).shutdown();\n      } catch (NoClassDefFoundError ignore) {\n        // Om nom nom. Some custom class loaders, like Tomcat's one, cannot load classes while in shutdown hooks, since their\n        // runtime is already shutdown. Ignoring the exception, if ShutdownLogManager is not loaded at this point there are no instances\n        // of it anyway and we have nothing to shutdown.\n      }\n    }\n  }", "language": "java", "code": "public void shutdown() {\n    if (shutdownFlag.compareAndSet(false, true)) {\n      try {\n        if (LogManager.getLogManager() instanceof ShutdownLogManager)\n          ((ShutdownLogManager) LogManager.getLogManager()).shutdown();\n      } catch (NoClassDefFoundError ignore) {\n        // Om nom nom. Some custom class loaders, like Tomcat's one, cannot load classes while in shutdown hooks, since their\n        // runtime is already shutdown. Ignoring the exception, if ShutdownLogManager is not loaded at this point there are no instances\n        // of it anyway and we have nothing to shutdown.\n      }\n    }\n  }", "code_tokens": ["public", "void", "shutdown", "(", ")", "{", "if", "(", "shutdownFlag", ".", "compareAndSet", "(", "false", ",", "true", ")", ")", "{", "try", "{", "if", "(", "LogManager", ".", "getLogManager", "(", ")", "instanceof", "ShutdownLogManager", ")", "(", "(", "ShutdownLogManager", ")", "LogManager", ".", "getLogManager", "(", ")", ")", ".", "shutdown", "(", ")", ";", "}", "catch", "(", "NoClassDefFoundError", "ignore", ")", "{", "// Om nom nom. Some custom class loaders, like Tomcat's one, cannot load classes while in shutdown hooks, since their", "// runtime is already shutdown. Ignoring the exception, if ShutdownLogManager is not loaded at this point there are no instances", "// of it anyway and we have nothing to shutdown.", "}", "}", "}"], "docstring": "Shutdowns this log manager.", "docstring_tokens": ["Shutdowns", "this", "log", "manager", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/log/OLogManager.java#L373-L384", "partition": "test", "index": 3246, "time": "2016-08-16 15:17:52"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/OServerShutdownHook.java", "func_name": "OServerShutdownHook.run", "original_string": "@Override\r\n  public void run() {\r\n    if (server != null)\r\n      if (!server.shutdown()) {\r\n        // ALREADY IN SHUTDOWN, WAIT FOR 5 SEC MORE\r\n        try {\r\n          Thread.sleep(5000);\r\n        } catch (InterruptedException e) {\r\n        }\r\n      }\r\n  }", "language": "java", "code": "@Override\r\n  public void run() {\r\n    if (server != null)\r\n      if (!server.shutdown()) {\r\n        // ALREADY IN SHUTDOWN, WAIT FOR 5 SEC MORE\r\n        try {\r\n          Thread.sleep(5000);\r\n        } catch (InterruptedException e) {\r\n        }\r\n      }\r\n  }", "code_tokens": ["@", "Override", "public", "void", "run", "(", ")", "{", "if", "(", "server", "!=", "null", ")", "if", "(", "!", "server", ".", "shutdown", "(", ")", ")", "{", "// ALREADY IN SHUTDOWN, WAIT FOR 5 SEC MORE\r", "try", "{", "Thread", ".", "sleep", "(", "5000", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "}", "}", "}"], "docstring": "Catch the JVM exit and assure to shutdown the Orient Server.", "docstring_tokens": ["Catch", "the", "JVM", "exit", "and", "assure", "to", "shutdown", "the", "Orient", "Server", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/OServerShutdownHook.java#L37-L47", "partition": "test", "index": 3237, "time": "2016-08-16 15:17:52"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OCreateIndexStatement.java", "func_name": "OCreateIndexStatement.getIndexClass", "original_string": "private OClass getIndexClass(OCommandContext ctx) {\n    if (className == null) {\n      return null;\n    }\n    OClass result = ctx.getDatabase().getMetadata().getSchema().getClass(className.getStringValue());\n    if (result == null) {\n      throw new OCommandExecutionException(\"Cannot find class \" + className);\n    }\n    return result;\n  }", "language": "java", "code": "private OClass getIndexClass(OCommandContext ctx) {\n    if (className == null) {\n      return null;\n    }\n    OClass result = ctx.getDatabase().getMetadata().getSchema().getClass(className.getStringValue());\n    if (result == null) {\n      throw new OCommandExecutionException(\"Cannot find class \" + className);\n    }\n    return result;\n  }", "code_tokens": ["private", "OClass", "getIndexClass", "(", "OCommandContext", "ctx", ")", "{", "if", "(", "className", "==", "null", ")", "{", "return", "null", ";", "}", "OClass", "result", "=", "ctx", ".", "getDatabase", "(", ")", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "className", ".", "getStringValue", "(", ")", ")", ";", "if", "(", "result", "==", "null", ")", "{", "throw", "new", "OCommandExecutionException", "(", "\"Cannot find class \"", "+", "className", ")", ";", "}", "return", "result", ";", "}"], "docstring": "calculates the indexed class based on the class name", "docstring_tokens": ["calculates", "the", "indexed", "class", "based", "on", "the", "class", "name"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OCreateIndexStatement.java#L174-L183", "partition": "test", "index": 3294, "time": "2016-08-17 12:44:27"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphSONUtility.java", "func_name": "OGraphSONUtility.objectNodeFromElement", "original_string": "public static ObjectNode objectNodeFromElement(final Element element, final Set<String> propertyKeys, final GraphSONMode mode) {\n    final OGraphSONUtility graphson = element instanceof Edge ? new OGraphSONUtility(mode, null, null, propertyKeys)\n        : new OGraphSONUtility(mode, null, propertyKeys, null);\n    return graphson.objectNodeFromElement(element);\n  }", "language": "java", "code": "public static ObjectNode objectNodeFromElement(final Element element, final Set<String> propertyKeys, final GraphSONMode mode) {\n    final OGraphSONUtility graphson = element instanceof Edge ? new OGraphSONUtility(mode, null, null, propertyKeys)\n        : new OGraphSONUtility(mode, null, propertyKeys, null);\n    return graphson.objectNodeFromElement(element);\n  }", "code_tokens": ["public", "static", "ObjectNode", "objectNodeFromElement", "(", "final", "Element", "element", ",", "final", "Set", "<", "String", ">", "propertyKeys", ",", "final", "GraphSONMode", "mode", ")", "{", "final", "OGraphSONUtility", "graphson", "=", "element", "instanceof", "Edge", "?", "new", "OGraphSONUtility", "(", "mode", ",", "null", ",", "null", ",", "propertyKeys", ")", ":", "new", "OGraphSONUtility", "(", "mode", ",", "null", ",", "propertyKeys", ",", "null", ")", ";", "return", "graphson", ".", "objectNodeFromElement", "(", "element", ")", ";", "}"], "docstring": "Creates a Jackson ObjectNode from a graph element.\n\n@param element\nthe graph element to convert to JSON.\n@param propertyKeys\nThe property keys at the root of the element to serialize. If null, then all keys are serialized.\n@param mode\nThe type of GraphSON to generate.", "docstring_tokens": ["Creates", "a", "Jackson", "ObjectNode", "from", "a", "graph", "element", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphSONUtility.java#L430-L434", "partition": "test", "index": 3180, "time": "2016-08-23 02:43:20"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphSONUtility.java", "func_name": "OGraphSONUtility.jsonFromElement", "original_string": "public static JSONObject jsonFromElement(final Element element, final Set<String> propertyKeys, final GraphSONMode mode)\n      throws JSONException {\n    final OGraphSONUtility graphson = element instanceof Edge ? new OGraphSONUtility(mode, null, null, propertyKeys)\n        : new OGraphSONUtility(mode, null, propertyKeys, null);\n    return graphson.jsonFromElement(element);\n  }", "language": "java", "code": "public static JSONObject jsonFromElement(final Element element, final Set<String> propertyKeys, final GraphSONMode mode)\n      throws JSONException {\n    final OGraphSONUtility graphson = element instanceof Edge ? new OGraphSONUtility(mode, null, null, propertyKeys)\n        : new OGraphSONUtility(mode, null, propertyKeys, null);\n    return graphson.jsonFromElement(element);\n  }", "code_tokens": ["public", "static", "JSONObject", "jsonFromElement", "(", "final", "Element", "element", ",", "final", "Set", "<", "String", ">", "propertyKeys", ",", "final", "GraphSONMode", "mode", ")", "throws", "JSONException", "{", "final", "OGraphSONUtility", "graphson", "=", "element", "instanceof", "Edge", "?", "new", "OGraphSONUtility", "(", "mode", ",", "null", ",", "null", ",", "propertyKeys", ")", ":", "new", "OGraphSONUtility", "(", "mode", ",", "null", ",", "propertyKeys", ",", "null", ")", ";", "return", "graphson", ".", "jsonFromElement", "(", "element", ")", ";", "}"], "docstring": "Creates a Jettison JSONObject from a graph element.\n\n@param element\nthe graph element to convert to JSON.\n@param propertyKeys\nThe property keys at the root of the element to serialize. If null, then all keys are serialized.\n@param mode\nthe type of GraphSON to be generated.", "docstring_tokens": ["Creates", "a", "Jettison", "JSONObject", "from", "a", "graph", "element", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphSONUtility.java#L413-L418", "partition": "test", "index": 3179, "time": "2016-08-23 02:43:20"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphSONUtility.java", "func_name": "OGraphSONUtility.vertexFromJson", "original_string": "public static Vertex vertexFromJson(final JSONObject json, final ElementFactory factory, final GraphSONMode mode,\n      final Set<String> propertyKeys) throws IOException {\n    final OGraphSONUtility graphson = new OGraphSONUtility(mode, factory, propertyKeys, null);\n    return graphson.vertexFromJson(json);\n  }", "language": "java", "code": "public static Vertex vertexFromJson(final JSONObject json, final ElementFactory factory, final GraphSONMode mode,\n      final Set<String> propertyKeys) throws IOException {\n    final OGraphSONUtility graphson = new OGraphSONUtility(mode, factory, propertyKeys, null);\n    return graphson.vertexFromJson(json);\n  }", "code_tokens": ["public", "static", "Vertex", "vertexFromJson", "(", "final", "JSONObject", "json", ",", "final", "ElementFactory", "factory", ",", "final", "GraphSONMode", "mode", ",", "final", "Set", "<", "String", ">", "propertyKeys", ")", "throws", "IOException", "{", "final", "OGraphSONUtility", "graphson", "=", "new", "OGraphSONUtility", "(", "mode", ",", "factory", ",", "propertyKeys", ",", "null", ")", ";", "return", "graphson", ".", "vertexFromJson", "(", "json", ")", ";", "}"], "docstring": "Reads an individual Vertex from JSON. The vertex must match the accepted GraphSON format.\n\n@param json\na single vertex in GraphSON format as Jettison JSONObject\n@param factory\nthe factory responsible for constructing graph elements\n@param mode\nthe mode of the GraphSON\n@param propertyKeys\na list of keys to include on reading of element properties", "docstring_tokens": ["Reads", "an", "individual", "Vertex", "from", "JSON", ".", "The", "vertex", "must", "match", "the", "accepted", "GraphSON", "format", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphSONUtility.java#L271-L275", "partition": "test", "index": 3177, "time": "2016-08-23 02:43:20"}
{"repo": "orientechnologies/orientdb", "path": "graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphSONUtility.java", "func_name": "OGraphSONUtility.edgeFromJson", "original_string": "public static Edge edgeFromJson(final JSONObject json, final Vertex out, final Vertex in, final ElementFactory factory,\n      final GraphSONMode mode, final Set<String> propertyKeys) throws IOException {\n    final OGraphSONUtility graphson = new OGraphSONUtility(mode, factory, null, propertyKeys);\n    return graphson.edgeFromJson(json, out, in);\n  }", "language": "java", "code": "public static Edge edgeFromJson(final JSONObject json, final Vertex out, final Vertex in, final ElementFactory factory,\n      final GraphSONMode mode, final Set<String> propertyKeys) throws IOException {\n    final OGraphSONUtility graphson = new OGraphSONUtility(mode, factory, null, propertyKeys);\n    return graphson.edgeFromJson(json, out, in);\n  }", "code_tokens": ["public", "static", "Edge", "edgeFromJson", "(", "final", "JSONObject", "json", ",", "final", "Vertex", "out", ",", "final", "Vertex", "in", ",", "final", "ElementFactory", "factory", ",", "final", "GraphSONMode", "mode", ",", "final", "Set", "<", "String", ">", "propertyKeys", ")", "throws", "IOException", "{", "final", "OGraphSONUtility", "graphson", "=", "new", "OGraphSONUtility", "(", "mode", ",", "factory", ",", "null", ",", "propertyKeys", ")", ";", "return", "graphson", ".", "edgeFromJson", "(", "json", ",", "out", ",", "in", ")", ";", "}"], "docstring": "Reads an individual Edge from JSON. The edge must match the accepted GraphSON format.\n\n@param json\na single edge in GraphSON format as a Jettison JSONObject\n@param factory\nthe factory responsible for constructing graph elements\n@param mode\nthe mode of the GraphSON\n@param propertyKeys\na list of keys to include when reading of element properties", "docstring_tokens": ["Reads", "an", "individual", "Edge", "from", "JSON", ".", "The", "edge", "must", "match", "the", "accepted", "GraphSON", "format", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/graphdb/src/main/java/com/orientechnologies/orient/graph/graphml/OGraphSONUtility.java#L343-L347", "partition": "test", "index": 3178, "time": "2016-08-23 02:43:20"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/enhancement/field/ODocumentSimpleFieldHandlingStrategy.java", "func_name": "ODocumentSimpleFieldHandlingStrategy.deriveFieldType", "original_string": "protected OType deriveFieldType(ODocument iRecord, String fieldName, OType requestedFieldType) {\n\n    // Schema defined types can not be ignored\n    if (iRecord.getSchemaClass().existsProperty(fieldName)) {\n      return iRecord.getSchemaClass().getProperty(fieldName).getType();\n    }\n\n    // New type\n    if (requestedFieldType != null) {\n      return requestedFieldType;\n    }\n\n    // Existing type (not fixed by the schema)\n    return iRecord.fieldType(fieldName);\n  }", "language": "java", "code": "protected OType deriveFieldType(ODocument iRecord, String fieldName, OType requestedFieldType) {\n\n    // Schema defined types can not be ignored\n    if (iRecord.getSchemaClass().existsProperty(fieldName)) {\n      return iRecord.getSchemaClass().getProperty(fieldName).getType();\n    }\n\n    // New type\n    if (requestedFieldType != null) {\n      return requestedFieldType;\n    }\n\n    // Existing type (not fixed by the schema)\n    return iRecord.fieldType(fieldName);\n  }", "code_tokens": ["protected", "OType", "deriveFieldType", "(", "ODocument", "iRecord", ",", "String", "fieldName", ",", "OType", "requestedFieldType", ")", "{", "// Schema defined types can not be ignored", "if", "(", "iRecord", ".", "getSchemaClass", "(", ")", ".", "existsProperty", "(", "fieldName", ")", ")", "{", "return", "iRecord", ".", "getSchemaClass", "(", ")", ".", "getProperty", "(", "fieldName", ")", ".", "getType", "(", ")", ";", "}", "// New type", "if", "(", "requestedFieldType", "!=", "null", ")", "{", "return", "requestedFieldType", ";", "}", "// Existing type (not fixed by the schema)", "return", "iRecord", ".", "fieldType", "(", "fieldName", ")", ";", "}"], "docstring": "Derives the type of a field in a document.\n\n@param iRecord\n@param fieldName\n@param requestedFieldType\n@return derived field type", "docstring_tokens": ["Derives", "the", "type", "of", "a", "field", "in", "a", "document", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/enhancement/field/ODocumentSimpleFieldHandlingStrategy.java#L58-L72", "partition": "test", "index": 2916, "time": "2016-09-06 16:12:02"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OScriptExecutionPlan.java", "func_name": "OScriptExecutionPlan.executeUntilReturn", "original_string": "public OExecutionStepInternal executeUntilReturn() {\n    if (steps.size() > 0) {\n      lastStep = steps.get(steps.size() - 1);\n    }\n    for (int i = 0; i < steps.size() - 1; i++) {\n      ScriptLineStep step = steps.get(i);\n      if (step.containsReturn()) {\n        OExecutionStepInternal returnStep = step.executeUntilReturn(ctx);\n        if (returnStep != null) {\n          lastStep = returnStep;\n          return lastStep;\n        }\n      }\n      OResultSet lastResult = step.syncPull(ctx, 100);\n\n      while (lastResult.hasNext()) {\n        while (lastResult.hasNext()) {\n          lastResult.next();\n        }\n        lastResult = step.syncPull(ctx, 100);\n      }\n    }\n    this.lastStep = steps.get(steps.size() - 1);\n    return lastStep;\n  }", "language": "java", "code": "public OExecutionStepInternal executeUntilReturn() {\n    if (steps.size() > 0) {\n      lastStep = steps.get(steps.size() - 1);\n    }\n    for (int i = 0; i < steps.size() - 1; i++) {\n      ScriptLineStep step = steps.get(i);\n      if (step.containsReturn()) {\n        OExecutionStepInternal returnStep = step.executeUntilReturn(ctx);\n        if (returnStep != null) {\n          lastStep = returnStep;\n          return lastStep;\n        }\n      }\n      OResultSet lastResult = step.syncPull(ctx, 100);\n\n      while (lastResult.hasNext()) {\n        while (lastResult.hasNext()) {\n          lastResult.next();\n        }\n        lastResult = step.syncPull(ctx, 100);\n      }\n    }\n    this.lastStep = steps.get(steps.size() - 1);\n    return lastStep;\n  }", "code_tokens": ["public", "OExecutionStepInternal", "executeUntilReturn", "(", ")", "{", "if", "(", "steps", ".", "size", "(", ")", ">", "0", ")", "{", "lastStep", "=", "steps", ".", "get", "(", "steps", ".", "size", "(", ")", "-", "1", ")", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "steps", ".", "size", "(", ")", "-", "1", ";", "i", "++", ")", "{", "ScriptLineStep", "step", "=", "steps", ".", "get", "(", "i", ")", ";", "if", "(", "step", ".", "containsReturn", "(", ")", ")", "{", "OExecutionStepInternal", "returnStep", "=", "step", ".", "executeUntilReturn", "(", "ctx", ")", ";", "if", "(", "returnStep", "!=", "null", ")", "{", "lastStep", "=", "returnStep", ";", "return", "lastStep", ";", "}", "}", "OResultSet", "lastResult", "=", "step", ".", "syncPull", "(", "ctx", ",", "100", ")", ";", "while", "(", "lastResult", ".", "hasNext", "(", ")", ")", "{", "while", "(", "lastResult", ".", "hasNext", "(", ")", ")", "{", "lastResult", ".", "next", "(", ")", ";", "}", "lastResult", "=", "step", ".", "syncPull", "(", "ctx", ",", "100", ")", ";", "}", "}", "this", ".", "lastStep", "=", "steps", ".", "get", "(", "steps", ".", "size", "(", ")", "-", "1", ")", ";", "return", "lastStep", ";", "}"], "docstring": "executes all the script and returns last statement execution step, so that it can be executed from outside\n\n@return", "docstring_tokens": ["executes", "all", "the", "script", "and", "returns", "last", "statement", "execution", "step", "so", "that", "it", "can", "be", "executed", "from", "outside"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OScriptExecutionPlan.java#L174-L198", "partition": "test", "index": 2983, "time": "2016-09-20 11:37:32"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/enhancement/field/ODocumentFieldHandlingStrategyFactory.java", "func_name": "ODocumentFieldHandlingStrategyFactory.create", "original_string": "public ODocumentFieldHandlingStrategy create(int strategy) {\n\n    Optional<ODocumentFieldHandlingStrategy> registered = ODocumentFieldHandlingStrategyRegistry.getInstance()\n        .getStrategy(strategy);\n    if (registered.isPresent()) {\n      return registered.get();\n    }\n\n    Map<OType, ODocumentFieldOTypeHandlingStrategy> typeHandlingStrategies = new HashMap<OType, ODocumentFieldOTypeHandlingStrategy>();\n\n    switch (strategy) {\n    case SINGLE_ORECORD_BYTES:\n      typeHandlingStrategies.put(OType.BINARY, new ODocumentSingleRecordBytesOTypeHandlingStrategy());\n      break;\n\n    case SPLIT_ORECORD_BYTES:\n      typeHandlingStrategies.put(OType.BINARY, new ODocumentSplitRecordBytesOTypeHandlingStrategy());\n      break;\n\n    case SIMPLE:\n    default:\n      break;\n    }\n\n    ODocumentSmartFieldHandlingStrategy strategyInstance = new ODocumentSmartFieldHandlingStrategy(typeHandlingStrategies);\n    ODocumentFieldHandlingStrategyRegistry.getInstance().registerStrategy(strategy, strategyInstance);\n    return strategyInstance;\n  }", "language": "java", "code": "public ODocumentFieldHandlingStrategy create(int strategy) {\n\n    Optional<ODocumentFieldHandlingStrategy> registered = ODocumentFieldHandlingStrategyRegistry.getInstance()\n        .getStrategy(strategy);\n    if (registered.isPresent()) {\n      return registered.get();\n    }\n\n    Map<OType, ODocumentFieldOTypeHandlingStrategy> typeHandlingStrategies = new HashMap<OType, ODocumentFieldOTypeHandlingStrategy>();\n\n    switch (strategy) {\n    case SINGLE_ORECORD_BYTES:\n      typeHandlingStrategies.put(OType.BINARY, new ODocumentSingleRecordBytesOTypeHandlingStrategy());\n      break;\n\n    case SPLIT_ORECORD_BYTES:\n      typeHandlingStrategies.put(OType.BINARY, new ODocumentSplitRecordBytesOTypeHandlingStrategy());\n      break;\n\n    case SIMPLE:\n    default:\n      break;\n    }\n\n    ODocumentSmartFieldHandlingStrategy strategyInstance = new ODocumentSmartFieldHandlingStrategy(typeHandlingStrategies);\n    ODocumentFieldHandlingStrategyRegistry.getInstance().registerStrategy(strategy, strategyInstance);\n    return strategyInstance;\n  }", "code_tokens": ["public", "ODocumentFieldHandlingStrategy", "create", "(", "int", "strategy", ")", "{", "Optional", "<", "ODocumentFieldHandlingStrategy", ">", "registered", "=", "ODocumentFieldHandlingStrategyRegistry", ".", "getInstance", "(", ")", ".", "getStrategy", "(", "strategy", ")", ";", "if", "(", "registered", ".", "isPresent", "(", ")", ")", "{", "return", "registered", ".", "get", "(", ")", ";", "}", "Map", "<", "OType", ",", "ODocumentFieldOTypeHandlingStrategy", ">", "typeHandlingStrategies", "=", "new", "HashMap", "<", "OType", ",", "ODocumentFieldOTypeHandlingStrategy", ">", "(", ")", ";", "switch", "(", "strategy", ")", "{", "case", "SINGLE_ORECORD_BYTES", ":", "typeHandlingStrategies", ".", "put", "(", "OType", ".", "BINARY", ",", "new", "ODocumentSingleRecordBytesOTypeHandlingStrategy", "(", ")", ")", ";", "break", ";", "case", "SPLIT_ORECORD_BYTES", ":", "typeHandlingStrategies", ".", "put", "(", "OType", ".", "BINARY", ",", "new", "ODocumentSplitRecordBytesOTypeHandlingStrategy", "(", ")", ")", ";", "break", ";", "case", "SIMPLE", ":", "default", ":", "break", ";", "}", "ODocumentSmartFieldHandlingStrategy", "strategyInstance", "=", "new", "ODocumentSmartFieldHandlingStrategy", "(", "typeHandlingStrategies", ")", ";", "ODocumentFieldHandlingStrategyRegistry", ".", "getInstance", "(", ")", ".", "registerStrategy", "(", "strategy", ",", "strategyInstance", ")", ";", "return", "strategyInstance", ";", "}"], "docstring": "Creates a new instance of the requested strategy. Since strategies are stateless, if an existing instance already exists then\nit's returned.\n\n@param strategy\n@return strategy instance", "docstring_tokens": ["Creates", "a", "new", "instance", "of", "the", "requested", "strategy", ".", "Since", "strategies", "are", "stateless", "if", "an", "existing", "instance", "already", "exists", "then", "it", "s", "returned", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/enhancement/field/ODocumentFieldHandlingStrategyFactory.java#L57-L84", "partition": "test", "index": 2931, "time": "2016-10-11 14:47:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/Pattern.java", "func_name": "Pattern.getDisjointPatterns", "original_string": "public List<Pattern> getDisjointPatterns() {\n    Map<PatternNode, String> reverseMap = new IdentityHashMap<>();\n    reverseMap.putAll(this.aliasToNode.entrySet().stream().collect(Collectors.toMap(x -> x.getValue(), x -> x.getKey())));\n\n    List<Pattern> result = new ArrayList<>();\n    while (!reverseMap.isEmpty()) {\n      Pattern pattern = new Pattern();\n      result.add(pattern);\n      Map.Entry<PatternNode, String> nextNode = reverseMap.entrySet().iterator().next();\n      Set<PatternNode> toVisit = new HashSet<>();\n      toVisit.add(nextNode.getKey());\n      while (toVisit.size() > 0) {\n        PatternNode currentNode = toVisit.iterator().next();\n        toVisit.remove(currentNode);\n        if (reverseMap.containsKey(currentNode)) {\n          pattern.aliasToNode.put(reverseMap.get(currentNode), currentNode);\n          reverseMap.remove(currentNode);\n          for (PatternEdge x : currentNode.out) {\n            toVisit.add(x.in);\n          }\n          for (PatternEdge x : currentNode.in) {\n            toVisit.add(x.out);\n          }\n        }\n      }\n      pattern.recalculateNumOfEdges();\n    }\n    return result;\n  }", "language": "java", "code": "public List<Pattern> getDisjointPatterns() {\n    Map<PatternNode, String> reverseMap = new IdentityHashMap<>();\n    reverseMap.putAll(this.aliasToNode.entrySet().stream().collect(Collectors.toMap(x -> x.getValue(), x -> x.getKey())));\n\n    List<Pattern> result = new ArrayList<>();\n    while (!reverseMap.isEmpty()) {\n      Pattern pattern = new Pattern();\n      result.add(pattern);\n      Map.Entry<PatternNode, String> nextNode = reverseMap.entrySet().iterator().next();\n      Set<PatternNode> toVisit = new HashSet<>();\n      toVisit.add(nextNode.getKey());\n      while (toVisit.size() > 0) {\n        PatternNode currentNode = toVisit.iterator().next();\n        toVisit.remove(currentNode);\n        if (reverseMap.containsKey(currentNode)) {\n          pattern.aliasToNode.put(reverseMap.get(currentNode), currentNode);\n          reverseMap.remove(currentNode);\n          for (PatternEdge x : currentNode.out) {\n            toVisit.add(x.in);\n          }\n          for (PatternEdge x : currentNode.in) {\n            toVisit.add(x.out);\n          }\n        }\n      }\n      pattern.recalculateNumOfEdges();\n    }\n    return result;\n  }", "code_tokens": ["public", "List", "<", "Pattern", ">", "getDisjointPatterns", "(", ")", "{", "Map", "<", "PatternNode", ",", "String", ">", "reverseMap", "=", "new", "IdentityHashMap", "<>", "(", ")", ";", "reverseMap", ".", "putAll", "(", "this", ".", "aliasToNode", ".", "entrySet", "(", ")", ".", "stream", "(", ")", ".", "collect", "(", "Collectors", ".", "toMap", "(", "x", "->", "x", ".", "getValue", "(", ")", ",", "x", "->", "x", ".", "getKey", "(", ")", ")", ")", ")", ";", "List", "<", "Pattern", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "while", "(", "!", "reverseMap", ".", "isEmpty", "(", ")", ")", "{", "Pattern", "pattern", "=", "new", "Pattern", "(", ")", ";", "result", ".", "add", "(", "pattern", ")", ";", "Map", ".", "Entry", "<", "PatternNode", ",", "String", ">", "nextNode", "=", "reverseMap", ".", "entrySet", "(", ")", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "Set", "<", "PatternNode", ">", "toVisit", "=", "new", "HashSet", "<>", "(", ")", ";", "toVisit", ".", "add", "(", "nextNode", ".", "getKey", "(", ")", ")", ";", "while", "(", "toVisit", ".", "size", "(", ")", ">", "0", ")", "{", "PatternNode", "currentNode", "=", "toVisit", ".", "iterator", "(", ")", ".", "next", "(", ")", ";", "toVisit", ".", "remove", "(", "currentNode", ")", ";", "if", "(", "reverseMap", ".", "containsKey", "(", "currentNode", ")", ")", "{", "pattern", ".", "aliasToNode", ".", "put", "(", "reverseMap", ".", "get", "(", "currentNode", ")", ",", "currentNode", ")", ";", "reverseMap", ".", "remove", "(", "currentNode", ")", ";", "for", "(", "PatternEdge", "x", ":", "currentNode", ".", "out", ")", "{", "toVisit", ".", "add", "(", "x", ".", "in", ")", ";", "}", "for", "(", "PatternEdge", "x", ":", "currentNode", ".", "in", ")", "{", "toVisit", ".", "add", "(", "x", ".", "out", ")", ";", "}", "}", "}", "pattern", ".", "recalculateNumOfEdges", "(", ")", ";", "}", "return", "result", ";", "}"], "docstring": "splits this pattern into multiple\n\n@return", "docstring_tokens": ["splits", "this", "pattern", "into", "multiple"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/Pattern.java#L73-L101", "partition": "test", "index": 2946, "time": "2016-10-12 17:04:57"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OProfileStorageStatement.java", "func_name": "OProfileStorageStatement.executeSimple", "original_string": "@Override public OResultSet executeSimple(OCommandContext ctx) {\n    OResultInternal result = new OResultInternal();\n    result.setProperty(\"operation\", \"optimize database\");\n\n    OStorage storage = ((ODatabaseInternal) ctx.getDatabase()).getStorage();\n\n    if (on) {\n      // activate the profiler\n      ((OAbstractPaginatedStorage) storage).startGatheringPerformanceStatisticForCurrentThread();\n      result.setProperty(\"value\", \"on\");\n    } else {\n      // stop the profiler and return the stats\n      final OSessionStoragePerformanceStatistic performanceStatistic = ((OAbstractPaginatedStorage) storage)\n          .completeGatheringPerformanceStatisticForCurrentThread();\n\n      result.setProperty(\"value\", \"off\");\n      if (performanceStatistic != null) {\n        result.setProperty(\"result\", performanceStatistic.toDocument());\n      } else {\n        result.setProperty(\"result\", \"error\");\n        result.setProperty(\"errorMessage\", \"profiling of storage was not started\");\n      }\n    }\n\n    OInternalResultSet rs = new OInternalResultSet();\n    rs.add(result);\n    return rs;\n  }", "language": "java", "code": "@Override public OResultSet executeSimple(OCommandContext ctx) {\n    OResultInternal result = new OResultInternal();\n    result.setProperty(\"operation\", \"optimize database\");\n\n    OStorage storage = ((ODatabaseInternal) ctx.getDatabase()).getStorage();\n\n    if (on) {\n      // activate the profiler\n      ((OAbstractPaginatedStorage) storage).startGatheringPerformanceStatisticForCurrentThread();\n      result.setProperty(\"value\", \"on\");\n    } else {\n      // stop the profiler and return the stats\n      final OSessionStoragePerformanceStatistic performanceStatistic = ((OAbstractPaginatedStorage) storage)\n          .completeGatheringPerformanceStatisticForCurrentThread();\n\n      result.setProperty(\"value\", \"off\");\n      if (performanceStatistic != null) {\n        result.setProperty(\"result\", performanceStatistic.toDocument());\n      } else {\n        result.setProperty(\"result\", \"error\");\n        result.setProperty(\"errorMessage\", \"profiling of storage was not started\");\n      }\n    }\n\n    OInternalResultSet rs = new OInternalResultSet();\n    rs.add(result);\n    return rs;\n  }", "code_tokens": ["@", "Override", "public", "OResultSet", "executeSimple", "(", "OCommandContext", "ctx", ")", "{", "OResultInternal", "result", "=", "new", "OResultInternal", "(", ")", ";", "result", ".", "setProperty", "(", "\"operation\"", ",", "\"optimize database\"", ")", ";", "OStorage", "storage", "=", "(", "(", "ODatabaseInternal", ")", "ctx", ".", "getDatabase", "(", ")", ")", ".", "getStorage", "(", ")", ";", "if", "(", "on", ")", "{", "// activate the profiler", "(", "(", "OAbstractPaginatedStorage", ")", "storage", ")", ".", "startGatheringPerformanceStatisticForCurrentThread", "(", ")", ";", "result", ".", "setProperty", "(", "\"value\"", ",", "\"on\"", ")", ";", "}", "else", "{", "// stop the profiler and return the stats", "final", "OSessionStoragePerformanceStatistic", "performanceStatistic", "=", "(", "(", "OAbstractPaginatedStorage", ")", "storage", ")", ".", "completeGatheringPerformanceStatisticForCurrentThread", "(", ")", ";", "result", ".", "setProperty", "(", "\"value\"", ",", "\"off\"", ")", ";", "if", "(", "performanceStatistic", "!=", "null", ")", "{", "result", ".", "setProperty", "(", "\"result\"", ",", "performanceStatistic", ".", "toDocument", "(", ")", ")", ";", "}", "else", "{", "result", ".", "setProperty", "(", "\"result\"", ",", "\"error\"", ")", ";", "result", ".", "setProperty", "(", "\"errorMessage\"", ",", "\"profiling of storage was not started\"", ")", ";", "}", "}", "OInternalResultSet", "rs", "=", "new", "OInternalResultSet", "(", ")", ";", "rs", ".", "add", "(", "result", ")", ";", "return", "rs", ";", "}"], "docstring": "new execution logic", "docstring_tokens": ["new", "execution", "logic"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OProfileStorageStatement.java#L36-L63", "partition": "test", "index": 3264, "time": "2016-10-17 16:29:49"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/index/hashindex/local/OHashIndexBucket.java", "func_name": "OHashIndexBucket.getValue", "original_string": "public V getValue(int index) {\n    int entryPosition = getIntValue(POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE);\n\n    // skip hash code\n    entryPosition += OLongSerializer.LONG_SIZE;\n\n    if (encryption == null) {\n      // skip key\n      entryPosition += getObjectSizeInDirectMemory(keySerializer, entryPosition);\n    } else {\n      final int encryptedLength = getIntValue(entryPosition);\n      entryPosition += encryptedLength + OIntegerSerializer.INT_SIZE;\n    }\n\n    return deserializeFromDirectMemory(valueSerializer, entryPosition);\n  }", "language": "java", "code": "public V getValue(int index) {\n    int entryPosition = getIntValue(POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE);\n\n    // skip hash code\n    entryPosition += OLongSerializer.LONG_SIZE;\n\n    if (encryption == null) {\n      // skip key\n      entryPosition += getObjectSizeInDirectMemory(keySerializer, entryPosition);\n    } else {\n      final int encryptedLength = getIntValue(entryPosition);\n      entryPosition += encryptedLength + OIntegerSerializer.INT_SIZE;\n    }\n\n    return deserializeFromDirectMemory(valueSerializer, entryPosition);\n  }", "code_tokens": ["public", "V", "getValue", "(", "int", "index", ")", "{", "int", "entryPosition", "=", "getIntValue", "(", "POSITIONS_ARRAY_OFFSET", "+", "index", "*", "OIntegerSerializer", ".", "INT_SIZE", ")", ";", "// skip hash code", "entryPosition", "+=", "OLongSerializer", ".", "LONG_SIZE", ";", "if", "(", "encryption", "==", "null", ")", "{", "// skip key", "entryPosition", "+=", "getObjectSizeInDirectMemory", "(", "keySerializer", ",", "entryPosition", ")", ";", "}", "else", "{", "final", "int", "encryptedLength", "=", "getIntValue", "(", "entryPosition", ")", ";", "entryPosition", "+=", "encryptedLength", "+", "OIntegerSerializer", ".", "INT_SIZE", ";", "}", "return", "deserializeFromDirectMemory", "(", "valueSerializer", ",", "entryPosition", ")", ";", "}"], "docstring": "Obtains the value stored under the given index in this bucket.\n\n@param index the value index.\n\n@return the obtained value.", "docstring_tokens": ["Obtains", "the", "value", "stored", "under", "the", "given", "index", "in", "this", "bucket", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/index/hashindex/local/OHashIndexBucket.java#L165-L180", "partition": "test", "index": 3157, "time": "2016-10-24 16:21:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java", "func_name": "OAbstractPaginatedStorage.validatedPutIndexValue", "original_string": "@SuppressWarnings(\"UnusedReturnValue\")\n  public boolean validatedPutIndexValue(int indexId, final Object key, final ORID value,\n      final OBaseIndexEngine.Validator<Object, ORID> validator) throws OInvalidIndexEngineIdException {\n    indexId = extractInternalId(indexId);\n\n    try {\n      if (transaction.get() != null) {\n        return doValidatedPutIndexValue(indexId, key, value, validator);\n      }\n\n      checkOpenness();\n\n      stateLock.acquireReadLock();\n      try {\n        checkOpenness();\n\n        checkLowDiskSpaceRequestsAndReadOnlyConditions();\n\n        return doValidatedPutIndexValue(indexId, key, value, validator);\n      } finally {\n        stateLock.releaseReadLock();\n      }\n    } catch (final OInvalidIndexEngineIdException ie) {\n      throw logAndPrepareForRethrow(ie);\n    } catch (final RuntimeException ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Error ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Throwable t) {\n      throw logAndPrepareForRethrow(t);\n    }\n  }", "language": "java", "code": "@SuppressWarnings(\"UnusedReturnValue\")\n  public boolean validatedPutIndexValue(int indexId, final Object key, final ORID value,\n      final OBaseIndexEngine.Validator<Object, ORID> validator) throws OInvalidIndexEngineIdException {\n    indexId = extractInternalId(indexId);\n\n    try {\n      if (transaction.get() != null) {\n        return doValidatedPutIndexValue(indexId, key, value, validator);\n      }\n\n      checkOpenness();\n\n      stateLock.acquireReadLock();\n      try {\n        checkOpenness();\n\n        checkLowDiskSpaceRequestsAndReadOnlyConditions();\n\n        return doValidatedPutIndexValue(indexId, key, value, validator);\n      } finally {\n        stateLock.releaseReadLock();\n      }\n    } catch (final OInvalidIndexEngineIdException ie) {\n      throw logAndPrepareForRethrow(ie);\n    } catch (final RuntimeException ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Error ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Throwable t) {\n      throw logAndPrepareForRethrow(t);\n    }\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"UnusedReturnValue\"", ")", "public", "boolean", "validatedPutIndexValue", "(", "int", "indexId", ",", "final", "Object", "key", ",", "final", "ORID", "value", ",", "final", "OBaseIndexEngine", ".", "Validator", "<", "Object", ",", "ORID", ">", "validator", ")", "throws", "OInvalidIndexEngineIdException", "{", "indexId", "=", "extractInternalId", "(", "indexId", ")", ";", "try", "{", "if", "(", "transaction", ".", "get", "(", ")", "!=", "null", ")", "{", "return", "doValidatedPutIndexValue", "(", "indexId", ",", "key", ",", "value", ",", "validator", ")", ";", "}", "checkOpenness", "(", ")", ";", "stateLock", ".", "acquireReadLock", "(", ")", ";", "try", "{", "checkOpenness", "(", ")", ";", "checkLowDiskSpaceRequestsAndReadOnlyConditions", "(", ")", ";", "return", "doValidatedPutIndexValue", "(", "indexId", ",", "key", ",", "value", ",", "validator", ")", ";", "}", "finally", "{", "stateLock", ".", "releaseReadLock", "(", ")", ";", "}", "}", "catch", "(", "final", "OInvalidIndexEngineIdException", "ie", ")", "{", "throw", "logAndPrepareForRethrow", "(", "ie", ")", ";", "}", "catch", "(", "final", "RuntimeException", "ee", ")", "{", "throw", "logAndPrepareForRethrow", "(", "ee", ")", ";", "}", "catch", "(", "final", "Error", "ee", ")", "{", "throw", "logAndPrepareForRethrow", "(", "ee", ")", ";", "}", "catch", "(", "final", "Throwable", "t", ")", "{", "throw", "logAndPrepareForRethrow", "(", "t", ")", ";", "}", "}"], "docstring": "Puts the given value under the given key into this storage for the index with the given index id. Validates the operation using\nthe provided validator.\n\n@param indexId   the index id of the index to put the value into.\n@param key       the key to put the value under.\n@param value     the value to put.\n@param validator the operation validator.\n\n@return {@code true} if the validator allowed the put, {@code false} otherwise.\n\n@see OBaseIndexEngine.Validator#validate(Object, Object, Object)", "docstring_tokens": ["Puts", "the", "given", "value", "under", "the", "given", "key", "into", "this", "storage", "for", "the", "index", "with", "the", "given", "index", "id", ".", "Validates", "the", "operation", "using", "the", "provided", "validator", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java#L2992-L3023", "partition": "test", "index": 3319, "time": "2016-10-24 16:21:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/compression/OCompressionFactory.java", "func_name": "OCompressionFactory.register", "original_string": "public void register(final Class<? extends OCompression> compression) {\n    try {\n      final OCompression tempInstance = compression.newInstance();\n\n      final String name = tempInstance.name();\n\n      if (compressions.containsKey(name))\n        throw new IllegalArgumentException(\"Compression with name '\" + name + \"' was already registered\");\n\n      if (compressionClasses.containsKey(tempInstance.name()))\n        throw new IllegalArgumentException(\"Compression with name '\" + name + \"' was already registered\");\n\n      compressionClasses.put(name, compression);\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Cannot register storage compression algorithm '%s'\", e, compression);\n    }\n  }", "language": "java", "code": "public void register(final Class<? extends OCompression> compression) {\n    try {\n      final OCompression tempInstance = compression.newInstance();\n\n      final String name = tempInstance.name();\n\n      if (compressions.containsKey(name))\n        throw new IllegalArgumentException(\"Compression with name '\" + name + \"' was already registered\");\n\n      if (compressionClasses.containsKey(tempInstance.name()))\n        throw new IllegalArgumentException(\"Compression with name '\" + name + \"' was already registered\");\n\n      compressionClasses.put(name, compression);\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Cannot register storage compression algorithm '%s'\", e, compression);\n    }\n  }", "code_tokens": ["public", "void", "register", "(", "final", "Class", "<", "?", "extends", "OCompression", ">", "compression", ")", "{", "try", "{", "final", "OCompression", "tempInstance", "=", "compression", ".", "newInstance", "(", ")", ";", "final", "String", "name", "=", "tempInstance", ".", "name", "(", ")", ";", "if", "(", "compressions", ".", "containsKey", "(", "name", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Compression with name '\"", "+", "name", "+", "\"' was already registered\"", ")", ";", "if", "(", "compressionClasses", ".", "containsKey", "(", "tempInstance", ".", "name", "(", ")", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Compression with name '\"", "+", "name", "+", "\"' was already registered\"", ")", ";", "compressionClasses", ".", "put", "(", "name", ",", "compression", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Cannot register storage compression algorithm '%s'\"", ",", "e", ",", "compression", ")", ";", "}", "}"], "docstring": "Registers a stateless implementations, the same instance will be shared on all the storages.\n\n@param compression Compression class", "docstring_tokens": ["Registers", "a", "stateless", "implementations", "the", "same", "instance", "will", "be", "shared", "on", "all", "the", "storages", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/compression/OCompressionFactory.java#L110-L126", "partition": "test", "index": 2978, "time": "2016-10-28 15:40:22"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getRegisteredServers", "original_string": "public Set<String> getRegisteredServers() {\n\n    final ODocument servers = configuration.field(SERVERS);\n    final Set<String> result = new HashSet<String>();\n    if (servers != null)\n      for (String s : servers.fieldNames())\n        result.add(s);\n    return result;\n  }", "language": "java", "code": "public Set<String> getRegisteredServers() {\n\n    final ODocument servers = configuration.field(SERVERS);\n    final Set<String> result = new HashSet<String>();\n    if (servers != null)\n      for (String s : servers.fieldNames())\n        result.add(s);\n    return result;\n  }", "code_tokens": ["public", "Set", "<", "String", ">", "getRegisteredServers", "(", ")", "{", "final", "ODocument", "servers", "=", "configuration", ".", "field", "(", "SERVERS", ")", ";", "final", "Set", "<", "String", ">", "result", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "if", "(", "servers", "!=", "null", ")", "for", "(", "String", "s", ":", "servers", ".", "fieldNames", "(", ")", ")", "result", ".", "(", "s", ")", ";", "return", "result", ";", "}"], "docstring": "Returns the registered servers.", "docstring_tokens": ["Returns", "the", "registered", "servers", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L557-L565", "partition": "test", "index": 3099, "time": "2016-11-07 13:00:50"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getNewNodeStrategy", "original_string": "public NEW_NODE_STRATEGIES getNewNodeStrategy() {\n\n    final String value = configuration.field(NEW_NODE_STRATEGY);\n    if (value != null)\n      return NEW_NODE_STRATEGIES.valueOf(value.toUpperCase(Locale.ENGLISH));\n\n    return NEW_NODE_STRATEGIES.STATIC;\n  }", "language": "java", "code": "public NEW_NODE_STRATEGIES getNewNodeStrategy() {\n\n    final String value = configuration.field(NEW_NODE_STRATEGY);\n    if (value != null)\n      return NEW_NODE_STRATEGIES.valueOf(value.toUpperCase(Locale.ENGLISH));\n\n    return NEW_NODE_STRATEGIES.STATIC;\n  }", "code_tokens": ["public", "NEW_NODE_STRATEGIES", "getNewNodeStrategy", "(", ")", "{", "final", "String", "value", "=", "configuration", ".", "field", "(", "NEW_NODE_STRATEGY", ")", ";", "if", "(", "value", "!=", "null", ")", "return", "NEW_NODE_STRATEGIES", ".", "valueOf", "(", "value", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ")", ";", "return", "NEW_NODE_STRATEGIES", ".", "STATIC", ";", "}"], "docstring": "Returns the new node strategy between \"dynamic\" and \"static\". If static, the node is registered under the \"server\" tag.\n\n@return NEW_NODE_STRATEGIES enum", "docstring_tokens": ["Returns", "the", "new", "node", "strategy", "between", "dynamic", "and", "static", ".", "If", "static", "the", "node", "is", "registered", "under", "the", "server", "tag", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L108-L115", "partition": "test", "index": 3085, "time": "2016-11-07 19:24:29"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java", "func_name": "OSymmetricKey.fromConfig", "original_string": "public static OSymmetricKey fromConfig(final OSymmetricKeyConfig keyConfig) {\n    if (keyConfig.usesKeyString()) {\n      return fromString(keyConfig.getKeyAlgorithm(), keyConfig.getKeyString());\n    } else if (keyConfig.usesKeyFile()) {\n      return fromFile(keyConfig.getKeyAlgorithm(), keyConfig.getKeyFile());\n    } else if (keyConfig.usesKeystore()) {\n      return fromKeystore(keyConfig.getKeystoreFile(), keyConfig.getKeystorePassword(), keyConfig.getKeystoreKeyAlias(),\n          keyConfig.getKeystoreKeyPassword());\n    } else {\n      throw new OSecurityException(\"OSymmetricKey(OSymmetricKeyConfig) Invalid configuration\");\n    }\n  }", "language": "java", "code": "public static OSymmetricKey fromConfig(final OSymmetricKeyConfig keyConfig) {\n    if (keyConfig.usesKeyString()) {\n      return fromString(keyConfig.getKeyAlgorithm(), keyConfig.getKeyString());\n    } else if (keyConfig.usesKeyFile()) {\n      return fromFile(keyConfig.getKeyAlgorithm(), keyConfig.getKeyFile());\n    } else if (keyConfig.usesKeystore()) {\n      return fromKeystore(keyConfig.getKeystoreFile(), keyConfig.getKeystorePassword(), keyConfig.getKeystoreKeyAlias(),\n          keyConfig.getKeystoreKeyPassword());\n    } else {\n      throw new OSecurityException(\"OSymmetricKey(OSymmetricKeyConfig) Invalid configuration\");\n    }\n  }", "code_tokens": ["public", "static", "OSymmetricKey", "fromConfig", "(", "final", "OSymmetricKeyConfig", "keyConfig", ")", "{", "if", "(", "keyConfig", ".", "usesKeyString", "(", ")", ")", "{", "return", "fromString", "(", "keyConfig", ".", "getKeyAlgorithm", "(", ")", ",", "keyConfig", ".", "getKeyString", "(", ")", ")", ";", "}", "else", "if", "(", "keyConfig", ".", "usesKeyFile", "(", ")", ")", "{", "return", "fromFile", "(", "keyConfig", ".", "getKeyAlgorithm", "(", ")", ",", "keyConfig", ".", "getKeyFile", "(", ")", ")", ";", "}", "else", "if", "(", "keyConfig", ".", "usesKeystore", "(", ")", ")", "{", "return", "fromKeystore", "(", "keyConfig", ".", "getKeystoreFile", "(", ")", ",", "keyConfig", ".", "getKeystorePassword", "(", ")", ",", "keyConfig", ".", "getKeystoreKeyAlias", "(", ")", ",", "keyConfig", ".", "getKeystoreKeyPassword", "(", ")", ")", ";", "}", "else", "{", "throw", "new", "OSecurityException", "(", "\"OSymmetricKey(OSymmetricKeyConfig) Invalid configuration\"", ")", ";", "}", "}"], "docstring": "Creates an OSymmetricKey from an OSymmetricKeyConfig interface.", "docstring_tokens": ["Creates", "an", "OSymmetricKey", "from", "an", "OSymmetricKeyConfig", "interface", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java#L222-L233", "partition": "test", "index": 3185, "time": "2016-12-16 15:58:02"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java", "func_name": "OSymmetricKey.fromFile", "original_string": "public static OSymmetricKey fromFile(final String algorithm, final String path) {\n    String base64Key = null;\n\n    try {\n      java.io.FileInputStream fis = null;\n\n      try {\n        fis = new java.io.FileInputStream(OSystemVariableResolver.resolveSystemVariables(path));\n\n        return fromStream(algorithm, fis);\n      } finally {\n        if (fis != null)\n          fis.close();\n      }\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.fromFile() Exception: \" + ex.getMessage()), ex);\n    }\n  }", "language": "java", "code": "public static OSymmetricKey fromFile(final String algorithm, final String path) {\n    String base64Key = null;\n\n    try {\n      java.io.FileInputStream fis = null;\n\n      try {\n        fis = new java.io.FileInputStream(OSystemVariableResolver.resolveSystemVariables(path));\n\n        return fromStream(algorithm, fis);\n      } finally {\n        if (fis != null)\n          fis.close();\n      }\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.fromFile() Exception: \" + ex.getMessage()), ex);\n    }\n  }", "code_tokens": ["public", "static", "OSymmetricKey", "fromFile", "(", "final", "String", "algorithm", ",", "final", "String", "path", ")", "{", "String", "base64Key", "=", "null", ";", "try", "{", "java", ".", "io", ".", "FileInputStream", "fis", "=", "null", ";", "try", "{", "fis", "=", "new", "java", ".", "io", ".", "FileInputStream", "(", "OSystemVariableResolver", ".", "resolveSystemVariables", "(", "path", ")", ")", ";", "return", "fromStream", "(", "algorithm", ",", "fis", ")", ";", "}", "finally", "{", "if", "(", "fis", "!=", "null", ")", "fis", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OSecurityException", "(", "\"OSymmetricKey.fromFile() Exception: \"", "+", "ex", ".", "getMessage", "(", ")", ")", ",", "ex", ")", ";", "}", "}"], "docstring": "Creates an OSymmetricKey from a file containing a Base64 key.", "docstring_tokens": ["Creates", "an", "OSymmetricKey", "from", "a", "file", "containing", "a", "Base64", "key", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java#L245-L262", "partition": "test", "index": 3186, "time": "2016-12-16 15:58:02"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java", "func_name": "OSymmetricKey.fromStream", "original_string": "public static OSymmetricKey fromStream(final String algorithm, final InputStream is) {\n    String base64Key = null;\n\n    try {\n      base64Key = OIOUtils.readStreamAsString(is);\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.fromStream() Exception: \" + ex.getMessage()), ex);\n    }\n\n    return new OSymmetricKey(algorithm, base64Key);\n  }", "language": "java", "code": "public static OSymmetricKey fromStream(final String algorithm, final InputStream is) {\n    String base64Key = null;\n\n    try {\n      base64Key = OIOUtils.readStreamAsString(is);\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.fromStream() Exception: \" + ex.getMessage()), ex);\n    }\n\n    return new OSymmetricKey(algorithm, base64Key);\n  }", "code_tokens": ["public", "static", "OSymmetricKey", "fromStream", "(", "final", "String", "algorithm", ",", "final", "InputStream", "is", ")", "{", "String", "base64Key", "=", "null", ";", "try", "{", "base64Key", "=", "OIOUtils", ".", "readStreamAsString", "(", "is", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OSecurityException", "(", "\"OSymmetricKey.fromStream() Exception: \"", "+", "ex", ".", "getMessage", "(", ")", ")", ",", "ex", ")", ";", "}", "return", "new", "OSymmetricKey", "(", "algorithm", ",", "base64Key", ")", ";", "}"], "docstring": "Creates an OSymmetricKey from an InputStream containing a Base64 key.", "docstring_tokens": ["Creates", "an", "OSymmetricKey", "from", "an", "InputStream", "containing", "a", "Base64", "key", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java#L267-L277", "partition": "test", "index": 3187, "time": "2016-12-16 15:58:02"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java", "func_name": "OSymmetricKey.encrypt", "original_string": "public String encrypt(final String transform, final byte[] bytes) {\n    String encodedJSON = null;\n\n    if (secretKey == null)\n      throw new OSecurityException(\"OSymmetricKey.encrypt() SecretKey is null\");\n    if (transform == null)\n      throw new OSecurityException(\"OSymmetricKey.encrypt() Cannot determine cipher transformation\");\n\n    try {\n      // Throws NoSuchAlgorithmException and NoSuchPaddingException.\n      Cipher cipher = Cipher.getInstance(transform);\n\n      // If the cipher transformation requires an initialization vector then init() will create a random one.\n      // (Use cipher.getIV() to retrieve the IV, if it exists.)\n      cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n      // If the cipher does not use an IV, this will be null.\n      byte[] initVector = cipher.getIV();\n\n//      byte[] initVector = encCipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();\n\n      byte[] encrypted = cipher.doFinal(bytes);\n\n      encodedJSON = encodeJSON(encrypted, initVector);\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.encrypt() Exception: \" + ex.getMessage()), ex);\n    }\n\n    return encodedJSON;\n  }", "language": "java", "code": "public String encrypt(final String transform, final byte[] bytes) {\n    String encodedJSON = null;\n\n    if (secretKey == null)\n      throw new OSecurityException(\"OSymmetricKey.encrypt() SecretKey is null\");\n    if (transform == null)\n      throw new OSecurityException(\"OSymmetricKey.encrypt() Cannot determine cipher transformation\");\n\n    try {\n      // Throws NoSuchAlgorithmException and NoSuchPaddingException.\n      Cipher cipher = Cipher.getInstance(transform);\n\n      // If the cipher transformation requires an initialization vector then init() will create a random one.\n      // (Use cipher.getIV() to retrieve the IV, if it exists.)\n      cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n      // If the cipher does not use an IV, this will be null.\n      byte[] initVector = cipher.getIV();\n\n//      byte[] initVector = encCipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();\n\n      byte[] encrypted = cipher.doFinal(bytes);\n\n      encodedJSON = encodeJSON(encrypted, initVector);\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.encrypt() Exception: \" + ex.getMessage()), ex);\n    }\n\n    return encodedJSON;\n  }", "code_tokens": ["public", "String", "encrypt", "(", "final", "String", "transform", ",", "final", "byte", "[", "]", "bytes", ")", "{", "String", "encodedJSON", "=", "null", ";", "if", "(", "secretKey", "==", "null", ")", "throw", "new", "OSecurityException", "(", "\"OSymmetricKey.encrypt() SecretKey is null\"", ")", ";", "if", "(", "transform", "==", "null", ")", "throw", "new", "OSecurityException", "(", "\"OSymmetricKey.encrypt() Cannot determine cipher transformation\"", ")", ";", "try", "{", "// Throws NoSuchAlgorithmException and NoSuchPaddingException.", "Cipher", "cipher", "=", "Cipher", ".", "getInstance", "(", "transform", ")", ";", "// If the cipher transformation requires an initialization vector then init() will create a random one.", "// (Use cipher.getIV() to retrieve the IV, if it exists.)", "cipher", ".", "init", "(", "Cipher", ".", "ENCRYPT_MODE", ",", "secretKey", ")", ";", "// If the cipher does not use an IV, this will be null.", "byte", "[", "]", "initVector", "=", "cipher", ".", "getIV", "(", ")", ";", "//      byte[] initVector = encCipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();", "byte", "[", "]", "encrypted", "=", "cipher", ".", "doFinal", "(", "bytes", ")", ";", "encodedJSON", "=", "encodeJSON", "(", "encrypted", ",", "initVector", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OSecurityException", "(", "\"OSymmetricKey.encrypt() Exception: \"", "+", "ex", ".", "getMessage", "(", ")", ")", ",", "ex", ")", ";", "}", "return", "encodedJSON", ";", "}"], "docstring": "This method encrypts an array of bytes.\n\n@param transform The cipher transformation to use.\n@param bytes     The array of bytes to be encrypted.\n\n@return The encrypted bytes as a Base64-encoded JSON document or null if unsuccessful.", "docstring_tokens": ["This", "method", "encrypts", "an", "array", "of", "bytes", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java#L439-L468", "partition": "test", "index": 3188, "time": "2016-12-16 15:58:02"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java", "func_name": "OSymmetricKey.saveToStream", "original_string": "public void saveToStream(final OutputStream os) {\n    if (os == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToStream() OutputStream is null\");\n\n    try {\n      final OutputStreamWriter osw = new OutputStreamWriter(os);\n      try {\n        final BufferedWriter writer = new BufferedWriter(osw);\n        try {\n          writer.write(getBase64Key());\n        } finally {\n          writer.close();\n        }\n      } finally {\n        os.close();\n      }\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.saveToStream() Exception: \" + ex.getMessage()), ex);\n    }\n  }", "language": "java", "code": "public void saveToStream(final OutputStream os) {\n    if (os == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToStream() OutputStream is null\");\n\n    try {\n      final OutputStreamWriter osw = new OutputStreamWriter(os);\n      try {\n        final BufferedWriter writer = new BufferedWriter(osw);\n        try {\n          writer.write(getBase64Key());\n        } finally {\n          writer.close();\n        }\n      } finally {\n        os.close();\n      }\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.saveToStream() Exception: \" + ex.getMessage()), ex);\n    }\n  }", "code_tokens": ["public", "void", "saveToStream", "(", "final", "OutputStream", "os", ")", "{", "if", "(", "os", "==", "null", ")", "throw", "new", "OSecurityException", "(", "\"OSymmetricKey.saveToStream() OutputStream is null\"", ")", ";", "try", "{", "final", "OutputStreamWriter", "osw", "=", "new", "OutputStreamWriter", "(", "os", ")", ";", "try", "{", "final", "BufferedWriter", "writer", "=", "new", "BufferedWriter", "(", "osw", ")", ";", "try", "{", "writer", ".", "write", "(", "getBase64Key", "(", ")", ")", ";", "}", "finally", "{", "writer", ".", "close", "(", ")", ";", "}", "}", "finally", "{", "os", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OSecurityException", "(", "\"OSymmetricKey.saveToStream() Exception: \"", "+", "ex", ".", "getMessage", "(", ")", ")", ",", "ex", ")", ";", "}", "}"], "docstring": "Saves the internal SecretKey to the specified OutputStream as a Base64 String.", "docstring_tokens": ["Saves", "the", "internal", "SecretKey", "to", "the", "specified", "OutputStream", "as", "a", "Base64", "String", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java#L591-L610", "partition": "test", "index": 3189, "time": "2016-12-16 15:58:02"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java", "func_name": "OSymmetricKey.saveToKeystore", "original_string": "public void saveToKeystore(final OutputStream os, final String ksPasswd, final String keyAlias, final String keyPasswd) {\n    if (os == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToKeystore() OutputStream is null\");\n    if (ksPasswd == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToKeystore() Keystore Password is required\");\n    if (keyAlias == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToKeystore() Key Alias is required\");\n    if (keyPasswd == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToKeystore() Key Password is required\");\n\n    try {\n      KeyStore ks = KeyStore.getInstance(\"JCEKS\");\n\n      char[] ksPasswdCA = ksPasswd.toCharArray();\n      char[] keyPasswdCA = keyPasswd.toCharArray();\n\n      // Create a new KeyStore by passing null.\n      ks.load(null, ksPasswdCA);\n\n      KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(keyPasswdCA);\n\n      KeyStore.SecretKeyEntry skEntry = new KeyStore.SecretKeyEntry(secretKey);\n      ks.setEntry(keyAlias, skEntry, protParam);\n\n      // Save the KeyStore\n      ks.store(os, ksPasswdCA);\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.saveToKeystore() Exception: \" + ex.getMessage()), ex);\n    }\n  }", "language": "java", "code": "public void saveToKeystore(final OutputStream os, final String ksPasswd, final String keyAlias, final String keyPasswd) {\n    if (os == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToKeystore() OutputStream is null\");\n    if (ksPasswd == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToKeystore() Keystore Password is required\");\n    if (keyAlias == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToKeystore() Key Alias is required\");\n    if (keyPasswd == null)\n      throw new OSecurityException(\"OSymmetricKey.saveToKeystore() Key Password is required\");\n\n    try {\n      KeyStore ks = KeyStore.getInstance(\"JCEKS\");\n\n      char[] ksPasswdCA = ksPasswd.toCharArray();\n      char[] keyPasswdCA = keyPasswd.toCharArray();\n\n      // Create a new KeyStore by passing null.\n      ks.load(null, ksPasswdCA);\n\n      KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(keyPasswdCA);\n\n      KeyStore.SecretKeyEntry skEntry = new KeyStore.SecretKeyEntry(secretKey);\n      ks.setEntry(keyAlias, skEntry, protParam);\n\n      // Save the KeyStore\n      ks.store(os, ksPasswdCA);\n    } catch (Exception ex) {\n      throw OException.wrapException(new OSecurityException(\"OSymmetricKey.saveToKeystore() Exception: \" + ex.getMessage()), ex);\n    }\n  }", "code_tokens": ["public", "void", "saveToKeystore", "(", "final", "OutputStream", "os", ",", "final", "String", "ksPasswd", ",", "final", "String", "keyAlias", ",", "final", "String", "keyPasswd", ")", "{", "if", "(", "os", "==", "null", ")", "throw", "new", "OSecurityException", "(", "\"OSymmetricKey.saveToKeystore() OutputStream is null\"", ")", ";", "if", "(", "ksPasswd", "==", "null", ")", "throw", "new", "OSecurityException", "(", "\"OSymmetricKey.saveToKeystore() Keystore Password is required\"", ")", ";", "if", "(", "keyAlias", "==", "null", ")", "throw", "new", "OSecurityException", "(", "\"OSymmetricKey.saveToKeystore() Key Alias is required\"", ")", ";", "if", "(", "keyPasswd", "==", "null", ")", "throw", "new", "OSecurityException", "(", "\"OSymmetricKey.saveToKeystore() Key Password is required\"", ")", ";", "try", "{", "KeyStore", "ks", "=", "KeyStore", ".", "getInstance", "(", "\"JCEKS\"", ")", ";", "char", "[", "]", "ksPasswdCA", "=", "ksPasswd", ".", "toCharArray", "(", ")", ";", "char", "[", "]", "keyPasswdCA", "=", "keyPasswd", ".", "toCharArray", "(", ")", ";", "// Create a new KeyStore by passing null.", "ks", ".", "load", "(", "null", ",", "ksPasswdCA", ")", ";", "KeyStore", ".", "ProtectionParameter", "protParam", "=", "new", "KeyStore", ".", "PasswordProtection", "(", "keyPasswdCA", ")", ";", "KeyStore", ".", "SecretKeyEntry", "skEntry", "=", "new", "KeyStore", ".", "SecretKeyEntry", "(", "secretKey", ")", ";", "ks", ".", "setEntry", "(", "keyAlias", ",", "skEntry", ",", "protParam", ")", ";", "// Save the KeyStore", "ks", ".", "store", "(", "os", ",", "ksPasswdCA", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OSecurityException", "(", "\"OSymmetricKey.saveToKeystore() Exception: \"", "+", "ex", ".", "getMessage", "(", ")", ")", ",", "ex", ")", ";", "}", "}"], "docstring": "Saves the internal SecretKey as a KeyStore.", "docstring_tokens": ["Saves", "the", "internal", "SecretKey", "as", "a", "KeyStore", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java#L615-L644", "partition": "test", "index": 3190, "time": "2016-12-16 15:58:02"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java", "func_name": "OSymmetricKey.separateAlgorithm", "original_string": "protected static String separateAlgorithm(final String cipherTransform) {\n    String[] array = cipherTransform.split(\"/\");\n\n    if (array.length > 1)\n      return array[0];\n\n    return null;\n  }", "language": "java", "code": "protected static String separateAlgorithm(final String cipherTransform) {\n    String[] array = cipherTransform.split(\"/\");\n\n    if (array.length > 1)\n      return array[0];\n\n    return null;\n  }", "code_tokens": ["protected", "static", "String", "separateAlgorithm", "(", "final", "String", "cipherTransform", ")", "{", "String", "[", "]", "array", "=", "cipherTransform", ".", "split", "(", "\"/\"", ")", ";", "if", "(", "array", ".", "length", ">", "1", ")", "return", "array", "[", "0", "]", ";", "return", "null", ";", "}"], "docstring": "Returns the secret key algorithm portion of the cipher transformation.", "docstring_tokens": ["Returns", "the", "secret", "key", "algorithm", "portion", "of", "the", "cipher", "transformation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/security/symmetrickey/OSymmetricKey.java#L210-L217", "partition": "test", "index": 3184, "time": "2016-12-16 15:58:02"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java", "func_name": "OObjectDatabaseTx.command", "original_string": "public <RET extends OCommandRequest> RET command(final OCommandRequest iCommand) {\r\n    return (RET) new OCommandSQLPojoWrapper(this, underlying.command(iCommand));\r\n  }", "language": "java", "code": "public <RET extends OCommandRequest> RET command(final OCommandRequest iCommand) {\r\n    return (RET) new OCommandSQLPojoWrapper(this, underlying.command(iCommand));\r\n  }", "code_tokens": ["public", "<", "RET", "extends", "OCommandRequest", ">", "RET", "command", "(", "final", "OCommandRequest", "iCommand", ")", "{", "return", "(", "RET", ")", "new", "OCommandSQLPojoWrapper", "(", "this", ",", "underlying", ".", "command", "(", "iCommand", ")", ")", ";", "}"], "docstring": "Returns a wrapped OCommandRequest instance to catch the result-set by converting it before to return to the user application.", "docstring_tokens": ["Returns", "a", "wrapped", "OCommandRequest", "instance", "to", "catch", "the", "result", "-", "set", "by", "converting", "it", "before", "to", "return", "to", "the", "user", "application", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java#L984-L986", "partition": "test", "index": 3141, "time": "2017-01-04 13:15:05"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java", "func_name": "OObjectDatabaseTx.setDirty", "original_string": "public void setDirty(final Object iPojo) {\r\n    if (iPojo == null)\r\n      return;\r\n\r\n    final ODocument record = getRecordByUserObject(iPojo, false);\r\n    if (record == null)\r\n      throw new OObjectNotManagedException(\"The object \" + iPojo + \" is not managed by current database\");\r\n\r\n    record.setDirty();\r\n  }", "language": "java", "code": "public void setDirty(final Object iPojo) {\r\n    if (iPojo == null)\r\n      return;\r\n\r\n    final ODocument record = getRecordByUserObject(iPojo, false);\r\n    if (record == null)\r\n      throw new OObjectNotManagedException(\"The object \" + iPojo + \" is not managed by current database\");\r\n\r\n    record.setDirty();\r\n  }", "code_tokens": ["public", "void", "setDirty", "(", "final", "Object", "iPojo", ")", "{", "if", "(", "iPojo", "==", "null", ")", "return", ";", "final", "ODocument", "record", "=", "getRecordByUserObject", "(", "iPojo", ",", "false", ")", ";", "if", "(", "record", "==", "null", ")", "throw", "new", "OObjectNotManagedException", "(", "\"The object \"", "+", "iPojo", "+", "\" is not managed by current database\"", ")", ";", "record", ".", "setDirty", "(", ")", ";", "}"], "docstring": "Sets as dirty a POJO. This is useful when you change the object and need to tell to the engine to treat as dirty.\n\n@param iPojo User object", "docstring_tokens": ["Sets", "as", "dirty", "a", "POJO", ".", "This", "is", "useful", "when", "you", "change", "the", "object", "and", "need", "to", "tell", "to", "the", "engine", "to", "treat", "as", "dirty", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java#L1040-L1049", "partition": "test", "index": 3142, "time": "2017-01-04 16:26:22"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java", "func_name": "OObjectDatabaseTx.unsetDirty", "original_string": "public void unsetDirty(final Object iPojo) {\r\n    if (iPojo == null)\r\n      return;\r\n\r\n    final ODocument record = getRecordByUserObject(iPojo, false);\r\n    if (record == null)\r\n      return;\r\n\r\n    ORecordInternal.unsetDirty(record);\r\n  }", "language": "java", "code": "public void unsetDirty(final Object iPojo) {\r\n    if (iPojo == null)\r\n      return;\r\n\r\n    final ODocument record = getRecordByUserObject(iPojo, false);\r\n    if (record == null)\r\n      return;\r\n\r\n    ORecordInternal.unsetDirty(record);\r\n  }", "code_tokens": ["public", "void", "unsetDirty", "(", "final", "Object", "iPojo", ")", "{", "if", "(", "iPojo", "==", "null", ")", "return", ";", "final", "ODocument", "record", "=", "getRecordByUserObject", "(", "iPojo", ",", "false", ")", ";", "if", "(", "record", "==", "null", ")", "return", ";", "ORecordInternal", ".", "unsetDirty", "(", "record", ")", ";", "}"], "docstring": "Sets as not dirty a POJO. This is useful when you change some other object and need to tell to the engine to treat this one as\nnot dirty.\n\n@param iPojo User object", "docstring_tokens": ["Sets", "as", "not", "dirty", "a", "POJO", ".", "This", "is", "useful", "when", "you", "change", "some", "other", "object", "and", "need", "to", "tell", "to", "the", "engine", "to", "treat", "this", "one", "as", "not", "dirty", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/db/OObjectDatabaseTx.java#L1057-L1066", "partition": "test", "index": 3143, "time": "2017-01-04 16:26:22"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWALSegmentCache.java", "func_name": "OWALSegmentCache.writePage", "original_string": "void writePage(ByteBuffer page, long pageIndex) throws IOException {\n    synchronized (lockObject) {\n      lastAccessTime = System.nanoTime();\n\n      if (pageIndex >= firstCachedPage && pageIndex <= firstCachedPage + pageCache.size()) {\n        if (pageIndex < firstCachedPage + pageCache.size()) {\n          pageCache.set((int) (pageIndex - firstCachedPage), page);\n        } else {\n          pageCache.add(page);\n        }\n      } else if (pageCache.isEmpty()) {\n        pageCache.add(page);\n        firstCachedPage = pageIndex;\n      }\n\n      lastWrittenPage = page;\n      lastWrittenPageIndex = pageIndex;\n\n      if (pageCache.size() * OWALPage.PAGE_SIZE >= bufferSize + OWALPage.PAGE_SIZE) {\n        flushAllBufferPagesExceptLastOne();\n      }\n    }\n  }", "language": "java", "code": "void writePage(ByteBuffer page, long pageIndex) throws IOException {\n    synchronized (lockObject) {\n      lastAccessTime = System.nanoTime();\n\n      if (pageIndex >= firstCachedPage && pageIndex <= firstCachedPage + pageCache.size()) {\n        if (pageIndex < firstCachedPage + pageCache.size()) {\n          pageCache.set((int) (pageIndex - firstCachedPage), page);\n        } else {\n          pageCache.add(page);\n        }\n      } else if (pageCache.isEmpty()) {\n        pageCache.add(page);\n        firstCachedPage = pageIndex;\n      }\n\n      lastWrittenPage = page;\n      lastWrittenPageIndex = pageIndex;\n\n      if (pageCache.size() * OWALPage.PAGE_SIZE >= bufferSize + OWALPage.PAGE_SIZE) {\n        flushAllBufferPagesExceptLastOne();\n      }\n    }\n  }", "code_tokens": ["void", "writePage", "(", "ByteBuffer", "page", ",", "long", "pageIndex", ")", "throws", "IOException", "{", "synchronized", "(", "lockObject", ")", "{", "lastAccessTime", "=", "System", ".", "nanoTime", "(", ")", ";", "if", "(", "pageIndex", ">=", "firstCachedPage", "&&", "pageIndex", "<=", "firstCachedPage", "+", "pageCache", ".", "size", "(", ")", ")", "{", "if", "(", "pageIndex", "<", "firstCachedPage", "+", "pageCache", ".", "size", "(", ")", ")", "{", "pageCache", ".", "set", "(", "(", "int", ")", "(", "pageIndex", "-", "firstCachedPage", ")", ",", "page", ")", ";", "}", "else", "{", "pageCache", ".", "add", "(", "page", ")", ";", "}", "}", "else", "if", "(", "pageCache", ".", "isEmpty", "(", ")", ")", "{", "pageCache", ".", "add", "(", "page", ")", ";", "firstCachedPage", "=", "pageIndex", ";", "}", "lastWrittenPage", "=", "page", ";", "lastWrittenPageIndex", "=", "pageIndex", ";", "if", "(", "pageCache", ".", "size", "(", ")", "*", "OWALPage", ".", "PAGE_SIZE", ">=", "bufferSize", "+", "OWALPage", ".", "PAGE_SIZE", ")", "{", "flushAllBufferPagesExceptLastOne", "(", ")", ";", "}", "}", "}"], "docstring": "Writes page with given page index to the cache and eventually writes it to the file.", "docstring_tokens": ["Writes", "page", "with", "given", "page", "index", "to", "the", "cache", "and", "eventually", "writes", "it", "to", "the", "file", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWALSegmentCache.java#L104-L126", "partition": "test", "index": 3080, "time": "2017-01-06 17:37:47"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWALSegmentCache.java", "func_name": "OWALSegmentCache.open", "original_string": "public void open() throws IOException {\n    synchronized (lockObject) {\n      lastAccessTime = System.nanoTime();\n      initFile();\n\n      long pagesCount = segChannel.size() / OWALPage.PAGE_SIZE;\n\n      if (segChannel.size() % OWALPage.PAGE_SIZE > 0) {\n        OLogManager.instance().error(this, \"Last WAL page was written partially, auto fix\", null);\n\n        segChannel.truncate(OWALPage.PAGE_SIZE * pagesCount);\n      }\n\n      firstCachedPage = -1;\n      pageCache.clear();\n\n      lastWrittenPage = null;\n      lastWrittenPageIndex = -1;\n    }\n  }", "language": "java", "code": "public void open() throws IOException {\n    synchronized (lockObject) {\n      lastAccessTime = System.nanoTime();\n      initFile();\n\n      long pagesCount = segChannel.size() / OWALPage.PAGE_SIZE;\n\n      if (segChannel.size() % OWALPage.PAGE_SIZE > 0) {\n        OLogManager.instance().error(this, \"Last WAL page was written partially, auto fix\", null);\n\n        segChannel.truncate(OWALPage.PAGE_SIZE * pagesCount);\n      }\n\n      firstCachedPage = -1;\n      pageCache.clear();\n\n      lastWrittenPage = null;\n      lastWrittenPageIndex = -1;\n    }\n  }", "code_tokens": ["public", "void", "open", "(", ")", "throws", "IOException", "{", "synchronized", "(", "lockObject", ")", "{", "lastAccessTime", "=", "System", ".", "nanoTime", "(", ")", ";", "initFile", "(", ")", ";", "long", "pagesCount", "=", "segChannel", ".", "size", "(", ")", "/", "OWALPage", ".", "PAGE_SIZE", ";", "if", "(", "segChannel", ".", "size", "(", ")", "%", "OWALPage", ".", "PAGE_SIZE", ">", "0", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Last WAL page was written partially, auto fix\"", ",", "null", ")", ";", "segChannel", ".", "truncate", "(", "OWALPage", ".", "PAGE_SIZE", "*", "pagesCount", ")", ";", "}", "firstCachedPage", "=", "-", "1", ";", "pageCache", ".", "clear", "(", ")", ";", "lastWrittenPage", "=", "null", ";", "lastWrittenPageIndex", "=", "-", "1", ";", "}", "}"], "docstring": "Initializes cache and opens underlying file.", "docstring_tokens": ["Initializes", "cache", "and", "opens", "underlying", "file", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWALSegmentCache.java#L336-L355", "partition": "test", "index": 3083, "time": "2017-01-06 17:37:47"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWALSegmentCache.java", "func_name": "OWALSegmentCache.readPage", "original_string": "byte[] readPage(long pageIndex) throws IOException {\n    synchronized (lockObject) {\n      lastAccessTime = System.nanoTime();\n\n      if (pageIndex == lastWrittenPageIndex) {\n        return lastWrittenPage.array();\n      }\n\n      if (pageIndex >= firstCachedPage && pageIndex < firstCachedPage + pageCache.size()) {\n        final ByteBuffer buffer = pageCache.get((int) (pageIndex - firstCachedPage));\n        return buffer.array();\n      }\n\n      final ByteBuffer buffer = ByteBuffer.allocate(OWALPage.PAGE_SIZE).order(ByteOrder.nativeOrder());\n\n      initFile();\n      segChannel.position(pageIndex * OWALPage.PAGE_SIZE);\n      readByteBuffer(buffer, segChannel);\n\n      return buffer.array();\n    }\n  }", "language": "java", "code": "byte[] readPage(long pageIndex) throws IOException {\n    synchronized (lockObject) {\n      lastAccessTime = System.nanoTime();\n\n      if (pageIndex == lastWrittenPageIndex) {\n        return lastWrittenPage.array();\n      }\n\n      if (pageIndex >= firstCachedPage && pageIndex < firstCachedPage + pageCache.size()) {\n        final ByteBuffer buffer = pageCache.get((int) (pageIndex - firstCachedPage));\n        return buffer.array();\n      }\n\n      final ByteBuffer buffer = ByteBuffer.allocate(OWALPage.PAGE_SIZE).order(ByteOrder.nativeOrder());\n\n      initFile();\n      segChannel.position(pageIndex * OWALPage.PAGE_SIZE);\n      readByteBuffer(buffer, segChannel);\n\n      return buffer.array();\n    }\n  }", "code_tokens": ["byte", "[", "]", "readPage", "(", "long", "pageIndex", ")", "throws", "IOException", "{", "synchronized", "(", "lockObject", ")", "{", "lastAccessTime", "=", "System", ".", "nanoTime", "(", ")", ";", "if", "(", "pageIndex", "==", "lastWrittenPageIndex", ")", "{", "return", "lastWrittenPage", ".", "array", "(", ")", ";", "}", "if", "(", "pageIndex", ">=", "firstCachedPage", "&&", "pageIndex", "<", "firstCachedPage", "+", "pageCache", ".", "size", "(", ")", ")", "{", "final", "ByteBuffer", "buffer", "=", "pageCache", ".", "get", "(", "(", "int", ")", "(", "pageIndex", "-", "firstCachedPage", ")", ")", ";", "return", "buffer", ".", "array", "(", ")", ";", "}", "final", "ByteBuffer", "buffer", "=", "ByteBuffer", ".", "allocate", "(", "OWALPage", ".", "PAGE_SIZE", ")", ".", "order", "(", "ByteOrder", ".", "nativeOrder", "(", ")", ")", ";", "initFile", "(", ")", ";", "segChannel", ".", "position", "(", "pageIndex", "*", "OWALPage", ".", "PAGE_SIZE", ")", ";", "readByteBuffer", "(", "buffer", ",", "segChannel", ")", ";", "return", "buffer", ".", "array", "(", ")", ";", "}", "}"], "docstring": "Read page content with given index from cache or file.", "docstring_tokens": ["Read", "page", "content", "with", "given", "index", "from", "cache", "or", "file", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWALSegmentCache.java#L171-L192", "partition": "test", "index": 3081, "time": "2017-01-06 17:37:47"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/db/OrientDBObject.java", "func_name": "OrientDBObject.open", "original_string": "public ODatabaseObject open(String name, String user, String password) {\n    return new OObjectDatabaseTx((ODatabaseDocumentInternal) orientDB.open(name, user, password));\n  }", "language": "java", "code": "public ODatabaseObject open(String name, String user, String password) {\n    return new OObjectDatabaseTx((ODatabaseDocumentInternal) orientDB.open(name, user, password));\n  }", "code_tokens": ["public", "ODatabaseObject", "open", "(", "String", "name", ",", "String", "user", ",", "String", "password", ")", "{", "return", "new", "OObjectDatabaseTx", "(", "(", "ODatabaseDocumentInternal", ")", "orientDB", ".", "open", "(", "name", ",", "user", ",", "password", ")", ")", ";", "}"], "docstring": "Open a database specified by name using the username and password if needed\n\n@param name     of the database to open\n@param user     the username allowed to open the database\n@param password related to the specified username\n\n@return the opened database", "docstring_tokens": ["Open", "a", "database", "specified", "by", "name", "using", "the", "username", "and", "password", "if", "needed"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/db/OrientDBObject.java#L160-L162", "partition": "test", "index": 3048, "time": "2017-01-13 17:00:08"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLMoveVertex.java", "func_name": "OCommandExecutorSQLMoveVertex.execute", "original_string": "public Object execute(final Map<Object, Object> iArgs) {\n\n    ODatabaseDocumentInternal db = getDatabase();\n\n    db.begin();\n\n    if (className == null && clusterName == null)\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\n\n    OModifiableBoolean shutdownGraph = new OModifiableBoolean();\n    final boolean txAlreadyBegun = getDatabase().getTransaction().isActive();\n\n    try {\n      final Set<OIdentifiable> sourceRIDs = OSQLEngine.getInstance().parseRIDTarget(db, source, context, iArgs);\n\n      // CREATE EDGES\n      final List<ODocument> result = new ArrayList<ODocument>(sourceRIDs.size());\n\n      for (OIdentifiable from : sourceRIDs) {\n        final OVertex fromVertex = toVertex(from);\n        if (fromVertex == null)\n          continue;\n\n        final ORID oldVertex = fromVertex.getIdentity().copy();\n        final ORID newVertex = fromVertex.moveTo(className, clusterName);\n\n        final ODocument newVertexDoc = newVertex.getRecord();\n\n        if (fields != null) {\n          // EVALUATE FIELDS\n          for (final OPair<String, Object> f : fields) {\n            if (f.getValue() instanceof OSQLFunctionRuntime)\n              f.setValue(((OSQLFunctionRuntime) f.getValue()).getValue(newVertex.getRecord(), null, context));\n          }\n\n          OSQLHelper.bindParameters(newVertexDoc, fields, new OCommandParameters(iArgs), context);\n        }\n\n        if (merge != null)\n          newVertexDoc.merge(merge, true, false);\n\n        // SAVE CHANGES\n        newVertexDoc.save();\n\n        // PUT THE MOVE INTO THE RESULT\n        result\n            .add(new ODocument().setTrackingChanges(false).field(\"old\", oldVertex, OType.LINK).field(\"new\", newVertex, OType.LINK));\n\n        if (batch > 0 && result.size() % batch == 0) {\n            db.commit();\n            db.begin();\n        }\n      }\n\n        db.commit();\n\n      return result;\n    } finally {\n//      if (!txAlreadyBegun)\n//        db.commit();\n\n    }\n  }", "language": "java", "code": "public Object execute(final Map<Object, Object> iArgs) {\n\n    ODatabaseDocumentInternal db = getDatabase();\n\n    db.begin();\n\n    if (className == null && clusterName == null)\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\n\n    OModifiableBoolean shutdownGraph = new OModifiableBoolean();\n    final boolean txAlreadyBegun = getDatabase().getTransaction().isActive();\n\n    try {\n      final Set<OIdentifiable> sourceRIDs = OSQLEngine.getInstance().parseRIDTarget(db, source, context, iArgs);\n\n      // CREATE EDGES\n      final List<ODocument> result = new ArrayList<ODocument>(sourceRIDs.size());\n\n      for (OIdentifiable from : sourceRIDs) {\n        final OVertex fromVertex = toVertex(from);\n        if (fromVertex == null)\n          continue;\n\n        final ORID oldVertex = fromVertex.getIdentity().copy();\n        final ORID newVertex = fromVertex.moveTo(className, clusterName);\n\n        final ODocument newVertexDoc = newVertex.getRecord();\n\n        if (fields != null) {\n          // EVALUATE FIELDS\n          for (final OPair<String, Object> f : fields) {\n            if (f.getValue() instanceof OSQLFunctionRuntime)\n              f.setValue(((OSQLFunctionRuntime) f.getValue()).getValue(newVertex.getRecord(), null, context));\n          }\n\n          OSQLHelper.bindParameters(newVertexDoc, fields, new OCommandParameters(iArgs), context);\n        }\n\n        if (merge != null)\n          newVertexDoc.merge(merge, true, false);\n\n        // SAVE CHANGES\n        newVertexDoc.save();\n\n        // PUT THE MOVE INTO THE RESULT\n        result\n            .add(new ODocument().setTrackingChanges(false).field(\"old\", oldVertex, OType.LINK).field(\"new\", newVertex, OType.LINK));\n\n        if (batch > 0 && result.size() % batch == 0) {\n            db.commit();\n            db.begin();\n        }\n      }\n\n        db.commit();\n\n      return result;\n    } finally {\n//      if (!txAlreadyBegun)\n//        db.commit();\n\n    }\n  }", "code_tokens": ["public", "Object", "execute", "(", "final", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "ODatabaseDocumentInternal", "db", "=", "getDatabase", "(", ")", ";", "db", ".", "begin", "(", ")", ";", "if", "(", "className", "==", "null", "&&", "clusterName", "==", "null", ")", "throw", "new", "OCommandExecutionException", "(", "\"Cannot execute the command because it has not been parsed yet\"", ")", ";", "OModifiableBoolean", "shutdownGraph", "=", "new", "OModifiableBoolean", "(", ")", ";", "final", "boolean", "txAlreadyBegun", "=", "getDatabase", "(", ")", ".", "getTransaction", "(", ")", ".", "isActive", "(", ")", ";", "try", "{", "final", "Set", "<", "OIdentifiable", ">", "sourceRIDs", "=", "OSQLEngine", ".", "getInstance", "(", ")", ".", "parseRIDTarget", "(", "db", ",", "source", ",", "context", ",", "iArgs", ")", ";", "// CREATE EDGES", "final", "List", "<", "ODocument", ">", "result", "=", "new", "ArrayList", "<", "ODocument", ">", "(", "sourceRIDs", ".", "size", "(", ")", ")", ";", "for", "(", "OIdentifiable", "from", ":", "sourceRIDs", ")", "{", "final", "OVertex", "fromVertex", "=", "toVertex", "(", "from", ")", ";", "if", "(", "fromVertex", "==", "null", ")", "continue", ";", "final", "ORID", "oldVertex", "=", "fromVertex", ".", "getIdentity", "(", ")", ".", "copy", "(", ")", ";", "final", "ORID", "newVertex", "=", "fromVertex", ".", "moveTo", "(", "className", ",", "clusterName", ")", ";", "final", "ODocument", "newVertexDoc", "=", "newVertex", ".", "getRecord", "(", ")", ";", "if", "(", "fields", "!=", "null", ")", "{", "// EVALUATE FIELDS", "for", "(", "final", "OPair", "<", "String", ",", "Object", ">", "f", ":", "fields", ")", "{", "if", "(", "f", ".", "getValue", "(", ")", "instanceof", "OSQLFunctionRuntime", ")", "f", ".", "setValue", "(", "(", "(", "OSQLFunctionRuntime", ")", "f", ".", "getValue", "(", ")", ")", ".", "getValue", "(", "newVertex", ".", "getRecord", "(", ")", ",", "null", ",", "context", ")", ")", ";", "}", "OSQLHelper", ".", "bindParameters", "(", "newVertexDoc", ",", "fields", ",", "new", "OCommandParameters", "(", "iArgs", ")", ",", "context", ")", ";", "}", "if", "(", "merge", "!=", "null", ")", "newVertexDoc", ".", "merge", "(", "merge", ",", "true", ",", "false", ")", ";", "// SAVE CHANGES", "newVertexDoc", ".", "save", "(", ")", ";", "// PUT THE MOVE INTO THE RESULT", "result", ".", "add", "(", "new", "ODocument", "(", ")", ".", "setTrackingChanges", "(", "false", ")", ".", "field", "(", "\"old\"", ",", "oldVertex", ",", "OType", ".", "LINK", ")", ".", "field", "(", "\"new\"", ",", "newVertex", ",", "OType", ".", "LINK", ")", ")", ";", "if", "(", "batch", ">", "0", "&&", "result", ".", "size", "(", ")", "%", "batch", "==", "0", ")", "{", "db", ".", "commit", "(", ")", ";", "db", ".", "begin", "(", ")", ";", "}", "}", "db", ".", "commit", "(", ")", ";", "return", "result", ";", "}", "finally", "{", "//      if (!txAlreadyBegun)", "//        db.commit();", "}", "}"], "docstring": "Executes the command and return the ODocument object created.", "docstring_tokens": ["Executes", "the", "command", "and", "return", "the", "ODocument", "object", "created", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLMoveVertex.java#L122-L184", "partition": "test", "index": 2986, "time": "2017-01-18 14:46:25"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/command/script/OScriptResultSets.java", "func_name": "OScriptResultSets.singleton", "original_string": "public static OScriptResultSet singleton(Object entity, OScriptTransformer transformer) {\n    return new OScriptResultSet(Collections.singletonList(entity).iterator(), transformer);\n  }", "language": "java", "code": "public static OScriptResultSet singleton(Object entity, OScriptTransformer transformer) {\n    return new OScriptResultSet(Collections.singletonList(entity).iterator(), transformer);\n  }", "code_tokens": ["public", "static", "OScriptResultSet", "singleton", "(", "Object", "entity", ",", "OScriptTransformer", "transformer", ")", "{", "return", "new", "OScriptResultSet", "(", "Collections", ".", "singletonList", "(", "entity", ")", ".", "iterator", "(", ")", ",", "transformer", ")", ";", "}"], "docstring": "Result set with a single result;\n\n@return", "docstring_tokens": ["Result", "set", "with", "a", "single", "result", ";"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/command/script/OScriptResultSets.java#L30-L32", "partition": "test", "index": 3015, "time": "2017-01-27 18:27:29"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/util/OCollections.java", "func_name": "OCollections.indexOf", "original_string": "public static int indexOf(final Object[] array, final Comparable object) {\n    for (int i = 0; i < array.length; ++i) {\n      if (object.compareTo(array[i]) == 0)\n        // FOUND\n        return i;\n    }\n    return -1;\n  }", "language": "java", "code": "public static int indexOf(final Object[] array, final Comparable object) {\n    for (int i = 0; i < array.length; ++i) {\n      if (object.compareTo(array[i]) == 0)\n        // FOUND\n        return i;\n    }\n    return -1;\n  }", "code_tokens": ["public", "static", "int", "indexOf", "(", "final", "Object", "[", "]", "array", ",", "final", "Comparable", "object", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "array", ".", "length", ";", "++", "i", ")", "{", "if", "(", "object", ".", "compareTo", "(", "array", "[", "i", "]", ")", "==", "0", ")", "// FOUND", "return", "i", ";", "}", "return", "-", "1", ";", "}"], "docstring": "This method is used to find an item in an array.\n\n@param array  Array in which value should be found.\n@param object Object to find.\n\n@return Index of found item or <code>-1</code> otherwise.", "docstring_tokens": ["This", "method", "is", "used", "to", "find", "an", "item", "in", "an", "array", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/util/OCollections.java#L64-L71", "partition": "test", "index": 3307, "time": "2017-02-09 17:25:40"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java", "func_name": "OHazelcastPlugin.electNewLockManager", "original_string": "@Override\n  public String electNewLockManager() {\n    if (hazelcastInstance == null)\n      throw new HazelcastInstanceNotActiveException();\n\n    final ILock lock = hazelcastInstance.getLock(\"orientdb.lockManagerElection\");\n    lock.lock();\n    try {\n\n      // TRY ALL THE SERVERS IN ORDER (ALL THE SERVERS HAVE THE SAME LIST)\n      String lockManagerServer = getLockManagerRequester().getServer();\n\n      // PROTECT FROM DOUBLE LOCK MANAGER ELECTION IN CASE OF REMOVE OF LOCK MANAGER\n      if (lockManagerServer != null && getActiveServers().contains(lockManagerServer))\n        return lockManagerServer;\n\n      final String originalLockManager = lockManagerServer;\n\n      ODistributedServerLog\n          .debug(this, nodeName, originalLockManager, DIRECTION.OUT, \"lock '%s' is unreachable, electing a new lock...\",\n              originalLockManager);\n\n      int lockManagerServerId = -1;\n      if (lockManagerServer != null && registeredNodeByName.containsKey(lockManagerServer))\n        lockManagerServerId = registeredNodeByName.get(lockManagerServer);\n\n      String newServer = null;\n\n      int currIndex = lockManagerServerId;\n      for (int i = 0; i < registeredNodeById.size(); ++i) {\n        currIndex++;\n        if (currIndex >= registeredNodeById.size())\n          // RESTART FROM THE FIRST\n          currIndex = 0;\n\n        newServer = registeredNodeById.get(currIndex);\n        if (newServer == null)\n          throw new OConfigurationException(\"Found null server at index \" + currIndex + \" of server list \" + registeredNodeById);\n\n        if (newServer.equalsIgnoreCase(getLocalNodeName()) || activeNodes.containsKey(newServer)) {\n          // TODO: IMPROVE ELECTION BY CHECKING AL THE NODES AGREE ON IT\n\n          ODistributedServerLog\n              .debug(this, nodeName, newServer, DIRECTION.OUT, \"Trying to elected server '%s' as new lock (old=%s)...\", newServer,\n                  originalLockManager);\n\n          try {\n            getLockManagerRequester().setServer(newServer);\n\n            configurationMap.put(CONFIG_LOCKMANAGER, getLockManagerRequester().getServer());\n\n            ODistributedServerLog\n                .info(this, nodeName, newServer, DIRECTION.OUT, \"Elected server '%s' as new lock (old=%s)\", newServer,\n                    originalLockManager);\n\n            break;\n\n          } catch (Exception e) {\n            // NO SERVER RESPONDED, THE SERVER COULD BE ISOLATED, GO AHEAD WITH THE NEXT IN THE LIST\n            ODistributedServerLog\n                .info(this, nodeName, newServer, DIRECTION.OUT, \"Error on electing server '%s' as new lock (error: %s)\", newServer,\n                    e);\n          }\n        }\n      }\n\n      return newServer;\n\n    } finally {\n      lock.unlock();\n    }\n  }", "language": "java", "code": "@Override\n  public String electNewLockManager() {\n    if (hazelcastInstance == null)\n      throw new HazelcastInstanceNotActiveException();\n\n    final ILock lock = hazelcastInstance.getLock(\"orientdb.lockManagerElection\");\n    lock.lock();\n    try {\n\n      // TRY ALL THE SERVERS IN ORDER (ALL THE SERVERS HAVE THE SAME LIST)\n      String lockManagerServer = getLockManagerRequester().getServer();\n\n      // PROTECT FROM DOUBLE LOCK MANAGER ELECTION IN CASE OF REMOVE OF LOCK MANAGER\n      if (lockManagerServer != null && getActiveServers().contains(lockManagerServer))\n        return lockManagerServer;\n\n      final String originalLockManager = lockManagerServer;\n\n      ODistributedServerLog\n          .debug(this, nodeName, originalLockManager, DIRECTION.OUT, \"lock '%s' is unreachable, electing a new lock...\",\n              originalLockManager);\n\n      int lockManagerServerId = -1;\n      if (lockManagerServer != null && registeredNodeByName.containsKey(lockManagerServer))\n        lockManagerServerId = registeredNodeByName.get(lockManagerServer);\n\n      String newServer = null;\n\n      int currIndex = lockManagerServerId;\n      for (int i = 0; i < registeredNodeById.size(); ++i) {\n        currIndex++;\n        if (currIndex >= registeredNodeById.size())\n          // RESTART FROM THE FIRST\n          currIndex = 0;\n\n        newServer = registeredNodeById.get(currIndex);\n        if (newServer == null)\n          throw new OConfigurationException(\"Found null server at index \" + currIndex + \" of server list \" + registeredNodeById);\n\n        if (newServer.equalsIgnoreCase(getLocalNodeName()) || activeNodes.containsKey(newServer)) {\n          // TODO: IMPROVE ELECTION BY CHECKING AL THE NODES AGREE ON IT\n\n          ODistributedServerLog\n              .debug(this, nodeName, newServer, DIRECTION.OUT, \"Trying to elected server '%s' as new lock (old=%s)...\", newServer,\n                  originalLockManager);\n\n          try {\n            getLockManagerRequester().setServer(newServer);\n\n            configurationMap.put(CONFIG_LOCKMANAGER, getLockManagerRequester().getServer());\n\n            ODistributedServerLog\n                .info(this, nodeName, newServer, DIRECTION.OUT, \"Elected server '%s' as new lock (old=%s)\", newServer,\n                    originalLockManager);\n\n            break;\n\n          } catch (Exception e) {\n            // NO SERVER RESPONDED, THE SERVER COULD BE ISOLATED, GO AHEAD WITH THE NEXT IN THE LIST\n            ODistributedServerLog\n                .info(this, nodeName, newServer, DIRECTION.OUT, \"Error on electing server '%s' as new lock (error: %s)\", newServer,\n                    e);\n          }\n        }\n      }\n\n      return newServer;\n\n    } finally {\n      lock.unlock();\n    }\n  }", "code_tokens": ["@", "Override", "public", "String", "electNewLockManager", "(", ")", "{", "if", "(", "hazelcastInstance", "==", "null", ")", "throw", "new", "HazelcastInstanceNotActiveException", "(", ")", ";", "final", "ILock", "lock", "=", "hazelcastInstance", ".", "getLock", "(", "\"orientdb.lockManagerElection\"", ")", ";", "lock", ".", "lock", "(", ")", ";", "try", "{", "// TRY ALL THE SERVERS IN ORDER (ALL THE SERVERS HAVE THE SAME LIST)", "String", "lockManagerServer", "=", "getLockManagerRequester", "(", ")", ".", "getServer", "(", ")", ";", "// PROTECT FROM DOUBLE LOCK MANAGER ELECTION IN CASE OF REMOVE OF LOCK MANAGER", "if", "(", "lockManagerServer", "!=", "null", "&&", "getActiveServers", "(", ")", ".", "contains", "(", "lockManagerServer", ")", ")", "return", "lockManagerServer", ";", "final", "String", "originalLockManager", "=", "lockManagerServer", ";", "ODistributedServerLog", ".", "debug", "(", "this", ",", "nodeName", ",", "originalLockManager", ",", "DIRECTION", ".", "OUT", ",", "\"lock '%s' is unreachable, electing a new lock...\"", ",", "originalLockManager", ")", ";", "int", "lockManagerServerId", "=", "-", "1", ";", "if", "(", "lockManagerServer", "!=", "null", "&&", "registeredNodeByName", ".", "containsKey", "(", "lockManagerServer", ")", ")", "lockManagerServerId", "=", "registeredNodeByName", ".", "get", "(", "lockManagerServer", ")", ";", "String", "newServer", "=", "null", ";", "int", "currIndex", "=", "lockManagerServerId", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "registeredNodeById", ".", "size", "(", ")", ";", "++", "i", ")", "{", "currIndex", "++", ";", "if", "(", "currIndex", ">=", "registeredNodeById", ".", "size", "(", ")", ")", "// RESTART FROM THE FIRST", "currIndex", "=", "0", ";", "newServer", "=", "registeredNodeById", ".", "get", "(", "currIndex", ")", ";", "if", "(", "newServer", "==", "null", ")", "throw", "new", "OConfigurationException", "(", "\"Found null server at index \"", "+", "currIndex", "+", "\" of server list \"", "+", "registeredNodeById", ")", ";", "if", "(", "newServer", ".", "equalsIgnoreCase", "(", "getLocalNodeName", "(", ")", ")", "||", "activeNodes", ".", "containsKey", "(", "newServer", ")", ")", "{", "// TODO: IMPROVE ELECTION BY CHECKING AL THE NODES AGREE ON IT", "ODistributedServerLog", ".", "debug", "(", "this", ",", "nodeName", ",", "newServer", ",", "DIRECTION", ".", "OUT", ",", "\"Trying to elected server '%s' as new lock (old=%s)...\"", ",", "newServer", ",", "originalLockManager", ")", ";", "try", "{", "getLockManagerRequester", "(", ")", ".", "setServer", "(", "newServer", ")", ";", "configurationMap", ".", "put", "(", "CONFIG_LOCKMANAGER", ",", "getLockManagerRequester", "(", ")", ".", "getServer", "(", ")", ")", ";", "ODistributedServerLog", ".", "info", "(", "this", ",", "nodeName", ",", "newServer", ",", "DIRECTION", ".", "OUT", ",", "\"Elected server '%s' as new lock (old=%s)\"", ",", "newServer", ",", "originalLockManager", ")", ";", "break", ";", "}", "catch", "(", "Exception", "e", ")", "{", "// NO SERVER RESPONDED, THE SERVER COULD BE ISOLATED, GO AHEAD WITH THE NEXT IN THE LIST", "ODistributedServerLog", ".", "info", "(", "this", ",", "nodeName", ",", "newServer", ",", "DIRECTION", ".", "OUT", ",", "\"Error on electing server '%s' as new lock (error: %s)\"", ",", "newServer", ",", "e", ")", ";", "}", "}", "}", "return", "newServer", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Elects a new server as coordinator. The election browse the ordered server list.", "docstring_tokens": ["Elects", "a", "new", "server", "as", "coordinator", ".", "The", "election", "browse", "the", "ordered", "server", "list", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java#L1603-L1674", "partition": "test", "index": 2938, "time": "2017-02-09 17:25:40"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java", "func_name": "OHazelcastPlugin.assignLockManagerFromCluster", "original_string": "private void assignLockManagerFromCluster() {\n    String lockManagerServer = null;\n    while (lockManagerServer == null) {\n      if (activeNodes.size() == 1) {\n        // ONLY CURRENT NODE ONLINE, SET IT AS INITIAL LOCK MANAGER\n        lockManagerServer = nodeName;\n        if (configurationMap.putIfAbsent(CONFIG_LOCKMANAGER, lockManagerServer) == null)\n          break;\n      } else {\n        lockManagerServer = (String) configurationMap.get(CONFIG_LOCKMANAGER);\n\n        if (lockManagerServer != null && lockManagerServer.equals(nodeName)) {\n          // LAST LOCK MANAGER WAS CURRENT NODE? TRY TO FORCE A NEW ELECTION\n          OLogManager.instance().info(this, \"Found lock as current node, even if it was offline. Forcing a new election...\");\n          getLockManagerRequester().setServer(lockManagerServer);\n          lockManagerServer = electNewLockManager();\n          break;\n        }\n\n        if (lockManagerServer != null)\n          break;\n      }\n\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException e) {\n        break;\n      }\n    }\n\n    getLockManagerRequester().setServer(lockManagerServer);\n\n    OLogManager.instance().info(this, \"Distributed Lock Manager server is '%s'\", lockManagerServer);\n  }", "language": "java", "code": "private void assignLockManagerFromCluster() {\n    String lockManagerServer = null;\n    while (lockManagerServer == null) {\n      if (activeNodes.size() == 1) {\n        // ONLY CURRENT NODE ONLINE, SET IT AS INITIAL LOCK MANAGER\n        lockManagerServer = nodeName;\n        if (configurationMap.putIfAbsent(CONFIG_LOCKMANAGER, lockManagerServer) == null)\n          break;\n      } else {\n        lockManagerServer = (String) configurationMap.get(CONFIG_LOCKMANAGER);\n\n        if (lockManagerServer != null && lockManagerServer.equals(nodeName)) {\n          // LAST LOCK MANAGER WAS CURRENT NODE? TRY TO FORCE A NEW ELECTION\n          OLogManager.instance().info(this, \"Found lock as current node, even if it was offline. Forcing a new election...\");\n          getLockManagerRequester().setServer(lockManagerServer);\n          lockManagerServer = electNewLockManager();\n          break;\n        }\n\n        if (lockManagerServer != null)\n          break;\n      }\n\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException e) {\n        break;\n      }\n    }\n\n    getLockManagerRequester().setServer(lockManagerServer);\n\n    OLogManager.instance().info(this, \"Distributed Lock Manager server is '%s'\", lockManagerServer);\n  }", "code_tokens": ["private", "void", "assignLockManagerFromCluster", "(", ")", "{", "String", "lockManagerServer", "=", "null", ";", "while", "(", "lockManagerServer", "==", "null", ")", "{", "if", "(", "activeNodes", ".", "size", "(", ")", "==", "1", ")", "{", "// ONLY CURRENT NODE ONLINE, SET IT AS INITIAL LOCK MANAGER", "lockManagerServer", "=", "nodeName", ";", "if", "(", "configurationMap", ".", "putIfAbsent", "(", "CONFIG_LOCKMANAGER", ",", "lockManagerServer", ")", "==", "null", ")", "break", ";", "}", "else", "{", "lockManagerServer", "=", "(", "String", ")", "configurationMap", ".", "get", "(", "CONFIG_LOCKMANAGER", ")", ";", "if", "(", "lockManagerServer", "!=", "null", "&&", "lockManagerServer", ".", "equals", "(", "nodeName", ")", ")", "{", "// LAST LOCK MANAGER WAS CURRENT NODE? TRY TO FORCE A NEW ELECTION", "OLogManager", ".", "instance", "(", ")", ".", "info", "(", "this", ",", "\"Found lock as current node, even if it was offline. Forcing a new election...\"", ")", ";", "getLockManagerRequester", "(", ")", ".", "setServer", "(", "lockManagerServer", ")", ";", "lockManagerServer", "=", "electNewLockManager", "(", ")", ";", "break", ";", "}", "if", "(", "lockManagerServer", "!=", "null", ")", "break", ";", "}", "try", "{", "Thread", ".", "sleep", "(", "100", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "break", ";", "}", "}", "getLockManagerRequester", "(", ")", ".", "setServer", "(", "lockManagerServer", ")", ";", "OLogManager", ".", "instance", "(", ")", ".", "info", "(", "this", ",", "\"Distributed Lock Manager server is '%s'\"", ",", "lockManagerServer", ")", ";", "}"], "docstring": "ASSIGN THE LOCK MANAGER AT STARTUP", "docstring_tokens": ["ASSIGN", "THE", "LOCK", "MANAGER", "AT", "STARTUP"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java#L1742-L1775", "partition": "test", "index": 2939, "time": "2017-02-09 17:25:40"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getMasterServers", "original_string": "public List<String> getMasterServers() {\n    final List<String> serverList = getClusterConfiguration(null).field(SERVERS);\n    if (serverList != null) {\n      // COPY AND REMOVE ANY NEW_NODE_TAG\n      List<String> masters = new ArrayList<String>(serverList.size());\n      for (String s : serverList) {\n        if (!s.equals(NEW_NODE_TAG))\n          masters.add(s);\n      }\n\n      final ROLES defRole = getDefaultServerRole();\n\n      final ODocument servers = configuration.field(SERVERS);\n      if (servers != null) {\n        for (Iterator<String> it = masters.iterator(); it.hasNext(); ) {\n          final String server = it.next();\n          final String roleAsString = servers.field(server);\n          final ROLES role = roleAsString != null ? ROLES.valueOf(roleAsString.toUpperCase(Locale.ENGLISH)) : defRole;\n          if (role != ROLES.MASTER)\n            it.remove();\n        }\n      }\n\n      return masters;\n    }\n\n    return Collections.EMPTY_LIST;\n  }", "language": "java", "code": "public List<String> getMasterServers() {\n    final List<String> serverList = getClusterConfiguration(null).field(SERVERS);\n    if (serverList != null) {\n      // COPY AND REMOVE ANY NEW_NODE_TAG\n      List<String> masters = new ArrayList<String>(serverList.size());\n      for (String s : serverList) {\n        if (!s.equals(NEW_NODE_TAG))\n          masters.add(s);\n      }\n\n      final ROLES defRole = getDefaultServerRole();\n\n      final ODocument servers = configuration.field(SERVERS);\n      if (servers != null) {\n        for (Iterator<String> it = masters.iterator(); it.hasNext(); ) {\n          final String server = it.next();\n          final String roleAsString = servers.field(server);\n          final ROLES role = roleAsString != null ? ROLES.valueOf(roleAsString.toUpperCase(Locale.ENGLISH)) : defRole;\n          if (role != ROLES.MASTER)\n            it.remove();\n        }\n      }\n\n      return masters;\n    }\n\n    return Collections.EMPTY_LIST;\n  }", "code_tokens": ["public", "List", "<", "String", ">", "getMasterServers", "(", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "null", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", ")", "{", "// COPY AND REMOVE ANY NEW_NODE_TAG", "List", "<", "String", ">", "masters", "=", "new", "ArrayList", "<", "String", ">", "(", "serverList", ".", "size", "(", ")", ")", ";", "for", "(", "String", "s", ":", "serverList", ")", "{", "if", "(", "!", "s", ".", "equals", "(", "NEW_NODE_TAG", ")", ")", "masters", ".", "add", "(", "s", ")", ";", "}", "final", "ROLES", "defRole", "=", "getDefaultServerRole", "(", ")", ";", "final", "ODocument", "servers", "=", "configuration", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "servers", "!=", "null", ")", "{", "for", "(", "Iterator", "<", "String", ">", "it", "=", "masters", ".", "iterator", "(", ")", ";", "it", ".", "hasNext", "(", ")", ";", ")", "{", "final", "String", "server", "=", "it", ".", "next", "(", ")", ";", "final", "String", "roleAsString", "=", "servers", ".", "field", "(", "server", ")", ";", "final", "ROLES", "role", "=", "roleAsString", "!=", "null", "?", "ROLES", ".", "valueOf", "(", "roleAsString", ".", "toUpperCase", "(", "Locale", ".", "ENGLISH", ")", ")", ":", "defRole", ";", "if", "(", "role", "!=", "ROLES", ".", "MASTER", ")", "it", ".", "remove", "(", ")", ";", "}", "}", "return", "masters", ";", "}", "return", "Collections", ".", "EMPTY_LIST", ";", "}"], "docstring": "Returns an ordered list of master server. The first in the list is the first found in configuration. This is used to determine\nthe cluster leader.", "docstring_tokens": ["Returns", "an", "ordered", "list", "of", "master", "server", ".", "The", "first", "in", "the", "list", "is", "the", "first", "found", "in", "configuration", ".", "This", "is", "used", "to", "determine", "the", "cluster", "leader", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java#L367-L394", "partition": "test", "index": 3092, "time": "2017-02-09 17:25:40"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/util/OCollections.java", "func_name": "OCollections.indexOf", "original_string": "public static int indexOf(final int[] array, final int object) {\n    for (int i = 0; i < array.length; ++i) {\n      if (array[i] == object)\n        // FOUND\n        return i;\n    }\n    return -1;\n  }", "language": "java", "code": "public static int indexOf(final int[] array, final int object) {\n    for (int i = 0; i < array.length; ++i) {\n      if (array[i] == object)\n        // FOUND\n        return i;\n    }\n    return -1;\n  }", "code_tokens": ["public", "static", "int", "indexOf", "(", "final", "int", "[", "]", "array", ",", "final", "int", "object", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "array", ".", "length", ";", "++", "i", ")", "{", "if", "(", "array", "[", "i", "]", "==", "object", ")", "// FOUND", "return", "i", ";", "}", "return", "-", "1", ";", "}"], "docstring": "This method is used to find a number in an array.\n\n@param array  Array of integers in which value should be found.\n@param object number to find.\n\n@return Index of found item or <code>-1</code> otherwise.", "docstring_tokens": ["This", "method", "is", "used", "to", "find", "a", "number", "in", "an", "array", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/util/OCollections.java#L81-L88", "partition": "test", "index": 3308, "time": "2017-02-09 17:25:40"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.findBestIndexFor", "original_string": "private IndexSearchDescriptor findBestIndexFor(OCommandContext ctx, Set<OIndex<?>> indexes, OAndBlock block, OClass clazz) {\n    //get all valid index descriptors\n    List<IndexSearchDescriptor> descriptors = indexes.stream().filter(x -> x.getInternal().canBeUsedInEqualityOperators())\n        .map(index -> buildIndexSearchDescriptor(ctx, index, block, clazz)).filter(Objects::nonNull)\n        .filter(x -> x.keyCondition != null).filter(x -> x.keyCondition.getSubBlocks().size() > 0).collect(Collectors.toList());\n\n    List<IndexSearchDescriptor> fullTextIndexDescriptors = indexes.stream()\n        .filter(idx->idx.getType().equalsIgnoreCase(\"FULLTEXT\"))\n        .filter(idx->!idx.getAlgorithm().equalsIgnoreCase(\"LUCENE\"))\n        .map(idx -> buildIndexSearchDescriptorForFulltext(ctx, idx, block, clazz)).filter(Objects::nonNull)\n        .filter(x -> x.keyCondition != null).filter(x -> x.keyCondition.getSubBlocks().size() > 0).collect(Collectors.toList());\n\n    descriptors.addAll(fullTextIndexDescriptors);\n\n\n    //remove the redundant descriptors (eg. if I have one on [a] and one on [a, b], the first one is redundant, just discard it)\n    descriptors = removePrefixIndexes(descriptors);\n\n    //sort by cost\n    List<OPair<Integer, IndexSearchDescriptor>> sortedDescriptors = descriptors.stream()\n        .map(x -> (OPair<Integer, IndexSearchDescriptor>) new OPair(x.cost(ctx), x)).sorted().collect(Collectors.toList());\n\n    //get only the descriptors with the lowest cost\n    descriptors = sortedDescriptors.isEmpty() ?\n        Collections.emptyList() :\n        sortedDescriptors.stream().filter(x -> x.key.equals(sortedDescriptors.get(0).key)).map(x -> x.value)\n            .collect(Collectors.toList());\n\n    //sort remaining by the number of indexed fields\n    descriptors = descriptors.stream().sorted(Comparator.comparingInt(x -> x.keyCondition.getSubBlocks().size()))\n        .collect(Collectors.toList());\n\n    //get the one that has more indexed fields\n    return descriptors.isEmpty() ? null : descriptors.get(descriptors.size() - 1);\n  }", "language": "java", "code": "private IndexSearchDescriptor findBestIndexFor(OCommandContext ctx, Set<OIndex<?>> indexes, OAndBlock block, OClass clazz) {\n    //get all valid index descriptors\n    List<IndexSearchDescriptor> descriptors = indexes.stream().filter(x -> x.getInternal().canBeUsedInEqualityOperators())\n        .map(index -> buildIndexSearchDescriptor(ctx, index, block, clazz)).filter(Objects::nonNull)\n        .filter(x -> x.keyCondition != null).filter(x -> x.keyCondition.getSubBlocks().size() > 0).collect(Collectors.toList());\n\n    List<IndexSearchDescriptor> fullTextIndexDescriptors = indexes.stream()\n        .filter(idx->idx.getType().equalsIgnoreCase(\"FULLTEXT\"))\n        .filter(idx->!idx.getAlgorithm().equalsIgnoreCase(\"LUCENE\"))\n        .map(idx -> buildIndexSearchDescriptorForFulltext(ctx, idx, block, clazz)).filter(Objects::nonNull)\n        .filter(x -> x.keyCondition != null).filter(x -> x.keyCondition.getSubBlocks().size() > 0).collect(Collectors.toList());\n\n    descriptors.addAll(fullTextIndexDescriptors);\n\n\n    //remove the redundant descriptors (eg. if I have one on [a] and one on [a, b], the first one is redundant, just discard it)\n    descriptors = removePrefixIndexes(descriptors);\n\n    //sort by cost\n    List<OPair<Integer, IndexSearchDescriptor>> sortedDescriptors = descriptors.stream()\n        .map(x -> (OPair<Integer, IndexSearchDescriptor>) new OPair(x.cost(ctx), x)).sorted().collect(Collectors.toList());\n\n    //get only the descriptors with the lowest cost\n    descriptors = sortedDescriptors.isEmpty() ?\n        Collections.emptyList() :\n        sortedDescriptors.stream().filter(x -> x.key.equals(sortedDescriptors.get(0).key)).map(x -> x.value)\n            .collect(Collectors.toList());\n\n    //sort remaining by the number of indexed fields\n    descriptors = descriptors.stream().sorted(Comparator.comparingInt(x -> x.keyCondition.getSubBlocks().size()))\n        .collect(Collectors.toList());\n\n    //get the one that has more indexed fields\n    return descriptors.isEmpty() ? null : descriptors.get(descriptors.size() - 1);\n  }", "code_tokens": ["private", "IndexSearchDescriptor", "findBestIndexFor", "(", "OCommandContext", "ctx", ",", "Set", "<", "OIndex", "<", "?", ">", ">", "indexes", ",", "OAndBlock", "block", ",", "OClass", "clazz", ")", "{", "//get all valid index descriptors", "List", "<", "IndexSearchDescriptor", ">", "descriptors", "=", "indexes", ".", "stream", "(", ")", ".", "filter", "(", "x", "->", "x", ".", "getInternal", "(", ")", ".", "canBeUsedInEqualityOperators", "(", ")", ")", ".", "map", "(", "index", "->", "buildIndexSearchDescriptor", "(", "ctx", ",", "index", ",", "block", ",", "clazz", ")", ")", ".", "filter", "(", "Objects", "::", "nonNull", ")", ".", "filter", "(", "x", "->", "x", ".", "keyCondition", "!=", "null", ")", ".", "filter", "(", "x", "->", "x", ".", "keyCondition", ".", "getSubBlocks", "(", ")", ".", "size", "(", ")", ">", "0", ")", ".", "collect", "(", "Collectors", ".", "toList", "(", ")", ")", ";", "List", "<", "IndexSearchDescriptor", ">", "fullTextIndexDescriptors", "=", "indexes", ".", "stream", "(", ")", ".", "filter", "(", "idx", "->", "idx", ".", "getType", "(", ")", ".", "equalsIgnoreCase", "(", "\"FULLTEXT\"", ")", ")", ".", "filter", "(", "idx", "->", "!", "idx", ".", "getAlgorithm", "(", ")", ".", "equalsIgnoreCase", "(", "\"LUCENE\"", ")", ")", ".", "map", "(", "idx", "->", "buildIndexSearchDescriptorForFulltext", "(", "ctx", ",", "idx", ",", "block", ",", "clazz", ")", ")", ".", "filter", "(", "Objects", "::", "nonNull", ")", ".", "filter", "(", "x", "->", "x", ".", "keyCondition", "!=", "null", ")", ".", "filter", "(", "x", "->", "x", ".", "keyCondition", ".", "getSubBlocks", "(", ")", ".", "size", "(", ")", ">", "0", ")", ".", "collect", "(", "Collectors", ".", "toList", "(", ")", ")", ";", "descriptors", ".", "addAll", "(", "fullTextIndexDescriptors", ")", ";", "//remove the redundant descriptors (eg. if I have one on [a] and one on [a, b], the first one is redundant, just discard it)", "descriptors", "=", "removePrefixIndexes", "(", "descriptors", ")", ";", "//sort by cost", "List", "<", "OPair", "<", "Integer", ",", "IndexSearchDescriptor", ">", ">", "sortedDescriptors", "=", "descriptors", ".", "stream", "(", ")", ".", "map", "(", "x", "->", "(", "OPair", "<", "Integer", ",", "IndexSearchDescriptor", ">", ")", "new", "OPair", "(", "x", ".", "cost", "(", "ctx", ")", ",", "x", ")", ")", ".", "sorted", "(", ")", ".", "collect", "(", "Collectors", ".", "toList", "(", ")", ")", ";", "//get only the descriptors with the lowest cost", "descriptors", "=", "sortedDescriptors", ".", "isEmpty", "(", ")", "?", "Collections", ".", "emptyList", "(", ")", ":", "sortedDescriptors", ".", "stream", "(", ")", ".", "filter", "(", "x", "->", "x", ".", "key", ".", "equals", "(", "sortedDescriptors", ".", "get", "(", "0", ")", ".", "key", ")", ")", ".", "map", "(", "x", "->", "x", ".", "value", ")", ".", "collect", "(", "Collectors", ".", "toList", "(", ")", ")", ";", "//sort remaining by the number of indexed fields", "descriptors", "=", "descriptors", ".", "stream", "(", ")", ".", "sorted", "(", "Comparator", ".", "comparingInt", "(", "x", "->", "x", ".", "keyCondition", ".", "getSubBlocks", "(", ")", ".", "size", "(", ")", ")", ")", ".", "collect", "(", "Collectors", ".", "toList", "(", ")", ")", ";", "//get the one that has more indexed fields", "return", "descriptors", ".", "isEmpty", "(", ")", "?", "null", ":", "descriptors", ".", "get", "(", "descriptors", ".", "size", "(", ")", "-", "1", ")", ";", "}"], "docstring": "given a flat AND block and a set of indexes, returns the best index to be used to process it, with the complete description on\nhow to use it\n\n@param ctx\n@param indexes\n@param block\n\n@return", "docstring_tokens": ["given", "a", "flat", "AND", "block", "and", "a", "set", "of", "indexes", "returns", "the", "best", "index", "to", "be", "used", "to", "process", "it", "with", "the", "complete", "description", "on", "how", "to", "use", "it"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L2164-L2198", "partition": "test", "index": 2928, "time": "2017-03-28 12:47:39"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OMatchExecutionPlanner.java", "func_name": "OMatchExecutionPlanner.getDependencies", "original_string": "private Map<String, Set<String>> getDependencies(Pattern pattern) {\n    Map<String, Set<String>> result = new HashMap<String, Set<String>>();\n\n    for (PatternNode node : pattern.aliasToNode.values()) {\n      Set<String> currentDependencies = new HashSet<String>();\n\n      OWhereClause filter = aliasFilters.get(node.alias);\n      if (filter != null && filter.getBaseExpression() != null) {\n        List<String> involvedAliases = filter.getBaseExpression().getMatchPatternInvolvedAliases();\n        if (involvedAliases != null) {\n          currentDependencies.addAll(involvedAliases);\n        }\n      }\n\n      result.put(node.alias, currentDependencies);\n    }\n\n    return result;\n  }", "language": "java", "code": "private Map<String, Set<String>> getDependencies(Pattern pattern) {\n    Map<String, Set<String>> result = new HashMap<String, Set<String>>();\n\n    for (PatternNode node : pattern.aliasToNode.values()) {\n      Set<String> currentDependencies = new HashSet<String>();\n\n      OWhereClause filter = aliasFilters.get(node.alias);\n      if (filter != null && filter.getBaseExpression() != null) {\n        List<String> involvedAliases = filter.getBaseExpression().getMatchPatternInvolvedAliases();\n        if (involvedAliases != null) {\n          currentDependencies.addAll(involvedAliases);\n        }\n      }\n\n      result.put(node.alias, currentDependencies);\n    }\n\n    return result;\n  }", "code_tokens": ["private", "Map", "<", "String", ",", "Set", "<", "String", ">", ">", "getDependencies", "(", "Pattern", "pattern", ")", "{", "Map", "<", "String", ",", "Set", "<", "String", ">", ">", "result", "=", "new", "HashMap", "<", "String", ",", "Set", "<", "String", ">", ">", "(", ")", ";", "for", "(", "PatternNode", "node", ":", "pattern", ".", "aliasToNode", ".", "values", "(", ")", ")", "{", "Set", "<", "String", ">", "currentDependencies", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "OWhereClause", "filter", "=", "aliasFilters", ".", "get", "(", "node", ".", "alias", ")", ";", "if", "(", "filter", "!=", "null", "&&", "filter", ".", "getBaseExpression", "(", ")", "!=", "null", ")", "{", "List", "<", "String", ">", "involvedAliases", "=", "filter", ".", "getBaseExpression", "(", ")", ".", "getMatchPatternInvolvedAliases", "(", ")", ";", "if", "(", "involvedAliases", "!=", "null", ")", "{", "currentDependencies", ".", "addAll", "(", "involvedAliases", ")", ";", "}", "}", "result", ".", "put", "(", "node", ".", "alias", ",", "currentDependencies", ")", ";", "}", "return", "result", ";", "}"], "docstring": "Calculate the set of dependency aliases for each alias in the pattern.\n\n@param pattern\n\n@return map of alias to the set of aliases it depends on", "docstring_tokens": ["Calculate", "the", "set", "of", "dependency", "aliases", "for", "each", "alias", "in", "the", "pattern", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OMatchExecutionPlanner.java#L447-L465", "partition": "test", "index": 3166, "time": "2017-04-20 11:30:05"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/directmemory/OByteBufferPool.java", "func_name": "OByteBufferPool.release", "original_string": "public final void release(OPointer pointer) {\n    if (TRACK) {\n      pointerMapping.remove(pointer);\n    }\n\n    long poolSize = pointersPoolSize.incrementAndGet();\n    if (poolSize > this.poolSize) {\n      pointersPoolSize.decrementAndGet();\n      allocator.deallocate(pointer);\n    } else {\n      pointersPool.add(pointer);\n    }\n  }", "language": "java", "code": "public final void release(OPointer pointer) {\n    if (TRACK) {\n      pointerMapping.remove(pointer);\n    }\n\n    long poolSize = pointersPoolSize.incrementAndGet();\n    if (poolSize > this.poolSize) {\n      pointersPoolSize.decrementAndGet();\n      allocator.deallocate(pointer);\n    } else {\n      pointersPool.add(pointer);\n    }\n  }", "code_tokens": ["public", "final", "void", "release", "(", "OPointer", "pointer", ")", "{", "if", "(", "TRACK", ")", "{", "pointerMapping", ".", "remove", "(", "pointer", ")", ";", "}", "long", "poolSize", "=", "pointersPoolSize", ".", "incrementAndGet", "(", ")", ";", "if", "(", "poolSize", ">", "this", ".", "poolSize", ")", "{", "pointersPoolSize", ".", "decrementAndGet", "(", ")", ";", "allocator", ".", "deallocate", "(", "pointer", ")", ";", "}", "else", "{", "pointersPool", ".", "add", "(", "pointer", ")", ";", "}", "}"], "docstring": "Put buffer which is not used any more back to the pool or frees direct memory if pool is full.\n\n@param pointer Not used instance of buffer.\n\n@see OGlobalConfiguration#DIRECT_MEMORY_POOL_LIMIT", "docstring_tokens": ["Put", "buffer", "which", "is", "not", "used", "any", "more", "back", "to", "the", "pool", "or", "frees", "direct", "memory", "if", "pool", "is", "full", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/directmemory/OByteBufferPool.java#L167-L179", "partition": "test", "index": 3300, "time": "2017-04-26 14:43:47"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODatabaseDocumentDistributed.java", "func_name": "ODatabaseDocumentDistributed.getActiveDataCenterMap", "original_string": "public Map<String, Set<String>> getActiveDataCenterMap() {\n    Map<String, Set<String>> result = new HashMap<>();\n    ODistributedConfiguration cfg = getDistributedConfiguration();\n    Set<String> servers = cfg.getRegisteredServers();\n    for (String server : servers) {\n      String dc = cfg.getDataCenterOfServer(server);\n      Set<String> dcConfig = result.get(dc);\n      if (dcConfig == null) {\n        dcConfig = new HashSet<>();\n        result.put(dc, dcConfig);\n      }\n      dcConfig.add(server);\n    }\n    return result;\n  }", "language": "java", "code": "public Map<String, Set<String>> getActiveDataCenterMap() {\n    Map<String, Set<String>> result = new HashMap<>();\n    ODistributedConfiguration cfg = getDistributedConfiguration();\n    Set<String> servers = cfg.getRegisteredServers();\n    for (String server : servers) {\n      String dc = cfg.getDataCenterOfServer(server);\n      Set<String> dcConfig = result.get(dc);\n      if (dcConfig == null) {\n        dcConfig = new HashSet<>();\n        result.put(dc, dcConfig);\n      }\n      dcConfig.add(server);\n    }\n    return result;\n  }", "code_tokens": ["public", "Map", "<", "String", ",", "Set", "<", "String", ">", ">", "getActiveDataCenterMap", "(", ")", "{", "Map", "<", "String", ",", "Set", "<", "String", ">", ">", "result", "=", "new", "HashMap", "<>", "(", ")", ";", "ODistributedConfiguration", "cfg", "=", "getDistributedConfiguration", "(", ")", ";", "Set", "<", "String", ">", "servers", "=", "cfg", ".", "getRegisteredServers", "(", ")", ";", "for", "(", "String", "server", ":", "servers", ")", "{", "String", "dc", "=", "cfg", ".", "getDataCenterOfServer", "(", "server", ")", ";", "Set", "<", "String", ">", "dcConfig", "=", "result", ".", "get", "(", "dc", ")", ";", "if", "(", "dcConfig", "==", "null", ")", "{", "dcConfig", "=", "new", "HashSet", "<>", "(", ")", ";", "result", ".", "put", "(", "dc", ",", "dcConfig", ")", ";", "}", "dcConfig", ".", "add", "(", "server", ")", ";", "}", "return", "result", ";", "}"], "docstring": "returns the data center map for current deploy. The keys are data center names, the values are node names per data center\n\n@return data center map for current deploy", "docstring_tokens": ["returns", "the", "data", "center", "map", "for", "current", "deploy", ".", "The", "keys", "are", "data", "center", "names", "the", "values", "are", "node", "names", "per", "data", "center"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODatabaseDocumentDistributed.java#L157-L171", "partition": "test", "index": 3183, "time": "2017-05-09 09:37:09"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OLiveQueryClientListener.java", "func_name": "OLiveQueryClientListener.onEvent", "original_string": "public boolean onEvent(OLiveQueryPushRequest pushRequest) {\n    ODatabaseDocumentInternal old = ODatabaseRecordThreadLocal.instance().getIfDefined();\n    try {\n      database.activateOnCurrentThread();\n      if (pushRequest.getStatus() == OLiveQueryPushRequest.ERROR) {\n        onError(pushRequest.getErrorCode().newException(pushRequest.getErrorMessage(), null));\n        return true;\n      } else {\n        for (OLiveQueryResult result : pushRequest.getEvents()) {\n          switch (result.getEventType()) {\n          case OLiveQueryResult.CREATE_EVENT:\n            listener.onCreate(database, result.getCurrentValue());\n            break;\n          case OLiveQueryResult.UPDATE_EVENT:\n            listener.onUpdate(database, result.getOldValue(), result.getCurrentValue());\n            break;\n          case OLiveQueryResult.DELETE_EVENT:\n            listener.onDelete(database, result.getCurrentValue());\n            break;\n          }\n        }\n        if (pushRequest.getStatus() == OLiveQueryPushRequest.END) {\n          onEnd();\n          return true;\n        }\n      }\n      return false;\n    } finally {\n      ODatabaseRecordThreadLocal.instance().set(old);\n    }\n  }", "language": "java", "code": "public boolean onEvent(OLiveQueryPushRequest pushRequest) {\n    ODatabaseDocumentInternal old = ODatabaseRecordThreadLocal.instance().getIfDefined();\n    try {\n      database.activateOnCurrentThread();\n      if (pushRequest.getStatus() == OLiveQueryPushRequest.ERROR) {\n        onError(pushRequest.getErrorCode().newException(pushRequest.getErrorMessage(), null));\n        return true;\n      } else {\n        for (OLiveQueryResult result : pushRequest.getEvents()) {\n          switch (result.getEventType()) {\n          case OLiveQueryResult.CREATE_EVENT:\n            listener.onCreate(database, result.getCurrentValue());\n            break;\n          case OLiveQueryResult.UPDATE_EVENT:\n            listener.onUpdate(database, result.getOldValue(), result.getCurrentValue());\n            break;\n          case OLiveQueryResult.DELETE_EVENT:\n            listener.onDelete(database, result.getCurrentValue());\n            break;\n          }\n        }\n        if (pushRequest.getStatus() == OLiveQueryPushRequest.END) {\n          onEnd();\n          return true;\n        }\n      }\n      return false;\n    } finally {\n      ODatabaseRecordThreadLocal.instance().set(old);\n    }\n  }", "code_tokens": ["public", "boolean", "onEvent", "(", "OLiveQueryPushRequest", "pushRequest", ")", "{", "ODatabaseDocumentInternal", "old", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "getIfDefined", "(", ")", ";", "try", "{", "database", ".", "activateOnCurrentThread", "(", ")", ";", "if", "(", "pushRequest", ".", "getStatus", "(", ")", "==", "OLiveQueryPushRequest", ".", "ERROR", ")", "{", "onError", "(", "pushRequest", ".", "getErrorCode", "(", ")", ".", "newException", "(", "pushRequest", ".", "getErrorMessage", "(", ")", ",", "null", ")", ")", ";", "return", "true", ";", "}", "else", "{", "for", "(", "OLiveQueryResult", "result", ":", "pushRequest", ".", "getEvents", "(", ")", ")", "{", "switch", "(", "result", ".", "getEventType", "(", ")", ")", "{", "case", "OLiveQueryResult", ".", "CREATE_EVENT", ":", "listener", ".", "onCreate", "(", "database", ",", "result", ".", "getCurrentValue", "(", ")", ")", ";", "break", ";", "case", "OLiveQueryResult", ".", "UPDATE_EVENT", ":", "listener", ".", "onUpdate", "(", "database", ",", "result", ".", "getOldValue", "(", ")", ",", "result", ".", "getCurrentValue", "(", ")", ")", ";", "break", ";", "case", "OLiveQueryResult", ".", "DELETE_EVENT", ":", "listener", ".", "onDelete", "(", "database", ",", "result", ".", "getCurrentValue", "(", ")", ")", ";", "break", ";", "}", "}", "if", "(", "pushRequest", ".", "getStatus", "(", ")", "==", "OLiveQueryPushRequest", ".", "END", ")", "{", "onEnd", "(", ")", ";", "return", "true", ";", "}", "}", "return", "false", ";", "}", "finally", "{", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "set", "(", "old", ")", ";", "}", "}"], "docstring": "Return true if the push request require an unregister\n\n@param pushRequest\n\n@return", "docstring_tokens": ["Return", "true", "if", "the", "push", "request", "require", "an", "unregister"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OLiveQueryClientListener.java#L31-L61", "partition": "test", "index": 3258, "time": "2017-05-28 01:57:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.getMinimalSetOfNodesForShardedQuery", "original_string": "private Map<String, Set<String>> getMinimalSetOfNodesForShardedQuery(String localNode, Map<String, Set<String>> clusterMap,\n      Set<String> queryClusters) {\n    //approximate algorithm, the problem is NP-complete\n    Map<String, Set<String>> result = new LinkedHashMap<>();\n    Set<String> uncovered = new HashSet<>();\n    uncovered.addAll(queryClusters);\n    uncovered = uncovered.stream().filter(x -> x != null).map(x -> x.toLowerCase(Locale.ENGLISH)).collect(Collectors.toSet());\n\n    //try local node first\n    Set<String> nextNodeClusters = new HashSet<>();\n    Set<String> clustersForNode = clusterMap.get(localNode);\n    if (clustersForNode != null) {\n      nextNodeClusters.addAll(clustersForNode);\n    }\n    nextNodeClusters.retainAll(uncovered);\n    if (nextNodeClusters.size() > 0) {\n      result.put(localNode, nextNodeClusters);\n      uncovered.removeAll(nextNodeClusters);\n    }\n\n    while (uncovered.size() > 0) {\n      String nextNode = findItemThatCoversMore(uncovered, clusterMap);\n      nextNodeClusters = new HashSet<>();\n      nextNodeClusters.addAll(clusterMap.get(nextNode));\n      nextNodeClusters.retainAll(uncovered);\n      if (nextNodeClusters.size() == 0) {\n        throw new OCommandExecutionException(\n            \"Cannot execute a sharded query: clusters [\" + uncovered.stream().collect(Collectors.joining(\", \"))\n                + \"] are not present on any node\" + \"\\n [\" + clusterMap.entrySet().stream()\n                .map(x -> \"\" + x.getKey() + \":(\" + x.getValue().stream().collect(Collectors.joining(\",\")) + \")\")\n                .collect(Collectors.joining(\", \")) + \"]\");\n      }\n      result.put(nextNode, nextNodeClusters);\n      uncovered.removeAll(nextNodeClusters);\n    }\n    return result;\n  }", "language": "java", "code": "private Map<String, Set<String>> getMinimalSetOfNodesForShardedQuery(String localNode, Map<String, Set<String>> clusterMap,\n      Set<String> queryClusters) {\n    //approximate algorithm, the problem is NP-complete\n    Map<String, Set<String>> result = new LinkedHashMap<>();\n    Set<String> uncovered = new HashSet<>();\n    uncovered.addAll(queryClusters);\n    uncovered = uncovered.stream().filter(x -> x != null).map(x -> x.toLowerCase(Locale.ENGLISH)).collect(Collectors.toSet());\n\n    //try local node first\n    Set<String> nextNodeClusters = new HashSet<>();\n    Set<String> clustersForNode = clusterMap.get(localNode);\n    if (clustersForNode != null) {\n      nextNodeClusters.addAll(clustersForNode);\n    }\n    nextNodeClusters.retainAll(uncovered);\n    if (nextNodeClusters.size() > 0) {\n      result.put(localNode, nextNodeClusters);\n      uncovered.removeAll(nextNodeClusters);\n    }\n\n    while (uncovered.size() > 0) {\n      String nextNode = findItemThatCoversMore(uncovered, clusterMap);\n      nextNodeClusters = new HashSet<>();\n      nextNodeClusters.addAll(clusterMap.get(nextNode));\n      nextNodeClusters.retainAll(uncovered);\n      if (nextNodeClusters.size() == 0) {\n        throw new OCommandExecutionException(\n            \"Cannot execute a sharded query: clusters [\" + uncovered.stream().collect(Collectors.joining(\", \"))\n                + \"] are not present on any node\" + \"\\n [\" + clusterMap.entrySet().stream()\n                .map(x -> \"\" + x.getKey() + \":(\" + x.getValue().stream().collect(Collectors.joining(\",\")) + \")\")\n                .collect(Collectors.joining(\", \")) + \"]\");\n      }\n      result.put(nextNode, nextNodeClusters);\n      uncovered.removeAll(nextNodeClusters);\n    }\n    return result;\n  }", "code_tokens": ["private", "Map", "<", "String", ",", "Set", "<", "String", ">", ">", "getMinimalSetOfNodesForShardedQuery", "(", "String", "localNode", ",", "Map", "<", "String", ",", "Set", "<", "String", ">", ">", "clusterMap", ",", "Set", "<", "String", ">", "queryClusters", ")", "{", "//approximate algorithm, the problem is NP-complete", "Map", "<", "String", ",", "Set", "<", "String", ">", ">", "result", "=", "new", "LinkedHashMap", "<>", "(", ")", ";", "Set", "<", "String", ">", "uncovered", "=", "new", "HashSet", "<>", "(", ")", ";", "uncovered", ".", "addAll", "(", "queryClusters", ")", ";", "uncovered", "=", "uncovered", ".", "stream", "(", ")", ".", "filter", "(", "x", "->", "x", "!=", "null", ")", ".", "map", "(", "x", "->", "x", ".", "toLowerCase", "(", "Locale", ".", "ENGLISH", ")", ")", ".", "collect", "(", "Collectors", ".", "toSet", "(", ")", ")", ";", "//try local node first", "Set", "<", "String", ">", "nextNodeClusters", "=", "new", "HashSet", "<>", "(", ")", ";", "Set", "<", "String", ">", "clustersForNode", "=", "clusterMap", ".", "get", "(", "localNode", ")", ";", "if", "(", "clustersForNode", "!=", "null", ")", "{", "nextNodeClusters", ".", "addAll", "(", "clustersForNode", ")", ";", "}", "nextNodeClusters", ".", "retainAll", "(", "uncovered", ")", ";", "if", "(", "nextNodeClusters", ".", "size", "(", ")", ">", "0", ")", "{", "result", ".", "put", "(", "localNode", ",", "nextNodeClusters", ")", ";", "uncovered", ".", "removeAll", "(", "nextNodeClusters", ")", ";", "}", "while", "(", "uncovered", ".", "size", "(", ")", ">", "0", ")", "{", "String", "nextNode", "=", "findItemThatCoversMore", "(", "uncovered", ",", "clusterMap", ")", ";", "nextNodeClusters", "=", "new", "HashSet", "<>", "(", ")", ";", "nextNodeClusters", ".", "addAll", "(", "clusterMap", ".", "get", "(", "nextNode", ")", ")", ";", "nextNodeClusters", ".", "retainAll", "(", "uncovered", ")", ";", "if", "(", "nextNodeClusters", ".", "size", "(", ")", "==", "0", ")", "{", "throw", "new", "OCommandExecutionException", "(", "\"Cannot execute a sharded query: clusters [\"", "+", "uncovered", ".", "stream", "(", ")", ".", "collect", "(", "Collectors", ".", "joining", "(", "\", \"", ")", ")", "+", "\"] are not present on any node\"", "+", "\"\\n [\"", "+", "clusterMap", ".", "entrySet", "(", ")", ".", "stream", "(", ")", ".", "map", "(", "x", "->", "\"\"", "+", "x", ".", "getKey", "(", ")", "+", "\":(\"", "+", "x", ".", "getValue", "(", ")", ".", "stream", "(", ")", ".", "collect", "(", "Collectors", ".", "joining", "(", "\",\"", ")", ")", "+", "\")\"", ")", ".", "collect", "(", "Collectors", ".", "joining", "(", "\", \"", ")", ")", "+", "\"]\"", ")", ";", "}", "result", ".", "put", "(", "nextNode", ",", "nextNodeClusters", ")", ";", "uncovered", ".", "removeAll", "(", "nextNodeClusters", ")", ";", "}", "return", "result", ";", "}"], "docstring": "given a cluster map and a set of clusters involved in a query, tries to calculate the minimum number of nodes that will have to\nbe involved in the query execution, with clusters involved for each node.\n\n@param clusterMap\n@param queryClusters\n\n@return a map that has node names as a key and clusters (data files) for each node as a value", "docstring_tokens": ["given", "a", "cluster", "map", "and", "a", "set", "of", "clusters", "involved", "in", "a", "query", "tries", "to", "calculate", "the", "minimum", "number", "of", "nodes", "that", "will", "have", "to", "be", "involved", "in", "the", "query", "execution", "with", "clusters", "involved", "for", "each", "node", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L251-L287", "partition": "test", "index": 2919, "time": "2017-06-20 14:50:07"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedMessageServiceImpl.java", "func_name": "ODistributedMessageServiceImpl.timeoutRequest", "original_string": "public void timeoutRequest(final long msgId) {\n    final ODistributedResponseManager asynchMgr = responsesByRequestIds.remove(msgId);\n    if (asynchMgr != null)\n      asynchMgr.timeout();\n  }", "language": "java", "code": "public void timeoutRequest(final long msgId) {\n    final ODistributedResponseManager asynchMgr = responsesByRequestIds.remove(msgId);\n    if (asynchMgr != null)\n      asynchMgr.timeout();\n  }", "code_tokens": ["public", "void", "timeoutRequest", "(", "final", "long", "msgId", ")", "{", "final", "ODistributedResponseManager", "asynchMgr", "=", "responsesByRequestIds", ".", "remove", "(", "msgId", ")", ";", "if", "(", "asynchMgr", "!=", "null", ")", "asynchMgr", ".", "timeout", "(", ")", ";", "}"], "docstring": "Removes a response manager because in timeout.", "docstring_tokens": ["Removes", "a", "response", "manager", "because", "in", "timeout", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/distributed/impl/ODistributedMessageServiceImpl.java#L214-L218", "partition": "test", "index": 3030, "time": "2017-06-21 11:57:44"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.isFromClusters", "original_string": "private boolean isFromClusters(ORid rid, Set<String> filterClusters, ODatabase database) {\n    if (filterClusters == null) {\n      throw new IllegalArgumentException();\n    }\n    String clusterName = database.getClusterNameById(rid.getCluster().getValue().intValue());\n    return filterClusters.contains(clusterName);\n  }", "language": "java", "code": "private boolean isFromClusters(ORid rid, Set<String> filterClusters, ODatabase database) {\n    if (filterClusters == null) {\n      throw new IllegalArgumentException();\n    }\n    String clusterName = database.getClusterNameById(rid.getCluster().getValue().intValue());\n    return filterClusters.contains(clusterName);\n  }", "code_tokens": ["private", "boolean", "isFromClusters", "(", "ORid", "rid", ",", "Set", "<", "String", ">", "filterClusters", ",", "ODatabase", "database", ")", "{", "if", "(", "filterClusters", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", ")", ";", "}", "String", "clusterName", "=", "database", ".", "getClusterNameById", "(", "rid", ".", "getCluster", "(", ")", ".", "getValue", "(", ")", ".", "intValue", "(", ")", ")", ";", "return", "filterClusters", ".", "contains", "(", "clusterName", ")", ";", "}"], "docstring": "checks if this RID is from one of these clusters\n\n@param rid\n@param filterClusters\n@param database\n\n@return", "docstring_tokens": ["checks", "if", "this", "RID", "is", "from", "one", "of", "these", "clusters"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L1283-L1289", "partition": "test", "index": 2923, "time": "2017-06-21 13:58:38"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java", "func_name": "OAbstractPaginatedStorage.rollback", "original_string": "public void rollback(final OMicroTransaction microTransaction) {\n    try {\n      checkOpenness();\n      stateLock.acquireReadLock();\n      try {\n        try {\n          checkOpenness();\n\n          if (transaction.get() == null) {\n            return;\n          }\n\n          if (transaction.get().getMicroTransaction().getId() != microTransaction.getId()) {\n            throw new OStorageException(\n                \"Passed in and active micro-transaction are different micro-transactions. Passed in micro-transaction cannot be \"\n                    + \"rolled back.\");\n          }\n\n          makeStorageDirty();\n          rollbackStorageTx();\n\n          microTransaction.updateRecordCacheAfterRollback();\n\n          txRollback.incrementAndGet();\n\n        } catch (final IOException e) {\n          throw OException.wrapException(new OStorageException(\"Error during micro-transaction rollback\"), e);\n        } finally {\n          transaction.set(null);\n        }\n      } finally {\n        stateLock.releaseReadLock();\n      }\n    } catch (final RuntimeException ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Error ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Throwable t) {\n      throw logAndPrepareForRethrow(t);\n    }\n  }", "language": "java", "code": "public void rollback(final OMicroTransaction microTransaction) {\n    try {\n      checkOpenness();\n      stateLock.acquireReadLock();\n      try {\n        try {\n          checkOpenness();\n\n          if (transaction.get() == null) {\n            return;\n          }\n\n          if (transaction.get().getMicroTransaction().getId() != microTransaction.getId()) {\n            throw new OStorageException(\n                \"Passed in and active micro-transaction are different micro-transactions. Passed in micro-transaction cannot be \"\n                    + \"rolled back.\");\n          }\n\n          makeStorageDirty();\n          rollbackStorageTx();\n\n          microTransaction.updateRecordCacheAfterRollback();\n\n          txRollback.incrementAndGet();\n\n        } catch (final IOException e) {\n          throw OException.wrapException(new OStorageException(\"Error during micro-transaction rollback\"), e);\n        } finally {\n          transaction.set(null);\n        }\n      } finally {\n        stateLock.releaseReadLock();\n      }\n    } catch (final RuntimeException ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Error ee) {\n      throw logAndPrepareForRethrow(ee);\n    } catch (final Throwable t) {\n      throw logAndPrepareForRethrow(t);\n    }\n  }", "code_tokens": ["public", "void", "rollback", "(", "final", "OMicroTransaction", "microTransaction", ")", "{", "try", "{", "checkOpenness", "(", ")", ";", "stateLock", ".", "acquireReadLock", "(", ")", ";", "try", "{", "try", "{", "checkOpenness", "(", ")", ";", "if", "(", "transaction", ".", "get", "(", ")", "==", "null", ")", "{", "return", ";", "}", "if", "(", "transaction", ".", "get", "(", ")", ".", "getMicroTransaction", "(", ")", ".", "getId", "(", ")", "!=", "microTransaction", ".", "getId", "(", ")", ")", "{", "throw", "new", "OStorageException", "(", "\"Passed in and active micro-transaction are different micro-transactions. Passed in micro-transaction cannot be \"", "+", "\"rolled back.\"", ")", ";", "}", "makeStorageDirty", "(", ")", ";", "rollbackStorageTx", "(", ")", ";", "microTransaction", ".", "updateRecordCacheAfterRollback", "(", ")", ";", "txRollback", ".", "incrementAndGet", "(", ")", ";", "}", "catch", "(", "final", "IOException", "e", ")", "{", "throw", "OException", ".", "wrapException", "(", "new", "OStorageException", "(", "\"Error during micro-transaction rollback\"", ")", ",", "e", ")", ";", "}", "finally", "{", "transaction", ".", "set", "(", "null", ")", ";", "}", "}", "finally", "{", "stateLock", ".", "releaseReadLock", "(", ")", ";", "}", "}", "catch", "(", "final", "RuntimeException", "ee", ")", "{", "throw", "logAndPrepareForRethrow", "(", "ee", ")", ";", "}", "catch", "(", "final", "Error", "ee", ")", "{", "throw", "logAndPrepareForRethrow", "(", "ee", ")", ";", "}", "catch", "(", "final", "Throwable", "t", ")", "{", "throw", "logAndPrepareForRethrow", "(", "t", ")", ";", "}", "}"], "docstring": "Rollbacks the given micro-transaction.\n\n@param microTransaction the micro-transaction to rollback.", "docstring_tokens": ["Rollbacks", "the", "given", "micro", "-", "transaction", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java#L3466-L3506", "partition": "test", "index": 3320, "time": "2017-06-22 19:44:45"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java", "func_name": "OMicroTransaction.updateRecordCacheAfterRollback", "original_string": "public void updateRecordCacheAfterRollback() {\n    final OLocalRecordCache databaseLocalCache = database.getLocalCache();\n\n    for (ORecordOperation recordOperation : recordOperations.values())\n      databaseLocalCache.deleteRecord(recordOperation.getRecord().getIdentity());\n  }", "language": "java", "code": "public void updateRecordCacheAfterRollback() {\n    final OLocalRecordCache databaseLocalCache = database.getLocalCache();\n\n    for (ORecordOperation recordOperation : recordOperations.values())\n      databaseLocalCache.deleteRecord(recordOperation.getRecord().getIdentity());\n  }", "code_tokens": ["public", "void", "updateRecordCacheAfterRollback", "(", ")", "{", "final", "OLocalRecordCache", "databaseLocalCache", "=", "database", ".", "getLocalCache", "(", ")", ";", "for", "(", "ORecordOperation", "recordOperation", ":", "recordOperations", ".", "values", "(", ")", ")", "databaseLocalCache", ".", "deleteRecord", "(", "recordOperation", ".", "getRecord", "(", ")", ".", "getIdentity", "(", ")", ")", ";", "}"], "docstring": "Updates the record cache after unsuccessful micro-transaction commit.", "docstring_tokens": ["Updates", "the", "record", "cache", "after", "unsuccessful", "micro", "-", "transaction", "commit", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java#L282-L287", "partition": "test", "index": 2943, "time": "2017-06-22 19:44:45"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java", "func_name": "OMicroTransaction.commit", "original_string": "public void commit() {\n    if (!active)\n      throw error(\"Inactive micro-transaction on commit\");\n    if (level < 1)\n      throw error(\"Unbalanced micro-transaction, level = \" + level);\n\n    --level;\n\n    if (level == 0) {\n      active = false;\n      doCommit();\n    }\n  }", "language": "java", "code": "public void commit() {\n    if (!active)\n      throw error(\"Inactive micro-transaction on commit\");\n    if (level < 1)\n      throw error(\"Unbalanced micro-transaction, level = \" + level);\n\n    --level;\n\n    if (level == 0) {\n      active = false;\n      doCommit();\n    }\n  }", "code_tokens": ["public", "void", "commit", "(", ")", "{", "if", "(", "!", "active", ")", "throw", "error", "(", "\"Inactive micro-transaction on commit\"", ")", ";", "if", "(", "level", "<", "1", ")", "throw", "error", "(", "\"Unbalanced micro-transaction, level = \"", "+", "level", ")", ";", "--", "level", ";", "if", "(", "level", "==", "0", ")", "{", "active", "=", "false", ";", "doCommit", "(", ")", ";", "}", "}"], "docstring": "Commits the micro-transaction if it's a top-level micro-transaction.", "docstring_tokens": ["Commits", "the", "micro", "-", "transaction", "if", "it", "s", "a", "top", "-", "level", "micro", "-", "transaction", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java#L158-L170", "partition": "test", "index": 2940, "time": "2017-06-22 19:44:45"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java", "func_name": "OMicroTransaction.rollback", "original_string": "public void rollback() {\n    if (!active)\n      throw error(\"Inactive micro-transaction on rollback\");\n    if (level < 1)\n      throw error(\"Unbalanced micro-transaction, level = \" + level);\n\n    --level;\n\n    if (level == 0) {\n      active = false;\n      doRollback();\n    }\n  }", "language": "java", "code": "public void rollback() {\n    if (!active)\n      throw error(\"Inactive micro-transaction on rollback\");\n    if (level < 1)\n      throw error(\"Unbalanced micro-transaction, level = \" + level);\n\n    --level;\n\n    if (level == 0) {\n      active = false;\n      doRollback();\n    }\n  }", "code_tokens": ["public", "void", "rollback", "(", ")", "{", "if", "(", "!", "active", ")", "throw", "error", "(", "\"Inactive micro-transaction on rollback\"", ")", ";", "if", "(", "level", "<", "1", ")", "throw", "error", "(", "\"Unbalanced micro-transaction, level = \"", "+", "level", ")", ";", "--", "level", ";", "if", "(", "level", "==", "0", ")", "{", "active", "=", "false", ";", "doRollback", "(", ")", ";", "}", "}"], "docstring": "Rollbacks the micro-transaction if it's a top-level micro-transaction.", "docstring_tokens": ["Rollbacks", "the", "micro", "-", "transaction", "if", "it", "s", "a", "top", "-", "level", "micro", "-", "transaction", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java#L175-L187", "partition": "test", "index": 2941, "time": "2017-06-22 19:44:45"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java", "func_name": "OMicroTransaction.updateIdentityAfterRecordCommit", "original_string": "public void updateIdentityAfterRecordCommit(final ORID oldRid, final ORID newRid) {\n    if (oldRid.equals(newRid))\n      return; // no change, ignore\n\n    // XXX: Identity update may mutate the index keys, so we have to identify and reinsert potentially affected index keys to keep\n    // the OTransactionIndexChanges.changesPerKey in a consistent state.\n\n    final List<KeyChangesUpdateRecord> keyRecordsToReinsert = new ArrayList<>();\n    final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();\n    for (Map.Entry<String, OTransactionIndexChanges> entry : indexOperations.entrySet()) {\n      final OIndex<?> index = indexManager.getIndex(entry.getKey());\n      if (index == null)\n        throw new OTransactionException(\"Cannot find index '\" + entry.getValue() + \"' while committing transaction\");\n\n      final Dependency[] fieldRidDependencies = getIndexFieldRidDependencies(index);\n      if (!isIndexMayDependOnRids(fieldRidDependencies))\n        continue;\n\n      final OTransactionIndexChanges indexChanges = entry.getValue();\n      for (final Iterator<OTransactionIndexChangesPerKey> iterator = indexChanges.changesPerKey.values().iterator(); iterator\n          .hasNext(); ) {\n        final OTransactionIndexChangesPerKey keyChanges = iterator.next();\n        if (isIndexKeyMayDependOnRid(keyChanges.key, oldRid, fieldRidDependencies)) {\n          keyRecordsToReinsert.add(new KeyChangesUpdateRecord(keyChanges, indexChanges));\n          iterator.remove();\n        }\n      }\n    }\n\n    // Update the identity.\n\n    final ORecordOperation rec = resolveRecordOperation(oldRid);\n    if (rec != null) {\n      updatedRids.put(newRid.copy(), oldRid.copy());\n\n      if (!rec.getRecord().getIdentity().equals(newRid)) {\n        ORecordInternal.onBeforeIdentityChanged(rec.getRecord());\n\n        final ORecordId recordId = (ORecordId) rec.getRecord().getIdentity();\n        if (recordId == null) {\n          ORecordInternal.setIdentity(rec.getRecord(), new ORecordId(newRid));\n        } else {\n          recordId.setClusterPosition(newRid.getClusterPosition());\n          recordId.setClusterId(newRid.getClusterId());\n        }\n\n        ORecordInternal.onAfterIdentityChanged(rec.getRecord());\n      }\n    }\n\n    // Reinsert the potentially affected index keys.\n\n    for (KeyChangesUpdateRecord record : keyRecordsToReinsert)\n      record.indexChanges.changesPerKey.put(record.keyChanges.key, record.keyChanges);\n\n    // Update the indexes.\n\n    final List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(translateRid(oldRid));\n    if (transactionIndexOperations != null) {\n      for (final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations) {\n        OTransactionIndexChanges indexEntryChanges = indexOperations.get(indexOperation.index);\n        if (indexEntryChanges == null)\n          continue;\n        final OTransactionIndexChangesPerKey keyChanges;\n        if (indexOperation.key == null) {\n          keyChanges = indexEntryChanges.nullKeyChanges;\n        } else {\n          keyChanges = indexEntryChanges.changesPerKey.get(indexOperation.key);\n        }\n        if (keyChanges != null)\n          updateChangesIdentity(oldRid, newRid, keyChanges);\n      }\n    }\n  }", "language": "java", "code": "public void updateIdentityAfterRecordCommit(final ORID oldRid, final ORID newRid) {\n    if (oldRid.equals(newRid))\n      return; // no change, ignore\n\n    // XXX: Identity update may mutate the index keys, so we have to identify and reinsert potentially affected index keys to keep\n    // the OTransactionIndexChanges.changesPerKey in a consistent state.\n\n    final List<KeyChangesUpdateRecord> keyRecordsToReinsert = new ArrayList<>();\n    final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();\n    for (Map.Entry<String, OTransactionIndexChanges> entry : indexOperations.entrySet()) {\n      final OIndex<?> index = indexManager.getIndex(entry.getKey());\n      if (index == null)\n        throw new OTransactionException(\"Cannot find index '\" + entry.getValue() + \"' while committing transaction\");\n\n      final Dependency[] fieldRidDependencies = getIndexFieldRidDependencies(index);\n      if (!isIndexMayDependOnRids(fieldRidDependencies))\n        continue;\n\n      final OTransactionIndexChanges indexChanges = entry.getValue();\n      for (final Iterator<OTransactionIndexChangesPerKey> iterator = indexChanges.changesPerKey.values().iterator(); iterator\n          .hasNext(); ) {\n        final OTransactionIndexChangesPerKey keyChanges = iterator.next();\n        if (isIndexKeyMayDependOnRid(keyChanges.key, oldRid, fieldRidDependencies)) {\n          keyRecordsToReinsert.add(new KeyChangesUpdateRecord(keyChanges, indexChanges));\n          iterator.remove();\n        }\n      }\n    }\n\n    // Update the identity.\n\n    final ORecordOperation rec = resolveRecordOperation(oldRid);\n    if (rec != null) {\n      updatedRids.put(newRid.copy(), oldRid.copy());\n\n      if (!rec.getRecord().getIdentity().equals(newRid)) {\n        ORecordInternal.onBeforeIdentityChanged(rec.getRecord());\n\n        final ORecordId recordId = (ORecordId) rec.getRecord().getIdentity();\n        if (recordId == null) {\n          ORecordInternal.setIdentity(rec.getRecord(), new ORecordId(newRid));\n        } else {\n          recordId.setClusterPosition(newRid.getClusterPosition());\n          recordId.setClusterId(newRid.getClusterId());\n        }\n\n        ORecordInternal.onAfterIdentityChanged(rec.getRecord());\n      }\n    }\n\n    // Reinsert the potentially affected index keys.\n\n    for (KeyChangesUpdateRecord record : keyRecordsToReinsert)\n      record.indexChanges.changesPerKey.put(record.keyChanges.key, record.keyChanges);\n\n    // Update the indexes.\n\n    final List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(translateRid(oldRid));\n    if (transactionIndexOperations != null) {\n      for (final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations) {\n        OTransactionIndexChanges indexEntryChanges = indexOperations.get(indexOperation.index);\n        if (indexEntryChanges == null)\n          continue;\n        final OTransactionIndexChangesPerKey keyChanges;\n        if (indexOperation.key == null) {\n          keyChanges = indexEntryChanges.nullKeyChanges;\n        } else {\n          keyChanges = indexEntryChanges.changesPerKey.get(indexOperation.key);\n        }\n        if (keyChanges != null)\n          updateChangesIdentity(oldRid, newRid, keyChanges);\n      }\n    }\n  }", "code_tokens": ["public", "void", "updateIdentityAfterRecordCommit", "(", "final", "ORID", "oldRid", ",", "final", "ORID", "newRid", ")", "{", "if", "(", "oldRid", ".", "equals", "(", "newRid", ")", ")", "return", ";", "// no change, ignore", "// XXX: Identity update may mutate the index keys, so we have to identify and reinsert potentially affected index keys to keep", "// the OTransactionIndexChanges.changesPerKey in a consistent state.", "final", "List", "<", "KeyChangesUpdateRecord", ">", "keyRecordsToReinsert", "=", "new", "ArrayList", "<>", "(", ")", ";", "final", "OIndexManager", "indexManager", "=", "getDatabase", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "OTransactionIndexChanges", ">", "entry", ":", "indexOperations", ".", "entrySet", "(", ")", ")", "{", "final", "OIndex", "<", "?", ">", "index", "=", "indexManager", ".", "getIndex", "(", "entry", ".", "getKey", "(", ")", ")", ";", "if", "(", "index", "==", "null", ")", "throw", "new", "OTransactionException", "(", "\"Cannot find index '\"", "+", "entry", ".", "getValue", "(", ")", "+", "\"' while committing transaction\"", ")", ";", "final", "Dependency", "[", "]", "fieldRidDependencies", "=", "getIndexFieldRidDependencies", "(", "index", ")", ";", "if", "(", "!", "isIndexMayDependOnRids", "(", "fieldRidDependencies", ")", ")", "continue", ";", "final", "OTransactionIndexChanges", "indexChanges", "=", "entry", ".", "getValue", "(", ")", ";", "for", "(", "final", "Iterator", "<", "OTransactionIndexChangesPerKey", ">", "iterator", "=", "indexChanges", ".", "changesPerKey", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "iterator", ".", "hasNext", "(", ")", ";", ")", "{", "final", "OTransactionIndexChangesPerKey", "keyChanges", "=", "iterator", ".", "next", "(", ")", ";", "if", "(", "isIndexKeyMayDependOnRid", "(", "keyChanges", ".", "key", ",", "oldRid", ",", "fieldRidDependencies", ")", ")", "{", "keyRecordsToReinsert", ".", "add", "(", "new", "KeyChangesUpdateRecord", "(", "keyChanges", ",", "indexChanges", ")", ")", ";", "iterator", ".", "remove", "(", ")", ";", "}", "}", "}", "// Update the identity.", "final", "ORecordOperation", "rec", "=", "resolveRecordOperation", "(", "oldRid", ")", ";", "if", "(", "rec", "!=", "null", ")", "{", "updatedRids", ".", "put", "(", "newRid", ".", "copy", "(", ")", ",", "oldRid", ".", "copy", "(", ")", ")", ";", "if", "(", "!", "rec", ".", "getRecord", "(", ")", ".", "getIdentity", "(", ")", ".", "equals", "(", "newRid", ")", ")", "{", "ORecordInternal", ".", "onBeforeIdentityChanged", "(", "rec", ".", "getRecord", "(", ")", ")", ";", "final", "ORecordId", "recordId", "=", "(", "ORecordId", ")", "rec", ".", "getRecord", "(", ")", ".", "getIdentity", "(", ")", ";", "if", "(", "recordId", "==", "null", ")", "{", "ORecordInternal", ".", "setIdentity", "(", "rec", ".", "getRecord", "(", ")", ",", "new", "ORecordId", "(", "newRid", ")", ")", ";", "}", "else", "{", "recordId", ".", "setClusterPosition", "(", "newRid", ".", "getClusterPosition", "(", ")", ")", ";", "recordId", ".", "setClusterId", "(", "newRid", ".", "getClusterId", "(", ")", ")", ";", "}", "ORecordInternal", ".", "onAfterIdentityChanged", "(", "rec", ".", "getRecord", "(", ")", ")", ";", "}", "}", "// Reinsert the potentially affected index keys.", "for", "(", "KeyChangesUpdateRecord", "record", ":", "keyRecordsToReinsert", ")", "record", ".", "indexChanges", ".", "changesPerKey", ".", "put", "(", "record", ".", "keyChanges", ".", "key", ",", "record", ".", "keyChanges", ")", ";", "// Update the indexes.", "final", "List", "<", "OTransactionRecordIndexOperation", ">", "transactionIndexOperations", "=", "recordIndexOperations", ".", "get", "(", "translateRid", "(", "oldRid", ")", ")", ";", "if", "(", "transactionIndexOperations", "!=", "null", ")", "{", "for", "(", "final", "OTransactionRecordIndexOperation", "indexOperation", ":", "transactionIndexOperations", ")", "{", "OTransactionIndexChanges", "indexEntryChanges", "=", "indexOperations", ".", "get", "(", "indexOperation", ".", "index", ")", ";", "if", "(", "indexEntryChanges", "==", "null", ")", "continue", ";", "final", "OTransactionIndexChangesPerKey", "keyChanges", ";", "if", "(", "indexOperation", ".", "key", "==", "null", ")", "{", "keyChanges", "=", "indexEntryChanges", ".", "nullKeyChanges", ";", "}", "else", "{", "keyChanges", "=", "indexEntryChanges", ".", "changesPerKey", ".", "get", "(", "indexOperation", ".", "key", ")", ";", "}", "if", "(", "keyChanges", "!=", "null", ")", "updateChangesIdentity", "(", "oldRid", ",", "newRid", ",", "keyChanges", ")", ";", "}", "}", "}"], "docstring": "Updates the record identity after its successful commit.", "docstring_tokens": ["Updates", "the", "record", "identity", "after", "its", "successful", "commit", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java#L204-L277", "partition": "test", "index": 2942, "time": "2017-06-22 19:44:45"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/io/OFileUtils.java", "func_name": "OFileUtils.prepareForFileCreationOrReplacement", "original_string": "public static void prepareForFileCreationOrReplacement(Path path, Object requester, String operation) throws IOException {\n    if (Files.deleteIfExists(path))\n      OLogManager.instance().warn(requester, \"'%s' deleted while %s\", path, operation);\n\n    final Path parent = path.getParent();\n    if (parent != null)\n      Files.createDirectories(parent);\n  }", "language": "java", "code": "public static void prepareForFileCreationOrReplacement(Path path, Object requester, String operation) throws IOException {\n    if (Files.deleteIfExists(path))\n      OLogManager.instance().warn(requester, \"'%s' deleted while %s\", path, operation);\n\n    final Path parent = path.getParent();\n    if (parent != null)\n      Files.createDirectories(parent);\n  }", "code_tokens": ["public", "static", "void", "prepareForFileCreationOrReplacement", "(", "Path", "path", ",", "Object", "requester", ",", "String", "operation", ")", "throws", "IOException", "{", "if", "(", "Files", ".", "deleteIfExists", "(", "path", ")", ")", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "requester", ",", "\"'%s' deleted while %s\"", ",", "path", ",", "operation", ")", ";", "final", "Path", "parent", "=", "path", ".", "getParent", "(", ")", ";", "if", "(", "parent", "!=", "null", ")", "Files", ".", "createDirectories", "(", "parent", ")", ";", "}"], "docstring": "Prepares the path for a file creation or replacement. If the file pointed by the path already exists, it will be deleted, a\nwarning will be emitted to the log in this case. All absent directories along the path will be created.\n\n@param path      the file path.\n@param requester the requester of an operation being performed to produce user-friendly log messages.\n@param operation the description of an operation being performed to produce user-friendly log messages. Use descriptions like\n\"exporting\", \"backing up\", etc.", "docstring_tokens": ["Prepares", "the", "path", "for", "a", "file", "creation", "or", "replacement", ".", "If", "the", "file", "pointed", "by", "the", "path", "already", "exists", "it", "will", "be", "deleted", "a", "warning", "will", "be", "emitted", "to", "the", "log", "in", "this", "case", ".", "All", "absent", "directories", "along", "the", "path", "will", "be", "created", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/io/OFileUtils.java#L245-L252", "partition": "test", "index": 2944, "time": "2017-07-28 15:48:13"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/io/OFileUtils.java", "func_name": "OFileUtils.atomicMoveWithFallback", "original_string": "public static void atomicMoveWithFallback(Path source, Path target, Object requester) throws IOException {\n    try {\n      Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n    } catch (AtomicMoveNotSupportedException ignore) {\n      OLogManager.instance()\n          .warn(requester, \"atomic file move is not possible, falling back to regular move (moving '%s' to '%s')\", source, target);\n      Files.move(source, target);\n    }\n  }", "language": "java", "code": "public static void atomicMoveWithFallback(Path source, Path target, Object requester) throws IOException {\n    try {\n      Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n    } catch (AtomicMoveNotSupportedException ignore) {\n      OLogManager.instance()\n          .warn(requester, \"atomic file move is not possible, falling back to regular move (moving '%s' to '%s')\", source, target);\n      Files.move(source, target);\n    }\n  }", "code_tokens": ["public", "static", "void", "atomicMoveWithFallback", "(", "Path", "source", ",", "Path", "target", ",", "Object", "requester", ")", "throws", "IOException", "{", "try", "{", "Files", ".", "move", "(", "source", ",", "target", ",", "StandardCopyOption", ".", "ATOMIC_MOVE", ")", ";", "}", "catch", "(", "AtomicMoveNotSupportedException", "ignore", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "requester", ",", "\"atomic file move is not possible, falling back to regular move (moving '%s' to '%s')\"", ",", "source", ",", "target", ")", ";", "Files", ".", "move", "(", "source", ",", "target", ")", ";", "}", "}"], "docstring": "Tries to move a file from the source to the target atomically. If atomic move is not possible, falls back to regular move.\n\n@param source    the source to move the file from.\n@param target    the target to move the file to.\n@param requester the requester of the move being performed to produce user-friendly log messages.\n\n@see Files#move(Path, Path, CopyOption...)\n@see StandardCopyOption#ATOMIC_MOVE", "docstring_tokens": ["Tries", "to", "move", "a", "file", "from", "the", "source", "to", "the", "target", "atomically", ".", "If", "atomic", "move", "is", "not", "possible", "falls", "back", "to", "regular", "move", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/io/OFileUtils.java#L264-L272", "partition": "test", "index": 2945, "time": "2017-08-01 13:41:30"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/record/impl/ODirtyManager.java", "func_name": "ODirtyManager.mergeSet", "original_string": "private static Set<ORecord> mergeSet(Set<ORecord> target, Set<ORecord> source) {\n    if (source != null) {\n      if (target == null) {\n        return source;\n      } else {\n        if (target.size() > source.size()) {\n          target.addAll(source);\n          return target;\n        } else {\n          source.addAll(target);\n          return source;\n        }\n      }\n    } else {\n      return target;\n    }\n  }", "language": "java", "code": "private static Set<ORecord> mergeSet(Set<ORecord> target, Set<ORecord> source) {\n    if (source != null) {\n      if (target == null) {\n        return source;\n      } else {\n        if (target.size() > source.size()) {\n          target.addAll(source);\n          return target;\n        } else {\n          source.addAll(target);\n          return source;\n        }\n      }\n    } else {\n      return target;\n    }\n  }", "code_tokens": ["private", "static", "Set", "<", "ORecord", ">", "mergeSet", "(", "Set", "<", "ORecord", ">", "target", ",", "Set", "<", "ORecord", ">", "source", ")", "{", "if", "(", "source", "!=", "null", ")", "{", "if", "(", "target", "==", "null", ")", "{", "return", "source", ";", "}", "else", "{", "if", "(", "target", ".", "size", "(", ")", ">", "source", ".", "size", "(", ")", ")", "{", "target", ".", "addAll", "(", "source", ")", ";", "return", "target", ";", "}", "else", "{", "source", ".", "addAll", "(", "target", ")", ";", "return", "source", ";", "}", "}", "}", "else", "{", "return", "target", ";", "}", "}"], "docstring": "Merge the two set try to use the optimum case\n\n@param target\n@param source\n\n@return", "docstring_tokens": ["Merge", "the", "two", "set", "try", "to", "use", "the", "optimum", "case"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/record/impl/ODirtyManager.java#L109-L125", "partition": "test", "index": 3076, "time": "2017-08-31 17:17:00"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWALSegmentCache.java", "func_name": "OWALSegmentCache.truncate", "original_string": "void truncate(long pageIndex) throws IOException {\n    synchronized (lockObject) {\n      lastAccessTime = System.nanoTime();\n\n      flushBuffer();\n\n      lastWrittenPageIndex = -1;\n      lastWrittenPage = null;\n\n      segChannel.truncate(pageIndex * OWALPage.PAGE_SIZE);\n    }\n  }", "language": "java", "code": "void truncate(long pageIndex) throws IOException {\n    synchronized (lockObject) {\n      lastAccessTime = System.nanoTime();\n\n      flushBuffer();\n\n      lastWrittenPageIndex = -1;\n      lastWrittenPage = null;\n\n      segChannel.truncate(pageIndex * OWALPage.PAGE_SIZE);\n    }\n  }", "code_tokens": ["void", "truncate", "(", "long", "pageIndex", ")", "throws", "IOException", "{", "synchronized", "(", "lockObject", ")", "{", "lastAccessTime", "=", "System", ".", "nanoTime", "(", ")", ";", "flushBuffer", "(", ")", ";", "lastWrittenPageIndex", "=", "-", "1", ";", "lastWrittenPage", "=", "null", ";", "segChannel", ".", "truncate", "(", "pageIndex", "*", "OWALPage", ".", "PAGE_SIZE", ")", ";", "}", "}"], "docstring": "Flushes all buffered pages and truncates file till passed in page index", "docstring_tokens": ["Flushes", "all", "buffered", "pages", "and", "truncates", "file", "till", "passed", "in", "page", "index"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWALSegmentCache.java#L197-L208", "partition": "test", "index": 3082, "time": "2017-09-01 16:16:26"}
{"repo": "orientechnologies/orientdb", "path": "etl/src/main/java/com/orientechnologies/orient/etl/http/OETLHandler.java", "func_name": "OETLHandler.status", "original_string": "public ODocument status() {\n\n    ODocument status = new ODocument();\n\n    Collection<ODocument> jobs = new ArrayList<ODocument>();\n    if (currentJob != null) {\n      jobs.add(currentJob.status());\n    }\n    status.field(\"jobs\", jobs);\n    return status;\n  }", "language": "java", "code": "public ODocument status() {\n\n    ODocument status = new ODocument();\n\n    Collection<ODocument> jobs = new ArrayList<ODocument>();\n    if (currentJob != null) {\n      jobs.add(currentJob.status());\n    }\n    status.field(\"jobs\", jobs);\n    return status;\n  }", "code_tokens": ["public", "ODocument", "status", "(", ")", "{", "ODocument", "status", "=", "new", "ODocument", "(", ")", ";", "Collection", "<", "ODocument", ">", "jobs", "=", "new", "ArrayList", "<", "ODocument", ">", "(", ")", ";", "if", "(", "currentJob", "!=", "null", ")", "{", "jobs", ".", "add", "(", "currentJob", ".", "status", "(", ")", ")", ";", "}", "status", ".", "field", "(", "\"jobs\"", ",", "jobs", ")", ";", "return", "status", ";", "}"], "docstring": "Status of the Running Jobs\n\n@return ODocument", "docstring_tokens": ["Status", "of", "the", "Running", "Jobs"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/etl/src/main/java/com/orientechnologies/orient/etl/http/OETLHandler.java#L58-L68", "partition": "test", "index": 3182, "time": "2017-09-07 18:12:34"}
{"repo": "orientechnologies/orientdb", "path": "etl/src/main/java/com/orientechnologies/orient/etl/http/OETLHandler.java", "func_name": "OETLHandler.executeImport", "original_string": "public void executeImport(ODocument cfg, OServer server) {\n\n    OETLJob job = new OETLJob(cfg, server, new OETLListener() {\n      @Override\n      public void onEnd(OETLJob etlJob) {\n        currentJob = null;\n      }\n    });\n\n    job.validate();\n\n    currentJob = job;\n    pool.execute(job);\n\n  }", "language": "java", "code": "public void executeImport(ODocument cfg, OServer server) {\n\n    OETLJob job = new OETLJob(cfg, server, new OETLListener() {\n      @Override\n      public void onEnd(OETLJob etlJob) {\n        currentJob = null;\n      }\n    });\n\n    job.validate();\n\n    currentJob = job;\n    pool.execute(job);\n\n  }", "code_tokens": ["public", "void", "executeImport", "(", "ODocument", "cfg", ",", "OServer", "server", ")", "{", "OETLJob", "job", "=", "new", "OETLJob", "(", "cfg", ",", "server", ",", "new", "OETLListener", "(", ")", "{", "@", "Override", "public", "void", "onEnd", "(", "OETLJob", "etlJob", ")", "{", "currentJob", "=", "null", ";", "}", "}", ")", ";", "job", ".", "validate", "(", ")", ";", "currentJob", "=", "job", ";", "pool", ".", "execute", "(", "job", ")", ";", "}"], "docstring": "Executes import with configuration;", "docstring_tokens": ["Executes", "import", "with", "configuration", ";"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/etl/src/main/java/com/orientechnologies/orient/etl/http/OETLHandler.java#L30-L44", "partition": "test", "index": 3181, "time": "2017-09-07 18:12:34"}
{"repo": "orientechnologies/orientdb", "path": "etl/src/main/java/com/orientechnologies/orient/etl/http/OETLJob.java", "func_name": "OETLJob.status", "original_string": "public ODocument status() {\n\n    synchronized (listener) {\n      ODocument status = new ODocument();\n      status.field(\"cfg\", cfg);\n      status.field(\"status\", this.status);\n\n      String lastBatchLog = \"\";\n      if (this.messageHandler != null) {\n        lastBatchLog = extractBatchLog();\n      }\n      status.field(\"log\", lastBatchLog);\n\n      if (this.status == Status.FINISHED) {\n        listener.notifyAll();\n      }\n      return status;\n    }\n\n  }", "language": "java", "code": "public ODocument status() {\n\n    synchronized (listener) {\n      ODocument status = new ODocument();\n      status.field(\"cfg\", cfg);\n      status.field(\"status\", this.status);\n\n      String lastBatchLog = \"\";\n      if (this.messageHandler != null) {\n        lastBatchLog = extractBatchLog();\n      }\n      status.field(\"log\", lastBatchLog);\n\n      if (this.status == Status.FINISHED) {\n        listener.notifyAll();\n      }\n      return status;\n    }\n\n  }", "code_tokens": ["public", "ODocument", "status", "(", ")", "{", "synchronized", "(", "listener", ")", "{", "ODocument", "status", "=", "new", "ODocument", "(", ")", ";", "status", ".", "field", "(", "\"cfg\"", ",", "cfg", ")", ";", "status", ".", "field", "(", "\"status\"", ",", "this", ".", "status", ")", ";", "String", "lastBatchLog", "=", "\"\"", ";", "if", "(", "this", ".", "messageHandler", "!=", "null", ")", "{", "lastBatchLog", "=", "extractBatchLog", "(", ")", ";", "}", "status", ".", "field", "(", "\"log\"", ",", "lastBatchLog", ")", ";", "if", "(", "this", ".", "status", "==", "Status", ".", "FINISHED", ")", "{", "listener", ".", "notifyAll", "(", ")", ";", "}", "return", "status", ";", "}", "}"], "docstring": "Single Job Status\n\n@return ODocument", "docstring_tokens": ["Single", "Job", "Status"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/etl/src/main/java/com/orientechnologies/orient/etl/http/OETLJob.java#L95-L114", "partition": "test", "index": 3316, "time": "2017-09-07 18:12:34"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java", "func_name": "ODistributedResponseManagerImpl.getBestResponsesGroup", "original_string": "protected int getBestResponsesGroup() {\n    int maxCoherentResponses = 0;\n    int bestGroupSoFar = 0;\n    for (int i = 0; i < responseGroups.size(); ++i) {\n      final int currentGroupSize = responseGroups.get(i).size();\n      if (currentGroupSize > maxCoherentResponses) {\n        maxCoherentResponses = currentGroupSize;\n        bestGroupSoFar = i;\n      }\n    }\n    return bestGroupSoFar;\n  }", "language": "java", "code": "protected int getBestResponsesGroup() {\n    int maxCoherentResponses = 0;\n    int bestGroupSoFar = 0;\n    for (int i = 0; i < responseGroups.size(); ++i) {\n      final int currentGroupSize = responseGroups.get(i).size();\n      if (currentGroupSize > maxCoherentResponses) {\n        maxCoherentResponses = currentGroupSize;\n        bestGroupSoFar = i;\n      }\n    }\n    return bestGroupSoFar;\n  }", "code_tokens": ["protected", "int", "getBestResponsesGroup", "(", ")", "{", "int", "maxCoherentResponses", "=", "0", ";", "int", "bestGroupSoFar", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "responseGroups", ".", "size", "(", ")", ";", "++", "i", ")", "{", "final", "int", "currentGroupSize", "=", "responseGroups", ".", "get", "(", "i", ")", ".", "size", "(", ")", ";", "if", "(", "currentGroupSize", ">", "maxCoherentResponses", ")", "{", "maxCoherentResponses", "=", "currentGroupSize", ";", "bestGroupSoFar", "=", "i", ";", "}", "}", "return", "bestGroupSoFar", ";", "}"], "docstring": "Returns the biggest response group.\n\n@return", "docstring_tokens": ["Returns", "the", "biggest", "response", "group", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java#L580-L591", "partition": "test", "index": 3148, "time": "2017-09-14 18:16:51"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java", "func_name": "ODistributedResponseManagerImpl.getReceivedResponses", "original_string": "protected List<ODistributedResponse> getReceivedResponses() {\n    final List<ODistributedResponse> parsed = new ArrayList<ODistributedResponse>();\n    for (Object r : responses.values())\n      if (r != NO_RESPONSE)\n        parsed.add((ODistributedResponse) r);\n    return parsed;\n  }", "language": "java", "code": "protected List<ODistributedResponse> getReceivedResponses() {\n    final List<ODistributedResponse> parsed = new ArrayList<ODistributedResponse>();\n    for (Object r : responses.values())\n      if (r != NO_RESPONSE)\n        parsed.add((ODistributedResponse) r);\n    return parsed;\n  }", "code_tokens": ["protected", "List", "<", "ODistributedResponse", ">", "getReceivedResponses", "(", ")", "{", "final", "List", "<", "ODistributedResponse", ">", "parsed", "=", "new", "ArrayList", "<", "ODistributedResponse", ">", "(", ")", ";", "for", "(", "Object", "r", ":", "responses", ".", "values", "(", ")", ")", "if", "(", "r", "!=", "NO_RESPONSE", ")", "parsed", ".", "add", "(", "(", "ODistributedResponse", ")", "r", ")", ";", "return", "parsed", ";", "}"], "docstring": "Returns the received response objects.", "docstring_tokens": ["Returns", "the", "received", "response", "objects", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java#L658-L664", "partition": "test", "index": 3150, "time": "2017-09-14 18:16:51"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java", "func_name": "ODistributedResponseManagerImpl.getMissingNodes", "original_string": "public List<String> getMissingNodes() {\n    synchronousResponsesLock.lock();\n    try {\n\n      final List<String> missingNodes = new ArrayList<String>();\n      for (Map.Entry<String, Object> entry : responses.entrySet())\n        if (entry.getValue() == NO_RESPONSE)\n          missingNodes.add(entry.getKey());\n      return missingNodes;\n\n    } finally {\n      synchronousResponsesLock.unlock();\n    }\n  }", "language": "java", "code": "public List<String> getMissingNodes() {\n    synchronousResponsesLock.lock();\n    try {\n\n      final List<String> missingNodes = new ArrayList<String>();\n      for (Map.Entry<String, Object> entry : responses.entrySet())\n        if (entry.getValue() == NO_RESPONSE)\n          missingNodes.add(entry.getKey());\n      return missingNodes;\n\n    } finally {\n      synchronousResponsesLock.unlock();\n    }\n  }", "code_tokens": ["public", "List", "<", "String", ">", "getMissingNodes", "(", ")", "{", "synchronousResponsesLock", ".", "lock", "(", ")", ";", "try", "{", "final", "List", "<", "String", ">", "missingNodes", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "entry", ":", "responses", ".", "entrySet", "(", ")", ")", "if", "(", "entry", ".", "getValue", "(", ")", "==", "NO_RESPONSE", ")", "missingNodes", ".", "add", "(", "entry", ".", "getKey", "(", ")", ")", ";", "return", "missingNodes", ";", "}", "finally", "{", "synchronousResponsesLock", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Returns the list of node names that didn't provide a response.", "docstring_tokens": ["Returns", "the", "list", "of", "node", "names", "that", "didn", "t", "provide", "a", "response", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java#L486-L499", "partition": "test", "index": 3146, "time": "2017-09-14 18:16:51"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java", "func_name": "ODistributedResponseManagerImpl.computeQuorumResponse", "original_string": "private boolean computeQuorumResponse(boolean reachedTimeout) {\n    if (quorumResponse != null)\n      // ALREADY COMPUTED\n      return true;\n\n    if (groupResponsesByResult) {\n      for (List<ODistributedResponse> group : responseGroups) {\n        if (group.size() >= quorum) {\n          int responsesForQuorum = 0;\n          for (ODistributedResponse r : group) {\n            if (nodesConcurInQuorum.contains(r.getExecutorNodeName())) {\n              final Object payload = r.getPayload();\n\n              if (payload instanceof Throwable) {\n                if (payload instanceof ODistributedRecordLockedException)\n                  // JUST ONE ODistributedRecordLockedException IS ENOUGH TO FAIL THE OPERATION BECAUSE RESOURCES CANNOT BE LOCKED\n                  break;\n                if (payload instanceof OConcurrentCreateException)\n                  // JUST ONE OConcurrentCreateException IS ENOUGH TO FAIL THE OPERATION BECAUSE RID ARE DIFFERENT\n                  break;\n              } else if (++responsesForQuorum >= quorum) {\n                // QUORUM REACHED\n                setQuorumResponse(r);\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n    } else {\n      if (receivedResponses >= quorum) {\n        int responsesForQuorum = 0;\n        for (Map.Entry<String, Object> response : responses.entrySet()) {\n          if (response.getValue() != NO_RESPONSE && nodesConcurInQuorum.contains(response.getKey())\n              && ++responsesForQuorum >= quorum) {\n            // QUORUM REACHED\n            ODistributedResponse resp = (ODistributedResponse) response.getValue();\n            if (resp != null && !(resp.getPayload() instanceof Throwable))\n              setQuorumResponse(resp);\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }", "language": "java", "code": "private boolean computeQuorumResponse(boolean reachedTimeout) {\n    if (quorumResponse != null)\n      // ALREADY COMPUTED\n      return true;\n\n    if (groupResponsesByResult) {\n      for (List<ODistributedResponse> group : responseGroups) {\n        if (group.size() >= quorum) {\n          int responsesForQuorum = 0;\n          for (ODistributedResponse r : group) {\n            if (nodesConcurInQuorum.contains(r.getExecutorNodeName())) {\n              final Object payload = r.getPayload();\n\n              if (payload instanceof Throwable) {\n                if (payload instanceof ODistributedRecordLockedException)\n                  // JUST ONE ODistributedRecordLockedException IS ENOUGH TO FAIL THE OPERATION BECAUSE RESOURCES CANNOT BE LOCKED\n                  break;\n                if (payload instanceof OConcurrentCreateException)\n                  // JUST ONE OConcurrentCreateException IS ENOUGH TO FAIL THE OPERATION BECAUSE RID ARE DIFFERENT\n                  break;\n              } else if (++responsesForQuorum >= quorum) {\n                // QUORUM REACHED\n                setQuorumResponse(r);\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n    } else {\n      if (receivedResponses >= quorum) {\n        int responsesForQuorum = 0;\n        for (Map.Entry<String, Object> response : responses.entrySet()) {\n          if (response.getValue() != NO_RESPONSE && nodesConcurInQuorum.contains(response.getKey())\n              && ++responsesForQuorum >= quorum) {\n            // QUORUM REACHED\n            ODistributedResponse resp = (ODistributedResponse) response.getValue();\n            if (resp != null && !(resp.getPayload() instanceof Throwable))\n              setQuorumResponse(resp);\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }", "code_tokens": ["private", "boolean", "computeQuorumResponse", "(", "boolean", "reachedTimeout", ")", "{", "if", "(", "quorumResponse", "!=", "null", ")", "// ALREADY COMPUTED", "return", "true", ";", "if", "(", "groupResponsesByResult", ")", "{", "for", "(", "List", "<", "ODistributedResponse", ">", "group", ":", "responseGroups", ")", "{", "if", "(", "group", ".", "size", "(", ")", ">=", "quorum", ")", "{", "int", "responsesForQuorum", "=", "0", ";", "for", "(", "ODistributedResponse", "r", ":", "group", ")", "{", "if", "(", "nodesConcurInQuorum", ".", "contains", "(", "r", ".", "getExecutorNodeName", "(", ")", ")", ")", "{", "final", "Object", "payload", "=", "r", ".", "getPayload", "(", ")", ";", "if", "(", "payload", "instanceof", "Throwable", ")", "{", "if", "(", "payload", "instanceof", "ODistributedRecordLockedException", ")", "// JUST ONE ODistributedRecordLockedException IS ENOUGH TO FAIL THE OPERATION BECAUSE RESOURCES CANNOT BE LOCKED", "break", ";", "if", "(", "payload", "instanceof", "OConcurrentCreateException", ")", "// JUST ONE OConcurrentCreateException IS ENOUGH TO FAIL THE OPERATION BECAUSE RID ARE DIFFERENT", "break", ";", "}", "else", "if", "(", "++", "responsesForQuorum", ">=", "quorum", ")", "{", "// QUORUM REACHED", "setQuorumResponse", "(", "r", ")", ";", "return", "true", ";", "}", "}", "}", "}", "}", "}", "else", "{", "if", "(", "receivedResponses", ">=", "quorum", ")", "{", "int", "responsesForQuorum", "=", "0", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "response", ":", "responses", ".", "entrySet", "(", ")", ")", "{", "if", "(", "response", ".", "getValue", "(", ")", "!=", "NO_RESPONSE", "&&", "nodesConcurInQuorum", ".", "contains", "(", "response", ".", "getKey", "(", ")", ")", "&&", "++", "responsesForQuorum", ">=", "quorum", ")", "{", "// QUORUM REACHED", "ODistributedResponse", "resp", "=", "(", "ODistributedResponse", ")", "response", ".", "getValue", "(", ")", ";", "if", "(", "resp", "!=", "null", "&&", "!", "(", "resp", ".", "getPayload", "(", ")", "instanceof", "Throwable", ")", ")", "setQuorumResponse", "(", "resp", ")", ";", "return", "true", ";", "}", "}", "}", "}", "return", "false", ";", "}"], "docstring": "Computes the quorum response if possible by returning true and setting the field quorumResponse with the ODistributedResponse.", "docstring_tokens": ["Computes", "the", "quorum", "response", "if", "possible", "by", "returning", "true", "and", "setting", "the", "field", "quorumResponse", "with", "the", "ODistributedResponse", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java#L606-L653", "partition": "test", "index": 3149, "time": "2017-09-14 18:16:51"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java", "func_name": "ODistributedResponseManagerImpl.getConflictResponses", "original_string": "protected List<ODistributedResponse> getConflictResponses() {\n    final List<ODistributedResponse> servers = new ArrayList<ODistributedResponse>();\n    int bestGroupSoFar = getBestResponsesGroup();\n    for (int i = 0; i < responseGroups.size(); ++i) {\n      if (i != bestGroupSoFar) {\n        for (ODistributedResponse r : responseGroups.get(i))\n          servers.add(r);\n      }\n    }\n    return servers;\n  }", "language": "java", "code": "protected List<ODistributedResponse> getConflictResponses() {\n    final List<ODistributedResponse> servers = new ArrayList<ODistributedResponse>();\n    int bestGroupSoFar = getBestResponsesGroup();\n    for (int i = 0; i < responseGroups.size(); ++i) {\n      if (i != bestGroupSoFar) {\n        for (ODistributedResponse r : responseGroups.get(i))\n          servers.add(r);\n      }\n    }\n    return servers;\n  }", "code_tokens": ["protected", "List", "<", "ODistributedResponse", ">", "getConflictResponses", "(", ")", "{", "final", "List", "<", "ODistributedResponse", ">", "servers", "=", "new", "ArrayList", "<", "ODistributedResponse", ">", "(", ")", ";", "int", "bestGroupSoFar", "=", "getBestResponsesGroup", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "responseGroups", ".", "size", "(", ")", ";", "++", "i", ")", "{", "if", "(", "i", "!=", "bestGroupSoFar", ")", "{", "for", "(", "ODistributedResponse", "r", ":", "responseGroups", ".", "get", "(", "i", ")", ")", "servers", ".", "(", "r", ")", ";", "}", "}", "return", "servers", ";", "}"], "docstring": "Returns all the responses in conflict.", "docstring_tokens": ["Returns", "all", "the", "responses", "in", "conflict", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedResponseManagerImpl.java#L547-L557", "partition": "test", "index": 3147, "time": "2017-09-14 18:16:51"}
{"repo": "orientechnologies/orientdb", "path": "etl/src/main/java/com/orientechnologies/orient/etl/context/OETLContext.java", "func_name": "OETLContext.printExceptionStackTrace", "original_string": "public String printExceptionStackTrace(Exception e, String level) {\n\n    // copying the exception stack trace in the string\n    Writer writer = new StringWriter();\n    e.printStackTrace(new PrintWriter(writer));\n    String s = writer.toString();\n\n    switch (level) {\n    case \"debug\":\n      this.messageHandler.debug(this, \"\\n\" + s + \"\\n\");\n      break;\n    case \"info\":\n      this.messageHandler.info(this, \"\\n\" + s + \"\\n\");\n      break;\n    case \"warn\":\n      this.messageHandler.warn(this, \"\\n\" + s + \"\\n\");\n      break;\n    case \"error\":\n      this.messageHandler.error(this, \"\\n\" + s + \"\\n\");\n      break;\n    }\n\n    return s;\n  }", "language": "java", "code": "public String printExceptionStackTrace(Exception e, String level) {\n\n    // copying the exception stack trace in the string\n    Writer writer = new StringWriter();\n    e.printStackTrace(new PrintWriter(writer));\n    String s = writer.toString();\n\n    switch (level) {\n    case \"debug\":\n      this.messageHandler.debug(this, \"\\n\" + s + \"\\n\");\n      break;\n    case \"info\":\n      this.messageHandler.info(this, \"\\n\" + s + \"\\n\");\n      break;\n    case \"warn\":\n      this.messageHandler.warn(this, \"\\n\" + s + \"\\n\");\n      break;\n    case \"error\":\n      this.messageHandler.error(this, \"\\n\" + s + \"\\n\");\n      break;\n    }\n\n    return s;\n  }", "code_tokens": ["public", "String", "printExceptionStackTrace", "(", "Exception", "e", ",", "String", "level", ")", "{", "// copying the exception stack trace in the string", "Writer", "writer", "=", "new", "StringWriter", "(", ")", ";", "e", ".", "printStackTrace", "(", "new", "PrintWriter", "(", "writer", ")", ")", ";", "String", "s", "=", "writer", ".", "toString", "(", ")", ";", "switch", "(", "level", ")", "{", "case", "\"debug\"", ":", "this", ".", "messageHandler", ".", "debug", "(", "this", ",", "\"\\n\"", "+", "s", "+", "\"\\n\"", ")", ";", "break", ";", "case", "\"info\"", ":", "this", ".", "messageHandler", ".", "info", "(", "this", ",", "\"\\n\"", "+", "s", "+", "\"\\n\"", ")", ";", "break", ";", "case", "\"warn\"", ":", "this", ".", "messageHandler", ".", "warn", "(", "this", ",", "\"\\n\"", "+", "s", "+", "\"\\n\"", ")", ";", "break", ";", "case", "\"error\"", ":", "this", ".", "messageHandler", ".", "error", "(", "this", ",", "\"\\n\"", "+", "s", "+", "\"\\n\"", ")", ";", "break", ";", "}", "return", "s", ";", "}"], "docstring": "Builds the exception stack trace and prints it according to a level passed as argument.\n\n@param e\n@param level\n\n@return printedMessage", "docstring_tokens": ["Builds", "the", "exception", "stack", "trace", "and", "prints", "it", "according", "to", "a", "level", "passed", "as", "argument", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/etl/src/main/java/com/orientechnologies/orient/etl/context/OETLContext.java#L104-L127", "partition": "test", "index": 3286, "time": "2017-09-30 13:18:37"}
{"repo": "orientechnologies/orientdb", "path": "etl/src/main/java/com/orientechnologies/orient/etl/util/OFileManager.java", "func_name": "OFileManager.buildJsonFromFile", "original_string": "public static ODocument buildJsonFromFile(String filePath) throws IOException {\n\n    if (filePath == null) {\n      return null;\n    }\n\n    File jsonFile = new File(filePath);\n    if (!jsonFile.exists()) {\n      return null;\n    }\n\n    FileInputStream is = new FileInputStream(jsonFile);\n    BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n    ODocument json = new ODocument();\n    String jsonText = OFileManager.readAllTextFile(rd);\n    json.fromJSON(jsonText, \"noMap\");\n    return json;\n\n  }", "language": "java", "code": "public static ODocument buildJsonFromFile(String filePath) throws IOException {\n\n    if (filePath == null) {\n      return null;\n    }\n\n    File jsonFile = new File(filePath);\n    if (!jsonFile.exists()) {\n      return null;\n    }\n\n    FileInputStream is = new FileInputStream(jsonFile);\n    BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n    ODocument json = new ODocument();\n    String jsonText = OFileManager.readAllTextFile(rd);\n    json.fromJSON(jsonText, \"noMap\");\n    return json;\n\n  }", "code_tokens": ["public", "static", "ODocument", "buildJsonFromFile", "(", "String", "filePath", ")", "throws", "IOException", "{", "if", "(", "filePath", "==", "null", ")", "{", "return", "null", ";", "}", "File", "jsonFile", "=", "new", "File", "(", "filePath", ")", ";", "if", "(", "!", "jsonFile", ".", "exists", "(", ")", ")", "{", "return", "null", ";", "}", "FileInputStream", "is", "=", "new", "FileInputStream", "(", "jsonFile", ")", ";", "BufferedReader", "rd", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "is", ",", "Charset", ".", "forName", "(", "\"UTF-8\"", ")", ")", ")", ";", "ODocument", "json", "=", "new", "ODocument", "(", ")", ";", "String", "jsonText", "=", "OFileManager", ".", "readAllTextFile", "(", "rd", ")", ";", "json", ".", "fromJSON", "(", "jsonText", ",", "\"noMap\"", ")", ";", "return", "json", ";", "}"], "docstring": "It returns a ODocument starting from a json file.\n\n@param filePath\n\n@return ODocument (null if the file does not exist or problem are encountered during the reading)", "docstring_tokens": ["It", "returns", "a", "ODocument", "starting", "from", "a", "json", "file", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/etl/src/main/java/com/orientechnologies/orient/etl/util/OFileManager.java#L123-L141", "partition": "test", "index": 2998, "time": "2017-09-30 13:18:37"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java", "func_name": "OAbstractPaginatedStorage.handleJVMError", "original_string": "public final void handleJVMError(final Error e) {\n    if (jvmError.compareAndSet(null, e)) {\n      OLogManager.instance().errorNoDb(this, \"JVM error was thrown\", e);\n    }\n  }", "language": "java", "code": "public final void handleJVMError(final Error e) {\n    if (jvmError.compareAndSet(null, e)) {\n      OLogManager.instance().errorNoDb(this, \"JVM error was thrown\", e);\n    }\n  }", "code_tokens": ["public", "final", "void", "handleJVMError", "(", "final", "Error", "e", ")", "{", "if", "(", "jvmError", ".", "compareAndSet", "(", "null", ",", "e", ")", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "errorNoDb", "(", "this", ",", "\"JVM error was thrown\"", ",", "e", ")", ";", "}", "}"], "docstring": "That is internal method which is called once we encounter any error inside of JVM. In such case we need to restart JVM to avoid\nany data corruption. Till JVM is not restarted storage will be put in read-only state.", "docstring_tokens": ["That", "is", "internal", "method", "which", "is", "called", "once", "we", "encounter", "any", "error", "inside", "of", "JVM", ".", "In", "such", "case", "we", "need", "to", "restart", "JVM", "to", "avoid", "any", "data", "corruption", ".", "Till", "JVM", "is", "not", "restarted", "storage", "will", "be", "put", "in", "read", "-", "only", "state", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OAbstractPaginatedStorage.java#L448-L452", "partition": "test", "index": 3318, "time": "2017-11-07 15:54:54"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/concur/lock/OReadersWriterSpinLock.java", "func_name": "OReadersWriterSpinLock.tryAcquireReadLock", "original_string": "public boolean tryAcquireReadLock(long timeout) {\n    final OModifiableInteger lHolds = lockHolds.get();\n\n    final int holds = lHolds.intValue();\n    if (holds > 0) {\n      // we have already acquire read lock\n      lHolds.increment();\n      return true;\n    } else if (holds < 0) {\n      // write lock is acquired before, do nothing\n      return true;\n    }\n\n    distributedCounter.increment();\n\n    WNode wNode = tail.get();\n\n    final long start = System.nanoTime();\n    while (wNode.locked) {\n      distributedCounter.decrement();\n\n      while (wNode.locked && wNode == tail.get()) {\n        wNode.waitingReaders.put(Thread.currentThread(), Boolean.TRUE);\n\n        if (wNode.locked && wNode == tail.get()) {\n          final long parkTimeout = timeout - (System.nanoTime() - start);\n          if (parkTimeout > 0) {\n            LockSupport.parkNanos(this, parkTimeout);\n          } else {\n            return false;\n          }\n        }\n\n        wNode = tail.get();\n\n        if (System.nanoTime() - start > timeout) {\n          return false;\n        }\n      }\n\n      distributedCounter.increment();\n\n      wNode = tail.get();\n      if (System.nanoTime() - start > timeout) {\n        distributedCounter.decrement();\n\n        return false;\n      }\n    }\n\n    lHolds.increment();\n    assert lHolds.intValue() == 1;\n\n    return true;\n  }", "language": "java", "code": "public boolean tryAcquireReadLock(long timeout) {\n    final OModifiableInteger lHolds = lockHolds.get();\n\n    final int holds = lHolds.intValue();\n    if (holds > 0) {\n      // we have already acquire read lock\n      lHolds.increment();\n      return true;\n    } else if (holds < 0) {\n      // write lock is acquired before, do nothing\n      return true;\n    }\n\n    distributedCounter.increment();\n\n    WNode wNode = tail.get();\n\n    final long start = System.nanoTime();\n    while (wNode.locked) {\n      distributedCounter.decrement();\n\n      while (wNode.locked && wNode == tail.get()) {\n        wNode.waitingReaders.put(Thread.currentThread(), Boolean.TRUE);\n\n        if (wNode.locked && wNode == tail.get()) {\n          final long parkTimeout = timeout - (System.nanoTime() - start);\n          if (parkTimeout > 0) {\n            LockSupport.parkNanos(this, parkTimeout);\n          } else {\n            return false;\n          }\n        }\n\n        wNode = tail.get();\n\n        if (System.nanoTime() - start > timeout) {\n          return false;\n        }\n      }\n\n      distributedCounter.increment();\n\n      wNode = tail.get();\n      if (System.nanoTime() - start > timeout) {\n        distributedCounter.decrement();\n\n        return false;\n      }\n    }\n\n    lHolds.increment();\n    assert lHolds.intValue() == 1;\n\n    return true;\n  }", "code_tokens": ["public", "boolean", "tryAcquireReadLock", "(", "long", "timeout", ")", "{", "final", "OModifiableInteger", "lHolds", "=", "lockHolds", ".", "get", "(", ")", ";", "final", "int", "holds", "=", "lHolds", ".", "intValue", "(", ")", ";", "if", "(", "holds", ">", "0", ")", "{", "// we have already acquire read lock", "lHolds", ".", "increment", "(", ")", ";", "return", "true", ";", "}", "else", "if", "(", "holds", "<", "0", ")", "{", "// write lock is acquired before, do nothing", "return", "true", ";", "}", "distributedCounter", ".", "increment", "(", ")", ";", "WNode", "wNode", "=", "tail", ".", "get", "(", ")", ";", "final", "long", "start", "=", "System", ".", "nanoTime", "(", ")", ";", "while", "(", "wNode", ".", "locked", ")", "{", "distributedCounter", ".", "decrement", "(", ")", ";", "while", "(", "wNode", ".", "locked", "&&", "wNode", "==", "tail", ".", "get", "(", ")", ")", "{", "wNode", ".", "waitingReaders", ".", "put", "(", "Thread", ".", "currentThread", "(", ")", ",", "Boolean", ".", "TRUE", ")", ";", "if", "(", "wNode", ".", "locked", "&&", "wNode", "==", "tail", ".", "get", "(", ")", ")", "{", "final", "long", "parkTimeout", "=", "timeout", "-", "(", "System", ".", "nanoTime", "(", ")", "-", "start", ")", ";", "if", "(", "parkTimeout", ">", "0", ")", "{", "LockSupport", ".", "parkNanos", "(", "this", ",", "parkTimeout", ")", ";", "}", "else", "{", "return", "false", ";", "}", "}", "wNode", "=", "tail", ".", "get", "(", ")", ";", "if", "(", "System", ".", "nanoTime", "(", ")", "-", "start", ">", "timeout", ")", "{", "return", "false", ";", "}", "}", "distributedCounter", ".", "increment", "(", ")", ";", "wNode", "=", "tail", ".", "get", "(", ")", ";", "if", "(", "System", ".", "nanoTime", "(", ")", "-", "start", ">", "timeout", ")", "{", "distributedCounter", ".", "decrement", "(", ")", ";", "return", "false", ";", "}", "}", "lHolds", ".", "increment", "(", ")", ";", "assert", "lHolds", ".", "intValue", "(", ")", "==", "1", ";", "return", "true", ";", "}"], "docstring": "Tries to acquire lock during provided interval of time and returns either if provided time interval was passed or\nif lock was acquired.\n\n@param timeout Timeout during of which we should wait for read lock.\n\n@return <code>true</code> if read lock was acquired.", "docstring_tokens": ["Tries", "to", "acquire", "lock", "during", "provided", "interval", "of", "time", "and", "returns", "either", "if", "provided", "time", "interval", "was", "passed", "or", "if", "lock", "was", "acquired", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/concur/lock/OReadersWriterSpinLock.java#L64-L118", "partition": "test", "index": 3269, "time": "2017-12-05 08:32:34"}
{"repo": "orientechnologies/orientdb", "path": "distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java", "func_name": "OHazelcastPlugin.initSystemDatabase", "original_string": "protected void initSystemDatabase() {\n    final ODocument defaultCfg = getStorage(OSystemDatabase.SYSTEM_DB_NAME)\n        .loadDatabaseConfiguration(getDefaultDatabaseConfigFile());\n    defaultCfg.field(\"autoDeploy\", false);\n    final OModifiableDistributedConfiguration sysCfg = new OModifiableDistributedConfiguration(defaultCfg);\n    sysCfg.removeServer(\"<NEW_NODE>\");\n\n    messageService.registerDatabase(OSystemDatabase.SYSTEM_DB_NAME, sysCfg);\n    sysCfg.addNewNodeInServerList(getLocalNodeName());\n  }", "language": "java", "code": "protected void initSystemDatabase() {\n    final ODocument defaultCfg = getStorage(OSystemDatabase.SYSTEM_DB_NAME)\n        .loadDatabaseConfiguration(getDefaultDatabaseConfigFile());\n    defaultCfg.field(\"autoDeploy\", false);\n    final OModifiableDistributedConfiguration sysCfg = new OModifiableDistributedConfiguration(defaultCfg);\n    sysCfg.removeServer(\"<NEW_NODE>\");\n\n    messageService.registerDatabase(OSystemDatabase.SYSTEM_DB_NAME, sysCfg);\n    sysCfg.addNewNodeInServerList(getLocalNodeName());\n  }", "code_tokens": ["protected", "void", "initSystemDatabase", "(", ")", "{", "final", "ODocument", "defaultCfg", "=", "getStorage", "(", "OSystemDatabase", ".", "SYSTEM_DB_NAME", ")", ".", "loadDatabaseConfiguration", "(", "getDefaultDatabaseConfigFile", "(", ")", ")", ";", "defaultCfg", ".", "field", "(", "\"autoDeploy\"", ",", "false", ")", ";", "final", "OModifiableDistributedConfiguration", "sysCfg", "=", "new", "OModifiableDistributedConfiguration", "(", "defaultCfg", ")", ";", "sysCfg", ".", "removeServer", "(", "\"<NEW_NODE>\"", ")", ";", "messageService", ".", "registerDatabase", "(", "OSystemDatabase", ".", "SYSTEM_DB_NAME", ",", "sysCfg", ")", ";", "sysCfg", ".", "addNewNodeInServerList", "(", "getLocalNodeName", "(", ")", ")", ";", "}"], "docstring": "Protecte system database from being replicated", "docstring_tokens": ["Protecte", "system", "database", "from", "being", "replicated"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastPlugin.java#L309-L318", "partition": "test", "index": 2935, "time": "2017-12-05 11:55:56"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyEmbedded.java", "func_name": "OPropertyEmbedded.setTypeInternal", "original_string": "protected void setTypeInternal(final OType iType) {\n    getDatabase().checkSecurity(ORule.ResourceGeneric.SCHEMA, ORole.PERMISSION_UPDATE);\n\n    acquireSchemaWriteLock();\n    try {\n      if (iType == globalRef.getType())\n        // NO CHANGES\n        return;\n\n      if (!iType.getCastable().contains(globalRef.getType()))\n        throw new IllegalArgumentException(\"Cannot change property type from \" + globalRef.getType() + \" to \" + iType);\n\n      this.globalRef = owner.owner.findOrCreateGlobalProperty(this.globalRef.getName(), iType);\n    } finally {\n      releaseSchemaWriteLock();\n    }\n  }", "language": "java", "code": "protected void setTypeInternal(final OType iType) {\n    getDatabase().checkSecurity(ORule.ResourceGeneric.SCHEMA, ORole.PERMISSION_UPDATE);\n\n    acquireSchemaWriteLock();\n    try {\n      if (iType == globalRef.getType())\n        // NO CHANGES\n        return;\n\n      if (!iType.getCastable().contains(globalRef.getType()))\n        throw new IllegalArgumentException(\"Cannot change property type from \" + globalRef.getType() + \" to \" + iType);\n\n      this.globalRef = owner.owner.findOrCreateGlobalProperty(this.globalRef.getName(), iType);\n    } finally {\n      releaseSchemaWriteLock();\n    }\n  }", "code_tokens": ["protected", "void", "setTypeInternal", "(", "final", "OType", "iType", ")", "{", "getDatabase", "(", ")", ".", "checkSecurity", "(", "ORule", ".", "ResourceGeneric", ".", "SCHEMA", ",", "ORole", ".", "PERMISSION_UPDATE", ")", ";", "acquireSchemaWriteLock", "(", ")", ";", "try", "{", "if", "(", "iType", "==", "globalRef", ".", "getType", "(", ")", ")", "// NO CHANGES", "return", ";", "if", "(", "!", "iType", ".", "getCastable", "(", ")", ".", "contains", "(", "globalRef", ".", "getType", "(", ")", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cannot change property type from \"", "+", "globalRef", ".", "getType", "(", ")", "+", "\" to \"", "+", "iType", ")", ";", "this", ".", "globalRef", "=", "owner", ".", "owner", ".", "findOrCreateGlobalProperty", "(", "this", ".", "globalRef", ".", "getName", "(", ")", ",", "iType", ")", ";", "}", "finally", "{", "releaseSchemaWriteLock", "(", ")", ";", "}", "}"], "docstring": "Change the type. It checks for compatibility between the change of type.\n\n@param iType", "docstring_tokens": ["Change", "the", "type", ".", "It", "checks", "for", "compatibility", "between", "the", "change", "of", "type", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OPropertyEmbedded.java#L58-L74", "partition": "test", "index": 2909, "time": "2017-12-29 11:06:55"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OExecutionPlanCache.java", "func_name": "OExecutionPlanCache.get", "original_string": "public static OExecutionPlan get(String statement, OCommandContext ctx, ODatabaseDocumentInternal db) {\n    if (db == null) {\n      throw new IllegalArgumentException(\"DB cannot be null\");\n    }\n    if (statement == null) {\n      return null;\n    }\n\n    OExecutionPlanCache resource = db.getSharedContext().getExecutionPlanCache();\n    OExecutionPlan result = resource.getInternal(statement, ctx, db);\n    return result;\n  }", "language": "java", "code": "public static OExecutionPlan get(String statement, OCommandContext ctx, ODatabaseDocumentInternal db) {\n    if (db == null) {\n      throw new IllegalArgumentException(\"DB cannot be null\");\n    }\n    if (statement == null) {\n      return null;\n    }\n\n    OExecutionPlanCache resource = db.getSharedContext().getExecutionPlanCache();\n    OExecutionPlan result = resource.getInternal(statement, ctx, db);\n    return result;\n  }", "code_tokens": ["public", "static", "OExecutionPlan", "get", "(", "String", "statement", ",", "OCommandContext", "ctx", ",", "ODatabaseDocumentInternal", "db", ")", "{", "if", "(", "db", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"DB cannot be null\"", ")", ";", "}", "if", "(", "statement", "==", "null", ")", "{", "return", "null", ";", "}", "OExecutionPlanCache", "resource", "=", "db", ".", "getSharedContext", "(", ")", ".", "getExecutionPlanCache", "(", ")", ";", "OExecutionPlan", "result", "=", "resource", ".", "getInternal", "(", "statement", ",", "ctx", ",", "db", ")", ";", "return", "result", ";", "}"], "docstring": "returns an already prepared SQL execution plan, taking it from the cache if it exists or creating a new one if it doesn't\n\n@param statement the SQL statement\n@param ctx\n@param db        the current DB instance\n\n@return a statement executor from the cache", "docstring_tokens": ["returns", "an", "already", "prepared", "SQL", "execution", "plan", "taking", "it", "from", "the", "cache", "if", "it", "exists", "or", "creating", "a", "new", "one", "if", "it", "doesn", "t"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OExecutionPlanCache.java#L74-L85", "partition": "test", "index": 3151, "time": "2018-02-12 09:49:50"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/atomicoperations/OAtomicOperation.java", "func_name": "OAtomicOperation.checkChangesFilledUpTo", "original_string": "private static boolean checkChangesFilledUpTo(final FileChanges changesContainer, final long pageIndex) {\n    if (changesContainer == null) {\n      return true;\n    } else if (changesContainer.isNew || changesContainer.maxNewPageIndex > -2) {\n      return pageIndex < changesContainer.maxNewPageIndex + 1;\n    } else\n      return !changesContainer.truncate;\n  }", "language": "java", "code": "private static boolean checkChangesFilledUpTo(final FileChanges changesContainer, final long pageIndex) {\n    if (changesContainer == null) {\n      return true;\n    } else if (changesContainer.isNew || changesContainer.maxNewPageIndex > -2) {\n      return pageIndex < changesContainer.maxNewPageIndex + 1;\n    } else\n      return !changesContainer.truncate;\n  }", "code_tokens": ["private", "static", "boolean", "checkChangesFilledUpTo", "(", "final", "FileChanges", "changesContainer", ",", "final", "long", "pageIndex", ")", "{", "if", "(", "changesContainer", "==", "null", ")", "{", "return", "true", ";", "}", "else", "if", "(", "changesContainer", ".", "isNew", "||", "changesContainer", ".", "maxNewPageIndex", ">", "-", "2", ")", "{", "return", "pageIndex", "<", "changesContainer", ".", "maxNewPageIndex", "+", "1", ";", "}", "else", "return", "!", "changesContainer", ".", "truncate", ";", "}"], "docstring": "This check if a file was trimmed or trunked in the current atomic operation.\n\n@param changesContainer changes container to check\n@param pageIndex        limit to check against the changes\n\n@return true if there are no changes or pageIndex still fit, false if the pageIndex do not fit anymore", "docstring_tokens": ["This", "check", "if", "a", "file", "was", "trimmed", "or", "trunked", "in", "the", "current", "atomic", "operation", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/atomicoperations/OAtomicOperation.java#L298-L305", "partition": "test", "index": 3008, "time": "2018-02-15 16:36:19"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/record/binary/ORecordSerializerBinaryV0.java", "func_name": "ORecordSerializerBinaryV0.getPositionsFromEmbeddedCollection", "original_string": "private List<RecordInfo> getPositionsFromEmbeddedCollection(final BytesContainer bytes, int serializerVersion) {\n    List<RecordInfo> retList = new ArrayList<>();\n\n    int numberOfElements = OVarIntSerializer.readAsInteger(bytes);\n    //read collection type\n    readByte(bytes);\n\n    for (int i = 0; i < numberOfElements; i++) {\n      //read element\n\n      //read data type      \n      OType dataType = readOType(bytes, false);\n      int fieldStart = bytes.offset;      \n\n      RecordInfo fieldInfo = new RecordInfo();\n      fieldInfo.fieldStartOffset = fieldStart;\n      fieldInfo.fieldType = dataType;\n\n      //TODO find better way to skip data bytes;\n      deserializeValue(bytes, dataType, null, true, -1, serializerVersion, true);\n      fieldInfo.fieldLength = bytes.offset - fieldStart;\n      retList.add(fieldInfo);\n    }\n\n    return retList;\n  }", "language": "java", "code": "private List<RecordInfo> getPositionsFromEmbeddedCollection(final BytesContainer bytes, int serializerVersion) {\n    List<RecordInfo> retList = new ArrayList<>();\n\n    int numberOfElements = OVarIntSerializer.readAsInteger(bytes);\n    //read collection type\n    readByte(bytes);\n\n    for (int i = 0; i < numberOfElements; i++) {\n      //read element\n\n      //read data type      \n      OType dataType = readOType(bytes, false);\n      int fieldStart = bytes.offset;      \n\n      RecordInfo fieldInfo = new RecordInfo();\n      fieldInfo.fieldStartOffset = fieldStart;\n      fieldInfo.fieldType = dataType;\n\n      //TODO find better way to skip data bytes;\n      deserializeValue(bytes, dataType, null, true, -1, serializerVersion, true);\n      fieldInfo.fieldLength = bytes.offset - fieldStart;\n      retList.add(fieldInfo);\n    }\n\n    return retList;\n  }", "code_tokens": ["private", "List", "<", "RecordInfo", ">", "getPositionsFromEmbeddedCollection", "(", "final", "BytesContainer", "bytes", ",", "int", "serializerVersion", ")", "{", "List", "<", "RecordInfo", ">", "retList", "=", "new", "ArrayList", "<>", "(", ")", ";", "int", "numberOfElements", "=", "OVarIntSerializer", ".", "readAsInteger", "(", "bytes", ")", ";", "//read collection type", "readByte", "(", "bytes", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "numberOfElements", ";", "i", "++", ")", "{", "//read element", "//read data type      ", "OType", "dataType", "=", "readOType", "(", "bytes", ",", "false", ")", ";", "int", "fieldStart", "=", "bytes", ".", "offset", ";", "RecordInfo", "fieldInfo", "=", "new", "RecordInfo", "(", ")", ";", "fieldInfo", ".", "fieldStartOffset", "=", "fieldStart", ";", "fieldInfo", ".", "fieldType", "=", "dataType", ";", "//TODO find better way to skip data bytes;", "deserializeValue", "(", "bytes", ",", "dataType", ",", "null", ",", "true", ",", "-", "1", ",", "serializerVersion", ",", "true", ")", ";", "fieldInfo", ".", "fieldLength", "=", "bytes", ".", "offset", "-", "fieldStart", ";", "retList", ".", "add", "(", "fieldInfo", ")", ";", "}", "return", "retList", ";", "}"], "docstring": "returns begin position and length for each value in embedded collection", "docstring_tokens": ["returns", "begin", "position", "and", "length", "for", "each", "value", "in", "embedded", "collection"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/record/binary/ORecordSerializerBinaryV0.java#L466-L491", "partition": "test", "index": 3279, "time": "2018-03-01 11:37:17"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.requiresMultipleIndexLookups", "original_string": "private boolean requiresMultipleIndexLookups(OAndBlock keyCondition) {\n    for (OBooleanExpression oBooleanExpression : keyCondition.getSubBlocks()) {\n      if (!(oBooleanExpression instanceof OBinaryCondition)) {\n        return true;\n      }\n    }\n    return false;\n  }", "language": "java", "code": "private boolean requiresMultipleIndexLookups(OAndBlock keyCondition) {\n    for (OBooleanExpression oBooleanExpression : keyCondition.getSubBlocks()) {\n      if (!(oBooleanExpression instanceof OBinaryCondition)) {\n        return true;\n      }\n    }\n    return false;\n  }", "code_tokens": ["private", "boolean", "requiresMultipleIndexLookups", "(", "OAndBlock", "keyCondition", ")", "{", "for", "(", "OBooleanExpression", "oBooleanExpression", ":", "keyCondition", ".", "getSubBlocks", "(", ")", ")", "{", "if", "(", "!", "(", "oBooleanExpression", "instanceof", "OBinaryCondition", ")", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "checks whether the condition has CONTAINSANY or similar expressions, that require multiple index evaluations\n\n@param keyCondition\n\n@return", "docstring_tokens": ["checks", "whether", "the", "condition", "has", "CONTAINSANY", "or", "similar", "expressions", "that", "require", "multiple", "index", "evaluations"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L2139-L2146", "partition": "test", "index": 2927, "time": "2018-03-15 15:00:31"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/record/binary/ORecordSerializerBinaryV1.java", "func_name": "ORecordSerializerBinaryV1.getFieldSizeAndTypeFromCurrentPosition", "original_string": "private Tuple<Integer, OType> getFieldSizeAndTypeFromCurrentPosition(BytesContainer bytes) {\n    int fieldSize = OVarIntSerializer.readAsInteger(bytes);\n    OType type = readOType(bytes, false);    \n    return new Tuple<>(fieldSize, type);\n  }", "language": "java", "code": "private Tuple<Integer, OType> getFieldSizeAndTypeFromCurrentPosition(BytesContainer bytes) {\n    int fieldSize = OVarIntSerializer.readAsInteger(bytes);\n    OType type = readOType(bytes, false);    \n    return new Tuple<>(fieldSize, type);\n  }", "code_tokens": ["private", "Tuple", "<", "Integer", ",", "OType", ">", "getFieldSizeAndTypeFromCurrentPosition", "(", "BytesContainer", "bytes", ")", "{", "int", "fieldSize", "=", "OVarIntSerializer", ".", "readAsInteger", "(", "bytes", ")", ";", "OType", "type", "=", "readOType", "(", "bytes", ",", "false", ")", ";", "return", "new", "Tuple", "<>", "(", "fieldSize", ",", "type", ")", ";", "}"], "docstring": "use only for named fields", "docstring_tokens": ["use", "only", "for", "named", "fields"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/record/binary/ORecordSerializerBinaryV1.java#L632-L636", "partition": "test", "index": 3041, "time": "2018-03-20 17:38:22"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/jna/ONative.java", "func_name": "ONative.getOpenFilesLimit", "original_string": "public int getOpenFilesLimit(boolean verbose, int recommended, int defLimit) {\n    if (Platform.isLinux()) {\n      final OCLibrary.Rlimit rlimit = new OCLibrary.Rlimit();\n      final int result = C_LIBRARY.getrlimit(OCLibrary.RLIMIT_NOFILE, rlimit);\n\n      if (result == 0 && rlimit.rlim_cur > 0) {\n        if (verbose) {\n          OLogManager.instance().infoNoDb(this, \"Detected limit of amount of simultaneously open files is %d, \"\n              + \" limit of open files for disk cache will be set to %d\", rlimit.rlim_cur, rlimit.rlim_cur / 2 - 512);\n        }\n\n        if (rlimit.rlim_cur < recommended) {\n          OLogManager.instance()\n              .warnNoDb(this, \"Value of limit of simultaneously open files is too small, recommended value is %d\", recommended);\n        }\n\n        return (int) rlimit.rlim_cur / 2 - 512;\n      } else {\n        if (verbose) {\n          OLogManager.instance().infoNoDb(this, \"Can not detect value of limit of open files.\");\n        }\n      }\n    } else if (Platform.isWindows()) {\n      if (verbose) {\n        OLogManager.instance()\n            .infoNoDb(this, \"Windows OS is detected, %d limit of open files will be set for the disk cache.\", recommended);\n      }\n\n      return recommended;\n    }\n\n    if (verbose) {\n      OLogManager.instance().infoNoDb(this, \"Default limit of open files (%d) will be used.\", defLimit);\n    }\n\n    return defLimit;\n  }", "language": "java", "code": "public int getOpenFilesLimit(boolean verbose, int recommended, int defLimit) {\n    if (Platform.isLinux()) {\n      final OCLibrary.Rlimit rlimit = new OCLibrary.Rlimit();\n      final int result = C_LIBRARY.getrlimit(OCLibrary.RLIMIT_NOFILE, rlimit);\n\n      if (result == 0 && rlimit.rlim_cur > 0) {\n        if (verbose) {\n          OLogManager.instance().infoNoDb(this, \"Detected limit of amount of simultaneously open files is %d, \"\n              + \" limit of open files for disk cache will be set to %d\", rlimit.rlim_cur, rlimit.rlim_cur / 2 - 512);\n        }\n\n        if (rlimit.rlim_cur < recommended) {\n          OLogManager.instance()\n              .warnNoDb(this, \"Value of limit of simultaneously open files is too small, recommended value is %d\", recommended);\n        }\n\n        return (int) rlimit.rlim_cur / 2 - 512;\n      } else {\n        if (verbose) {\n          OLogManager.instance().infoNoDb(this, \"Can not detect value of limit of open files.\");\n        }\n      }\n    } else if (Platform.isWindows()) {\n      if (verbose) {\n        OLogManager.instance()\n            .infoNoDb(this, \"Windows OS is detected, %d limit of open files will be set for the disk cache.\", recommended);\n      }\n\n      return recommended;\n    }\n\n    if (verbose) {\n      OLogManager.instance().infoNoDb(this, \"Default limit of open files (%d) will be used.\", defLimit);\n    }\n\n    return defLimit;\n  }", "code_tokens": ["public", "int", "getOpenFilesLimit", "(", "boolean", "verbose", ",", "int", "recommended", ",", "int", "defLimit", ")", "{", "if", "(", "Platform", ".", "isLinux", "(", ")", ")", "{", "final", "OCLibrary", ".", "Rlimit", "rlimit", "=", "new", "OCLibrary", ".", "Rlimit", "(", ")", ";", "final", "int", "result", "=", "C_LIBRARY", ".", "getrlimit", "(", "OCLibrary", ".", "RLIMIT_NOFILE", ",", "rlimit", ")", ";", "if", "(", "result", "==", "0", "&&", "rlimit", ".", "rlim_cur", ">", "0", ")", "{", "if", "(", "verbose", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "infoNoDb", "(", "this", ",", "\"Detected limit of amount of simultaneously open files is %d, \"", "+", "\" limit of open files for disk cache will be set to %d\"", ",", "rlimit", ".", "rlim_cur", ",", "rlimit", ".", "rlim_cur", "/", "2", "-", "512", ")", ";", "}", "if", "(", "rlimit", ".", "rlim_cur", "<", "recommended", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warnNoDb", "(", "this", ",", "\"Value of limit of simultaneously open files is too small, recommended value is %d\"", ",", "recommended", ")", ";", "}", "return", "(", "int", ")", "rlimit", ".", "rlim_cur", "/", "2", "-", "512", ";", "}", "else", "{", "if", "(", "verbose", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "infoNoDb", "(", "this", ",", "\"Can not detect value of limit of open files.\"", ")", ";", "}", "}", "}", "else", "if", "(", "Platform", ".", "isWindows", "(", ")", ")", "{", "if", "(", "verbose", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "infoNoDb", "(", "this", ",", "\"Windows OS is detected, %d limit of open files will be set for the disk cache.\"", ",", "recommended", ")", ";", "}", "return", "recommended", ";", "}", "if", "(", "verbose", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "infoNoDb", "(", "this", ",", "\"Default limit of open files (%d) will be used.\"", ",", "defLimit", ")", ";", "}", "return", "defLimit", ";", "}"], "docstring": "Detects limit of limit of open files.\n\n@param recommended recommended value of limit of open files.\n@param defLimit    default value for limit of open files.\n\n@return limit of open files, available for the system.", "docstring_tokens": ["Detects", "limit", "of", "limit", "of", "open", "files", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/jna/ONative.java#L109-L145", "partition": "test", "index": 2979, "time": "2018-05-07 21:12:57"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/enhancement/OObjectProxyMethodHandler.java", "func_name": "OObjectProxyMethodHandler.attach", "original_string": "public void attach(final Object self)\n      throws IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n    for (Class<?> currentClass = self.getClass(); currentClass != Object.class; ) {\n      if (Proxy.class.isAssignableFrom(currentClass)) {\n        currentClass = currentClass.getSuperclass();\n        continue;\n      }\n      for (Field f : currentClass.getDeclaredFields()) {\n        final String fieldName = f.getName();\n        final Class<?> declaringClass = f.getDeclaringClass();\n\n        if (OObjectEntitySerializer.isTransientField(declaringClass, fieldName) || OObjectEntitySerializer\n            .isVersionField(declaringClass, fieldName) || OObjectEntitySerializer.isIdField(declaringClass, fieldName))\n          continue;\n\n        Object value = OObjectEntitySerializer.getFieldValue(f, self);\n        value = setValue(self, fieldName, value);\n        OObjectEntitySerializer.setFieldValue(f, self, value);\n      }\n      currentClass = currentClass.getSuperclass();\n\n      if (currentClass == null || currentClass.equals(ODocument.class))\n        // POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER\n        // ODOCUMENT FIELDS\n        currentClass = Object.class;\n    }\n  }", "language": "java", "code": "public void attach(final Object self)\n      throws IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n    for (Class<?> currentClass = self.getClass(); currentClass != Object.class; ) {\n      if (Proxy.class.isAssignableFrom(currentClass)) {\n        currentClass = currentClass.getSuperclass();\n        continue;\n      }\n      for (Field f : currentClass.getDeclaredFields()) {\n        final String fieldName = f.getName();\n        final Class<?> declaringClass = f.getDeclaringClass();\n\n        if (OObjectEntitySerializer.isTransientField(declaringClass, fieldName) || OObjectEntitySerializer\n            .isVersionField(declaringClass, fieldName) || OObjectEntitySerializer.isIdField(declaringClass, fieldName))\n          continue;\n\n        Object value = OObjectEntitySerializer.getFieldValue(f, self);\n        value = setValue(self, fieldName, value);\n        OObjectEntitySerializer.setFieldValue(f, self, value);\n      }\n      currentClass = currentClass.getSuperclass();\n\n      if (currentClass == null || currentClass.equals(ODocument.class))\n        // POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER\n        // ODOCUMENT FIELDS\n        currentClass = Object.class;\n    }\n  }", "code_tokens": ["public", "void", "attach", "(", "final", "Object", "self", ")", "throws", "IllegalArgumentException", ",", "IllegalAccessException", ",", "NoSuchMethodException", ",", "InvocationTargetException", "{", "for", "(", "Class", "<", "?", ">", "currentClass", "=", "self", ".", "getClass", "(", ")", ";", "currentClass", "!=", "Object", ".", "class", ";", ")", "{", "if", "(", "Proxy", ".", "class", ".", "isAssignableFrom", "(", "currentClass", ")", ")", "{", "currentClass", "=", "currentClass", ".", "getSuperclass", "(", ")", ";", "continue", ";", "}", "for", "(", "Field", "f", ":", "currentClass", ".", "getDeclaredFields", "(", ")", ")", "{", "final", "String", "fieldName", "=", "f", ".", "getName", "(", ")", ";", "final", "Class", "<", "?", ">", "declaringClass", "=", "f", ".", "getDeclaringClass", "(", ")", ";", "if", "(", "OObjectEntitySerializer", ".", "isTransientField", "(", "declaringClass", ",", "fieldName", ")", "||", "OObjectEntitySerializer", ".", "isVersionField", "(", "declaringClass", ",", "fieldName", ")", "||", "OObjectEntitySerializer", ".", "isIdField", "(", "declaringClass", ",", "fieldName", ")", ")", "continue", ";", "Object", "value", "=", "OObjectEntitySerializer", ".", "getFieldValue", "(", "f", ",", "self", ")", ";", "value", "=", "setValue", "(", "self", ",", "fieldName", ",", "value", ")", ";", "OObjectEntitySerializer", ".", "setFieldValue", "(", "f", ",", "self", ",", "value", ")", ";", "}", "currentClass", "=", "currentClass", ".", "getSuperclass", "(", ")", ";", "if", "(", "currentClass", "==", "null", "||", "currentClass", ".", "equals", "(", "ODocument", ".", "class", ")", ")", "// POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER", "// ODOCUMENT FIELDS", "currentClass", "=", "Object", ".", "class", ";", "}", "}"], "docstring": "Method that attaches all data contained in the object to the associated document\n\n@param self :- The object containing this handler instance\n\n@throws IllegalAccessException\n@throws IllegalArgumentException\n@throws InvocationTargetException\n@throws NoSuchMethodException", "docstring_tokens": ["Method", "that", "attaches", "all", "data", "contained", "in", "the", "object", "to", "the", "associated", "document"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/enhancement/OObjectProxyMethodHandler.java#L213-L239", "partition": "test", "index": 3293, "time": "2018-05-11 15:14:53"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OScriptExecutionPlan.java", "func_name": "OScriptExecutionPlan.executeFull", "original_string": "public OExecutionStepInternal executeFull() {\n    for (int i = 0; i < steps.size(); i++) {\n      ScriptLineStep step = steps.get(i);\n      if (step.containsReturn()) {\n        OExecutionStepInternal returnStep = step.executeUntilReturn(ctx);\n        if (returnStep != null) {\n          return returnStep;\n        }\n      }\n      OResultSet lastResult = step.syncPull(ctx, 100);\n\n      while (lastResult.hasNext()) {\n        while (lastResult.hasNext()) {\n          lastResult.next();\n        }\n        lastResult = step.syncPull(ctx, 100);\n      }\n    }\n\n    return null;\n  }", "language": "java", "code": "public OExecutionStepInternal executeFull() {\n    for (int i = 0; i < steps.size(); i++) {\n      ScriptLineStep step = steps.get(i);\n      if (step.containsReturn()) {\n        OExecutionStepInternal returnStep = step.executeUntilReturn(ctx);\n        if (returnStep != null) {\n          return returnStep;\n        }\n      }\n      OResultSet lastResult = step.syncPull(ctx, 100);\n\n      while (lastResult.hasNext()) {\n        while (lastResult.hasNext()) {\n          lastResult.next();\n        }\n        lastResult = step.syncPull(ctx, 100);\n      }\n    }\n\n    return null;\n  }", "code_tokens": ["public", "OExecutionStepInternal", "executeFull", "(", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "steps", ".", "size", "(", ")", ";", "i", "++", ")", "{", "ScriptLineStep", "step", "=", "steps", ".", "get", "(", "i", ")", ";", "if", "(", "step", ".", "containsReturn", "(", ")", ")", "{", "OExecutionStepInternal", "returnStep", "=", "step", ".", "executeUntilReturn", "(", "ctx", ")", ";", "if", "(", "returnStep", "!=", "null", ")", "{", "return", "returnStep", ";", "}", "}", "OResultSet", "lastResult", "=", "step", ".", "syncPull", "(", "ctx", ",", "100", ")", ";", "while", "(", "lastResult", ".", "hasNext", "(", ")", ")", "{", "while", "(", "lastResult", ".", "hasNext", "(", ")", ")", "{", "lastResult", ".", "next", "(", ")", ";", "}", "lastResult", "=", "step", ".", "syncPull", "(", "ctx", ",", "100", ")", ";", "}", "}", "return", "null", ";", "}"], "docstring": "executes the whole script and returns last statement ONLY if it's a RETURN, otherwise it returns null;\n\n@return", "docstring_tokens": ["executes", "the", "whole", "script", "and", "returns", "last", "statement", "ONLY", "if", "it", "s", "a", "RETURN", "otherwise", "it", "returns", "null", ";"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OScriptExecutionPlan.java#L205-L225", "partition": "test", "index": 2984, "time": "2018-06-12 17:10:36"}
{"repo": "orientechnologies/orientdb", "path": "object/src/main/java/com/orientechnologies/orient/object/jpa/parsing/JPAHandler.java", "func_name": "JPAHandler.characters", "original_string": "@Override\n  public void characters(char[] ch, int start, int length) throws SAXException {\n    builder.append(ch, start, length);\n  }", "language": "java", "code": "@Override\n  public void characters(char[] ch, int start, int length) throws SAXException {\n    builder.append(ch, start, length);\n  }", "code_tokens": ["@", "Override", "public", "void", "characters", "(", "char", "[", "]", "ch", ",", "int", "start", ",", "int", "length", ")", "throws", "SAXException", "{", "builder", ".", "append", "(", "ch", ",", "start", ",", "length", ")", ";", "}"], "docstring": "Collect up the characters, as element's characters may be split across multiple calls. Isn't SAX lovely...", "docstring_tokens": ["Collect", "up", "the", "characters", "as", "element", "s", "characters", "may", "be", "split", "across", "multiple", "calls", ".", "Isn", "t", "SAX", "lovely", "..."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/object/src/main/java/com/orientechnologies/orient/object/jpa/parsing/JPAHandler.java#L151-L154", "partition": "test", "index": 2948, "time": "2018-06-13 21:18:27"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/parser/OJson.java", "func_name": "OJson.toObjectDetermineType", "original_string": "public Object toObjectDetermineType(OResult source, OCommandContext ctx){\n    String className = getClassNameForDocument(ctx);\n    String type = getTypeForDocument(ctx);\n    if (className != null || (type != null && \"d\".equalsIgnoreCase(type))) {\n      return toDocument(source, ctx, className);\n    }\n    else{\n      return toMap(source, ctx);\n    }\n  }", "language": "java", "code": "public Object toObjectDetermineType(OResult source, OCommandContext ctx){\n    String className = getClassNameForDocument(ctx);\n    String type = getTypeForDocument(ctx);\n    if (className != null || (type != null && \"d\".equalsIgnoreCase(type))) {\n      return toDocument(source, ctx, className);\n    }\n    else{\n      return toMap(source, ctx);\n    }\n  }", "code_tokens": ["public", "Object", "toObjectDetermineType", "(", "OResult", "source", ",", "OCommandContext", "ctx", ")", "{", "String", "className", "=", "getClassNameForDocument", "(", "ctx", ")", ";", "String", "type", "=", "getTypeForDocument", "(", "ctx", ")", ";", "if", "(", "className", "!=", "null", "||", "(", "type", "!=", "null", "&&", "\"d\"", ".", "equalsIgnoreCase", "(", "type", ")", ")", ")", "{", "return", "toDocument", "(", "source", ",", "ctx", ",", "className", ")", ";", "}", "else", "{", "return", "toMap", "(", "source", ",", "ctx", ")", ";", "}", "}"], "docstring": "choosing return type is based on existence of @class and @type field in JSON\n@param source\n@param ctx\n@return", "docstring_tokens": ["choosing", "return", "type", "is", "based", "on", "existence", "of"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/parser/OJson.java#L97-L106", "partition": "test", "index": 2993, "time": "2018-08-28 14:05:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/record/ridbag/embedded/OEmbeddedRidBag.java", "func_name": "OEmbeddedRidBag.swap", "original_string": "public boolean swap(int index, OIdentifiable newValue) {\n    EntriesIterator iter = (EntriesIterator) rawIterator();\n    int currIndex = 0;\n    while (iter.hasNext()) {\n      iter.next();\n      if (index == currIndex) {\n        iter.swapValueOnCurrent(newValue);\n        return true;\n      }\n      currIndex++;\n    }\n    return false;\n  }", "language": "java", "code": "public boolean swap(int index, OIdentifiable newValue) {\n    EntriesIterator iter = (EntriesIterator) rawIterator();\n    int currIndex = 0;\n    while (iter.hasNext()) {\n      iter.next();\n      if (index == currIndex) {\n        iter.swapValueOnCurrent(newValue);\n        return true;\n      }\n      currIndex++;\n    }\n    return false;\n  }", "code_tokens": ["public", "boolean", "swap", "(", "int", "index", ",", "OIdentifiable", "newValue", ")", "{", "EntriesIterator", "iter", "=", "(", "EntriesIterator", ")", "rawIterator", "(", ")", ";", "int", "currIndex", "=", "0", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "iter", ".", "next", "(", ")", ";", "if", "(", "index", "==", "currIndex", ")", "{", "iter", ".", "swapValueOnCurrent", "(", "newValue", ")", ";", "return", "true", ";", "}", "currIndex", "++", ";", "}", "return", "false", ";", "}"], "docstring": "for internal use only\n\n@param index\n@param newValue\n\n@return", "docstring_tokens": ["for", "internal", "use", "only"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/record/ridbag/embedded/OEmbeddedRidBag.java#L295-L307", "partition": "test", "index": 2970, "time": "2018-08-31 17:10:35"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/common/concur/lock/ScalableRWLock.java", "func_name": "ScalableRWLock.addState", "original_string": "private ReadersEntry addState() {\n    final AtomicInteger state = new AtomicInteger(SRWL_STATE_NOT_READING);\n    final ReadersEntry newEntry = new ReadersEntry(state);\n    entry.set(newEntry);\n    readersStateList.add(state);\n    readersStateArrayRef.set(null);\n    return newEntry;\n  }", "language": "java", "code": "private ReadersEntry addState() {\n    final AtomicInteger state = new AtomicInteger(SRWL_STATE_NOT_READING);\n    final ReadersEntry newEntry = new ReadersEntry(state);\n    entry.set(newEntry);\n    readersStateList.add(state);\n    readersStateArrayRef.set(null);\n    return newEntry;\n  }", "code_tokens": ["private", "ReadersEntry", "addState", "(", ")", "{", "final", "AtomicInteger", "state", "=", "new", "AtomicInteger", "(", "SRWL_STATE_NOT_READING", ")", ";", "final", "ReadersEntry", "newEntry", "=", "new", "ReadersEntry", "(", "state", ")", ";", "entry", ".", "set", "(", "newEntry", ")", ";", "readersStateList", ".", "add", "(", "state", ")", ";", "readersStateArrayRef", ".", "set", "(", "null", ")", ";", "return", "newEntry", ";", "}"], "docstring": "Creates a new ReadersEntry instance for the current thread and\nits associated AtomicInteger to store the state of the Reader\n\n@return Returns a reference to the newly created instance of\n{@code ReadersEntry}", "docstring_tokens": ["Creates", "a", "new", "ReadersEntry", "instance", "for", "the", "current", "thread", "and", "its", "associated", "AtomicInteger", "to", "store", "the", "state", "of", "the", "Reader"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/common/concur/lock/ScalableRWLock.java#L260-L267", "partition": "test", "index": 3266, "time": "2018-10-01 18:17:12"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/sequence/OSequenceCached.java", "func_name": "OSequenceCached.nextWithNewCurrentValue", "original_string": "protected long nextWithNewCurrentValue(long currentValue, boolean executeViaDistributed)\n      throws OSequenceLimitReachedException, ODatabaseException {\n    if (!executeViaDistributed) {\n      //we don't want synchronization on whole method, because called with executeViaDistributed == true\n      //will later call nextWithNewCurrentValue with parameter executeViaDistributed == false\n      //and that will cause deadlock\n      synchronized (this) {\n        cacheStart = currentValue;\n        return nextWork();\n      }\n    } else {\n      try{\n        return sendSequenceActionSetAndNext(currentValue);\n      }\n      catch (InterruptedException | ExecutionException exc){\n        OLogManager.instance().error(this, exc.getMessage(), exc, (Object[]) null);\n        throw new ODatabaseException(exc.getMessage());\n      }\n    }\n  }", "language": "java", "code": "protected long nextWithNewCurrentValue(long currentValue, boolean executeViaDistributed)\n      throws OSequenceLimitReachedException, ODatabaseException {\n    if (!executeViaDistributed) {\n      //we don't want synchronization on whole method, because called with executeViaDistributed == true\n      //will later call nextWithNewCurrentValue with parameter executeViaDistributed == false\n      //and that will cause deadlock\n      synchronized (this) {\n        cacheStart = currentValue;\n        return nextWork();\n      }\n    } else {\n      try{\n        return sendSequenceActionSetAndNext(currentValue);\n      }\n      catch (InterruptedException | ExecutionException exc){\n        OLogManager.instance().error(this, exc.getMessage(), exc, (Object[]) null);\n        throw new ODatabaseException(exc.getMessage());\n      }\n    }\n  }", "code_tokens": ["protected", "long", "nextWithNewCurrentValue", "(", "long", "currentValue", ",", "boolean", "executeViaDistributed", ")", "throws", "OSequenceLimitReachedException", ",", "ODatabaseException", "{", "if", "(", "!", "executeViaDistributed", ")", "{", "//we don't want synchronization on whole method, because called with executeViaDistributed == true", "//will later call nextWithNewCurrentValue with parameter executeViaDistributed == false", "//and that will cause deadlock", "synchronized", "(", "this", ")", "{", "cacheStart", "=", "currentValue", ";", "return", "nextWork", "(", ")", ";", "}", "}", "else", "{", "try", "{", "return", "sendSequenceActionSetAndNext", "(", "currentValue", ")", ";", "}", "catch", "(", "InterruptedException", "|", "ExecutionException", "exc", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "exc", ".", "getMessage", "(", ")", ",", "exc", ",", "(", "Object", "[", "]", ")", "null", ")", ";", "throw", "new", "ODatabaseException", "(", "exc", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}"], "docstring": "first set new current value then call next", "docstring_tokens": ["first", "set", "new", "current", "value", "then", "call", "next"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/sequence/OSequenceCached.java#L128-L147", "partition": "test", "index": 3295, "time": "2018-10-05 18:55:03"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ODistributedStorage.java", "func_name": "ODistributedStorage.executeOnlyLocally", "original_string": "protected boolean executeOnlyLocally(final String localNodeName, final ODistributedConfiguration dbCfg,\n      final OCommandExecutor exec, final Collection<String> involvedClusters, final Collection<String> nodes) {\n    boolean executeLocally = false;\n    if (exec.isIdempotent()) {\n      final int availableNodes = nodes.size();\n\n      // IDEMPOTENT: CHECK IF CAN WORK LOCALLY ONLY\n      int maxReadQuorum;\n      if (involvedClusters.isEmpty())\n        maxReadQuorum = dbCfg.getReadQuorum(null, availableNodes, localNodeName);\n      else {\n        maxReadQuorum = 0;\n        for (String cl : involvedClusters)\n          maxReadQuorum = Math.max(maxReadQuorum, dbCfg.getReadQuorum(cl, availableNodes, localNodeName));\n      }\n\n      if (nodes.contains(localNodeName) && maxReadQuorum <= 1)\n        executeLocally = true;\n    }\n\n    return executeLocally;\n  }\n\n  public boolean isLocalEnv() {\n    return localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal.INSTANCE\n        .isRunModeDistributed();\n  }\n\n  public OStorageOperationResult<ORawBuffer> readRecord(final ORecordId iRecordId, final String iFetchPlan,\n      final boolean iIgnoreCache, final boolean prefetchRecords, final ORecordCallback<ORawBuffer> iCallback) {\n\n    if (isLocalEnv()) {\n      // ALREADY DISTRIBUTED\n      return wrapped.readRecord(iRecordId, iFetchPlan, iIgnoreCache, prefetchRecords, iCallback);\n    }\n\n    final ORawBuffer memCopy = localDistributedDatabase.getRecordIfLocked(iRecordId);\n    if (memCopy != null)\n      return new OStorageOperationResult<ORawBuffer>(memCopy);\n\n    try {\n      final String clusterName = getClusterNameByRID(iRecordId);\n\n      final ODistributedConfiguration dbCfg = distributedConfiguration;\n      final List<String> nodes = dbCfg.getServers(clusterName, null);\n      final int availableNodes = nodes.size();\n\n      // CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER\n      final String localNodeName = dManager.getLocalNodeName();\n\n      if (nodes.isEmpty()\n          || nodes.contains(dManager.getLocalNodeName()) && dbCfg.getReadQuorum(clusterName, availableNodes, localNodeName) <= 1) {\n        // DON'T REPLICATE\n        return (OStorageOperationResult<ORawBuffer>) OScenarioThreadLocal.executeAsDistributed(new Callable() {\n          @Override\n          public Object call() throws Exception {\n            return wrapped.readRecord(iRecordId, iFetchPlan, iIgnoreCache, prefetchRecords, iCallback);\n          }\n        });\n      }\n\n      final OReadRecordTask task = ((OReadRecordTask) dManager.getTaskFactoryManager().getFactoryByServerNames(nodes)\n          .createTask(OReadRecordTask.FACTORYID)).init(iRecordId);\n\n      // DISTRIBUTE IT\n      final ODistributedResponse response = dManager\n          .sendRequest(getName(), Collections.singleton(clusterName), nodes, task, dManager.getNextMessageIdCounter(),\n              EXECUTION_MODE.RESPONSE, null, null, null);\n      final Object dResult = response != null ? response.getPayload() : null;\n\n      if (dResult instanceof ONeedRetryException)\n        throw (ONeedRetryException) dResult;\n      else if (dResult instanceof Exception)\n        throw OException\n            .wrapException(new ODistributedException(\"Error on execution distributed read record\"), (Exception) dResult);\n\n      return new OStorageOperationResult<ORawBuffer>((ORawBuffer) dResult);\n\n    } catch (ONeedRetryException e) {\n      // PASS THROUGH\n      throw e;\n    } catch (Exception e) {\n      handleDistributedException(\"Cannot route read record operation for %s to the distributed node\", e, iRecordId);\n      // UNREACHABLE\n      return null;\n    }\n  }\n\n  @Override\n  public OStorageOperationResult<ORawBuffer> readRecordIfVersionIsNotLatest(final ORecordId rid, final String fetchPlan,\n      final boolean ignoreCache, final int recordVersion) throws ORecordNotFoundException {\n    if (isLocalEnv()) {\n      return wrapped.readRecordIfVersionIsNotLatest(rid, fetchPlan, ignoreCache, recordVersion);\n    }\n    final ORawBuffer memCopy = localDistributedDatabase.getRecordIfLocked(rid);\n    if (memCopy != null)\n      return new OStorageOperationResult<ORawBuffer>(memCopy);\n\n    try {\n      final String clusterName = getClusterNameByRID(rid);\n\n      final ODistributedConfiguration dbCfg = distributedConfiguration;\n      final List<String> nodes = dbCfg.getServers(clusterName, null);\n      final int availableNodes = nodes.size();\n\n      // CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER\n      final String localNodeName = dManager.getLocalNodeName();\n\n      if (nodes.isEmpty()\n          || nodes.contains(dManager.getLocalNodeName()) && dbCfg.getReadQuorum(clusterName, availableNodes, localNodeName) <= 1) {\n        // DON'T REPLICATE\n        return (OStorageOperationResult<ORawBuffer>) OScenarioThreadLocal.executeAsDistributed(new Callable() {\n          @Override\n          public Object call() throws Exception {\n            return wrapped.readRecordIfVersionIsNotLatest(rid, fetchPlan, ignoreCache, recordVersion);\n          }\n        });\n      }\n\n      final OReadRecordIfNotLatestTask task = (OReadRecordIfNotLatestTask) dManager.getTaskFactoryManager()\n          .getFactoryByServerNames(nodes).createTask(OReadRecordIfNotLatestTask.FACTORYID);\n      task.init(rid, recordVersion);\n\n      // DISTRIBUTE IT\n      final Object result = dManager\n          .sendRequest(getName(), Collections.singleton(clusterName), nodes, task, dManager.getNextMessageIdCounter(),\n              EXECUTION_MODE.RESPONSE, null, null, null).getPayload();\n\n      if (result instanceof ONeedRetryException)\n        throw (ONeedRetryException) result;\n      else if (result instanceof Exception)\n        throw OException.wrapException(new ODistributedException(\"Error on execution distributed read record\"), (Exception) result);\n\n      return new OStorageOperationResult<ORawBuffer>((ORawBuffer) result);\n\n    } catch (ONeedRetryException e) {\n      // PASS THROUGH\n      throw e;\n    } catch (Exception e) {\n      handleDistributedException(\"Cannot route read record operation for %s to the distributed node\", e, rid);\n      // UNREACHABLE\n      return null;\n    }\n  }\n\n  @Override\n  public OStorageOperationResult<Boolean> deleteRecord(final ORecordId iRecordId, final int iVersion, final int iMode,\n      final ORecordCallback<Boolean> iCallback) {\n    // IF is a real delete should be with a tx\n    return wrapped.deleteRecord(iRecordId, iVersion, iMode, iCallback);\n  }", "language": "java", "code": "protected boolean executeOnlyLocally(final String localNodeName, final ODistributedConfiguration dbCfg,\n      final OCommandExecutor exec, final Collection<String> involvedClusters, final Collection<String> nodes) {\n    boolean executeLocally = false;\n    if (exec.isIdempotent()) {\n      final int availableNodes = nodes.size();\n\n      // IDEMPOTENT: CHECK IF CAN WORK LOCALLY ONLY\n      int maxReadQuorum;\n      if (involvedClusters.isEmpty())\n        maxReadQuorum = dbCfg.getReadQuorum(null, availableNodes, localNodeName);\n      else {\n        maxReadQuorum = 0;\n        for (String cl : involvedClusters)\n          maxReadQuorum = Math.max(maxReadQuorum, dbCfg.getReadQuorum(cl, availableNodes, localNodeName));\n      }\n\n      if (nodes.contains(localNodeName) && maxReadQuorum <= 1)\n        executeLocally = true;\n    }\n\n    return executeLocally;\n  }\n\n  public boolean isLocalEnv() {\n    return localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal.INSTANCE\n        .isRunModeDistributed();\n  }\n\n  public OStorageOperationResult<ORawBuffer> readRecord(final ORecordId iRecordId, final String iFetchPlan,\n      final boolean iIgnoreCache, final boolean prefetchRecords, final ORecordCallback<ORawBuffer> iCallback) {\n\n    if (isLocalEnv()) {\n      // ALREADY DISTRIBUTED\n      return wrapped.readRecord(iRecordId, iFetchPlan, iIgnoreCache, prefetchRecords, iCallback);\n    }\n\n    final ORawBuffer memCopy = localDistributedDatabase.getRecordIfLocked(iRecordId);\n    if (memCopy != null)\n      return new OStorageOperationResult<ORawBuffer>(memCopy);\n\n    try {\n      final String clusterName = getClusterNameByRID(iRecordId);\n\n      final ODistributedConfiguration dbCfg = distributedConfiguration;\n      final List<String> nodes = dbCfg.getServers(clusterName, null);\n      final int availableNodes = nodes.size();\n\n      // CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER\n      final String localNodeName = dManager.getLocalNodeName();\n\n      if (nodes.isEmpty()\n          || nodes.contains(dManager.getLocalNodeName()) && dbCfg.getReadQuorum(clusterName, availableNodes, localNodeName) <= 1) {\n        // DON'T REPLICATE\n        return (OStorageOperationResult<ORawBuffer>) OScenarioThreadLocal.executeAsDistributed(new Callable() {\n          @Override\n          public Object call() throws Exception {\n            return wrapped.readRecord(iRecordId, iFetchPlan, iIgnoreCache, prefetchRecords, iCallback);\n          }\n        });\n      }\n\n      final OReadRecordTask task = ((OReadRecordTask) dManager.getTaskFactoryManager().getFactoryByServerNames(nodes)\n          .createTask(OReadRecordTask.FACTORYID)).init(iRecordId);\n\n      // DISTRIBUTE IT\n      final ODistributedResponse response = dManager\n          .sendRequest(getName(), Collections.singleton(clusterName), nodes, task, dManager.getNextMessageIdCounter(),\n              EXECUTION_MODE.RESPONSE, null, null, null);\n      final Object dResult = response != null ? response.getPayload() : null;\n\n      if (dResult instanceof ONeedRetryException)\n        throw (ONeedRetryException) dResult;\n      else if (dResult instanceof Exception)\n        throw OException\n            .wrapException(new ODistributedException(\"Error on execution distributed read record\"), (Exception) dResult);\n\n      return new OStorageOperationResult<ORawBuffer>((ORawBuffer) dResult);\n\n    } catch (ONeedRetryException e) {\n      // PASS THROUGH\n      throw e;\n    } catch (Exception e) {\n      handleDistributedException(\"Cannot route read record operation for %s to the distributed node\", e, iRecordId);\n      // UNREACHABLE\n      return null;\n    }\n  }\n\n  @Override\n  public OStorageOperationResult<ORawBuffer> readRecordIfVersionIsNotLatest(final ORecordId rid, final String fetchPlan,\n      final boolean ignoreCache, final int recordVersion) throws ORecordNotFoundException {\n    if (isLocalEnv()) {\n      return wrapped.readRecordIfVersionIsNotLatest(rid, fetchPlan, ignoreCache, recordVersion);\n    }\n    final ORawBuffer memCopy = localDistributedDatabase.getRecordIfLocked(rid);\n    if (memCopy != null)\n      return new OStorageOperationResult<ORawBuffer>(memCopy);\n\n    try {\n      final String clusterName = getClusterNameByRID(rid);\n\n      final ODistributedConfiguration dbCfg = distributedConfiguration;\n      final List<String> nodes = dbCfg.getServers(clusterName, null);\n      final int availableNodes = nodes.size();\n\n      // CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER\n      final String localNodeName = dManager.getLocalNodeName();\n\n      if (nodes.isEmpty()\n          || nodes.contains(dManager.getLocalNodeName()) && dbCfg.getReadQuorum(clusterName, availableNodes, localNodeName) <= 1) {\n        // DON'T REPLICATE\n        return (OStorageOperationResult<ORawBuffer>) OScenarioThreadLocal.executeAsDistributed(new Callable() {\n          @Override\n          public Object call() throws Exception {\n            return wrapped.readRecordIfVersionIsNotLatest(rid, fetchPlan, ignoreCache, recordVersion);\n          }\n        });\n      }\n\n      final OReadRecordIfNotLatestTask task = (OReadRecordIfNotLatestTask) dManager.getTaskFactoryManager()\n          .getFactoryByServerNames(nodes).createTask(OReadRecordIfNotLatestTask.FACTORYID);\n      task.init(rid, recordVersion);\n\n      // DISTRIBUTE IT\n      final Object result = dManager\n          .sendRequest(getName(), Collections.singleton(clusterName), nodes, task, dManager.getNextMessageIdCounter(),\n              EXECUTION_MODE.RESPONSE, null, null, null).getPayload();\n\n      if (result instanceof ONeedRetryException)\n        throw (ONeedRetryException) result;\n      else if (result instanceof Exception)\n        throw OException.wrapException(new ODistributedException(\"Error on execution distributed read record\"), (Exception) result);\n\n      return new OStorageOperationResult<ORawBuffer>((ORawBuffer) result);\n\n    } catch (ONeedRetryException e) {\n      // PASS THROUGH\n      throw e;\n    } catch (Exception e) {\n      handleDistributedException(\"Cannot route read record operation for %s to the distributed node\", e, rid);\n      // UNREACHABLE\n      return null;\n    }\n  }\n\n  @Override\n  public OStorageOperationResult<Boolean> deleteRecord(final ORecordId iRecordId, final int iVersion, final int iMode,\n      final ORecordCallback<Boolean> iCallback) {\n    // IF is a real delete should be with a tx\n    return wrapped.deleteRecord(iRecordId, iVersion, iMode, iCallback);\n  }", "code_tokens": ["protected", "boolean", "executeOnlyLocally", "(", "final", "String", "localNodeName", ",", "final", "ODistributedConfiguration", "dbCfg", ",", "final", "OCommandExecutor", "exec", ",", "final", "Collection", "<", "String", ">", "involvedClusters", ",", "final", "Collection", "<", "String", ">", "nodes", ")", "{", "boolean", "executeLocally", "=", "false", ";", "if", "(", "exec", ".", "isIdempotent", "(", ")", ")", "{", "final", "int", "availableNodes", "=", "nodes", ".", "size", "(", ")", ";", "// IDEMPOTENT: CHECK IF CAN WORK LOCALLY ONLY", "int", "maxReadQuorum", ";", "if", "(", "involvedClusters", ".", "isEmpty", "(", ")", ")", "maxReadQuorum", "=", "dbCfg", ".", "getReadQuorum", "(", "null", ",", "availableNodes", ",", "localNodeName", ")", ";", "else", "{", "maxReadQuorum", "=", "0", ";", "for", "(", "String", "cl", ":", "involvedClusters", ")", "maxReadQuorum", "=", "Math", ".", "max", "(", "maxReadQuorum", ",", "dbCfg", ".", "getReadQuorum", "(", "cl", ",", "availableNodes", ",", "localNodeName", ")", ")", ";", "}", "if", "(", "nodes", ".", "contains", "(", "localNodeName", ")", "&&", "maxReadQuorum", "<=", "1", ")", "executeLocally", "=", "true", ";", "}", "return", "executeLocally", ";", "}", "public", "boolean", "isLocalEnv", "(", ")", "{", "return", "localDistributedDatabase", "==", "null", "||", "dManager", "==", "null", "||", "distributedConfiguration", "==", "null", "||", "OScenarioThreadLocal", ".", "INSTANCE", ".", "isRunModeDistributed", "(", ")", ";", "}", "public", "OStorageOperationResult", "<", "ORawBuffer", ">", "readRecord", "", "(", "final", "ORecordId", "iRecordId", ",", "final", "String", "iFetchPlan", ",", "final", "boolean", "iIgnoreCache", ",", "final", "boolean", "prefetchRecords", ",", "final", "ORecordCallback", "<", "ORawBuffer", ">", "iCallback", ")", "{", "if", "(", "isLocalEnv", "(", ")", ")", "{", "// ALREADY DISTRIBUTED", "return", "wrapped", ".", "readRecord", "(", "iRecordId", ",", "iFetchPlan", ",", "iIgnoreCache", ",", "prefetchRecords", ",", "iCallback", ")", ";", "}", "final", "ORawBuffer", "memCopy", "=", "localDistributedDatabase", ".", "getRecordIfLocked", "(", "iRecordId", ")", ";", "if", "(", "memCopy", "!=", "null", ")", "return", "new", "OStorageOperationResult", "<", "ORawBuffer", ">", "(", "memCopy", ")", ";", "try", "{", "final", "String", "clusterName", "=", "getClusterNameByRID", "(", "iRecordId", ")", ";", "final", "ODistributedConfiguration", "dbCfg", "=", "distributedConfiguration", ";", "final", "List", "<", "String", ">", "nodes", "=", "dbCfg", ".", "getServers", "(", "clusterName", ",", "null", ")", ";", "final", "int", "availableNodes", "=", "nodes", ".", "size", "(", ")", ";", "// CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER", "final", "String", "localNodeName", "=", "dManager", ".", "getLocalNodeName", "(", ")", ";", "if", "(", "nodes", ".", "isEmpty", "(", ")", "||", "nodes", ".", "contains", "(", "dManager", ".", "getLocalNodeName", "(", ")", ")", "&&", "dbCfg", ".", "getReadQuorum", "(", "clusterName", ",", "availableNodes", ",", "localNodeName", ")", "<=", "1", ")", "{", "// DON'T REPLICATE", "return", "(", "OStorageOperationResult", "<", "ORawBuffer", ">", ")", "OScenarioThreadLocal", ".", "executeAsDistributed", "(", "new", "Callable", "(", ")", "{", "@", "Override", "public", "Object", "call", "(", ")", "throws", "Exception", "{", "return", "wrapped", ".", "readRecord", "(", "iRecordId", ",", "iFetchPlan", ",", "iIgnoreCache", ",", "prefetchRecords", ",", "iCallback", ")", ";", "}", "}", ")", ";", "}", "final", "OReadRecordTask", "task", "=", "(", "(", "OReadRecordTask", ")", "dManager", ".", "getTaskFactoryManager", "(", ")", ".", "getFactoryByServerNames", "(", "nodes", ")", ".", "createTask", "(", "OReadRecordTask", ".", "FACTORYID", ")", ")", ".", "init", "(", "iRecordId", ")", ";", "// DISTRIBUTE IT", "final", "ODistributedResponse", "response", "=", "dManager", ".", "sendRequest", "(", "getName", "(", ")", ",", "Collections", ".", "singleton", "(", "clusterName", ")", ",", "nodes", ",", "task", ",", "dManager", ".", "getNextMessageIdCounter", "(", ")", ",", "EXECUTION_MODE", ".", "RESPONSE", ",", "null", ",", "null", ",", "null", ")", ";", "final", "Object", "dResult", "=", "response", "!=", "null", "?", "response", ".", "getPayload", "(", ")", ":", "null", ";", "if", "(", "dResult", "instanceof", "ONeedRetryException", ")", "throw", "(", "ONeedRetryException", ")", "dResult", ";", "else", "if", "(", "dResult", "instanceof", "Exception", ")", "throw", "OException", ".", "wrapException", "(", "new", "ODistributedException", "(", "\"Error on execution distributed read record\"", ")", ",", "(", "Exception", ")", "dResult", ")", ";", "return", "new", "OStorageOperationResult", "<", "ORawBuffer", ">", "(", "(", "ORawBuffer", ")", "dResult", ")", ";", "}", "catch", "(", "ONeedRetryException", "e", ")", "{", "// PASS THROUGH", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "handleDistributedException", "(", "\"Cannot route read record operation for %s to the distributed node\"", ",", "e", ",", "iRecordId", ")", ";", "// UNREACHABLE", "return", "null", ";", "}", "}", "@", "Override", "public", "OStorageOperationResult", "<", "ORawBuffer", ">", "readRecordIfVersionIsNotLatest", "", "(", "final", "ORecordId", "rid", ",", "final", "String", "fetchPlan", ",", "final", "boolean", "ignoreCache", ",", "final", "int", "recordVersion", ")", "throws", "ORecordNotFoundException", "{", "if", "(", "isLocalEnv", "(", ")", ")", "{", "return", "wrapped", ".", "readRecordIfVersionIsNotLatest", "(", "rid", ",", "fetchPlan", ",", "ignoreCache", ",", "recordVersion", ")", ";", "}", "final", "ORawBuffer", "memCopy", "=", "localDistributedDatabase", ".", "getRecordIfLocked", "(", "rid", ")", ";", "if", "(", "memCopy", "!=", "null", ")", "return", "new", "OStorageOperationResult", "<", "ORawBuffer", ">", "(", "memCopy", ")", ";", "try", "{", "final", "String", "clusterName", "=", "getClusterNameByRID", "(", "rid", ")", ";", "final", "ODistributedConfiguration", "dbCfg", "=", "distributedConfiguration", ";", "final", "List", "<", "String", ">", "nodes", "=", "dbCfg", ".", "getServers", "(", "clusterName", ",", "null", ")", ";", "final", "int", "availableNodes", "=", "nodes", ".", "size", "(", ")", ";", "// CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER", "final", "String", "localNodeName", "=", "dManager", ".", "getLocalNodeName", "(", ")", ";", "if", "(", "nodes", ".", "isEmpty", "(", ")", "||", "nodes", ".", "contains", "(", "dManager", ".", "getLocalNodeName", "(", ")", ")", "&&", "dbCfg", ".", "getReadQuorum", "(", "clusterName", ",", "availableNodes", ",", "localNodeName", ")", "<=", "1", ")", "{", "// DON'T REPLICATE", "return", "(", "OStorageOperationResult", "<", "ORawBuffer", ">", ")", "OScenarioThreadLocal", ".", "executeAsDistributed", "(", "new", "Callable", "(", ")", "{", "@", "Override", "public", "Object", "call", "(", ")", "throws", "Exception", "{", "return", "wrapped", ".", "readRecordIfVersionIsNotLatest", "(", "rid", ",", "fetchPlan", ",", "ignoreCache", ",", "recordVersion", ")", ";", "}", "}", ")", ";", "}", "final", "OReadRecordIfNotLatestTask", "task", "=", "(", "OReadRecordIfNotLatestTask", ")", "dManager", ".", "getTaskFactoryManager", "(", ")", ".", "getFactoryByServerNames", "(", "nodes", ")", ".", "createTask", "(", "OReadRecordIfNotLatestTask", ".", "FACTORYID", ")", ";", "task", ".", "init", "(", "rid", ",", "recordVersion", ")", ";", "// DISTRIBUTE IT", "final", "Object", "result", "=", "dManager", ".", "sendRequest", "(", "getName", "(", ")", ",", "Collections", ".", "singleton", "(", "clusterName", ")", ",", "nodes", ",", "task", ",", "dManager", ".", "getNextMessageIdCounter", "(", ")", ",", "EXECUTION_MODE", ".", "RESPONSE", ",", "null", ",", "null", ",", "null", ")", ".", "getPayload", "(", ")", ";", "if", "(", "result", "instanceof", "ONeedRetryException", ")", "throw", "(", "ONeedRetryException", ")", "result", ";", "else", "if", "(", "result", "instanceof", "Exception", ")", "throw", "OException", ".", "wrapException", "(", "new", "ODistributedException", "(", "\"Error on execution distributed read record\"", ")", ",", "(", "Exception", ")", "result", ")", ";", "return", "new", "OStorageOperationResult", "<", "ORawBuffer", ">", "(", "(", "ORawBuffer", ")", "result", ")", ";", "}", "catch", "(", "ONeedRetryException", "e", ")", "{", "// PASS THROUGH", "throw", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "handleDistributedException", "(", "\"Cannot route read record operation for %s to the distributed node\"", ",", "e", ",", "rid", ")", ";", "// UNREACHABLE", "return", "null", ";", "}", "}", "@", "Override", "public", "OStorageOperationResult", "<", "Boolean", ">", "deleteRecord", "", "(", "final", "ORecordId", "iRecordId", ",", "final", "int", "iVersion", ",", "final", "int", "iMode", ",", "final", "ORecordCallback", "<", "Boolean", ">", "iCallback", ")", "{", "// IF is a real delete should be with a tx", "return", "wrapped", ".", "deleteRecord", "(", "iRecordId", ",", "iVersion", ",", "iMode", ",", "iCallback", ")", ";", "}"], "docstring": "Only idempotent commands that don't involve any other node can be executed locally.", "docstring_tokens": ["Only", "idempotent", "commands", "that", "don", "t", "involve", "any", "other", "node", "can", "be", "executed", "locally", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ODistributedStorage.java#L473-L623", "partition": "test", "index": 2947, "time": "2018-11-30 17:46:58"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/OConflictResolverDatabaseRepairer.java", "func_name": "OConflictResolverDatabaseRepairer.enqueueRepairRecord", "original_string": "@Override\n  public void enqueueRepairRecord(final ORecordId rid) {\n    if (!active)\n      return;\n\n    if (rid == null || !rid.isPersistent())\n      return;\n\n    if (rid.getClusterPosition() < -1)\n      // SKIP TRANSACTIONAL RIDS\n      return;\n\n    recordProcessed.incrementAndGet();\n\n    // ADD RECORD TO REPAIR\n    records.put(rid, Boolean.TRUE);\n  }", "language": "java", "code": "@Override\n  public void enqueueRepairRecord(final ORecordId rid) {\n    if (!active)\n      return;\n\n    if (rid == null || !rid.isPersistent())\n      return;\n\n    if (rid.getClusterPosition() < -1)\n      // SKIP TRANSACTIONAL RIDS\n      return;\n\n    recordProcessed.incrementAndGet();\n\n    // ADD RECORD TO REPAIR\n    records.put(rid, Boolean.TRUE);\n  }", "code_tokens": ["@", "Override", "public", "void", "enqueueRepairRecord", "(", "final", "ORecordId", "rid", ")", "{", "if", "(", "!", "active", ")", "return", ";", "if", "(", "rid", "==", "null", "||", "!", "rid", ".", "isPersistent", "(", ")", ")", "return", ";", "if", "(", "rid", ".", "getClusterPosition", "(", ")", "<", "-", "1", ")", "// SKIP TRANSACTIONAL RIDS", "return", ";", "recordProcessed", ".", "incrementAndGet", "(", ")", ";", "// ADD RECORD TO REPAIR", "records", ".", "put", "(", "rid", ",", "Boolean", ".", "TRUE", ")", ";", "}"], "docstring": "Adds the record to repair int the map of records and cluster. The decision about repairing is taken by the timer task.\n\n@param rid RecordId to repair", "docstring_tokens": ["Adds", "the", "record", "to", "repair", "int", "the", "map", "of", "records", "and", "cluster", ".", "The", "decision", "about", "repairing", "is", "taken", "by", "the", "timer", "task", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/OConflictResolverDatabaseRepairer.java#L145-L161", "partition": "test", "index": 3163, "time": "2018-11-30 17:46:58"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/OConflictResolverDatabaseRepairer.java", "func_name": "OConflictResolverDatabaseRepairer.cancelRepairRecord", "original_string": "@Override\n  public void cancelRepairRecord(final ORecordId rid) {\n    if (!active)\n      return;\n\n    if (rid.getClusterPosition() < -1)\n      // SKIP TRANSACTIONAL RIDS\n      return;\n\n    // REMOVE THE RECORD TO REPAIR\n    if (records.remove(rid) != null)\n      // REMOVED\n      recordCanceled.incrementAndGet();\n  }", "language": "java", "code": "@Override\n  public void cancelRepairRecord(final ORecordId rid) {\n    if (!active)\n      return;\n\n    if (rid.getClusterPosition() < -1)\n      // SKIP TRANSACTIONAL RIDS\n      return;\n\n    // REMOVE THE RECORD TO REPAIR\n    if (records.remove(rid) != null)\n      // REMOVED\n      recordCanceled.incrementAndGet();\n  }", "code_tokens": ["@", "Override", "public", "void", "cancelRepairRecord", "(", "final", "ORecordId", "rid", ")", "{", "if", "(", "!", "active", ")", "return", ";", "if", "(", "rid", ".", "getClusterPosition", "(", ")", "<", "-", "1", ")", "// SKIP TRANSACTIONAL RIDS", "return", ";", "// REMOVE THE RECORD TO REPAIR", "if", "(", "records", ".", "remove", "(", "rid", ")", "!=", "null", ")", "// REMOVED", "recordCanceled", ".", "incrementAndGet", "(", ")", ";", "}"], "docstring": "Cancel the repair against a record because the update succeed.\n\n@param rid RecordId to remove from repair", "docstring_tokens": ["Cancel", "the", "repair", "against", "a", "record", "because", "the", "update", "succeed", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/OConflictResolverDatabaseRepairer.java#L168-L181", "partition": "test", "index": 3164, "time": "2018-11-30 17:46:58"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/OConflictResolverDatabaseRepairer.java", "func_name": "OConflictResolverDatabaseRepairer.enqueueRepairCluster", "original_string": "@Override\n  public void enqueueRepairCluster(final int clusterId) {\n    if (!active)\n      return;\n\n    if (clusterId < -1)\n      // SKIP TRANSACTIONAL RIDS\n      return;\n\n    recordProcessed.incrementAndGet();\n\n    // ADD CLUSTER TO REPAIR\n    clusters.put(clusterId, Boolean.TRUE);\n  }", "language": "java", "code": "@Override\n  public void enqueueRepairCluster(final int clusterId) {\n    if (!active)\n      return;\n\n    if (clusterId < -1)\n      // SKIP TRANSACTIONAL RIDS\n      return;\n\n    recordProcessed.incrementAndGet();\n\n    // ADD CLUSTER TO REPAIR\n    clusters.put(clusterId, Boolean.TRUE);\n  }", "code_tokens": ["@", "Override", "public", "void", "enqueueRepairCluster", "(", "final", "int", "clusterId", ")", "{", "if", "(", "!", "active", ")", "return", ";", "if", "(", "clusterId", "<", "-", "1", ")", "// SKIP TRANSACTIONAL RIDS", "return", ";", "recordProcessed", ".", "incrementAndGet", "(", ")", ";", "// ADD CLUSTER TO REPAIR", "clusters", ".", "put", "(", "clusterId", ",", "Boolean", ".", "TRUE", ")", ";", "}"], "docstring": "Enqueues the request to repair a cluster. The decision about repairing is taken by the timer task.\n\n@param clusterId Broken cluster id to start repairing", "docstring_tokens": ["Enqueues", "the", "request", "to", "repair", "a", "cluster", ".", "The", "decision", "about", "repairing", "is", "taken", "by", "the", "timer", "task", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/OConflictResolverDatabaseRepairer.java#L188-L201", "partition": "test", "index": 3165, "time": "2018-11-30 17:46:58"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ODistributedWorker.java", "func_name": "ODistributedWorker.initDatabaseInstance", "original_string": "public void initDatabaseInstance() {\n    if (database == null) {\n      for (int retry = 0; retry < 100; ++retry) {\n        try {\n          database = distributed.getDatabaseInstance();\n          // OK\n          break;\n\n        } catch (OStorageException e) {\n          // WAIT FOR A WHILE, THEN RETRY\n          if (!dbNotAvailable(retry))\n            return;\n        } catch (OConfigurationException e) {\n          // WAIT FOR A WHILE, THEN RETRY\n          if (!dbNotAvailable(retry))\n            return;\n        }\n      }\n\n      if (database == null) {\n        ODistributedServerLog.info(this, manager.getLocalNodeName(), null, DIRECTION.NONE,\n            \"Database '%s' not present, shutting down database manager\", databaseName);\n        distributed.shutdown();\n        throw new ODistributedException(\"Cannot open database '\" + databaseName + \"'\");\n      }\n\n    } else if (database.isClosed()) {\n      // DATABASE CLOSED, REOPEN IT\n      database.activateOnCurrentThread();\n      database.close();\n      database = distributed.getDatabaseInstance();\n    }\n  }", "language": "java", "code": "public void initDatabaseInstance() {\n    if (database == null) {\n      for (int retry = 0; retry < 100; ++retry) {\n        try {\n          database = distributed.getDatabaseInstance();\n          // OK\n          break;\n\n        } catch (OStorageException e) {\n          // WAIT FOR A WHILE, THEN RETRY\n          if (!dbNotAvailable(retry))\n            return;\n        } catch (OConfigurationException e) {\n          // WAIT FOR A WHILE, THEN RETRY\n          if (!dbNotAvailable(retry))\n            return;\n        }\n      }\n\n      if (database == null) {\n        ODistributedServerLog.info(this, manager.getLocalNodeName(), null, DIRECTION.NONE,\n            \"Database '%s' not present, shutting down database manager\", databaseName);\n        distributed.shutdown();\n        throw new ODistributedException(\"Cannot open database '\" + databaseName + \"'\");\n      }\n\n    } else if (database.isClosed()) {\n      // DATABASE CLOSED, REOPEN IT\n      database.activateOnCurrentThread();\n      database.close();\n      database = distributed.getDatabaseInstance();\n    }\n  }", "code_tokens": ["public", "void", "initDatabaseInstance", "(", ")", "{", "if", "(", "database", "==", "null", ")", "{", "for", "(", "int", "retry", "=", "0", ";", "retry", "<", "100", ";", "++", "retry", ")", "{", "try", "{", "database", "=", "distributed", ".", "getDatabaseInstance", "(", ")", ";", "// OK", "break", ";", "}", "catch", "(", "OStorageException", "e", ")", "{", "// WAIT FOR A WHILE, THEN RETRY", "if", "(", "!", "dbNotAvailable", "(", "retry", ")", ")", "return", ";", "}", "catch", "(", "OConfigurationException", "e", ")", "{", "// WAIT FOR A WHILE, THEN RETRY", "if", "(", "!", "dbNotAvailable", "(", "retry", ")", ")", "return", ";", "}", "}", "if", "(", "database", "==", "null", ")", "{", "ODistributedServerLog", ".", "info", "(", "this", ",", "manager", ".", "getLocalNodeName", "(", ")", ",", "null", ",", "DIRECTION", ".", "NONE", ",", "\"Database '%s' not present, shutting down database manager\"", ",", "databaseName", ")", ";", "distributed", ".", "shutdown", "(", ")", ";", "throw", "new", "ODistributedException", "(", "\"Cannot open database '\"", "+", "databaseName", "+", "\"'\"", ")", ";", "}", "}", "else", "if", "(", "database", ".", "isClosed", "(", ")", ")", "{", "// DATABASE CLOSED, REOPEN IT", "database", ".", "activateOnCurrentThread", "(", ")", ";", "database", ".", "close", "(", ")", ";", "database", "=", "distributed", ".", "getDatabaseInstance", "(", ")", ";", "}", "}"], "docstring": "Opens the database.", "docstring_tokens": ["Opens", "the", "database", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ODistributedWorker.java#L149-L181", "partition": "test", "index": 3285, "time": "2018-11-30 17:46:58"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ODistributedAbstractPlugin.java", "func_name": "ODistributedAbstractPlugin.getNodesWithStatus", "original_string": "@Override\n  public int getNodesWithStatus(final Collection<String> iNodes, final String databaseName, final DB_STATUS... statuses) {\n    for (Iterator<String> it = iNodes.iterator(); it.hasNext(); ) {\n      final String node = it.next();\n\n      if (!isNodeStatusEqualsTo(node, databaseName, statuses))\n        it.remove();\n    }\n    return iNodes.size();\n  }", "language": "java", "code": "@Override\n  public int getNodesWithStatus(final Collection<String> iNodes, final String databaseName, final DB_STATUS... statuses) {\n    for (Iterator<String> it = iNodes.iterator(); it.hasNext(); ) {\n      final String node = it.next();\n\n      if (!isNodeStatusEqualsTo(node, databaseName, statuses))\n        it.remove();\n    }\n    return iNodes.size();\n  }", "code_tokens": ["@", "Override", "public", "int", "getNodesWithStatus", "(", "final", "Collection", "<", "String", ">", "iNodes", ",", "final", "String", "databaseName", ",", "final", "DB_STATUS", "...", "statuses", ")", "{", "for", "(", "Iterator", "<", "String", ">", "it", "=", "iNodes", ".", "iterator", "(", ")", ";", "it", ".", "hasNext", "(", ")", ";", ")", "{", "final", "String", "node", "=", "it", ".", "next", "(", ")", ";", "if", "(", "!", "isNodeStatusEqualsTo", "(", "node", ",", "databaseName", ",", "statuses", ")", ")", "it", ".", "remove", "(", ")", ";", "}", "return", "iNodes", ".", "size", "(", ")", ";", "}"], "docstring": "Returns the nodes with the requested status.", "docstring_tokens": ["Returns", "the", "nodes", "with", "the", "requested", "status", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ODistributedAbstractPlugin.java#L638-L647", "partition": "test", "index": 3216, "time": "2018-11-30 17:46:58"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ODistributedAbstractPlugin.java", "func_name": "ODistributedAbstractPlugin.executeOnLocalNode", "original_string": "@Override\n  public Object executeOnLocalNode(final ODistributedRequestId reqId, final ORemoteTask task,\n      final ODatabaseDocumentInternal database) {\n    if (database != null && !(database.getStorage() instanceof ODistributedStorage))\n      throw new ODistributedException(\n          \"Distributed storage was not installed for database '\" + database.getName() + \"'. Implementation found: \" + database\n              .getStorage().getClass().getName());\n\n    final ODistributedAbstractPlugin manager = this;\n\n    return OScenarioThreadLocal.executeAsDistributed(new Callable<Object>() {\n      @Override\n      public Object call() throws Exception {\n        try {\n          final Object result = task.execute(reqId, serverInstance, manager, database);\n\n          if (result instanceof Throwable && !(result instanceof OException))\n            // EXCEPTION\n            ODistributedServerLog.debug(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,\n                \"Error on executing request %d (%s) on local node: \", (Throwable) result, reqId, task);\n          else {\n            // OK\n            final String sourceNodeName = task.getNodeSource();\n\n            if (database != null) {\n              final ODistributedDatabaseImpl ddb = getMessageService().getDatabase(database.getName());\n\n              if (ddb != null && !(result instanceof Throwable) && task instanceof OAbstractReplicatedTask && !task\n                  .isIdempotent()) {\n\n                // UPDATE LSN WITH LAST OPERATION\n                ddb.setLSN(sourceNodeName, ((OAbstractReplicatedTask) task).getLastLSN(), true);\n\n                // UPDATE LSN WITH LAST LOCAL OPERATION\n                ddb.setLSN(getLocalNodeName(), ((OAbstractPaginatedStorage) database.getStorage().getUnderlying()).getLSN(), true);\n              }\n            }\n          }\n\n          return result;\n\n        } catch (InterruptedException e) {\n          // IGNORE IT\n          ODistributedServerLog.debug(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,\n              \"Interrupted execution on executing distributed request %s on local node: %s\", e, reqId, task);\n          return e;\n\n        } catch (Exception e) {\n          if (!(e instanceof OException))\n            ODistributedServerLog.error(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,\n                \"Error on executing distributed request %s on local node: %s\", e, reqId, task);\n\n          return e;\n        }\n      }\n    });\n  }", "language": "java", "code": "@Override\n  public Object executeOnLocalNode(final ODistributedRequestId reqId, final ORemoteTask task,\n      final ODatabaseDocumentInternal database) {\n    if (database != null && !(database.getStorage() instanceof ODistributedStorage))\n      throw new ODistributedException(\n          \"Distributed storage was not installed for database '\" + database.getName() + \"'. Implementation found: \" + database\n              .getStorage().getClass().getName());\n\n    final ODistributedAbstractPlugin manager = this;\n\n    return OScenarioThreadLocal.executeAsDistributed(new Callable<Object>() {\n      @Override\n      public Object call() throws Exception {\n        try {\n          final Object result = task.execute(reqId, serverInstance, manager, database);\n\n          if (result instanceof Throwable && !(result instanceof OException))\n            // EXCEPTION\n            ODistributedServerLog.debug(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,\n                \"Error on executing request %d (%s) on local node: \", (Throwable) result, reqId, task);\n          else {\n            // OK\n            final String sourceNodeName = task.getNodeSource();\n\n            if (database != null) {\n              final ODistributedDatabaseImpl ddb = getMessageService().getDatabase(database.getName());\n\n              if (ddb != null && !(result instanceof Throwable) && task instanceof OAbstractReplicatedTask && !task\n                  .isIdempotent()) {\n\n                // UPDATE LSN WITH LAST OPERATION\n                ddb.setLSN(sourceNodeName, ((OAbstractReplicatedTask) task).getLastLSN(), true);\n\n                // UPDATE LSN WITH LAST LOCAL OPERATION\n                ddb.setLSN(getLocalNodeName(), ((OAbstractPaginatedStorage) database.getStorage().getUnderlying()).getLSN(), true);\n              }\n            }\n          }\n\n          return result;\n\n        } catch (InterruptedException e) {\n          // IGNORE IT\n          ODistributedServerLog.debug(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,\n              \"Interrupted execution on executing distributed request %s on local node: %s\", e, reqId, task);\n          return e;\n\n        } catch (Exception e) {\n          if (!(e instanceof OException))\n            ODistributedServerLog.error(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,\n                \"Error on executing distributed request %s on local node: %s\", e, reqId, task);\n\n          return e;\n        }\n      }\n    });\n  }", "code_tokens": ["@", "Override", "public", "Object", "executeOnLocalNode", "(", "final", "ODistributedRequestId", "reqId", ",", "final", "ORemoteTask", "task", ",", "final", "ODatabaseDocumentInternal", "database", ")", "{", "if", "(", "database", "!=", "null", "&&", "!", "(", "database", ".", "getStorage", "(", ")", "instanceof", "ODistributedStorage", ")", ")", "throw", "new", "ODistributedException", "(", "\"Distributed storage was not installed for database '\"", "+", "database", ".", "getName", "(", ")", "+", "\"'. Implementation found: \"", "+", "database", ".", "getStorage", "(", ")", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ";", "final", "ODistributedAbstractPlugin", "manager", "=", "this", ";", "return", "OScenarioThreadLocal", ".", "executeAsDistributed", "(", "new", "Callable", "<", "Object", ">", "(", ")", "{", "@", "Override", "public", "Object", "call", "(", ")", "throws", "Exception", "{", "try", "{", "final", "Object", "result", "=", "task", ".", "execute", "(", "reqId", ",", "serverInstance", ",", "manager", ",", "database", ")", ";", "if", "(", "result", "instanceof", "Throwable", "&&", "!", "(", "result", "instanceof", "OException", ")", ")", "// EXCEPTION", "ODistributedServerLog", ".", "debug", "(", "this", ",", "nodeName", ",", "getNodeNameById", "(", "reqId", ".", "getNodeId", "(", ")", ")", ",", "DIRECTION", ".", "IN", ",", "\"Error on executing request %d (%s) on local node: \"", ",", "(", "Throwable", ")", "result", ",", "reqId", ",", "task", ")", ";", "else", "{", "// OK", "final", "String", "sourceNodeName", "=", "task", ".", "getNodeSource", "(", ")", ";", "if", "(", "database", "!=", "null", ")", "{", "final", "ODistributedDatabaseImpl", "ddb", "=", "getMessageService", "(", ")", ".", "getDatabase", "(", "database", ".", "getName", "(", ")", ")", ";", "if", "(", "ddb", "!=", "null", "&&", "!", "(", "result", "instanceof", "Throwable", ")", "&&", "task", "instanceof", "OAbstractReplicatedTask", "&&", "!", "task", ".", "isIdempotent", "(", ")", ")", "{", "// UPDATE LSN WITH LAST OPERATION", "ddb", ".", "setLSN", "(", "sourceNodeName", ",", "(", "(", "OAbstractReplicatedTask", ")", "task", ")", ".", "getLastLSN", "(", ")", ",", "true", ")", ";", "// UPDATE LSN WITH LAST LOCAL OPERATION", "ddb", ".", "setLSN", "(", "getLocalNodeName", "(", ")", ",", "(", "(", "OAbstractPaginatedStorage", ")", "database", ".", "getStorage", "(", ")", ".", "getUnderlying", "(", ")", ")", ".", "getLSN", "(", ")", ",", "true", ")", ";", "}", "}", "}", "return", "result", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "// IGNORE IT", "ODistributedServerLog", ".", "debug", "(", "this", ",", "nodeName", ",", "getNodeNameById", "(", "reqId", ".", "getNodeId", "(", ")", ")", ",", "DIRECTION", ".", "IN", ",", "\"Interrupted execution on executing distributed request %s on local node: %s\"", ",", "e", ",", "reqId", ",", "task", ")", ";", "return", "e", ";", "}", "catch", "(", "Exception", "e", ")", "{", "if", "(", "!", "(", "e", "instanceof", "OException", ")", ")", "ODistributedServerLog", ".", "error", "(", "this", ",", "nodeName", ",", "getNodeNameById", "(", "reqId", ".", "getNodeId", "(", ")", ")", ",", "DIRECTION", ".", "IN", ",", "\"Error on executing distributed request %s on local node: %s\"", ",", "e", ",", "reqId", ",", "task", ")", ";", "return", "e", ";", "}", "}", "}", ")", ";", "}"], "docstring": "Executes the request on local node. In case of error returns the Exception itself", "docstring_tokens": ["Executes", "the", "request", "on", "local", "node", ".", "In", "case", "of", "error", "returns", "the", "Exception", "itself"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ODistributedAbstractPlugin.java#L433-L489", "partition": "test", "index": 3215, "time": "2018-11-30 17:46:58"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ONodeManager.java", "func_name": "ONodeManager.initReceiveMessages", "original_string": "protected void initReceiveMessages() throws IOException {\n    messageThread = new Thread(() -> {\n      while (!Thread.interrupted()) {\n        receiveMessages();\n      }\n    });\n    messageThread.setName(\"OrientDB_DistributedDiscoveryThread\");\n    messageThread.setDaemon(true);\n    messageThread.start();\n  }", "language": "java", "code": "protected void initReceiveMessages() throws IOException {\n    messageThread = new Thread(() -> {\n      while (!Thread.interrupted()) {\n        receiveMessages();\n      }\n    });\n    messageThread.setName(\"OrientDB_DistributedDiscoveryThread\");\n    messageThread.setDaemon(true);\n    messageThread.start();\n  }", "code_tokens": ["protected", "void", "initReceiveMessages", "(", ")", "throws", "IOException", "{", "messageThread", "=", "new", "Thread", "(", "(", ")", "->", "{", "while", "(", "!", "Thread", ".", "interrupted", "(", ")", ")", "{", "receiveMessages", "(", ")", ";", "}", "}", ")", ";", "messageThread", ".", "setName", "(", "\"OrientDB_DistributedDiscoveryThread\"", ")", ";", "messageThread", ".", "setDaemon", "(", "true", ")", ";", "messageThread", ".", "start", "(", ")", ";", "}"], "docstring": "inits the procedure that listens to pings from other servers, eg. that discovers other nodes in the network\n\n@throws IOException", "docstring_tokens": ["inits", "the", "procedure", "that", "listens", "to", "pings", "from", "other", "servers", "eg", ".", "that", "discovers", "other", "nodes", "in", "the", "network"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ONodeManager.java#L129-L138", "partition": "test", "index": 3064, "time": "2019-01-16 16:54:16"}
{"repo": "orientechnologies/orientdb", "path": "distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ONodeManager.java", "func_name": "ONodeManager.initCheckDisconnect", "original_string": "protected void initCheckDisconnect() {\n    disconnectTimer = new TimerTask() {\n      public void run() {\n        try {\n          checkIfKnownServersAreAlive();\n          if (running) {\n            initCheckDisconnect();\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    };\n    taskScheduler.scheduleOnce(disconnectTimer, discoveryPingIntervalMillis);\n  }", "language": "java", "code": "protected void initCheckDisconnect() {\n    disconnectTimer = new TimerTask() {\n      public void run() {\n        try {\n          checkIfKnownServersAreAlive();\n          if (running) {\n            initCheckDisconnect();\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    };\n    taskScheduler.scheduleOnce(disconnectTimer, discoveryPingIntervalMillis);\n  }", "code_tokens": ["protected", "void", "initCheckDisconnect", "(", ")", "{", "disconnectTimer", "=", "new", "TimerTask", "(", ")", "{", "public", "void", "run", "(", ")", "{", "try", "{", "checkIfKnownServersAreAlive", "(", ")", ";", "if", "(", "running", ")", "{", "initCheckDisconnect", "(", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "}", "}", ";", "taskScheduler", ".", "scheduleOnce", "(", "disconnectTimer", ",", "discoveryPingIntervalMillis", ")", ";", "}"], "docstring": "inits the procedure that checks if a server is no longer available, ie. if he did not ping for a long time", "docstring_tokens": ["inits", "the", "procedure", "that", "checks", "if", "a", "server", "is", "no", "longer", "available", "ie", ".", "if", "he", "did", "not", "ping", "for", "a", "long", "time"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/distributed-v2/src/main/java/com/orientechnologies/orient/distributed/impl/ONodeManager.java#L301-L315", "partition": "test", "index": 3065, "time": "2019-01-16 16:54:16"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/fs/OFileClassic.java", "func_name": "OFileClassic.create", "original_string": "public void create() throws IOException {\n    acquireWriteLock();\n    try {\n      acquireExclusiveAccess();\n\n      openChannel();\n      init();\n\n      setVersion(OFileClassic.CURRENT_VERSION);\n      version = OFileClassic.CURRENT_VERSION;\n\n      initAllocationMode();\n    } finally {\n      releaseWriteLock();\n    }\n  }", "language": "java", "code": "public void create() throws IOException {\n    acquireWriteLock();\n    try {\n      acquireExclusiveAccess();\n\n      openChannel();\n      init();\n\n      setVersion(OFileClassic.CURRENT_VERSION);\n      version = OFileClassic.CURRENT_VERSION;\n\n      initAllocationMode();\n    } finally {\n      releaseWriteLock();\n    }\n  }", "code_tokens": ["public", "void", "create", "(", ")", "throws", "IOException", "{", "acquireWriteLock", "(", ")", ";", "try", "{", "acquireExclusiveAccess", "(", ")", ";", "openChannel", "(", ")", ";", "init", "(", ")", ";", "setVersion", "(", "OFileClassic", ".", "CURRENT_VERSION", ")", ";", "version", "=", "OFileClassic", ".", "CURRENT_VERSION", ";", "initAllocationMode", "(", ")", ";", "}", "finally", "{", "releaseWriteLock", "(", ")", ";", "}", "}"], "docstring": "Creates the file.", "docstring_tokens": ["Creates", "the", "file", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/fs/OFileClassic.java#L523-L538", "partition": "test", "index": 2957, "time": "2019-01-22 10:49:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/fs/OFileClassic.java", "func_name": "OFileClassic.replaceContentWith", "original_string": "public void replaceContentWith(final Path newContentFile) throws IOException {\n    acquireWriteLock();\n    try {\n      close();\n\n      Files.copy(newContentFile, osFile, StandardCopyOption.REPLACE_EXISTING);\n\n      open();\n    } finally {\n      releaseWriteLock();\n    }\n  }", "language": "java", "code": "public void replaceContentWith(final Path newContentFile) throws IOException {\n    acquireWriteLock();\n    try {\n      close();\n\n      Files.copy(newContentFile, osFile, StandardCopyOption.REPLACE_EXISTING);\n\n      open();\n    } finally {\n      releaseWriteLock();\n    }\n  }", "code_tokens": ["public", "void", "replaceContentWith", "(", "final", "Path", "newContentFile", ")", "throws", "IOException", "{", "acquireWriteLock", "(", ")", ";", "try", "{", "close", "(", ")", ";", "Files", ".", "copy", "(", "newContentFile", ",", "osFile", ",", "StandardCopyOption", ".", "REPLACE_EXISTING", ")", ";", "open", "(", ")", ";", "}", "finally", "{", "releaseWriteLock", "(", ")", ";", "}", "}"], "docstring": "Replaces the file content with the content of the provided file.\n\n@param newContentFile the new content file to replace the content with.", "docstring_tokens": ["Replaces", "the", "file", "content", "with", "the", "content", "of", "the", "provided", "file", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/fs/OFileClassic.java#L933-L944", "partition": "test", "index": 2959, "time": "2019-01-22 10:49:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/fs/OFileClassic.java", "func_name": "OFileClassic.checkRegions", "original_string": "private long checkRegions(final long iOffset, final long iLength) {\n    acquireReadLock();\n    try {\n      if (iOffset < 0 || iOffset + iLength > size) {\n        throw new OIOException(\n            \"You cannot access outside the file size (\" + size + \" bytes). You have requested portion \" + iOffset + \"-\" + (iOffset\n                + iLength) + \" bytes. File: \" + this);\n      }\n\n      return iOffset + HEADER_SIZE;\n    } finally {\n      releaseReadLock();\n    }\n\n  }", "language": "java", "code": "private long checkRegions(final long iOffset, final long iLength) {\n    acquireReadLock();\n    try {\n      if (iOffset < 0 || iOffset + iLength > size) {\n        throw new OIOException(\n            \"You cannot access outside the file size (\" + size + \" bytes). You have requested portion \" + iOffset + \"-\" + (iOffset\n                + iLength) + \" bytes. File: \" + this);\n      }\n\n      return iOffset + HEADER_SIZE;\n    } finally {\n      releaseReadLock();\n    }\n\n  }", "code_tokens": ["private", "long", "checkRegions", "(", "final", "long", "iOffset", ",", "final", "long", "iLength", ")", "{", "acquireReadLock", "(", ")", ";", "try", "{", "if", "(", "iOffset", "<", "0", "||", "iOffset", "+", "iLength", ">", "size", ")", "{", "throw", "new", "OIOException", "(", "\"You cannot access outside the file size (\"", "+", "size", "+", "\" bytes). You have requested portion \"", "+", "iOffset", "+", "\"-\"", "+", "(", "iOffset", "+", "iLength", ")", "+", "\" bytes. File: \"", "+", "this", ")", ";", "}", "return", "iOffset", "+", "HEADER_SIZE", ";", "}", "finally", "{", "releaseReadLock", "(", ")", ";", "}", "}"], "docstring": "ALWAYS ADD THE HEADER SIZE BECAUSE ON THIS TYPE IS ALWAYS NEEDED", "docstring_tokens": ["ALWAYS", "ADD", "THE", "HEADER", "SIZE", "BECAUSE", "ON", "THIS", "TYPE", "IS", "ALWAYS", "NEEDED"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/fs/OFileClassic.java#L567-L581", "partition": "test", "index": 2958, "time": "2019-01-22 10:49:59"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java", "func_name": "ODatabaseDocumentAbstract.callbackHooks", "original_string": "public ORecordHook.RESULT callbackHooks(final ORecordHook.TYPE type, final OIdentifiable id) {\n    if (id == null || hooks.isEmpty() || id.getIdentity().getClusterId() == 0)\n      return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    final ORecordHook.SCOPE scope = ORecordHook.SCOPE.typeToScope(type);\n    final int scopeOrdinal = scope.ordinal();\n\n    final ORID identity = id.getIdentity().copy();\n    if (!pushInHook(identity))\n      return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    try {\n      final ORecord rec = id.getRecord();\n      if (rec == null)\n        return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n      final OScenarioThreadLocal.RUN_MODE runMode = OScenarioThreadLocal.INSTANCE.getRunMode();\n\n      boolean recordChanged = false;\n      for (ORecordHook hook : hooksByScope[scopeOrdinal]) {\n        switch (runMode) {\n        case DEFAULT: // NON_DISTRIBUTED OR PROXIED DB\n          if (getStorage().isDistributed()\n              && hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.TARGET_NODE)\n            // SKIP\n            continue;\n          break; // TARGET NODE\n        case RUNNING_DISTRIBUTED:\n          if (hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.SOURCE_NODE)\n            continue;\n        }\n\n        final ORecordHook.RESULT res = hook.onTrigger(type, rec);\n\n        if (res == ORecordHook.RESULT.RECORD_CHANGED)\n          recordChanged = true;\n        else if (res == ORecordHook.RESULT.SKIP_IO)\n          // SKIP IO OPERATION\n          return res;\n        else if (res == ORecordHook.RESULT.SKIP)\n          // SKIP NEXT HOOKS AND RETURN IT\n          return res;\n        else if (res == ORecordHook.RESULT.RECORD_REPLACED)\n          return res;\n      }\n\n      return recordChanged ? ORecordHook.RESULT.RECORD_CHANGED : ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    } finally {\n      popInHook(identity);\n    }\n  }", "language": "java", "code": "public ORecordHook.RESULT callbackHooks(final ORecordHook.TYPE type, final OIdentifiable id) {\n    if (id == null || hooks.isEmpty() || id.getIdentity().getClusterId() == 0)\n      return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    final ORecordHook.SCOPE scope = ORecordHook.SCOPE.typeToScope(type);\n    final int scopeOrdinal = scope.ordinal();\n\n    final ORID identity = id.getIdentity().copy();\n    if (!pushInHook(identity))\n      return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    try {\n      final ORecord rec = id.getRecord();\n      if (rec == null)\n        return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n      final OScenarioThreadLocal.RUN_MODE runMode = OScenarioThreadLocal.INSTANCE.getRunMode();\n\n      boolean recordChanged = false;\n      for (ORecordHook hook : hooksByScope[scopeOrdinal]) {\n        switch (runMode) {\n        case DEFAULT: // NON_DISTRIBUTED OR PROXIED DB\n          if (getStorage().isDistributed()\n              && hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.TARGET_NODE)\n            // SKIP\n            continue;\n          break; // TARGET NODE\n        case RUNNING_DISTRIBUTED:\n          if (hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.SOURCE_NODE)\n            continue;\n        }\n\n        final ORecordHook.RESULT res = hook.onTrigger(type, rec);\n\n        if (res == ORecordHook.RESULT.RECORD_CHANGED)\n          recordChanged = true;\n        else if (res == ORecordHook.RESULT.SKIP_IO)\n          // SKIP IO OPERATION\n          return res;\n        else if (res == ORecordHook.RESULT.SKIP)\n          // SKIP NEXT HOOKS AND RETURN IT\n          return res;\n        else if (res == ORecordHook.RESULT.RECORD_REPLACED)\n          return res;\n      }\n\n      return recordChanged ? ORecordHook.RESULT.RECORD_CHANGED : ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    } finally {\n      popInHook(identity);\n    }\n  }", "code_tokens": ["public", "ORecordHook", ".", "RESULT", "callbackHooks", "(", "final", "ORecordHook", ".", "TYPE", "type", ",", "final", "OIdentifiable", "id", ")", "{", "if", "(", "id", "==", "null", "||", "hooks", ".", "isEmpty", "(", ")", "||", "id", ".", "getIdentity", "(", ")", ".", "getClusterId", "(", ")", "==", "0", ")", "return", "ORecordHook", ".", "RESULT", ".", "RECORD_NOT_CHANGED", ";", "final", "ORecordHook", ".", "SCOPE", "scope", "=", "ORecordHook", ".", "SCOPE", ".", "typeToScope", "(", "type", ")", ";", "final", "int", "scopeOrdinal", "=", "scope", ".", "ordinal", "(", ")", ";", "final", "ORID", "identity", "=", "id", ".", "getIdentity", "(", ")", ".", "copy", "(", ")", ";", "if", "(", "!", "pushInHook", "(", "identity", ")", ")", "return", "ORecordHook", ".", "RESULT", ".", "RECORD_NOT_CHANGED", ";", "try", "{", "final", "ORecord", "rec", "=", "id", ".", "getRecord", "(", ")", ";", "if", "(", "rec", "==", "null", ")", "return", "ORecordHook", ".", "RESULT", ".", "RECORD_NOT_CHANGED", ";", "final", "OScenarioThreadLocal", ".", "RUN_MODE", "runMode", "=", "OScenarioThreadLocal", ".", "INSTANCE", ".", "getRunMode", "(", ")", ";", "boolean", "recordChanged", "=", "false", ";", "for", "(", "ORecordHook", "hook", ":", "hooksByScope", "[", "scopeOrdinal", "]", ")", "{", "switch", "(", "runMode", ")", "{", "case", "DEFAULT", ":", "// NON_DISTRIBUTED OR PROXIED DB", "if", "(", "getStorage", "(", ")", ".", "isDistributed", "(", ")", "&&", "hook", ".", "getDistributedExecutionMode", "(", ")", "==", "ORecordHook", ".", "DISTRIBUTED_EXECUTION_MODE", ".", "TARGET_NODE", ")", "// SKIP", "continue", ";", "break", ";", "// TARGET NODE", "case", "RUNNING_DISTRIBUTED", ":", "if", "(", "hook", ".", "getDistributedExecutionMode", "(", ")", "==", "ORecordHook", ".", "DISTRIBUTED_EXECUTION_MODE", ".", "SOURCE_NODE", ")", "continue", ";", "}", "final", "ORecordHook", ".", "RESULT", "res", "=", "hook", ".", "onTrigger", "(", "type", ",", "rec", ")", ";", "if", "(", "res", "==", "ORecordHook", ".", "RESULT", ".", "RECORD_CHANGED", ")", "recordChanged", "=", "true", ";", "else", "if", "(", "res", "==", "ORecordHook", ".", "RESULT", ".", "SKIP_IO", ")", "// SKIP IO OPERATION", "return", "res", ";", "else", "if", "(", "res", "==", "ORecordHook", ".", "RESULT", ".", "SKIP", ")", "// SKIP NEXT HOOKS AND RETURN IT", "return", "res", ";", "else", "if", "(", "res", "==", "ORecordHook", ".", "RESULT", ".", "RECORD_REPLACED", ")", "return", "res", ";", "}", "return", "recordChanged", "?", "ORecordHook", ".", "RESULT", ".", "RECORD_CHANGED", ":", "ORecordHook", ".", "RESULT", ".", "RECORD_NOT_CHANGED", ";", "}", "finally", "{", "popInHook", "(", "identity", ")", ";", "}", "}"], "docstring": "Callback the registered hooks if any.\n\n@param type Hook type. Define when hook is called.\n@param id   Record received in the callback\n\n@return True if the input record is changed, otherwise false", "docstring_tokens": ["Callback", "the", "registered", "hooks", "if", "any", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java#L640-L691", "partition": "test", "index": 3327, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java", "func_name": "ODatabaseDocumentAbstract.delete", "original_string": "public ODatabaseDocument delete(final ORID iRecord) {\n    checkOpenness();\n    checkIfActive();\n\n    final ORecord rec = load(iRecord);\n    if (rec != null)\n      delete(rec);\n    return this;\n  }", "language": "java", "code": "public ODatabaseDocument delete(final ORID iRecord) {\n    checkOpenness();\n    checkIfActive();\n\n    final ORecord rec = load(iRecord);\n    if (rec != null)\n      delete(rec);\n    return this;\n  }", "code_tokens": ["public", "ODatabaseDocument", "delete", "(", "final", "ORID", "iRecord", ")", "{", "checkOpenness", "(", ")", ";", "checkIfActive", "(", ")", ";", "final", "ORecord", "rec", "=", "load", "(", "iRecord", ")", ";", "if", "(", "rec", "!=", "null", ")", "delete", "(", "rec", ")", ";", "return", "this", ";", "}"], "docstring": "Deletes the record without checking the version.", "docstring_tokens": ["Deletes", "the", "record", "without", "checking", "the", "version", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java#L1106-L1114", "partition": "test", "index": 3328, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java", "func_name": "ODatabaseDocumentAbstract.countClass", "original_string": "public long countClass(final String iClassName, final boolean iPolymorphic) {\n    final OClass cls = getMetadata().getImmutableSchemaSnapshot().getClass(iClassName);\n    if (cls == null)\n      throw new IllegalArgumentException(\"Class '\" + cls + \"' not found in database\");\n\n    return countClass(cls, iPolymorphic);\n  }", "language": "java", "code": "public long countClass(final String iClassName, final boolean iPolymorphic) {\n    final OClass cls = getMetadata().getImmutableSchemaSnapshot().getClass(iClassName);\n    if (cls == null)\n      throw new IllegalArgumentException(\"Class '\" + cls + \"' not found in database\");\n\n    return countClass(cls, iPolymorphic);\n  }", "code_tokens": ["public", "long", "countClass", "(", "final", "String", "iClassName", ",", "final", "boolean", "iPolymorphic", ")", "{", "final", "OClass", "cls", "=", "getMetadata", "(", ")", ".", "getImmutableSchemaSnapshot", "(", ")", ".", "getClass", "(", "iClassName", ")", ";", "if", "(", "cls", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"Class '\"", "+", "cls", "+", "\"' not found in database\"", ")", ";", "return", "countClass", "(", "cls", ",", "iPolymorphic", ")", ";", "}"], "docstring": "Returns the number of the records of the class iClassName considering also sub classes if polymorphic is true.", "docstring_tokens": ["Returns", "the", "number", "of", "the", "records", "of", "the", "class", "iClassName", "considering", "also", "sub", "classes", "if", "polymorphic", "is", "true", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java#L1925-L1931", "partition": "test", "index": 3330, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java", "func_name": "ODatabaseDocumentAbstract.activateOnCurrentThread", "original_string": "@Override\n  public ODatabaseDocumentAbstract activateOnCurrentThread() {\n    final ODatabaseRecordThreadLocal tl = ODatabaseRecordThreadLocal.instance();\n    if (tl != null)\n      tl.set(this);\n    return this;\n  }", "language": "java", "code": "@Override\n  public ODatabaseDocumentAbstract activateOnCurrentThread() {\n    final ODatabaseRecordThreadLocal tl = ODatabaseRecordThreadLocal.instance();\n    if (tl != null)\n      tl.set(this);\n    return this;\n  }", "code_tokens": ["@", "Override", "public", "ODatabaseDocumentAbstract", "activateOnCurrentThread", "(", ")", "{", "final", "ODatabaseRecordThreadLocal", "tl", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ";", "if", "(", "tl", "!=", "null", ")", "tl", ".", "set", "(", "this", ")", ";", "return", "this", ";", "}"], "docstring": "Activates current database instance on current thread.", "docstring_tokens": ["Activates", "current", "database", "instance", "on", "current", "thread", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java#L2251-L2257", "partition": "test", "index": 3331, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/index/OIndexManagerShared.java", "func_name": "OIndexManagerShared.toStream", "original_string": "@Override\n  public ODocument toStream() {\n    internalAcquireExclusiveLock();\n    try {\n      document.setInternalStatus(ORecordElement.STATUS.UNMARSHALLING);\n\n      try {\n        final OTrackedSet<ODocument> indexes = new OTrackedSet<>(document);\n\n        for (final OIndex<?> i : this.indexes.values()) {\n          indexes.add(((OIndexInternal<?>) i).updateConfiguration());\n        }\n        document.field(CONFIG_INDEXES, indexes, OType.EMBEDDEDSET);\n\n      } finally {\n        document.setInternalStatus(ORecordElement.STATUS.LOADED);\n      }\n      document.setDirty();\n\n      return document;\n    } finally {\n      internalReleaseExclusiveLock();\n    }\n  }", "language": "java", "code": "@Override\n  public ODocument toStream() {\n    internalAcquireExclusiveLock();\n    try {\n      document.setInternalStatus(ORecordElement.STATUS.UNMARSHALLING);\n\n      try {\n        final OTrackedSet<ODocument> indexes = new OTrackedSet<>(document);\n\n        for (final OIndex<?> i : this.indexes.values()) {\n          indexes.add(((OIndexInternal<?>) i).updateConfiguration());\n        }\n        document.field(CONFIG_INDEXES, indexes, OType.EMBEDDEDSET);\n\n      } finally {\n        document.setInternalStatus(ORecordElement.STATUS.LOADED);\n      }\n      document.setDirty();\n\n      return document;\n    } finally {\n      internalReleaseExclusiveLock();\n    }\n  }", "code_tokens": ["@", "Override", "public", "ODocument", "toStream", "(", ")", "{", "internalAcquireExclusiveLock", "(", ")", ";", "try", "{", "document", ".", "setInternalStatus", "(", "ORecordElement", ".", "STATUS", ".", "UNMARSHALLING", ")", ";", "try", "{", "final", "OTrackedSet", "<", "ODocument", ">", "indexes", "=", "new", "OTrackedSet", "<>", "(", "document", ")", ";", "for", "(", "final", "OIndex", "<", "?", ">", "i", ":", "this", ".", "indexes", ".", "values", "(", ")", ")", "{", "indexes", ".", "add", "(", "(", "(", "OIndexInternal", "<", "?", ">", ")", "i", ")", ".", "updateConfiguration", "(", ")", ")", ";", "}", "document", ".", "field", "(", "CONFIG_INDEXES", ",", "indexes", ",", "OType", ".", "EMBEDDEDSET", ")", ";", "}", "finally", "{", "document", ".", "setInternalStatus", "(", "ORecordElement", ".", "STATUS", ".", "LOADED", ")", ";", "}", "document", ".", "setDirty", "(", ")", ";", "return", "document", ";", "}", "finally", "{", "internalReleaseExclusiveLock", "(", ")", ";", "}", "}"], "docstring": "Binds POJO to ODocument.", "docstring_tokens": ["Binds", "POJO", "to", "ODocument", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/index/OIndexManagerShared.java#L269-L292", "partition": "test", "index": 3027, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java", "func_name": "ODatabaseDocumentAbstract.delete", "original_string": "public ODatabase<ORecord> delete(final ORID iRecord, final int iVersion) {\n    ORecord record = load(iRecord);\n    ORecordInternal.setVersion(record, iVersion);\n    delete(record);\n    return this;\n  }", "language": "java", "code": "public ODatabase<ORecord> delete(final ORID iRecord, final int iVersion) {\n    ORecord record = load(iRecord);\n    ORecordInternal.setVersion(record, iVersion);\n    delete(record);\n    return this;\n  }", "code_tokens": ["public", "ODatabase", "<", "ORecord", ">", "delete", "(", "final", "ORID", "iRecord", ",", "final", "int", "iVersion", ")", "{", "ORecord", "record", "=", "load", "(", "iRecord", ")", ";", "ORecordInternal", ".", "setVersion", "(", "record", ",", "iVersion", ")", ";", "delete", "(", "record", ")", ";", "return", "this", ";", "}"], "docstring": "Deletes the record checking the version.", "docstring_tokens": ["Deletes", "the", "record", "checking", "the", "version", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java#L205-L210", "partition": "test", "index": 3326, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java", "func_name": "ODatabaseDocumentAbstract.countView", "original_string": "public long countView(final String viewName) {\n    final OView cls = getMetadata().getImmutableSchemaSnapshot().getView(viewName);\n    if (cls == null)\n      throw new IllegalArgumentException(\"View '\" + cls + \"' not found in database\");\n\n    return countClass(cls, false);\n  }", "language": "java", "code": "public long countView(final String viewName) {\n    final OView cls = getMetadata().getImmutableSchemaSnapshot().getView(viewName);\n    if (cls == null)\n      throw new IllegalArgumentException(\"View '\" + cls + \"' not found in database\");\n\n    return countClass(cls, false);\n  }", "code_tokens": ["public", "long", "countView", "(", "final", "String", "viewName", ")", "{", "final", "OView", "cls", "=", "getMetadata", "(", ")", ".", "getImmutableSchemaSnapshot", "(", ")", ".", "getView", "(", "viewName", ")", ";", "if", "(", "cls", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"View '\"", "+", "cls", "+", "\"' not found in database\"", ")", ";", "return", "countClass", "(", "cls", ",", "false", ")", ";", "}"], "docstring": "Returns the number of the records of the class iClassName.", "docstring_tokens": ["Returns", "the", "number", "of", "the", "records", "of", "the", "class", "iClassName", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java#L1907-L1913", "partition": "test", "index": 3329, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/index/OIndexFullText.java", "func_name": "OIndexFullText.put", "original_string": "@Override\n  public OIndexFullText put(Object key, final OIdentifiable singleValue) {\n    if (key == null) {\n      return this;\n    }\n\n    key = getCollatingValue(key);\n\n    final Set<String> words = splitIntoWords(key.toString());\n\n    // FOREACH WORD CREATE THE LINK TO THE CURRENT DOCUMENT\n    for (final String word : words) {\n      acquireSharedLock();\n      try {\n        if (apiVersion == 0) {\n          doPutV0(singleValue, word);\n        } else if (apiVersion == 1) {\n          doPutV1(singleValue, word);\n        } else {\n          throw new IllegalStateException(\"Invalid API version, \" + apiVersion);\n        }\n\n      } finally {\n        releaseSharedLock();\n      }\n    }\n\n    return this;\n  }", "language": "java", "code": "@Override\n  public OIndexFullText put(Object key, final OIdentifiable singleValue) {\n    if (key == null) {\n      return this;\n    }\n\n    key = getCollatingValue(key);\n\n    final Set<String> words = splitIntoWords(key.toString());\n\n    // FOREACH WORD CREATE THE LINK TO THE CURRENT DOCUMENT\n    for (final String word : words) {\n      acquireSharedLock();\n      try {\n        if (apiVersion == 0) {\n          doPutV0(singleValue, word);\n        } else if (apiVersion == 1) {\n          doPutV1(singleValue, word);\n        } else {\n          throw new IllegalStateException(\"Invalid API version, \" + apiVersion);\n        }\n\n      } finally {\n        releaseSharedLock();\n      }\n    }\n\n    return this;\n  }", "code_tokens": ["@", "Override", "public", "OIndexFullText", "put", "(", "Object", "key", ",", "final", "OIdentifiable", "singleValue", ")", "{", "if", "(", "key", "==", "null", ")", "{", "return", "this", ";", "}", "key", "=", "getCollatingValue", "(", "key", ")", ";", "final", "Set", "<", "String", ">", "words", "=", "splitIntoWords", "(", "key", ".", "toString", "(", ")", ")", ";", "// FOREACH WORD CREATE THE LINK TO THE CURRENT DOCUMENT", "for", "(", "final", "String", "word", ":", "words", ")", "{", "acquireSharedLock", "(", ")", ";", "try", "{", "if", "(", "apiVersion", "==", "0", ")", "{", "doPutV0", "(", "singleValue", ",", "word", ")", ";", "}", "else", "if", "(", "apiVersion", "==", "1", ")", "{", "doPutV1", "(", "singleValue", ",", "word", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"Invalid API version, \"", "+", "apiVersion", ")", ";", "}", "}", "finally", "{", "releaseSharedLock", "(", ")", ";", "}", "}", "return", "this", ";", "}"], "docstring": "Indexes a value and save the index. Splits the value in single words and index each one. Save of the index is responsibility of\nthe caller.", "docstring_tokens": ["Indexes", "a", "value", "and", "save", "the", "index", ".", "Splits", "the", "value", "in", "single", "words", "and", "index", "each", "one", ".", "Save", "of", "the", "index", "is", "responsibility", "of", "the", "caller", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/index/OIndexFullText.java#L79-L107", "partition": "test", "index": 2953, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/security/OSecurityShared.java", "func_name": "OSecurityShared.createMetadata", "original_string": "public OUser createMetadata() {\n    final ODatabaseDocument database = getDatabase();\n\n    OClass identityClass = database.getMetadata().getSchema().getClass(OIdentity.CLASS_NAME); // SINCE 1.2.0\n    if (identityClass == null)\n      identityClass = database.getMetadata().getSchema().createAbstractClass(OIdentity.CLASS_NAME);\n\n    OClass roleClass = createOrUpdateORoleClass(database, identityClass);\n\n    createOrUpdateOUserClass(database, identityClass, roleClass);\n\n    // CREATE ROLES AND USERS\n    ORole adminRole = getRole(ORole.ADMIN);\n    if (adminRole == null) {\n      adminRole = createRole(ORole.ADMIN, ORole.ALLOW_MODES.ALLOW_ALL_BUT);\n      adminRole.addRule(ORule.ResourceGeneric.BYPASS_RESTRICTED, null, ORole.PERMISSION_ALL).save();\n    }\n\n    OUser adminUser = getUser(OUser.ADMIN);\n\n    if (adminUser == null) {\n      // This will return the global value if a local storage context configuration value does not exist.\n      boolean createDefUsers = getDatabase().getStorage().getConfiguration().getContextConfiguration()\n          .getValueAsBoolean(OGlobalConfiguration.CREATE_DEFAULT_USERS);\n\n      if (createDefUsers) {\n        adminUser = createUser(OUser.ADMIN, OUser.ADMIN, adminRole);\n      }\n    }\n\n    // SINCE 1.2.0\n    createOrUpdateORestrictedClass(database);\n\n    return adminUser;\n  }", "language": "java", "code": "public OUser createMetadata() {\n    final ODatabaseDocument database = getDatabase();\n\n    OClass identityClass = database.getMetadata().getSchema().getClass(OIdentity.CLASS_NAME); // SINCE 1.2.0\n    if (identityClass == null)\n      identityClass = database.getMetadata().getSchema().createAbstractClass(OIdentity.CLASS_NAME);\n\n    OClass roleClass = createOrUpdateORoleClass(database, identityClass);\n\n    createOrUpdateOUserClass(database, identityClass, roleClass);\n\n    // CREATE ROLES AND USERS\n    ORole adminRole = getRole(ORole.ADMIN);\n    if (adminRole == null) {\n      adminRole = createRole(ORole.ADMIN, ORole.ALLOW_MODES.ALLOW_ALL_BUT);\n      adminRole.addRule(ORule.ResourceGeneric.BYPASS_RESTRICTED, null, ORole.PERMISSION_ALL).save();\n    }\n\n    OUser adminUser = getUser(OUser.ADMIN);\n\n    if (adminUser == null) {\n      // This will return the global value if a local storage context configuration value does not exist.\n      boolean createDefUsers = getDatabase().getStorage().getConfiguration().getContextConfiguration()\n          .getValueAsBoolean(OGlobalConfiguration.CREATE_DEFAULT_USERS);\n\n      if (createDefUsers) {\n        adminUser = createUser(OUser.ADMIN, OUser.ADMIN, adminRole);\n      }\n    }\n\n    // SINCE 1.2.0\n    createOrUpdateORestrictedClass(database);\n\n    return adminUser;\n  }", "code_tokens": ["public", "OUser", "createMetadata", "(", ")", "{", "final", "ODatabaseDocument", "database", "=", "getDatabase", "(", ")", ";", "OClass", "identityClass", "=", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "OIdentity", ".", "CLASS_NAME", ")", ";", "// SINCE 1.2.0", "if", "(", "identityClass", "==", "null", ")", "identityClass", "=", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "createAbstractClass", "(", "OIdentity", ".", "CLASS_NAME", ")", ";", "OClass", "roleClass", "=", "createOrUpdateORoleClass", "(", "database", ",", "identityClass", ")", ";", "createOrUpdateOUserClass", "(", "database", ",", "identityClass", ",", "roleClass", ")", ";", "// CREATE ROLES AND USERS", "ORole", "adminRole", "=", "getRole", "(", "ORole", ".", "ADMIN", ")", ";", "if", "(", "adminRole", "==", "null", ")", "{", "adminRole", "=", "createRole", "(", "ORole", ".", "ADMIN", ",", "ORole", ".", "ALLOW_MODES", ".", "ALLOW_ALL_BUT", ")", ";", "adminRole", ".", "addRule", "(", "ORule", ".", "ResourceGeneric", ".", "BYPASS_RESTRICTED", ",", "null", ",", "ORole", ".", "PERMISSION_ALL", ")", ".", "save", "(", ")", ";", "}", "OUser", "adminUser", "=", "getUser", "(", "OUser", ".", "ADMIN", ")", ";", "if", "(", "adminUser", "==", "null", ")", "{", "// This will return the global value if a local storage context configuration value does not exist.", "boolean", "createDefUsers", "=", "getDatabase", "(", ")", ".", "getStorage", "(", ")", ".", "getConfiguration", "(", ")", ".", "getContextConfiguration", "(", ")", ".", "getValueAsBoolean", "(", "OGlobalConfiguration", ".", "CREATE_DEFAULT_USERS", ")", ";", "if", "(", "createDefUsers", ")", "{", "adminUser", "=", "createUser", "(", "OUser", ".", "ADMIN", ",", "OUser", ".", "ADMIN", ",", "adminRole", ")", ";", "}", "}", "// SINCE 1.2.0", "createOrUpdateORestrictedClass", "(", "database", ")", ";", "return", "adminUser", ";", "}"], "docstring": "Repairs the security structure if broken by creating the ADMIN role and user with default password.\n\n@return", "docstring_tokens": ["Repairs", "the", "security", "structure", "if", "broken", "by", "creating", "the", "ADMIN", "role", "and", "user", "with", "default", "password", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/security/OSecurityShared.java#L441-L475", "partition": "test", "index": 3268, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/security/OSecurityShared.java", "func_name": "OSecurityShared.authenticate", "original_string": "public OUser authenticate(final OToken authToken) {\n    final String dbName = getDatabase().getName();\n    if (authToken.getIsValid() != true) {\n      throw new OSecurityAccessException(dbName, \"Token not valid\");\n    }\n\n    OUser user = authToken.getUser(getDatabase());\n    if (user == null && authToken.getUserName() != null) {\n      // Token handler may not support returning an OUser so let's get username (subject) and query:\n      user = getUser(authToken.getUserName());\n    }\n\n    if (user == null) {\n      throw new OSecurityAccessException(dbName, \"Authentication failed, could not load user from token\");\n    }\n    if (user.getAccountStatus() != STATUSES.ACTIVE)\n      throw new OSecurityAccessException(dbName, \"User '\" + user.getName() + \"' is not active\");\n\n    return user;\n  }", "language": "java", "code": "public OUser authenticate(final OToken authToken) {\n    final String dbName = getDatabase().getName();\n    if (authToken.getIsValid() != true) {\n      throw new OSecurityAccessException(dbName, \"Token not valid\");\n    }\n\n    OUser user = authToken.getUser(getDatabase());\n    if (user == null && authToken.getUserName() != null) {\n      // Token handler may not support returning an OUser so let's get username (subject) and query:\n      user = getUser(authToken.getUserName());\n    }\n\n    if (user == null) {\n      throw new OSecurityAccessException(dbName, \"Authentication failed, could not load user from token\");\n    }\n    if (user.getAccountStatus() != STATUSES.ACTIVE)\n      throw new OSecurityAccessException(dbName, \"User '\" + user.getName() + \"' is not active\");\n\n    return user;\n  }", "code_tokens": ["public", "OUser", "authenticate", "(", "final", "OToken", "authToken", ")", "{", "final", "String", "dbName", "=", "getDatabase", "(", ")", ".", "getName", "(", ")", ";", "if", "(", "authToken", ".", "getIsValid", "(", ")", "!=", "true", ")", "{", "throw", "new", "OSecurityAccessException", "(", "dbName", ",", "\"Token not valid\"", ")", ";", "}", "OUser", "user", "=", "authToken", ".", "getUser", "(", "getDatabase", "(", ")", ")", ";", "if", "(", "user", "==", "null", "&&", "authToken", ".", "getUserName", "(", ")", "!=", "null", ")", "{", "// Token handler may not support returning an OUser so let's get username (subject) and query:", "user", "=", "getUser", "(", "authToken", ".", "getUserName", "(", ")", ")", ";", "}", "if", "(", "user", "==", "null", ")", "{", "throw", "new", "OSecurityAccessException", "(", "dbName", ",", "\"Authentication failed, could not load user from token\"", ")", ";", "}", "if", "(", "user", ".", "getAccountStatus", "(", ")", "!=", "STATUSES", ".", "ACTIVE", ")", "throw", "new", "OSecurityAccessException", "(", "dbName", ",", "\"User '\"", "+", "user", ".", "getName", "(", ")", "+", "\"' is not active\"", ")", ";", "return", "user", ";", "}"], "docstring": "Token MUST be validated before being passed to this method.", "docstring_tokens": ["Token", "MUST", "be", "validated", "before", "being", "passed", "to", "this", "method", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/metadata/security/OSecurityShared.java#L260-L279", "partition": "test", "index": 3267, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/index/OIndexFullText.java", "func_name": "OIndexFullText.remove", "original_string": "@Override\n  public boolean remove(Object key, final OIdentifiable value) {\n    if (key == null) {\n      return false;\n    }\n\n    key = getCollatingValue(key);\n\n    final Set<String> words = splitIntoWords(key.toString());\n    final OModifiableBoolean removed = new OModifiableBoolean(false);\n\n    for (final String word : words) {\n      acquireSharedLock();\n      try {\n        if (apiVersion == 0) {\n          removeV0(value, removed, word);\n        } else if (apiVersion == 1) {\n          removeV1(value, removed, word);\n        } else {\n          throw new IllegalStateException(\"Invalid API version, \" + apiVersion);\n        }\n      } finally {\n        releaseSharedLock();\n      }\n    }\n\n    return removed.getValue();\n  }", "language": "java", "code": "@Override\n  public boolean remove(Object key, final OIdentifiable value) {\n    if (key == null) {\n      return false;\n    }\n\n    key = getCollatingValue(key);\n\n    final Set<String> words = splitIntoWords(key.toString());\n    final OModifiableBoolean removed = new OModifiableBoolean(false);\n\n    for (final String word : words) {\n      acquireSharedLock();\n      try {\n        if (apiVersion == 0) {\n          removeV0(value, removed, word);\n        } else if (apiVersion == 1) {\n          removeV1(value, removed, word);\n        } else {\n          throw new IllegalStateException(\"Invalid API version, \" + apiVersion);\n        }\n      } finally {\n        releaseSharedLock();\n      }\n    }\n\n    return removed.getValue();\n  }", "code_tokens": ["@", "Override", "public", "boolean", "remove", "(", "Object", "key", ",", "final", "OIdentifiable", "value", ")", "{", "if", "(", "key", "==", "null", ")", "{", "return", "false", ";", "}", "key", "=", "getCollatingValue", "(", "key", ")", ";", "final", "Set", "<", "String", ">", "words", "=", "splitIntoWords", "(", "key", ".", "toString", "(", ")", ")", ";", "final", "OModifiableBoolean", "removed", "=", "new", "OModifiableBoolean", "(", "false", ")", ";", "for", "(", "final", "String", "word", ":", "words", ")", "{", "acquireSharedLock", "(", ")", ";", "try", "{", "if", "(", "apiVersion", "==", "0", ")", "{", "removeV0", "(", "value", ",", "removed", ",", "word", ")", ";", "}", "else", "if", "(", "apiVersion", "==", "1", ")", "{", "removeV1", "(", "value", ",", "removed", ",", "word", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"Invalid API version, \"", "+", "apiVersion", ")", ";", "}", "}", "finally", "{", "releaseSharedLock", "(", ")", ";", "}", "}", "return", "removed", ".", "getValue", "(", ")", ";", "}"], "docstring": "Splits passed in key on several words and remove records with keys equals to any item of split result and values equals to\npassed in value.\n\n@param key   Key to remove.\n@param value Value to remove.\n\n@return <code>true</code> if at least one record is removed.", "docstring_tokens": ["Splits", "passed", "in", "key", "on", "several", "words", "and", "remove", "records", "with", "keys", "equals", "to", "any", "item", "of", "split", "result", "and", "values", "equals", "to", "passed", "in", "value", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/index/OIndexFullText.java#L177-L204", "partition": "test", "index": 2954, "time": "2019-01-22 14:19:10"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/config/OStorageConfigurationImpl.java", "func_name": "OStorageConfigurationImpl.load", "original_string": "public OStorageConfigurationImpl load(final OContextConfiguration configuration) throws OSerializationException {\n    lock.acquireWriteLock();\n    try {\n      initConfiguration(configuration);\n\n      final byte[] record = storage.readRecord(CONFIG_RID, null, false, false, null).getResult().buffer;\n\n      if (record == null)\n        throw new OStorageException(\"Cannot load database configuration. The database seems corrupted\");\n\n      fromStream(record, 0, record.length, streamCharset);\n    } finally {\n      lock.releaseWriteLock();\n    }\n\n    return this;\n  }", "language": "java", "code": "public OStorageConfigurationImpl load(final OContextConfiguration configuration) throws OSerializationException {\n    lock.acquireWriteLock();\n    try {\n      initConfiguration(configuration);\n\n      final byte[] record = storage.readRecord(CONFIG_RID, null, false, false, null).getResult().buffer;\n\n      if (record == null)\n        throw new OStorageException(\"Cannot load database configuration. The database seems corrupted\");\n\n      fromStream(record, 0, record.length, streamCharset);\n    } finally {\n      lock.releaseWriteLock();\n    }\n\n    return this;\n  }", "code_tokens": ["public", "OStorageConfigurationImpl", "load", "(", "final", "OContextConfiguration", "configuration", ")", "throws", "OSerializationException", "{", "lock", ".", "acquireWriteLock", "(", ")", ";", "try", "{", "initConfiguration", "(", "configuration", ")", ";", "final", "byte", "[", "]", "record", "=", "storage", ".", "readRecord", "(", "CONFIG_RID", ",", "null", ",", "false", ",", "false", ",", "null", ")", ".", "getResult", "(", ")", ".", "buffer", ";", "if", "(", "record", "==", "null", ")", "throw", "new", "OStorageException", "(", "\"Cannot load database configuration. The database seems corrupted\"", ")", ";", "fromStream", "(", "record", ",", "0", ",", "record", ".", "length", ",", "streamCharset", ")", ";", "}", "finally", "{", "lock", ".", "releaseWriteLock", "(", ")", ";", "}", "return", "this", ";", "}"], "docstring": "This method load the record information by the internal cluster segment. It's for compatibility with older database than\n0.9.25.", "docstring_tokens": ["This", "method", "load", "the", "record", "information", "by", "the", "internal", "cluster", "segment", ".", "It", "s", "for", "compatibility", "with", "older", "database", "than", "0", ".", "9", ".", "25", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/config/OStorageConfigurationImpl.java#L287-L303", "partition": "test", "index": 2987, "time": "2019-01-22 17:29:29"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponse.java", "func_name": "OHttpResponse.compress", "original_string": "public byte[] compress(String jsonStr) {\n    if (jsonStr == null || jsonStr.length() == 0) {\n      return null;\n    }\n    GZIPOutputStream gout = null;\n    ByteArrayOutputStream baos = null;\n    try {\n      byte[] incoming = jsonStr.getBytes(\"UTF-8\");\n      baos = new ByteArrayOutputStream();\n      gout = new GZIPOutputStream(baos, 16384); // 16KB\n      gout.write(incoming);\n      gout.finish();\n      return baos.toByteArray();\n    } catch (Exception ex) {\n      OLogManager.instance().error(this, \"Error on compressing HTTP response\", ex);\n    } finally {\n      try {\n        if (gout != null) {\n          gout.close();\n        }\n        if (baos != null) {\n          baos.close();\n        }\n      } catch (Exception ex) {\n      }\n    }\n    return null;\n  }", "language": "java", "code": "public byte[] compress(String jsonStr) {\n    if (jsonStr == null || jsonStr.length() == 0) {\n      return null;\n    }\n    GZIPOutputStream gout = null;\n    ByteArrayOutputStream baos = null;\n    try {\n      byte[] incoming = jsonStr.getBytes(\"UTF-8\");\n      baos = new ByteArrayOutputStream();\n      gout = new GZIPOutputStream(baos, 16384); // 16KB\n      gout.write(incoming);\n      gout.finish();\n      return baos.toByteArray();\n    } catch (Exception ex) {\n      OLogManager.instance().error(this, \"Error on compressing HTTP response\", ex);\n    } finally {\n      try {\n        if (gout != null) {\n          gout.close();\n        }\n        if (baos != null) {\n          baos.close();\n        }\n      } catch (Exception ex) {\n      }\n    }\n    return null;\n  }", "code_tokens": ["public", "byte", "[", "]", "compress", "(", "String", "jsonStr", ")", "{", "if", "(", "jsonStr", "==", "null", "||", "jsonStr", ".", "length", "(", ")", "==", "0", ")", "{", "return", "null", ";", "}", "GZIPOutputStream", "gout", "=", "null", ";", "ByteArrayOutputStream", "baos", "=", "null", ";", "try", "{", "byte", "[", "]", "incoming", "=", "jsonStr", ".", "getBytes", "(", "\"UTF-8\"", ")", ";", "baos", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "gout", "=", "new", "GZIPOutputStream", "(", "baos", ",", "16384", ")", ";", "// 16KB", "gout", ".", "write", "(", "incoming", ")", ";", "gout", ".", "finish", "(", ")", ";", "return", "baos", ".", "toByteArray", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error on compressing HTTP response\"", ",", "ex", ")", ";", "}", "finally", "{", "try", "{", "if", "(", "gout", "!=", "null", ")", "{", "gout", ".", "close", "(", ")", ";", "}", "if", "(", "baos", "!=", "null", ")", "{", "baos", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "}", "}", "return", "null", ";", "}"], "docstring": "Compress content string", "docstring_tokens": ["Compress", "content", "string"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponse.java#L557-L584", "partition": "test", "index": 3137, "time": "2019-01-25 07:57:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/Orient.java", "func_name": "Orient.initShutdownQueue", "original_string": "private void initShutdownQueue() {\n    addShutdownHandler(new OShutdownWorkersHandler());\n    addShutdownHandler(new OShutdownOrientDBInstancesHandler());\n    addShutdownHandler(new OShutdownPendingThreadsHandler());\n    addShutdownHandler(new OShutdownProfilerHandler());\n    addShutdownHandler(new OShutdownCallListenersHandler());\n  }", "language": "java", "code": "private void initShutdownQueue() {\n    addShutdownHandler(new OShutdownWorkersHandler());\n    addShutdownHandler(new OShutdownOrientDBInstancesHandler());\n    addShutdownHandler(new OShutdownPendingThreadsHandler());\n    addShutdownHandler(new OShutdownProfilerHandler());\n    addShutdownHandler(new OShutdownCallListenersHandler());\n  }", "code_tokens": ["private", "void", "initShutdownQueue", "(", ")", "{", "addShutdownHandler", "(", "new", "OShutdownWorkersHandler", "(", ")", ")", ";", "addShutdownHandler", "(", "new", "OShutdownOrientDBInstancesHandler", "(", ")", ")", ";", "addShutdownHandler", "(", "new", "OShutdownPendingThreadsHandler", "(", ")", ")", ";", "addShutdownHandler", "(", "new", "OShutdownProfilerHandler", "(", ")", ")", ";", "addShutdownHandler", "(", "new", "OShutdownCallListenersHandler", "(", ")", ")", ";", "}"], "docstring": "Adds shutdown handlers in order which will be used during execution of shutdown.", "docstring_tokens": ["Adds", "shutdown", "handlers", "in", "order", "which", "will", "be", "used", "during", "execution", "of", "shutdown", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/Orient.java#L349-L355", "partition": "test", "index": 3262, "time": "2019-01-25 07:57:21"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OStorageRemote.java", "func_name": "OStorageRemote.command", "original_string": "public Object command(final OCommandRequestText iCommand) {\n\n    final boolean live = iCommand instanceof OLiveQuery;\n    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();\n    final boolean asynch = iCommand instanceof OCommandRequestAsynch && ((OCommandRequestAsynch) iCommand).isAsynchronous();\n\n    OCommandRequest request = new OCommandRequest(database, asynch, iCommand, live);\n    OCommandResponse response = networkOperation(request, \"Error on executing command: \" + iCommand);\n    return response.getResult();\n\n  }", "language": "java", "code": "public Object command(final OCommandRequestText iCommand) {\n\n    final boolean live = iCommand instanceof OLiveQuery;\n    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();\n    final boolean asynch = iCommand instanceof OCommandRequestAsynch && ((OCommandRequestAsynch) iCommand).isAsynchronous();\n\n    OCommandRequest request = new OCommandRequest(database, asynch, iCommand, live);\n    OCommandResponse response = networkOperation(request, \"Error on executing command: \" + iCommand);\n    return response.getResult();\n\n  }", "code_tokens": ["public", "Object", "command", "(", "final", "OCommandRequestText", "iCommand", ")", "{", "final", "boolean", "live", "=", "iCommand", "instanceof", "OLiveQuery", ";", "final", "ODatabaseDocumentInternal", "database", "=", "ODatabaseRecordThreadLocal", ".", "instance", "(", ")", ".", "get", "(", ")", ";", "final", "boolean", "asynch", "=", "iCommand", "instanceof", "OCommandRequestAsynch", "&&", "(", "(", "OCommandRequestAsynch", ")", "iCommand", ")", ".", "isAsynchronous", "(", ")", ";", "OCommandRequest", "request", "=", "new", "OCommandRequest", "(", "database", ",", "asynch", ",", "iCommand", ",", "live", ")", ";", "OCommandResponse", "response", "=", "networkOperation", "(", "request", ",", "\"Error on executing command: \"", "+", "iCommand", ")", ";", "return", "response", ".", "getResult", "(", ")", ";", "}"], "docstring": "Execute the command remotely and get the results back.", "docstring_tokens": ["Execute", "the", "command", "remotely", "and", "get", "the", "results", "back", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OStorageRemote.java#L992-L1002", "partition": "test", "index": 2960, "time": "2019-01-25 07:57:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/Orient.java", "func_name": "Orient.getEngine", "original_string": "public OEngine getEngine(final String engineName) {\n    engineLock.readLock().lock();\n    try {\n      return engines.get(engineName);\n    } finally {\n      engineLock.readLock().unlock();\n    }\n  }", "language": "java", "code": "public OEngine getEngine(final String engineName) {\n    engineLock.readLock().lock();\n    try {\n      return engines.get(engineName);\n    } finally {\n      engineLock.readLock().unlock();\n    }\n  }", "code_tokens": ["public", "OEngine", "getEngine", "(", "final", "String", "engineName", ")", "{", "engineLock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "try", "{", "return", "engines", ".", "get", "(", "engineName", ")", ";", "}", "finally", "{", "engineLock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Returns the engine by its name.\n\n@param engineName Engine name to retrieve\n\n@return OEngine instance of found, otherwise null", "docstring_tokens": ["Returns", "the", "engine", "by", "its", "name", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/Orient.java#L554-L561", "partition": "test", "index": 3263, "time": "2019-01-25 07:57:21"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OStorageRemote.java", "func_name": "OStorageRemote.endRequest", "original_string": "public void endRequest(final OChannelBinaryAsynchClient iNetwork) throws IOException {\n    if (iNetwork == null)\n      return;\n\n    iNetwork.flush();\n    iNetwork.releaseWriteLock();\n\n  }", "language": "java", "code": "public void endRequest(final OChannelBinaryAsynchClient iNetwork) throws IOException {\n    if (iNetwork == null)\n      return;\n\n    iNetwork.flush();\n    iNetwork.releaseWriteLock();\n\n  }", "code_tokens": ["public", "void", "endRequest", "(", "final", "OChannelBinaryAsynchClient", "iNetwork", ")", "throws", "IOException", "{", "if", "(", "iNetwork", "==", "null", ")", "return", ";", "iNetwork", ".", "flush", "(", ")", ";", "iNetwork", ".", "releaseWriteLock", "(", ")", ";", "}"], "docstring": "Ends the request and unlock the write lock", "docstring_tokens": ["Ends", "the", "request", "and", "unlock", "the", "write", "lock"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OStorageRemote.java#L1325-L1332", "partition": "test", "index": 2961, "time": "2019-01-25 07:57:21"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OStorageRemote.java", "func_name": "OStorageRemote.addHost", "original_string": "protected String addHost(String host) {\n    if (host.startsWith(LOCALHOST))\n      host = LOCAL_IP + host.substring(\"localhost\".length());\n\n    if (host.contains(\"/\"))\n      host = host.substring(0, host.indexOf(\"/\"));\n\n    // REGISTER THE REMOTE SERVER+PORT\n    if (!host.contains(\":\"))\n      host += \":\" + (clientConfiguration.getValueAsBoolean(OGlobalConfiguration.CLIENT_USE_SSL) ?\n          getDefaultSSLPort() :\n          getDefaultPort());\n    else if (host.split(\":\").length < 2 || host.split(\":\")[1].trim().length() == 0)\n      host += (clientConfiguration.getValueAsBoolean(OGlobalConfiguration.CLIENT_USE_SSL) ? getDefaultSSLPort() : getDefaultPort());\n\n    // DISABLED BECAUSE THIS DID NOT ALLOW TO CONNECT TO LOCAL HOST ANYMORE IF THE SERVER IS BOUND TO 127.0.0.1\n    // CONVERT 127.0.0.1 TO THE PUBLIC IP IF POSSIBLE\n    // if (host.startsWith(LOCAL_IP)) {\n    // try {\n    // final String publicIP = InetAddress.getLocalHost().getHostAddress();\n    // host = publicIP + host.substring(LOCAL_IP.length());\n    // } catch (UnknownHostException e) {\n    // // IGNORE IT\n    // }\n    // }\n\n    synchronized (serverURLs) {\n      if (!serverURLs.contains(host)) {\n        serverURLs.add(host);\n        OLogManager.instance().debug(this, \"Registered the new available server '%s'\", host);\n      }\n    }\n\n    return host;\n  }", "language": "java", "code": "protected String addHost(String host) {\n    if (host.startsWith(LOCALHOST))\n      host = LOCAL_IP + host.substring(\"localhost\".length());\n\n    if (host.contains(\"/\"))\n      host = host.substring(0, host.indexOf(\"/\"));\n\n    // REGISTER THE REMOTE SERVER+PORT\n    if (!host.contains(\":\"))\n      host += \":\" + (clientConfiguration.getValueAsBoolean(OGlobalConfiguration.CLIENT_USE_SSL) ?\n          getDefaultSSLPort() :\n          getDefaultPort());\n    else if (host.split(\":\").length < 2 || host.split(\":\")[1].trim().length() == 0)\n      host += (clientConfiguration.getValueAsBoolean(OGlobalConfiguration.CLIENT_USE_SSL) ? getDefaultSSLPort() : getDefaultPort());\n\n    // DISABLED BECAUSE THIS DID NOT ALLOW TO CONNECT TO LOCAL HOST ANYMORE IF THE SERVER IS BOUND TO 127.0.0.1\n    // CONVERT 127.0.0.1 TO THE PUBLIC IP IF POSSIBLE\n    // if (host.startsWith(LOCAL_IP)) {\n    // try {\n    // final String publicIP = InetAddress.getLocalHost().getHostAddress();\n    // host = publicIP + host.substring(LOCAL_IP.length());\n    // } catch (UnknownHostException e) {\n    // // IGNORE IT\n    // }\n    // }\n\n    synchronized (serverURLs) {\n      if (!serverURLs.contains(host)) {\n        serverURLs.add(host);\n        OLogManager.instance().debug(this, \"Registered the new available server '%s'\", host);\n      }\n    }\n\n    return host;\n  }", "code_tokens": ["protected", "String", "addHost", "(", "String", "host", ")", "{", "if", "(", "host", ".", "startsWith", "(", "LOCALHOST", ")", ")", "host", "=", "LOCAL_IP", "+", "host", ".", "substring", "(", "\"localhost\"", ".", "length", "(", ")", ")", ";", "if", "(", "host", ".", "contains", "(", "\"/\"", ")", ")", "host", "=", "host", ".", "substring", "(", "0", ",", "host", ".", "indexOf", "(", "\"/\"", ")", ")", ";", "// REGISTER THE REMOTE SERVER+PORT", "if", "(", "!", "host", ".", "contains", "(", "\":\"", ")", ")", "host", "+=", "\":\"", "+", "(", "clientConfiguration", ".", "getValueAsBoolean", "(", "OGlobalConfiguration", ".", "CLIENT_USE_SSL", ")", "?", "getDefaultSSLPort", "(", ")", ":", "getDefaultPort", "(", ")", ")", ";", "else", "if", "(", "host", ".", "split", "(", "\":\"", ")", ".", "length", "<", "2", "||", "host", ".", "split", "(", "\":\"", ")", "[", "1", "]", ".", "trim", "(", ")", ".", "length", "(", ")", "==", "0", ")", "host", "+=", "(", "clientConfiguration", ".", "getValueAsBoolean", "(", "OGlobalConfiguration", ".", "CLIENT_USE_SSL", ")", "?", "getDefaultSSLPort", "(", ")", ":", "getDefaultPort", "(", ")", ")", ";", "// DISABLED BECAUSE THIS DID NOT ALLOW TO CONNECT TO LOCAL HOST ANYMORE IF THE SERVER IS BOUND TO 127.0.0.1", "// CONVERT 127.0.0.1 TO THE PUBLIC IP IF POSSIBLE", "// if (host.startsWith(LOCAL_IP)) {", "// try {", "// final String publicIP = InetAddress.getLocalHost().getHostAddress();", "// host = publicIP + host.substring(LOCAL_IP.length());", "// } catch (UnknownHostException e) {", "// // IGNORE IT", "// }", "// }", "synchronized", "(", "serverURLs", ")", "{", "if", "(", "!", "serverURLs", ".", "contains", "(", "host", ")", ")", "{", "serverURLs", ".", "add", "(", "host", ")", ";", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Registered the new available server '%s'\"", ",", "host", ")", ";", "}", "}", "return", "host", ";", "}"], "docstring": "Registers the remote server with port.", "docstring_tokens": ["Registers", "the", "remote", "server", "with", "port", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OStorageRemote.java#L1812-L1846", "partition": "test", "index": 2962, "time": "2019-01-25 07:57:21"}
{"repo": "orientechnologies/orientdb", "path": "client/src/main/java/com/orientechnologies/orient/client/remote/OStorageRemote.java", "func_name": "OStorageRemote.beginRequest", "original_string": "public OChannelBinaryAsynchClient beginRequest(final OChannelBinaryAsynchClient network, final byte iCommand,\n      OStorageRemoteSession session) throws IOException {\n    network.beginRequest(iCommand, session);\n    return network;\n  }", "language": "java", "code": "public OChannelBinaryAsynchClient beginRequest(final OChannelBinaryAsynchClient network, final byte iCommand,\n      OStorageRemoteSession session) throws IOException {\n    network.beginRequest(iCommand, session);\n    return network;\n  }", "code_tokens": ["public", "OChannelBinaryAsynchClient", "beginRequest", "(", "final", "OChannelBinaryAsynchClient", "network", ",", "final", "byte", "iCommand", ",", "OStorageRemoteSession", "session", ")", "throws", "IOException", "{", "network", ".", "beginRequest", "(", "iCommand", ",", "session", ")", ";", "return", "network", ";", "}"], "docstring": "Acquire a network channel from the pool. Don't lock the write stream since the connection usage is exclusive.\n\n@param iCommand id. Ids described at {@link OChannelBinaryProtocol}\n\n@return connection to server", "docstring_tokens": ["Acquire", "a", "network", "channel", "from", "the", "pool", ".", "Don", "t", "lock", "the", "write", "stream", "since", "the", "connection", "usage", "is", "exclusive", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/client/src/main/java/com/orientechnologies/orient/client/remote/OStorageRemote.java#L1863-L1867", "partition": "test", "index": 2963, "time": "2019-01-25 07:57:21"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/readbuffer/StripedBuffer.java", "func_name": "StripedBuffer.advanceProbe", "original_string": "private int advanceProbe(int probe) {\n    probe ^= probe << 13; // xorshift\n    probe ^= probe >>> 17;\n    probe ^= probe << 5;\n\n    this.probe.get().set(probe);\n    return probe;\n  }", "language": "java", "code": "private int advanceProbe(int probe) {\n    probe ^= probe << 13; // xorshift\n    probe ^= probe >>> 17;\n    probe ^= probe << 5;\n\n    this.probe.get().set(probe);\n    return probe;\n  }", "code_tokens": ["private", "int", "advanceProbe", "(", "int", "probe", ")", "{", "probe", "^=", "probe", "<<", "13", ";", "// xorshift", "probe", "^=", "probe", ">>>", "17", ";", "probe", "^=", "probe", "<<", "5", ";", "this", ".", "probe", ".", "get", "(", ")", ".", "set", "(", "probe", ")", ";", "return", "probe", ";", "}"], "docstring": "Pseudo-randomly advances and records the given probe value for the given thread.", "docstring_tokens": ["Pseudo", "-", "randomly", "advances", "and", "records", "the", "given", "probe", "value", "for", "the", "given", "thread", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/readbuffer/StripedBuffer.java#L135-L142", "partition": "test", "index": 2996, "time": "2019-02-07 10:00:24"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/FrequencySketch.java", "func_name": "FrequencySketch.indexOf", "original_string": "private int indexOf(final int item, final int i) {\n    long hash = SEED[i] * item;\n    hash += hash >> 32;\n    return ((int) hash) & tableMask;\n  }", "language": "java", "code": "private int indexOf(final int item, final int i) {\n    long hash = SEED[i] * item;\n    hash += hash >> 32;\n    return ((int) hash) & tableMask;\n  }", "code_tokens": ["private", "int", "indexOf", "(", "final", "int", "item", ",", "final", "int", "i", ")", "{", "long", "hash", "=", "SEED", "[", "i", "]", "*", "item", ";", "hash", "+=", "hash", ">>", "32", ";", "return", "(", "(", "int", ")", "hash", ")", "&", "tableMask", ";", "}"], "docstring": "Returns the table index for the counter at the specified depth.\n\n@param item the element's hash\n@param i    the counter depth\n\n@return the table index", "docstring_tokens": ["Returns", "the", "table", "index", "for", "the", "counter", "at", "the", "specified", "depth", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/FrequencySketch.java#L173-L177", "partition": "test", "index": 3021, "time": "2019-02-07 10:00:24"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/FrequencySketch.java", "func_name": "FrequencySketch.reset", "original_string": "private void reset() {\n    int count = 0;\n    for (int i = 0; i < table.length; i++) {\n      count += Long.bitCount(table[i] & ONE_MASK);\n      table[i] = (table[i] >>> 1) & RESET_MASK;\n    }\n    size = (size >>> 1) - (count >>> 2);\n  }", "language": "java", "code": "private void reset() {\n    int count = 0;\n    for (int i = 0; i < table.length; i++) {\n      count += Long.bitCount(table[i] & ONE_MASK);\n      table[i] = (table[i] >>> 1) & RESET_MASK;\n    }\n    size = (size >>> 1) - (count >>> 2);\n  }", "code_tokens": ["private", "void", "reset", "(", ")", "{", "int", "count", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "table", ".", "length", ";", "i", "++", ")", "{", "count", "+=", "Long", ".", "bitCount", "(", "table", "[", "i", "]", "&", "ONE_MASK", ")", ";", "table", "[", "i", "]", "=", "(", "table", "[", "i", "]", ">>>", "1", ")", "&", "RESET_MASK", ";", "}", "size", "=", "(", "size", ">>>", "1", ")", "-", "(", "count", ">>>", "2", ")", ";", "}"], "docstring": "Reduces every counter by half of its original value.", "docstring_tokens": ["Reduces", "every", "counter", "by", "half", "of", "its", "original", "value", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/FrequencySketch.java#L156-L163", "partition": "test", "index": 3020, "time": "2019-02-07 10:00:24"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/FrequencySketch.java", "func_name": "FrequencySketch.spread", "original_string": "private int spread(int x) {\n    x = ((x >>> 16) ^ x) * 0x45d9f3b;\n    x = ((x >>> 16) ^ x) * randomSeed;\n    return (x >>> 16) ^ x;\n  }", "language": "java", "code": "private int spread(int x) {\n    x = ((x >>> 16) ^ x) * 0x45d9f3b;\n    x = ((x >>> 16) ^ x) * randomSeed;\n    return (x >>> 16) ^ x;\n  }", "code_tokens": ["private", "int", "spread", "(", "int", "x", ")", "{", "x", "=", "(", "(", "x", ">>>", "16", ")", "^", "x", ")", "*", "0x45d9f3b", ";", "x", "=", "(", "(", "x", ">>>", "16", ")", "^", "x", ")", "*", "randomSeed", ";", "return", "(", "x", ">>>", "16", ")", "^", "x", ";", "}"], "docstring": "Applies a supplemental hash function to a given hashCode, which defends against poor quality\nhash functions.", "docstring_tokens": ["Applies", "a", "supplemental", "hash", "function", "to", "a", "given", "hashCode", "which", "defends", "against", "poor", "quality", "hash", "functions", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/FrequencySketch.java#L183-L187", "partition": "test", "index": 3022, "time": "2019-02-07 10:00:24"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java", "func_name": "OClientConnectionManager.getConnection", "original_string": "public OClientConnection getConnection(final int iChannelId, ONetworkProtocol protocol) {\n    // SEARCH THE CONNECTION BY ID\n    OClientConnection connection = connections.get(iChannelId);\n    if (connection != null)\n      connection.setProtocol(protocol);\n\n    return connection;\n  }", "language": "java", "code": "public OClientConnection getConnection(final int iChannelId, ONetworkProtocol protocol) {\n    // SEARCH THE CONNECTION BY ID\n    OClientConnection connection = connections.get(iChannelId);\n    if (connection != null)\n      connection.setProtocol(protocol);\n\n    return connection;\n  }", "code_tokens": ["public", "OClientConnection", "getConnection", "(", "final", "int", "iChannelId", ",", "ONetworkProtocol", "protocol", ")", "{", "// SEARCH THE CONNECTION BY ID", "OClientConnection", "connection", "=", "connections", ".", "get", "(", "iChannelId", ")", ";", "if", "(", "connection", "!=", "null", ")", "connection", ".", "setProtocol", "(", "protocol", ")", ";", "return", "connection", ";", "}"], "docstring": "Retrieves the connection by id.\n\n@param iChannelId id of connection\n\n@return The connection if any, otherwise null", "docstring_tokens": ["Retrieves", "the", "connection", "by", "id", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java#L213-L220", "partition": "test", "index": 2965, "time": "2019-02-11 18:14:55"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java", "func_name": "OClientConnectionManager.interrupt", "original_string": "public void interrupt(final int iChannelId) {\n    final OClientConnection connection = connections.get(iChannelId);\n    if (connection != null) {\n      final ONetworkProtocol protocol = connection.getProtocol();\n      if (protocol != null)\n        // INTERRUPT THE NEWTORK MANAGER\n        protocol.softShutdown();\n    }\n  }", "language": "java", "code": "public void interrupt(final int iChannelId) {\n    final OClientConnection connection = connections.get(iChannelId);\n    if (connection != null) {\n      final ONetworkProtocol protocol = connection.getProtocol();\n      if (protocol != null)\n        // INTERRUPT THE NEWTORK MANAGER\n        protocol.softShutdown();\n    }\n  }", "code_tokens": ["public", "void", "interrupt", "(", "final", "int", "iChannelId", ")", "{", "final", "OClientConnection", "connection", "=", "connections", ".", "get", "(", "iChannelId", ")", ";", "if", "(", "connection", "!=", "null", ")", "{", "final", "ONetworkProtocol", "protocol", "=", "connection", ".", "getProtocol", "(", ")", ";", "if", "(", "protocol", "!=", "null", ")", "// INTERRUPT THE NEWTORK MANAGER", "protocol", ".", "softShutdown", "(", ")", ";", "}", "}"], "docstring": "Interrupt the associated network manager.\n\n@param iChannelId id of connection", "docstring_tokens": ["Interrupt", "the", "associated", "network", "manager", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java#L278-L286", "partition": "test", "index": 2967, "time": "2019-02-11 18:14:55"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java", "func_name": "OClientConnectionManager.disconnect", "original_string": "public boolean disconnect(final int iChannelId) {\n    OLogManager.instance().debug(this, \"Disconnecting connection with id=%d\", iChannelId);\n\n    final OClientConnection connection = connections.remove(iChannelId);\n\n    if (connection != null) {\n      OServerPluginHelper.invokeHandlerCallbackOnClientDisconnection(server, connection);\n      connection.close();\n      removeConnectionFromSession(connection);\n\n      // CHECK IF THERE ARE OTHER CONNECTIONS\n      for (Entry<Integer, OClientConnection> entry : connections.entrySet()) {\n        if (entry.getValue().getProtocol().equals(connection.getProtocol())) {\n          OLogManager.instance()\n              .debug(this, \"Disconnected connection with id=%d but are present other active channels\", iChannelId);\n          return false;\n        }\n      }\n\n      OLogManager.instance().debug(this, \"Disconnected connection with id=%d, no other active channels found\", iChannelId);\n      return true;\n    }\n\n    OLogManager.instance().debug(this, \"Cannot find connection with id=%d\", iChannelId);\n    return false;\n  }", "language": "java", "code": "public boolean disconnect(final int iChannelId) {\n    OLogManager.instance().debug(this, \"Disconnecting connection with id=%d\", iChannelId);\n\n    final OClientConnection connection = connections.remove(iChannelId);\n\n    if (connection != null) {\n      OServerPluginHelper.invokeHandlerCallbackOnClientDisconnection(server, connection);\n      connection.close();\n      removeConnectionFromSession(connection);\n\n      // CHECK IF THERE ARE OTHER CONNECTIONS\n      for (Entry<Integer, OClientConnection> entry : connections.entrySet()) {\n        if (entry.getValue().getProtocol().equals(connection.getProtocol())) {\n          OLogManager.instance()\n              .debug(this, \"Disconnected connection with id=%d but are present other active channels\", iChannelId);\n          return false;\n        }\n      }\n\n      OLogManager.instance().debug(this, \"Disconnected connection with id=%d, no other active channels found\", iChannelId);\n      return true;\n    }\n\n    OLogManager.instance().debug(this, \"Cannot find connection with id=%d\", iChannelId);\n    return false;\n  }", "code_tokens": ["public", "boolean", "disconnect", "(", "final", "int", "iChannelId", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Disconnecting connection with id=%d\"", ",", "iChannelId", ")", ";", "final", "OClientConnection", "connection", "=", "connections", ".", "remove", "(", "iChannelId", ")", ";", "if", "(", "connection", "!=", "null", ")", "{", "OServerPluginHelper", ".", "invokeHandlerCallbackOnClientDisconnection", "(", "server", ",", "connection", ")", ";", "connection", ".", "close", "(", ")", ";", "removeConnectionFromSession", "(", "connection", ")", ";", "// CHECK IF THERE ARE OTHER CONNECTIONS", "for", "(", "Entry", "<", "Integer", ",", "OClientConnection", ">", "entry", ":", "connections", ".", "entrySet", "(", ")", ")", "{", "if", "(", "entry", ".", "getValue", "(", ")", ".", "getProtocol", "(", ")", ".", "equals", "(", "connection", ".", "getProtocol", "(", ")", ")", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Disconnected connection with id=%d but are present other active channels\"", ",", "iChannelId", ")", ";", "return", "false", ";", "}", "}", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Disconnected connection with id=%d, no other active channels found\"", ",", "iChannelId", ")", ";", "return", "true", ";", "}", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Cannot find connection with id=%d\"", ",", "iChannelId", ")", ";", "return", "false", ";", "}"], "docstring": "Disconnects a client connections\n\n@param iChannelId id of connection\n\n@return true if was last one, otherwise false", "docstring_tokens": ["Disconnects", "a", "client", "connections"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java#L295-L320", "partition": "test", "index": 2968, "time": "2019-02-11 18:14:55"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java", "func_name": "OClientConnectionManager.pushDistribCfg2Clients", "original_string": "public void pushDistribCfg2Clients(final ODocument iConfig) {\n    if (iConfig == null)\n      return;\n\n    final Set<String> pushed = new HashSet<String>();\n    for (OClientConnection c : connections.values()) {\n      if (!c.getData().supportsLegacyPushMessages)\n        continue;\n\n      try {\n        final String remoteAddress = c.getRemoteAddress();\n        if (pushed.contains(remoteAddress))\n          // ALREADY SENT: JUMP IT\n          continue;\n\n      } catch (Exception e) {\n        // SOCKET EXCEPTION SKIP IT\n        continue;\n      }\n\n      if (!(c.getProtocol() instanceof ONetworkProtocolBinary) || c.getData().getSerializationImpl() == null)\n        // INVOLVE ONLY BINARY PROTOCOLS\n        continue;\n\n      final ONetworkProtocolBinary p = (ONetworkProtocolBinary) c.getProtocol();\n      final OChannelBinary channel = p.getChannel();\n      final ORecordSerializer ser = ORecordSerializerFactory.instance().getFormat(c.getData().getSerializationImpl());\n      if (ser == null)\n        return;\n\n      final byte[] content = ser.toStream(iConfig, false);\n\n      try {\n        // TRY ACQUIRING THE LOCK FOR MAXIMUM 3 SECS TO AVOID TO FREEZE CURRENT THREAD\n        if (channel.tryAcquireWriteLock(TIMEOUT_PUSH)) {\n          try {\n            channel.writeByte(OChannelBinaryProtocol.PUSH_DATA);\n            channel.writeInt(Integer.MIN_VALUE);\n            channel.writeByte(OChannelBinaryProtocol.REQUEST_PUSH_DISTRIB_CONFIG);\n            channel.writeBytes(content);\n            channel.flush();\n\n            pushed.add(c.getRemoteAddress());\n            OLogManager.instance().debug(this, \"Sent updated cluster configuration to the remote client %s\", c.getRemoteAddress());\n\n          } finally {\n            channel.releaseWriteLock();\n          }\n        } else {\n          OLogManager.instance()\n              .info(this, \"Timeout on sending updated cluster configuration to the remote client %s\", c.getRemoteAddress());\n        }\n      } catch (Exception e) {\n        OLogManager.instance().warn(this, \"Cannot push cluster configuration to the client %s\", e, c.getRemoteAddress());\n      }\n    }\n  }", "language": "java", "code": "public void pushDistribCfg2Clients(final ODocument iConfig) {\n    if (iConfig == null)\n      return;\n\n    final Set<String> pushed = new HashSet<String>();\n    for (OClientConnection c : connections.values()) {\n      if (!c.getData().supportsLegacyPushMessages)\n        continue;\n\n      try {\n        final String remoteAddress = c.getRemoteAddress();\n        if (pushed.contains(remoteAddress))\n          // ALREADY SENT: JUMP IT\n          continue;\n\n      } catch (Exception e) {\n        // SOCKET EXCEPTION SKIP IT\n        continue;\n      }\n\n      if (!(c.getProtocol() instanceof ONetworkProtocolBinary) || c.getData().getSerializationImpl() == null)\n        // INVOLVE ONLY BINARY PROTOCOLS\n        continue;\n\n      final ONetworkProtocolBinary p = (ONetworkProtocolBinary) c.getProtocol();\n      final OChannelBinary channel = p.getChannel();\n      final ORecordSerializer ser = ORecordSerializerFactory.instance().getFormat(c.getData().getSerializationImpl());\n      if (ser == null)\n        return;\n\n      final byte[] content = ser.toStream(iConfig, false);\n\n      try {\n        // TRY ACQUIRING THE LOCK FOR MAXIMUM 3 SECS TO AVOID TO FREEZE CURRENT THREAD\n        if (channel.tryAcquireWriteLock(TIMEOUT_PUSH)) {\n          try {\n            channel.writeByte(OChannelBinaryProtocol.PUSH_DATA);\n            channel.writeInt(Integer.MIN_VALUE);\n            channel.writeByte(OChannelBinaryProtocol.REQUEST_PUSH_DISTRIB_CONFIG);\n            channel.writeBytes(content);\n            channel.flush();\n\n            pushed.add(c.getRemoteAddress());\n            OLogManager.instance().debug(this, \"Sent updated cluster configuration to the remote client %s\", c.getRemoteAddress());\n\n          } finally {\n            channel.releaseWriteLock();\n          }\n        } else {\n          OLogManager.instance()\n              .info(this, \"Timeout on sending updated cluster configuration to the remote client %s\", c.getRemoteAddress());\n        }\n      } catch (Exception e) {\n        OLogManager.instance().warn(this, \"Cannot push cluster configuration to the client %s\", e, c.getRemoteAddress());\n      }\n    }\n  }", "code_tokens": ["public", "void", "pushDistribCfg2Clients", "(", "final", "ODocument", "iConfig", ")", "{", "if", "(", "iConfig", "==", "null", ")", "return", ";", "final", "Set", "<", "String", ">", "pushed", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "for", "(", "OClientConnection", "c", ":", "connections", ".", "values", "(", ")", ")", "{", "if", "(", "!", "c", ".", "getData", "(", ")", ".", "supportsLegacyPushMessages", ")", "continue", ";", "try", "{", "final", "String", "remoteAddress", "=", "c", ".", "getRemoteAddress", "(", ")", ";", "if", "(", "pushed", ".", "contains", "(", "remoteAddress", ")", ")", "// ALREADY SENT: JUMP IT", "continue", ";", "}", "catch", "(", "Exception", "e", ")", "{", "// SOCKET EXCEPTION SKIP IT", "continue", ";", "}", "if", "(", "!", "(", "c", ".", "getProtocol", "(", ")", "instanceof", "ONetworkProtocolBinary", ")", "||", "c", ".", "getData", "(", ")", ".", "getSerializationImpl", "(", ")", "==", "null", ")", "// INVOLVE ONLY BINARY PROTOCOLS", "continue", ";", "final", "ONetworkProtocolBinary", "p", "=", "(", "ONetworkProtocolBinary", ")", "c", ".", "getProtocol", "(", ")", ";", "final", "OChannelBinary", "channel", "=", "p", ".", "getChannel", "(", ")", ";", "final", "ORecordSerializer", "ser", "=", "ORecordSerializerFactory", ".", "instance", "(", ")", ".", "getFormat", "(", "c", ".", "getData", "(", ")", ".", "getSerializationImpl", "(", ")", ")", ";", "if", "(", "ser", "==", "null", ")", "return", ";", "final", "byte", "[", "]", "content", "=", "ser", ".", "toStream", "(", "iConfig", ",", "false", ")", ";", "try", "{", "// TRY ACQUIRING THE LOCK FOR MAXIMUM 3 SECS TO AVOID TO FREEZE CURRENT THREAD", "if", "(", "channel", ".", "tryAcquireWriteLock", "(", "TIMEOUT_PUSH", ")", ")", "{", "try", "{", "channel", ".", "writeByte", "(", "OChannelBinaryProtocol", ".", "PUSH_DATA", ")", ";", "channel", ".", "writeInt", "(", "Integer", ".", "MIN_VALUE", ")", ";", "channel", ".", "writeByte", "(", "OChannelBinaryProtocol", ".", "REQUEST_PUSH_DISTRIB_CONFIG", ")", ";", "channel", ".", "writeBytes", "(", "content", ")", ";", "channel", ".", "flush", "(", ")", ";", "pushed", ".", "add", "(", "c", ".", "getRemoteAddress", "(", ")", ")", ";", "OLogManager", ".", "instance", "(", ")", ".", "debug", "(", "this", ",", "\"Sent updated cluster configuration to the remote client %s\"", ",", "c", ".", "getRemoteAddress", "(", ")", ")", ";", "}", "finally", "{", "channel", ".", "releaseWriteLock", "(", ")", ";", "}", "}", "else", "{", "OLogManager", ".", "instance", "(", ")", ".", "info", "(", "this", ",", "\"Timeout on sending updated cluster configuration to the remote client %s\"", ",", "c", ".", "getRemoteAddress", "(", ")", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "warn", "(", "this", ",", "\"Cannot push cluster configuration to the client %s\"", ",", "e", ",", "c", ".", "getRemoteAddress", "(", ")", ")", ";", "}", "}", "}"], "docstring": "Pushes the distributed configuration to all the connected clients.", "docstring_tokens": ["Pushes", "the", "distributed", "configuration", "to", "all", "the", "connected", "clients", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java#L368-L424", "partition": "test", "index": 2969, "time": "2019-02-11 18:14:55"}
{"repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java", "func_name": "OClientConnectionManager.kill", "original_string": "public void kill(final OClientConnection connection) {\n    if (connection != null) {\n      final ONetworkProtocol protocol = connection.getProtocol();\n\n      try {\n        // INTERRUPT THE NEWTORK MANAGER TOO\n        protocol.interrupt();\n      } catch (Exception e) {\n        OLogManager.instance().error(this, \"Error during interruption of binary protocol\", e);\n      }\n\n      disconnect(connection);\n\n      // KILL THE NETWORK MANAGER TOO\n      protocol.sendShutdown();\n    }\n  }", "language": "java", "code": "public void kill(final OClientConnection connection) {\n    if (connection != null) {\n      final ONetworkProtocol protocol = connection.getProtocol();\n\n      try {\n        // INTERRUPT THE NEWTORK MANAGER TOO\n        protocol.interrupt();\n      } catch (Exception e) {\n        OLogManager.instance().error(this, \"Error during interruption of binary protocol\", e);\n      }\n\n      disconnect(connection);\n\n      // KILL THE NETWORK MANAGER TOO\n      protocol.sendShutdown();\n    }\n  }", "code_tokens": ["public", "void", "kill", "(", "final", "OClientConnection", "connection", ")", "{", "if", "(", "connection", "!=", "null", ")", "{", "final", "ONetworkProtocol", "protocol", "=", "connection", ".", "getProtocol", "(", ")", ";", "try", "{", "// INTERRUPT THE NEWTORK MANAGER TOO", "protocol", ".", "interrupt", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error during interruption of binary protocol\"", ",", "e", ")", ";", "}", "disconnect", "(", "connection", ")", ";", "// KILL THE NETWORK MANAGER TOO", "protocol", ".", "sendShutdown", "(", ")", ";", "}", "}"], "docstring": "Disconnects and kill the associated network manager.\n\n@param connection connection to kill", "docstring_tokens": ["Disconnects", "and", "kill", "the", "associated", "network", "manager", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager.java#L251-L267", "partition": "test", "index": 2966, "time": "2019-02-11 18:14:55"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLInsert.java", "func_name": "OCommandExecutorSQLInsert.execute", "original_string": "public Object execute(final Map<Object, Object> iArgs) {\n    if (newRecords == null && content == null && subQuery == null)\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\n\n    final OCommandParameters commandParameters = new OCommandParameters(iArgs);\n    if (indexName != null) {\n      if (newRecords == null)\n        throw new OCommandExecutionException(\"No key/value found\");\n\n      final OIndex<?> index = getDatabase().getMetadata().getIndexManager().getIndex(indexName);\n      if (index == null)\n        throw new OCommandExecutionException(\"Target index '\" + indexName + \"' not found\");\n\n      // BIND VALUES\n      Map<String, Object> result = new HashMap<String, Object>();\n\n      for (Map<String, Object> candidate : newRecords) {\n        Object indexKey = getIndexKeyValue(commandParameters, candidate);\n        OIdentifiable indexValue = getIndexValue(commandParameters, candidate);\n\n        if (index instanceof OIndexMultiValues) {\n          final Collection<ORID> rids = ((OIndexMultiValues) index).get(indexKey);\n          if (!rids.contains(indexValue.getIdentity())) {\n            index.put(indexKey, indexValue);\n          }\n        } else {\n          index.put(indexKey, indexValue);\n        }\n\n        result.put(KEYWORD_KEY, indexKey);\n        result.put(KEYWORD_RID, indexValue);\n      }\n\n      // RETURN LAST ENTRY\n      return prepareReturnItem(new ODocument(result));\n    } else {\n      // CREATE NEW DOCUMENTS\n      final List<ODocument> docs = new ArrayList<ODocument>();\n      if (newRecords != null) {\n        for (Map<String, Object> candidate : newRecords) {\n          final ODocument doc = className != null ? new ODocument(className) : new ODocument();\n          OSQLHelper.bindParameters(doc, candidate, commandParameters, context);\n\n          saveRecord(doc);\n          docs.add(doc);\n        }\n\n        if (docs.size() == 1)\n          return prepareReturnItem(docs.get(0));\n        else\n          return prepareReturnResult(docs);\n      } else if (content != null) {\n        final ODocument doc = className != null ? new ODocument(className) : new ODocument();\n        doc.merge(content, true, false);\n        saveRecord(doc);\n        return prepareReturnItem(doc);\n      } else if (subQuery != null) {\n        subQuery.execute();\n        if (queryResult != null)\n          return prepareReturnResult(queryResult);\n\n        return saved.longValue();\n      }\n    }\n    return null;\n  }", "language": "java", "code": "public Object execute(final Map<Object, Object> iArgs) {\n    if (newRecords == null && content == null && subQuery == null)\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\n\n    final OCommandParameters commandParameters = new OCommandParameters(iArgs);\n    if (indexName != null) {\n      if (newRecords == null)\n        throw new OCommandExecutionException(\"No key/value found\");\n\n      final OIndex<?> index = getDatabase().getMetadata().getIndexManager().getIndex(indexName);\n      if (index == null)\n        throw new OCommandExecutionException(\"Target index '\" + indexName + \"' not found\");\n\n      // BIND VALUES\n      Map<String, Object> result = new HashMap<String, Object>();\n\n      for (Map<String, Object> candidate : newRecords) {\n        Object indexKey = getIndexKeyValue(commandParameters, candidate);\n        OIdentifiable indexValue = getIndexValue(commandParameters, candidate);\n\n        if (index instanceof OIndexMultiValues) {\n          final Collection<ORID> rids = ((OIndexMultiValues) index).get(indexKey);\n          if (!rids.contains(indexValue.getIdentity())) {\n            index.put(indexKey, indexValue);\n          }\n        } else {\n          index.put(indexKey, indexValue);\n        }\n\n        result.put(KEYWORD_KEY, indexKey);\n        result.put(KEYWORD_RID, indexValue);\n      }\n\n      // RETURN LAST ENTRY\n      return prepareReturnItem(new ODocument(result));\n    } else {\n      // CREATE NEW DOCUMENTS\n      final List<ODocument> docs = new ArrayList<ODocument>();\n      if (newRecords != null) {\n        for (Map<String, Object> candidate : newRecords) {\n          final ODocument doc = className != null ? new ODocument(className) : new ODocument();\n          OSQLHelper.bindParameters(doc, candidate, commandParameters, context);\n\n          saveRecord(doc);\n          docs.add(doc);\n        }\n\n        if (docs.size() == 1)\n          return prepareReturnItem(docs.get(0));\n        else\n          return prepareReturnResult(docs);\n      } else if (content != null) {\n        final ODocument doc = className != null ? new ODocument(className) : new ODocument();\n        doc.merge(content, true, false);\n        saveRecord(doc);\n        return prepareReturnItem(doc);\n      } else if (subQuery != null) {\n        subQuery.execute();\n        if (queryResult != null)\n          return prepareReturnResult(queryResult);\n\n        return saved.longValue();\n      }\n    }\n    return null;\n  }", "code_tokens": ["public", "Object", "execute", "(", "final", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "if", "(", "newRecords", "==", "null", "&&", "content", "==", "null", "&&", "subQuery", "==", "null", ")", "throw", "new", "OCommandExecutionException", "(", "\"Cannot execute the command because it has not been parsed yet\"", ")", ";", "final", "OCommandParameters", "commandParameters", "=", "new", "OCommandParameters", "(", "iArgs", ")", ";", "if", "(", "indexName", "!=", "null", ")", "{", "if", "(", "newRecords", "==", "null", ")", "throw", "new", "OCommandExecutionException", "(", "\"No key/value found\"", ")", ";", "final", "OIndex", "<", "?", ">", "index", "=", "getDatabase", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ".", "getIndex", "(", "indexName", ")", ";", "if", "(", "index", "==", "null", ")", "throw", "new", "OCommandExecutionException", "(", "\"Target index '\"", "+", "indexName", "+", "\"' not found\"", ")", ";", "// BIND VALUES", "Map", "<", "String", ",", "Object", ">", "result", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "for", "(", "Map", "<", "String", ",", "Object", ">", "candidate", ":", "newRecords", ")", "{", "Object", "indexKey", "=", "getIndexKeyValue", "(", "commandParameters", ",", "candidate", ")", ";", "OIdentifiable", "indexValue", "=", "getIndexValue", "(", "commandParameters", ",", "candidate", ")", ";", "if", "(", "index", "instanceof", "OIndexMultiValues", ")", "{", "final", "Collection", "<", "ORID", ">", "rids", "=", "(", "(", "OIndexMultiValues", ")", "index", ")", ".", "get", "(", "indexKey", ")", ";", "if", "(", "!", "rids", ".", "contains", "(", "indexValue", ".", "getIdentity", "(", ")", ")", ")", "{", "index", ".", "put", "(", "indexKey", ",", "indexValue", ")", ";", "}", "}", "else", "{", "index", ".", "put", "(", "indexKey", ",", "indexValue", ")", ";", "}", "result", ".", "put", "(", "KEYWORD_KEY", ",", "indexKey", ")", ";", "result", ".", "put", "(", "KEYWORD_RID", ",", "indexValue", ")", ";", "}", "// RETURN LAST ENTRY", "return", "prepareReturnItem", "(", "new", "ODocument", "(", "result", ")", ")", ";", "}", "else", "{", "// CREATE NEW DOCUMENTS", "final", "List", "<", "ODocument", ">", "docs", "=", "new", "ArrayList", "<", "ODocument", ">", "(", ")", ";", "if", "(", "newRecords", "!=", "null", ")", "{", "for", "(", "Map", "<", "String", ",", "Object", ">", "candidate", ":", "newRecords", ")", "{", "final", "ODocument", "doc", "=", "className", "!=", "null", "?", "new", "ODocument", "(", "className", ")", ":", "new", "ODocument", "(", ")", ";", "OSQLHelper", ".", "bindParameters", "(", "doc", ",", "candidate", ",", "commandParameters", ",", "context", ")", ";", "saveRecord", "(", "doc", ")", ";", "docs", ".", "add", "(", "doc", ")", ";", "}", "if", "(", "docs", ".", "size", "(", ")", "==", "1", ")", "return", "prepareReturnItem", "(", "docs", ".", "get", "(", "0", ")", ")", ";", "else", "return", "prepareReturnResult", "(", "docs", ")", ";", "}", "else", "if", "(", "content", "!=", "null", ")", "{", "final", "ODocument", "doc", "=", "className", "!=", "null", "?", "new", "ODocument", "(", "className", ")", ":", "new", "ODocument", "(", ")", ";", "doc", ".", "merge", "(", "content", ",", "true", ",", "false", ")", ";", "saveRecord", "(", "doc", ")", ";", "return", "prepareReturnItem", "(", "doc", ")", ";", "}", "else", "if", "(", "subQuery", "!=", "null", ")", "{", "subQuery", ".", "execute", "(", ")", ";", "if", "(", "queryResult", "!=", "null", ")", "return", "prepareReturnResult", "(", "queryResult", ")", ";", "return", "saved", ".", "longValue", "(", ")", ";", "}", "}", "return", "null", ";", "}"], "docstring": "Execute the INSERT and return the ODocument object created.", "docstring_tokens": ["Execute", "the", "INSERT", "and", "return", "the", "ODocument", "object", "created", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLInsert.java#L210-L275", "partition": "test", "index": 3280, "time": "2019-02-15 21:33:30"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLCreateIndex.java", "func_name": "OCommandExecutorSQLCreateIndex.execute", "original_string": "@SuppressWarnings(\"rawtypes\")\n  public Object execute(final Map<Object, Object> iArgs) {\n    if (indexName == null)\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\n\n    final ODatabaseDocument database = getDatabase();\n    final OIndex<?> idx;\n    List<OCollate> collatesList = null;\n\n    if (collates != null) {\n      collatesList = new ArrayList<OCollate>();\n\n      for (String collate : collates) {\n        if (collate != null) {\n          final OCollate col = OSQLEngine.getCollate(collate);\n          collatesList.add(col);\n        } else\n          collatesList.add(null);\n      }\n    }\n\n    if (fields == null || fields.length == 0) {\n      OIndexFactory factory = OIndexes.getFactory(indexType.toString(), null);\n\n      if (keyTypes != null)\n        idx = database.getMetadata().getIndexManager()\n            .createIndex(indexName, indexType.toString(), new OSimpleKeyIndexDefinition(keyTypes, collatesList), null, null,\n                metadataDoc, engine);\n      else if (serializerKeyId != 0) {\n        idx = database.getMetadata().getIndexManager()\n            .createIndex(indexName, indexType.toString(), new ORuntimeKeyIndexDefinition(serializerKeyId), null, null, metadataDoc,\n                engine);\n      } else {\n        throw new ODatabaseException(\"Impossible to create an index without specify the key type or the associated property\");\n      }\n    } else {\n      if ((keyTypes == null || keyTypes.length == 0) && collates == null) {\n        idx = oClass.createIndex(indexName, indexType.toString(), null, metadataDoc, engine, fields);\n      } else {\n        final List<OType> fieldTypeList;\n        if (keyTypes == null) {\n          for (final String fieldName : fields) {\n            if (!fieldName.equals(\"@rid\") && !oClass.existsProperty(fieldName))\n              throw new OIndexException(\n                  \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass.getName() + \"' because field: '\"\n                      + fieldName + \"' is absent in class definition.\");\n          }\n          fieldTypeList = ((OClassImpl) oClass).extractFieldTypes(fields);\n        } else\n          fieldTypeList = Arrays.asList(keyTypes);\n\n        final OIndexDefinition idxDef = OIndexDefinitionFactory\n            .createIndexDefinition(oClass, Arrays.asList(fields), fieldTypeList, collatesList, indexType.toString(), null);\n\n        idx = database.getMetadata().getIndexManager()\n            .createIndex(indexName, indexType.name(), idxDef, oClass.getPolymorphicClusterIds(), null, metadataDoc, engine);\n      }\n    }\n\n    if (idx != null)\n      return idx.getSize();\n\n    return null;\n  }", "language": "java", "code": "@SuppressWarnings(\"rawtypes\")\n  public Object execute(final Map<Object, Object> iArgs) {\n    if (indexName == null)\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\n\n    final ODatabaseDocument database = getDatabase();\n    final OIndex<?> idx;\n    List<OCollate> collatesList = null;\n\n    if (collates != null) {\n      collatesList = new ArrayList<OCollate>();\n\n      for (String collate : collates) {\n        if (collate != null) {\n          final OCollate col = OSQLEngine.getCollate(collate);\n          collatesList.add(col);\n        } else\n          collatesList.add(null);\n      }\n    }\n\n    if (fields == null || fields.length == 0) {\n      OIndexFactory factory = OIndexes.getFactory(indexType.toString(), null);\n\n      if (keyTypes != null)\n        idx = database.getMetadata().getIndexManager()\n            .createIndex(indexName, indexType.toString(), new OSimpleKeyIndexDefinition(keyTypes, collatesList), null, null,\n                metadataDoc, engine);\n      else if (serializerKeyId != 0) {\n        idx = database.getMetadata().getIndexManager()\n            .createIndex(indexName, indexType.toString(), new ORuntimeKeyIndexDefinition(serializerKeyId), null, null, metadataDoc,\n                engine);\n      } else {\n        throw new ODatabaseException(\"Impossible to create an index without specify the key type or the associated property\");\n      }\n    } else {\n      if ((keyTypes == null || keyTypes.length == 0) && collates == null) {\n        idx = oClass.createIndex(indexName, indexType.toString(), null, metadataDoc, engine, fields);\n      } else {\n        final List<OType> fieldTypeList;\n        if (keyTypes == null) {\n          for (final String fieldName : fields) {\n            if (!fieldName.equals(\"@rid\") && !oClass.existsProperty(fieldName))\n              throw new OIndexException(\n                  \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass.getName() + \"' because field: '\"\n                      + fieldName + \"' is absent in class definition.\");\n          }\n          fieldTypeList = ((OClassImpl) oClass).extractFieldTypes(fields);\n        } else\n          fieldTypeList = Arrays.asList(keyTypes);\n\n        final OIndexDefinition idxDef = OIndexDefinitionFactory\n            .createIndexDefinition(oClass, Arrays.asList(fields), fieldTypeList, collatesList, indexType.toString(), null);\n\n        idx = database.getMetadata().getIndexManager()\n            .createIndex(indexName, indexType.name(), idxDef, oClass.getPolymorphicClusterIds(), null, metadataDoc, engine);\n      }\n    }\n\n    if (idx != null)\n      return idx.getSize();\n\n    return null;\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"rawtypes\"", ")", "public", "Object", "execute", "(", "final", "Map", "<", "Object", ",", "Object", ">", "iArgs", ")", "{", "if", "(", "indexName", "==", "null", ")", "throw", "new", "OCommandExecutionException", "(", "\"Cannot execute the command because it has not been parsed yet\"", ")", ";", "final", "ODatabaseDocument", "database", "=", "getDatabase", "(", ")", ";", "final", "OIndex", "<", "?", ">", "idx", ";", "List", "<", "OCollate", ">", "collatesList", "=", "null", ";", "if", "(", "collates", "!=", "null", ")", "{", "collatesList", "=", "new", "ArrayList", "<", "OCollate", ">", "(", ")", ";", "for", "(", "String", "collate", ":", "collates", ")", "{", "if", "(", "collate", "!=", "null", ")", "{", "final", "OCollate", "col", "=", "OSQLEngine", ".", "getCollate", "(", "collate", ")", ";", "collatesList", ".", "add", "(", "col", ")", ";", "}", "else", "collatesList", ".", "add", "(", "null", ")", ";", "}", "}", "if", "(", "fields", "==", "null", "||", "fields", ".", "length", "==", "0", ")", "{", "OIndexFactory", "factory", "=", "OIndexes", ".", "getFactory", "(", "indexType", ".", "toString", "(", ")", ",", "null", ")", ";", "if", "(", "keyTypes", "!=", "null", ")", "idx", "=", "database", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ".", "createIndex", "(", "indexName", ",", "indexType", ".", "toString", "(", ")", ",", "new", "OSimpleKeyIndexDefinition", "(", "keyTypes", ",", "collatesList", ")", ",", "null", ",", "null", ",", "metadataDoc", ",", "engine", ")", ";", "else", "if", "(", "serializerKeyId", "!=", "0", ")", "{", "idx", "=", "database", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ".", "createIndex", "(", "indexName", ",", "indexType", ".", "toString", "(", ")", ",", "new", "ORuntimeKeyIndexDefinition", "(", "serializerKeyId", ")", ",", "null", ",", "null", ",", "metadataDoc", ",", "engine", ")", ";", "}", "else", "{", "throw", "new", "ODatabaseException", "(", "\"Impossible to create an index without specify the key type or the associated property\"", ")", ";", "}", "}", "else", "{", "if", "(", "(", "keyTypes", "==", "null", "||", "keyTypes", ".", "length", "==", "0", ")", "&&", "collates", "==", "null", ")", "{", "idx", "=", "oClass", ".", "createIndex", "(", "indexName", ",", "indexType", ".", "toString", "(", ")", ",", "null", ",", "metadataDoc", ",", "engine", ",", "fields", ")", ";", "}", "else", "{", "final", "List", "<", "OType", ">", "fieldTypeList", ";", "if", "(", "keyTypes", "==", "null", ")", "{", "for", "(", "final", "String", "fieldName", ":", "fields", ")", "{", "if", "(", "!", "fieldName", ".", "equals", "(", "\"@rid\"", ")", "&&", "!", "oClass", ".", "existsProperty", "(", "fieldName", ")", ")", "throw", "new", "OIndexException", "(", "\"Index with name : '\"", "+", "indexName", "+", "\"' cannot be created on class : '\"", "+", "oClass", ".", "getName", "(", ")", "+", "\"' because field: '\"", "+", "fieldName", "+", "\"' is absent in class definition.\"", ")", ";", "}", "fieldTypeList", "=", "(", "(", "OClassImpl", ")", "oClass", ")", ".", "extractFieldTypes", "(", "fields", ")", ";", "}", "else", "fieldTypeList", "=", "Arrays", ".", "asList", "(", "keyTypes", ")", ";", "final", "OIndexDefinition", "idxDef", "=", "OIndexDefinitionFactory", ".", "createIndexDefinition", "(", "oClass", ",", "Arrays", ".", "asList", "(", "fields", ")", ",", "fieldTypeList", ",", "collatesList", ",", "indexType", ".", "toString", "(", ")", ",", "null", ")", ";", "idx", "=", "database", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ".", "createIndex", "(", "indexName", ",", "indexType", ".", "name", "(", ")", ",", "idxDef", ",", "oClass", ".", "getPolymorphicClusterIds", "(", ")", ",", "null", ",", "metadataDoc", ",", "engine", ")", ";", "}", "}", "if", "(", "idx", "!=", "null", ")", "return", "idx", ".", "getSize", "(", ")", ";", "return", "null", ";", "}"], "docstring": "Execute the CREATE INDEX.", "docstring_tokens": ["Execute", "the", "CREATE", "INDEX", "."], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLCreateIndex.java#L243-L306", "partition": "test", "index": 3229, "time": "2019-02-28 09:51:03"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/tool/ODatabaseImport.java", "func_name": "ODatabaseImport.processBrokenRids", "original_string": "private void processBrokenRids(Set<ORID> brokenRids) throws IOException, ParseException {\n    if (exporterVersion >= 12) {\n      listener.onMessage(\"Reading of set of RIDs of records which were detected as broken during database export\\n\");\n\n      jsonReader.readNext(OJSONReader.BEGIN_COLLECTION);\n\n      while (true) {\n        jsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\n\n        final ORecordId recordId = new ORecordId(jsonReader.getValue());\n        brokenRids.add(recordId);\n\n        if (jsonReader.lastChar() == ']')\n          break;\n      }\n    }\n    if (migrateLinks) {\n      if (exporterVersion >= 12)\n        listener.onMessage(\n            brokenRids.size() + \" were detected as broken during database export, links on those records will be removed from\"\n                + \" result database\");\n      migrateLinksInImportedDocuments(brokenRids);\n    }\n  }", "language": "java", "code": "private void processBrokenRids(Set<ORID> brokenRids) throws IOException, ParseException {\n    if (exporterVersion >= 12) {\n      listener.onMessage(\"Reading of set of RIDs of records which were detected as broken during database export\\n\");\n\n      jsonReader.readNext(OJSONReader.BEGIN_COLLECTION);\n\n      while (true) {\n        jsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);\n\n        final ORecordId recordId = new ORecordId(jsonReader.getValue());\n        brokenRids.add(recordId);\n\n        if (jsonReader.lastChar() == ']')\n          break;\n      }\n    }\n    if (migrateLinks) {\n      if (exporterVersion >= 12)\n        listener.onMessage(\n            brokenRids.size() + \" were detected as broken during database export, links on those records will be removed from\"\n                + \" result database\");\n      migrateLinksInImportedDocuments(brokenRids);\n    }\n  }", "code_tokens": ["private", "void", "processBrokenRids", "(", "Set", "<", "ORID", ">", "brokenRids", ")", "throws", "IOException", ",", "ParseException", "{", "if", "(", "exporterVersion", ">=", "12", ")", "{", "listener", ".", "onMessage", "(", "\"Reading of set of RIDs of records which were detected as broken during database export\\n\"", ")", ";", "jsonReader", ".", "readNext", "(", "OJSONReader", ".", "BEGIN_COLLECTION", ")", ";", "while", "(", "true", ")", "{", "jsonReader", ".", "readNext", "(", "OJSONReader", ".", "NEXT_IN_ARRAY", ")", ";", "final", "ORecordId", "recordId", "=", "new", "ORecordId", "(", "jsonReader", ".", "getValue", "(", ")", ")", ";", "brokenRids", ".", "add", "(", "recordId", ")", ";", "if", "(", "jsonReader", ".", "lastChar", "(", ")", "==", "'", "'", ")", "break", ";", "}", "}", "if", "(", "migrateLinks", ")", "{", "if", "(", "exporterVersion", ">=", "12", ")", "listener", ".", "onMessage", "(", "brokenRids", ".", "size", "(", ")", "+", "\" were detected as broken during database export, links on those records will be removed from\"", "+", "\" result database\"", ")", ";", "migrateLinksInImportedDocuments", "(", "brokenRids", ")", ";", "}", "}"], "docstring": "just read collection so import process can continue", "docstring_tokens": ["just", "read", "collection", "so", "import", "process", "can", "continue"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/db/tool/ODatabaseImport.java#L267-L290", "partition": "test", "index": 3213, "time": "2019-02-28 09:51:03"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/binary/OBinarySerializerFactory.java", "func_name": "OBinarySerializerFactory.getObjectSerializer", "original_string": "@SuppressWarnings(\"unchecked\")\n  public <T> OBinarySerializer<T> getObjectSerializer(final OType type) {\n    return (OBinarySerializer<T>) serializerTypeMap.get(type);\n  }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\n  public <T> OBinarySerializer<T> getObjectSerializer(final OType type) {\n    return (OBinarySerializer<T>) serializerTypeMap.get(type);\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "<", "T", ">", "OBinarySerializer", "<", "T", ">", "getObjectSerializer", "(", "final", "OType", "type", ")", "{", "return", "(", "OBinarySerializer", "<", "T", ">", ")", "serializerTypeMap", ".", "get", "(", "type", ")", ";", "}"], "docstring": "Obtain OBinarySerializer realization for the OType\n\n@param type is the OType to obtain serializer algorithm for\n\n@return OBinarySerializer instance", "docstring_tokens": ["Obtain", "OBinarySerializer", "realization", "for", "the", "OType"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/serialization/serializer/binary/OBinarySerializerFactory.java#L164-L167", "partition": "test", "index": 3261, "time": "2019-02-28 09:51:03"}
{"repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.buildIndexSearchDescriptorForFulltext", "original_string": "private IndexSearchDescriptor buildIndexSearchDescriptorForFulltext(OCommandContext ctx, OIndex<?> index, OAndBlock block, OClass clazz) {\n    List<String> indexFields = index.getDefinition().getFields();\n    OBinaryCondition keyCondition = new OBinaryCondition(-1);\n    OIdentifier key = new OIdentifier(\"key\");\n    keyCondition.setLeft(new OExpression(key));\n    boolean found = false;\n\n    OAndBlock blockCopy = block.copy();\n    Iterator<OBooleanExpression> blockIterator;\n\n    OAndBlock indexKeyValue = new OAndBlock(-1);\n    IndexSearchDescriptor result = new IndexSearchDescriptor();\n    result.idx = index;\n    result.keyCondition = indexKeyValue;\n    for (String indexField : indexFields) {\n      blockIterator = blockCopy.getSubBlocks().iterator();\n      boolean breakHere = false;\n      boolean indexFieldFound = false;\n      while (blockIterator.hasNext()) {\n        OBooleanExpression singleExp = blockIterator.next();\n        if (singleExp instanceof OContainsTextCondition) {\n          OExpression left = ((OContainsTextCondition) singleExp).getLeft();\n          if (left.isBaseIdentifier()) {\n            String fieldName = left.getDefaultAlias().getStringValue();\n            if (indexField.equals(fieldName)) {\n              found = true;\n              indexFieldFound = true;\n              OContainsTextCondition condition = new OContainsTextCondition(-1);\n              condition.setLeft(left);\n              condition.setRight(((OContainsTextCondition) singleExp).getRight().copy());\n              indexKeyValue.getSubBlocks().add(condition);\n              blockIterator.remove();\n              break;\n            }\n          }\n        }\n      }\n      if (breakHere || !indexFieldFound) {\n        break;\n      }\n    }\n\n    if (result.keyCondition.getSubBlocks().size() < index.getDefinition().getFields().size() && !index\n        .supportsOrderedIterations()) {\n      //hash indexes do not support partial key match\n      return null;\n    }\n\n    if (found) {\n      result.remainingCondition = blockCopy;\n      return result;\n    }\n    return null;\n  }", "language": "java", "code": "private IndexSearchDescriptor buildIndexSearchDescriptorForFulltext(OCommandContext ctx, OIndex<?> index, OAndBlock block, OClass clazz) {\n    List<String> indexFields = index.getDefinition().getFields();\n    OBinaryCondition keyCondition = new OBinaryCondition(-1);\n    OIdentifier key = new OIdentifier(\"key\");\n    keyCondition.setLeft(new OExpression(key));\n    boolean found = false;\n\n    OAndBlock blockCopy = block.copy();\n    Iterator<OBooleanExpression> blockIterator;\n\n    OAndBlock indexKeyValue = new OAndBlock(-1);\n    IndexSearchDescriptor result = new IndexSearchDescriptor();\n    result.idx = index;\n    result.keyCondition = indexKeyValue;\n    for (String indexField : indexFields) {\n      blockIterator = blockCopy.getSubBlocks().iterator();\n      boolean breakHere = false;\n      boolean indexFieldFound = false;\n      while (blockIterator.hasNext()) {\n        OBooleanExpression singleExp = blockIterator.next();\n        if (singleExp instanceof OContainsTextCondition) {\n          OExpression left = ((OContainsTextCondition) singleExp).getLeft();\n          if (left.isBaseIdentifier()) {\n            String fieldName = left.getDefaultAlias().getStringValue();\n            if (indexField.equals(fieldName)) {\n              found = true;\n              indexFieldFound = true;\n              OContainsTextCondition condition = new OContainsTextCondition(-1);\n              condition.setLeft(left);\n              condition.setRight(((OContainsTextCondition) singleExp).getRight().copy());\n              indexKeyValue.getSubBlocks().add(condition);\n              blockIterator.remove();\n              break;\n            }\n          }\n        }\n      }\n      if (breakHere || !indexFieldFound) {\n        break;\n      }\n    }\n\n    if (result.keyCondition.getSubBlocks().size() < index.getDefinition().getFields().size() && !index\n        .supportsOrderedIterations()) {\n      //hash indexes do not support partial key match\n      return null;\n    }\n\n    if (found) {\n      result.remainingCondition = blockCopy;\n      return result;\n    }\n    return null;\n  }", "code_tokens": ["private", "IndexSearchDescriptor", "buildIndexSearchDescriptorForFulltext", "(", "OCommandContext", "ctx", ",", "OIndex", "<", "?", ">", "index", ",", "OAndBlock", "block", ",", "OClass", "clazz", ")", "{", "List", "<", "String", ">", "indexFields", "=", "index", ".", "getDefinition", "(", ")", ".", "getFields", "(", ")", ";", "OBinaryCondition", "keyCondition", "=", "new", "OBinaryCondition", "(", "-", "1", ")", ";", "OIdentifier", "key", "=", "new", "OIdentifier", "(", "\"key\"", ")", ";", "keyCondition", ".", "setLeft", "(", "new", "OExpression", "(", "key", ")", ")", ";", "boolean", "found", "=", "false", ";", "OAndBlock", "blockCopy", "=", "block", ".", "copy", "(", ")", ";", "Iterator", "<", "OBooleanExpression", ">", "blockIterator", ";", "OAndBlock", "indexKeyValue", "=", "new", "OAndBlock", "(", "-", "1", ")", ";", "IndexSearchDescriptor", "result", "=", "new", "IndexSearchDescriptor", "(", ")", ";", "result", ".", "idx", "=", "index", ";", "result", ".", "keyCondition", "=", "indexKeyValue", ";", "for", "(", "String", "indexField", ":", "indexFields", ")", "{", "blockIterator", "=", "blockCopy", ".", "getSubBlocks", "(", ")", ".", "iterator", "(", ")", ";", "boolean", "breakHere", "=", "false", ";", "boolean", "indexFieldFound", "=", "false", ";", "while", "(", "blockIterator", ".", "hasNext", "(", ")", ")", "{", "OBooleanExpression", "singleExp", "=", "blockIterator", ".", "next", "(", ")", ";", "if", "(", "singleExp", "instanceof", "OContainsTextCondition", ")", "{", "OExpression", "left", "=", "(", "(", "OContainsTextCondition", ")", "singleExp", ")", ".", "getLeft", "(", ")", ";", "if", "(", "left", ".", "isBaseIdentifier", "(", ")", ")", "{", "String", "fieldName", "=", "left", ".", "getDefaultAlias", "(", ")", ".", "getStringValue", "(", ")", ";", "if", "(", "indexField", ".", "equals", "(", "fieldName", ")", ")", "{", "found", "=", "true", ";", "indexFieldFound", "=", "true", ";", "OContainsTextCondition", "condition", "=", "new", "OContainsTextCondition", "(", "-", "1", ")", ";", "condition", ".", "setLeft", "(", "left", ")", ";", "condition", ".", "setRight", "(", "(", "(", "OContainsTextCondition", ")", "singleExp", ")", ".", "getRight", "(", ")", ".", "copy", "(", ")", ")", ";", "indexKeyValue", ".", "getSubBlocks", "(", ")", ".", "add", "(", "condition", ")", ";", "blockIterator", ".", "remove", "(", ")", ";", "break", ";", "}", "}", "}", "}", "if", "(", "breakHere", "||", "!", "indexFieldFound", ")", "{", "break", ";", "}", "}", "if", "(", "result", ".", "keyCondition", ".", "getSubBlocks", "(", ")", ".", "size", "(", ")", "<", "index", ".", "getDefinition", "(", ")", ".", "getFields", "(", ")", ".", "size", "(", ")", "&&", "!", "index", ".", "supportsOrderedIterations", "(", ")", ")", "{", "//hash indexes do not support partial key match", "return", "null", ";", "}", "if", "(", "found", ")", "{", "result", ".", "remainingCondition", "=", "blockCopy", ";", "return", "result", ";", "}", "return", "null", ";", "}"], "docstring": "given a full text index and a flat AND block, returns a descriptor on how to process it with an index (index, index key and additional\nfilters to apply after index fetch\n\n@param ctx\n@param index\n@param block\n@param clazz\n\n@return", "docstring_tokens": ["given", "a", "full", "text", "index", "and", "a", "flat", "AND", "block", "returns", "a", "descriptor", "on", "how", "to", "process", "it", "with", "an", "index", "(", "index", "index", "key", "and", "additional", "filters", "to", "apply", "after", "index", "fetch"], "sha": "d970b12033f0462f0239ea0ad8ed41207e6e26f1", "url": "https://github.com/orientechnologies/orientdb/blob/d970b12033f0462f0239ea0ad8ed41207e6e26f1/core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java#L2452-L2505", "partition": "test", "index": 2929, "time": "2019-04-10 13:57:58"}
