{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/collections/Grid/Grid.js", "func_name": "Grid", "original_string": "function Grid(props) {\n  const {\n    celled,\n    centered,\n    children,\n    className,\n    columns,\n    container,\n    divided,\n    doubling,\n    inverted,\n    padded,\n    relaxed,\n    reversed,\n    stackable,\n    stretched,\n    textAlign,\n    verticalAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(container, 'container'),\n    useKeyOnly(doubling, 'doubling'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(stackable, 'stackable'),\n    useKeyOnly(stretched, 'stretched'),\n    useKeyOrValueAndKey(celled, 'celled'),\n    useKeyOrValueAndKey(divided, 'divided'),\n    useKeyOrValueAndKey(padded, 'padded'),\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\n    useMultipleProp(reversed, 'reversed'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(columns, 'column', true),\n    'grid',\n    className,\n  )\n  const rest = getUnhandledProps(Grid, props)\n  const ElementType = getElementType(Grid, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function Grid(props) {\n  const {\n    celled,\n    centered,\n    children,\n    className,\n    columns,\n    container,\n    divided,\n    doubling,\n    inverted,\n    padded,\n    relaxed,\n    reversed,\n    stackable,\n    stretched,\n    textAlign,\n    verticalAlign,\n  } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(container, 'container'),\n    useKeyOnly(doubling, 'doubling'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(stackable, 'stackable'),\n    useKeyOnly(stretched, 'stretched'),\n    useKeyOrValueAndKey(celled, 'celled'),\n    useKeyOrValueAndKey(divided, 'divided'),\n    useKeyOrValueAndKey(padded, 'padded'),\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\n    useMultipleProp(reversed, 'reversed'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    useWidthProp(columns, 'column', true),\n    'grid',\n    className,\n  )\n  const rest = getUnhandledProps(Grid, props)\n  const ElementType = getElementType(Grid, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {children}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "Grid", "(", "props", ")", "{", "const", "{", "celled", ",", "centered", ",", "children", ",", "className", ",", "columns", ",", "container", ",", "divided", ",", "doubling", ",", "inverted", ",", "padded", ",", "relaxed", ",", "reversed", ",", "stackable", ",", "stretched", ",", "textAlign", ",", "verticalAlign", ",", "}", "=", "props", "const", "classes", "=", "cx", "(", "'ui'", ",", "useKeyOnly", "(", "centered", ",", "'centered'", ")", ",", "useKeyOnly", "(", "container", ",", "'container'", ")", ",", "useKeyOnly", "(", "doubling", ",", "'doubling'", ")", ",", "useKeyOnly", "(", "inverted", ",", "'inverted'", ")", ",", "useKeyOnly", "(", "stackable", ",", "'stackable'", ")", ",", "useKeyOnly", "(", "stretched", ",", "'stretched'", ")", ",", "useKeyOrValueAndKey", "(", "celled", ",", "'celled'", ")", ",", "useKeyOrValueAndKey", "(", "divided", ",", "'divided'", ")", ",", "useKeyOrValueAndKey", "(", "padded", ",", "'padded'", ")", ",", "useKeyOrValueAndKey", "(", "relaxed", ",", "'relaxed'", ")", ",", "useMultipleProp", "(", "reversed", ",", "'reversed'", ")", ",", "useTextAlignProp", "(", "textAlign", ")", ",", "useVerticalAlignProp", "(", "verticalAlign", ")", ",", "useWidthProp", "(", "columns", ",", "'column'", ",", "true", ")", ",", "'grid'", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "Grid", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "Grid", ",", "props", ")", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "children", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A grid is used to harmonize negative space in a layout.", "docstring_tokens": ["A", "grid", "is", "used", "to", "harmonize", "negative", "space", "in", "a", "layout", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Grid/Grid.js#L23-L70", "partition": "test"}
{"repo": "carbon-design-system/carbon-components", "path": "packages/bundler/src/commands/measure.js", "func_name": "findPackageFor", "original_string": "async function findPackageFor(filepath) {\n  let directory = filepath;\n\n  while (directory !== '/') {\n    const directoryToSearch = path.dirname(directory);\n    const files = await fs.readdir(directoryToSearch);\n\n    if (files.indexOf('package.json') !== -1) {\n      const packageJson = await fs.readJson(\n        path.join(directoryToSearch, 'package.json')\n      );\n      return packageJson.name;\n    }\n\n    directory = path.resolve(directory, '..');\n  }\n\n  throw new Error(`Unable to find package for: ${filepath}`);\n}", "language": "javascript", "code": "async function findPackageFor(filepath) {\n  let directory = filepath;\n\n  while (directory !== '/') {\n    const directoryToSearch = path.dirname(directory);\n    const files = await fs.readdir(directoryToSearch);\n\n    if (files.indexOf('package.json') !== -1) {\n      const packageJson = await fs.readJson(\n        path.join(directoryToSearch, 'package.json')\n      );\n      return packageJson.name;\n    }\n\n    directory = path.resolve(directory, '..');\n  }\n\n  throw new Error(`Unable to find package for: ${filepath}`);\n}", "code_tokens": ["async", "function", "findPackageFor", "(", "filepath", ")", "{", "let", "directory", "=", "filepath", ";", "while", "(", "directory", "!==", "'/'", ")", "{", "const", "directoryToSearch", "=", "path", ".", "dirname", "(", "directory", ")", ";", "const", "files", "=", "await", "fs", ".", "readdir", "(", "directoryToSearch", ")", ";", "if", "(", "files", ".", "indexOf", "(", "'package.json'", ")", "!==", "-", "1", ")", "{", "const", "packageJson", "=", "await", "fs", ".", "readJson", "(", "path", ".", "join", "(", "directoryToSearch", ",", "'package.json'", ")", ")", ";", "return", "packageJson", ".", "name", ";", "}", "directory", "=", "path", ".", "resolve", "(", "directory", ",", "'..'", ")", ";", "}", "throw", "new", "Error", "(", "`", "${", "filepath", "}", "`", ")", ";", "}"], "docstring": "Rough heuristic used to find the package name for a given file. Idea is to move upwards looking for directories that have a `package.json` file. Once we find one, we report back the name from that file.", "docstring_tokens": ["Rough", "heuristic", "used", "to", "find", "the", "package", "name", "for", "a", "given", "file", ".", "Idea", "is", "to", "move", "upwards", "looking", "for", "directories", "that", "have", "a", "package", ".", "json", "file", ".", "Once", "we", "find", "one", "we", "report", "back", "the", "name", "from", "that", "file", "."], "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302", "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/bundler/src/commands/measure.js#L89-L107", "partition": "test"}
{"repo": "blakevanlan/insist", "path": "index.js", "func_name": "", "original_string": "function (args) {\n   // Find the minimum expected length.\n   var expected = Array.prototype.slice.call(arguments, 1);\n   var minimum = expected.length\n   var hasOptionalTypes = false;\n   \n   for (var i = 0; i < expected.length; i++) {\n      if (!isValidType(expected[i])) {\n         throw Error('Expected argument ' + i + ' is not a valid type.');\n      }\n      if (isOptionalType(expected[i])) {\n         minimum--;\n         hasOptionalTypes = true;\n      }\n   };\n   // Exit early if in production, INSIST_IN_PROD is not equal to true and there are no optional\n   // options.\n   if (isDisabled && !hasOptionalTypes) {\n      return [];\n   }\n\n   // Check if the args and expected lengths are different (and there are no optional args).\n   if (minimum == expected.length && args.length != expected.length) {\n      throw Error(getExpectedVsRecieved_(expected, args));\n   }\n   // Check if the args are within the expected range.\n   if (args.length < minimum || args.length > expected.length) {\n      throw Error(getExpectedVsRecieved_(expected, args));\n   }\n\n   // We don't have to worry about shifting if all the arguments are present.\n   if (args.length === expected.length) {\n      for (var i = 0; i < expected.length; i++) {\n         if (!isOfType(args[i], expected[i])) {\n            throw Error(getExpectedVsRecieved_(expected, args));\n         }\n      };\n      return args;\n   }\n\n   return shiftArguments_(expected, args, minimum);\n}", "language": "javascript", "code": "function (args) {\n   // Find the minimum expected length.\n   var expected = Array.prototype.slice.call(arguments, 1);\n   var minimum = expected.length\n   var hasOptionalTypes = false;\n   \n   for (var i = 0; i < expected.length; i++) {\n      if (!isValidType(expected[i])) {\n         throw Error('Expected argument ' + i + ' is not a valid type.');\n      }\n      if (isOptionalType(expected[i])) {\n         minimum--;\n         hasOptionalTypes = true;\n      }\n   };\n   // Exit early if in production, INSIST_IN_PROD is not equal to true and there are no optional\n   // options.\n   if (isDisabled && !hasOptionalTypes) {\n      return [];\n   }\n\n   // Check if the args and expected lengths are different (and there are no optional args).\n   if (minimum == expected.length && args.length != expected.length) {\n      throw Error(getExpectedVsRecieved_(expected, args));\n   }\n   // Check if the args are within the expected range.\n   if (args.length < minimum || args.length > expected.length) {\n      throw Error(getExpectedVsRecieved_(expected, args));\n   }\n\n   // We don't have to worry about shifting if all the arguments are present.\n   if (args.length === expected.length) {\n      for (var i = 0; i < expected.length; i++) {\n         if (!isOfType(args[i], expected[i])) {\n            throw Error(getExpectedVsRecieved_(expected, args));\n         }\n      };\n      return args;\n   }\n\n   return shiftArguments_(expected, args, minimum);\n}", "code_tokens": ["function", "(", "args", ")", "{", "// Find the minimum expected length.", "var", "expected", "=", "Array", ".", "prototype", ".", "slice", ".", "call", "(", "arguments", ",", "1", ")", ";", "var", "minimum", "=", "expected", ".", "length", "var", "hasOptionalTypes", "=", "false", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "expected", ".", "length", ";", "i", "++", ")", "{", "if", "(", "!", "isValidType", "(", "expected", "[", "i", "]", ")", ")", "{", "throw", "Error", "(", "'Expected argument '", "+", "i", "+", "' is not a valid type.'", ")", ";", "}", "if", "(", "isOptionalType", "(", "expected", "[", "i", "]", ")", ")", "{", "minimum", "--", ";", "hasOptionalTypes", "=", "true", ";", "}", "}", ";", "// Exit early if in production, INSIST_IN_PROD is not equal to true and there are no optional", "// options.", "if", "(", "isDisabled", "&&", "!", "hasOptionalTypes", ")", "{", "return", "[", "]", ";", "}", "// Check if the args and expected lengths are different (and there are no optional args).", "if", "(", "minimum", "==", "expected", ".", "length", "&&", "args", ".", "length", "!=", "expected", ".", "length", ")", "{", "throw", "Error", "(", "getExpectedVsRecieved_", "(", "expected", ",", "args", ")", ")", ";", "}", "// Check if the args are within the expected range.", "if", "(", "args", ".", "length", "<", "minimum", "||", "args", ".", "length", ">", "expected", ".", "length", ")", "{", "throw", "Error", "(", "getExpectedVsRecieved_", "(", "expected", ",", "args", ")", ")", ";", "}", "// We don't have to worry about shifting if all the arguments are present.", "if", "(", "args", ".", "length", "===", "expected", ".", "length", ")", "{", "for", "(", "var", "i", "=", "0", ";", "i", "<", "expected", ".", "length", ";", "i", "++", ")", "{", "if", "(", "!", "isOfType", "(", "args", "[", "i", "]", ",", "expected", "[", "i", "]", ")", ")", "{", "throw", "Error", "(", "getExpectedVsRecieved_", "(", "expected", ",", "args", ")", ")", ";", "}", "}", ";", "return", "args", ";", "}", "return", "shiftArguments_", "(", "expected", ",", "args", ",", "minimum", ")", ";", "}"], "docstring": "Asserts that the arguments supplied are what's expected. If an argument can be multiples\ntypes, use an array of acceptable types.\n@param {Array.<?>} args\n@param {?,..} expected types\n@return Returns an array with the arguments shifted into the correct indices.", "docstring_tokens": ["Asserts", "that", "the", "arguments", "supplied", "are", "what", "s", "expected", ".", "If", "an", "argument", "can", "be", "multiples", "types", "use", "an", "array", "of", "acceptable", "types", "."], "sha": "a5f557f4fd48029e20ae0d66912f701d0577feb5", "url": "https://github.com/blakevanlan/insist/blob/a5f557f4fd48029e20ae0d66912f701d0577feb5/index.js#L23-L64", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "extractDescription", "original_string": "function extractDescription (d) {\n      if (!d) return;\n      if (d === \"ERROR: No README data found!\") return;\n      // the first block of text before the first heading\n      // that isn't the first line heading\n      d = d.trim().split('\\n')\n      for (var s = 0; d[s] && d[s].trim().match(/^(#|$)/); s ++);\n      var l = d.length\n      for (var e = s + 1; e < l && d[e].trim(); e ++);\n      return d.slice(s, e).join(' ').trim()\n    }", "language": "javascript", "code": "function extractDescription (d) {\n      if (!d) return;\n      if (d === \"ERROR: No README data found!\") return;\n      // the first block of text before the first heading\n      // that isn't the first line heading\n      d = d.trim().split('\\n')\n      for (var s = 0; d[s] && d[s].trim().match(/^(#|$)/); s ++);\n      var l = d.length\n      for (var e = s + 1; e < l && d[e].trim(); e ++);\n      return d.slice(s, e).join(' ').trim()\n    }", "code_tokens": ["function", "extractDescription", "(", "d", ")", "{", "if", "(", "!", "d", ")", "return", ";", "if", "(", "d", "===", "\"ERROR: No README data found!\"", ")", "return", ";", "// the first block of text before the first heading", "// that isn't the first line heading", "d", "=", "d", ".", "trim", "(", ")", ".", "split", "(", "'\\n'", ")", "for", "(", "var", "s", "=", "0", ";", "d", "[", "s", "]", "&&", "d", "[", "s", "]", ".", "trim", "(", ")", ".", "match", "(", "/", "^(#|$)", "/", ")", ";", "s", "++", ")", ";", "var", "l", "=", "d", ".", "length", "for", "(", "var", "e", "=", "s", "+", "1", ";", "e", "<", "l", "&&", "d", "[", "e", "]", ".", "trim", "(", ")", ";", "e", "++", ")", ";", "return", "d", ".", "slice", "(", "s", ",", "e", ")", ".", "join", "(", "' '", ")", ".", "trim", "(", ")", "}"], "docstring": "Extracts description from contents of a readme file in markdown format", "docstring_tokens": ["Extracts", "description", "from", "contents", "of", "a", "readme", "file", "in", "markdown", "format"], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L6047-L6057", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function() {\n\t\t\tthis.stopListening();\n\n\t\t\tif ( this instanceof Backbone.HasOne ) {\n\t\t\t\tthis.setRelated( null );\n\t\t\t}\n\t\t\telse if ( this instanceof Backbone.HasMany ) {\n\t\t\t\tthis.setRelated( this._prepareCollection() );\n\t\t\t}\n\n\t\t\t_.each( this.getReverseRelations(), function( relation ) {\n\t\t\t\trelation.removeRelated( this.instance );\n\t\t\t}, this );\n\t\t}", "language": "javascript", "code": "function() {\n\t\t\tthis.stopListening();\n\n\t\t\tif ( this instanceof Backbone.HasOne ) {\n\t\t\t\tthis.setRelated( null );\n\t\t\t}\n\t\t\telse if ( this instanceof Backbone.HasMany ) {\n\t\t\t\tthis.setRelated( this._prepareCollection() );\n\t\t\t}\n\n\t\t\t_.each( this.getReverseRelations(), function( relation ) {\n\t\t\t\trelation.removeRelated( this.instance );\n\t\t\t}, this );\n\t\t}", "code_tokens": ["function", "(", ")", "{", "this", ".", "stopListening", "(", ")", ";", "if", "(", "this", "instanceof", "Backbone", ".", "HasOne", ")", "{", "this", ".", "setRelated", "(", "null", ")", ";", "}", "else", "if", "(", "this", "instanceof", "Backbone", ".", "HasMany", ")", "{", "this", ".", "setRelated", "(", "this", ".", "_prepareCollection", "(", ")", ")", ";", "}", "_", ".", "each", "(", "this", ".", "getReverseRelations", "(", ")", ",", "function", "(", "relation", ")", "{", "relation", ".", "removeRelated", "(", "this", ".", "instance", ")", ";", "}", ",", "this", ")", ";", "}"], "docstring": "When `this.instance` is destroyed, cleanup our relations.\nGet reverse relation, call removeRelated on each.", "docstring_tokens": ["When", "this", ".", "instance", "is", "destroyed", "cleanup", "our", "relations", ".", "Get", "reverse", "relation", "call", "removeRelated", "on", "each", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L684-L697", "partition": "test"}
{"repo": "dataminr/react-components", "path": "src/js/table/TableStore.js", "func_name": "", "original_string": "function(payload) {\n        var action = payload.action;\n\n        if (!this.shouldHandleAction(action.component)) {\n            return;\n        }\n\n        switch (action.actionType) {\n            case ActionTypes.REQUEST_DATA:\n                this.handleRequestDataAction(action);\n                break;\n            case ActionTypes.TABLE_SORT:\n                this.collection[action.id].sortData(action.data.colIndex, action.data.direction);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.FILTER:\n                this.collection[action.id].setFilterValue(action.data.value);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.ADVANCED_FILTER:\n                this.collection[action.id].setAdvancedFilters(action.data.advancedFilters);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.PAGINATE:\n                this.collection[action.id].paginate(action.data.direction);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.TOGGLE_BULK_SELECT:\n                this.collection[action.id].updateBulkSelection(action.data.deselect);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.TOGGLE_ROW_SELECT:\n                this.collection[action.id].updateRowSelection(action.data.rowIndex);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.DESTROY_INSTANCE:\n                this.destroyInstance(action.id);\n                break;\n        }\n    }", "language": "javascript", "code": "function(payload) {\n        var action = payload.action;\n\n        if (!this.shouldHandleAction(action.component)) {\n            return;\n        }\n\n        switch (action.actionType) {\n            case ActionTypes.REQUEST_DATA:\n                this.handleRequestDataAction(action);\n                break;\n            case ActionTypes.TABLE_SORT:\n                this.collection[action.id].sortData(action.data.colIndex, action.data.direction);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.FILTER:\n                this.collection[action.id].setFilterValue(action.data.value);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.ADVANCED_FILTER:\n                this.collection[action.id].setAdvancedFilters(action.data.advancedFilters);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.PAGINATE:\n                this.collection[action.id].paginate(action.data.direction);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.TOGGLE_BULK_SELECT:\n                this.collection[action.id].updateBulkSelection(action.data.deselect);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.TOGGLE_ROW_SELECT:\n                this.collection[action.id].updateRowSelection(action.data.rowIndex);\n                this.emitChange(action.id);\n                break;\n            case ActionTypes.DESTROY_INSTANCE:\n                this.destroyInstance(action.id);\n                break;\n        }\n    }", "code_tokens": ["function", "(", "payload", ")", "{", "var", "action", "=", "payload", ".", "action", ";", "if", "(", "!", "this", ".", "shouldHandleAction", "(", "action", ".", "component", ")", ")", "{", "return", ";", "}", "switch", "(", "action", ".", "actionType", ")", "{", "case", "ActionTypes", ".", "REQUEST_DATA", ":", "this", ".", "handleRequestDataAction", "(", "action", ")", ";", "break", ";", "case", "ActionTypes", ".", "TABLE_SORT", ":", "this", ".", "collection", "[", "action", ".", "id", "]", ".", "sortData", "(", "action", ".", "data", ".", "colIndex", ",", "action", ".", "data", ".", "direction", ")", ";", "this", ".", "emitChange", "(", "action", ".", "id", ")", ";", "break", ";", "case", "ActionTypes", ".", "FILTER", ":", "this", ".", "collection", "[", "action", ".", "id", "]", ".", "setFilterValue", "(", "action", ".", "data", ".", "value", ")", ";", "this", ".", "emitChange", "(", "action", ".", "id", ")", ";", "break", ";", "case", "ActionTypes", ".", "ADVANCED_FILTER", ":", "this", ".", "collection", "[", "action", ".", "id", "]", ".", "setAdvancedFilters", "(", "action", ".", "data", ".", "advancedFilters", ")", ";", "this", ".", "emitChange", "(", "action", ".", "id", ")", ";", "break", ";", "case", "ActionTypes", ".", "PAGINATE", ":", "this", ".", "collection", "[", "action", ".", "id", "]", ".", "paginate", "(", "action", ".", "data", ".", "direction", ")", ";", "this", ".", "emitChange", "(", "action", ".", "id", ")", ";", "break", ";", "case", "ActionTypes", ".", "TOGGLE_BULK_SELECT", ":", "this", ".", "collection", "[", "action", ".", "id", "]", ".", "updateBulkSelection", "(", "action", ".", "data", ".", "deselect", ")", ";", "this", ".", "emitChange", "(", "action", ".", "id", ")", ";", "break", ";", "case", "ActionTypes", ".", "TOGGLE_ROW_SELECT", ":", "this", ".", "collection", "[", "action", ".", "id", "]", ".", "updateRowSelection", "(", "action", ".", "data", ".", "rowIndex", ")", ";", "this", ".", "emitChange", "(", "action", ".", "id", ")", ";", "break", ";", "case", "ActionTypes", ".", "DESTROY_INSTANCE", ":", "this", ".", "destroyInstance", "(", "action", ".", "id", ")", ";", "break", ";", "}", "}"], "docstring": "Handles all events sent from the dispatcher. Filters out to only those sent via the Table\n@param {Object} payload - Contains action details.", "docstring_tokens": ["Handles", "all", "events", "sent", "from", "the", "dispatcher", ".", "Filters", "out", "to", "only", "those", "sent", "via", "the", "Table"], "sha": "0aa29ed8562ee35fd8e682a5052ac979cd409de7", "url": "https://github.com/dataminr/react-components/blob/0aa29ed8562ee35fd8e682a5052ac979cd409de7/src/js/table/TableStore.js#L498-L537", "partition": "test"}
{"repo": "GeoSensorWebLab/polarmap.js", "path": "js/leaflet.markercluster.js", "func_name": "", "original_string": "function () {\n    var childClusters = this._childClusters.slice(),\n      map = this._group._map,\n      boundsZoom = map.getBoundsZoom(this._bounds),\n      zoom = this._zoom + 1,\n      mapZoom = map.getZoom(),\n      i;\n\n    //calculate how far we need to zoom down to see all of the markers\n    while (childClusters.length > 0 && boundsZoom > zoom) {\n      zoom++;\n      var newClusters = [];\n      for (i = 0; i < childClusters.length; i++) {\n        newClusters = newClusters.concat(childClusters[i]._childClusters);\n      }\n      childClusters = newClusters;\n    }\n\n    if (boundsZoom > zoom) {\n      this._group._map.setView(this._latlng, zoom);\n    } else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead\n      this._group._map.setView(this._latlng, mapZoom + 1);\n    } else {\n      this._group._map.fitBounds(this._bounds);\n    }\n  }", "language": "javascript", "code": "function () {\n    var childClusters = this._childClusters.slice(),\n      map = this._group._map,\n      boundsZoom = map.getBoundsZoom(this._bounds),\n      zoom = this._zoom + 1,\n      mapZoom = map.getZoom(),\n      i;\n\n    //calculate how far we need to zoom down to see all of the markers\n    while (childClusters.length > 0 && boundsZoom > zoom) {\n      zoom++;\n      var newClusters = [];\n      for (i = 0; i < childClusters.length; i++) {\n        newClusters = newClusters.concat(childClusters[i]._childClusters);\n      }\n      childClusters = newClusters;\n    }\n\n    if (boundsZoom > zoom) {\n      this._group._map.setView(this._latlng, zoom);\n    } else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead\n      this._group._map.setView(this._latlng, mapZoom + 1);\n    } else {\n      this._group._map.fitBounds(this._bounds);\n    }\n  }", "code_tokens": ["function", "(", ")", "{", "var", "childClusters", "=", "this", ".", "_childClusters", ".", "slice", "(", ")", ",", "map", "=", "this", ".", "_group", ".", "_map", ",", "boundsZoom", "=", "map", ".", "getBoundsZoom", "(", "this", ".", "_bounds", ")", ",", "zoom", "=", "this", ".", "_zoom", "+", "1", ",", "mapZoom", "=", "map", ".", "getZoom", "(", ")", ",", "i", ";", "//calculate how far we need to zoom down to see all of the markers", "while", "(", "childClusters", ".", "length", ">", "0", "&&", "boundsZoom", ">", "zoom", ")", "{", "zoom", "++", ";", "var", "newClusters", "=", "[", "]", ";", "for", "(", "i", "=", "0", ";", "i", "<", "childClusters", ".", "length", ";", "i", "++", ")", "{", "newClusters", "=", "newClusters", ".", "concat", "(", "childClusters", "[", "i", "]", ".", "_childClusters", ")", ";", "}", "childClusters", "=", "newClusters", ";", "}", "if", "(", "boundsZoom", ">", "zoom", ")", "{", "this", ".", "_group", ".", "_map", ".", "setView", "(", "this", ".", "_latlng", ",", "zoom", ")", ";", "}", "else", "if", "(", "boundsZoom", "<=", "mapZoom", ")", "{", "//If fitBounds wouldn't zoom us down, zoom us down instead", "this", ".", "_group", ".", "_map", ".", "setView", "(", "this", ".", "_latlng", ",", "mapZoom", "+", "1", ")", ";", "}", "else", "{", "this", ".", "_group", ".", "_map", ".", "fitBounds", "(", "this", ".", "_bounds", ")", ";", "}", "}"], "docstring": "Zoom to the minimum of showing all of the child markers, or the extents of this cluster", "docstring_tokens": ["Zoom", "to", "the", "minimum", "of", "showing", "all", "of", "the", "child", "markers", "or", "the", "extents", "of", "this", "cluster"], "sha": "fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b", "url": "https://github.com/GeoSensorWebLab/polarmap.js/blob/fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b/js/leaflet.markercluster.js#L1141-L1166", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/cordova/plugin/plugin_spec_parser.js", "func_name": "PluginSpec", "original_string": "function PluginSpec (raw, scope, id, version) {\n    /** @member {String|null} The npm scope of the plugin spec or null if it does not have one */\n    this.scope = scope || null;\n\n    /** @member {String|null} The id of the plugin or the raw plugin spec if it is not an npm package */\n    this.id = id || raw;\n\n    /** @member {String|null} The specified version of the plugin or null if no version was specified */\n    this.version = version || null;\n\n    /** @member {String|null} The npm package of the plugin (with scope) or null if this is not a spec for an npm package */\n    this.package = (scope ? scope + id : id) || null;\n}", "language": "javascript", "code": "function PluginSpec (raw, scope, id, version) {\n    /** @member {String|null} The npm scope of the plugin spec or null if it does not have one */\n    this.scope = scope || null;\n\n    /** @member {String|null} The id of the plugin or the raw plugin spec if it is not an npm package */\n    this.id = id || raw;\n\n    /** @member {String|null} The specified version of the plugin or null if no version was specified */\n    this.version = version || null;\n\n    /** @member {String|null} The npm package of the plugin (with scope) or null if this is not a spec for an npm package */\n    this.package = (scope ? scope + id : id) || null;\n}", "code_tokens": ["function", "PluginSpec", "(", "raw", ",", "scope", ",", "id", ",", "version", ")", "{", "/** @member {String|null} The npm scope of the plugin spec or null if it does not have one */", "this", ".", "scope", "=", "scope", "||", "null", ";", "/** @member {String|null} The id of the plugin or the raw plugin spec if it is not an npm package */", "this", ".", "id", "=", "id", "||", "raw", ";", "/** @member {String|null} The specified version of the plugin or null if no version was specified */", "this", ".", "version", "=", "version", "||", "null", ";", "/** @member {String|null} The npm package of the plugin (with scope) or null if this is not a spec for an npm package */", "this", ".", "package", "=", "(", "scope", "?", "scope", "+", "id", ":", "id", ")", "||", "null", ";", "}"], "docstring": "Represents a parsed specification for a plugin\n@class\n@param {String} raw      The raw specification (i.e. provided by the user)\n@param {String} scope    The scope of the package if this is an npm package\n@param {String} id       The id of the package if this is an npm package\n@param {String} version  The version specified for the package if this is an npm package", "docstring_tokens": ["Represents", "a", "parsed", "specification", "for", "a", "plugin"], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/plugin/plugin_spec_parser.js#L33-L45", "partition": "test"}
{"repo": "darrencruse/sugarlisp-htmlreader", "path": "readfuncs.js", "func_name": "find_attr_value", "original_string": "function find_attr_value(attrForms, attrName) {\n  var attrVal;\n  var attrPos = -1;\n  if(attrForms && Array.isArray(attrForms)) {\n    attrKey = attrForms.find(function (form, i) {\n      attrPos = i;\n      return (i % 2 === 1) && form.value === attrName;\n    })\n    if(attrKey && attrPos+1 < attrForms.length) {\n      attrVal = attrForms[attrPos+1];\n    }\n  }\n  return attrVal;\n}", "language": "javascript", "code": "function find_attr_value(attrForms, attrName) {\n  var attrVal;\n  var attrPos = -1;\n  if(attrForms && Array.isArray(attrForms)) {\n    attrKey = attrForms.find(function (form, i) {\n      attrPos = i;\n      return (i % 2 === 1) && form.value === attrName;\n    })\n    if(attrKey && attrPos+1 < attrForms.length) {\n      attrVal = attrForms[attrPos+1];\n    }\n  }\n  return attrVal;\n}", "code_tokens": ["function", "find_attr_value", "(", "attrForms", ",", "attrName", ")", "{", "var", "attrVal", ";", "var", "attrPos", "=", "-", "1", ";", "if", "(", "attrForms", "&&", "Array", ".", "isArray", "(", "attrForms", ")", ")", "{", "attrKey", "=", "attrForms", ".", "find", "(", "function", "(", "form", ",", "i", ")", "{", "attrPos", "=", "i", ";", "return", "(", "i", "%", "2", "===", "1", ")", "&&", "form", ".", "value", "===", "attrName", ";", "}", ")", "if", "(", "attrKey", "&&", "attrPos", "+", "1", "<", "attrForms", ".", "length", ")", "{", "attrVal", "=", "attrForms", "[", "attrPos", "+", "1", "]", ";", "}", "}", "return", "attrVal", ";", "}"], "docstring": "find the value form with the given name in the attribute forms, otherwise undefined", "docstring_tokens": ["find", "the", "value", "form", "with", "the", "given", "name", "in", "the", "attribute", "forms", "otherwise", "undefined"], "sha": "7e336435c1d0311504a9aa8909fef35a4d231a33", "url": "https://github.com/darrencruse/sugarlisp-htmlreader/blob/7e336435c1d0311504a9aa8909fef35a4d231a33/readfuncs.js#L148-L161", "partition": "test"}
{"repo": "prtksxna/jsdoc-class-hierarchy", "path": "index.js", "func_name": "", "original_string": "function ( e ) {\n\t\tvar doclet = e.doclet;\n\t\tif (\n\t\t\tdoclet.kind === 'class' &&\n\t\t\tdoclet.augments !== undefined &&\n\t\t\tdoclet.augments.length > 0\n\t\t) {\n\t\t\tparents[ doclet.longname ] = doclet.augments[ 0 ];\n\t\t}\n\t}", "language": "javascript", "code": "function ( e ) {\n\t\tvar doclet = e.doclet;\n\t\tif (\n\t\t\tdoclet.kind === 'class' &&\n\t\t\tdoclet.augments !== undefined &&\n\t\t\tdoclet.augments.length > 0\n\t\t) {\n\t\t\tparents[ doclet.longname ] = doclet.augments[ 0 ];\n\t\t}\n\t}", "code_tokens": ["function", "(", "e", ")", "{", "var", "doclet", "=", "e", ".", "doclet", ";", "if", "(", "doclet", ".", "kind", "===", "'class'", "&&", "doclet", ".", "augments", "!==", "undefined", "&&", "doclet", ".", "augments", ".", "length", ">", "0", ")", "{", "parents", "[", "doclet", ".", "longname", "]", "=", "doclet", ".", "augments", "[", "0", "]", ";", "}", "}"], "docstring": "Add names to the parents map for every new doclet", "docstring_tokens": ["Add", "names", "to", "the", "parents", "map", "for", "every", "new", "doclet"], "sha": "5a3ec689a85aea83ac4b8f1623ea4a79f8676ccc", "url": "https://github.com/prtksxna/jsdoc-class-hierarchy/blob/5a3ec689a85aea83ac4b8f1623ea4a79f8676ccc/index.js#L91-L100", "partition": "test"}
{"repo": "GraFiddle/angular-chart", "path": "angular-chart.js", "func_name": "setupDataBigWatcher", "original_string": "function setupDataBigWatcher(watcher) {\n      return watcher.scope.$watch(function () {\n        if (watcher.scope.options.data && angular.isArray(watcher.scope.options.data)) {\n          return watcher.scope.options.data.length;\n        } else {\n          return 0;\n        }\n      }, function () {\n        if (angular.isFunction(watcher.dataCallback)) {\n          watcher.dataCallback();\n        }\n        setupDataWatcher(watcher);\n      });\n    }", "language": "javascript", "code": "function setupDataBigWatcher(watcher) {\n      return watcher.scope.$watch(function () {\n        if (watcher.scope.options.data && angular.isArray(watcher.scope.options.data)) {\n          return watcher.scope.options.data.length;\n        } else {\n          return 0;\n        }\n      }, function () {\n        if (angular.isFunction(watcher.dataCallback)) {\n          watcher.dataCallback();\n        }\n        setupDataWatcher(watcher);\n      });\n    }", "code_tokens": ["function", "setupDataBigWatcher", "(", "watcher", ")", "{", "return", "watcher", ".", "scope", ".", "$watch", "(", "function", "(", ")", "{", "if", "(", "watcher", ".", "scope", ".", "options", ".", "data", "&&", "angular", ".", "isArray", "(", "watcher", ".", "scope", ".", "options", ".", "data", ")", ")", "{", "return", "watcher", ".", "scope", ".", "options", ".", "data", ".", "length", ";", "}", "else", "{", "return", "0", ";", "}", "}", ",", "function", "(", ")", "{", "if", "(", "angular", ".", "isFunction", "(", "watcher", ".", "dataCallback", ")", ")", "{", "watcher", ".", "dataCallback", "(", ")", ";", "}", "setupDataWatcher", "(", "watcher", ")", ";", "}", ")", ";", "}"], "docstring": "start watcher changes in big datasets, compares length of records", "docstring_tokens": ["start", "watcher", "changes", "in", "big", "datasets", "compares", "length", "of", "records"], "sha": "76620974f0547b5a9c86d2860b6b401af8aee5fc", "url": "https://github.com/GraFiddle/angular-chart/blob/76620974f0547b5a9c86d2860b6b401af8aee5fc/angular-chart.js#L191-L204", "partition": "test"}
{"repo": "nearform/nscale-kernel", "path": "lib/sysrev/sysrev.js", "func_name": "", "original_string": "function(repoPath) {\n    var sys;\n\n    if (fse.existsSync(path.join(repoPath, 'system.js'))) {\n      // TODO extract in its own module\n      sys = require(repoPath + '/system.js');\n      delete require.cache[repoPath + '/system.js'];\n    }\n\n    if (!sys) {\n      return new Error('missing system.js, is this an nscale repository?');\n    }\n    if (!sys.name) {\n      return new Error('missing name in system.js, correct and try again');\n    }\n    if (!sys.namespace) {\n      return new Error('missing namespace in system.js, correct and try again');\n    }\n    if (!sys.id) {\n      return new Error('missing id in system.js, correct and try again');\n    }\n  }", "language": "javascript", "code": "function(repoPath) {\n    var sys;\n\n    if (fse.existsSync(path.join(repoPath, 'system.js'))) {\n      // TODO extract in its own module\n      sys = require(repoPath + '/system.js');\n      delete require.cache[repoPath + '/system.js'];\n    }\n\n    if (!sys) {\n      return new Error('missing system.js, is this an nscale repository?');\n    }\n    if (!sys.name) {\n      return new Error('missing name in system.js, correct and try again');\n    }\n    if (!sys.namespace) {\n      return new Error('missing namespace in system.js, correct and try again');\n    }\n    if (!sys.id) {\n      return new Error('missing id in system.js, correct and try again');\n    }\n  }", "code_tokens": ["function", "(", "repoPath", ")", "{", "var", "sys", ";", "if", "(", "fse", ".", "existsSync", "(", "path", ".", "join", "(", "repoPath", ",", "'system.js'", ")", ")", ")", "{", "// TODO extract in its own module", "sys", "=", "require", "(", "repoPath", "+", "'/system.js'", ")", ";", "delete", "require", ".", "cache", "[", "repoPath", "+", "'/system.js'", "]", ";", "}", "if", "(", "!", "sys", ")", "{", "return", "new", "Error", "(", "'missing system.js, is this an nscale repository?'", ")", ";", "}", "if", "(", "!", "sys", ".", "name", ")", "{", "return", "new", "Error", "(", "'missing name in system.js, correct and try again'", ")", ";", "}", "if", "(", "!", "sys", ".", "namespace", ")", "{", "return", "new", "Error", "(", "'missing namespace in system.js, correct and try again'", ")", ";", "}", "if", "(", "!", "sys", ".", "id", ")", "{", "return", "new", "Error", "(", "'missing id in system.js, correct and try again'", ")", ";", "}", "}"], "docstring": "checks if a directory is a system (has all the required files and correct\nsystem.json and system.js", "docstring_tokens": ["checks", "if", "a", "directory", "is", "a", "system", "(", "has", "all", "the", "required", "files", "and", "correct", "system", ".", "json", "and", "system", ".", "js"], "sha": "5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3", "url": "https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/sysrev/sysrev.js#L67-L88", "partition": "test"}
{"repo": "mysticatea/eslint-utils", "path": "src/get-static-value.js", "func_name": "getStaticValueR", "original_string": "function getStaticValueR(node, initialScope) {\n    if (node != null && Object.hasOwnProperty.call(operations, node.type)) {\n        return operations[node.type](node, initialScope)\n    }\n    return null\n}", "language": "javascript", "code": "function getStaticValueR(node, initialScope) {\n    if (node != null && Object.hasOwnProperty.call(operations, node.type)) {\n        return operations[node.type](node, initialScope)\n    }\n    return null\n}", "code_tokens": ["function", "getStaticValueR", "(", "node", ",", "initialScope", ")", "{", "if", "(", "node", "!=", "null", "&&", "Object", ".", "hasOwnProperty", ".", "call", "(", "operations", ",", "node", ".", "type", ")", ")", "{", "return", "operations", "[", "node", ".", "type", "]", "(", "node", ",", "initialScope", ")", "}", "return", "null", "}"], "docstring": "Get the value of a given node if it's a static value.\n@param {Node} node The node to get.\n@param {Scope|undefined} initialScope The scope to start finding variable.\n@returns {{value:any}|null} The static value of the node, or `null`.", "docstring_tokens": ["Get", "the", "value", "of", "a", "given", "node", "if", "it", "s", "a", "static", "value", "."], "sha": "b2041e47f3c74e00ef7b746c4b0c43fc3f4732f0", "url": "https://github.com/mysticatea/eslint-utils/blob/b2041e47f3c74e00ef7b746c4b0c43fc3f4732f0/src/get-static-value.js#L395-L400", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(options) {\n      var regions;\n      this._initRegionManager();\n  \n      regions = Marionette._getValue(this.regions, this, [options]) || {};\n  \n      // Enable users to define `regions` as instance options.\n      var regionOptions = this.getOption.call(options, 'regions');\n  \n      // enable region options to be a function\n      regionOptions = Marionette._getValue(regionOptions, this, [options]);\n  \n      _.extend(regions, regionOptions);\n  \n      // Normalize region selectors hash to allow\n      // a user to use the @ui. syntax.\n      regions = this.normalizeUIValues(regions, ['selector', 'el']);\n  \n      this.addRegions(regions);\n    }", "language": "javascript", "code": "function(options) {\n      var regions;\n      this._initRegionManager();\n  \n      regions = Marionette._getValue(this.regions, this, [options]) || {};\n  \n      // Enable users to define `regions` as instance options.\n      var regionOptions = this.getOption.call(options, 'regions');\n  \n      // enable region options to be a function\n      regionOptions = Marionette._getValue(regionOptions, this, [options]);\n  \n      _.extend(regions, regionOptions);\n  \n      // Normalize region selectors hash to allow\n      // a user to use the @ui. syntax.\n      regions = this.normalizeUIValues(regions, ['selector', 'el']);\n  \n      this.addRegions(regions);\n    }", "code_tokens": ["function", "(", "options", ")", "{", "var", "regions", ";", "this", ".", "_initRegionManager", "(", ")", ";", "regions", "=", "Marionette", ".", "_getValue", "(", "this", ".", "regions", ",", "this", ",", "[", "options", "]", ")", "||", "{", "}", ";", "// Enable users to define `regions` as instance options.", "var", "regionOptions", "=", "this", ".", "getOption", ".", "call", "(", "options", ",", "'regions'", ")", ";", "// enable region options to be a function", "regionOptions", "=", "Marionette", ".", "_getValue", "(", "regionOptions", ",", "this", ",", "[", "options", "]", ")", ";", "_", ".", "extend", "(", "regions", ",", "regionOptions", ")", ";", "// Normalize region selectors hash to allow", "// a user to use the @ui. syntax.", "regions", "=", "this", ".", "normalizeUIValues", "(", "regions", ",", "[", "'selector'", ",", "'el'", "]", ")", ";", "this", ".", "addRegions", "(", "regions", ")", ";", "}"], "docstring": "Internal method to initialize the regions that have been defined in a `regions` attribute on this layoutView.", "docstring_tokens": ["Internal", "method", "to", "initialize", "the", "regions", "that", "have", "been", "defined", "in", "a", "regions", "attribute", "on", "this", "layoutView", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19253-L19272", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/navigation/Bar.js", "func_name": "", "original_string": "function() {\n        var text = this.backButtonStack[this.backButtonStack.length - 2],\n            useTitleForBackButtonText = this.getUseTitleForBackButtonText();\n\n        if (!useTitleForBackButtonText) {\n            if (text) {\n                text = this.getDefaultBackButtonText();\n            }\n        }\n\n        return text;\n    }", "language": "javascript", "code": "function() {\n        var text = this.backButtonStack[this.backButtonStack.length - 2],\n            useTitleForBackButtonText = this.getUseTitleForBackButtonText();\n\n        if (!useTitleForBackButtonText) {\n            if (text) {\n                text = this.getDefaultBackButtonText();\n            }\n        }\n\n        return text;\n    }", "code_tokens": ["function", "(", ")", "{", "var", "text", "=", "this", ".", "backButtonStack", "[", "this", ".", "backButtonStack", ".", "length", "-", "2", "]", ",", "useTitleForBackButtonText", "=", "this", ".", "getUseTitleForBackButtonText", "(", ")", ";", "if", "(", "!", "useTitleForBackButtonText", ")", "{", "if", "(", "text", ")", "{", "text", "=", "this", ".", "getDefaultBackButtonText", "(", ")", ";", "}", "}", "return", "text", ";", "}"], "docstring": "Returns the text needed for the current back button at anytime.\n@private", "docstring_tokens": ["Returns", "the", "text", "needed", "for", "the", "current", "back", "button", "at", "anytime", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/navigation/Bar.js#L529-L540", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getEffectiveDecoratorArgumentType", "original_string": "function getEffectiveDecoratorArgumentType(node, argIndex) {\n            if (argIndex === 0) {\n                return getEffectiveDecoratorFirstArgumentType(node.parent);\n            }\n            else if (argIndex === 1) {\n                return getEffectiveDecoratorSecondArgumentType(node.parent);\n            }\n            else if (argIndex === 2) {\n                return getEffectiveDecoratorThirdArgumentType(node.parent);\n            }\n            ts.Debug.fail(\"Decorators should not have a fourth synthetic argument.\");\n            return unknownType;\n        }", "language": "javascript", "code": "function getEffectiveDecoratorArgumentType(node, argIndex) {\n            if (argIndex === 0) {\n                return getEffectiveDecoratorFirstArgumentType(node.parent);\n            }\n            else if (argIndex === 1) {\n                return getEffectiveDecoratorSecondArgumentType(node.parent);\n            }\n            else if (argIndex === 2) {\n                return getEffectiveDecoratorThirdArgumentType(node.parent);\n            }\n            ts.Debug.fail(\"Decorators should not have a fourth synthetic argument.\");\n            return unknownType;\n        }", "code_tokens": ["function", "getEffectiveDecoratorArgumentType", "(", "node", ",", "argIndex", ")", "{", "if", "(", "argIndex", "===", "0", ")", "{", "return", "getEffectiveDecoratorFirstArgumentType", "(", "node", ".", "parent", ")", ";", "}", "else", "if", "(", "argIndex", "===", "1", ")", "{", "return", "getEffectiveDecoratorSecondArgumentType", "(", "node", ".", "parent", ")", ";", "}", "else", "if", "(", "argIndex", "===", "2", ")", "{", "return", "getEffectiveDecoratorThirdArgumentType", "(", "node", ".", "parent", ")", ";", "}", "ts", ".", "Debug", ".", "fail", "(", "\"Decorators should not have a fourth synthetic argument.\"", ")", ";", "return", "unknownType", ";", "}"], "docstring": "Returns the effective argument type for the provided argument to a decorator.", "docstring_tokens": ["Returns", "the", "effective", "argument", "type", "for", "the", "provided", "argument", "to", "a", "decorator", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L21279-L21291", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getEffectiveArgument", "original_string": "function getEffectiveArgument(node, args, argIndex) {\n            // For a decorator or the first argument of a tagged template expression we return undefined.\n            if (node.kind === 139 /* Decorator */ ||\n                (argIndex === 0 && node.kind === 170 /* TaggedTemplateExpression */)) {\n                return undefined;\n            }\n            return args[argIndex];\n        }", "language": "javascript", "code": "function getEffectiveArgument(node, args, argIndex) {\n            // For a decorator or the first argument of a tagged template expression we return undefined.\n            if (node.kind === 139 /* Decorator */ ||\n                (argIndex === 0 && node.kind === 170 /* TaggedTemplateExpression */)) {\n                return undefined;\n            }\n            return args[argIndex];\n        }", "code_tokens": ["function", "getEffectiveArgument", "(", "node", ",", "args", ",", "argIndex", ")", "{", "// For a decorator or the first argument of a tagged template expression we return undefined.", "if", "(", "node", ".", "kind", "===", "139", "/* Decorator */", "||", "(", "argIndex", "===", "0", "&&", "node", ".", "kind", "===", "170", "/* TaggedTemplateExpression */", ")", ")", "{", "return", "undefined", ";", "}", "return", "args", "[", "argIndex", "]", ";", "}"], "docstring": "Gets the effective argument expression for an argument in a call expression.", "docstring_tokens": ["Gets", "the", "effective", "argument", "expression", "for", "an", "argument", "in", "a", "call", "expression", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L21312-L21319", "partition": "test"}
{"repo": "AustP/jwt-express", "path": "jwt-express.js", "func_name": "", "original_string": "function(token) {\n        this.token = token || '';\n        \n        try {\n            this.payload = utils.verify(this.token, this.secret, this.options.verifyOptions);\n            this.valid = true;\n        } catch (err) {\n            this.payload = utils.decode(this.token) || {};\n            if (err.name == 'TokenExpiredError') {\n                this.expired = true;\n            }\n        }\n        \n        if (this.valid && !this.options.verify(this)) {\n            this.valid = false;\n        }\n        \n        if (this.payload.stales && Date.now() <= this.payload.stales) {\n            this.stale = false;\n        }\n        \n        return this;\n    }", "language": "javascript", "code": "function(token) {\n        this.token = token || '';\n        \n        try {\n            this.payload = utils.verify(this.token, this.secret, this.options.verifyOptions);\n            this.valid = true;\n        } catch (err) {\n            this.payload = utils.decode(this.token) || {};\n            if (err.name == 'TokenExpiredError') {\n                this.expired = true;\n            }\n        }\n        \n        if (this.valid && !this.options.verify(this)) {\n            this.valid = false;\n        }\n        \n        if (this.payload.stales && Date.now() <= this.payload.stales) {\n            this.stale = false;\n        }\n        \n        return this;\n    }", "code_tokens": ["function", "(", "token", ")", "{", "this", ".", "token", "=", "token", "||", "''", ";", "try", "{", "this", ".", "payload", "=", "utils", ".", "verify", "(", "this", ".", "token", ",", "this", ".", "secret", ",", "this", ".", "options", ".", "verifyOptions", ")", ";", "this", ".", "valid", "=", "true", ";", "}", "catch", "(", "err", ")", "{", "this", ".", "payload", "=", "utils", ".", "decode", "(", "this", ".", "token", ")", "||", "{", "}", ";", "if", "(", "err", ".", "name", "==", "'TokenExpiredError'", ")", "{", "this", ".", "expired", "=", "true", ";", "}", "}", "if", "(", "this", ".", "valid", "&&", "!", "this", ".", "options", ".", "verify", "(", "this", ")", ")", "{", "this", ".", "valid", "=", "false", ";", "}", "if", "(", "this", ".", "payload", ".", "stales", "&&", "Date", ".", "now", "(", ")", "<=", "this", ".", "payload", ".", "stales", ")", "{", "this", ".", "stale", "=", "false", ";", "}", "return", "this", ";", "}"], "docstring": "verify - verifies the JWT's token\n@param string token The token to verify\n@return this", "docstring_tokens": ["verify", "-", "verifies", "the", "JWT", "s", "token"], "sha": "f33e5c858e19826b7d767939a7048e3c5ff66387", "url": "https://github.com/AustP/jwt-express/blob/f33e5c858e19826b7d767939a7048e3c5ff66387/jwt-express.js#L87-L109", "partition": "test"}
{"repo": "seripap/vainglory", "path": "dist/api/parser.js", "func_name": "filterRelations", "original_string": "function filterRelations(relation) {\n    var mappedData = includedData.find(function (inc) {\n      return inc.id === relation.id;\n    });\n    var RelationModel = getModel(relation.type);\n    var modeledData = new RelationModel(mappedData);\n\n    return checkForRelations(modeledData, modeledData.data);\n  }", "language": "javascript", "code": "function filterRelations(relation) {\n    var mappedData = includedData.find(function (inc) {\n      return inc.id === relation.id;\n    });\n    var RelationModel = getModel(relation.type);\n    var modeledData = new RelationModel(mappedData);\n\n    return checkForRelations(modeledData, modeledData.data);\n  }", "code_tokens": ["function", "filterRelations", "(", "relation", ")", "{", "var", "mappedData", "=", "includedData", ".", "find", "(", "function", "(", "inc", ")", "{", "return", "inc", ".", "id", "===", "relation", ".", "id", ";", "}", ")", ";", "var", "RelationModel", "=", "getModel", "(", "relation", ".", "type", ")", ";", "var", "modeledData", "=", "new", "RelationModel", "(", "mappedData", ")", ";", "return", "checkForRelations", "(", "modeledData", ",", "modeledData", ".", "data", ")", ";", "}"], "docstring": "Filters models so they are formatted correctly.", "docstring_tokens": ["Filters", "models", "so", "they", "are", "formatted", "correctly", "."], "sha": "885369e465c143eaac27b90c28a22e4af2266fa6", "url": "https://github.com/seripap/vainglory/blob/885369e465c143eaac27b90c28a22e4af2266fa6/dist/api/parser.js#L103-L111", "partition": "test"}
{"repo": "JedWatson/asyncdi", "path": "index.js", "func_name": "", "original_string": "function(context, callback) {\n\t\tif (arguments.length === 1) {\n\t\t\tcallback = context;\n\t\t\tcontext = this._context;\n\t\t}\n\t\tif (this.isAsync) {\n\t\t\t// clone the arguments so this.call can be reused with different callbacks\n\t\t\tvar asyncArgs = this._arguments.slice();\n\t\t\t// push the callback onto the new arguments array\n\t\t\tasyncArgs.push(callback);\n\t\t\t// call the function\n\t\t\tthis.fn.apply(context, asyncArgs);\n\t\t} else {\n\t\t\t// if the function isn't async, allow it to be called with or without a callback\n\t\t\tif (callback) {\n\t\t\t\t// If a callback is provided, it must use the error-first arguments pattern.\n\t\t\t\t// The return value of the function will be the second argument.\n\t\t\t\ttry {\n\t\t\t\t\tcallback(null, this.fn.apply(context, this._arguments));\n\t\t\t\t} catch(e) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If no callback is provided simply return the result of the function\n\t\t\t\treturn this.fn.apply(context, this._arguments);\n\t\t\t}\n\t\t}\n\t}", "language": "javascript", "code": "function(context, callback) {\n\t\tif (arguments.length === 1) {\n\t\t\tcallback = context;\n\t\t\tcontext = this._context;\n\t\t}\n\t\tif (this.isAsync) {\n\t\t\t// clone the arguments so this.call can be reused with different callbacks\n\t\t\tvar asyncArgs = this._arguments.slice();\n\t\t\t// push the callback onto the new arguments array\n\t\t\tasyncArgs.push(callback);\n\t\t\t// call the function\n\t\t\tthis.fn.apply(context, asyncArgs);\n\t\t} else {\n\t\t\t// if the function isn't async, allow it to be called with or without a callback\n\t\t\tif (callback) {\n\t\t\t\t// If a callback is provided, it must use the error-first arguments pattern.\n\t\t\t\t// The return value of the function will be the second argument.\n\t\t\t\ttry {\n\t\t\t\t\tcallback(null, this.fn.apply(context, this._arguments));\n\t\t\t\t} catch(e) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If no callback is provided simply return the result of the function\n\t\t\t\treturn this.fn.apply(context, this._arguments);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["function", "(", "context", ",", "callback", ")", "{", "if", "(", "arguments", ".", "length", "===", "1", ")", "{", "callback", "=", "context", ";", "context", "=", "this", ".", "_context", ";", "}", "if", "(", "this", ".", "isAsync", ")", "{", "// clone the arguments so this.call can be reused with different callbacks", "var", "asyncArgs", "=", "this", ".", "_arguments", ".", "slice", "(", ")", ";", "// push the callback onto the new arguments array", "asyncArgs", ".", "push", "(", "callback", ")", ";", "// call the function", "this", ".", "fn", ".", "apply", "(", "context", ",", "asyncArgs", ")", ";", "}", "else", "{", "// if the function isn't async, allow it to be called with or without a callback", "if", "(", "callback", ")", "{", "// If a callback is provided, it must use the error-first arguments pattern.", "// The return value of the function will be the second argument.", "try", "{", "callback", "(", "null", ",", "this", ".", "fn", ".", "apply", "(", "context", ",", "this", ".", "_arguments", ")", ")", ";", "}", "catch", "(", "e", ")", "{", "callback", "(", "e", ")", ";", "}", "}", "else", "{", "// If no callback is provided simply return the result of the function", "return", "this", ".", "fn", ".", "apply", "(", "context", ",", "this", ".", "_arguments", ")", ";", "}", "}", "}"], "docstring": "Calls the function\n\nWill return the result if not async and no callback is provided\n\n@param  {Object} context (optional)\n@param  {Function} callback", "docstring_tokens": ["Calls", "the", "function"], "sha": "4e9dd53ded83b65fc96f07fd9347931a1c82b302", "url": "https://github.com/JedWatson/asyncdi/blob/4e9dd53ded83b65fc96f07fd9347931a1c82b302/index.js#L124-L151", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/input-generators/robots.js", "func_name": "getRobotsFile", "original_string": "function getRobotsFile (options, callback) {\n  fs.readFile(options.source, function (err, data) {\n    if (!err) {\n      data.toString().split('\\n').every(function (line) {\n        // Process the line input, but break if base.input returns false.\n        // For now, this can only happen if no outputDir is defined,\n        //   which is a fatal bad option problem and will happen immediately.\n        if (!oneline(line, options)) {\n          err = common.prependMsgToErr(base.generatorError(), line, true);\n          return false;\n        }\n        return true;\n      });\n    }\n\n    callback(err);\n  });\n}", "language": "javascript", "code": "function getRobotsFile (options, callback) {\n  fs.readFile(options.source, function (err, data) {\n    if (!err) {\n      data.toString().split('\\n').every(function (line) {\n        // Process the line input, but break if base.input returns false.\n        // For now, this can only happen if no outputDir is defined,\n        //   which is a fatal bad option problem and will happen immediately.\n        if (!oneline(line, options)) {\n          err = common.prependMsgToErr(base.generatorError(), line, true);\n          return false;\n        }\n        return true;\n      });\n    }\n\n    callback(err);\n  });\n}", "code_tokens": ["function", "getRobotsFile", "(", "options", ",", "callback", ")", "{", "fs", ".", "readFile", "(", "options", ".", "source", ",", "function", "(", "err", ",", "data", ")", "{", "if", "(", "!", "err", ")", "{", "data", ".", "toString", "(", ")", ".", "split", "(", "'\\n'", ")", ".", "every", "(", "function", "(", "line", ")", "{", "// Process the line input, but break if base.input returns false.", "// For now, this can only happen if no outputDir is defined,", "//   which is a fatal bad option problem and will happen immediately.", "if", "(", "!", "oneline", "(", "line", ",", "options", ")", ")", "{", "err", "=", "common", ".", "prependMsgToErr", "(", "base", ".", "generatorError", "(", ")", ",", "line", ",", "true", ")", ";", "return", "false", ";", "}", "return", "true", ";", "}", ")", ";", "}", "callback", "(", "err", ")", ";", "}", ")", ";", "}"], "docstring": "Reads the robots.txt file and parses it.", "docstring_tokens": ["Reads", "the", "robots", ".", "txt", "file", "and", "parses", "it", "."], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/input-generators/robots.js#L81-L98", "partition": "test"}
{"repo": "acarl005/join-monster", "path": "src/stringifiers/shared.js", "func_name": "sortKeyToWhereCondition", "original_string": "function sortKeyToWhereCondition(keyObj, descending, sortTable, dialect) {\n  const { name, quote: q } = dialect\n  const sortColumns = []\n  const sortValues = []\n  for (let key in keyObj) {\n    sortColumns.push(`${q(sortTable)}.${q(key)}`)\n    sortValues.push(maybeQuote(keyObj[key], name))\n  }\n  const operator = descending ? '<' : '>'\n  return name === 'oracle'\n    ? recursiveWhereJoin(sortColumns, sortValues, operator)\n    : `(${sortColumns.join(', ')}) ${operator} (${sortValues.join(', ')})`\n}", "language": "javascript", "code": "function sortKeyToWhereCondition(keyObj, descending, sortTable, dialect) {\n  const { name, quote: q } = dialect\n  const sortColumns = []\n  const sortValues = []\n  for (let key in keyObj) {\n    sortColumns.push(`${q(sortTable)}.${q(key)}`)\n    sortValues.push(maybeQuote(keyObj[key], name))\n  }\n  const operator = descending ? '<' : '>'\n  return name === 'oracle'\n    ? recursiveWhereJoin(sortColumns, sortValues, operator)\n    : `(${sortColumns.join(', ')}) ${operator} (${sortValues.join(', ')})`\n}", "code_tokens": ["function", "sortKeyToWhereCondition", "(", "keyObj", ",", "descending", ",", "sortTable", ",", "dialect", ")", "{", "const", "{", "name", ",", "quote", ":", "q", "}", "=", "dialect", "const", "sortColumns", "=", "[", "]", "const", "sortValues", "=", "[", "]", "for", "(", "let", "key", "in", "keyObj", ")", "{", "sortColumns", ".", "push", "(", "`", "${", "q", "(", "sortTable", ")", "}", "${", "q", "(", "key", ")", "}", "`", ")", "sortValues", ".", "push", "(", "maybeQuote", "(", "keyObj", "[", "key", "]", ",", "name", ")", ")", "}", "const", "operator", "=", "descending", "?", "'<'", ":", "'>'", "return", "name", "===", "'oracle'", "?", "recursiveWhereJoin", "(", "sortColumns", ",", "sortValues", ",", "operator", ")", ":", "`", "${", "sortColumns", ".", "join", "(", "', '", ")", "}", "${", "operator", "}", "${", "sortValues", ".", "join", "(", "', '", ")", "}", "`", "}"], "docstring": "take the sort key and translate that for the where clause", "docstring_tokens": ["take", "the", "sort", "key", "and", "translate", "that", "for", "the", "where", "clause"], "sha": "8db8b54aaefd2fd975d63e2ab3ec05922e25118c", "url": "https://github.com/acarl005/join-monster/blob/8db8b54aaefd2fd975d63e2ab3ec05922e25118c/src/stringifiers/shared.js#L204-L216", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      this.destroyEmptyView();\n      this.destroyChildren({checkEmpty: false});\n  \n      if (this.isEmpty(this.collection)) {\n        this.showEmptyView();\n      } else {\n        this.triggerMethod('before:render:collection', this);\n        this.startBuffering();\n        this.showCollection();\n        this.endBuffering();\n        this.triggerMethod('render:collection', this);\n  \n        // If we have shown children and none have passed the filter, show the empty view\n        if (this.children.isEmpty() && this.getOption('filter')) {\n          this.showEmptyView();\n        }\n      }\n    }", "language": "javascript", "code": "function() {\n      this.destroyEmptyView();\n      this.destroyChildren({checkEmpty: false});\n  \n      if (this.isEmpty(this.collection)) {\n        this.showEmptyView();\n      } else {\n        this.triggerMethod('before:render:collection', this);\n        this.startBuffering();\n        this.showCollection();\n        this.endBuffering();\n        this.triggerMethod('render:collection', this);\n  \n        // If we have shown children and none have passed the filter, show the empty view\n        if (this.children.isEmpty() && this.getOption('filter')) {\n          this.showEmptyView();\n        }\n      }\n    }", "code_tokens": ["function", "(", ")", "{", "this", ".", "destroyEmptyView", "(", ")", ";", "this", ".", "destroyChildren", "(", "{", "checkEmpty", ":", "false", "}", ")", ";", "if", "(", "this", ".", "isEmpty", "(", "this", ".", "collection", ")", ")", "{", "this", ".", "showEmptyView", "(", ")", ";", "}", "else", "{", "this", ".", "triggerMethod", "(", "'before:render:collection'", ",", "this", ")", ";", "this", ".", "startBuffering", "(", ")", ";", "this", ".", "showCollection", "(", ")", ";", "this", ".", "endBuffering", "(", ")", ";", "this", ".", "triggerMethod", "(", "'render:collection'", ",", "this", ")", ";", "// If we have shown children and none have passed the filter, show the empty view", "if", "(", "this", ".", "children", ".", "isEmpty", "(", ")", "&&", "this", ".", "getOption", "(", "'filter'", ")", ")", "{", "this", ".", "showEmptyView", "(", ")", ";", "}", "}", "}"], "docstring": "Internal method. Separated so that CompositeView can have more control over events being triggered, around the rendering process", "docstring_tokens": ["Internal", "method", ".", "Separated", "so", "that", "CompositeView", "can", "have", "more", "control", "over", "events", "being", "triggered", "around", "the", "rendering", "process"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18479-L18497", "partition": "test"}
{"repo": "azproduction/lmd", "path": "examples/demos/mock_chat/js/lmd/index.lmd.js", "func_name": "stats_calculate_coverage", "original_string": "function stats_calculate_coverage(moduleName) {\n    var stats = sb.trigger('*:stats-get', moduleName, null)[1],\n        total,\n        covered,\n        lineId,\n        lineNum,\n        parts;\n\n    var lineReport = {};\n\n    if (!stats.lines) {\n        return;\n    }\n    stats.coverage = {};\n\n    covered = 0;\n    total = stats.lines.length;\n    for (lineId in stats.runLines) {\n        if (stats.runLines[lineId] > 0) {\n            covered++;\n        } else {\n            lineNum = lineId;\n            if (!lineReport[lineNum]) {\n                lineReport[lineNum] = {};\n            }\n            lineReport[lineNum].lines = false;\n        }\n    }\n    stats.coverage.lines = {\n        total: total,\n        covered: covered,\n        percentage: 100.0 * (total ? covered / total : 1)\n    };\n\n    covered = 0;\n    total = stats.functions.length;\n    for (lineId in stats.runFunctions) {\n        if (stats.runFunctions[lineId] > 0) {\n            covered++;\n        } else {\n            parts = lineId.split(':');\n            lineNum = parts[1];\n            if (!lineReport[lineNum]) {\n                lineReport[lineNum] = {};\n            }\n            if (!lineReport[lineNum].functions) {\n                lineReport[lineNum].functions = [];\n            }\n            lineReport[lineNum].functions.push(parts[0]);\n        }\n    }\n    stats.coverage.functions = {\n        total:total,\n        covered:covered,\n        percentage:100.0 * (total ? covered / total : 1)\n    };\n\n    covered = 0;\n    total = stats.conditions.length;\n    for (lineId in stats.runConditions) {\n        if (stats.runConditions[lineId][1] > 0) {\n            covered += 1;\n        }\n\n        if (stats.runConditions[lineId][1] === 0) {\n\n            parts = lineId.split(':');\n            lineNum = parts[1];\n            if (!lineReport[lineNum]) {\n                lineReport[lineNum] = {};\n            }\n            if (!lineReport[lineNum].conditions) {\n                lineReport[lineNum].conditions = [];\n            }\n            lineReport[lineNum].conditions.push(stats.runConditions[lineId]);\n        }\n    }\n    stats.coverage.conditions = {\n        total:total,\n        covered:covered,\n        percentage:100.0 * (total ? covered / total : 1)\n    };\n    stats.coverage.report = lineReport;\n}", "language": "javascript", "code": "function stats_calculate_coverage(moduleName) {\n    var stats = sb.trigger('*:stats-get', moduleName, null)[1],\n        total,\n        covered,\n        lineId,\n        lineNum,\n        parts;\n\n    var lineReport = {};\n\n    if (!stats.lines) {\n        return;\n    }\n    stats.coverage = {};\n\n    covered = 0;\n    total = stats.lines.length;\n    for (lineId in stats.runLines) {\n        if (stats.runLines[lineId] > 0) {\n            covered++;\n        } else {\n            lineNum = lineId;\n            if (!lineReport[lineNum]) {\n                lineReport[lineNum] = {};\n            }\n            lineReport[lineNum].lines = false;\n        }\n    }\n    stats.coverage.lines = {\n        total: total,\n        covered: covered,\n        percentage: 100.0 * (total ? covered / total : 1)\n    };\n\n    covered = 0;\n    total = stats.functions.length;\n    for (lineId in stats.runFunctions) {\n        if (stats.runFunctions[lineId] > 0) {\n            covered++;\n        } else {\n            parts = lineId.split(':');\n            lineNum = parts[1];\n            if (!lineReport[lineNum]) {\n                lineReport[lineNum] = {};\n            }\n            if (!lineReport[lineNum].functions) {\n                lineReport[lineNum].functions = [];\n            }\n            lineReport[lineNum].functions.push(parts[0]);\n        }\n    }\n    stats.coverage.functions = {\n        total:total,\n        covered:covered,\n        percentage:100.0 * (total ? covered / total : 1)\n    };\n\n    covered = 0;\n    total = stats.conditions.length;\n    for (lineId in stats.runConditions) {\n        if (stats.runConditions[lineId][1] > 0) {\n            covered += 1;\n        }\n\n        if (stats.runConditions[lineId][1] === 0) {\n\n            parts = lineId.split(':');\n            lineNum = parts[1];\n            if (!lineReport[lineNum]) {\n                lineReport[lineNum] = {};\n            }\n            if (!lineReport[lineNum].conditions) {\n                lineReport[lineNum].conditions = [];\n            }\n            lineReport[lineNum].conditions.push(stats.runConditions[lineId]);\n        }\n    }\n    stats.coverage.conditions = {\n        total:total,\n        covered:covered,\n        percentage:100.0 * (total ? covered / total : 1)\n    };\n    stats.coverage.report = lineReport;\n}", "code_tokens": ["function", "stats_calculate_coverage", "(", "moduleName", ")", "{", "var", "stats", "=", "sb", ".", "trigger", "(", "'*:stats-get'", ",", "moduleName", ",", "null", ")", "[", "1", "]", ",", "total", ",", "covered", ",", "lineId", ",", "lineNum", ",", "parts", ";", "var", "lineReport", "=", "{", "}", ";", "if", "(", "!", "stats", ".", "lines", ")", "{", "return", ";", "}", "stats", ".", "coverage", "=", "{", "}", ";", "covered", "=", "0", ";", "total", "=", "stats", ".", "lines", ".", "length", ";", "for", "(", "lineId", "in", "stats", ".", "runLines", ")", "{", "if", "(", "stats", ".", "runLines", "[", "lineId", "]", ">", "0", ")", "{", "covered", "++", ";", "}", "else", "{", "lineNum", "=", "lineId", ";", "if", "(", "!", "lineReport", "[", "lineNum", "]", ")", "{", "lineReport", "[", "lineNum", "]", "=", "{", "}", ";", "}", "lineReport", "[", "lineNum", "]", ".", "lines", "=", "false", ";", "}", "}", "stats", ".", "coverage", ".", "lines", "=", "{", "total", ":", "total", ",", "covered", ":", "covered", ",", "percentage", ":", "100.0", "*", "(", "total", "?", "covered", "/", "total", ":", "1", ")", "}", ";", "covered", "=", "0", ";", "total", "=", "stats", ".", "functions", ".", "length", ";", "for", "(", "lineId", "in", "stats", ".", "runFunctions", ")", "{", "if", "(", "stats", ".", "runFunctions", "[", "lineId", "]", ">", "0", ")", "{", "covered", "++", ";", "}", "else", "{", "parts", "=", "lineId", ".", "split", "(", "':'", ")", ";", "lineNum", "=", "parts", "[", "1", "]", ";", "if", "(", "!", "lineReport", "[", "lineNum", "]", ")", "{", "lineReport", "[", "lineNum", "]", "=", "{", "}", ";", "}", "if", "(", "!", "lineReport", "[", "lineNum", "]", ".", "functions", ")", "{", "lineReport", "[", "lineNum", "]", ".", "functions", "=", "[", "]", ";", "}", "lineReport", "[", "lineNum", "]", ".", "functions", ".", "push", "(", "parts", "[", "0", "]", ")", ";", "}", "}", "stats", ".", "coverage", ".", "functions", "=", "{", "total", ":", "total", ",", "covered", ":", "covered", ",", "percentage", ":", "100.0", "*", "(", "total", "?", "covered", "/", "total", ":", "1", ")", "}", ";", "covered", "=", "0", ";", "total", "=", "stats", ".", "conditions", ".", "length", ";", "for", "(", "lineId", "in", "stats", ".", "runConditions", ")", "{", "if", "(", "stats", ".", "runConditions", "[", "lineId", "]", "[", "1", "]", ">", "0", ")", "{", "covered", "+=", "1", ";", "}", "if", "(", "stats", ".", "runConditions", "[", "lineId", "]", "[", "1", "]", "===", "0", ")", "{", "parts", "=", "lineId", ".", "split", "(", "':'", ")", ";", "lineNum", "=", "parts", "[", "1", "]", ";", "if", "(", "!", "lineReport", "[", "lineNum", "]", ")", "{", "lineReport", "[", "lineNum", "]", "=", "{", "}", ";", "}", "if", "(", "!", "lineReport", "[", "lineNum", "]", ".", "conditions", ")", "{", "lineReport", "[", "lineNum", "]", ".", "conditions", "=", "[", "]", ";", "}", "lineReport", "[", "lineNum", "]", ".", "conditions", ".", "push", "(", "stats", ".", "runConditions", "[", "lineId", "]", ")", ";", "}", "}", "stats", ".", "coverage", ".", "conditions", "=", "{", "total", ":", "total", ",", "covered", ":", "covered", ",", "percentage", ":", "100.0", "*", "(", "total", "?", "covered", "/", "total", ":", "1", ")", "}", ";", "stats", ".", "coverage", ".", "report", "=", "lineReport", ";", "}"], "docstring": "Calculate coverage total\n\n@param moduleName", "docstring_tokens": ["Calculate", "coverage", "total"], "sha": "03410c36839728de683c697670e1b205dc8193ee", "url": "https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/examples/demos/mock_chat/js/lmd/index.lmd.js#L831-L914", "partition": "test"}
{"repo": "liabru/matter-js", "path": "src/render/RenderPixi.js", "func_name": "", "original_string": "function(render, body) {\n        var bodyRender = body.render,\n            options = render.options,\n            primitive = new PIXI.Graphics(),\n            fillStyle = Common.colorToNumber(bodyRender.fillStyle),\n            strokeStyle = Common.colorToNumber(bodyRender.strokeStyle),\n            strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle),\n            strokeStyleWireframe = Common.colorToNumber('#bbb'),\n            strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'),\n            part;\n\n        primitive.clear();\n\n        // handle compound parts\n        for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n            part = body.parts[k];\n\n            if (!options.wireframes) {\n                primitive.beginFill(fillStyle, 1);\n                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);\n            } else {\n                primitive.beginFill(0, 0);\n                primitive.lineStyle(1, strokeStyleWireframe, 1);\n            }\n\n            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);\n\n            for (var j = 1; j < part.vertices.length; j++) {\n                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);\n            }\n\n            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);\n\n            primitive.endFill();\n\n            // angle indicator\n            if (options.showAngleIndicator || options.showAxes) {\n                primitive.beginFill(0, 0);\n\n                if (options.wireframes) {\n                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);\n                } else {\n                    primitive.lineStyle(1, strokeStyleIndicator);\n                }\n\n                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);\n                primitive.lineTo(((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2 - body.position.x), \n                                 ((part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2 - body.position.y));\n\n                primitive.endFill();\n            }\n        }\n\n        return primitive;\n    }", "language": "javascript", "code": "function(render, body) {\n        var bodyRender = body.render,\n            options = render.options,\n            primitive = new PIXI.Graphics(),\n            fillStyle = Common.colorToNumber(bodyRender.fillStyle),\n            strokeStyle = Common.colorToNumber(bodyRender.strokeStyle),\n            strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle),\n            strokeStyleWireframe = Common.colorToNumber('#bbb'),\n            strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'),\n            part;\n\n        primitive.clear();\n\n        // handle compound parts\n        for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n            part = body.parts[k];\n\n            if (!options.wireframes) {\n                primitive.beginFill(fillStyle, 1);\n                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);\n            } else {\n                primitive.beginFill(0, 0);\n                primitive.lineStyle(1, strokeStyleWireframe, 1);\n            }\n\n            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);\n\n            for (var j = 1; j < part.vertices.length; j++) {\n                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);\n            }\n\n            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);\n\n            primitive.endFill();\n\n            // angle indicator\n            if (options.showAngleIndicator || options.showAxes) {\n                primitive.beginFill(0, 0);\n\n                if (options.wireframes) {\n                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);\n                } else {\n                    primitive.lineStyle(1, strokeStyleIndicator);\n                }\n\n                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);\n                primitive.lineTo(((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2 - body.position.x), \n                                 ((part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2 - body.position.y));\n\n                primitive.endFill();\n            }\n        }\n\n        return primitive;\n    }", "code_tokens": ["function", "(", "render", ",", "body", ")", "{", "var", "bodyRender", "=", "body", ".", "render", ",", "options", "=", "render", ".", "options", ",", "primitive", "=", "new", "PIXI", ".", "Graphics", "(", ")", ",", "fillStyle", "=", "Common", ".", "colorToNumber", "(", "bodyRender", ".", "fillStyle", ")", ",", "strokeStyle", "=", "Common", ".", "colorToNumber", "(", "bodyRender", ".", "strokeStyle", ")", ",", "strokeStyleIndicator", "=", "Common", ".", "colorToNumber", "(", "bodyRender", ".", "strokeStyle", ")", ",", "strokeStyleWireframe", "=", "Common", ".", "colorToNumber", "(", "'#bbb'", ")", ",", "strokeStyleWireframeIndicator", "=", "Common", ".", "colorToNumber", "(", "'#CD5C5C'", ")", ",", "part", ";", "primitive", ".", "clear", "(", ")", ";", "// handle compound parts", "for", "(", "var", "k", "=", "body", ".", "parts", ".", "length", ">", "1", "?", "1", ":", "0", ";", "k", "<", "body", ".", "parts", ".", "length", ";", "k", "++", ")", "{", "part", "=", "body", ".", "parts", "[", "k", "]", ";", "if", "(", "!", "options", ".", "wireframes", ")", "{", "primitive", ".", "beginFill", "(", "fillStyle", ",", "1", ")", ";", "primitive", ".", "lineStyle", "(", "bodyRender", ".", "lineWidth", ",", "strokeStyle", ",", "1", ")", ";", "}", "else", "{", "primitive", ".", "beginFill", "(", "0", ",", "0", ")", ";", "primitive", ".", "lineStyle", "(", "1", ",", "strokeStyleWireframe", ",", "1", ")", ";", "}", "primitive", ".", "moveTo", "(", "part", ".", "vertices", "[", "0", "]", ".", "x", "-", "body", ".", "position", ".", "x", ",", "part", ".", "vertices", "[", "0", "]", ".", "y", "-", "body", ".", "position", ".", "y", ")", ";", "for", "(", "var", "j", "=", "1", ";", "j", "<", "part", ".", "vertices", ".", "length", ";", "j", "++", ")", "{", "primitive", ".", "lineTo", "(", "part", ".", "vertices", "[", "j", "]", ".", "x", "-", "body", ".", "position", ".", "x", ",", "part", ".", "vertices", "[", "j", "]", ".", "y", "-", "body", ".", "position", ".", "y", ")", ";", "}", "primitive", ".", "lineTo", "(", "part", ".", "vertices", "[", "0", "]", ".", "x", "-", "body", ".", "position", ".", "x", ",", "part", ".", "vertices", "[", "0", "]", ".", "y", "-", "body", ".", "position", ".", "y", ")", ";", "primitive", ".", "endFill", "(", ")", ";", "// angle indicator", "if", "(", "options", ".", "showAngleIndicator", "||", "options", ".", "showAxes", ")", "{", "primitive", ".", "beginFill", "(", "0", ",", "0", ")", ";", "if", "(", "options", ".", "wireframes", ")", "{", "primitive", ".", "lineStyle", "(", "1", ",", "strokeStyleWireframeIndicator", ",", "1", ")", ";", "}", "else", "{", "primitive", ".", "lineStyle", "(", "1", ",", "strokeStyleIndicator", ")", ";", "}", "primitive", ".", "moveTo", "(", "part", ".", "position", ".", "x", "-", "body", ".", "position", ".", "x", ",", "part", ".", "position", ".", "y", "-", "body", ".", "position", ".", "y", ")", ";", "primitive", ".", "lineTo", "(", "(", "(", "part", ".", "vertices", "[", "0", "]", ".", "x", "+", "part", ".", "vertices", "[", "part", ".", "vertices", ".", "length", "-", "1", "]", ".", "x", ")", "/", "2", "-", "body", ".", "position", ".", "x", ")", ",", "(", "(", "part", ".", "vertices", "[", "0", "]", ".", "y", "+", "part", ".", "vertices", "[", "part", ".", "vertices", ".", "length", "-", "1", "]", ".", "y", ")", "/", "2", "-", "body", ".", "position", ".", "y", ")", ")", ";", "primitive", ".", "endFill", "(", ")", ";", "}", "}", "return", "primitive", ";", "}"], "docstring": "Creates a body primitive\n@method _createBodyPrimitive\n@private\n@param {RenderPixi} render\n@param {body} body\n@return {PIXI.Graphics} graphics\n@deprecated", "docstring_tokens": ["Creates", "a", "body", "primitive"], "sha": "2ec247b7af1c6b5da6ee05c73274ed5822c73503", "url": "https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/render/RenderPixi.js#L441-L495", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(buffer, attributeBindings) {\n    var attributeValue,\n        unspecifiedAttributeBindings = this._unspecifiedAttributeBindings = this._unspecifiedAttributeBindings || {};\n\n    a_forEach(attributeBindings, function(binding) {\n      var split = binding.split(':'),\n          property = split[0],\n          attributeName = split[1] || property;\n\n      if (property in this) {\n        this._setupAttributeBindingObservation(property, attributeName);\n\n        // Determine the current value and add it to the render buffer\n        // if necessary.\n        attributeValue = get(this, property);\n        Ember.View.applyAttributeBindings(buffer, attributeName, attributeValue);\n      } else {\n        unspecifiedAttributeBindings[property] = attributeName;\n      }\n    }, this);\n\n    // Lazily setup setUnknownProperty after attributeBindings are initially applied\n    this.setUnknownProperty = this._setUnknownProperty;\n  }", "language": "javascript", "code": "function(buffer, attributeBindings) {\n    var attributeValue,\n        unspecifiedAttributeBindings = this._unspecifiedAttributeBindings = this._unspecifiedAttributeBindings || {};\n\n    a_forEach(attributeBindings, function(binding) {\n      var split = binding.split(':'),\n          property = split[0],\n          attributeName = split[1] || property;\n\n      if (property in this) {\n        this._setupAttributeBindingObservation(property, attributeName);\n\n        // Determine the current value and add it to the render buffer\n        // if necessary.\n        attributeValue = get(this, property);\n        Ember.View.applyAttributeBindings(buffer, attributeName, attributeValue);\n      } else {\n        unspecifiedAttributeBindings[property] = attributeName;\n      }\n    }, this);\n\n    // Lazily setup setUnknownProperty after attributeBindings are initially applied\n    this.setUnknownProperty = this._setUnknownProperty;\n  }", "code_tokens": ["function", "(", "buffer", ",", "attributeBindings", ")", "{", "var", "attributeValue", ",", "unspecifiedAttributeBindings", "=", "this", ".", "_unspecifiedAttributeBindings", "=", "this", ".", "_unspecifiedAttributeBindings", "||", "{", "}", ";", "a_forEach", "(", "attributeBindings", ",", "function", "(", "binding", ")", "{", "var", "split", "=", "binding", ".", "split", "(", "':'", ")", ",", "property", "=", "split", "[", "0", "]", ",", "attributeName", "=", "split", "[", "1", "]", "||", "property", ";", "if", "(", "property", "in", "this", ")", "{", "this", ".", "_setupAttributeBindingObservation", "(", "property", ",", "attributeName", ")", ";", "// Determine the current value and add it to the render buffer", "// if necessary.", "attributeValue", "=", "get", "(", "this", ",", "property", ")", ";", "Ember", ".", "View", ".", "applyAttributeBindings", "(", "buffer", ",", "attributeName", ",", "attributeValue", ")", ";", "}", "else", "{", "unspecifiedAttributeBindings", "[", "property", "]", "=", "attributeName", ";", "}", "}", ",", "this", ")", ";", "// Lazily setup setUnknownProperty after attributeBindings are initially applied", "this", ".", "setUnknownProperty", "=", "this", ".", "_setUnknownProperty", ";", "}"], "docstring": "Iterates through the view's attribute bindings, sets up observers for each,\nthen applies the current value of the attributes to the passed render buffer.\n\n@method _applyAttributeBindings\n@param {Ember.RenderBuffer} buffer\n@private", "docstring_tokens": ["Iterates", "through", "the", "view", "s", "attribute", "bindings", "sets", "up", "observers", "for", "each", "then", "applies", "the", "current", "value", "of", "the", "attributes", "to", "the", "passed", "render", "buffer", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L23686-L23709", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(view, options) {\n      if (!this._ensureElement()) {\n        return;\n      }\n  \n      this._ensureViewIsIntact(view);\n      Marionette.MonitorDOMRefresh(view);\n  \n      var showOptions     = options || {};\n      var isDifferentView = view !== this.currentView;\n      var preventDestroy  = !!showOptions.preventDestroy;\n      var forceShow       = !!showOptions.forceShow;\n  \n      // We are only changing the view if there is a current view to change to begin with\n      var isChangingView = !!this.currentView;\n  \n      // Only destroy the current view if we don't want to `preventDestroy` and if\n      // the view given in the first argument is different than `currentView`\n      var _shouldDestroyView = isDifferentView && !preventDestroy;\n  \n      // Only show the view given in the first argument if it is different than\n      // the current view or if we want to re-show the view. Note that if\n      // `_shouldDestroyView` is true, then `_shouldShowView` is also necessarily true.\n      var _shouldShowView = isDifferentView || forceShow;\n  \n      if (isChangingView) {\n        this.triggerMethod('before:swapOut', this.currentView, this, options);\n      }\n  \n      if (this.currentView && isDifferentView) {\n        delete this.currentView._parent;\n      }\n  \n      if (_shouldDestroyView) {\n        this.empty();\n  \n      // A `destroy` event is attached to the clean up manually removed views.\n      // We need to detach this event when a new view is going to be shown as it\n      // is no longer relevant.\n      } else if (isChangingView && _shouldShowView) {\n        this.currentView.off('destroy', this.empty, this);\n      }\n  \n      if (_shouldShowView) {\n  \n        // We need to listen for if a view is destroyed\n        // in a way other than through the region.\n        // If this happens we need to remove the reference\n        // to the currentView since once a view has been destroyed\n        // we can not reuse it.\n        view.once('destroy', this.empty, this);\n  \n        // make this region the view's parent,\n        // It's important that this parent binding happens before rendering\n        // so that any events the child may trigger during render can also be\n        // triggered on the child's ancestor views\n        view._parent = this;\n        this._renderView(view);\n  \n        if (isChangingView) {\n          this.triggerMethod('before:swap', view, this, options);\n        }\n  \n        this.triggerMethod('before:show', view, this, options);\n        Marionette.triggerMethodOn(view, 'before:show', view, this, options);\n  \n        if (isChangingView) {\n          this.triggerMethod('swapOut', this.currentView, this, options);\n        }\n  \n        // An array of views that we're about to display\n        var attachedRegion = Marionette.isNodeAttached(this.el);\n  \n        // The views that we're about to attach to the document\n        // It's important that we prevent _getNestedViews from being executed unnecessarily\n        // as it's a potentially-slow method\n        var displayedViews = [];\n  \n        var attachOptions = _.extend({\n          triggerBeforeAttach: this.triggerBeforeAttach,\n          triggerAttach: this.triggerAttach\n        }, showOptions);\n  \n        if (attachedRegion && attachOptions.triggerBeforeAttach) {\n          displayedViews = this._displayedViews(view);\n          this._triggerAttach(displayedViews, 'before:');\n        }\n  \n        this.attachHtml(view);\n        this.currentView = view;\n  \n        if (attachedRegion && attachOptions.triggerAttach) {\n          displayedViews = this._displayedViews(view);\n          this._triggerAttach(displayedViews);\n        }\n  \n        if (isChangingView) {\n          this.triggerMethod('swap', view, this, options);\n        }\n  \n        this.triggerMethod('show', view, this, options);\n        Marionette.triggerMethodOn(view, 'show', view, this, options);\n  \n        return this;\n      }\n  \n      return this;\n    }", "language": "javascript", "code": "function(view, options) {\n      if (!this._ensureElement()) {\n        return;\n      }\n  \n      this._ensureViewIsIntact(view);\n      Marionette.MonitorDOMRefresh(view);\n  \n      var showOptions     = options || {};\n      var isDifferentView = view !== this.currentView;\n      var preventDestroy  = !!showOptions.preventDestroy;\n      var forceShow       = !!showOptions.forceShow;\n  \n      // We are only changing the view if there is a current view to change to begin with\n      var isChangingView = !!this.currentView;\n  \n      // Only destroy the current view if we don't want to `preventDestroy` and if\n      // the view given in the first argument is different than `currentView`\n      var _shouldDestroyView = isDifferentView && !preventDestroy;\n  \n      // Only show the view given in the first argument if it is different than\n      // the current view or if we want to re-show the view. Note that if\n      // `_shouldDestroyView` is true, then `_shouldShowView` is also necessarily true.\n      var _shouldShowView = isDifferentView || forceShow;\n  \n      if (isChangingView) {\n        this.triggerMethod('before:swapOut', this.currentView, this, options);\n      }\n  \n      if (this.currentView && isDifferentView) {\n        delete this.currentView._parent;\n      }\n  \n      if (_shouldDestroyView) {\n        this.empty();\n  \n      // A `destroy` event is attached to the clean up manually removed views.\n      // We need to detach this event when a new view is going to be shown as it\n      // is no longer relevant.\n      } else if (isChangingView && _shouldShowView) {\n        this.currentView.off('destroy', this.empty, this);\n      }\n  \n      if (_shouldShowView) {\n  \n        // We need to listen for if a view is destroyed\n        // in a way other than through the region.\n        // If this happens we need to remove the reference\n        // to the currentView since once a view has been destroyed\n        // we can not reuse it.\n        view.once('destroy', this.empty, this);\n  \n        // make this region the view's parent,\n        // It's important that this parent binding happens before rendering\n        // so that any events the child may trigger during render can also be\n        // triggered on the child's ancestor views\n        view._parent = this;\n        this._renderView(view);\n  \n        if (isChangingView) {\n          this.triggerMethod('before:swap', view, this, options);\n        }\n  \n        this.triggerMethod('before:show', view, this, options);\n        Marionette.triggerMethodOn(view, 'before:show', view, this, options);\n  \n        if (isChangingView) {\n          this.triggerMethod('swapOut', this.currentView, this, options);\n        }\n  \n        // An array of views that we're about to display\n        var attachedRegion = Marionette.isNodeAttached(this.el);\n  \n        // The views that we're about to attach to the document\n        // It's important that we prevent _getNestedViews from being executed unnecessarily\n        // as it's a potentially-slow method\n        var displayedViews = [];\n  \n        var attachOptions = _.extend({\n          triggerBeforeAttach: this.triggerBeforeAttach,\n          triggerAttach: this.triggerAttach\n        }, showOptions);\n  \n        if (attachedRegion && attachOptions.triggerBeforeAttach) {\n          displayedViews = this._displayedViews(view);\n          this._triggerAttach(displayedViews, 'before:');\n        }\n  \n        this.attachHtml(view);\n        this.currentView = view;\n  \n        if (attachedRegion && attachOptions.triggerAttach) {\n          displayedViews = this._displayedViews(view);\n          this._triggerAttach(displayedViews);\n        }\n  \n        if (isChangingView) {\n          this.triggerMethod('swap', view, this, options);\n        }\n  \n        this.triggerMethod('show', view, this, options);\n        Marionette.triggerMethodOn(view, 'show', view, this, options);\n  \n        return this;\n      }\n  \n      return this;\n    }", "code_tokens": ["function", "(", "view", ",", "options", ")", "{", "if", "(", "!", "this", ".", "_ensureElement", "(", ")", ")", "{", "return", ";", "}", "this", ".", "_ensureViewIsIntact", "(", "view", ")", ";", "Marionette", ".", "MonitorDOMRefresh", "(", "view", ")", ";", "var", "showOptions", "=", "options", "||", "{", "}", ";", "var", "isDifferentView", "=", "view", "!==", "this", ".", "currentView", ";", "var", "preventDestroy", "=", "!", "!", "showOptions", ".", "preventDestroy", ";", "var", "forceShow", "=", "!", "!", "showOptions", ".", "forceShow", ";", "// We are only changing the view if there is a current view to change to begin with", "var", "isChangingView", "=", "!", "!", "this", ".", "currentView", ";", "// Only destroy the current view if we don't want to `preventDestroy` and if", "// the view given in the first argument is different than `currentView`", "var", "_shouldDestroyView", "=", "isDifferentView", "&&", "!", "preventDestroy", ";", "// Only show the view given in the first argument if it is different than", "// the current view or if we want to re-show the view. Note that if", "// `_shouldDestroyView` is true, then `_shouldShowView` is also necessarily true.", "var", "_shouldShowView", "=", "isDifferentView", "||", "forceShow", ";", "if", "(", "isChangingView", ")", "{", "this", ".", "triggerMethod", "(", "'before:swapOut'", ",", "this", ".", "currentView", ",", "this", ",", "options", ")", ";", "}", "if", "(", "this", ".", "currentView", "&&", "isDifferentView", ")", "{", "delete", "this", ".", "currentView", ".", "_parent", ";", "}", "if", "(", "_shouldDestroyView", ")", "{", "this", ".", "empty", "(", ")", ";", "// A `destroy` event is attached to the clean up manually removed views.", "// We need to detach this event when a new view is going to be shown as it", "// is no longer relevant.", "}", "else", "if", "(", "isChangingView", "&&", "_shouldShowView", ")", "{", "this", ".", "currentView", ".", "off", "(", "'destroy'", ",", "this", ".", "empty", ",", "this", ")", ";", "}", "if", "(", "_shouldShowView", ")", "{", "// We need to listen for if a view is destroyed", "// in a way other than through the region.", "// If this happens we need to remove the reference", "// to the currentView since once a view has been destroyed", "// we can not reuse it.", "view", ".", "once", "(", "'destroy'", ",", "this", ".", "empty", ",", "this", ")", ";", "// make this region the view's parent,", "// It's important that this parent binding happens before rendering", "// so that any events the child may trigger during render can also be", "// triggered on the child's ancestor views", "view", ".", "_parent", "=", "this", ";", "this", ".", "_renderView", "(", "view", ")", ";", "if", "(", "isChangingView", ")", "{", "this", ".", "triggerMethod", "(", "'before:swap'", ",", "view", ",", "this", ",", "options", ")", ";", "}", "this", ".", "triggerMethod", "(", "'before:show'", ",", "view", ",", "this", ",", "options", ")", ";", "Marionette", ".", "triggerMethodOn", "(", "view", ",", "'before:show'", ",", "view", ",", "this", ",", "options", ")", ";", "if", "(", "isChangingView", ")", "{", "this", ".", "triggerMethod", "(", "'swapOut'", ",", "this", ".", "currentView", ",", "this", ",", "options", ")", ";", "}", "// An array of views that we're about to display", "var", "attachedRegion", "=", "Marionette", ".", "isNodeAttached", "(", "this", ".", "el", ")", ";", "// The views that we're about to attach to the document", "// It's important that we prevent _getNestedViews from being executed unnecessarily", "// as it's a potentially-slow method", "var", "displayedViews", "=", "[", "]", ";", "var", "attachOptions", "=", "_", ".", "extend", "(", "{", "triggerBeforeAttach", ":", "this", ".", "triggerBeforeAttach", ",", "triggerAttach", ":", "this", ".", "triggerAttach", "}", ",", "showOptions", ")", ";", "if", "(", "attachedRegion", "&&", "attachOptions", ".", "triggerBeforeAttach", ")", "{", "displayedViews", "=", "this", ".", "_displayedViews", "(", "view", ")", ";", "this", ".", "_triggerAttach", "(", "displayedViews", ",", "'before:'", ")", ";", "}", "this", ".", "attachHtml", "(", "view", ")", ";", "this", ".", "currentView", "=", "view", ";", "if", "(", "attachedRegion", "&&", "attachOptions", ".", "triggerAttach", ")", "{", "displayedViews", "=", "this", ".", "_displayedViews", "(", "view", ")", ";", "this", ".", "_triggerAttach", "(", "displayedViews", ")", ";", "}", "if", "(", "isChangingView", ")", "{", "this", ".", "triggerMethod", "(", "'swap'", ",", "view", ",", "this", ",", "options", ")", ";", "}", "this", ".", "triggerMethod", "(", "'show'", ",", "view", ",", "this", ",", "options", ")", ";", "Marionette", ".", "triggerMethodOn", "(", "view", ",", "'show'", ",", "view", ",", "this", ",", "options", ")", ";", "return", "this", ";", "}", "return", "this", ";", "}"], "docstring": "Displays a backbone view instance inside of the region. Handles calling the `render` method for you. Reads content directly from the `el` attribute. Also calls an optional `onShow` and `onDestroy` method on your view, just after showing or just before destroying the view, respectively. The `preventDestroy` option can be used to prevent a view from the old view being destroyed on show. The `forceShow` option can be used to force a view to be re-rendered if it's already shown in the region.", "docstring_tokens": ["Displays", "a", "backbone", "view", "instance", "inside", "of", "the", "region", ".", "Handles", "calling", "the", "render", "method", "for", "you", ".", "Reads", "content", "directly", "from", "the", "el", "attribute", ".", "Also", "calls", "an", "optional", "onShow", "and", "onDestroy", "method", "on", "your", "view", "just", "after", "showing", "or", "just", "before", "destroying", "the", "view", "respectively", ".", "The", "preventDestroy", "option", "can", "be", "used", "to", "prevent", "a", "view", "from", "the", "old", "view", "being", "destroyed", "on", "show", ".", "The", "forceShow", "option", "can", "be", "used", "to", "force", "a", "view", "to", "be", "re", "-", "rendered", "if", "it", "s", "already", "shown", "in", "the", "region", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L17179-L17286", "partition": "test"}
{"repo": "flightjs/jasmine-flight", "path": "lib/jasmine-flight.js", "func_name": "describeModuleFactory", "original_string": "function describeModuleFactory (modulePath, specDefinitions) {\n    return function () {\n      beforeEach(function (done) {\n        this.module = null;\n\n        var requireCallback = function (module) {\n          this.module = module;\n          done();\n        }.bind(this);\n\n        require([modulePath], requireCallback);\n      });\n\n      specDefinitions.apply(this);\n    };\n  }", "language": "javascript", "code": "function describeModuleFactory (modulePath, specDefinitions) {\n    return function () {\n      beforeEach(function (done) {\n        this.module = null;\n\n        var requireCallback = function (module) {\n          this.module = module;\n          done();\n        }.bind(this);\n\n        require([modulePath], requireCallback);\n      });\n\n      specDefinitions.apply(this);\n    };\n  }", "code_tokens": ["function", "describeModuleFactory", "(", "modulePath", ",", "specDefinitions", ")", "{", "return", "function", "(", ")", "{", "beforeEach", "(", "function", "(", "done", ")", "{", "this", ".", "module", "=", "null", ";", "var", "requireCallback", "=", "function", "(", "module", ")", "{", "this", ".", "module", "=", "module", ";", "done", "(", ")", ";", "}", ".", "bind", "(", "this", ")", ";", "require", "(", "[", "modulePath", "]", ",", "requireCallback", ")", ";", "}", ")", ";", "specDefinitions", ".", "apply", "(", "this", ")", ";", "}", ";", "}"], "docstring": "Load amd module before executing specDefinitions", "docstring_tokens": ["Load", "amd", "module", "before", "executing", "specDefinitions"], "sha": "8b82f490aaf239adc8369927bbf72e207efffdb1", "url": "https://github.com/flightjs/jasmine-flight/blob/8b82f490aaf239adc8369927bbf72e207efffdb1/lib/jasmine-flight.js#L192-L207", "partition": "test"}
{"repo": "bvellacott/sforce-mocks", "path": "mocks.js", "func_name": "", "original_string": "function(obj) {\n\t\tvar matches = this.sequence[0].matches(obj);\n\t\tfor(var i = 1; i < this.sequence.length; i += 2) {\n\t\t\tif(this.sequence[i] === '&')\n\t\t\t\tmatches = matches && this.sequence[i+1].matches(obj);\n\t\t\telse\n\t\t\t\tmatches = matches || this.sequence[i+1].matches(obj);\n\t\t}\n\t\treturn matches;\n\t}", "language": "javascript", "code": "function(obj) {\n\t\tvar matches = this.sequence[0].matches(obj);\n\t\tfor(var i = 1; i < this.sequence.length; i += 2) {\n\t\t\tif(this.sequence[i] === '&')\n\t\t\t\tmatches = matches && this.sequence[i+1].matches(obj);\n\t\t\telse\n\t\t\t\tmatches = matches || this.sequence[i+1].matches(obj);\n\t\t}\n\t\treturn matches;\n\t}", "code_tokens": ["function", "(", "obj", ")", "{", "var", "matches", "=", "this", ".", "sequence", "[", "0", "]", ".", "matches", "(", "obj", ")", ";", "for", "(", "var", "i", "=", "1", ";", "i", "<", "this", ".", "sequence", ".", "length", ";", "i", "+=", "2", ")", "{", "if", "(", "this", ".", "sequence", "[", "i", "]", "===", "'&'", ")", "matches", "=", "matches", "&&", "this", ".", "sequence", "[", "i", "+", "1", "]", ".", "matches", "(", "obj", ")", ";", "else", "matches", "=", "matches", "||", "this", ".", "sequence", "[", "i", "+", "1", "]", ".", "matches", "(", "obj", ")", ";", "}", "return", "matches", ";", "}"], "docstring": "Runs the conditions in the condition set and returns a boolean as a result", "docstring_tokens": ["Runs", "the", "conditions", "in", "the", "condition", "set", "and", "returns", "a", "boolean", "as", "a", "result"], "sha": "d49129d81cb41a820621a4cf38766f0e85db7f43", "url": "https://github.com/bvellacott/sforce-mocks/blob/d49129d81cb41a820621a4cf38766f0e85db7f43/mocks.js#L390-L399", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/utils.js", "func_name": "promiseWrapper", "original_string": "function promiseWrapper(options, originalCallback, handler) {\n  if (typeof originalCallback === 'function') {\n    // Callback-based invocation\n    handler.call(this, originalCallback);\n    return undefined;\n  }\n  const factory = options.promiseFactory || defaultPromiseFactory;\n  const self = this;\n  return factory(function handlerWrapper(callback) {\n    handler.call(self, callback);\n  });\n}", "language": "javascript", "code": "function promiseWrapper(options, originalCallback, handler) {\n  if (typeof originalCallback === 'function') {\n    // Callback-based invocation\n    handler.call(this, originalCallback);\n    return undefined;\n  }\n  const factory = options.promiseFactory || defaultPromiseFactory;\n  const self = this;\n  return factory(function handlerWrapper(callback) {\n    handler.call(self, callback);\n  });\n}", "code_tokens": ["function", "promiseWrapper", "(", "options", ",", "originalCallback", ",", "handler", ")", "{", "if", "(", "typeof", "originalCallback", "===", "'function'", ")", "{", "// Callback-based invocation", "handler", ".", "call", "(", "this", ",", "originalCallback", ")", ";", "return", "undefined", ";", "}", "const", "factory", "=", "options", ".", "promiseFactory", "||", "defaultPromiseFactory", ";", "const", "self", "=", "this", ";", "return", "factory", "(", "function", "handlerWrapper", "(", "callback", ")", "{", "handler", ".", "call", "(", "self", ",", "callback", ")", ";", "}", ")", ";", "}"], "docstring": "Wraps the callback-based method. When no originalCallback is not defined, it returns a Promise.\n@param {ClientOptions} options\n@param {Function} originalCallback\n@param {Function} handler\n@returns {Promise|undefined}", "docstring_tokens": ["Wraps", "the", "callback", "-", "based", "method", ".", "When", "no", "originalCallback", "is", "not", "defined", "it", "returns", "a", "Promise", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/utils.js#L413-L424", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      this._ensureViewIsIntact();\n  \n      if (this._firstRender) {\n        // if this is the first render, don't do anything to\n        // reset the regions\n        this._firstRender = false;\n      } else {\n        // If this is not the first render call, then we need to\n        // re-initialize the `el` for each region\n        this._reInitializeRegions();\n      }\n  \n      return Marionette.ItemView.prototype.render.apply(this, arguments);\n    }", "language": "javascript", "code": "function() {\n      this._ensureViewIsIntact();\n  \n      if (this._firstRender) {\n        // if this is the first render, don't do anything to\n        // reset the regions\n        this._firstRender = false;\n      } else {\n        // If this is not the first render call, then we need to\n        // re-initialize the `el` for each region\n        this._reInitializeRegions();\n      }\n  \n      return Marionette.ItemView.prototype.render.apply(this, arguments);\n    }", "code_tokens": ["function", "(", ")", "{", "this", ".", "_ensureViewIsIntact", "(", ")", ";", "if", "(", "this", ".", "_firstRender", ")", "{", "// if this is the first render, don't do anything to", "// reset the regions", "this", ".", "_firstRender", "=", "false", ";", "}", "else", "{", "// If this is not the first render call, then we need to", "// re-initialize the `el` for each region", "this", ".", "_reInitializeRegions", "(", ")", ";", "}", "return", "Marionette", ".", "ItemView", ".", "prototype", ".", "render", ".", "apply", "(", "this", ",", "arguments", ")", ";", "}"], "docstring": "LayoutView's render will use the existing region objects the first time it is called. Subsequent calls will destroy the views that the regions are showing and then reset the `el` for the regions to the newly rendered DOM elements.", "docstring_tokens": ["LayoutView", "s", "render", "will", "use", "the", "existing", "region", "objects", "the", "first", "time", "it", "is", "called", ".", "Subsequent", "calls", "will", "destroy", "the", "views", "that", "the", "regions", "are", "showing", "and", "then", "reset", "the", "el", "for", "the", "regions", "to", "the", "newly", "rendered", "DOM", "elements", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19173-L19187", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "clearCache", "original_string": "function clearCache ( fromMarionette ) {\n        templateCache = {};\n        if ( ! fromMarionette && Backbone.Marionette && Backbone.Marionette.TemplateCache ) Backbone.Marionette.TemplateCache.clear();\n    }", "language": "javascript", "code": "function clearCache ( fromMarionette ) {\n        templateCache = {};\n        if ( ! fromMarionette && Backbone.Marionette && Backbone.Marionette.TemplateCache ) Backbone.Marionette.TemplateCache.clear();\n    }", "code_tokens": ["function", "clearCache", "(", "fromMarionette", ")", "{", "templateCache", "=", "{", "}", ";", "if", "(", "!", "fromMarionette", "&&", "Backbone", ".", "Marionette", "&&", "Backbone", ".", "Marionette", ".", "TemplateCache", ")", "Backbone", ".", "Marionette", ".", "TemplateCache", ".", "clear", "(", ")", ";", "}"], "docstring": "Clears the cache as a whole.\n\nAlso clears the Marionette cache (if Marionette is available).\n\n@param {boolean} [fromMarionette=false]  internal flag to prevent circular calls to and from Marionette", "docstring_tokens": ["Clears", "the", "cache", "as", "a", "whole", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L15326-L15329", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(objects) {\n    Ember.beginPropertyChanges(this);\n    forEach(objects, function(obj) { this.removeObject(obj); }, this);\n    Ember.endPropertyChanges(this);\n    return this;\n  }", "language": "javascript", "code": "function(objects) {\n    Ember.beginPropertyChanges(this);\n    forEach(objects, function(obj) { this.removeObject(obj); }, this);\n    Ember.endPropertyChanges(this);\n    return this;\n  }", "code_tokens": ["function", "(", "objects", ")", "{", "Ember", ".", "beginPropertyChanges", "(", "this", ")", ";", "forEach", "(", "objects", ",", "function", "(", "obj", ")", "{", "this", ".", "removeObject", "(", "obj", ")", ";", "}", ",", "this", ")", ";", "Ember", ".", "endPropertyChanges", "(", "this", ")", ";", "return", "this", ";", "}"], "docstring": "Removes each object in the passed enumerable from the receiver.\n\n@method removeObjects\n@param {Ember.Enumerable} objects the objects to remove\n@return {Object} receiver", "docstring_tokens": ["Removes", "each", "object", "in", "the", "passed", "enumerable", "from", "the", "receiver", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L17731-L17736", "partition": "test"}
{"repo": "steve-jansen/json-proxy", "path": "lib/proxy.js", "func_name": "proxyRequest", "original_string": "function proxyRequest(req, res, rule) {\n  var router,\n      target,\n      path;\n\n  injectProxyHeaders(req, rule);\n\n  // rewrite the base path of the requested URL\n  path = req.url.replace(rule.regexp, rule.target.path);\n\n  if (useGateway) {\n    // for HTTP LAN proxies, rewrite the request URL from a relative URL to an absolute URL\n    // also add a header that can be inspected by the unit tests\n    req.url = url.parse(util.format('%s//%s:%s%s', rule.target.protocol, rule.target.host, rule.target.port, path)).href;\n    req.headers['X-Forwarded-Url'] = req.url;\n\n    // the proxy target is really the HTTP LAN proxy\n    target = config.gateway;\n    logger.info('proxy: %s %s --> %s:%s --> %s//%s:%s%s', req.method, req.url, config.gateway.host, config.gateway.port, rule.target.protocol, rule.target.host, rule.target.port, path);\n  } else {\n    target = rule.target;\n    logger.info('proxy: %s %s --> %s//%s:%s%s', req.method, req.url, rule.target.protocol, rule.target.host, rule.target.port, path);\n    req.url = path;\n  }\n\n  var errorCallback = function errorCallback(err, proxyRequest, proxyResponse) {\n    var status = 500;\n    if (proxyResponse !== undefined && proxyResponse !== null && proxyResponse.statusCode >= 400) {\n      status = proxyResponse.statusCode;\n    }\n\n    logger.error('proxy: error - %s %s - %s', proxyRequest.method, proxyRequest.url, err.message);\n    if( res.status && typeof res.status === 'function'  ){\n        res.status(status).json({ error: status, message: err.message });\n    }\n  };\n\n  // get a ProxyServer from the cache\n  router = createRouter(target);\n\n  // proxy the request\n  router.web(req, res, errorCallback);\n}", "language": "javascript", "code": "function proxyRequest(req, res, rule) {\n  var router,\n      target,\n      path;\n\n  injectProxyHeaders(req, rule);\n\n  // rewrite the base path of the requested URL\n  path = req.url.replace(rule.regexp, rule.target.path);\n\n  if (useGateway) {\n    // for HTTP LAN proxies, rewrite the request URL from a relative URL to an absolute URL\n    // also add a header that can be inspected by the unit tests\n    req.url = url.parse(util.format('%s//%s:%s%s', rule.target.protocol, rule.target.host, rule.target.port, path)).href;\n    req.headers['X-Forwarded-Url'] = req.url;\n\n    // the proxy target is really the HTTP LAN proxy\n    target = config.gateway;\n    logger.info('proxy: %s %s --> %s:%s --> %s//%s:%s%s', req.method, req.url, config.gateway.host, config.gateway.port, rule.target.protocol, rule.target.host, rule.target.port, path);\n  } else {\n    target = rule.target;\n    logger.info('proxy: %s %s --> %s//%s:%s%s', req.method, req.url, rule.target.protocol, rule.target.host, rule.target.port, path);\n    req.url = path;\n  }\n\n  var errorCallback = function errorCallback(err, proxyRequest, proxyResponse) {\n    var status = 500;\n    if (proxyResponse !== undefined && proxyResponse !== null && proxyResponse.statusCode >= 400) {\n      status = proxyResponse.statusCode;\n    }\n\n    logger.error('proxy: error - %s %s - %s', proxyRequest.method, proxyRequest.url, err.message);\n    if( res.status && typeof res.status === 'function'  ){\n        res.status(status).json({ error: status, message: err.message });\n    }\n  };\n\n  // get a ProxyServer from the cache\n  router = createRouter(target);\n\n  // proxy the request\n  router.web(req, res, errorCallback);\n}", "code_tokens": ["function", "proxyRequest", "(", "req", ",", "res", ",", "rule", ")", "{", "var", "router", ",", "target", ",", "path", ";", "injectProxyHeaders", "(", "req", ",", "rule", ")", ";", "// rewrite the base path of the requested URL", "path", "=", "req", ".", "url", ".", "replace", "(", "rule", ".", "regexp", ",", "rule", ".", "target", ".", "path", ")", ";", "if", "(", "useGateway", ")", "{", "// for HTTP LAN proxies, rewrite the request URL from a relative URL to an absolute URL", "// also add a header that can be inspected by the unit tests", "req", ".", "url", "=", "url", ".", "parse", "(", "util", ".", "format", "(", "'%s//%s:%s%s'", ",", "rule", ".", "target", ".", "protocol", ",", "rule", ".", "target", ".", "host", ",", "rule", ".", "target", ".", "port", ",", "path", ")", ")", ".", "href", ";", "req", ".", "headers", "[", "'X-Forwarded-Url'", "]", "=", "req", ".", "url", ";", "// the proxy target is really the HTTP LAN proxy", "target", "=", "config", ".", "gateway", ";", "logger", ".", "info", "(", "'proxy: %s %s --> %s:%s --> %s//%s:%s%s'", ",", "req", ".", "method", ",", "req", ".", "url", ",", "config", ".", "gateway", ".", "host", ",", "config", ".", "gateway", ".", "port", ",", "rule", ".", "target", ".", "protocol", ",", "rule", ".", "target", ".", "host", ",", "rule", ".", "target", ".", "port", ",", "path", ")", ";", "}", "else", "{", "target", "=", "rule", ".", "target", ";", "logger", ".", "info", "(", "'proxy: %s %s --> %s//%s:%s%s'", ",", "req", ".", "method", ",", "req", ".", "url", ",", "rule", ".", "target", ".", "protocol", ",", "rule", ".", "target", ".", "host", ",", "rule", ".", "target", ".", "port", ",", "path", ")", ";", "req", ".", "url", "=", "path", ";", "}", "var", "errorCallback", "=", "function", "errorCallback", "(", "err", ",", "proxyRequest", ",", "proxyResponse", ")", "{", "var", "status", "=", "500", ";", "if", "(", "proxyResponse", "!==", "undefined", "&&", "proxyResponse", "!==", "null", "&&", "proxyResponse", ".", "statusCode", ">=", "400", ")", "{", "status", "=", "proxyResponse", ".", "statusCode", ";", "}", "logger", ".", "error", "(", "'proxy: error - %s %s - %s'", ",", "proxyRequest", ".", "method", ",", "proxyRequest", ".", "url", ",", "err", ".", "message", ")", ";", "if", "(", "res", ".", "status", "&&", "typeof", "res", ".", "status", "===", "'function'", ")", "{", "res", ".", "status", "(", "status", ")", ".", "json", "(", "{", "error", ":", "status", ",", "message", ":", "err", ".", "message", "}", ")", ";", "}", "}", ";", "// get a ProxyServer from the cache", "router", "=", "createRouter", "(", "target", ")", ";", "// proxy the request", "router", ".", "web", "(", "req", ",", "res", ",", "errorCallback", ")", ";", "}"], "docstring": "injects any LAN proxy servers into the request", "docstring_tokens": ["injects", "any", "LAN", "proxy", "servers", "into", "the", "request"], "sha": "b996609b627690774367d8d887f2e8baf102f6bf", "url": "https://github.com/steve-jansen/json-proxy/blob/b996609b627690774367d8d887f2e8baf102f6bf/lib/proxy.js#L37-L79", "partition": "test"}
{"repo": "ftlabs/fruitmachine", "path": "examples/lib/delegate.js", "func_name": "Delegate", "original_string": "function Delegate(root) {\n\t\tvar\n\n\n\t\t\t/**\n\t\t\t * Keep a reference to the current instance\n\t\t\t *\n\t\t\t * @internal\n\t\t\t * @type Delegate\n\t\t\t */\n\t\t\tthat = this,\n\n\n\t\t\t/**\n\t\t\t * Maintain a list of listeners, indexed by event name\n\t\t\t *\n\t\t\t * @internal\n\t\t\t * @type Object\n\t\t\t */\n\t\t\tlistenerList = {};\n\n\t\tif (typeof root === 'string') {\n\t\t\troot = document.querySelector(root);\n\t\t}\n\n\t\tif (!root || !root.addEventListener) {\n\t\t\tthrow new TypeError('Root node not specified');\n\t\t}\n\n\n\t\t/**\n\t\t * Attach a handler to one event for all elements that match the selector, now or in the future\n\t\t *\n\t\t * The handler function receives three arguments: the DOM event object, the node that matched the selector while the event was bubbling\n\t\t * and a reference to itself. Within the handler, 'this' is equal to the second argument.\n\t\t * The node that actually received the event can be accessed via 'event.target'.\n\t\t *\n\t\t * @param {string} eventType Listen for these events (in a space-separated list)\n\t\t * @param {string} selector Only handle events on elements matching this selector\n\t\t * @param {Object} [eventData] If this parameter is not specified, the third parameter must be the handler\n\t\t * @param {function()} handler Handler function - event data passed here will be in event.data\n\t\t * @returns {Delegate} This method is chainable\n\t\t */\n\t\tthis.on = function() {\n\t\t\tArray.prototype.unshift.call(arguments, that, listenerList, root);\n\t\t\ton.apply(that, arguments);\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t * Remove an event handler for elements that match the selector, forever\n\t\t *\n\t\t * @param {string} eventType Remove handlers for events matching this type, considering the other parameters\n\t\t * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n\t\t * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n\t\t * @returns {Delegate} This method is chainable\n\t\t */\n\t\tthis.off = function() {\n\t\t\tArray.prototype.unshift.call(arguments, that, listenerList, root);\n\t\t\toff.apply(that, arguments);\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t * Handle an arbitrary event\n\t\t *\n\t\t * @private\n\t\t * @param {Event} event\n\t\t */\n\t\tthis.handle = function(event) {\n\t\t\thandle.call(that, listenerList, root, event);\n\t\t};\n\t}", "language": "javascript", "code": "function Delegate(root) {\n\t\tvar\n\n\n\t\t\t/**\n\t\t\t * Keep a reference to the current instance\n\t\t\t *\n\t\t\t * @internal\n\t\t\t * @type Delegate\n\t\t\t */\n\t\t\tthat = this,\n\n\n\t\t\t/**\n\t\t\t * Maintain a list of listeners, indexed by event name\n\t\t\t *\n\t\t\t * @internal\n\t\t\t * @type Object\n\t\t\t */\n\t\t\tlistenerList = {};\n\n\t\tif (typeof root === 'string') {\n\t\t\troot = document.querySelector(root);\n\t\t}\n\n\t\tif (!root || !root.addEventListener) {\n\t\t\tthrow new TypeError('Root node not specified');\n\t\t}\n\n\n\t\t/**\n\t\t * Attach a handler to one event for all elements that match the selector, now or in the future\n\t\t *\n\t\t * The handler function receives three arguments: the DOM event object, the node that matched the selector while the event was bubbling\n\t\t * and a reference to itself. Within the handler, 'this' is equal to the second argument.\n\t\t * The node that actually received the event can be accessed via 'event.target'.\n\t\t *\n\t\t * @param {string} eventType Listen for these events (in a space-separated list)\n\t\t * @param {string} selector Only handle events on elements matching this selector\n\t\t * @param {Object} [eventData] If this parameter is not specified, the third parameter must be the handler\n\t\t * @param {function()} handler Handler function - event data passed here will be in event.data\n\t\t * @returns {Delegate} This method is chainable\n\t\t */\n\t\tthis.on = function() {\n\t\t\tArray.prototype.unshift.call(arguments, that, listenerList, root);\n\t\t\ton.apply(that, arguments);\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t * Remove an event handler for elements that match the selector, forever\n\t\t *\n\t\t * @param {string} eventType Remove handlers for events matching this type, considering the other parameters\n\t\t * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n\t\t * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n\t\t * @returns {Delegate} This method is chainable\n\t\t */\n\t\tthis.off = function() {\n\t\t\tArray.prototype.unshift.call(arguments, that, listenerList, root);\n\t\t\toff.apply(that, arguments);\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t * Handle an arbitrary event\n\t\t *\n\t\t * @private\n\t\t * @param {Event} event\n\t\t */\n\t\tthis.handle = function(event) {\n\t\t\thandle.call(that, listenerList, root, event);\n\t\t};\n\t}", "code_tokens": ["function", "Delegate", "(", "root", ")", "{", "var", "/**\n\t\t\t * Keep a reference to the current instance\n\t\t\t *\n\t\t\t * @internal\n\t\t\t * @type Delegate\n\t\t\t */", "that", "=", "this", ",", "/**\n\t\t\t * Maintain a list of listeners, indexed by event name\n\t\t\t *\n\t\t\t * @internal\n\t\t\t * @type Object\n\t\t\t */", "listenerList", "=", "{", "}", ";", "if", "(", "typeof", "root", "===", "'string'", ")", "{", "root", "=", "document", ".", "querySelector", "(", "root", ")", ";", "}", "if", "(", "!", "root", "||", "!", "root", ".", "addEventListener", ")", "{", "throw", "new", "TypeError", "(", "'Root node not specified'", ")", ";", "}", "/**\n\t\t * Attach a handler to one event for all elements that match the selector, now or in the future\n\t\t *\n\t\t * The handler function receives three arguments: the DOM event object, the node that matched the selector while the event was bubbling\n\t\t * and a reference to itself. Within the handler, 'this' is equal to the second argument.\n\t\t * The node that actually received the event can be accessed via 'event.target'.\n\t\t *\n\t\t * @param {string} eventType Listen for these events (in a space-separated list)\n\t\t * @param {string} selector Only handle events on elements matching this selector\n\t\t * @param {Object} [eventData] If this parameter is not specified, the third parameter must be the handler\n\t\t * @param {function()} handler Handler function - event data passed here will be in event.data\n\t\t * @returns {Delegate} This method is chainable\n\t\t */", "this", ".", "on", "=", "function", "(", ")", "{", "Array", ".", "prototype", ".", "unshift", ".", "call", "(", "arguments", ",", "that", ",", "listenerList", ",", "root", ")", ";", "on", ".", "apply", "(", "that", ",", "arguments", ")", ";", "return", "this", ";", "}", ";", "/**\n\t\t * Remove an event handler for elements that match the selector, forever\n\t\t *\n\t\t * @param {string} eventType Remove handlers for events matching this type, considering the other parameters\n\t\t * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n\t\t * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n\t\t * @returns {Delegate} This method is chainable\n\t\t */", "this", ".", "off", "=", "function", "(", ")", "{", "Array", ".", "prototype", ".", "unshift", ".", "call", "(", "arguments", ",", "that", ",", "listenerList", ",", "root", ")", ";", "off", ".", "apply", "(", "that", ",", "arguments", ")", ";", "return", "this", ";", "}", ";", "/**\n\t\t * Handle an arbitrary event\n\t\t *\n\t\t * @private\n\t\t * @param {Event} event\n\t\t */", "this", ".", "handle", "=", "function", "(", "event", ")", "{", "handle", ".", "call", "(", "that", ",", "listenerList", ",", "root", ",", "event", ")", ";", "}", ";", "}"], "docstring": "DOM event delegator\n\nThe delegator will listen for events that bubble up to the root node.\n\n@constructor\n@param {Node|DOMWindow|string} root The root node, a window object or a selector string", "docstring_tokens": ["DOM", "event", "delegator"], "sha": "7ef6445c3a422e462074b4de5007c4662ae09347", "url": "https://github.com/ftlabs/fruitmachine/blob/7ef6445c3a422e462074b4de5007c4662ae09347/examples/lib/delegate.js#L479-L553", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "formatArgs", "original_string": "function formatArgs() {\n      var args = arguments;\n      var useColors = this.useColors;\n      var name = this.namespace;\n    \n      if (useColors) {\n        var c = this.color;\n    \n        args[0] = '  \\u001b[3' + c + ';1m' + name + ' '\n          + '\\u001b[0m'\n          + args[0] + '\\u001b[3' + c + 'm'\n          + ' +' + exports.humanize(this.diff) + '\\u001b[0m';\n      } else {\n        args[0] = new Date().toUTCString()\n          + ' ' + name + ' ' + args[0];\n      }\n      return args;\n    }", "language": "javascript", "code": "function formatArgs() {\n      var args = arguments;\n      var useColors = this.useColors;\n      var name = this.namespace;\n    \n      if (useColors) {\n        var c = this.color;\n    \n        args[0] = '  \\u001b[3' + c + ';1m' + name + ' '\n          + '\\u001b[0m'\n          + args[0] + '\\u001b[3' + c + 'm'\n          + ' +' + exports.humanize(this.diff) + '\\u001b[0m';\n      } else {\n        args[0] = new Date().toUTCString()\n          + ' ' + name + ' ' + args[0];\n      }\n      return args;\n    }", "code_tokens": ["function", "formatArgs", "(", ")", "{", "var", "args", "=", "arguments", ";", "var", "useColors", "=", "this", ".", "useColors", ";", "var", "name", "=", "this", ".", "namespace", ";", "if", "(", "useColors", ")", "{", "var", "c", "=", "this", ".", "color", ";", "args", "[", "0", "]", "=", "'  \\u001b[3'", "+", "c", "+", "';1m'", "+", "name", "+", "' '", "+", "'\\u001b[0m'", "+", "args", "[", "0", "]", "+", "'\\u001b[3'", "+", "c", "+", "'m'", "+", "' +'", "+", "exports", ".", "humanize", "(", "this", ".", "diff", ")", "+", "'\\u001b[0m'", ";", "}", "else", "{", "args", "[", "0", "]", "=", "new", "Date", "(", ")", ".", "toUTCString", "(", ")", "+", "' '", "+", "name", "+", "' '", "+", "args", "[", "0", "]", ";", "}", "return", "args", ";", "}"], "docstring": "Adds ANSI color escape codes if enabled.\n\n@api public", "docstring_tokens": ["Adds", "ANSI", "color", "escape", "codes", "if", "enabled", "."], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L51639-L51656", "partition": "test"}
{"repo": "integreat-io/integreat", "path": "lib/utils/nextSchedule.js", "func_name": "nextSchedule", "original_string": "function nextSchedule (schedule, allowNow = false) {\n  if (schedule) {\n    try {\n      const dates = later.schedule(schedule).next(2)\n      return nextDate(dates, allowNow)\n    } catch (error) {\n      throw TypeError('Invalid schedule definition')\n    }\n  }\n  return null\n}", "language": "javascript", "code": "function nextSchedule (schedule, allowNow = false) {\n  if (schedule) {\n    try {\n      const dates = later.schedule(schedule).next(2)\n      return nextDate(dates, allowNow)\n    } catch (error) {\n      throw TypeError('Invalid schedule definition')\n    }\n  }\n  return null\n}", "code_tokens": ["function", "nextSchedule", "(", "schedule", ",", "allowNow", "=", "false", ")", "{", "if", "(", "schedule", ")", "{", "try", "{", "const", "dates", "=", "later", ".", "schedule", "(", "schedule", ")", ".", "next", "(", "2", ")", "return", "nextDate", "(", "dates", ",", "allowNow", ")", "}", "catch", "(", "error", ")", "{", "throw", "TypeError", "(", "'Invalid schedule definition'", ")", "}", "}", "return", "null", "}"], "docstring": "Get next time for a schedule. Will never return the current time, even if it\nis valid for the schedule, unless `allowNow` is true.\n@param {Object} schedule - The schedule\n@param {boolean} allowNow - True to allow now as next Date\n@returns {Date} The next Date", "docstring_tokens": ["Get", "next", "time", "for", "a", "schedule", ".", "Will", "never", "return", "the", "current", "time", "even", "if", "it", "is", "valid", "for", "the", "schedule", "unless", "allowNow", "is", "true", "."], "sha": "b3092036bfd40d74a082297cace1f678502427c6", "url": "https://github.com/integreat-io/integreat/blob/b3092036bfd40d74a082297cace1f678502427c6/lib/utils/nextSchedule.js#L17-L27", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function() {\n    this._attributes = {};\n\n    if (get(this, 'isError')) {\n      this._inFlightAttributes = {};\n      set(this, 'isError', false);\n    }\n\n    if (!get(this, 'isValid')) {\n      this._inFlightAttributes = {};\n    }\n\n    this.send('rolledBack');\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  }", "language": "javascript", "code": "function() {\n    this._attributes = {};\n\n    if (get(this, 'isError')) {\n      this._inFlightAttributes = {};\n      set(this, 'isError', false);\n    }\n\n    if (!get(this, 'isValid')) {\n      this._inFlightAttributes = {};\n    }\n\n    this.send('rolledBack');\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  }", "code_tokens": ["function", "(", ")", "{", "this", ".", "_attributes", "=", "{", "}", ";", "if", "(", "get", "(", "this", ",", "'isError'", ")", ")", "{", "this", ".", "_inFlightAttributes", "=", "{", "}", ";", "set", "(", "this", ",", "'isError'", ",", "false", ")", ";", "}", "if", "(", "!", "get", "(", "this", ",", "'isValid'", ")", ")", "{", "this", ".", "_inFlightAttributes", "=", "{", "}", ";", "}", "this", ".", "send", "(", "'rolledBack'", ")", ";", "this", ".", "suspendRelationshipObservers", "(", "function", "(", ")", "{", "this", ".", "notifyPropertyChange", "(", "'data'", ")", ";", "}", ")", ";", "}"], "docstring": "If the model `isDirty` this function will which discard any unsaved\nchanges\n\nExample\n\n```javascript\nrecord.get('name'); // 'Untitled Document'\nrecord.set('name', 'Doc 1');\nrecord.get('name'); // 'Doc 1'\nrecord.rollback();\nrecord.get('name'); // 'Untitled Document'\n```\n\n@method rollback", "docstring_tokens": ["If", "the", "model", "isDirty", "this", "function", "will", "which", "discard", "any", "unsaved", "changes"], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L5295-L5312", "partition": "test"}
{"repo": "alanhoff/node-bolty", "path": "lib/bolty.js", "func_name": "", "original_string": "function(schema) {\n  this._decoders = decoders;\n  this._encoders = encoders;\n  this._schemas = {};\n\n  // Allow to pass the fields direclty\n  if(Object.keys(schema).join(',') !== 'name,fields'){\n    schema = {\n      name: '_auto-' + new Date().getTime(),\n      fields: schema\n    };\n  }\n\n  this._schema = schema;\n  this._fieldIndex = Object.keys(schema.fields);\n  this._schemas[schema.name] = schema;\n}", "language": "javascript", "code": "function(schema) {\n  this._decoders = decoders;\n  this._encoders = encoders;\n  this._schemas = {};\n\n  // Allow to pass the fields direclty\n  if(Object.keys(schema).join(',') !== 'name,fields'){\n    schema = {\n      name: '_auto-' + new Date().getTime(),\n      fields: schema\n    };\n  }\n\n  this._schema = schema;\n  this._fieldIndex = Object.keys(schema.fields);\n  this._schemas[schema.name] = schema;\n}", "code_tokens": ["function", "(", "schema", ")", "{", "this", ".", "_decoders", "=", "decoders", ";", "this", ".", "_encoders", "=", "encoders", ";", "this", ".", "_schemas", "=", "{", "}", ";", "// Allow to pass the fields direclty", "if", "(", "Object", ".", "keys", "(", "schema", ")", ".", "join", "(", "','", ")", "!==", "'name,fields'", ")", "{", "schema", "=", "{", "name", ":", "'_auto-'", "+", "new", "Date", "(", ")", ".", "getTime", "(", ")", ",", "fields", ":", "schema", "}", ";", "}", "this", ".", "_schema", "=", "schema", ";", "this", ".", "_fieldIndex", "=", "Object", ".", "keys", "(", "schema", ".", "fields", ")", ";", "this", ".", "_schemas", "[", "schema", ".", "name", "]", "=", "schema", ";", "}"], "docstring": "Bolty main class\n@class\n@param {object} schema The main schmma.\n@example\n```javascript\nvar Bolty = require('bolty');\nvar schema = {\nname: 'string',\nsurname: 'string'\n};\nvar template = new Bolty(schema);\n```", "docstring_tokens": ["Bolty", "main", "class"], "sha": "979d73b13db2a88996b8a76a51dcce03bf62d8b9", "url": "https://github.com/alanhoff/node-bolty/blob/979d73b13db2a88996b8a76a51dcce03bf62d8b9/lib/bolty.js#L19-L35", "partition": "test"}
{"repo": "Countly/countly-sdk-nodejs", "path": "lib/countly-bulk.js", "func_name": "getProperties", "original_string": "function getProperties(orig, props){\n        var ob = {};\n        var prop;\n        for(var i = 0; i < props.length; i++){\n            prop = props[i];\n            if(typeof orig[prop] !== \"undefined\"){\n                ob[prop] = orig[prop];\n            }\n        }\n        return ob;\n    }", "language": "javascript", "code": "function getProperties(orig, props){\n        var ob = {};\n        var prop;\n        for(var i = 0; i < props.length; i++){\n            prop = props[i];\n            if(typeof orig[prop] !== \"undefined\"){\n                ob[prop] = orig[prop];\n            }\n        }\n        return ob;\n    }", "code_tokens": ["function", "getProperties", "(", "orig", ",", "props", ")", "{", "var", "ob", "=", "{", "}", ";", "var", "prop", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "props", ".", "length", ";", "i", "++", ")", "{", "prop", "=", "props", "[", "i", "]", ";", "if", "(", "typeof", "orig", "[", "prop", "]", "!==", "\"undefined\"", ")", "{", "ob", "[", "prop", "]", "=", "orig", "[", "prop", "]", ";", "}", "}", "return", "ob", ";", "}"], "docstring": "retrieve only specific properties from object", "docstring_tokens": ["retrieve", "only", "specific", "properties", "from", "object"], "sha": "4cdce095fa0e479aad985cbfa2d58bc1163ae635", "url": "https://github.com/Countly/countly-sdk-nodejs/blob/4cdce095fa0e479aad985cbfa2d58bc1163ae635/lib/countly-bulk.js#L539-L549", "partition": "test"}
{"repo": "johnnycopperstone/led-me-know", "path": "lib/led-me-know.js", "func_name": "", "original_string": "function(strip) {\n\n        if (!strip) {\n            console.log(messagingTexts.noStrip);\n        }\n\n        if (!(strip instanceof pixel.Strip)) {\n            console.log(messagingTexts.wrongStrip);\n        }\n\n        pattern.reset(strip, interval);\n        setTimeout(function() {\n            pattern.flash(strip, 'green', 2);\n        }, 10);\n    }", "language": "javascript", "code": "function(strip) {\n\n        if (!strip) {\n            console.log(messagingTexts.noStrip);\n        }\n\n        if (!(strip instanceof pixel.Strip)) {\n            console.log(messagingTexts.wrongStrip);\n        }\n\n        pattern.reset(strip, interval);\n        setTimeout(function() {\n            pattern.flash(strip, 'green', 2);\n        }, 10);\n    }", "code_tokens": ["function", "(", "strip", ")", "{", "if", "(", "!", "strip", ")", "{", "console", ".", "log", "(", "messagingTexts", ".", "noStrip", ")", ";", "}", "if", "(", "!", "(", "strip", "instanceof", "pixel", ".", "Strip", ")", ")", "{", "console", ".", "log", "(", "messagingTexts", ".", "wrongStrip", ")", ";", "}", "pattern", ".", "reset", "(", "strip", ",", "interval", ")", ";", "setTimeout", "(", "function", "(", ")", "{", "pattern", ".", "flash", "(", "strip", ",", "'green'", ",", "2", ")", ";", "}", ",", "10", ")", ";", "}"], "docstring": "Flash the strip with green lights,\nindicating tests were successful.", "docstring_tokens": ["Flash", "the", "strip", "with", "green", "lights", "indicating", "tests", "were", "successful", "."], "sha": "ece9bfed5e4ed4de1ad3c31def1aea59c7a72023", "url": "https://github.com/johnnycopperstone/led-me-know/blob/ece9bfed5e4ed4de1ad3c31def1aea59c7a72023/lib/led-me-know.js#L56-L70", "partition": "test"}
{"repo": "italia/bootstrap-italia", "path": "src/js/plugins/transfer-back.js", "func_name": "targetControl", "original_string": "function targetControl(targetControl) {\n    var tocheck = targetControl.find('input')\n    var checknum = tocheck.length\n    var targetText = tocheck\n      .closest('.it-transfer-wrapper')\n      .find('.transfer-header')\n      .find('label span.num')\n    var header = $(targetControl).find('.transfer-header input')\n\n    if (checknum < 1) {\n      $(header).prop('disabled', true)\n    } else {\n      $(header).prop('disabled', false)\n    }\n\n    $(targetText).text(checknum)\n  }", "language": "javascript", "code": "function targetControl(targetControl) {\n    var tocheck = targetControl.find('input')\n    var checknum = tocheck.length\n    var targetText = tocheck\n      .closest('.it-transfer-wrapper')\n      .find('.transfer-header')\n      .find('label span.num')\n    var header = $(targetControl).find('.transfer-header input')\n\n    if (checknum < 1) {\n      $(header).prop('disabled', true)\n    } else {\n      $(header).prop('disabled', false)\n    }\n\n    $(targetText).text(checknum)\n  }", "code_tokens": ["function", "targetControl", "(", "targetControl", ")", "{", "var", "tocheck", "=", "targetControl", ".", "find", "(", "'input'", ")", "var", "checknum", "=", "tocheck", ".", "length", "var", "targetText", "=", "tocheck", ".", "closest", "(", "'.it-transfer-wrapper'", ")", ".", "find", "(", "'.transfer-header'", ")", ".", "find", "(", "'label span.num'", ")", "var", "header", "=", "$", "(", "targetControl", ")", ".", "find", "(", "'.transfer-header input'", ")", "if", "(", "checknum", "<", "1", ")", "{", "$", "(", "header", ")", ".", "prop", "(", "'disabled'", ",", "true", ")", "}", "else", "{", "$", "(", "header", ")", ".", "prop", "(", "'disabled'", ",", "false", ")", "}", "$", "(", "targetText", ")", ".", "text", "(", "checknum", ")", "}"], "docstring": "controllo elementi target", "docstring_tokens": ["controllo", "elementi", "target"], "sha": "9d2177a1c0c731f83636d2164bd22702ef5767c2", "url": "https://github.com/italia/bootstrap-italia/blob/9d2177a1c0c731f83636d2164bd22702ef5767c2/src/js/plugins/transfer-back.js#L166-L182", "partition": "test"}
{"repo": "appium/appium-xcuitest-driver", "path": "lib/commands/file-movement.js", "func_name": "parseContainerPath", "original_string": "async function parseContainerPath (remotePath, containerRootSupplier) {\n  const match = CONTAINER_PATH_PATTERN.exec(remotePath);\n  if (!match) {\n    log.errorAndThrow(`It is expected that package identifier ` +\n      `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` +\n      `relative path with a single slash. '${remotePath}' is given instead`);\n  }\n  let [, bundleId, relativePath] = match;\n  let containerType = null;\n  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);\n  // We only consider container type exists if its length is greater than zero\n  // not counting the colon\n  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {\n    containerType = bundleId.substring(typeSeparatorPos + 1);\n    log.debug(`Parsed container type: ${containerType}`);\n    bundleId = bundleId.substring(0, typeSeparatorPos);\n  }\n  const containerRoot = _.isFunction(containerRootSupplier)\n    ? await containerRootSupplier(bundleId, containerType)\n    : containerRootSupplier;\n  const resultPath = path.posix.resolve(containerRoot, relativePath);\n  verifyIsSubPath(resultPath, containerRoot);\n  return [bundleId, resultPath];\n}", "language": "javascript", "code": "async function parseContainerPath (remotePath, containerRootSupplier) {\n  const match = CONTAINER_PATH_PATTERN.exec(remotePath);\n  if (!match) {\n    log.errorAndThrow(`It is expected that package identifier ` +\n      `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` +\n      `relative path with a single slash. '${remotePath}' is given instead`);\n  }\n  let [, bundleId, relativePath] = match;\n  let containerType = null;\n  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);\n  // We only consider container type exists if its length is greater than zero\n  // not counting the colon\n  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {\n    containerType = bundleId.substring(typeSeparatorPos + 1);\n    log.debug(`Parsed container type: ${containerType}`);\n    bundleId = bundleId.substring(0, typeSeparatorPos);\n  }\n  const containerRoot = _.isFunction(containerRootSupplier)\n    ? await containerRootSupplier(bundleId, containerType)\n    : containerRootSupplier;\n  const resultPath = path.posix.resolve(containerRoot, relativePath);\n  verifyIsSubPath(resultPath, containerRoot);\n  return [bundleId, resultPath];\n}", "code_tokens": ["async", "function", "parseContainerPath", "(", "remotePath", ",", "containerRootSupplier", ")", "{", "const", "match", "=", "CONTAINER_PATH_PATTERN", ".", "exec", "(", "remotePath", ")", ";", "if", "(", "!", "match", ")", "{", "log", ".", "errorAndThrow", "(", "`", "`", "+", "`", "${", "CONTAINER_PATH_MARKER", "}", "`", "+", "`", "${", "remotePath", "}", "`", ")", ";", "}", "let", "[", ",", "bundleId", ",", "relativePath", "]", "=", "match", ";", "let", "containerType", "=", "null", ";", "const", "typeSeparatorPos", "=", "bundleId", ".", "indexOf", "(", "CONTAINER_TYPE_SEPARATOR", ")", ";", "// We only consider container type exists if its length is greater than zero", "// not counting the colon", "if", "(", "typeSeparatorPos", ">", "0", "&&", "typeSeparatorPos", "<", "bundleId", ".", "length", "-", "1", ")", "{", "containerType", "=", "bundleId", ".", "substring", "(", "typeSeparatorPos", "+", "1", ")", ";", "log", ".", "debug", "(", "`", "${", "containerType", "}", "`", ")", ";", "bundleId", "=", "bundleId", ".", "substring", "(", "0", ",", "typeSeparatorPos", ")", ";", "}", "const", "containerRoot", "=", "_", ".", "isFunction", "(", "containerRootSupplier", ")", "?", "await", "containerRootSupplier", "(", "bundleId", ",", "containerType", ")", ":", "containerRootSupplier", ";", "const", "resultPath", "=", "path", ".", "posix", ".", "resolve", "(", "containerRoot", ",", "relativePath", ")", ";", "verifyIsSubPath", "(", "resultPath", ",", "containerRoot", ")", ";", "return", "[", "bundleId", ",", "resultPath", "]", ";", "}"], "docstring": "Parses the actual path and the bundle identifier from the given path string\n\n@param {string} remotePath - The given path string. The string should\nmatch `CONTAINER_PATH_PATTERN` regexp, otherwise an error is going\nto be thrown. A valid string example: `@bundle.identifier:container_type/relative_path_in_container`\n@param {Function|string} containerRootSupplier - Either a string, that contains\nfull path to the mount root for real devices or a function, which accepts two parameters\n(bundle identifier and optional container type) and returns full path to container\nroot folder on the local file system, for Simulator\n@returns {Array<string>} - An array where the first item is the parsed bundle\nidentifier and the second one is the absolute full path of the item on the local\nfile system", "docstring_tokens": ["Parses", "the", "actual", "path", "and", "the", "bundle", "identifier", "from", "the", "given", "path", "string"], "sha": "eb8c1348c390314c7ad12294f8eb5c2e52326f57", "url": "https://github.com/appium/appium-xcuitest-driver/blob/eb8c1348c390314c7ad12294f8eb5c2e52326f57/lib/commands/file-movement.js#L59-L82", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/PluginHandler.js", "func_name": "getPluginFilePath", "original_string": "function getPluginFilePath(plugin, pluginFile, targetDir) {\n    var src = path.resolve(plugin.dir, pluginFile);\n    return '$(ProjectDir)' + path.relative(targetDir, src);\n}", "language": "javascript", "code": "function getPluginFilePath(plugin, pluginFile, targetDir) {\n    var src = path.resolve(plugin.dir, pluginFile);\n    return '$(ProjectDir)' + path.relative(targetDir, src);\n}", "code_tokens": ["function", "getPluginFilePath", "(", "plugin", ",", "pluginFile", ",", "targetDir", ")", "{", "var", "src", "=", "path", ".", "resolve", "(", "plugin", ".", "dir", ",", "pluginFile", ")", ";", "return", "'$(ProjectDir)'", "+", "path", ".", "relative", "(", "targetDir", ",", "src", ")", ";", "}"], "docstring": "returns relative file path for a file in the plugin's folder that can be referenced from a project file.", "docstring_tokens": ["returns", "relative", "file", "path", "for", "a", "file", "in", "the", "plugin", "s", "folder", "that", "can", "be", "referenced", "from", "a", "project", "file", "."], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/PluginHandler.js#L30-L33", "partition": "test"}
{"repo": "AndreasMadsen/article", "path": "tools/label/logic.js", "func_name": "", "original_string": "function (done) {\n        datamap[item.index].labeled = true;\n\n        fs.writeFile(\n          path.resolve(__dirname, '../../test/reallife/datamap.json'),\n          JSON.stringify(datamap, null, '\\t') + '\\n',\n          done\n        );\n      }", "language": "javascript", "code": "function (done) {\n        datamap[item.index].labeled = true;\n\n        fs.writeFile(\n          path.resolve(__dirname, '../../test/reallife/datamap.json'),\n          JSON.stringify(datamap, null, '\\t') + '\\n',\n          done\n        );\n      }", "code_tokens": ["function", "(", "done", ")", "{", "datamap", "[", "item", ".", "index", "]", ".", "labeled", "=", "true", ";", "fs", ".", "writeFile", "(", "path", ".", "resolve", "(", "__dirname", ",", "'../../test/reallife/datamap.json'", ")", ",", "JSON", ".", "stringify", "(", "datamap", ",", "null", ",", "'\\t'", ")", "+", "'\\n'", ",", "done", ")", ";", "}"], "docstring": "Save labeled flag", "docstring_tokens": ["Save", "labeled", "flag"], "sha": "8cf3777fc9dc72d041214faae1b8d65d37a7d134", "url": "https://github.com/AndreasMadsen/article/blob/8cf3777fc9dc72d041214faae1b8d65d37a7d134/tools/label/logic.js#L115-L123", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "micromatch", "original_string": "function micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}", "language": "javascript", "code": "function micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}", "code_tokens": ["function", "micromatch", "(", "list", ",", "patterns", ",", "options", ")", "{", "patterns", "=", "utils", ".", "arrayify", "(", "patterns", ")", ";", "list", "=", "utils", ".", "arrayify", "(", "list", ")", ";", "var", "len", "=", "patterns", ".", "length", ";", "if", "(", "list", ".", "length", "===", "0", "||", "len", "===", "0", ")", "{", "return", "[", "]", ";", "}", "if", "(", "len", "===", "1", ")", "{", "return", "micromatch", ".", "match", "(", "list", ",", "patterns", "[", "0", "]", ",", "options", ")", ";", "}", "var", "omit", "=", "[", "]", ";", "var", "keep", "=", "[", "]", ";", "var", "idx", "=", "-", "1", ";", "while", "(", "++", "idx", "<", "len", ")", "{", "var", "pattern", "=", "patterns", "[", "idx", "]", ";", "if", "(", "typeof", "pattern", "===", "'string'", "&&", "pattern", ".", "charCodeAt", "(", "0", ")", "===", "33", "/* ! */", ")", "{", "omit", ".", "push", ".", "apply", "(", "omit", ",", "micromatch", ".", "match", "(", "list", ",", "pattern", ".", "slice", "(", "1", ")", ",", "options", ")", ")", ";", "}", "else", "{", "keep", ".", "push", ".", "apply", "(", "keep", ",", "micromatch", ".", "match", "(", "list", ",", "pattern", ",", "options", ")", ")", ";", "}", "}", "var", "matches", "=", "utils", ".", "diff", "(", "keep", ",", "omit", ")", ";", "if", "(", "!", "options", "||", "options", ".", "nodupes", "!==", "false", ")", "{", "return", "utils", ".", "unique", "(", "matches", ")", ";", "}", "return", "matches", ";", "}"], "docstring": "The main function takes a list of strings and one or more\nglob patterns to use for matching.\n\n```js\nvar mm = require('micromatch');\nmm(list, patterns[, options]);\n\nconsole.log(mm(['a.js', 'a.txt'], ['*.js']));\n//=> [ 'a.js' ]\n```\n@param {Array} `list` A list of strings to match\n@param {String|Array} `patterns` One or more glob patterns to use for matching.\n@param {Object} `options` See available [options](#options) for changing how matches are performed\n@return {Array} Returns an array of matches\n@summary false\n@api public", "docstring_tokens": ["The", "main", "function", "takes", "a", "list", "of", "strings", "and", "one", "or", "more", "glob", "patterns", "to", "use", "for", "matching", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L12481-L12514", "partition": "test"}
{"repo": "GitbookIO/theme-default", "path": "src/js/theme/keyboard.js", "func_name": "init", "original_string": "function init() {\n    // Next\n    bindShortcut(['right'], function(e) {\n        navigation.goNext();\n    });\n\n    // Prev\n    bindShortcut(['left'], function(e) {\n        navigation.goPrev();\n    });\n\n    // Toggle Summary\n    bindShortcut(['s'], function(e) {\n        sidebar.toggle();\n    });\n}", "language": "javascript", "code": "function init() {\n    // Next\n    bindShortcut(['right'], function(e) {\n        navigation.goNext();\n    });\n\n    // Prev\n    bindShortcut(['left'], function(e) {\n        navigation.goPrev();\n    });\n\n    // Toggle Summary\n    bindShortcut(['s'], function(e) {\n        sidebar.toggle();\n    });\n}", "code_tokens": ["function", "init", "(", ")", "{", "// Next", "bindShortcut", "(", "[", "'right'", "]", ",", "function", "(", "e", ")", "{", "navigation", ".", "goNext", "(", ")", ";", "}", ")", ";", "// Prev", "bindShortcut", "(", "[", "'left'", "]", ",", "function", "(", "e", ")", "{", "navigation", ".", "goPrev", "(", ")", ";", "}", ")", ";", "// Toggle Summary", "bindShortcut", "(", "[", "'s'", "]", ",", "function", "(", "e", ")", "{", "sidebar", ".", "toggle", "(", ")", ";", "}", ")", ";", "}"], "docstring": "Bind keyboard shortcuts", "docstring_tokens": ["Bind", "keyboard", "shortcuts"], "sha": "a8e920453dc8e4eb522840b61606486622848099", "url": "https://github.com/GitbookIO/theme-default/blob/a8e920453dc8e4eb522840b61606486622848099/src/js/theme/keyboard.js#L16-L31", "partition": "test"}
{"repo": "jordifreek/Backbone-Special-K", "path": "src/specialk.js", "func_name": "", "original_string": "function(view) {\n            this.unmount();\n            this.currentView = view;\n\n            var renderReturnsView = this.currentView.render();\n            if (renderReturnsView) {\n                $(SpecialK.mainContainer).empty().append(renderReturnsView.el).fadeIn('slow');\n            }\n        }", "language": "javascript", "code": "function(view) {\n            this.unmount();\n            this.currentView = view;\n\n            var renderReturnsView = this.currentView.render();\n            if (renderReturnsView) {\n                $(SpecialK.mainContainer).empty().append(renderReturnsView.el).fadeIn('slow');\n            }\n        }", "code_tokens": ["function", "(", "view", ")", "{", "this", ".", "unmount", "(", ")", ";", "this", ".", "currentView", "=", "view", ";", "var", "renderReturnsView", "=", "this", ".", "currentView", ".", "render", "(", ")", ";", "if", "(", "renderReturnsView", ")", "{", "$", "(", "SpecialK", ".", "mainContainer", ")", ".", "empty", "(", ")", ".", "append", "(", "renderReturnsView", ".", "el", ")", ".", "fadeIn", "(", "'slow'", ")", ";", "}", "}"], "docstring": "Realiza un unmount y renderiza la nueva vista.\n\nPara poder renderizar una vista es necesario que devuelva \"this\"\nen el m\u00e9todo render.\n\n@param  {Object} view Nueva vista a renderizar", "docstring_tokens": ["Realiza", "un", "unmount", "y", "renderiza", "la", "nueva", "vista", "."], "sha": "c22fcc3c398d30379c6d4625072f642ed376639b", "url": "https://github.com/jordifreek/Backbone-Special-K/blob/c22fcc3c398d30379c6d4625072f642ed376639b/src/specialk.js#L25-L33", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Module.js", "func_name": "_stopOneByOne", "original_string": "function _stopOneByOne(oModule, sModuleId) {\n  iterateObject(oModule.instances, function (oItem, sInstanceId) {\n    stop(sModuleId, sInstanceId);\n  });\n}", "language": "javascript", "code": "function _stopOneByOne(oModule, sModuleId) {\n  iterateObject(oModule.instances, function (oItem, sInstanceId) {\n    stop(sModuleId, sInstanceId);\n  });\n}", "code_tokens": ["function", "_stopOneByOne", "(", "oModule", ",", "sModuleId", ")", "{", "iterateObject", "(", "oModule", ".", "instances", ",", "function", "(", "oItem", ",", "sInstanceId", ")", "{", "stop", "(", "sModuleId", ",", "sInstanceId", ")", ";", "}", ")", ";", "}"], "docstring": "Loops over instances of modules to stop them.\n@param {Object} oModule\n@param {String} sModuleId\n@private", "docstring_tokens": ["Loops", "over", "instances", "of", "modules", "to", "stop", "them", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Module.js#L540-L544", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/views/Item/ItemGroup.js", "func_name": "ItemGroup", "original_string": "function ItemGroup(props) {\n  const { children, className, content, divided, items, link, relaxed, unstackable } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(divided, 'divided'),\n    useKeyOnly(link, 'link'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\n    'items',\n    className,\n  )\n  const rest = getUnhandledProps(ItemGroup, props)\n  const ElementType = getElementType(ItemGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  const itemsJSX = _.map(items, (item) => {\n    const { childKey, ...itemProps } = item\n    const finalKey =\n      childKey ||\n      [itemProps.content, itemProps.description, itemProps.header, itemProps.meta].join('-')\n\n    return <Item {...itemProps} key={finalKey} />\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {itemsJSX}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function ItemGroup(props) {\n  const { children, className, content, divided, items, link, relaxed, unstackable } = props\n\n  const classes = cx(\n    'ui',\n    useKeyOnly(divided, 'divided'),\n    useKeyOnly(link, 'link'),\n    useKeyOnly(unstackable, 'unstackable'),\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\n    'items',\n    className,\n  )\n  const rest = getUnhandledProps(ItemGroup, props)\n  const ElementType = getElementType(ItemGroup, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n  if (!childrenUtils.isNil(content)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {content}\n      </ElementType>\n    )\n  }\n\n  const itemsJSX = _.map(items, (item) => {\n    const { childKey, ...itemProps } = item\n    const finalKey =\n      childKey ||\n      [itemProps.content, itemProps.description, itemProps.header, itemProps.meta].join('-')\n\n    return <Item {...itemProps} key={finalKey} />\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {itemsJSX}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "ItemGroup", "(", "props", ")", "{", "const", "{", "children", ",", "className", ",", "content", ",", "divided", ",", "items", ",", "link", ",", "relaxed", ",", "unstackable", "}", "=", "props", "const", "classes", "=", "cx", "(", "'ui'", ",", "useKeyOnly", "(", "divided", ",", "'divided'", ")", ",", "useKeyOnly", "(", "link", ",", "'link'", ")", ",", "useKeyOnly", "(", "unstackable", ",", "'unstackable'", ")", ",", "useKeyOrValueAndKey", "(", "relaxed", ",", "'relaxed'", ")", ",", "'items'", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "ItemGroup", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "ItemGroup", ",", "props", ")", "if", "(", "!", "childrenUtils", ".", "isNil", "(", "children", ")", ")", "{", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "children", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "if", "(", "!", "childrenUtils", ".", "isNil", "(", "content", ")", ")", "{", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "content", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "const", "itemsJSX", "=", "_", ".", "map", "(", "items", ",", "(", "item", ")", "=>", "{", "const", "{", "childKey", ",", "...", "itemProps", "}", "=", "item", "const", "finalKey", "=", "childKey", "||", "[", "itemProps", ".", "content", ",", "itemProps", ".", "description", ",", "itemProps", ".", "header", ",", "itemProps", ".", "meta", "]", ".", "join", "(", "'-'", ")", "return", "<", "Item", "{", "...", "itemProps", "}", "key", "=", "{", "finalKey", "}", "/", ">", "}", ")", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "itemsJSX", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A group of items.", "docstring_tokens": ["A", "group", "of", "items", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Item/ItemGroup.js#L19-L63", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/util/LineSegment.js", "func_name": "", "original_string": "function(lineSegment) {\n        var point1 = this.point1,\n            point2 = this.point2,\n            point3 = lineSegment.point1,\n            point4 = lineSegment.point2,\n            x1 = point1.x,\n            x2 = point2.x,\n            x3 = point3.x,\n            x4 = point4.x,\n            y1 = point1.y,\n            y2 = point2.y,\n            y3 = point3.y,\n            y4 = point4.y,\n            d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4),\n            xi, yi;\n\n        if (d == 0) {\n            return null;\n        }\n\n        xi = ((x3 - x4) * (x1 * y2 - y1 * x2) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;\n        yi = ((y3 - y4) * (x1 * y2 - y1 * x2) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;\n\n        if (xi < Math.min(x1, x2) || xi > Math.max(x1, x2)\n            || xi < Math.min(x3, x4) || xi > Math.max(x3, x4)\n            || yi < Math.min(y1, y2) || yi > Math.max(y1, y2)\n            || yi < Math.min(y3, y4) || yi > Math.max(y3, y4)) {\n            return null;\n        }\n\n        return new Ext.util.Point(xi, yi);\n    }", "language": "javascript", "code": "function(lineSegment) {\n        var point1 = this.point1,\n            point2 = this.point2,\n            point3 = lineSegment.point1,\n            point4 = lineSegment.point2,\n            x1 = point1.x,\n            x2 = point2.x,\n            x3 = point3.x,\n            x4 = point4.x,\n            y1 = point1.y,\n            y2 = point2.y,\n            y3 = point3.y,\n            y4 = point4.y,\n            d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4),\n            xi, yi;\n\n        if (d == 0) {\n            return null;\n        }\n\n        xi = ((x3 - x4) * (x1 * y2 - y1 * x2) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;\n        yi = ((y3 - y4) * (x1 * y2 - y1 * x2) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;\n\n        if (xi < Math.min(x1, x2) || xi > Math.max(x1, x2)\n            || xi < Math.min(x3, x4) || xi > Math.max(x3, x4)\n            || yi < Math.min(y1, y2) || yi > Math.max(y1, y2)\n            || yi < Math.min(y3, y4) || yi > Math.max(y3, y4)) {\n            return null;\n        }\n\n        return new Ext.util.Point(xi, yi);\n    }", "code_tokens": ["function", "(", "lineSegment", ")", "{", "var", "point1", "=", "this", ".", "point1", ",", "point2", "=", "this", ".", "point2", ",", "point3", "=", "lineSegment", ".", "point1", ",", "point4", "=", "lineSegment", ".", "point2", ",", "x1", "=", "point1", ".", "x", ",", "x2", "=", "point2", ".", "x", ",", "x3", "=", "point3", ".", "x", ",", "x4", "=", "point4", ".", "x", ",", "y1", "=", "point1", ".", "y", ",", "y2", "=", "point2", ".", "y", ",", "y3", "=", "point3", ".", "y", ",", "y4", "=", "point4", ".", "y", ",", "d", "=", "(", "x1", "-", "x2", ")", "*", "(", "y3", "-", "y4", ")", "-", "(", "y1", "-", "y2", ")", "*", "(", "x3", "-", "x4", ")", ",", "xi", ",", "yi", ";", "if", "(", "d", "==", "0", ")", "{", "return", "null", ";", "}", "xi", "=", "(", "(", "x3", "-", "x4", ")", "*", "(", "x1", "*", "y2", "-", "y1", "*", "x2", ")", "-", "(", "x1", "-", "x2", ")", "*", "(", "x3", "*", "y4", "-", "y3", "*", "x4", ")", ")", "/", "d", ";", "yi", "=", "(", "(", "y3", "-", "y4", ")", "*", "(", "x1", "*", "y2", "-", "y1", "*", "x2", ")", "-", "(", "y1", "-", "y2", ")", "*", "(", "x3", "*", "y4", "-", "y3", "*", "x4", ")", ")", "/", "d", ";", "if", "(", "xi", "<", "Math", ".", "min", "(", "x1", ",", "x2", ")", "||", "xi", ">", "Math", ".", "max", "(", "x1", ",", "x2", ")", "||", "xi", "<", "Math", ".", "min", "(", "x3", ",", "x4", ")", "||", "xi", ">", "Math", ".", "max", "(", "x3", ",", "x4", ")", "||", "yi", "<", "Math", ".", "min", "(", "y1", ",", "y2", ")", "||", "yi", ">", "Math", ".", "max", "(", "y1", ",", "y2", ")", "||", "yi", "<", "Math", ".", "min", "(", "y3", ",", "y4", ")", "||", "yi", ">", "Math", ".", "max", "(", "y3", ",", "y4", ")", ")", "{", "return", "null", ";", "}", "return", "new", "Ext", ".", "util", ".", "Point", "(", "xi", ",", "yi", ")", ";", "}"], "docstring": "Returns the point where two lines intersect.\n@param {Ext.util.LineSegment} lineSegment The line to intersect with.\n@return {Ext.util.Point}", "docstring_tokens": ["Returns", "the", "point", "where", "two", "lines", "intersect", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/util/LineSegment.js#L26-L57", "partition": "test"}
{"repo": "chrisbateman/impetus", "path": "dist/impetus.js", "func_name": "addRuntimeEvents", "original_string": "function addRuntimeEvents() {\n            cleanUpRuntimeEvents();\n\n            // @see https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            document.addEventListener('touchmove', onMove, getPassiveSupported() ? { passive: false } : false);\n            document.addEventListener('touchend', onUp);\n            document.addEventListener('touchcancel', stopTracking);\n            document.addEventListener('mousemove', onMove, getPassiveSupported() ? { passive: false } : false);\n            document.addEventListener('mouseup', onUp);\n        }", "language": "javascript", "code": "function addRuntimeEvents() {\n            cleanUpRuntimeEvents();\n\n            // @see https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            document.addEventListener('touchmove', onMove, getPassiveSupported() ? { passive: false } : false);\n            document.addEventListener('touchend', onUp);\n            document.addEventListener('touchcancel', stopTracking);\n            document.addEventListener('mousemove', onMove, getPassiveSupported() ? { passive: false } : false);\n            document.addEventListener('mouseup', onUp);\n        }", "code_tokens": ["function", "addRuntimeEvents", "(", ")", "{", "cleanUpRuntimeEvents", "(", ")", ";", "// @see https://developers.google.com/web/updates/2017/01/scrolling-intervention", "document", ".", "addEventListener", "(", "'touchmove'", ",", "onMove", ",", "getPassiveSupported", "(", ")", "?", "{", "passive", ":", "false", "}", ":", "false", ")", ";", "document", ".", "addEventListener", "(", "'touchend'", ",", "onUp", ")", ";", "document", ".", "addEventListener", "(", "'touchcancel'", ",", "stopTracking", ")", ";", "document", ".", "addEventListener", "(", "'mousemove'", ",", "onMove", ",", "getPassiveSupported", "(", ")", "?", "{", "passive", ":", "false", "}", ":", "false", ")", ";", "document", ".", "addEventListener", "(", "'mouseup'", ",", "onUp", ")", ";", "}"], "docstring": "Add all required runtime events", "docstring_tokens": ["Add", "all", "required", "runtime", "events"], "sha": "ef9fefec150655c06e2aec9e628422909fd5f4ce", "url": "https://github.com/chrisbateman/impetus/blob/ef9fefec150655c06e2aec9e628422909fd5f4ce/dist/impetus.js#L186-L195", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      var data = {};\n  \n      if (this.model) {\n        data = _.partial(this.serializeModel, this.model).apply(this, arguments);\n      }\n  \n      return data;\n    }", "language": "javascript", "code": "function() {\n      var data = {};\n  \n      if (this.model) {\n        data = _.partial(this.serializeModel, this.model).apply(this, arguments);\n      }\n  \n      return data;\n    }", "code_tokens": ["function", "(", ")", "{", "var", "data", "=", "{", "}", ";", "if", "(", "this", ".", "model", ")", "{", "data", "=", "_", ".", "partial", "(", "this", ".", "serializeModel", ",", "this", ".", "model", ")", ".", "apply", "(", "this", ",", "arguments", ")", ";", "}", "return", "data", ";", "}"], "docstring": "Serialize the model for the view. You can override the `serializeData` method in your own view definition, to provide custom serialization for your view's data.", "docstring_tokens": ["Serialize", "the", "model", "for", "the", "view", ".", "You", "can", "override", "the", "serializeData", "method", "in", "your", "own", "view", "definition", "to", "provide", "custom", "serialization", "for", "your", "view", "s", "data", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19003-L19011", "partition": "test"}
{"repo": "ralt/tartempion", "path": "lib/routes.js", "func_name": "addRoutes", "original_string": "function addRoutes( pies, pie, routes, app ) {\n    // Add the GET routes\n    if ( 'get' in routes ) {\n        routes.get.forEach( function( route ) {\n            Object.keys( route ).forEach( function( r ) {\n                var middlewares = true;\n                if ( typeof route[ r ] === 'string' ) {\n                    middlewares = false;\n                }\n                loadRoute( app, 'get', r, pies[ pie ].path, route[ r ], middlewares );\n            });\n        });\n    }\n\n    // Add the POST routes\n    if ( 'post' in routes ) {\n        routes.post.forEach( function( route ) {\n            Object.keys( route ).forEach( function( r ) {\n                var middlewares = true;\n                if ( typeof route[ r ] === 'string' ) {\n                    middlewares = false;\n                }\n                loadRoute( app, 'post', r, pies[ pie ].path, route[ r ], middlewares );\n            });\n        });\n    }\n}", "language": "javascript", "code": "function addRoutes( pies, pie, routes, app ) {\n    // Add the GET routes\n    if ( 'get' in routes ) {\n        routes.get.forEach( function( route ) {\n            Object.keys( route ).forEach( function( r ) {\n                var middlewares = true;\n                if ( typeof route[ r ] === 'string' ) {\n                    middlewares = false;\n                }\n                loadRoute( app, 'get', r, pies[ pie ].path, route[ r ], middlewares );\n            });\n        });\n    }\n\n    // Add the POST routes\n    if ( 'post' in routes ) {\n        routes.post.forEach( function( route ) {\n            Object.keys( route ).forEach( function( r ) {\n                var middlewares = true;\n                if ( typeof route[ r ] === 'string' ) {\n                    middlewares = false;\n                }\n                loadRoute( app, 'post', r, pies[ pie ].path, route[ r ], middlewares );\n            });\n        });\n    }\n}", "code_tokens": ["function", "addRoutes", "(", "pies", ",", "pie", ",", "routes", ",", "app", ")", "{", "// Add the GET routes", "if", "(", "'get'", "in", "routes", ")", "{", "routes", ".", "get", ".", "forEach", "(", "function", "(", "route", ")", "{", "Object", ".", "keys", "(", "route", ")", ".", "forEach", "(", "function", "(", "r", ")", "{", "var", "middlewares", "=", "true", ";", "if", "(", "typeof", "route", "[", "r", "]", "===", "'string'", ")", "{", "middlewares", "=", "false", ";", "}", "loadRoute", "(", "app", ",", "'get'", ",", "r", ",", "pies", "[", "pie", "]", ".", "path", ",", "route", "[", "r", "]", ",", "middlewares", ")", ";", "}", ")", ";", "}", ")", ";", "}", "// Add the POST routes", "if", "(", "'post'", "in", "routes", ")", "{", "routes", ".", "post", ".", "forEach", "(", "function", "(", "route", ")", "{", "Object", ".", "keys", "(", "route", ")", ".", "forEach", "(", "function", "(", "r", ")", "{", "var", "middlewares", "=", "true", ";", "if", "(", "typeof", "route", "[", "r", "]", "===", "'string'", ")", "{", "middlewares", "=", "false", ";", "}", "loadRoute", "(", "app", ",", "'post'", ",", "r", ",", "pies", "[", "pie", "]", ".", "path", ",", "route", "[", "r", "]", ",", "middlewares", ")", ";", "}", ")", ";", "}", ")", ";", "}", "}"], "docstring": "Add ALL the routes!", "docstring_tokens": ["Add", "ALL", "the", "routes!"], "sha": "0de497437261229575d40f49f20f9630bf6053e2", "url": "https://github.com/ralt/tartempion/blob/0de497437261229575d40f49f20f9630bf6053e2/lib/routes.js#L25-L51", "partition": "test"}
{"repo": "NathanGRomano/message-exchange", "path": "lib/channel.js", "func_name": "Channel", "original_string": "function Channel (id, exchange) {\n  var self = this;\n  events.EventEmitter.call(this);\n  this.id = id;\n  this.exchange = exchange;\n  this.exchange.on(this.id, function (message) {\n    self.emit('message', message);\n  });\n  this.setMaxListeners(0);\n}", "language": "javascript", "code": "function Channel (id, exchange) {\n  var self = this;\n  events.EventEmitter.call(this);\n  this.id = id;\n  this.exchange = exchange;\n  this.exchange.on(this.id, function (message) {\n    self.emit('message', message);\n  });\n  this.setMaxListeners(0);\n}", "code_tokens": ["function", "Channel", "(", "id", ",", "exchange", ")", "{", "var", "self", "=", "this", ";", "events", ".", "EventEmitter", ".", "call", "(", "this", ")", ";", "this", ".", "id", "=", "id", ";", "this", ".", "exchange", "=", "exchange", ";", "this", ".", "exchange", ".", "on", "(", "this", ".", "id", ",", "function", "(", "message", ")", "{", "self", ".", "emit", "(", "'message'", ",", "message", ")", ";", "}", ")", ";", "this", ".", "setMaxListeners", "(", "0", ")", ";", "}"], "docstring": "An Channel is where messages are sent to and receive\n\n@param {string} id\n@param {Exchange} exchange", "docstring_tokens": ["An", "Channel", "is", "where", "messages", "are", "sent", "to", "and", "receive"], "sha": "bc10f64fbda6a62bc02d53fd4dabb859643350e9", "url": "https://github.com/NathanGRomano/message-exchange/blob/bc10f64fbda6a62bc02d53fd4dabb859643350e9/lib/channel.js#L13-L22", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/core/utils/Basic.js", "func_name": "ctor", "original_string": "function ctor() {\n\t\t\tthis.constructor = child;\n\n\t\t\tif (MXI_DEBUG) {\n\t\t\t\tvar getCtorName = function(fn) {\n\t\t\t\t\tvar m = fn.toString().match(/^function\\s([^\\(\\s]+)/);\n\t\t\t\t\treturn m ? m[1] : false;\n\t\t\t\t};\n\n\t\t\t\tthis.ctorName = getCtorName(child);\n\t\t\t}\n\t\t}", "language": "javascript", "code": "function ctor() {\n\t\t\tthis.constructor = child;\n\n\t\t\tif (MXI_DEBUG) {\n\t\t\t\tvar getCtorName = function(fn) {\n\t\t\t\t\tvar m = fn.toString().match(/^function\\s([^\\(\\s]+)/);\n\t\t\t\t\treturn m ? m[1] : false;\n\t\t\t\t};\n\n\t\t\t\tthis.ctorName = getCtorName(child);\n\t\t\t}\n\t\t}", "code_tokens": ["function", "ctor", "(", ")", "{", "this", ".", "constructor", "=", "child", ";", "if", "(", "MXI_DEBUG", ")", "{", "var", "getCtorName", "=", "function", "(", "fn", ")", "{", "var", "m", "=", "fn", ".", "toString", "(", ")", ".", "match", "(", "/", "^function\\s([^\\(\\s]+)", "/", ")", ";", "return", "m", "?", "m", "[", "1", "]", ":", "false", ";", "}", ";", "this", ".", "ctorName", "=", "getCtorName", "(", "child", ")", ";", "}", "}"], "docstring": "give child `class` a place to define its own methods", "docstring_tokens": ["give", "child", "class", "a", "place", "to", "define", "its", "own", "methods"], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Basic.js#L155-L166", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      var elBuffer = document.createDocumentFragment();\n      _.each(this._bufferedChildren, function(b) {\n        elBuffer.appendChild(b.el);\n      });\n      return elBuffer;\n    }", "language": "javascript", "code": "function() {\n      var elBuffer = document.createDocumentFragment();\n      _.each(this._bufferedChildren, function(b) {\n        elBuffer.appendChild(b.el);\n      });\n      return elBuffer;\n    }", "code_tokens": ["function", "(", ")", "{", "var", "elBuffer", "=", "document", ".", "createDocumentFragment", "(", ")", ";", "_", ".", "each", "(", "this", ".", "_bufferedChildren", ",", "function", "(", "b", ")", "{", "elBuffer", ".", "appendChild", "(", "b", ".", "el", ")", ";", "}", ")", ";", "return", "elBuffer", ";", "}"], "docstring": "Create a fragment buffer from the currently buffered children", "docstring_tokens": ["Create", "a", "fragment", "buffer", "from", "the", "currently", "buffered", "children"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18814-L18820", "partition": "test"}
{"repo": "gulp-cookery/gulp-ccr-browserify", "path": "index.js", "func_name": "prewatch", "original_string": "function prewatch(theOptions) {\n\t\t\tif (config.watch) {\n\t\t\t\treturn _.defaults(theOptions, watchify.args);\n\t\t\t}\n\t\t\treturn theOptions;\n\t\t}", "language": "javascript", "code": "function prewatch(theOptions) {\n\t\t\tif (config.watch) {\n\t\t\t\treturn _.defaults(theOptions, watchify.args);\n\t\t\t}\n\t\t\treturn theOptions;\n\t\t}", "code_tokens": ["function", "prewatch", "(", "theOptions", ")", "{", "if", "(", "config", ".", "watch", ")", "{", "return", "_", ".", "defaults", "(", "theOptions", ",", "watchify", ".", "args", ")", ";", "}", "return", "theOptions", ";", "}"], "docstring": "Add watchify args", "docstring_tokens": ["Add", "watchify", "args"], "sha": "f03736aba15e5bdd70c3982dec32833044943435", "url": "https://github.com/gulp-cookery/gulp-ccr-browserify/blob/f03736aba15e5bdd70c3982dec32833044943435/index.js#L463-L468", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/errors.js", "func_name": "DriverError", "original_string": "function DriverError (message) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.info = 'Cassandra Driver Error';\n  // Explicitly set the message property as the Error.call() doesn't set the property on v8\n  this.message = message;\n}", "language": "javascript", "code": "function DriverError (message) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.info = 'Cassandra Driver Error';\n  // Explicitly set the message property as the Error.call() doesn't set the property on v8\n  this.message = message;\n}", "code_tokens": ["function", "DriverError", "(", "message", ")", "{", "Error", ".", "call", "(", "this", ",", "message", ")", ";", "Error", ".", "captureStackTrace", "(", "this", ",", "this", ".", "constructor", ")", ";", "this", ".", "name", "=", "this", ".", "constructor", ".", "name", ";", "this", ".", "info", "=", "'Cassandra Driver Error'", ";", "// Explicitly set the message property as the Error.call() doesn't set the property on v8", "this", ".", "message", "=", "message", ";", "}"], "docstring": "Contains the error classes exposed by the driver.\n@module errors\n \nBase Error\n@private", "docstring_tokens": ["Contains", "the", "error", "classes", "exposed", "by", "the", "driver", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/errors.js#L13-L20", "partition": "test"}
{"repo": "evanshortiss/env-var", "path": "lib/variable.js", "func_name": "", "original_string": "function (isRequired) {\n      if (isRequired === false) {\n        return accessors\n      }\n\n      if (typeof container[varName] === 'undefined' && typeof defValue === 'undefined') {\n        throw new EnvVarError(`\"${varName}\" is a required variable, but it was not set`)\n      }\n\n      return accessors\n    }", "language": "javascript", "code": "function (isRequired) {\n      if (isRequired === false) {\n        return accessors\n      }\n\n      if (typeof container[varName] === 'undefined' && typeof defValue === 'undefined') {\n        throw new EnvVarError(`\"${varName}\" is a required variable, but it was not set`)\n      }\n\n      return accessors\n    }", "code_tokens": ["function", "(", "isRequired", ")", "{", "if", "(", "isRequired", "===", "false", ")", "{", "return", "accessors", "}", "if", "(", "typeof", "container", "[", "varName", "]", "===", "'undefined'", "&&", "typeof", "defValue", "===", "'undefined'", ")", "{", "throw", "new", "EnvVarError", "(", "`", "${", "varName", "}", "`", ")", "}", "return", "accessors", "}"], "docstring": "Ensures a variable is set in the given environment container. Throws an\nEnvVarError if the variable is not set or a default is not provided\n@param {Boolean} isRequired", "docstring_tokens": ["Ensures", "a", "variable", "is", "set", "in", "the", "given", "environment", "container", ".", "Throws", "an", "EnvVarError", "if", "the", "variable", "is", "not", "set", "or", "a", "default", "is", "not", "provided"], "sha": "9b1e660fe0a0e9049a59ccee91fca58d718923e5", "url": "https://github.com/evanshortiss/env-var/blob/9b1e660fe0a0e9049a59ccee91fca58d718923e5/lib/variable.js#L101-L111", "partition": "test"}
{"repo": "StarryInternet/eslint-plugin-starry", "path": "lib/rules/space-in-parens.js", "func_name": "getExceptions", "original_string": "function getExceptions() {\n      const openers = [];\n      const closers = [];\n\n      if ( options.braceException ) {\n        openers.push('{');\n        closers.push('}');\n      }\n\n      if ( options.bracketException ) {\n        openers.push('[');\n        closers.push(']');\n      }\n\n      if ( options.parenException ) {\n        openers.push('(');\n        closers.push(')');\n      }\n\n      if ( options.empty ) {\n        openers.push(')');\n        closers.push('(');\n      }\n\n      return {\n        openers,\n        closers\n      };\n    }", "language": "javascript", "code": "function getExceptions() {\n      const openers = [];\n      const closers = [];\n\n      if ( options.braceException ) {\n        openers.push('{');\n        closers.push('}');\n      }\n\n      if ( options.bracketException ) {\n        openers.push('[');\n        closers.push(']');\n      }\n\n      if ( options.parenException ) {\n        openers.push('(');\n        closers.push(')');\n      }\n\n      if ( options.empty ) {\n        openers.push(')');\n        closers.push('(');\n      }\n\n      return {\n        openers,\n        closers\n      };\n    }", "code_tokens": ["function", "getExceptions", "(", ")", "{", "const", "openers", "=", "[", "]", ";", "const", "closers", "=", "[", "]", ";", "if", "(", "options", ".", "braceException", ")", "{", "openers", ".", "push", "(", "'{'", ")", ";", "closers", ".", "push", "(", "'}'", ")", ";", "}", "if", "(", "options", ".", "bracketException", ")", "{", "openers", ".", "push", "(", "'['", ")", ";", "closers", ".", "push", "(", "']'", ")", ";", "}", "if", "(", "options", ".", "parenException", ")", "{", "openers", ".", "push", "(", "'('", ")", ";", "closers", ".", "push", "(", "')'", ")", ";", "}", "if", "(", "options", ".", "empty", ")", "{", "openers", ".", "push", "(", "')'", ")", ";", "closers", ".", "push", "(", "'('", ")", ";", "}", "return", "{", "openers", ",", "closers", "}", ";", "}"], "docstring": "Produces an object with the opener and closer exception values\n@param {Object} opts The exception options\n@returns {Object} `openers` and `closers` exception values\n@private", "docstring_tokens": ["Produces", "an", "object", "with", "the", "opener", "and", "closer", "exception", "values"], "sha": "6b0a55c4d0263c549e88f80001b8cca417fca5ca", "url": "https://github.com/StarryInternet/eslint-plugin-starry/blob/6b0a55c4d0263c549e88f80001b8cca417fca5ca/lib/rules/space-in-parens.js#L70-L98", "partition": "test"}
{"repo": "AbbottPlatform/abbott-framework", "path": "lib/controllers/slack/botkit/slack_web_api.js", "func_name": "postForm", "original_string": "function postForm(url, formData, cb, multipart) {\n        cb = cb || noop;\n\n        bot.logger.info('** API CALL: ' + url);\n        var params = {\n            url: url,\n            headers: {\n                'User-Agent': bot.userAgent(),\n            }\n        };\n\n        if (multipart === true) {\n            params.formData = formData;\n        } else {\n            params.form = formData;\n        }\n\n        request.post(params, function(error, response, body) {\n            bot.logger.debug('Got response', error, body);\n\n            if (error) {\n                return cb(error);\n            }\n\n            if (response.statusCode == 200) {\n                var json;\n                try {\n                    json = JSON.parse(body);\n                } catch (parseError) {\n                    return cb(parseError);\n                }\n\n                return cb((json.ok ? null : json.error), json);\n            } else if (response.statusCode == 429) {\n                return cb(new Error('Rate limit exceeded'));\n            } else {\n                return cb(new Error('Invalid response'));\n            }\n        });\n    }", "language": "javascript", "code": "function postForm(url, formData, cb, multipart) {\n        cb = cb || noop;\n\n        bot.logger.info('** API CALL: ' + url);\n        var params = {\n            url: url,\n            headers: {\n                'User-Agent': bot.userAgent(),\n            }\n        };\n\n        if (multipart === true) {\n            params.formData = formData;\n        } else {\n            params.form = formData;\n        }\n\n        request.post(params, function(error, response, body) {\n            bot.logger.debug('Got response', error, body);\n\n            if (error) {\n                return cb(error);\n            }\n\n            if (response.statusCode == 200) {\n                var json;\n                try {\n                    json = JSON.parse(body);\n                } catch (parseError) {\n                    return cb(parseError);\n                }\n\n                return cb((json.ok ? null : json.error), json);\n            } else if (response.statusCode == 429) {\n                return cb(new Error('Rate limit exceeded'));\n            } else {\n                return cb(new Error('Invalid response'));\n            }\n        });\n    }", "code_tokens": ["function", "postForm", "(", "url", ",", "formData", ",", "cb", ",", "multipart", ")", "{", "cb", "=", "cb", "||", "noop", ";", "bot", ".", "logger", ".", "info", "(", "'** API CALL: '", "+", "url", ")", ";", "var", "params", "=", "{", "url", ":", "url", ",", "headers", ":", "{", "'User-Agent'", ":", "bot", ".", "userAgent", "(", ")", ",", "}", "}", ";", "if", "(", "multipart", "===", "true", ")", "{", "params", ".", "formData", "=", "formData", ";", "}", "else", "{", "params", ".", "form", "=", "formData", ";", "}", "request", ".", "post", "(", "params", ",", "function", "(", "error", ",", "response", ",", "body", ")", "{", "bot", ".", "logger", ".", "debug", "(", "'Got response'", ",", "error", ",", "body", ")", ";", "if", "(", "error", ")", "{", "return", "cb", "(", "error", ")", ";", "}", "if", "(", "response", ".", "statusCode", "==", "200", ")", "{", "var", "json", ";", "try", "{", "json", "=", "JSON", ".", "parse", "(", "body", ")", ";", "}", "catch", "(", "parseError", ")", "{", "return", "cb", "(", "parseError", ")", ";", "}", "return", "cb", "(", "(", "json", ".", "ok", "?", "null", ":", "json", ".", "error", ")", ",", "json", ")", ";", "}", "else", "if", "(", "response", ".", "statusCode", "==", "429", ")", "{", "return", "cb", "(", "new", "Error", "(", "'Rate limit exceeded'", ")", ")", ";", "}", "else", "{", "return", "cb", "(", "new", "Error", "(", "'Invalid response'", ")", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Makes a POST request as a form to the given url with the options as data\n\n@param {string} url The URL to POST to\n@param {Object} formData The data to POST as a form\n@param {function=} cb An optional NodeJS style callback when the POST completes or errors out.", "docstring_tokens": ["Makes", "a", "POST", "request", "as", "a", "form", "to", "the", "given", "url", "with", "the", "options", "as", "data"], "sha": "24ae64070c9dfe8407eb2ba0cead2cb277e38704", "url": "https://github.com/AbbottPlatform/abbott-framework/blob/24ae64070c9dfe8407eb2ba0cead2cb277e38704/lib/controllers/slack/botkit/slack_web_api.js#L244-L283", "partition": "test"}
{"repo": "trufflesuite/ganache-core", "path": "lib/utils/transaction.js", "func_name": "initData", "original_string": "function initData(tx, data) {\n  if (data) {\n    if (typeof data === \"string\") {\n      data = to.buffer(data);\n    }\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n    const self = tx;\n    if (Array.isArray(data)) {\n      if (data.length > tx._fields.length) {\n        throw new Error(\"wrong number of fields in data\");\n      }\n\n      // make sure all the items are buffers\n      data.forEach((d, i) => {\n        self[self._fields[i]] = ethUtil.toBuffer(d);\n      });\n    } else if ((typeof data === \"undefined\" ? \"undefined\" : typeof data) === \"object\") {\n      const keys = Object.keys(data);\n      tx._fields.forEach(function(field) {\n        if (keys.indexOf(field) !== -1) {\n          self[field] = data[field];\n        }\n        if (field === \"gasLimit\") {\n          if (keys.indexOf(\"gas\") !== -1) {\n            self[\"gas\"] = data[\"gas\"];\n          }\n        } else if (field === \"data\") {\n          if (keys.indexOf(\"input\") !== -1) {\n            self[\"input\"] = data[\"input\"];\n          }\n        }\n      });\n\n      // Set chainId value from the data, if it's there and the data didn't\n      // contain a `v` value with chainId in it already. If we do have a\n      // data.chainId value let's set the interval v value to it.\n      if (!tx._chainId && data && data.chainId != null) {\n        tx.raw[self._fields.indexOf(\"v\")] = tx._chainId = data.chainId || 0;\n      }\n    } else {\n      throw new Error(\"invalid data\");\n    }\n  }\n}", "language": "javascript", "code": "function initData(tx, data) {\n  if (data) {\n    if (typeof data === \"string\") {\n      data = to.buffer(data);\n    }\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n    const self = tx;\n    if (Array.isArray(data)) {\n      if (data.length > tx._fields.length) {\n        throw new Error(\"wrong number of fields in data\");\n      }\n\n      // make sure all the items are buffers\n      data.forEach((d, i) => {\n        self[self._fields[i]] = ethUtil.toBuffer(d);\n      });\n    } else if ((typeof data === \"undefined\" ? \"undefined\" : typeof data) === \"object\") {\n      const keys = Object.keys(data);\n      tx._fields.forEach(function(field) {\n        if (keys.indexOf(field) !== -1) {\n          self[field] = data[field];\n        }\n        if (field === \"gasLimit\") {\n          if (keys.indexOf(\"gas\") !== -1) {\n            self[\"gas\"] = data[\"gas\"];\n          }\n        } else if (field === \"data\") {\n          if (keys.indexOf(\"input\") !== -1) {\n            self[\"input\"] = data[\"input\"];\n          }\n        }\n      });\n\n      // Set chainId value from the data, if it's there and the data didn't\n      // contain a `v` value with chainId in it already. If we do have a\n      // data.chainId value let's set the interval v value to it.\n      if (!tx._chainId && data && data.chainId != null) {\n        tx.raw[self._fields.indexOf(\"v\")] = tx._chainId = data.chainId || 0;\n      }\n    } else {\n      throw new Error(\"invalid data\");\n    }\n  }\n}", "code_tokens": ["function", "initData", "(", "tx", ",", "data", ")", "{", "if", "(", "data", ")", "{", "if", "(", "typeof", "data", "===", "\"string\"", ")", "{", "data", "=", "to", ".", "buffer", "(", "data", ")", ";", "}", "if", "(", "Buffer", ".", "isBuffer", "(", "data", ")", ")", "{", "data", "=", "rlp", ".", "decode", "(", "data", ")", ";", "}", "const", "self", "=", "tx", ";", "if", "(", "Array", ".", "isArray", "(", "data", ")", ")", "{", "if", "(", "data", ".", "length", ">", "tx", ".", "_fields", ".", "length", ")", "{", "throw", "new", "Error", "(", "\"wrong number of fields in data\"", ")", ";", "}", "// make sure all the items are buffers", "data", ".", "forEach", "(", "(", "d", ",", "i", ")", "=>", "{", "self", "[", "self", ".", "_fields", "[", "i", "]", "]", "=", "ethUtil", ".", "toBuffer", "(", "d", ")", ";", "}", ")", ";", "}", "else", "if", "(", "(", "typeof", "data", "===", "\"undefined\"", "?", "\"undefined\"", ":", "typeof", "data", ")", "===", "\"object\"", ")", "{", "const", "keys", "=", "Object", ".", "keys", "(", "data", ")", ";", "tx", ".", "_fields", ".", "forEach", "(", "function", "(", "field", ")", "{", "if", "(", "keys", ".", "indexOf", "(", "field", ")", "!==", "-", "1", ")", "{", "self", "[", "field", "]", "=", "data", "[", "field", "]", ";", "}", "if", "(", "field", "===", "\"gasLimit\"", ")", "{", "if", "(", "keys", ".", "indexOf", "(", "\"gas\"", ")", "!==", "-", "1", ")", "{", "self", "[", "\"gas\"", "]", "=", "data", "[", "\"gas\"", "]", ";", "}", "}", "else", "if", "(", "field", "===", "\"data\"", ")", "{", "if", "(", "keys", ".", "indexOf", "(", "\"input\"", ")", "!==", "-", "1", ")", "{", "self", "[", "\"input\"", "]", "=", "data", "[", "\"input\"", "]", ";", "}", "}", "}", ")", ";", "// Set chainId value from the data, if it's there and the data didn't", "// contain a `v` value with chainId in it already. If we do have a", "// data.chainId value let's set the interval v value to it.", "if", "(", "!", "tx", ".", "_chainId", "&&", "data", "&&", "data", ".", "chainId", "!=", "null", ")", "{", "tx", ".", "raw", "[", "self", ".", "_fields", ".", "indexOf", "(", "\"v\"", ")", "]", "=", "tx", ".", "_chainId", "=", "data", ".", "chainId", "||", "0", ";", "}", "}", "else", "{", "throw", "new", "Error", "(", "\"invalid data\"", ")", ";", "}", "}", "}"], "docstring": "Parses the given data object and adds its properties to the given tx.\n@param {Transaction} tx\n@param {Object} [data]", "docstring_tokens": ["Parses", "the", "given", "data", "object", "and", "adds", "its", "properties", "to", "the", "given", "tx", "."], "sha": "cba166610008262266a60908d7ab4eb20fd856be", "url": "https://github.com/trufflesuite/ganache-core/blob/cba166610008262266a60908d7ab4eb20fd856be/lib/utils/transaction.js#L108-L153", "partition": "test"}
{"repo": "retextjs/retext-indefinite-article", "path": "lib/index.js", "func_name": "classify", "original_string": "function classify(value) {\n  var type = null\n  var normal\n\n  value = value.replace(digits, toWords).split(split, 1)[0]\n  normal = lower(value)\n\n  if (requiresA(value)) {\n    type = 'a'\n  }\n\n  if (requiresAn(value)) {\n    type = type === 'a' ? 'a-or-an' : 'an'\n  }\n\n  if (!type && normal === value) {\n    type = vowel.test(normal.charAt(0)) ? 'an' : 'a'\n  }\n\n  return type\n}", "language": "javascript", "code": "function classify(value) {\n  var type = null\n  var normal\n\n  value = value.replace(digits, toWords).split(split, 1)[0]\n  normal = lower(value)\n\n  if (requiresA(value)) {\n    type = 'a'\n  }\n\n  if (requiresAn(value)) {\n    type = type === 'a' ? 'a-or-an' : 'an'\n  }\n\n  if (!type && normal === value) {\n    type = vowel.test(normal.charAt(0)) ? 'an' : 'a'\n  }\n\n  return type\n}", "code_tokens": ["function", "classify", "(", "value", ")", "{", "var", "type", "=", "null", "var", "normal", "value", "=", "value", ".", "replace", "(", "digits", ",", "toWords", ")", ".", "split", "(", "split", ",", "1", ")", "[", "0", "]", "normal", "=", "lower", "(", "value", ")", "if", "(", "requiresA", "(", "value", ")", ")", "{", "type", "=", "'a'", "}", "if", "(", "requiresAn", "(", "value", ")", ")", "{", "type", "=", "type", "===", "'a'", "?", "'a-or-an'", ":", "'an'", "}", "if", "(", "!", "type", "&&", "normal", "===", "value", ")", "{", "type", "=", "vowel", ".", "test", "(", "normal", ".", "charAt", "(", "0", ")", ")", "?", "'an'", ":", "'a'", "}", "return", "type", "}"], "docstring": "Classify a word.", "docstring_tokens": ["Classify", "a", "word", "."], "sha": "abe3642840f416c2f921b6947d9ceb277c271a43", "url": "https://github.com/retextjs/retext-indefinite-article/blob/abe3642840f416c2f921b6947d9ceb277c271a43/lib/index.js#L117-L137", "partition": "test"}
{"repo": "scrollback/ebus", "path": "ebus.js", "func_name": "Ebus", "original_string": "function Ebus(p) {\n\t\"use strict\";\n\t\n\tthis.debug = false;\n\tthis.yields = false;\n\tthis.handlers = {};\n\n\tif (p) {\n\t\tthis.priorities = p;\n\t} else {\n\t\tthis.priorities = {};\n\t}\n}", "language": "javascript", "code": "function Ebus(p) {\n\t\"use strict\";\n\t\n\tthis.debug = false;\n\tthis.yields = false;\n\tthis.handlers = {};\n\n\tif (p) {\n\t\tthis.priorities = p;\n\t} else {\n\t\tthis.priorities = {};\n\t}\n}", "code_tokens": ["function", "Ebus", "(", "p", ")", "{", "\"use strict\"", ";", "this", ".", "debug", "=", "false", ";", "this", ".", "yields", "=", "false", ";", "this", ".", "handlers", "=", "{", "}", ";", "if", "(", "p", ")", "{", "this", ".", "priorities", "=", "p", ";", "}", "else", "{", "this", ".", "priorities", "=", "{", "}", ";", "}", "}"], "docstring": "polyfills the global setImmediate", "docstring_tokens": ["polyfills", "the", "global", "setImmediate"], "sha": "834231071e430ebbad057a9a40aad4cff6dcd42d", "url": "https://github.com/scrollback/ebus/blob/834231071e430ebbad057a9a40aad4cff6dcd42d/ebus.js#L35-L47", "partition": "test"}
{"repo": "azproduction/lmd", "path": "lib/coverage_apply.js", "func_name": "countIf", "original_string": "function countIf() {\n\t\tvar self = this, ret;\n\t\tif (self[0].start && analyzing.indexOf(self) < 0) {\n\t\t\tvar decision = self[1];\n\t\t\tvar lineId = self[0].name + ':' + (self[0].start.line + lineOffset);\n\n\t\t\tself[1] = wrapCondition(decision, lineId);\n\n\t\t\t// We are adding new lines, make sure code blocks are actual blocks\n\t\t\tif (self[2] && self[2][0].start && self[2][0].start.value != \"{\") {\n\t\t\t\tself[2] = [ \"block\", [self[2]]];\n\t\t\t}\n\n\t\t\tif (self[3] && self[3][0].start && self[3][0].start.value != \"{\") {\n\t\t\t\tself[3] = [ \"block\", [self[3]]];\n\t\t\t}\n\t\t}\n\n\t\tret = countLine.call(self);\n\n\t\tif (decision) {\n\t\t\tanalyzing.pop(decision);\n\t\t}\n\n\t\treturn ret;\n\t}", "language": "javascript", "code": "function countIf() {\n\t\tvar self = this, ret;\n\t\tif (self[0].start && analyzing.indexOf(self) < 0) {\n\t\t\tvar decision = self[1];\n\t\t\tvar lineId = self[0].name + ':' + (self[0].start.line + lineOffset);\n\n\t\t\tself[1] = wrapCondition(decision, lineId);\n\n\t\t\t// We are adding new lines, make sure code blocks are actual blocks\n\t\t\tif (self[2] && self[2][0].start && self[2][0].start.value != \"{\") {\n\t\t\t\tself[2] = [ \"block\", [self[2]]];\n\t\t\t}\n\n\t\t\tif (self[3] && self[3][0].start && self[3][0].start.value != \"{\") {\n\t\t\t\tself[3] = [ \"block\", [self[3]]];\n\t\t\t}\n\t\t}\n\n\t\tret = countLine.call(self);\n\n\t\tif (decision) {\n\t\t\tanalyzing.pop(decision);\n\t\t}\n\n\t\treturn ret;\n\t}", "code_tokens": ["function", "countIf", "(", ")", "{", "var", "self", "=", "this", ",", "ret", ";", "if", "(", "self", "[", "0", "]", ".", "start", "&&", "analyzing", ".", "indexOf", "(", "self", ")", "<", "0", ")", "{", "var", "decision", "=", "self", "[", "1", "]", ";", "var", "lineId", "=", "self", "[", "0", "]", ".", "name", "+", "':'", "+", "(", "self", "[", "0", "]", ".", "start", ".", "line", "+", "lineOffset", ")", ";", "self", "[", "1", "]", "=", "wrapCondition", "(", "decision", ",", "lineId", ")", ";", "// We are adding new lines, make sure code blocks are actual blocks", "if", "(", "self", "[", "2", "]", "&&", "self", "[", "2", "]", "[", "0", "]", ".", "start", "&&", "self", "[", "2", "]", "[", "0", "]", ".", "start", ".", "value", "!=", "\"{\"", ")", "{", "self", "[", "2", "]", "=", "[", "\"block\"", ",", "[", "self", "[", "2", "]", "]", "]", ";", "}", "if", "(", "self", "[", "3", "]", "&&", "self", "[", "3", "]", "[", "0", "]", ".", "start", "&&", "self", "[", "3", "]", "[", "0", "]", ".", "start", ".", "value", "!=", "\"{\"", ")", "{", "self", "[", "3", "]", "=", "[", "\"block\"", ",", "[", "self", "[", "3", "]", "]", "]", ";", "}", "}", "ret", "=", "countLine", ".", "call", "(", "self", ")", ";", "if", "(", "decision", ")", "{", "analyzing", ".", "pop", "(", "decision", ")", ";", "}", "return", "ret", ";", "}"], "docstring": "Walker for 'if' nodes. It overrides countLine because we want to instrument conditions.\n\n'this' is an if node, so\n'this[0]' is the node descriptor\n'this[1]' is the decision block\n'this[2]' is the 'then' code block\n'this[3]' is the 'else' code block\n\nNote that if/else if/else in AST are represented as nested if/else", "docstring_tokens": ["Walker", "for", "if", "nodes", ".", "It", "overrides", "countLine", "because", "we", "want", "to", "instrument", "conditions", "."], "sha": "03410c36839728de683c697670e1b205dc8193ee", "url": "https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/lib/coverage_apply.js#L136-L161", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(array, type, filter) {\n    var typeMap = this.store.typeMapFor(type),\n        records = typeMap.records, record;\n\n    for (var i=0, l=records.length; i<l; i++) {\n      record = records[i];\n\n      if (!get(record, 'isDeleted') && !get(record, 'isEmpty')) {\n        this.updateRecordArray(array, filter, type, record);\n      }\n    }\n  }", "language": "javascript", "code": "function(array, type, filter) {\n    var typeMap = this.store.typeMapFor(type),\n        records = typeMap.records, record;\n\n    for (var i=0, l=records.length; i<l; i++) {\n      record = records[i];\n\n      if (!get(record, 'isDeleted') && !get(record, 'isEmpty')) {\n        this.updateRecordArray(array, filter, type, record);\n      }\n    }\n  }", "code_tokens": ["function", "(", "array", ",", "type", ",", "filter", ")", "{", "var", "typeMap", "=", "this", ".", "store", ".", "typeMapFor", "(", "type", ")", ",", "records", "=", "typeMap", ".", "records", ",", "record", ";", "for", "(", "var", "i", "=", "0", ",", "l", "=", "records", ".", "length", ";", "i", "<", "l", ";", "i", "++", ")", "{", "record", "=", "records", "[", "i", "]", ";", "if", "(", "!", "get", "(", "record", ",", "'isDeleted'", ")", "&&", "!", "get", "(", "record", ",", "'isEmpty'", ")", ")", "{", "this", ".", "updateRecordArray", "(", "array", ",", "filter", ",", "type", ",", "record", ")", ";", "}", "}", "}"], "docstring": "This method is invoked if the `filterFunction` property is\nchanged on a `DS.FilteredRecordArray`.\n\nIt essentially re-runs the filter from scratch. This same\nmethod is invoked when the filter is created in th first place.\n\n@method updateFilter\n@param array\n@param type\n@param filter", "docstring_tokens": ["This", "method", "is", "invoked", "if", "the", "filterFunction", "property", "is", "changed", "on", "a", "DS", ".", "FilteredRecordArray", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L7299-L7310", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/field/DatePicker.js", "func_name": "", "original_string": "function(picker, value) {\n        var me = this,\n            oldValue = me.getValue();\n\n        me.setValue(value);\n        me.fireEvent('select', me, value);\n        me.onChange(me, value, oldValue);\n    }", "language": "javascript", "code": "function(picker, value) {\n        var me = this,\n            oldValue = me.getValue();\n\n        me.setValue(value);\n        me.fireEvent('select', me, value);\n        me.onChange(me, value, oldValue);\n    }", "code_tokens": ["function", "(", "picker", ",", "value", ")", "{", "var", "me", "=", "this", ",", "oldValue", "=", "me", ".", "getValue", "(", ")", ";", "me", ".", "setValue", "(", "value", ")", ";", "me", ".", "fireEvent", "(", "'select'", ",", "me", ",", "value", ")", ";", "me", ".", "onChange", "(", "me", ",", "value", ",", "oldValue", ")", ";", "}"], "docstring": "Called when the picker changes its value.\n@param {Ext.picker.Date} picker The date picker.\n@param {Object} value The new value from the date picker.\n@private", "docstring_tokens": ["Called", "when", "the", "picker", "changes", "its", "value", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/field/DatePicker.js#L311-L318", "partition": "test"}
{"repo": "GeoSensorWebLab/polarmap.js", "path": "js/leaflet.markercluster.js", "func_name": "", "original_string": "function (layersArray) {\n    var fg = this._featureGroup,\n      npg = this._nonPointGroup,\n      chunked = this.options.chunkedLoading,\n      chunkInterval = this.options.chunkInterval,\n      chunkProgress = this.options.chunkProgress,\n      newMarkers, i, l, m;\n\n    if (this._map) {\n      var offset = 0,\n        started = (new Date()).getTime();\n      var process = L.bind(function () {\n        var start = (new Date()).getTime();\n        for (; offset < layersArray.length; offset++) {\n          if (chunked && offset % 200 === 0) {\n            // every couple hundred markers, instrument the time elapsed since processing started:\n            var elapsed = (new Date()).getTime() - start;\n            if (elapsed > chunkInterval) {\n              break; // been working too hard, time to take a break :-)\n            }\n          }\n\n          m = layersArray[offset];\n\n          //Not point data, can't be clustered\n          if (!m.getLatLng) {\n            npg.addLayer(m);\n            continue;\n          }\n\n          if (this.hasLayer(m)) {\n            continue;\n          }\n\n          this._addLayer(m, this._maxZoom);\n\n          //If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\n          if (m.__parent) {\n            if (m.__parent.getChildCount() === 2) {\n              var markers = m.__parent.getAllChildMarkers(),\n                otherMarker = markers[0] === m ? markers[1] : markers[0];\n              fg.removeLayer(otherMarker);\n            }\n          }\n        }\n\n        if (chunkProgress) {\n          // report progress and time elapsed:\n          chunkProgress(offset, layersArray.length, (new Date()).getTime() - started);\n        }\n\n        if (offset === layersArray.length) {\n          //Update the icons of all those visible clusters that were affected\n          this._featureGroup.eachLayer(function (c) {\n            if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {\n              c._updateIcon();\n            }\n          });\n\n          this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n        } else {\n          setTimeout(process, this.options.chunkDelay);\n        }\n      }, this);\n\n      process();\n    } else {\n      newMarkers = [];\n      for (i = 0, l = layersArray.length; i < l; i++) {\n        m = layersArray[i];\n\n        //Not point data, can't be clustered\n        if (!m.getLatLng) {\n          npg.addLayer(m);\n          continue;\n        }\n\n        if (this.hasLayer(m)) {\n          continue;\n        }\n\n        newMarkers.push(m);\n      }\n      this._needsClustering = this._needsClustering.concat(newMarkers);\n    }\n    return this;\n  }", "language": "javascript", "code": "function (layersArray) {\n    var fg = this._featureGroup,\n      npg = this._nonPointGroup,\n      chunked = this.options.chunkedLoading,\n      chunkInterval = this.options.chunkInterval,\n      chunkProgress = this.options.chunkProgress,\n      newMarkers, i, l, m;\n\n    if (this._map) {\n      var offset = 0,\n        started = (new Date()).getTime();\n      var process = L.bind(function () {\n        var start = (new Date()).getTime();\n        for (; offset < layersArray.length; offset++) {\n          if (chunked && offset % 200 === 0) {\n            // every couple hundred markers, instrument the time elapsed since processing started:\n            var elapsed = (new Date()).getTime() - start;\n            if (elapsed > chunkInterval) {\n              break; // been working too hard, time to take a break :-)\n            }\n          }\n\n          m = layersArray[offset];\n\n          //Not point data, can't be clustered\n          if (!m.getLatLng) {\n            npg.addLayer(m);\n            continue;\n          }\n\n          if (this.hasLayer(m)) {\n            continue;\n          }\n\n          this._addLayer(m, this._maxZoom);\n\n          //If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\n          if (m.__parent) {\n            if (m.__parent.getChildCount() === 2) {\n              var markers = m.__parent.getAllChildMarkers(),\n                otherMarker = markers[0] === m ? markers[1] : markers[0];\n              fg.removeLayer(otherMarker);\n            }\n          }\n        }\n\n        if (chunkProgress) {\n          // report progress and time elapsed:\n          chunkProgress(offset, layersArray.length, (new Date()).getTime() - started);\n        }\n\n        if (offset === layersArray.length) {\n          //Update the icons of all those visible clusters that were affected\n          this._featureGroup.eachLayer(function (c) {\n            if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {\n              c._updateIcon();\n            }\n          });\n\n          this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n        } else {\n          setTimeout(process, this.options.chunkDelay);\n        }\n      }, this);\n\n      process();\n    } else {\n      newMarkers = [];\n      for (i = 0, l = layersArray.length; i < l; i++) {\n        m = layersArray[i];\n\n        //Not point data, can't be clustered\n        if (!m.getLatLng) {\n          npg.addLayer(m);\n          continue;\n        }\n\n        if (this.hasLayer(m)) {\n          continue;\n        }\n\n        newMarkers.push(m);\n      }\n      this._needsClustering = this._needsClustering.concat(newMarkers);\n    }\n    return this;\n  }", "code_tokens": ["function", "(", "layersArray", ")", "{", "var", "fg", "=", "this", ".", "_featureGroup", ",", "npg", "=", "this", ".", "_nonPointGroup", ",", "chunked", "=", "this", ".", "options", ".", "chunkedLoading", ",", "chunkInterval", "=", "this", ".", "options", ".", "chunkInterval", ",", "chunkProgress", "=", "this", ".", "options", ".", "chunkProgress", ",", "newMarkers", ",", "i", ",", "l", ",", "m", ";", "if", "(", "this", ".", "_map", ")", "{", "var", "offset", "=", "0", ",", "started", "=", "(", "new", "Date", "(", ")", ")", ".", "getTime", "(", ")", ";", "var", "process", "=", "L", ".", "bind", "(", "function", "(", ")", "{", "var", "start", "=", "(", "new", "Date", "(", ")", ")", ".", "getTime", "(", ")", ";", "for", "(", ";", "offset", "<", "layersArray", ".", "length", ";", "offset", "++", ")", "{", "if", "(", "chunked", "&&", "offset", "%", "200", "===", "0", ")", "{", "// every couple hundred markers, instrument the time elapsed since processing started:", "var", "elapsed", "=", "(", "new", "Date", "(", ")", ")", ".", "getTime", "(", ")", "-", "start", ";", "if", "(", "elapsed", ">", "chunkInterval", ")", "{", "break", ";", "// been working too hard, time to take a break :-)", "}", "}", "m", "=", "layersArray", "[", "offset", "]", ";", "//Not point data, can't be clustered", "if", "(", "!", "m", ".", "getLatLng", ")", "{", "npg", ".", "addLayer", "(", "m", ")", ";", "continue", ";", "}", "if", "(", "this", ".", "hasLayer", "(", "m", ")", ")", "{", "continue", ";", "}", "this", ".", "_addLayer", "(", "m", ",", "this", ".", "_maxZoom", ")", ";", "//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will", "if", "(", "m", ".", "__parent", ")", "{", "if", "(", "m", ".", "__parent", ".", "getChildCount", "(", ")", "===", "2", ")", "{", "var", "markers", "=", "m", ".", "__parent", ".", "getAllChildMarkers", "(", ")", ",", "otherMarker", "=", "markers", "[", "0", "]", "===", "m", "?", "markers", "[", "1", "]", ":", "markers", "[", "0", "]", ";", "fg", ".", "removeLayer", "(", "otherMarker", ")", ";", "}", "}", "}", "if", "(", "chunkProgress", ")", "{", "// report progress and time elapsed:", "chunkProgress", "(", "offset", ",", "layersArray", ".", "length", ",", "(", "new", "Date", "(", ")", ")", ".", "getTime", "(", ")", "-", "started", ")", ";", "}", "if", "(", "offset", "===", "layersArray", ".", "length", ")", "{", "//Update the icons of all those visible clusters that were affected", "this", ".", "_featureGroup", ".", "eachLayer", "(", "function", "(", "c", ")", "{", "if", "(", "c", "instanceof", "L", ".", "MarkerCluster", "&&", "c", ".", "_iconNeedsUpdate", ")", "{", "c", ".", "_updateIcon", "(", ")", ";", "}", "}", ")", ";", "this", ".", "_topClusterLevel", ".", "_recursivelyAddChildrenToMap", "(", "null", ",", "this", ".", "_zoom", ",", "this", ".", "_currentShownBounds", ")", ";", "}", "else", "{", "setTimeout", "(", "process", ",", "this", ".", "options", ".", "chunkDelay", ")", ";", "}", "}", ",", "this", ")", ";", "process", "(", ")", ";", "}", "else", "{", "newMarkers", "=", "[", "]", ";", "for", "(", "i", "=", "0", ",", "l", "=", "layersArray", ".", "length", ";", "i", "<", "l", ";", "i", "++", ")", "{", "m", "=", "layersArray", "[", "i", "]", ";", "//Not point data, can't be clustered", "if", "(", "!", "m", ".", "getLatLng", ")", "{", "npg", ".", "addLayer", "(", "m", ")", ";", "continue", ";", "}", "if", "(", "this", ".", "hasLayer", "(", "m", ")", ")", "{", "continue", ";", "}", "newMarkers", ".", "push", "(", "m", ")", ";", "}", "this", ".", "_needsClustering", "=", "this", ".", "_needsClustering", ".", "concat", "(", "newMarkers", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Takes an array of markers and adds them in bulk", "docstring_tokens": ["Takes", "an", "array", "of", "markers", "and", "adds", "them", "in", "bulk"], "sha": "fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b", "url": "https://github.com/GeoSensorWebLab/polarmap.js/blob/fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b/js/leaflet.markercluster.js#L165-L251", "partition": "test"}
{"repo": "NathanWalker/nativescript-ng2-magic", "path": "install.js", "func_name": "fixRefFile", "original_string": "function fixRefFile() {\n    var existingRef='', refFile = '../../references.d.ts';\n    if (fs.existsSync(refFile)) {\n        existingRef = fs.readFileSync(refFile).toString();\n    }\n\n  if (existingRef.indexOf('typescript/lib/lib.d.ts') === -1) {\n    // has not been previously modified\n    var fix = '/// <reference path=\"./node_modules/tns-core-modules/tns-core-modules.d.ts\" />\\n' +\n      '/// <reference path=\"./node_modules/typescript/lib/lib.d.ts\" />\\n';\n\n\n    fs.writeFileSync(refFile, fix, 'utf8');\n  }\n}", "language": "javascript", "code": "function fixRefFile() {\n    var existingRef='', refFile = '../../references.d.ts';\n    if (fs.existsSync(refFile)) {\n        existingRef = fs.readFileSync(refFile).toString();\n    }\n\n  if (existingRef.indexOf('typescript/lib/lib.d.ts') === -1) {\n    // has not been previously modified\n    var fix = '/// <reference path=\"./node_modules/tns-core-modules/tns-core-modules.d.ts\" />\\n' +\n      '/// <reference path=\"./node_modules/typescript/lib/lib.d.ts\" />\\n';\n\n\n    fs.writeFileSync(refFile, fix, 'utf8');\n  }\n}", "code_tokens": ["function", "fixRefFile", "(", ")", "{", "var", "existingRef", "=", "''", ",", "refFile", "=", "'../../references.d.ts'", ";", "if", "(", "fs", ".", "existsSync", "(", "refFile", ")", ")", "{", "existingRef", "=", "fs", ".", "readFileSync", "(", "refFile", ")", ".", "toString", "(", ")", ";", "}", "if", "(", "existingRef", ".", "indexOf", "(", "'typescript/lib/lib.d.ts'", ")", "===", "-", "1", ")", "{", "// has not been previously modified", "var", "fix", "=", "'/// <reference path=\"./node_modules/tns-core-modules/tns-core-modules.d.ts\" />\\n'", "+", "'/// <reference path=\"./node_modules/typescript/lib/lib.d.ts\" />\\n'", ";", "fs", ".", "writeFileSync", "(", "refFile", ",", "fix", ",", "'utf8'", ")", ";", "}", "}"], "docstring": "This fixes the references file to work with TS 2.0 in the nativescript folder", "docstring_tokens": ["This", "fixes", "the", "references", "file", "to", "work", "with", "TS", "2", ".", "0", "in", "the", "nativescript", "folder"], "sha": "702395cf85add650170ca45ca6f582e6ad609863", "url": "https://github.com/NathanWalker/nativescript-ng2-magic/blob/702395cf85add650170ca45ca6f582e6ad609863/install.js#L323-L337", "partition": "test"}
{"repo": "expressjs/generator", "path": "bin/express-cli.js", "func_name": "around", "original_string": "function around (obj, method, fn) {\n  var old = obj[method]\n\n  obj[method] = function () {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) args[i] = arguments[i]\n    return fn.call(this, old, args)\n  }\n}", "language": "javascript", "code": "function around (obj, method, fn) {\n  var old = obj[method]\n\n  obj[method] = function () {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) args[i] = arguments[i]\n    return fn.call(this, old, args)\n  }\n}", "code_tokens": ["function", "around", "(", "obj", ",", "method", ",", "fn", ")", "{", "var", "old", "=", "obj", "[", "method", "]", "obj", "[", "method", "]", "=", "function", "(", ")", "{", "var", "args", "=", "new", "Array", "(", "arguments", ".", "length", ")", "for", "(", "var", "i", "=", "0", ";", "i", "<", "args", ".", "length", ";", "i", "++", ")", "args", "[", "i", "]", "=", "arguments", "[", "i", "]", "return", "fn", ".", "call", "(", "this", ",", "old", ",", "args", ")", "}", "}"], "docstring": "Install an around function; AOP.", "docstring_tokens": ["Install", "an", "around", "function", ";", "AOP", "."], "sha": "d1f3fcc6ccc7ab8986fb3438c82ab1a1f20dc50d", "url": "https://github.com/expressjs/generator/blob/d1f3fcc6ccc7ab8986fb3438c82ab1a1f20dc50d/bin/express-cli.js#L70-L78", "partition": "test"}
{"repo": "HQarroum/Fsm", "path": "examples/elevator/index.js", "func_name": "", "original_string": "function (event) {\n      if (event.name === 'goToLevel') {\n        if (event.level === self.level) {\n          this.transitionTo(open);\n        } else {\n          self.pushLevel(event.level);\n          this.transitionTo(moving);\n        }\n      }\n    }", "language": "javascript", "code": "function (event) {\n      if (event.name === 'goToLevel') {\n        if (event.level === self.level) {\n          this.transitionTo(open);\n        } else {\n          self.pushLevel(event.level);\n          this.transitionTo(moving);\n        }\n      }\n    }", "code_tokens": ["function", "(", "event", ")", "{", "if", "(", "event", ".", "name", "===", "'goToLevel'", ")", "{", "if", "(", "event", ".", "level", "===", "self", ".", "level", ")", "{", "this", ".", "transitionTo", "(", "open", ")", ";", "}", "else", "{", "self", ".", "pushLevel", "(", "event", ".", "level", ")", ";", "this", ".", "transitionTo", "(", "moving", ")", ";", "}", "}", "}"], "docstring": "When the elevator's doors are closed,\nwe wait for a request to move to another\nlevel.", "docstring_tokens": ["When", "the", "elevator", "s", "doors", "are", "closed", "we", "wait", "for", "a", "request", "to", "move", "to", "another", "level", "."], "sha": "4d46fa0ef2fe8e54976808194312b66f9c7689b1", "url": "https://github.com/HQarroum/Fsm/blob/4d46fa0ef2fe8e54976808194312b66f9c7689b1/examples/elevator/index.js#L69-L78", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "", "original_string": "function (containerChildSet, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendChildToContainerChildSet(containerChildSet, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }", "language": "javascript", "code": "function (containerChildSet, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendChildToContainerChildSet(containerChildSet, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }", "code_tokens": ["function", "(", "containerChildSet", ",", "workInProgress", ")", "{", "// We only have the top Fiber that was created but we need recurse down its", "// children to find all the terminal nodes.", "var", "node", "=", "workInProgress", ".", "child", ";", "while", "(", "node", "!==", "null", ")", "{", "if", "(", "node", ".", "tag", "===", "HostComponent", "||", "node", ".", "tag", "===", "HostText", ")", "{", "appendChildToContainerChildSet", "(", "containerChildSet", ",", "node", ".", "stateNode", ")", ";", "}", "else", "if", "(", "node", ".", "tag", "===", "HostPortal", ")", "{", "// If we have a portal child, then we don't want to traverse", "// down its children. Instead, we'll get insertions from each child in", "// the portal directly.", "}", "else", "if", "(", "node", ".", "child", "!==", "null", ")", "{", "node", ".", "child", ".", "return", "=", "node", ";", "node", "=", "node", ".", "child", ";", "continue", ";", "}", "if", "(", "node", "===", "workInProgress", ")", "{", "return", ";", "}", "while", "(", "node", ".", "sibling", "===", "null", ")", "{", "if", "(", "node", ".", "return", "===", "null", "||", "node", ".", "return", "===", "workInProgress", ")", "{", "return", ";", "}", "node", "=", "node", ".", "return", ";", "}", "node", ".", "sibling", ".", "return", "=", "node", ".", "return", ";", "node", "=", "node", ".", "sibling", ";", "}", "}"], "docstring": "Persistent host tree mode An unfortunate fork of appendAllChildren because we have two different parent types.", "docstring_tokens": ["Persistent", "host", "tree", "mode", "An", "unfortunate", "fork", "of", "appendAllChildren", "because", "we", "have", "two", "different", "parent", "types", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L16593-L16621", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(data, type, record, options) {\n    var root = Ember.String.decamelize(type.typeKey);\n    data[root] = this.serialize(record, options);\n  }", "language": "javascript", "code": "function(data, type, record, options) {\n    var root = Ember.String.decamelize(type.typeKey);\n    data[root] = this.serialize(record, options);\n  }", "code_tokens": ["function", "(", "data", ",", "type", ",", "record", ",", "options", ")", "{", "var", "root", "=", "Ember", ".", "String", ".", "decamelize", "(", "type", ".", "typeKey", ")", ";", "data", "[", "root", "]", "=", "this", ".", "serialize", "(", "record", ",", "options", ")", ";", "}"], "docstring": "Underscores the JSON root keys when serializing.\n\n@method serializeIntoHash\n@param {Object} hash\n@param {subclass of DS.Model} type\n@param {DS.Model} record\n@param {Object} options", "docstring_tokens": ["Underscores", "the", "JSON", "root", "keys", "when", "serializing", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L10127-L10130", "partition": "test"}
{"repo": "AndreasMadsen/article", "path": "lib/helpers-dom.js", "func_name": "commonParent", "original_string": "function commonParent(a, b) {\n  if (a === b) {\n    return a;\n  } else if (containerOf(a, b)) {\n    return a;\n  } else if (containerOf(b, a)) {\n    return b;\n  } else {\n    // This will happen at some point, since the root is a container of\n    // everything\n    while (b = b.parent) {\n      if (containerOf(b, a)) return b;\n    }\n  }\n}", "language": "javascript", "code": "function commonParent(a, b) {\n  if (a === b) {\n    return a;\n  } else if (containerOf(a, b)) {\n    return a;\n  } else if (containerOf(b, a)) {\n    return b;\n  } else {\n    // This will happen at some point, since the root is a container of\n    // everything\n    while (b = b.parent) {\n      if (containerOf(b, a)) return b;\n    }\n  }\n}", "code_tokens": ["function", "commonParent", "(", "a", ",", "b", ")", "{", "if", "(", "a", "===", "b", ")", "{", "return", "a", ";", "}", "else", "if", "(", "containerOf", "(", "a", ",", "b", ")", ")", "{", "return", "a", ";", "}", "else", "if", "(", "containerOf", "(", "b", ",", "a", ")", ")", "{", "return", "b", ";", "}", "else", "{", "// This will happen at some point, since the root is a container of", "// everything", "while", "(", "b", "=", "b", ".", "parent", ")", "{", "if", "(", "containerOf", "(", "b", ",", "a", ")", ")", "return", "b", ";", "}", "}", "}"], "docstring": "Find the common parent of a and b", "docstring_tokens": ["Find", "the", "common", "parent", "of", "a", "and", "b"], "sha": "8cf3777fc9dc72d041214faae1b8d65d37a7d134", "url": "https://github.com/AndreasMadsen/article/blob/8cf3777fc9dc72d041214faae1b8d65d37a7d134/lib/helpers-dom.js#L129-L143", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "Flow", "original_string": "function Flow(opts) {\n    /**\n     * Supported by browser?\n     * @type {boolean}\n     */\n    this.support = (\n        typeof File !== 'undefined' &&\n        typeof Blob !== 'undefined' &&\n        typeof FileList !== 'undefined' &&\n        (\n          !!Blob.prototype.slice || !!Blob.prototype.webkitSlice || !!Blob.prototype.mozSlice ||\n          false\n        ) // slicing files support\n    );\n\n    if (!this.support) {\n      return ;\n    }\n\n    /**\n     * Check if directory upload is supported\n     * @type {boolean}\n     */\n    this.supportDirectory = (\n        /Chrome/.test(window.navigator.userAgent) ||\n        /Firefox/.test(window.navigator.userAgent) ||\n        /Edge/.test(window.navigator.userAgent)\n    );\n\n    /**\n     * List of FlowFile objects\n     * @type {Array.<FlowFile>}\n     */\n    this.files = [];\n\n    /**\n     * Default options for flow.js\n     * @type {Object}\n     */\n    this.defaults = {\n      chunkSize: 1024 * 1024,\n      forceChunkSize: false,\n      simultaneousUploads: 3,\n      singleFile: false,\n      fileParameterName: 'file',\n      progressCallbacksInterval: 500,\n      speedSmoothingFactor: 0.1,\n      query: {},\n      headers: {},\n      withCredentials: false,\n      preprocess: null,\n      method: 'multipart',\n      testMethod: 'GET',\n      uploadMethod: 'POST',\n      prioritizeFirstAndLastChunk: false,\n      allowDuplicateUploads: false,\n      target: '/',\n      testChunks: true,\n      generateUniqueIdentifier: null,\n      maxChunkRetries: 0,\n      chunkRetryInterval: null,\n      permanentErrors: [404, 413, 415, 500, 501],\n      successStatuses: [200, 201, 202],\n      onDropStopPropagation: false,\n      initFileFn: null,\n      readFileFn: webAPIFileRead\n    };\n\n    /**\n     * Current options\n     * @type {Object}\n     */\n    this.opts = {};\n\n    /**\n     * List of events:\n     *  key stands for event name\n     *  value array list of callbacks\n     * @type {}\n     */\n    this.events = {};\n\n    var $ = this;\n\n    /**\n     * On drop event\n     * @function\n     * @param {MouseEvent} event\n     */\n    this.onDrop = function (event) {\n      if ($.opts.onDropStopPropagation) {\n        event.stopPropagation();\n      }\n      event.preventDefault();\n      var dataTransfer = event.dataTransfer;\n      if (dataTransfer.items && dataTransfer.items[0] &&\n        dataTransfer.items[0].webkitGetAsEntry) {\n        $.webkitReadDataTransfer(event);\n      } else {\n        $.addFiles(dataTransfer.files, event);\n      }\n    };\n\n    /**\n     * Prevent default\n     * @function\n     * @param {MouseEvent} event\n     */\n    this.preventEvent = function (event) {\n      event.preventDefault();\n    };\n\n\n    /**\n     * Current options\n     * @type {Object}\n     */\n    this.opts = Flow.extend({}, this.defaults, opts || {});\n\n  }", "language": "javascript", "code": "function Flow(opts) {\n    /**\n     * Supported by browser?\n     * @type {boolean}\n     */\n    this.support = (\n        typeof File !== 'undefined' &&\n        typeof Blob !== 'undefined' &&\n        typeof FileList !== 'undefined' &&\n        (\n          !!Blob.prototype.slice || !!Blob.prototype.webkitSlice || !!Blob.prototype.mozSlice ||\n          false\n        ) // slicing files support\n    );\n\n    if (!this.support) {\n      return ;\n    }\n\n    /**\n     * Check if directory upload is supported\n     * @type {boolean}\n     */\n    this.supportDirectory = (\n        /Chrome/.test(window.navigator.userAgent) ||\n        /Firefox/.test(window.navigator.userAgent) ||\n        /Edge/.test(window.navigator.userAgent)\n    );\n\n    /**\n     * List of FlowFile objects\n     * @type {Array.<FlowFile>}\n     */\n    this.files = [];\n\n    /**\n     * Default options for flow.js\n     * @type {Object}\n     */\n    this.defaults = {\n      chunkSize: 1024 * 1024,\n      forceChunkSize: false,\n      simultaneousUploads: 3,\n      singleFile: false,\n      fileParameterName: 'file',\n      progressCallbacksInterval: 500,\n      speedSmoothingFactor: 0.1,\n      query: {},\n      headers: {},\n      withCredentials: false,\n      preprocess: null,\n      method: 'multipart',\n      testMethod: 'GET',\n      uploadMethod: 'POST',\n      prioritizeFirstAndLastChunk: false,\n      allowDuplicateUploads: false,\n      target: '/',\n      testChunks: true,\n      generateUniqueIdentifier: null,\n      maxChunkRetries: 0,\n      chunkRetryInterval: null,\n      permanentErrors: [404, 413, 415, 500, 501],\n      successStatuses: [200, 201, 202],\n      onDropStopPropagation: false,\n      initFileFn: null,\n      readFileFn: webAPIFileRead\n    };\n\n    /**\n     * Current options\n     * @type {Object}\n     */\n    this.opts = {};\n\n    /**\n     * List of events:\n     *  key stands for event name\n     *  value array list of callbacks\n     * @type {}\n     */\n    this.events = {};\n\n    var $ = this;\n\n    /**\n     * On drop event\n     * @function\n     * @param {MouseEvent} event\n     */\n    this.onDrop = function (event) {\n      if ($.opts.onDropStopPropagation) {\n        event.stopPropagation();\n      }\n      event.preventDefault();\n      var dataTransfer = event.dataTransfer;\n      if (dataTransfer.items && dataTransfer.items[0] &&\n        dataTransfer.items[0].webkitGetAsEntry) {\n        $.webkitReadDataTransfer(event);\n      } else {\n        $.addFiles(dataTransfer.files, event);\n      }\n    };\n\n    /**\n     * Prevent default\n     * @function\n     * @param {MouseEvent} event\n     */\n    this.preventEvent = function (event) {\n      event.preventDefault();\n    };\n\n\n    /**\n     * Current options\n     * @type {Object}\n     */\n    this.opts = Flow.extend({}, this.defaults, opts || {});\n\n  }", "code_tokens": ["function", "Flow", "(", "opts", ")", "{", "/**\n     * Supported by browser?\n     * @type {boolean}\n     */", "this", ".", "support", "=", "(", "typeof", "File", "!==", "'undefined'", "&&", "typeof", "Blob", "!==", "'undefined'", "&&", "typeof", "FileList", "!==", "'undefined'", "&&", "(", "!", "!", "Blob", ".", "prototype", ".", "slice", "||", "!", "!", "Blob", ".", "prototype", ".", "webkitSlice", "||", "!", "!", "Blob", ".", "prototype", ".", "mozSlice", "||", "false", ")", "// slicing files support", ")", ";", "if", "(", "!", "this", ".", "support", ")", "{", "return", ";", "}", "/**\n     * Check if directory upload is supported\n     * @type {boolean}\n     */", "this", ".", "supportDirectory", "=", "(", "/", "Chrome", "/", ".", "test", "(", "window", ".", "navigator", ".", "userAgent", ")", "||", "/", "Firefox", "/", ".", "test", "(", "window", ".", "navigator", ".", "userAgent", ")", "||", "/", "Edge", "/", ".", "test", "(", "window", ".", "navigator", ".", "userAgent", ")", ")", ";", "/**\n     * List of FlowFile objects\n     * @type {Array.<FlowFile>}\n     */", "this", ".", "files", "=", "[", "]", ";", "/**\n     * Default options for flow.js\n     * @type {Object}\n     */", "this", ".", "defaults", "=", "{", "chunkSize", ":", "1024", "*", "1024", ",", "forceChunkSize", ":", "false", ",", "simultaneousUploads", ":", "3", ",", "singleFile", ":", "false", ",", "fileParameterName", ":", "'file'", ",", "progressCallbacksInterval", ":", "500", ",", "speedSmoothingFactor", ":", "0.1", ",", "query", ":", "{", "}", ",", "headers", ":", "{", "}", ",", "withCredentials", ":", "false", ",", "preprocess", ":", "null", ",", "method", ":", "'multipart'", ",", "testMethod", ":", "'GET'", ",", "uploadMethod", ":", "'POST'", ",", "prioritizeFirstAndLastChunk", ":", "false", ",", "allowDuplicateUploads", ":", "false", ",", "target", ":", "'/'", ",", "testChunks", ":", "true", ",", "generateUniqueIdentifier", ":", "null", ",", "maxChunkRetries", ":", "0", ",", "chunkRetryInterval", ":", "null", ",", "permanentErrors", ":", "[", "404", ",", "413", ",", "415", ",", "500", ",", "501", "]", ",", "successStatuses", ":", "[", "200", ",", "201", ",", "202", "]", ",", "onDropStopPropagation", ":", "false", ",", "initFileFn", ":", "null", ",", "readFileFn", ":", "webAPIFileRead", "}", ";", "/**\n     * Current options\n     * @type {Object}\n     */", "this", ".", "opts", "=", "{", "}", ";", "/**\n     * List of events:\n     *  key stands for event name\n     *  value array list of callbacks\n     * @type {}\n     */", "this", ".", "events", "=", "{", "}", ";", "var", "$", "=", "this", ";", "/**\n     * On drop event\n     * @function\n     * @param {MouseEvent} event\n     */", "this", ".", "onDrop", "=", "function", "(", "event", ")", "{", "if", "(", "$", ".", "opts", ".", "onDropStopPropagation", ")", "{", "event", ".", "stopPropagation", "(", ")", ";", "}", "event", ".", "preventDefault", "(", ")", ";", "var", "dataTransfer", "=", "event", ".", "dataTransfer", ";", "if", "(", "dataTransfer", ".", "items", "&&", "dataTransfer", ".", "items", "[", "0", "]", "&&", "dataTransfer", ".", "items", "[", "0", "]", ".", "webkitGetAsEntry", ")", "{", "$", ".", "webkitReadDataTransfer", "(", "event", ")", ";", "}", "else", "{", "$", ".", "addFiles", "(", "dataTransfer", ".", "files", ",", "event", ")", ";", "}", "}", ";", "/**\n     * Prevent default\n     * @function\n     * @param {MouseEvent} event\n     */", "this", ".", "preventEvent", "=", "function", "(", "event", ")", "{", "event", ".", "preventDefault", "(", ")", ";", "}", ";", "/**\n     * Current options\n     * @type {Object}\n     */", "this", ".", "opts", "=", "Flow", ".", "extend", "(", "{", "}", ",", "this", ".", "defaults", ",", "opts", "||", "{", "}", ")", ";", "}"], "docstring": "Flow.js is a library providing multiple simultaneous, stable and\nresumable uploads via the HTML5 File API.\n@param [opts]\n@param {number} [opts.chunkSize]\n@param {bool} [opts.forceChunkSize]\n@param {number} [opts.simultaneousUploads]\n@param {bool} [opts.singleFile]\n@param {string} [opts.fileParameterName]\n@param {number} [opts.progressCallbacksInterval]\n@param {number} [opts.speedSmoothingFactor]\n@param {Object|Function} [opts.query]\n@param {Object|Function} [opts.headers]\n@param {bool} [opts.withCredentials]\n@param {Function} [opts.preprocess]\n@param {string} [opts.method]\n@param {string|Function} [opts.testMethod]\n@param {string|Function} [opts.uploadMethod]\n@param {bool} [opts.prioritizeFirstAndLastChunk]\n@param {bool} [opts.allowDuplicateUploads]\n@param {string|Function} [opts.target]\n@param {number} [opts.maxChunkRetries]\n@param {number} [opts.chunkRetryInterval]\n@param {Array.<number>} [opts.permanentErrors]\n@param {Array.<number>} [opts.successStatuses]\n@param {Function} [opts.initFileFn]\n@param {Function} [opts.readFileFn]\n@param {Function} [opts.generateUniqueIdentifier]\n@constructor", "docstring_tokens": ["Flow", ".", "js", "is", "a", "library", "providing", "multiple", "simultaneous", "stable", "and", "resumable", "uploads", "via", "the", "HTML5", "File", "API", "."], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L41-L160", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getSingleCallSignature", "original_string": "function getSingleCallSignature(type) {\n            if (type.flags & 80896 /* ObjectType */) {\n                var resolved = resolveStructuredTypeMembers(type);\n                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 &&\n                    resolved.properties.length === 0 && !resolved.stringIndexType && !resolved.numberIndexType) {\n                    return resolved.callSignatures[0];\n                }\n            }\n            return undefined;\n        }", "language": "javascript", "code": "function getSingleCallSignature(type) {\n            if (type.flags & 80896 /* ObjectType */) {\n                var resolved = resolveStructuredTypeMembers(type);\n                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 &&\n                    resolved.properties.length === 0 && !resolved.stringIndexType && !resolved.numberIndexType) {\n                    return resolved.callSignatures[0];\n                }\n            }\n            return undefined;\n        }", "code_tokens": ["function", "getSingleCallSignature", "(", "type", ")", "{", "if", "(", "type", ".", "flags", "&", "80896", "/* ObjectType */", ")", "{", "var", "resolved", "=", "resolveStructuredTypeMembers", "(", "type", ")", ";", "if", "(", "resolved", ".", "callSignatures", ".", "length", "===", "1", "&&", "resolved", ".", "constructSignatures", ".", "length", "===", "0", "&&", "resolved", ".", "properties", ".", "length", "===", "0", "&&", "!", "resolved", ".", "stringIndexType", "&&", "!", "resolved", ".", "numberIndexType", ")", "{", "return", "resolved", ".", "callSignatures", "[", "0", "]", ";", "}", "}", "return", "undefined", ";", "}"], "docstring": "If type has a single call signature and no other members, return that signature. Otherwise, return undefined.", "docstring_tokens": ["If", "type", "has", "a", "single", "call", "signature", "and", "no", "other", "members", "return", "that", "signature", ".", "Otherwise", "return", "undefined", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L20938-L20947", "partition": "test"}
{"repo": "YR/data-store", "path": "src/lib/methods/fetch.js", "func_name": "generateExpiry", "original_string": "function generateExpiry(headers = {}, defaultCacheControl) {\n  const cacheControl = mergeCacheControl(parseCacheControl(headers['cache-control']), defaultCacheControl);\n\n  const now = Date.now();\n  let expires = now;\n\n  if (headers.expires) {\n    expires = typeof headers.expires === 'string' ? Number(new Date(headers.expires)) : headers.expires;\n  }\n  if (now >= expires) {\n    expires = now + cacheControl.maxAge;\n  }\n\n  return {\n    expires,\n    expiresIfError: expires + cacheControl.staleIfError\n  };\n}", "language": "javascript", "code": "function generateExpiry(headers = {}, defaultCacheControl) {\n  const cacheControl = mergeCacheControl(parseCacheControl(headers['cache-control']), defaultCacheControl);\n\n  const now = Date.now();\n  let expires = now;\n\n  if (headers.expires) {\n    expires = typeof headers.expires === 'string' ? Number(new Date(headers.expires)) : headers.expires;\n  }\n  if (now >= expires) {\n    expires = now + cacheControl.maxAge;\n  }\n\n  return {\n    expires,\n    expiresIfError: expires + cacheControl.staleIfError\n  };\n}", "code_tokens": ["function", "generateExpiry", "(", "headers", "=", "{", "}", ",", "defaultCacheControl", ")", "{", "const", "cacheControl", "=", "mergeCacheControl", "(", "parseCacheControl", "(", "headers", "[", "'cache-control'", "]", ")", ",", "defaultCacheControl", ")", ";", "const", "now", "=", "Date", ".", "now", "(", ")", ";", "let", "expires", "=", "now", ";", "if", "(", "headers", ".", "expires", ")", "{", "expires", "=", "typeof", "headers", ".", "expires", "===", "'string'", "?", "Number", "(", "new", "Date", "(", "headers", ".", "expires", ")", ")", ":", "headers", ".", "expires", ";", "}", "if", "(", "now", ">=", "expires", ")", "{", "expires", "=", "now", "+", "cacheControl", ".", "maxAge", ";", "}", "return", "{", "expires", ",", "expiresIfError", ":", "expires", "+", "cacheControl", ".", "staleIfError", "}", ";", "}"], "docstring": "Generate expiry object from 'headers'\n@param {Object} [headers]\n@param {Object} defaultCacheControl\n@returns {Number}", "docstring_tokens": ["Generate", "expiry", "object", "from", "headers"], "sha": "bf8f581f850b9ebcb0fd319001ca69d0d9ff967f", "url": "https://github.com/YR/data-store/blob/bf8f581f850b9ebcb0fd319001ca69d0d9ff967f/src/lib/methods/fetch.js#L243-L260", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/types/index.js", "func_name": "getDataTypeNameByCode", "original_string": "function getDataTypeNameByCode(item) {\n  if (!item || typeof item.code !== 'number') {\n    throw new errors.ArgumentError('Invalid signature type definition');\n  }\n  const typeName = _dataTypesByCode[item.code];\n  if (!typeName) {\n    throw new errors.ArgumentError(util.format('Type with code %d not found', item.code));\n  }\n  if (!item.info) {\n    return typeName;\n  }\n  if (util.isArray(item.info)) {\n    return (typeName +\n      '<' +\n      item.info.map(function (t) {\n        return getDataTypeNameByCode(t);\n      }).join(', ') +\n      '>');\n  }\n  if (typeof item.info.code === 'number') {\n    return typeName + '<' + getDataTypeNameByCode(item.info) + '>';\n  }\n  return typeName;\n}", "language": "javascript", "code": "function getDataTypeNameByCode(item) {\n  if (!item || typeof item.code !== 'number') {\n    throw new errors.ArgumentError('Invalid signature type definition');\n  }\n  const typeName = _dataTypesByCode[item.code];\n  if (!typeName) {\n    throw new errors.ArgumentError(util.format('Type with code %d not found', item.code));\n  }\n  if (!item.info) {\n    return typeName;\n  }\n  if (util.isArray(item.info)) {\n    return (typeName +\n      '<' +\n      item.info.map(function (t) {\n        return getDataTypeNameByCode(t);\n      }).join(', ') +\n      '>');\n  }\n  if (typeof item.info.code === 'number') {\n    return typeName + '<' + getDataTypeNameByCode(item.info) + '>';\n  }\n  return typeName;\n}", "code_tokens": ["function", "getDataTypeNameByCode", "(", "item", ")", "{", "if", "(", "!", "item", "||", "typeof", "item", ".", "code", "!==", "'number'", ")", "{", "throw", "new", "errors", ".", "ArgumentError", "(", "'Invalid signature type definition'", ")", ";", "}", "const", "typeName", "=", "_dataTypesByCode", "[", "item", ".", "code", "]", ";", "if", "(", "!", "typeName", ")", "{", "throw", "new", "errors", ".", "ArgumentError", "(", "util", ".", "format", "(", "'Type with code %d not found'", ",", "item", ".", "code", ")", ")", ";", "}", "if", "(", "!", "item", ".", "info", ")", "{", "return", "typeName", ";", "}", "if", "(", "util", ".", "isArray", "(", "item", ".", "info", ")", ")", "{", "return", "(", "typeName", "+", "'<'", "+", "item", ".", "info", ".", "map", "(", "function", "(", "t", ")", "{", "return", "getDataTypeNameByCode", "(", "t", ")", ";", "}", ")", ".", "join", "(", "', '", ")", "+", "'>'", ")", ";", "}", "if", "(", "typeof", "item", ".", "info", ".", "code", "===", "'number'", ")", "{", "return", "typeName", "+", "'<'", "+", "getDataTypeNameByCode", "(", "item", ".", "info", ")", "+", "'>'", ";", "}", "return", "typeName", ";", "}"], "docstring": "Gets the data type name for a given type definition\n@internal\n@ignore\n@throws {ArgumentError}", "docstring_tokens": ["Gets", "the", "data", "type", "name", "for", "a", "given", "type", "definition"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/types/index.js#L393-L416", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/common/index.js", "func_name": "", "original_string": "function (res, mediaTypes) {\n    var contentTypeOk,\n        result = \"status: '\" + res.statusCode + \"', GET failed.\";\n\n    mediaTypes = !Array.isArray(mediaTypes) ? [mediaTypes] : mediaTypes;\n\n    if (res.statusCode === 200) {\n      // if content-type exists, and media type found then contentTypeOk\n      contentTypeOk =\n        res.headers[\"content-type\"] &&\n        // empty array and none found return true\n        !mediaTypes.every(function(mediaType) {\n          // flip -1 to 0 and NOT, so that true == NOT found, found stops loop w/false\n          return !~res.headers[\"content-type\"].indexOf(mediaType);\n        });\n\n      result = contentTypeOk ? \"\" : \"content-type not one of '\"+mediaTypes.join(\",\")+\"'\";\n    }\n\n    return result;\n  }", "language": "javascript", "code": "function (res, mediaTypes) {\n    var contentTypeOk,\n        result = \"status: '\" + res.statusCode + \"', GET failed.\";\n\n    mediaTypes = !Array.isArray(mediaTypes) ? [mediaTypes] : mediaTypes;\n\n    if (res.statusCode === 200) {\n      // if content-type exists, and media type found then contentTypeOk\n      contentTypeOk =\n        res.headers[\"content-type\"] &&\n        // empty array and none found return true\n        !mediaTypes.every(function(mediaType) {\n          // flip -1 to 0 and NOT, so that true == NOT found, found stops loop w/false\n          return !~res.headers[\"content-type\"].indexOf(mediaType);\n        });\n\n      result = contentTypeOk ? \"\" : \"content-type not one of '\"+mediaTypes.join(\",\")+\"'\";\n    }\n\n    return result;\n  }", "code_tokens": ["function", "(", "res", ",", "mediaTypes", ")", "{", "var", "contentTypeOk", ",", "result", "=", "\"status: '\"", "+", "res", ".", "statusCode", "+", "\"', GET failed.\"", ";", "mediaTypes", "=", "!", "Array", ".", "isArray", "(", "mediaTypes", ")", "?", "[", "mediaTypes", "]", ":", "mediaTypes", ";", "if", "(", "res", ".", "statusCode", "===", "200", ")", "{", "// if content-type exists, and media type found then contentTypeOk", "contentTypeOk", "=", "res", ".", "headers", "[", "\"content-type\"", "]", "&&", "// empty array and none found return true", "!", "mediaTypes", ".", "every", "(", "function", "(", "mediaType", ")", "{", "// flip -1 to 0 and NOT, so that true == NOT found, found stops loop w/false", "return", "!", "~", "res", ".", "headers", "[", "\"content-type\"", "]", ".", "indexOf", "(", "mediaType", ")", ";", "}", ")", ";", "result", "=", "contentTypeOk", "?", "\"\"", ":", "\"content-type not one of '\"", "+", "mediaTypes", ".", "join", "(", "\",\"", ")", "+", "\"'\"", ";", "}", "return", "result", ";", "}"], "docstring": "Simple response checker for remote files.\nExpected use in robots.txt or sitemap.xml only.\n\n@param {IncomingMessage} res - The IncomingMessage response to check.\n@param {Array} mediaTypes - array of acceptable content-type media type strings.\n@returns {String} Error message, empty string (falsy) if OK.", "docstring_tokens": ["Simple", "response", "checker", "for", "remote", "files", ".", "Expected", "use", "in", "robots", ".", "txt", "or", "sitemap", ".", "xml", "only", "."], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/common/index.js#L78-L98", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/direct/RemotingProvider.js", "func_name": "", "original_string": "function(transaction) {\n        var me = this,\n            enableBuffer = me.getEnableBuffer();\n\n        if (transaction.getForm()) {\n            me.sendFormRequest(transaction);\n            return;\n        }\n\n        me.callBuffer.push(transaction);\n        if (enableBuffer) {\n            if (!me.callTask) {\n                me.callTask = Ext.create('Ext.util.DelayedTask', me.combineAndSend, me);\n            }\n            me.callTask.delay(Ext.isNumber(enableBuffer) ? enableBuffer : 10);\n        } else {\n            me.combineAndSend();\n        }\n    }", "language": "javascript", "code": "function(transaction) {\n        var me = this,\n            enableBuffer = me.getEnableBuffer();\n\n        if (transaction.getForm()) {\n            me.sendFormRequest(transaction);\n            return;\n        }\n\n        me.callBuffer.push(transaction);\n        if (enableBuffer) {\n            if (!me.callTask) {\n                me.callTask = Ext.create('Ext.util.DelayedTask', me.combineAndSend, me);\n            }\n            me.callTask.delay(Ext.isNumber(enableBuffer) ? enableBuffer : 10);\n        } else {\n            me.combineAndSend();\n        }\n    }", "code_tokens": ["function", "(", "transaction", ")", "{", "var", "me", "=", "this", ",", "enableBuffer", "=", "me", ".", "getEnableBuffer", "(", ")", ";", "if", "(", "transaction", ".", "getForm", "(", ")", ")", "{", "me", ".", "sendFormRequest", "(", "transaction", ")", ";", "return", ";", "}", "me", ".", "callBuffer", ".", "push", "(", "transaction", ")", ";", "if", "(", "enableBuffer", ")", "{", "if", "(", "!", "me", ".", "callTask", ")", "{", "me", ".", "callTask", "=", "Ext", ".", "create", "(", "'Ext.util.DelayedTask'", ",", "me", ".", "combineAndSend", ",", "me", ")", ";", "}", "me", ".", "callTask", ".", "delay", "(", "Ext", ".", "isNumber", "(", "enableBuffer", ")", "?", "enableBuffer", ":", "10", ")", ";", "}", "else", "{", "me", ".", "combineAndSend", "(", ")", ";", "}", "}"], "docstring": "Add a new transaction to the queue.\n@private\n@param {Ext.direct.Transaction} transaction The transaction.", "docstring_tokens": ["Add", "a", "new", "transaction", "to", "the", "queue", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/direct/RemotingProvider.js#L415-L433", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(keyName, decrement) {\n    if (Ember.isNone(decrement)) { decrement = 1; }\n    Ember.assert(\"Must pass a numeric value to decrementProperty\", (!isNaN(parseFloat(decrement)) && isFinite(decrement)));\n    set(this, keyName, (get(this, keyName) || 0) - decrement);\n    return get(this, keyName);\n  }", "language": "javascript", "code": "function(keyName, decrement) {\n    if (Ember.isNone(decrement)) { decrement = 1; }\n    Ember.assert(\"Must pass a numeric value to decrementProperty\", (!isNaN(parseFloat(decrement)) && isFinite(decrement)));\n    set(this, keyName, (get(this, keyName) || 0) - decrement);\n    return get(this, keyName);\n  }", "code_tokens": ["function", "(", "keyName", ",", "decrement", ")", "{", "if", "(", "Ember", ".", "isNone", "(", "decrement", ")", ")", "{", "decrement", "=", "1", ";", "}", "Ember", ".", "assert", "(", "\"Must pass a numeric value to decrementProperty\"", ",", "(", "!", "isNaN", "(", "parseFloat", "(", "decrement", ")", ")", "&&", "isFinite", "(", "decrement", ")", ")", ")", ";", "set", "(", "this", ",", "keyName", ",", "(", "get", "(", "this", ",", "keyName", ")", "||", "0", ")", "-", "decrement", ")", ";", "return", "get", "(", "this", ",", "keyName", ")", ";", "}"], "docstring": "Set the value of a property to the current value minus some amount.\n\n```javascript\nplayer.decrementProperty('lives');\norc.decrementProperty('health', 5);\n```\n\n@method decrementProperty\n@param {String} keyName The name of the property to decrement\n@param {Number} decrement The amount to decrement by. Defaults to 1\n@return {Number} The new property value", "docstring_tokens": ["Set", "the", "value", "of", "a", "property", "to", "the", "current", "value", "minus", "some", "amount", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L12753-L12758", "partition": "test"}
{"repo": "remarkjs/remark-validate-links", "path": "index.js", "func_name": "onresource", "original_string": "function onresource(node) {\n    var link = node.url\n    var definition\n    var index\n    var uri\n    var pathname\n    var hash\n\n    // Handle references.\n    if (node.identifier) {\n      definition = getDefinition(node.identifier)\n      link = definition && definition.url\n    }\n\n    // Ignore definitions without url.\n    if (!link) {\n      return\n    }\n\n    uri = parse(link)\n\n    // Drop `?search`\n    uri.search = ''\n    link = format(uri)\n\n    if (!fileSet && (uri.hostname || uri.pathname)) {\n      return\n    }\n\n    if (!uri.hostname) {\n      if (lines && lineExpression.test(uri.hash)) {\n        uri.hash = ''\n      }\n\n      // Handle hashes, or relative files.\n      if (!uri.pathname && uri.hash) {\n        link = file.path + uri.hash\n        uri = parse(link)\n      } else {\n        link = urljoin(file.dirname, link)\n\n        if (uri.hash) {\n          link += uri.hash\n        }\n\n        uri = parse(link)\n      }\n    }\n\n    // Handle full links.\n    if (uri.hostname) {\n      if (!prefix || !fileSet) {\n        return\n      }\n\n      if (\n        uri.hostname !== info.domain ||\n        uri.pathname.slice(0, prefix.length) !== prefix\n      ) {\n        return\n      }\n\n      link = uri.pathname.slice(prefix.length) + (uri.hash || '')\n\n      // Things get interesting here: branches: `foo/bar/baz` could be `baz` on\n      // the `foo/bar` branch, or, `baz` in the `bar` directory on the `foo`\n      // branch.\n      //  Currently, we\u2019re ignoring this and just not supporting branches.\n      link = link.slice(link.indexOf('/') + 1)\n    }\n\n    // Handle file links, or combinations of files and hashes.\n    index = link.indexOf(headingPrefix)\n\n    if (index === -1) {\n      pathname = link\n      hash = null\n    } else {\n      pathname = link.slice(0, index)\n      hash = link.slice(index + headingPrefix.length)\n\n      if (lines && lineExpression.test(hash)) {\n        hash = null\n      }\n    }\n\n    if (!cache[pathname]) {\n      cache[pathname] = []\n    }\n\n    cache[pathname].push(node)\n\n    if (hash) {\n      link = pathname + '#' + hash\n\n      if (!cache[link]) {\n        cache[link] = []\n      }\n\n      cache[link].push(node)\n    }\n  }", "language": "javascript", "code": "function onresource(node) {\n    var link = node.url\n    var definition\n    var index\n    var uri\n    var pathname\n    var hash\n\n    // Handle references.\n    if (node.identifier) {\n      definition = getDefinition(node.identifier)\n      link = definition && definition.url\n    }\n\n    // Ignore definitions without url.\n    if (!link) {\n      return\n    }\n\n    uri = parse(link)\n\n    // Drop `?search`\n    uri.search = ''\n    link = format(uri)\n\n    if (!fileSet && (uri.hostname || uri.pathname)) {\n      return\n    }\n\n    if (!uri.hostname) {\n      if (lines && lineExpression.test(uri.hash)) {\n        uri.hash = ''\n      }\n\n      // Handle hashes, or relative files.\n      if (!uri.pathname && uri.hash) {\n        link = file.path + uri.hash\n        uri = parse(link)\n      } else {\n        link = urljoin(file.dirname, link)\n\n        if (uri.hash) {\n          link += uri.hash\n        }\n\n        uri = parse(link)\n      }\n    }\n\n    // Handle full links.\n    if (uri.hostname) {\n      if (!prefix || !fileSet) {\n        return\n      }\n\n      if (\n        uri.hostname !== info.domain ||\n        uri.pathname.slice(0, prefix.length) !== prefix\n      ) {\n        return\n      }\n\n      link = uri.pathname.slice(prefix.length) + (uri.hash || '')\n\n      // Things get interesting here: branches: `foo/bar/baz` could be `baz` on\n      // the `foo/bar` branch, or, `baz` in the `bar` directory on the `foo`\n      // branch.\n      //  Currently, we\u2019re ignoring this and just not supporting branches.\n      link = link.slice(link.indexOf('/') + 1)\n    }\n\n    // Handle file links, or combinations of files and hashes.\n    index = link.indexOf(headingPrefix)\n\n    if (index === -1) {\n      pathname = link\n      hash = null\n    } else {\n      pathname = link.slice(0, index)\n      hash = link.slice(index + headingPrefix.length)\n\n      if (lines && lineExpression.test(hash)) {\n        hash = null\n      }\n    }\n\n    if (!cache[pathname]) {\n      cache[pathname] = []\n    }\n\n    cache[pathname].push(node)\n\n    if (hash) {\n      link = pathname + '#' + hash\n\n      if (!cache[link]) {\n        cache[link] = []\n      }\n\n      cache[link].push(node)\n    }\n  }", "code_tokens": ["function", "onresource", "(", "node", ")", "{", "var", "link", "=", "node", ".", "url", "var", "definition", "var", "index", "var", "uri", "var", "pathname", "var", "hash", "// Handle references.", "if", "(", "node", ".", "identifier", ")", "{", "definition", "=", "getDefinition", "(", "node", ".", "identifier", ")", "link", "=", "definition", "&&", "definition", ".", "url", "}", "// Ignore definitions without url.", "if", "(", "!", "link", ")", "{", "return", "}", "uri", "=", "parse", "(", "link", ")", "// Drop `?search`", "uri", ".", "search", "=", "''", "link", "=", "format", "(", "uri", ")", "if", "(", "!", "fileSet", "&&", "(", "uri", ".", "hostname", "||", "uri", ".", "pathname", ")", ")", "{", "return", "}", "if", "(", "!", "uri", ".", "hostname", ")", "{", "if", "(", "lines", "&&", "lineExpression", ".", "test", "(", "uri", ".", "hash", ")", ")", "{", "uri", ".", "hash", "=", "''", "}", "// Handle hashes, or relative files.", "if", "(", "!", "uri", ".", "pathname", "&&", "uri", ".", "hash", ")", "{", "link", "=", "file", ".", "path", "+", "uri", ".", "hash", "uri", "=", "parse", "(", "link", ")", "}", "else", "{", "link", "=", "urljoin", "(", "file", ".", "dirname", ",", "link", ")", "if", "(", "uri", ".", "hash", ")", "{", "link", "+=", "uri", ".", "hash", "}", "uri", "=", "parse", "(", "link", ")", "}", "}", "// Handle full links.", "if", "(", "uri", ".", "hostname", ")", "{", "if", "(", "!", "prefix", "||", "!", "fileSet", ")", "{", "return", "}", "if", "(", "uri", ".", "hostname", "!==", "info", ".", "domain", "||", "uri", ".", "pathname", ".", "slice", "(", "0", ",", "prefix", ".", "length", ")", "!==", "prefix", ")", "{", "return", "}", "link", "=", "uri", ".", "pathname", ".", "slice", "(", "prefix", ".", "length", ")", "+", "(", "uri", ".", "hash", "||", "''", ")", "// Things get interesting here: branches: `foo/bar/baz` could be `baz` on", "// the `foo/bar` branch, or, `baz` in the `bar` directory on the `foo`", "// branch.", "//  Currently, we\u2019re ignoring this and just not supporting branches.", "link", "=", "link", ".", "slice", "(", "link", ".", "indexOf", "(", "'/'", ")", "+", "1", ")", "}", "// Handle file links, or combinations of files and hashes.", "index", "=", "link", ".", "indexOf", "(", "headingPrefix", ")", "if", "(", "index", "===", "-", "1", ")", "{", "pathname", "=", "link", "hash", "=", "null", "}", "else", "{", "pathname", "=", "link", ".", "slice", "(", "0", ",", "index", ")", "hash", "=", "link", ".", "slice", "(", "index", "+", "headingPrefix", ".", "length", ")", "if", "(", "lines", "&&", "lineExpression", ".", "test", "(", "hash", ")", ")", "{", "hash", "=", "null", "}", "}", "if", "(", "!", "cache", "[", "pathname", "]", ")", "{", "cache", "[", "pathname", "]", "=", "[", "]", "}", "cache", "[", "pathname", "]", ".", "push", "(", "node", ")", "if", "(", "hash", ")", "{", "link", "=", "pathname", "+", "'#'", "+", "hash", "if", "(", "!", "cache", "[", "link", "]", ")", "{", "cache", "[", "link", "]", "=", "[", "]", "}", "cache", "[", "link", "]", ".", "push", "(", "node", ")", "}", "}"], "docstring": "Handle resources.", "docstring_tokens": ["Handle", "resources", "."], "sha": "caa1f9fa8ca09567951cf28f9252f642ab36ad9a", "url": "https://github.com/remarkjs/remark-validate-links/blob/caa1f9fa8ca09567951cf28f9252f642ab36ad9a/index.js#L279-L380", "partition": "test"}
{"repo": "phphe/vue-draggable-nested-tree", "path": "dist/vue-draggable-nested-tree.es.js", "func_name": "offsetToViewPort", "original_string": "function offsetToViewPort() {\n      var r = this.nodeInnerEl.getBoundingClientRect();\n      r.x = r.left;\n      r.y = r.top;\n      return r;\n    }", "language": "javascript", "code": "function offsetToViewPort() {\n      var r = this.nodeInnerEl.getBoundingClientRect();\n      r.x = r.left;\n      r.y = r.top;\n      return r;\n    }", "code_tokens": ["function", "offsetToViewPort", "(", ")", "{", "var", "r", "=", "this", ".", "nodeInnerEl", ".", "getBoundingClientRect", "(", ")", ";", "r", ".", "x", "=", "r", ".", "left", ";", "r", ".", "y", "=", "r", ".", "top", ";", "return", "r", ";", "}"], "docstring": "right bottom point", "docstring_tokens": ["right", "bottom", "point"], "sha": "094b12954d55d449cdebbcbc00c6456fed3c99ce", "url": "https://github.com/phphe/vue-draggable-nested-tree/blob/094b12954d55d449cdebbcbc00c6456fed3c99ce/dist/vue-draggable-nested-tree.es.js#L881-L886", "partition": "test"}
{"repo": "integreat-io/integreat", "path": "lib/service/mapFromService.js", "func_name": "mapFromService", "original_string": "function mapFromService () {\n  return ({ response, request, responseMapper, mappings }) => {\n    if (response.status !== 'ok') {\n      return response\n    }\n\n    const type = request.params.type || Object.keys(mappings)\n    const { onlyMappedValues, unmapped = false } = request.params\n\n    if (unmapped) {\n      return response\n    }\n\n    const { data, status = response.status, error, paging, params } =\n      mapWithEndpoint(responseMapper, response, request.action)\n\n    if (status !== 'ok') {\n      return removeDataProp({ ...response, status, error })\n    }\n\n    const mapType = (type) => (mappings[type])\n      ? mappings[type].fromService({ ...request, data }, { onlyMappedValues })\n      : []\n\n    return {\n      ...response,\n      status,\n      ...((paging) ? { paging } : {}),\n      ...((params) ? { params } : {}),\n      data: (data) ? flatten(mapAny(mapType, type)) : undefined\n    }\n  }\n}", "language": "javascript", "code": "function mapFromService () {\n  return ({ response, request, responseMapper, mappings }) => {\n    if (response.status !== 'ok') {\n      return response\n    }\n\n    const type = request.params.type || Object.keys(mappings)\n    const { onlyMappedValues, unmapped = false } = request.params\n\n    if (unmapped) {\n      return response\n    }\n\n    const { data, status = response.status, error, paging, params } =\n      mapWithEndpoint(responseMapper, response, request.action)\n\n    if (status !== 'ok') {\n      return removeDataProp({ ...response, status, error })\n    }\n\n    const mapType = (type) => (mappings[type])\n      ? mappings[type].fromService({ ...request, data }, { onlyMappedValues })\n      : []\n\n    return {\n      ...response,\n      status,\n      ...((paging) ? { paging } : {}),\n      ...((params) ? { params } : {}),\n      data: (data) ? flatten(mapAny(mapType, type)) : undefined\n    }\n  }\n}", "code_tokens": ["function", "mapFromService", "(", ")", "{", "return", "(", "{", "response", ",", "request", ",", "responseMapper", ",", "mappings", "}", ")", "=>", "{", "if", "(", "response", ".", "status", "!==", "'ok'", ")", "{", "return", "response", "}", "const", "type", "=", "request", ".", "params", ".", "type", "||", "Object", ".", "keys", "(", "mappings", ")", "const", "{", "onlyMappedValues", ",", "unmapped", "=", "false", "}", "=", "request", ".", "params", "if", "(", "unmapped", ")", "{", "return", "response", "}", "const", "{", "data", ",", "status", "=", "response", ".", "status", ",", "error", ",", "paging", ",", "params", "}", "=", "mapWithEndpoint", "(", "responseMapper", ",", "response", ",", "request", ".", "action", ")", "if", "(", "status", "!==", "'ok'", ")", "{", "return", "removeDataProp", "(", "{", "...", "response", ",", "status", ",", "error", "}", ")", "}", "const", "mapType", "=", "(", "type", ")", "=>", "(", "mappings", "[", "type", "]", ")", "?", "mappings", "[", "type", "]", ".", "fromService", "(", "{", "...", "request", ",", "data", "}", ",", "{", "onlyMappedValues", "}", ")", ":", "[", "]", "return", "{", "...", "response", ",", "status", ",", "...", "(", "(", "paging", ")", "?", "{", "paging", "}", ":", "{", "}", ")", ",", "...", "(", "(", "params", ")", "?", "{", "params", "}", ":", "{", "}", ")", ",", "data", ":", "(", "data", ")", "?", "flatten", "(", "mapAny", "(", "mapType", ",", "type", ")", ")", ":", "undefined", "}", "}", "}"], "docstring": "Map the data going _to_ the service. Everything is handled by the mappings,\nbut this method make sure that the right types are mapped.\n\n@param {Object} data - The data to map\n@param {Object} options - mappings, params, onlyMappedValues, and endpoint\n@returns {Object[]} Array of mapped items", "docstring_tokens": ["Map", "the", "data", "going", "_to_", "the", "service", ".", "Everything", "is", "handled", "by", "the", "mappings", "but", "this", "method", "make", "sure", "that", "the", "right", "types", "are", "mapped", "."], "sha": "b3092036bfd40d74a082297cace1f678502427c6", "url": "https://github.com/integreat-io/integreat/blob/b3092036bfd40d74a082297cace1f678502427c6/lib/service/mapFromService.js#L22-L54", "partition": "test"}
{"repo": "FGRibreau/forever-webui", "path": "public/js/pretty.js", "func_name": "prettyDate", "original_string": "function prettyDate(time){\r\n\t/*var date = new Date((time || \"\")*/ \r\n\tvar diff = (((new Date()).getTime() - time) / 1000),\r\n\t\t\tday_diff = Math.floor(diff / 86400);\r\n\t\t\t\r\n\tif ( isNaN(day_diff) || day_diff < 0 || day_diff >= 31 )\r\n\t\treturn;\r\n\t\t\t\r\n\treturn day_diff == 0 && (\r\n\t\t\tdiff < 60 && \"just now\" ||\r\n\t\t\tdiff < 120 && \"1 minute ago\" ||\r\n\t\t\tdiff < 3600 && Math.floor( diff / 60 ) + \" minutes ago\" ||\r\n\t\t\tdiff < 7200 && \"1 hour ago\" ||\r\n\t\t\tdiff < 86400 && Math.floor( diff / 3600 ) + \" hours ago\") ||\r\n\t\tday_diff == 1 && \"Yesterday\" ||\r\n\t\tday_diff < 7 && day_diff + \" days ago\" ||\r\n\t\tday_diff < 31 && Math.ceil( day_diff / 7 ) + \" weeks ago\";\r\n}", "language": "javascript", "code": "function prettyDate(time){\r\n\t/*var date = new Date((time || \"\")*/ \r\n\tvar diff = (((new Date()).getTime() - time) / 1000),\r\n\t\t\tday_diff = Math.floor(diff / 86400);\r\n\t\t\t\r\n\tif ( isNaN(day_diff) || day_diff < 0 || day_diff >= 31 )\r\n\t\treturn;\r\n\t\t\t\r\n\treturn day_diff == 0 && (\r\n\t\t\tdiff < 60 && \"just now\" ||\r\n\t\t\tdiff < 120 && \"1 minute ago\" ||\r\n\t\t\tdiff < 3600 && Math.floor( diff / 60 ) + \" minutes ago\" ||\r\n\t\t\tdiff < 7200 && \"1 hour ago\" ||\r\n\t\t\tdiff < 86400 && Math.floor( diff / 3600 ) + \" hours ago\") ||\r\n\t\tday_diff == 1 && \"Yesterday\" ||\r\n\t\tday_diff < 7 && day_diff + \" days ago\" ||\r\n\t\tday_diff < 31 && Math.ceil( day_diff / 7 ) + \" weeks ago\";\r\n}", "code_tokens": ["function", "prettyDate", "(", "time", ")", "{", "/*var date = new Date((time || \"\")*/", "var", "diff", "=", "(", "(", "(", "new", "Date", "(", ")", ")", ".", "getTime", "(", ")", "-", "time", ")", "/", "1000", ")", ",", "day_diff", "=", "Math", ".", "floor", "(", "diff", "/", "86400", ")", ";", "if", "(", "isNaN", "(", "day_diff", ")", "||", "day_diff", "<", "0", "||", "day_diff", ">=", "31", ")", "return", ";", "return", "day_diff", "==", "0", "&&", "(", "diff", "<", "60", "&&", "\"just now\"", "||", "diff", "<", "120", "&&", "\"1 minute ago\"", "||", "diff", "<", "3600", "&&", "Math", ".", "floor", "(", "diff", "/", "60", ")", "+", "\" minutes ago\"", "||", "diff", "<", "7200", "&&", "\"1 hour ago\"", "||", "diff", "<", "86400", "&&", "Math", ".", "floor", "(", "diff", "/", "3600", ")", "+", "\" hours ago\"", ")", "||", "day_diff", "==", "1", "&&", "\"Yesterday\"", "||", "day_diff", "<", "7", "&&", "day_diff", "+", "\" days ago\"", "||", "day_diff", "<", "31", "&&", "Math", ".", "ceil", "(", "day_diff", "/", "7", ")", "+", "\" weeks ago\"", ";", "}"], "docstring": "Takes an ISO time and returns a string representing how long ago the date represents.", "docstring_tokens": ["Takes", "an", "ISO", "time", "and", "returns", "a", "string", "representing", "how", "long", "ago", "the", "date", "represents", "."], "sha": "fe9b4a219097c56daddc3e6f3943dcc20a80fbcd", "url": "https://github.com/FGRibreau/forever-webui/blob/fe9b4a219097c56daddc3e6f3943dcc20a80fbcd/public/js/pretty.js#L9-L26", "partition": "test"}
{"repo": "olegpolyakov/sendpulse", "path": "index.js", "func_name": "editAddressBook", "original_string": "function editAddressBook(callback,id,bookName) {\n    if ((id===undefined) || (bookName === undefined) || (! bookName.length)) {\n        return callback(returnError(\"Empty book name or book id\"));\n    }\n    var data = {name: bookName};\n    sendRequest( 'addressbooks/' + id, 'PUT', data, true, callback );\n}", "language": "javascript", "code": "function editAddressBook(callback,id,bookName) {\n    if ((id===undefined) || (bookName === undefined) || (! bookName.length)) {\n        return callback(returnError(\"Empty book name or book id\"));\n    }\n    var data = {name: bookName};\n    sendRequest( 'addressbooks/' + id, 'PUT', data, true, callback );\n}", "code_tokens": ["function", "editAddressBook", "(", "callback", ",", "id", ",", "bookName", ")", "{", "if", "(", "(", "id", "===", "undefined", ")", "||", "(", "bookName", "===", "undefined", ")", "||", "(", "!", "bookName", ".", "length", ")", ")", "{", "return", "callback", "(", "returnError", "(", "\"Empty book name or book id\"", ")", ")", ";", "}", "var", "data", "=", "{", "name", ":", "bookName", "}", ";", "sendRequest", "(", "'addressbooks/'", "+", "id", ",", "'PUT'", ",", "data", ",", "true", ",", "callback", ")", ";", "}"], "docstring": "Edit address book name\n\n@param callback\n@param id\n@param bookName", "docstring_tokens": ["Edit", "address", "book", "name"], "sha": "7c8230e75c918a8a110f641ddb241006a1f86ac1", "url": "https://github.com/olegpolyakov/sendpulse/blob/7c8230e75c918a8a110f641ddb241006a1f86ac1/index.js#L307-L313", "partition": "test"}
{"repo": "genify/toolkit2", "path": "lib/cache.js", "func_name": "", "original_string": "function(config){\n    if (!_fs.exist(config.output)){\n        return abortProcess(\n            config,'no package to be uploaded'\n        );\n    }\n    _logger.info('begin build upload form ...');\n    var form = new FormData();\n    var ex = _util.merge(\n        {\n            version: '0.1',\n            platform: 'ios&android'\n        },\n        config.extension\n    );\n    // build form\n    Object.keys(ex).forEach(function(name){\n        form.append(name,ex[name]);\n    });\n    form.append('token',config.token);\n    form.append('resID',config.appid);\n    form.append('appID',config.nativeId);\n    form.append('userData',JSON.stringify({domains:config.domains}));\n    form.append('zip',fs.createReadStream(config.output));\n    // submit form\n    _logger.info('begin upload package to web cache server ...');\n    form.submit(config.api,function(err,res){\n        if (err){\n            return abortProcess(\n                config,'upload failed for reason:\\n%s',err.stack\n            );\n        }\n        // chunk response data\n        var arr = [];\n        res.on('data',function(chunk){\n            arr.push(chunk);\n        });\n        // parse response result\n        res.on('end',function(){\n            var ret = null,\n                txt = arr.join('');\n            try{\n                ret = JSON.parse(txt);\n            }catch(ex){\n                // result error\n                return abortProcess(\n                    config,'[%s] %s\\n%s',\n                    res.statusCode,txt,ex.stack\n                );\n            }\n            if (!!ret&&ret.code==0){\n                clearTemp(config);\n                _logger.info('package upload success');\n                config.ondone();\n            }else{\n                return abortProcess(\n                    config,'package upload failed for reason: [%s] %s',\n                    res.statusCode,txt\n                );\n            }\n        });\n        res.resume();\n    });\n}", "language": "javascript", "code": "function(config){\n    if (!_fs.exist(config.output)){\n        return abortProcess(\n            config,'no package to be uploaded'\n        );\n    }\n    _logger.info('begin build upload form ...');\n    var form = new FormData();\n    var ex = _util.merge(\n        {\n            version: '0.1',\n            platform: 'ios&android'\n        },\n        config.extension\n    );\n    // build form\n    Object.keys(ex).forEach(function(name){\n        form.append(name,ex[name]);\n    });\n    form.append('token',config.token);\n    form.append('resID',config.appid);\n    form.append('appID',config.nativeId);\n    form.append('userData',JSON.stringify({domains:config.domains}));\n    form.append('zip',fs.createReadStream(config.output));\n    // submit form\n    _logger.info('begin upload package to web cache server ...');\n    form.submit(config.api,function(err,res){\n        if (err){\n            return abortProcess(\n                config,'upload failed for reason:\\n%s',err.stack\n            );\n        }\n        // chunk response data\n        var arr = [];\n        res.on('data',function(chunk){\n            arr.push(chunk);\n        });\n        // parse response result\n        res.on('end',function(){\n            var ret = null,\n                txt = arr.join('');\n            try{\n                ret = JSON.parse(txt);\n            }catch(ex){\n                // result error\n                return abortProcess(\n                    config,'[%s] %s\\n%s',\n                    res.statusCode,txt,ex.stack\n                );\n            }\n            if (!!ret&&ret.code==0){\n                clearTemp(config);\n                _logger.info('package upload success');\n                config.ondone();\n            }else{\n                return abortProcess(\n                    config,'package upload failed for reason: [%s] %s',\n                    res.statusCode,txt\n                );\n            }\n        });\n        res.resume();\n    });\n}", "code_tokens": ["function", "(", "config", ")", "{", "if", "(", "!", "_fs", ".", "exist", "(", "config", ".", "output", ")", ")", "{", "return", "abortProcess", "(", "config", ",", "'no package to be uploaded'", ")", ";", "}", "_logger", ".", "info", "(", "'begin build upload form ...'", ")", ";", "var", "form", "=", "new", "FormData", "(", ")", ";", "var", "ex", "=", "_util", ".", "merge", "(", "{", "version", ":", "'0.1'", ",", "platform", ":", "'ios&android'", "}", ",", "config", ".", "extension", ")", ";", "// build form", "Object", ".", "keys", "(", "ex", ")", ".", "forEach", "(", "function", "(", "name", ")", "{", "form", ".", "append", "(", "name", ",", "ex", "[", "name", "]", ")", ";", "}", ")", ";", "form", ".", "append", "(", "'token'", ",", "config", ".", "token", ")", ";", "form", ".", "append", "(", "'resID'", ",", "config", ".", "appid", ")", ";", "form", ".", "append", "(", "'appID'", ",", "config", ".", "nativeId", ")", ";", "form", ".", "append", "(", "'userData'", ",", "JSON", ".", "stringify", "(", "{", "domains", ":", "config", ".", "domains", "}", ")", ")", ";", "form", ".", "append", "(", "'zip'", ",", "fs", ".", "createReadStream", "(", "config", ".", "output", ")", ")", ";", "// submit form", "_logger", ".", "info", "(", "'begin upload package to web cache server ...'", ")", ";", "form", ".", "submit", "(", "config", ".", "api", ",", "function", "(", "err", ",", "res", ")", "{", "if", "(", "err", ")", "{", "return", "abortProcess", "(", "config", ",", "'upload failed for reason:\\n%s'", ",", "err", ".", "stack", ")", ";", "}", "// chunk response data", "var", "arr", "=", "[", "]", ";", "res", ".", "on", "(", "'data'", ",", "function", "(", "chunk", ")", "{", "arr", ".", "push", "(", "chunk", ")", ";", "}", ")", ";", "// parse response result", "res", ".", "on", "(", "'end'", ",", "function", "(", ")", "{", "var", "ret", "=", "null", ",", "txt", "=", "arr", ".", "join", "(", "''", ")", ";", "try", "{", "ret", "=", "JSON", ".", "parse", "(", "txt", ")", ";", "}", "catch", "(", "ex", ")", "{", "// result error", "return", "abortProcess", "(", "config", ",", "'[%s] %s\\n%s'", ",", "res", ".", "statusCode", ",", "txt", ",", "ex", ".", "stack", ")", ";", "}", "if", "(", "!", "!", "ret", "&&", "ret", ".", "code", "==", "0", ")", "{", "clearTemp", "(", "config", ")", ";", "_logger", ".", "info", "(", "'package upload success'", ")", ";", "config", ".", "ondone", "(", ")", ";", "}", "else", "{", "return", "abortProcess", "(", "config", ",", "'package upload failed for reason: [%s] %s'", ",", "res", ".", "statusCode", ",", "txt", ")", ";", "}", "}", ")", ";", "res", ".", "resume", "(", ")", ";", "}", ")", ";", "}"], "docstring": "upload package to web cache server\n@param  {Object} config - config object\n@return {Void}", "docstring_tokens": ["upload", "package", "to", "web", "cache", "server"], "sha": "bb40480731f363327e055f7120d3fd6de6336cda", "url": "https://github.com/genify/toolkit2/blob/bb40480731f363327e055f7120d3fd6de6336cda/lib/cache.js#L95-L158", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      if (this.isDestroyed) { return this; }\n      // #2134: remove parent element before destroying the child views, so\n      // removing the child views doesn't retrigger repaints\n      if (this.getOption('destroyImmediate') === true) {\n        this.$el.remove();\n      }\n      this.regionManager.destroy();\n      return Marionette.ItemView.prototype.destroy.apply(this, arguments);\n    }", "language": "javascript", "code": "function() {\n      if (this.isDestroyed) { return this; }\n      // #2134: remove parent element before destroying the child views, so\n      // removing the child views doesn't retrigger repaints\n      if (this.getOption('destroyImmediate') === true) {\n        this.$el.remove();\n      }\n      this.regionManager.destroy();\n      return Marionette.ItemView.prototype.destroy.apply(this, arguments);\n    }", "code_tokens": ["function", "(", ")", "{", "if", "(", "this", ".", "isDestroyed", ")", "{", "return", "this", ";", "}", "// #2134: remove parent element before destroying the child views, so", "// removing the child views doesn't retrigger repaints", "if", "(", "this", ".", "getOption", "(", "'destroyImmediate'", ")", "===", "true", ")", "{", "this", ".", "$el", ".", "remove", "(", ")", ";", "}", "this", ".", "regionManager", ".", "destroy", "(", ")", ";", "return", "Marionette", ".", "ItemView", ".", "prototype", ".", "destroy", ".", "apply", "(", "this", ",", "arguments", ")", ";", "}"], "docstring": "Handle destroying regions, and then destroy the view itself.", "docstring_tokens": ["Handle", "destroying", "regions", "and", "then", "destroy", "the", "view", "itself", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19190-L19199", "partition": "test"}
{"repo": "Katochimoto/xblocks-core", "path": "src/xblocks/view.js", "func_name": "wrapperOrResult", "original_string": "function wrapperOrResult(srcFunc, objFunc, ...args) {\n    let resultObjFunction = false;\n    let resultSrcFunction = false;\n\n    if (isFunction(objFunc)) {\n        resultObjFunction = objFunc.apply(this, args);\n    }\n\n    if (isFunction(srcFunc)) {\n        resultSrcFunction = srcFunc.apply(this, args);\n    }\n\n    return resultObjFunction || resultSrcFunction;\n}", "language": "javascript", "code": "function wrapperOrResult(srcFunc, objFunc, ...args) {\n    let resultObjFunction = false;\n    let resultSrcFunction = false;\n\n    if (isFunction(objFunc)) {\n        resultObjFunction = objFunc.apply(this, args);\n    }\n\n    if (isFunction(srcFunc)) {\n        resultSrcFunction = srcFunc.apply(this, args);\n    }\n\n    return resultObjFunction || resultSrcFunction;\n}", "code_tokens": ["function", "wrapperOrResult", "(", "srcFunc", ",", "objFunc", ",", "...", "args", ")", "{", "let", "resultObjFunction", "=", "false", ";", "let", "resultSrcFunction", "=", "false", ";", "if", "(", "isFunction", "(", "objFunc", ")", ")", "{", "resultObjFunction", "=", "objFunc", ".", "apply", "(", "this", ",", "args", ")", ";", "}", "if", "(", "isFunction", "(", "srcFunc", ")", ")", "{", "resultSrcFunction", "=", "srcFunc", ".", "apply", "(", "this", ",", "args", ")", ";", "}", "return", "resultObjFunction", "||", "resultSrcFunction", ";", "}"], "docstring": "Merging the result of the logical \"or\".\n@example\n// call objFunc, srcFunc\n_.wrap(objFunc, _.wrap(srcFunc, wrapperOrResult));\n@param {function} [srcFunc]\n@param {function} [objFunc]\n@param {...*} args\n@returns {boolean}\n@private", "docstring_tokens": ["Merging", "the", "result", "of", "the", "logical", "or", "."], "sha": "714102b7c2adb4ae197403df252e967a1b967bb1", "url": "https://github.com/Katochimoto/xblocks-core/blob/714102b7c2adb4ae197403df252e967a1b967bb1/src/xblocks/view.js#L234-L247", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/elements/Button/ButtonGroup.js", "func_name": "ButtonGroup", "original_string": "function ButtonGroup(props) {\n  const {\n    attached,\n    basic,\n    buttons,\n    children,\n    className,\n    color,\n    compact,\n    content,\n    floated,\n    fluid,\n    icon,\n    inverted,\n    labeled,\n    negative,\n    positive,\n    primary,\n    secondary,\n    size,\n    toggle,\n    vertical,\n    widths,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(basic, 'basic'),\n    useKeyOnly(compact, 'compact'),\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(icon, 'icon'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(labeled, 'labeled'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(primary, 'primary'),\n    useKeyOnly(secondary, 'secondary'),\n    useKeyOnly(toggle, 'toggle'),\n    useKeyOnly(vertical, 'vertical'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useValueAndKey(floated, 'floated'),\n    useWidthProp(widths),\n    'buttons',\n    className,\n  )\n  const rest = getUnhandledProps(ButtonGroup, props)\n  const ElementType = getElementType(ButtonGroup, props)\n\n  if (_.isNil(buttons)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {childrenUtils.isNil(children) ? content : children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(buttons, button => Button.create(button))}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function ButtonGroup(props) {\n  const {\n    attached,\n    basic,\n    buttons,\n    children,\n    className,\n    color,\n    compact,\n    content,\n    floated,\n    fluid,\n    icon,\n    inverted,\n    labeled,\n    negative,\n    positive,\n    primary,\n    secondary,\n    size,\n    toggle,\n    vertical,\n    widths,\n  } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(basic, 'basic'),\n    useKeyOnly(compact, 'compact'),\n    useKeyOnly(fluid, 'fluid'),\n    useKeyOnly(icon, 'icon'),\n    useKeyOnly(inverted, 'inverted'),\n    useKeyOnly(labeled, 'labeled'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(primary, 'primary'),\n    useKeyOnly(secondary, 'secondary'),\n    useKeyOnly(toggle, 'toggle'),\n    useKeyOnly(vertical, 'vertical'),\n    useKeyOrValueAndKey(attached, 'attached'),\n    useValueAndKey(floated, 'floated'),\n    useWidthProp(widths),\n    'buttons',\n    className,\n  )\n  const rest = getUnhandledProps(ButtonGroup, props)\n  const ElementType = getElementType(ButtonGroup, props)\n\n  if (_.isNil(buttons)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {childrenUtils.isNil(children) ? content : children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(buttons, button => Button.create(button))}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "ButtonGroup", "(", "props", ")", "{", "const", "{", "attached", ",", "basic", ",", "buttons", ",", "children", ",", "className", ",", "color", ",", "compact", ",", "content", ",", "floated", ",", "fluid", ",", "icon", ",", "inverted", ",", "labeled", ",", "negative", ",", "positive", ",", "primary", ",", "secondary", ",", "size", ",", "toggle", ",", "vertical", ",", "widths", ",", "}", "=", "props", "const", "classes", "=", "cx", "(", "'ui'", ",", "color", ",", "size", ",", "useKeyOnly", "(", "basic", ",", "'basic'", ")", ",", "useKeyOnly", "(", "compact", ",", "'compact'", ")", ",", "useKeyOnly", "(", "fluid", ",", "'fluid'", ")", ",", "useKeyOnly", "(", "icon", ",", "'icon'", ")", ",", "useKeyOnly", "(", "inverted", ",", "'inverted'", ")", ",", "useKeyOnly", "(", "labeled", ",", "'labeled'", ")", ",", "useKeyOnly", "(", "negative", ",", "'negative'", ")", ",", "useKeyOnly", "(", "positive", ",", "'positive'", ")", ",", "useKeyOnly", "(", "primary", ",", "'primary'", ")", ",", "useKeyOnly", "(", "secondary", ",", "'secondary'", ")", ",", "useKeyOnly", "(", "toggle", ",", "'toggle'", ")", ",", "useKeyOnly", "(", "vertical", ",", "'vertical'", ")", ",", "useKeyOrValueAndKey", "(", "attached", ",", "'attached'", ")", ",", "useValueAndKey", "(", "floated", ",", "'floated'", ")", ",", "useWidthProp", "(", "widths", ")", ",", "'buttons'", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "ButtonGroup", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "ButtonGroup", ",", "props", ")", "if", "(", "_", ".", "isNil", "(", "buttons", ")", ")", "{", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "childrenUtils", ".", "isNil", "(", "children", ")", "?", "content", ":", "children", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "_", ".", "map", "(", "buttons", ",", "button", "=>", "Button", ".", "create", "(", "button", ")", ")", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "Buttons can be grouped.", "docstring_tokens": ["Buttons", "can", "be", "grouped", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Button/ButtonGroup.js#L22-L85", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "lib/reflect.js", "func_name": "", "original_string": "function(name) {\n    \"use strict\";\n    var trap = this.getTrap(\"deleteProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.deleteProperty(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    if (res === true) {\n      if (isSealed(name, this.target)) {\n        throw new TypeError(\"property '\"+name+\"' is non-configurable \"+\n                            \"and can't be deleted\");\n      }\n    }\n\n    return res;\n  }", "language": "javascript", "code": "function(name) {\n    \"use strict\";\n    var trap = this.getTrap(\"deleteProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.deleteProperty(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    if (res === true) {\n      if (isSealed(name, this.target)) {\n        throw new TypeError(\"property '\"+name+\"' is non-configurable \"+\n                            \"and can't be deleted\");\n      }\n    }\n\n    return res;\n  }", "code_tokens": ["function", "(", "name", ")", "{", "\"use strict\"", ";", "var", "trap", "=", "this", ".", "getTrap", "(", "\"deleteProperty\"", ")", ";", "if", "(", "trap", "===", "undefined", ")", "{", "// default forwarding behavior", "return", "Reflect", ".", "deleteProperty", "(", "this", ".", "target", ",", "name", ")", ";", "}", "name", "=", "String", "(", "name", ")", ";", "var", "res", "=", "trap", ".", "call", "(", "this", ".", "handler", ",", "this", ".", "target", ",", "name", ")", ";", "res", "=", "!", "!", "res", ";", "// coerce to Boolean", "if", "(", "res", "===", "true", ")", "{", "if", "(", "isSealed", "(", "name", ",", "this", ".", "target", ")", ")", "{", "throw", "new", "TypeError", "(", "\"property '\"", "+", "name", "+", "\"' is non-configurable \"", "+", "\"and can't be deleted\"", ")", ";", "}", "}", "return", "res", ";", "}"], "docstring": "If name denotes a sealed property, check whether handler rejects.", "docstring_tokens": ["If", "name", "denotes", "a", "sealed", "property", "check", "whether", "handler", "rejects", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/lib/reflect.js#L753-L773", "partition": "test"}
{"repo": "ax5ui/ax5ui-palette", "path": "dist/ax5palette.js", "func_name": "getMousePosition", "original_string": "function getMousePosition(e) {\n                var mouseObj = void 0,\n                    originalEvent = e.originalEvent ? e.originalEvent : e;\n                mouseObj = 'changedTouches' in originalEvent && originalEvent.changedTouches ? originalEvent.changedTouches[0] : originalEvent;\n                // clientX, Y \uc4f0\uba74 \uc2a4\ud06c\ub864\uc5d0\uc11c \ubb38\uc81c \ubc1c\uc0dd\n                return {\n                    clientX: mouseObj.pageX,\n                    clientY: mouseObj.pageY\n                };\n            }", "language": "javascript", "code": "function getMousePosition(e) {\n                var mouseObj = void 0,\n                    originalEvent = e.originalEvent ? e.originalEvent : e;\n                mouseObj = 'changedTouches' in originalEvent && originalEvent.changedTouches ? originalEvent.changedTouches[0] : originalEvent;\n                // clientX, Y \uc4f0\uba74 \uc2a4\ud06c\ub864\uc5d0\uc11c \ubb38\uc81c \ubc1c\uc0dd\n                return {\n                    clientX: mouseObj.pageX,\n                    clientY: mouseObj.pageY\n                };\n            }", "code_tokens": ["function", "getMousePosition", "(", "e", ")", "{", "var", "mouseObj", "=", "void", "0", ",", "originalEvent", "=", "e", ".", "originalEvent", "?", "e", ".", "originalEvent", ":", "e", ";", "mouseObj", "=", "'changedTouches'", "in", "originalEvent", "&&", "originalEvent", ".", "changedTouches", "?", "originalEvent", ".", "changedTouches", "[", "0", "]", ":", "originalEvent", ";", "// clientX, Y \uc4f0\uba74 \uc2a4\ud06c\ub864\uc5d0\uc11c \ubb38\uc81c \ubc1c\uc0dd", "return", "{", "clientX", ":", "mouseObj", ".", "pageX", ",", "clientY", ":", "mouseObj", ".", "pageY", "}", ";", "}"], "docstring": "get mouse position\n@param e\n@returns {{clientX, clientY}}", "docstring_tokens": ["get", "mouse", "position"], "sha": "8bd807434bed2406007237ce764087f1b4dead2b", "url": "https://github.com/ax5ui/ax5ui-palette/blob/8bd807434bed2406007237ce764087f1b4dead2b/dist/ax5palette.js#L85-L94", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "", "original_string": "function(type, fn) {\n    if (this.types.indexOf(type) === -1) {\n      this.types.push(type);\n    }\n    this.parsers[type] = fn.bind(this);\n    return this;\n  }", "language": "javascript", "code": "function(type, fn) {\n    if (this.types.indexOf(type) === -1) {\n      this.types.push(type);\n    }\n    this.parsers[type] = fn.bind(this);\n    return this;\n  }", "code_tokens": ["function", "(", "type", ",", "fn", ")", "{", "if", "(", "this", ".", "types", ".", "indexOf", "(", "type", ")", "===", "-", "1", ")", "{", "this", ".", "types", ".", "push", "(", "type", ")", ";", "}", "this", ".", "parsers", "[", "type", "]", "=", "fn", ".", "bind", "(", "this", ")", ";", "return", "this", ";", "}"], "docstring": "Set parser `name` with the given `fn`\n@param {String} `name`\n@param {Function} `fn`\n@api public", "docstring_tokens": ["Set", "parser", "name", "with", "the", "given", "fn"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L64767-L64773", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/migration/DatabaseMigrator.js", "func_name": "normalizeFetchBeforeObjectStores", "original_string": "function normalizeFetchBeforeObjectStores(objectStores) {\n  return objectStores.map((objectStore) => {\n    if (typeof objectStore === \"string\") {\n      return {\n        objectStore,\n        preprocessor: record => record\n      }\n    } else if (!objectStore.preprocessor) {\n      return {\n        objectStore: objectStore.objectStore,\n        preprocessor: record => record\n      }\n    } else {\n      return objectStore\n    }\n  })\n}", "language": "javascript", "code": "function normalizeFetchBeforeObjectStores(objectStores) {\n  return objectStores.map((objectStore) => {\n    if (typeof objectStore === \"string\") {\n      return {\n        objectStore,\n        preprocessor: record => record\n      }\n    } else if (!objectStore.preprocessor) {\n      return {\n        objectStore: objectStore.objectStore,\n        preprocessor: record => record\n      }\n    } else {\n      return objectStore\n    }\n  })\n}", "code_tokens": ["function", "normalizeFetchBeforeObjectStores", "(", "objectStores", ")", "{", "return", "objectStores", ".", "map", "(", "(", "objectStore", ")", "=>", "{", "if", "(", "typeof", "objectStore", "===", "\"string\"", ")", "{", "return", "{", "objectStore", ",", "preprocessor", ":", "record", "=>", "record", "}", "}", "else", "if", "(", "!", "objectStore", ".", "preprocessor", ")", "{", "return", "{", "objectStore", ":", "objectStore", ".", "objectStore", ",", "preprocessor", ":", "record", "=>", "record", "}", "}", "else", "{", "return", "objectStore", "}", "}", ")", "}"], "docstring": "Normalizes the provided array of object store fetch descriptors to process\nbefore upgrading the database schema.\n\n@param {(string|{objectStore: string, preprocessor: function(*, (number|string|Date|Array)): (*|UpgradedDatabaseSchema.SKIP_RECORD|UpgradedDatabaseSchema.DELETE_RECORD)=})[]} objectStores\nThe names of object stores that should have their records fetch or\n(possibly partially filled) object store fetch descriptors, mixed in\nan array.\n@return {{objectStore: string, preprocessor: function(*, (number|string|Date|Array)): (*|UpgradedDatabaseSchema.SKIP_RECORD|UpgradedDatabaseSchema.DELETE_RECORD)}[]}\nNormalized object store fetch descriptors.", "docstring_tokens": ["Normalizes", "the", "provided", "array", "of", "object", "store", "fetch", "descriptors", "to", "process", "before", "upgrading", "the", "database", "schema", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/migration/DatabaseMigrator.js#L198-L214", "partition": "test"}
{"repo": "kevinoid/travis-status", "path": "lib/invalid-slug-error.js", "func_name": "InvalidSlugError", "original_string": "function InvalidSlugError(message) {\n  if (!(this instanceof InvalidSlugError)) {\n    return new InvalidSlugError(message);\n  }\n\n  Error.captureStackTrace(this, InvalidSlugError);\n  // Like http://www.ecma-international.org/ecma-262/6.0/#sec-error-message\n  if (message !== undefined) {\n    Object.defineProperty(this, 'message', {\n      value: String(message),\n      configurable: true,\n      writable: true\n    });\n  }\n}", "language": "javascript", "code": "function InvalidSlugError(message) {\n  if (!(this instanceof InvalidSlugError)) {\n    return new InvalidSlugError(message);\n  }\n\n  Error.captureStackTrace(this, InvalidSlugError);\n  // Like http://www.ecma-international.org/ecma-262/6.0/#sec-error-message\n  if (message !== undefined) {\n    Object.defineProperty(this, 'message', {\n      value: String(message),\n      configurable: true,\n      writable: true\n    });\n  }\n}", "code_tokens": ["function", "InvalidSlugError", "(", "message", ")", "{", "if", "(", "!", "(", "this", "instanceof", "InvalidSlugError", ")", ")", "{", "return", "new", "InvalidSlugError", "(", "message", ")", ";", "}", "Error", ".", "captureStackTrace", "(", "this", ",", "InvalidSlugError", ")", ";", "// Like http://www.ecma-international.org/ecma-262/6.0/#sec-error-message", "if", "(", "message", "!==", "undefined", ")", "{", "Object", ".", "defineProperty", "(", "this", ",", "'message'", ",", "{", "value", ":", "String", "(", "message", ")", ",", "configurable", ":", "true", ",", "writable", ":", "true", "}", ")", ";", "}", "}"], "docstring": "Constructs an InvalidSlugError.\n\n@class Represents an error caused by a repository slug which does not\nfit the required format.\n@constructor\n@param {string=} message Human-readable description of the error.\n Note:  Only needed before https://github.com/eslint/eslint/pull/5398 eslint-disable-next-line consistent-return", "docstring_tokens": ["Constructs", "an", "InvalidSlugError", "."], "sha": "4432996e44c111046cbf0ca7b0054fe1a0a7032d", "url": "https://github.com/kevinoid/travis-status/blob/4432996e44c111046cbf0ca7b0054fe1a0a7032d/lib/invalid-slug-error.js#L19-L33", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/views/Advertisement/Advertisement.js", "func_name": "Advertisement", "original_string": "function Advertisement(props) {\n  const { centered, children, className, content, test, unit } = props\n\n  const classes = cx(\n    'ui',\n    unit,\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(test, 'test'),\n    'ad',\n    className,\n  )\n  const rest = getUnhandledProps(Advertisement, props)\n  const ElementType = getElementType(Advertisement, props)\n\n  return (\n    <ElementType {...rest} className={classes} data-text={test}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function Advertisement(props) {\n  const { centered, children, className, content, test, unit } = props\n\n  const classes = cx(\n    'ui',\n    unit,\n    useKeyOnly(centered, 'centered'),\n    useKeyOnly(test, 'test'),\n    'ad',\n    className,\n  )\n  const rest = getUnhandledProps(Advertisement, props)\n  const ElementType = getElementType(Advertisement, props)\n\n  return (\n    <ElementType {...rest} className={classes} data-text={test}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "Advertisement", "(", "props", ")", "{", "const", "{", "centered", ",", "children", ",", "className", ",", "content", ",", "test", ",", "unit", "}", "=", "props", "const", "classes", "=", "cx", "(", "'ui'", ",", "unit", ",", "useKeyOnly", "(", "centered", ",", "'centered'", ")", ",", "useKeyOnly", "(", "test", ",", "'test'", ")", ",", "'ad'", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "Advertisement", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "Advertisement", ",", "props", ")", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", "data-text", "=", "{", "test", "}", ">", "\n      ", "{", "childrenUtils", ".", "isNil", "(", "children", ")", "?", "content", ":", "children", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "An ad displays third-party promotional content.", "docstring_tokens": ["An", "ad", "displays", "third", "-", "party", "promotional", "content", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Advertisement/Advertisement.js#L16-L35", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "", "original_string": "function () {\n      if (this.error) {\n        return 1;\n      }\n      if (this.chunks.length === 1) {\n        this._prevProgress = Math.max(this._prevProgress, this.chunks[0].progress());\n        return this._prevProgress;\n      }\n      // Sum up progress across everything\n      var bytesLoaded = 0;\n      each(this.chunks, function (c) {\n        // get chunk progress relative to entire file\n        bytesLoaded += c.progress() * (c.endByte - c.startByte);\n      });\n      var percent = bytesLoaded / this.size;\n      // We don't want to lose percentages when an upload is paused\n      this._prevProgress = Math.max(this._prevProgress, percent > 0.9999 ? 1 : percent);\n      return this._prevProgress;\n    }", "language": "javascript", "code": "function () {\n      if (this.error) {\n        return 1;\n      }\n      if (this.chunks.length === 1) {\n        this._prevProgress = Math.max(this._prevProgress, this.chunks[0].progress());\n        return this._prevProgress;\n      }\n      // Sum up progress across everything\n      var bytesLoaded = 0;\n      each(this.chunks, function (c) {\n        // get chunk progress relative to entire file\n        bytesLoaded += c.progress() * (c.endByte - c.startByte);\n      });\n      var percent = bytesLoaded / this.size;\n      // We don't want to lose percentages when an upload is paused\n      this._prevProgress = Math.max(this._prevProgress, percent > 0.9999 ? 1 : percent);\n      return this._prevProgress;\n    }", "code_tokens": ["function", "(", ")", "{", "if", "(", "this", ".", "error", ")", "{", "return", "1", ";", "}", "if", "(", "this", ".", "chunks", ".", "length", "===", "1", ")", "{", "this", ".", "_prevProgress", "=", "Math", ".", "max", "(", "this", ".", "_prevProgress", ",", "this", ".", "chunks", "[", "0", "]", ".", "progress", "(", ")", ")", ";", "return", "this", ".", "_prevProgress", ";", "}", "// Sum up progress across everything", "var", "bytesLoaded", "=", "0", ";", "each", "(", "this", ".", "chunks", ",", "function", "(", "c", ")", "{", "// get chunk progress relative to entire file", "bytesLoaded", "+=", "c", ".", "progress", "(", ")", "*", "(", "c", ".", "endByte", "-", "c", ".", "startByte", ")", ";", "}", ")", ";", "var", "percent", "=", "bytesLoaded", "/", "this", ".", "size", ";", "// We don't want to lose percentages when an upload is paused", "this", ".", "_prevProgress", "=", "Math", ".", "max", "(", "this", ".", "_prevProgress", ",", "percent", ">", "0.9999", "?", "1", ":", "percent", ")", ";", "return", "this", ".", "_prevProgress", ";", "}"], "docstring": "Get current upload progress status\n@function\n@returns {number} from 0 to 1", "docstring_tokens": ["Get", "current", "upload", "progress", "status"], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L955-L973", "partition": "test"}
{"repo": "sportngin/ngin_client_node", "path": "src/sports/tiebreakPreference.js", "func_name": "scopeUrl", "original_string": "function scopeUrl(options, inst) {\n    options = _.extend(_.clone(options || {}), inst)\n    if (typeof options !== 'object' && (!options.tournament_id || !options.flight_id))\n      throw new Error('tournament_id or flight_id required to make tibreak preference api calls')\n\n    var url = ''\n    if (options.tournament_id) {\n      url += ngin.Tournament.urlRoot() + '/' + options.tournament_id\n    } else if (options.flight_id) {\n      url += ngin.Flight.urlRoot() + '/' + options.flight_id\n    }\n    return url + TiebreakPreference.urlRoot()\n  }", "language": "javascript", "code": "function scopeUrl(options, inst) {\n    options = _.extend(_.clone(options || {}), inst)\n    if (typeof options !== 'object' && (!options.tournament_id || !options.flight_id))\n      throw new Error('tournament_id or flight_id required to make tibreak preference api calls')\n\n    var url = ''\n    if (options.tournament_id) {\n      url += ngin.Tournament.urlRoot() + '/' + options.tournament_id\n    } else if (options.flight_id) {\n      url += ngin.Flight.urlRoot() + '/' + options.flight_id\n    }\n    return url + TiebreakPreference.urlRoot()\n  }", "code_tokens": ["function", "scopeUrl", "(", "options", ",", "inst", ")", "{", "options", "=", "_", ".", "extend", "(", "_", ".", "clone", "(", "options", "||", "{", "}", ")", ",", "inst", ")", "if", "(", "typeof", "options", "!==", "'object'", "&&", "(", "!", "options", ".", "tournament_id", "||", "!", "options", ".", "flight_id", ")", ")", "throw", "new", "Error", "(", "'tournament_id or flight_id required to make tibreak preference api calls'", ")", "var", "url", "=", "''", "if", "(", "options", ".", "tournament_id", ")", "{", "url", "+=", "ngin", ".", "Tournament", ".", "urlRoot", "(", ")", "+", "'/'", "+", "options", ".", "tournament_id", "}", "else", "if", "(", "options", ".", "flight_id", ")", "{", "url", "+=", "ngin", ".", "Flight", ".", "urlRoot", "(", ")", "+", "'/'", "+", "options", ".", "flight_id", "}", "return", "url", "+", "TiebreakPreference", ".", "urlRoot", "(", ")", "}"], "docstring": "Scopes the url to the tournament, league, or flight\n\n@param {Object} options\n@returns {String}\n@api public", "docstring_tokens": ["Scopes", "the", "url", "to", "the", "tournament", "league", "or", "flight"], "sha": "dafed7f3b86e86b01f7d5fd707d4a8d608258fe9", "url": "https://github.com/sportngin/ngin_client_node/blob/dafed7f3b86e86b01f7d5fd707d4a8d608258fe9/src/sports/tiebreakPreference.js#L19-L31", "partition": "test"}
{"repo": "LivelyKernel/lively.source-transform", "path": "capturing.js", "func_name": "generateUniqueName", "original_string": "function generateUniqueName(declaredNames, hint) {\n  var unique = hint, n = 1;\n  while (declaredNames.indexOf(unique) > -1) {\n    if (n > 1000) throw new Error(\"Endless loop searching for unique variable \" + unique);\n    unique = unique.replace(/_[0-9]+$|$/, \"_\" + (++n));\n  }\n  return unique;\n}", "language": "javascript", "code": "function generateUniqueName(declaredNames, hint) {\n  var unique = hint, n = 1;\n  while (declaredNames.indexOf(unique) > -1) {\n    if (n > 1000) throw new Error(\"Endless loop searching for unique variable \" + unique);\n    unique = unique.replace(/_[0-9]+$|$/, \"_\" + (++n));\n  }\n  return unique;\n}", "code_tokens": ["function", "generateUniqueName", "(", "declaredNames", ",", "hint", ")", "{", "var", "unique", "=", "hint", ",", "n", "=", "1", ";", "while", "(", "declaredNames", ".", "indexOf", "(", "unique", ")", ">", "-", "1", ")", "{", "if", "(", "n", ">", "1000", ")", "throw", "new", "Error", "(", "\"Endless loop searching for unique variable \"", "+", "unique", ")", ";", "unique", "=", "unique", ".", "replace", "(", "/", "_[0-9]+$|$", "/", ",", "\"_\"", "+", "(", "++", "n", ")", ")", ";", "}", "return", "unique", ";", "}"], "docstring": "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- naming -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-", "docstring_tokens": ["-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "naming", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-", "=", "-"], "sha": "4827c85699e6151b592cdab3a9638bbcb48b45aa", "url": "https://github.com/LivelyKernel/lively.source-transform/blob/4827c85699e6151b592cdab3a9638bbcb48b45aa/capturing.js#L377-L384", "partition": "test"}
{"repo": "CSNW/d3.compose", "path": "gulpfile.js", "func_name": "series", "original_string": "function series() {\n  const tasks = Array.prototype.slice.call(arguments);\n  var fn = cb => cb();\n\n  if (typeof tasks[tasks.length - 1] === 'function')\n    fn = tasks.pop();\n\n  return (cb) => {\n    const tasks_with_cb = tasks.concat([(err) => {\n      if (err) return cb(err);\n      fn(cb);\n    }]);\n\n    runSequence.apply(this, tasks_with_cb);\n  }\n}", "language": "javascript", "code": "function series() {\n  const tasks = Array.prototype.slice.call(arguments);\n  var fn = cb => cb();\n\n  if (typeof tasks[tasks.length - 1] === 'function')\n    fn = tasks.pop();\n\n  return (cb) => {\n    const tasks_with_cb = tasks.concat([(err) => {\n      if (err) return cb(err);\n      fn(cb);\n    }]);\n\n    runSequence.apply(this, tasks_with_cb);\n  }\n}", "code_tokens": ["function", "series", "(", ")", "{", "const", "tasks", "=", "Array", ".", "prototype", ".", "slice", ".", "call", "(", "arguments", ")", ";", "var", "fn", "=", "cb", "=>", "cb", "(", ")", ";", "if", "(", "typeof", "tasks", "[", "tasks", ".", "length", "-", "1", "]", "===", "'function'", ")", "fn", "=", "tasks", ".", "pop", "(", ")", ";", "return", "(", "cb", ")", "=>", "{", "const", "tasks_with_cb", "=", "tasks", ".", "concat", "(", "[", "(", "err", ")", "=>", "{", "if", "(", "err", ")", "return", "cb", "(", "err", ")", ";", "fn", "(", "cb", ")", ";", "}", "]", ")", ";", "runSequence", ".", "apply", "(", "this", ",", "tasks_with_cb", ")", ";", "}", "}"], "docstring": "Approximate gulp 4.0 series\n\n@param {...String} ...tasks\n@param {Function} [fn] Function to call at end of series\n@return {Function}", "docstring_tokens": ["Approximate", "gulp", "4", ".", "0", "series"], "sha": "28df23d5dfb4d3ec1bee7d58bc797f175a983c75", "url": "https://github.com/CSNW/d3.compose/blob/28df23d5dfb4d3ec1bee7d58bc797f175a983c75/gulpfile.js#L139-L154", "partition": "test"}
{"repo": "nearform/nscale-kernel", "path": "lib/sysrev/sysrev.js", "func_name": "", "original_string": "function(systemId, env, cb) {\n    var repoPath = _meta.repoPath(systemId);\n    var tagName = baseTag + env;\n    var editsTagName = editsTag + env;\n\n    ngit.Repository.open(repoPath, function(err, repo) {\n      if (err) { return cb(err); }\n\n      ngit.Reference.nameToId(repo, tagName, function(err, head) {\n        if (err && (!err.message || err.message.indexOf('not found') === -1)) { return cb(err); }\n        if (head) {\n          cb(null, head.toString());\n        }\n        else {\n          ngit.Reference.nameToId(repo, editsTagName, function(err) {\n            if (err) { return cb(err); }\n            cb(null, EDITS);\n          });\n        }\n      });\n    });\n  }", "language": "javascript", "code": "function(systemId, env, cb) {\n    var repoPath = _meta.repoPath(systemId);\n    var tagName = baseTag + env;\n    var editsTagName = editsTag + env;\n\n    ngit.Repository.open(repoPath, function(err, repo) {\n      if (err) { return cb(err); }\n\n      ngit.Reference.nameToId(repo, tagName, function(err, head) {\n        if (err && (!err.message || err.message.indexOf('not found') === -1)) { return cb(err); }\n        if (head) {\n          cb(null, head.toString());\n        }\n        else {\n          ngit.Reference.nameToId(repo, editsTagName, function(err) {\n            if (err) { return cb(err); }\n            cb(null, EDITS);\n          });\n        }\n      });\n    });\n  }", "code_tokens": ["function", "(", "systemId", ",", "env", ",", "cb", ")", "{", "var", "repoPath", "=", "_meta", ".", "repoPath", "(", "systemId", ")", ";", "var", "tagName", "=", "baseTag", "+", "env", ";", "var", "editsTagName", "=", "editsTag", "+", "env", ";", "ngit", ".", "Repository", ".", "open", "(", "repoPath", ",", "function", "(", "err", ",", "repo", ")", "{", "if", "(", "err", ")", "{", "return", "cb", "(", "err", ")", ";", "}", "ngit", ".", "Reference", ".", "nameToId", "(", "repo", ",", "tagName", ",", "function", "(", "err", ",", "head", ")", "{", "if", "(", "err", "&&", "(", "!", "err", ".", "message", "||", "err", ".", "message", ".", "indexOf", "(", "'not found'", ")", "===", "-", "1", ")", ")", "{", "return", "cb", "(", "err", ")", ";", "}", "if", "(", "head", ")", "{", "cb", "(", "null", ",", "head", ".", "toString", "(", ")", ")", ";", "}", "else", "{", "ngit", ".", "Reference", ".", "nameToId", "(", "repo", ",", "editsTagName", ",", "function", "(", "err", ")", "{", "if", "(", "err", ")", "{", "return", "cb", "(", "err", ")", ";", "}", "cb", "(", "null", ",", "EDITS", ")", ";", "}", ")", ";", "}", "}", ")", ";", "}", ")", ";", "}"], "docstring": "get the currently deployed revision", "docstring_tokens": ["get", "the", "currently", "deployed", "revision"], "sha": "5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3", "url": "https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/sysrev/sysrev.js#L391-L412", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/migration/DatabaseVersionMigrator.js", "func_name": "upgradeSchema", "original_string": "function upgradeSchema(nativeDatabase, nativeTransaction, descriptors) {\n  let objectStoreNames = Array.from(nativeDatabase.objectStoreNames)\n  let newObjectStoreNames = descriptors.map((objectStore) => {\n    return objectStore.name\n  })\n  objectStoreNames.forEach((objectStoreName) => {\n    if (newObjectStoreNames.indexOf(objectStoreName) === -1) {\n      nativeDatabase.deleteObjectStore(objectStoreName)\n    }\n  })\n\n  descriptors.forEach((objectStoreDescriptor) => {\n    let objectStoreName = objectStoreDescriptor.name\n    let nativeObjectStore = objectStoreNames.indexOf(objectStoreName) > -1 ?\n        nativeTransaction.objectStore(objectStoreName) : null\n\n    let objectStoreMigrator = new ObjectStoreMigrator(nativeDatabase,\n        nativeObjectStore, objectStoreDescriptor)\n    objectStoreMigrator.executeMigration()\n  })\n}", "language": "javascript", "code": "function upgradeSchema(nativeDatabase, nativeTransaction, descriptors) {\n  let objectStoreNames = Array.from(nativeDatabase.objectStoreNames)\n  let newObjectStoreNames = descriptors.map((objectStore) => {\n    return objectStore.name\n  })\n  objectStoreNames.forEach((objectStoreName) => {\n    if (newObjectStoreNames.indexOf(objectStoreName) === -1) {\n      nativeDatabase.deleteObjectStore(objectStoreName)\n    }\n  })\n\n  descriptors.forEach((objectStoreDescriptor) => {\n    let objectStoreName = objectStoreDescriptor.name\n    let nativeObjectStore = objectStoreNames.indexOf(objectStoreName) > -1 ?\n        nativeTransaction.objectStore(objectStoreName) : null\n\n    let objectStoreMigrator = new ObjectStoreMigrator(nativeDatabase,\n        nativeObjectStore, objectStoreDescriptor)\n    objectStoreMigrator.executeMigration()\n  })\n}", "code_tokens": ["function", "upgradeSchema", "(", "nativeDatabase", ",", "nativeTransaction", ",", "descriptors", ")", "{", "let", "objectStoreNames", "=", "Array", ".", "from", "(", "nativeDatabase", ".", "objectStoreNames", ")", "let", "newObjectStoreNames", "=", "descriptors", ".", "map", "(", "(", "objectStore", ")", "=>", "{", "return", "objectStore", ".", "name", "}", ")", "objectStoreNames", ".", "forEach", "(", "(", "objectStoreName", ")", "=>", "{", "if", "(", "newObjectStoreNames", ".", "indexOf", "(", "objectStoreName", ")", "===", "-", "1", ")", "{", "nativeDatabase", ".", "deleteObjectStore", "(", "objectStoreName", ")", "}", "}", ")", "descriptors", ".", "forEach", "(", "(", "objectStoreDescriptor", ")", "=>", "{", "let", "objectStoreName", "=", "objectStoreDescriptor", ".", "name", "let", "nativeObjectStore", "=", "objectStoreNames", ".", "indexOf", "(", "objectStoreName", ")", ">", "-", "1", "?", "nativeTransaction", ".", "objectStore", "(", "objectStoreName", ")", ":", "null", "let", "objectStoreMigrator", "=", "new", "ObjectStoreMigrator", "(", "nativeDatabase", ",", "nativeObjectStore", ",", "objectStoreDescriptor", ")", "objectStoreMigrator", ".", "executeMigration", "(", ")", "}", ")", "}"], "docstring": "Updates the schema of the provided Indexed DB database to the schema\nspecified by the provided schema descriptors.\n\n@param {IDBDatabase} nativeDatabase The native Indexed DB database being\nmigrated.\n@param {IDBTransaction} nativeTransaction The native {@code versionchange}\ntransaction.\n@param {((DatabaseSchema|UpgradedDatabaseSchema))[]} descriptors Schema\ndescriptor of the version to which the database is to be upgraded.", "docstring_tokens": ["Updates", "the", "schema", "of", "the", "provided", "Indexed", "DB", "database", "to", "the", "schema", "specified", "by", "the", "provided", "schema", "descriptors", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/migration/DatabaseVersionMigrator.js#L97-L117", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "emitTempVariableAssignment", "original_string": "function emitTempVariableAssignment(expression, canDefineTempVariablesInPlace, shouldEmitCommaBeforeAssignment) {\n                var identifier = createTempVariable(0 /* Auto */);\n                if (!canDefineTempVariablesInPlace) {\n                    recordTempDeclaration(identifier);\n                }\n                emitAssignment(identifier, expression, shouldEmitCommaBeforeAssignment);\n                return identifier;\n            }", "language": "javascript", "code": "function emitTempVariableAssignment(expression, canDefineTempVariablesInPlace, shouldEmitCommaBeforeAssignment) {\n                var identifier = createTempVariable(0 /* Auto */);\n                if (!canDefineTempVariablesInPlace) {\n                    recordTempDeclaration(identifier);\n                }\n                emitAssignment(identifier, expression, shouldEmitCommaBeforeAssignment);\n                return identifier;\n            }", "code_tokens": ["function", "emitTempVariableAssignment", "(", "expression", ",", "canDefineTempVariablesInPlace", ",", "shouldEmitCommaBeforeAssignment", ")", "{", "var", "identifier", "=", "createTempVariable", "(", "0", "/* Auto */", ")", ";", "if", "(", "!", "canDefineTempVariablesInPlace", ")", "{", "recordTempDeclaration", "(", "identifier", ")", ";", "}", "emitAssignment", "(", "identifier", ",", "expression", ",", "shouldEmitCommaBeforeAssignment", ")", ";", "return", "identifier", ";", "}"], "docstring": "Create temporary variable, emit an assignment of the variable the given expression\n@param expression an expression to assign to the newly created temporary variable\n@param canDefineTempVariablesInPlace a boolean indicating whether you can define the temporary variable at an assignment location\n@param shouldEmitCommaBeforeAssignment a boolean indicating whether an assignment should prefix with comma", "docstring_tokens": ["Create", "temporary", "variable", "emit", "an", "assignment", "of", "the", "variable", "the", "given", "expression"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L32331-L32338", "partition": "test"}
{"repo": "DeadAlready/node-easy-pipe", "path": "lib/pipeStream.js", "func_name": "addEventHandlers", "original_string": "function addEventHandlers(self){\n    self.on('error',function(d){\n        var fn = self._error;\n        self._cleanUp();\n        if(fn){\n            fn('pipeline[' + self._nr + ']:\"' + self._command + '\" failed with: ' + d.toString());\n        }\n    });\n}", "language": "javascript", "code": "function addEventHandlers(self){\n    self.on('error',function(d){\n        var fn = self._error;\n        self._cleanUp();\n        if(fn){\n            fn('pipeline[' + self._nr + ']:\"' + self._command + '\" failed with: ' + d.toString());\n        }\n    });\n}", "code_tokens": ["function", "addEventHandlers", "(", "self", ")", "{", "self", ".", "on", "(", "'error'", ",", "function", "(", "d", ")", "{", "var", "fn", "=", "self", ".", "_error", ";", "self", ".", "_cleanUp", "(", ")", ";", "if", "(", "fn", ")", "{", "fn", "(", "'pipeline['", "+", "self", ".", "_nr", "+", "']:\"'", "+", "self", ".", "_command", "+", "'\" failed with: '", "+", "d", ".", "toString", "(", ")", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Function for adding internal event handlers\n@param {EventEmitter} self", "docstring_tokens": ["Function", "for", "adding", "internal", "event", "handlers"], "sha": "e739e052494cd6be96c95bc65e34442042243e7d", "url": "https://github.com/DeadAlready/node-easy-pipe/blob/e739e052494cd6be96c95bc65e34442042243e7d/lib/pipeStream.js#L232-L240", "partition": "test"}
{"repo": "unfoldingWord-dev/node-resource-container", "path": "lib/main.js", "func_name": "containerSlug", "original_string": "function containerSlug(language_slug, project_slug, resource_slug) {\n    if(!language_slug || !project_slug || !resource_slug) throw new Error('Invalid resource container slug parameters');\n    return language_slug\n        + '_' + project_slug\n        + '_' + resource_slug;\n}", "language": "javascript", "code": "function containerSlug(language_slug, project_slug, resource_slug) {\n    if(!language_slug || !project_slug || !resource_slug) throw new Error('Invalid resource container slug parameters');\n    return language_slug\n        + '_' + project_slug\n        + '_' + resource_slug;\n}", "code_tokens": ["function", "containerSlug", "(", "language_slug", ",", "project_slug", ",", "resource_slug", ")", "{", "if", "(", "!", "language_slug", "||", "!", "project_slug", "||", "!", "resource_slug", ")", "throw", "new", "Error", "(", "'Invalid resource container slug parameters'", ")", ";", "return", "language_slug", "+", "'_'", "+", "project_slug", "+", "'_'", "+", "resource_slug", ";", "}"], "docstring": "Returns a properly formatted container slug.\n\n@param language_slug {string}\n@param project_slug {string}\n@param resource_slug {string}\n@returns {string}", "docstring_tokens": ["Returns", "a", "properly", "formatted", "container", "slug", "."], "sha": "20c4b7bfd2fa3f397ee7e0e743567822912c305b", "url": "https://github.com/unfoldingWord-dev/node-resource-container/blob/20c4b7bfd2fa3f397ee7e0e743567822912c305b/lib/main.js#L33-L38", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "checkDecorators", "original_string": "function checkDecorators(node) {\n            if (!node.decorators) {\n                return;\n            }\n            // skip this check for nodes that cannot have decorators. These should have already had an error reported by\n            // checkGrammarDecorators.\n            if (!ts.nodeCanBeDecorated(node)) {\n                return;\n            }\n            if (!compilerOptions.experimentalDecorators) {\n                error(node, ts.Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Specify_experimentalDecorators_to_remove_this_warning);\n            }\n            if (compilerOptions.emitDecoratorMetadata) {\n                // we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.\n                switch (node.kind) {\n                    case 214 /* ClassDeclaration */:\n                        var constructor = ts.getFirstConstructorWithBody(node);\n                        if (constructor) {\n                            checkParameterTypeAnnotationsAsExpressions(constructor);\n                        }\n                        break;\n                    case 143 /* MethodDeclaration */:\n                        checkParameterTypeAnnotationsAsExpressions(node);\n                    // fall-through\n                    case 146 /* SetAccessor */:\n                    case 145 /* GetAccessor */:\n                    case 141 /* PropertyDeclaration */:\n                    case 138 /* Parameter */:\n                        checkTypeAnnotationAsExpression(node);\n                        break;\n                }\n            }\n            emitDecorate = true;\n            if (node.kind === 138 /* Parameter */) {\n                emitParam = true;\n            }\n            ts.forEach(node.decorators, checkDecorator);\n        }", "language": "javascript", "code": "function checkDecorators(node) {\n            if (!node.decorators) {\n                return;\n            }\n            // skip this check for nodes that cannot have decorators. These should have already had an error reported by\n            // checkGrammarDecorators.\n            if (!ts.nodeCanBeDecorated(node)) {\n                return;\n            }\n            if (!compilerOptions.experimentalDecorators) {\n                error(node, ts.Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Specify_experimentalDecorators_to_remove_this_warning);\n            }\n            if (compilerOptions.emitDecoratorMetadata) {\n                // we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.\n                switch (node.kind) {\n                    case 214 /* ClassDeclaration */:\n                        var constructor = ts.getFirstConstructorWithBody(node);\n                        if (constructor) {\n                            checkParameterTypeAnnotationsAsExpressions(constructor);\n                        }\n                        break;\n                    case 143 /* MethodDeclaration */:\n                        checkParameterTypeAnnotationsAsExpressions(node);\n                    // fall-through\n                    case 146 /* SetAccessor */:\n                    case 145 /* GetAccessor */:\n                    case 141 /* PropertyDeclaration */:\n                    case 138 /* Parameter */:\n                        checkTypeAnnotationAsExpression(node);\n                        break;\n                }\n            }\n            emitDecorate = true;\n            if (node.kind === 138 /* Parameter */) {\n                emitParam = true;\n            }\n            ts.forEach(node.decorators, checkDecorator);\n        }", "code_tokens": ["function", "checkDecorators", "(", "node", ")", "{", "if", "(", "!", "node", ".", "decorators", ")", "{", "return", ";", "}", "// skip this check for nodes that cannot have decorators. These should have already had an error reported by", "// checkGrammarDecorators.", "if", "(", "!", "ts", ".", "nodeCanBeDecorated", "(", "node", ")", ")", "{", "return", ";", "}", "if", "(", "!", "compilerOptions", ".", "experimentalDecorators", ")", "{", "error", "(", "node", ",", "ts", ".", "Diagnostics", ".", "Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Specify_experimentalDecorators_to_remove_this_warning", ")", ";", "}", "if", "(", "compilerOptions", ".", "emitDecoratorMetadata", ")", "{", "// we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.", "switch", "(", "node", ".", "kind", ")", "{", "case", "214", "/* ClassDeclaration */", ":", "var", "constructor", "=", "ts", ".", "getFirstConstructorWithBody", "(", "node", ")", ";", "if", "(", "constructor", ")", "{", "checkParameterTypeAnnotationsAsExpressions", "(", "constructor", ")", ";", "}", "break", ";", "case", "143", "/* MethodDeclaration */", ":", "checkParameterTypeAnnotationsAsExpressions", "(", "node", ")", ";", "// fall-through", "case", "146", "/* SetAccessor */", ":", "case", "145", "/* GetAccessor */", ":", "case", "141", "/* PropertyDeclaration */", ":", "case", "138", "/* Parameter */", ":", "checkTypeAnnotationAsExpression", "(", "node", ")", ";", "break", ";", "}", "}", "emitDecorate", "=", "true", ";", "if", "(", "node", ".", "kind", "===", "138", "/* Parameter */", ")", "{", "emitParam", "=", "true", ";", "}", "ts", ".", "forEach", "(", "node", ".", "decorators", ",", "checkDecorator", ")", ";", "}"], "docstring": "Check the decorators of a node", "docstring_tokens": ["Check", "the", "decorators", "of", "a", "node"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L23914-L23951", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/util/Collection.js", "func_name": "", "original_string": "function(item) {\n        if (this.dirtyIndices) {\n            this.updateIndices();\n        }\n\n        var index = item ? this.indices[this.getKey(item)] : -1;\n        return (index === undefined) ? -1 : index;\n    }", "language": "javascript", "code": "function(item) {\n        if (this.dirtyIndices) {\n            this.updateIndices();\n        }\n\n        var index = item ? this.indices[this.getKey(item)] : -1;\n        return (index === undefined) ? -1 : index;\n    }", "code_tokens": ["function", "(", "item", ")", "{", "if", "(", "this", ".", "dirtyIndices", ")", "{", "this", ".", "updateIndices", "(", ")", ";", "}", "var", "index", "=", "item", "?", "this", ".", "indices", "[", "this", ".", "getKey", "(", "item", ")", "]", ":", "-", "1", ";", "return", "(", "index", "===", "undefined", ")", "?", "-", "1", ":", "index", ";", "}"], "docstring": "Returns index within the collection of the passed Object.\n@param {Object} item The item to find the index of.\n@return {Number} Index of the item. Returns -1 if not found.", "docstring_tokens": ["Returns", "index", "within", "the", "collection", "of", "the", "passed", "Object", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/util/Collection.js#L865-L872", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/utils.js", "func_name": "arrayIterator", "original_string": "function arrayIterator (arr) {\n  let index = 0;\n  return { next : function () {\n    if (index >= arr.length) {\n      return {done: true};\n    }\n    return {value: arr[index++], done: false };\n  }};\n}", "language": "javascript", "code": "function arrayIterator (arr) {\n  let index = 0;\n  return { next : function () {\n    if (index >= arr.length) {\n      return {done: true};\n    }\n    return {value: arr[index++], done: false };\n  }};\n}", "code_tokens": ["function", "arrayIterator", "(", "arr", ")", "{", "let", "index", "=", "0", ";", "return", "{", "next", ":", "function", "(", ")", "{", "if", "(", "index", ">=", "arr", ".", "length", ")", "{", "return", "{", "done", ":", "true", "}", ";", "}", "return", "{", "value", ":", "arr", "[", "index", "++", "]", ",", "done", ":", "false", "}", ";", "}", "}", ";", "}"], "docstring": "Uses the iterator protocol to go through the items of the Array\n@param arr\n@returns {{next: function}}", "docstring_tokens": ["Uses", "the", "iterator", "protocol", "to", "go", "through", "the", "items", "of", "the", "Array"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/utils.js#L223-L231", "partition": "test"}
{"repo": "AndreasMadsen/article", "path": "lib/helpers-dom.js", "func_name": "buildAttributeMatcher", "original_string": "function buildAttributeMatcher(match) {\n  var keys = Object.keys(match);\n  var jskey, i, l;\n\n  var transform = '';\n  var bool = '';\n\n  transform = 'transform = {\\n';\n  for (i = 0, l = keys.length; i < l; i++) {\n    jskey = JSON.stringify(keys[i]);\n\n    transform += '  ' + jskey + ': attr.hasOwnProperty(' + jskey + ') ? attr[' + jskey + '].toLowerCase() : false';\n    if (i !== l - 1) transform += ',';\n    transform += '\\n';\n  }\n  transform += '};\\n';\n\n  bool = 'return !!(';\n  for (i = 0, l = keys.length; i < l; i++) {\n    jskey = JSON.stringify(keys[i]);\n\n    if (i > 0) bool += '    ||    ';\n    bool += ' ( transform[' + jskey + ']';\n\n    if (Array.isArray(match[keys[i]])) {\n      bool += ' && ( ';\n\n      for (var j = 0, s = match[keys[i]].length; j < s; j++) {\n        if (j > 0) bool += ' || ';\n\n        if (typeof match[keys[i]][j] === 'string') {\n          bool += 'transform[' + jskey + '] === \\'' + match[keys[i]][j].toLowerCase() + '\\'';\n        } else if (util.isRegExp(match[keys[i]][j])) {\n          bool += 'match[' + jskey + '][' + j + '].test(transform[' + jskey + '])';\n        }\n      }\n\n      bool += ' )';\n    }\n\n    bool += ' ) \\n';\n  }\n\n  bool += '         );';\n\n  var anonymous = new Function('attr', 'match', transform + '\\n' + bool);\n  return function (attr) {\n    return anonymous(attr, match);\n  };\n}", "language": "javascript", "code": "function buildAttributeMatcher(match) {\n  var keys = Object.keys(match);\n  var jskey, i, l;\n\n  var transform = '';\n  var bool = '';\n\n  transform = 'transform = {\\n';\n  for (i = 0, l = keys.length; i < l; i++) {\n    jskey = JSON.stringify(keys[i]);\n\n    transform += '  ' + jskey + ': attr.hasOwnProperty(' + jskey + ') ? attr[' + jskey + '].toLowerCase() : false';\n    if (i !== l - 1) transform += ',';\n    transform += '\\n';\n  }\n  transform += '};\\n';\n\n  bool = 'return !!(';\n  for (i = 0, l = keys.length; i < l; i++) {\n    jskey = JSON.stringify(keys[i]);\n\n    if (i > 0) bool += '    ||    ';\n    bool += ' ( transform[' + jskey + ']';\n\n    if (Array.isArray(match[keys[i]])) {\n      bool += ' && ( ';\n\n      for (var j = 0, s = match[keys[i]].length; j < s; j++) {\n        if (j > 0) bool += ' || ';\n\n        if (typeof match[keys[i]][j] === 'string') {\n          bool += 'transform[' + jskey + '] === \\'' + match[keys[i]][j].toLowerCase() + '\\'';\n        } else if (util.isRegExp(match[keys[i]][j])) {\n          bool += 'match[' + jskey + '][' + j + '].test(transform[' + jskey + '])';\n        }\n      }\n\n      bool += ' )';\n    }\n\n    bool += ' ) \\n';\n  }\n\n  bool += '         );';\n\n  var anonymous = new Function('attr', 'match', transform + '\\n' + bool);\n  return function (attr) {\n    return anonymous(attr, match);\n  };\n}", "code_tokens": ["function", "buildAttributeMatcher", "(", "match", ")", "{", "var", "keys", "=", "Object", ".", "keys", "(", "match", ")", ";", "var", "jskey", ",", "i", ",", "l", ";", "var", "transform", "=", "''", ";", "var", "bool", "=", "''", ";", "transform", "=", "'transform = {\\n'", ";", "for", "(", "i", "=", "0", ",", "l", "=", "keys", ".", "length", ";", "i", "<", "l", ";", "i", "++", ")", "{", "jskey", "=", "JSON", ".", "stringify", "(", "keys", "[", "i", "]", ")", ";", "transform", "+=", "'  '", "+", "jskey", "+", "': attr.hasOwnProperty('", "+", "jskey", "+", "') ? attr['", "+", "jskey", "+", "'].toLowerCase() : false'", ";", "if", "(", "i", "!==", "l", "-", "1", ")", "transform", "+=", "','", ";", "transform", "+=", "'\\n'", ";", "}", "transform", "+=", "'};\\n'", ";", "bool", "=", "'return !!('", ";", "for", "(", "i", "=", "0", ",", "l", "=", "keys", ".", "length", ";", "i", "<", "l", ";", "i", "++", ")", "{", "jskey", "=", "JSON", ".", "stringify", "(", "keys", "[", "i", "]", ")", ";", "if", "(", "i", ">", "0", ")", "bool", "+=", "'    ||    '", ";", "bool", "+=", "' ( transform['", "+", "jskey", "+", "']'", ";", "if", "(", "Array", ".", "isArray", "(", "match", "[", "keys", "[", "i", "]", "]", ")", ")", "{", "bool", "+=", "' && ( '", ";", "for", "(", "var", "j", "=", "0", ",", "s", "=", "match", "[", "keys", "[", "i", "]", "]", ".", "length", ";", "j", "<", "s", ";", "j", "++", ")", "{", "if", "(", "j", ">", "0", ")", "bool", "+=", "' || '", ";", "if", "(", "typeof", "match", "[", "keys", "[", "i", "]", "]", "[", "j", "]", "===", "'string'", ")", "{", "bool", "+=", "'transform['", "+", "jskey", "+", "'] === \\''", "+", "match", "[", "keys", "[", "i", "]", "]", "[", "j", "]", ".", "toLowerCase", "(", ")", "+", "'\\''", ";", "}", "else", "if", "(", "util", ".", "isRegExp", "(", "match", "[", "keys", "[", "i", "]", "]", "[", "j", "]", ")", ")", "{", "bool", "+=", "'match['", "+", "jskey", "+", "']['", "+", "j", "+", "'].test(transform['", "+", "jskey", "+", "'])'", ";", "}", "}", "bool", "+=", "' )'", ";", "}", "bool", "+=", "' ) \\n'", ";", "}", "bool", "+=", "'         );'", ";", "var", "anonymous", "=", "new", "Function", "(", "'attr'", ",", "'match'", ",", "transform", "+", "'\\n'", "+", "bool", ")", ";", "return", "function", "(", "attr", ")", "{", "return", "anonymous", "(", "attr", ",", "match", ")", ";", "}", ";", "}"], "docstring": "Builds and attribute matching function, complexity is for uncomfirmed performace sake", "docstring_tokens": ["Builds", "and", "attribute", "matching", "function", "complexity", "is", "for", "uncomfirmed", "performace", "sake"], "sha": "8cf3777fc9dc72d041214faae1b8d65d37a7d134", "url": "https://github.com/AndreasMadsen/article/blob/8cf3777fc9dc72d041214faae1b8d65d37a7d134/lib/helpers-dom.js#L60-L109", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "exponential", "original_string": "function exponential(str, options, fn) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = null;\n  }\n\n  var opts = options || {};\n  var esc = '__ESC_EXP__';\n  var exp = 0;\n  var res;\n\n  var parts = str.split('{,}');\n  if (opts.nodupes) {\n    return fn(parts.join(''), opts);\n  }\n\n  exp = parts.length - 1;\n  res = fn(parts.join(esc), opts);\n  var len = res.length;\n  var arr = [];\n  var i = 0;\n\n  while (len--) {\n    var ele = res[i++];\n    var idx = ele.indexOf(esc);\n\n    if (idx === -1) {\n      arr.push(ele);\n\n    } else {\n      ele = ele.split('__ESC_EXP__').join('');\n      if (!!ele && opts.nodupes !== false) {\n        arr.push(ele);\n\n      } else {\n        var num = Math.pow(2, exp);\n        arr.push.apply(arr, repeat(ele, num));\n      }\n    }\n  }\n  return arr;\n}", "language": "javascript", "code": "function exponential(str, options, fn) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = null;\n  }\n\n  var opts = options || {};\n  var esc = '__ESC_EXP__';\n  var exp = 0;\n  var res;\n\n  var parts = str.split('{,}');\n  if (opts.nodupes) {\n    return fn(parts.join(''), opts);\n  }\n\n  exp = parts.length - 1;\n  res = fn(parts.join(esc), opts);\n  var len = res.length;\n  var arr = [];\n  var i = 0;\n\n  while (len--) {\n    var ele = res[i++];\n    var idx = ele.indexOf(esc);\n\n    if (idx === -1) {\n      arr.push(ele);\n\n    } else {\n      ele = ele.split('__ESC_EXP__').join('');\n      if (!!ele && opts.nodupes !== false) {\n        arr.push(ele);\n\n      } else {\n        var num = Math.pow(2, exp);\n        arr.push.apply(arr, repeat(ele, num));\n      }\n    }\n  }\n  return arr;\n}", "code_tokens": ["function", "exponential", "(", "str", ",", "options", ",", "fn", ")", "{", "if", "(", "typeof", "options", "===", "'function'", ")", "{", "fn", "=", "options", ";", "options", "=", "null", ";", "}", "var", "opts", "=", "options", "||", "{", "}", ";", "var", "esc", "=", "'__ESC_EXP__'", ";", "var", "exp", "=", "0", ";", "var", "res", ";", "var", "parts", "=", "str", ".", "split", "(", "'{,}'", ")", ";", "if", "(", "opts", ".", "nodupes", ")", "{", "return", "fn", "(", "parts", ".", "join", "(", "''", ")", ",", "opts", ")", ";", "}", "exp", "=", "parts", ".", "length", "-", "1", ";", "res", "=", "fn", "(", "parts", ".", "join", "(", "esc", ")", ",", "opts", ")", ";", "var", "len", "=", "res", ".", "length", ";", "var", "arr", "=", "[", "]", ";", "var", "i", "=", "0", ";", "while", "(", "len", "--", ")", "{", "var", "ele", "=", "res", "[", "i", "++", "]", ";", "var", "idx", "=", "ele", ".", "indexOf", "(", "esc", ")", ";", "if", "(", "idx", "===", "-", "1", ")", "{", "arr", ".", "push", "(", "ele", ")", ";", "}", "else", "{", "ele", "=", "ele", ".", "split", "(", "'__ESC_EXP__'", ")", ".", "join", "(", "''", ")", ";", "if", "(", "!", "!", "ele", "&&", "opts", ".", "nodupes", "!==", "false", ")", "{", "arr", ".", "push", "(", "ele", ")", ";", "}", "else", "{", "var", "num", "=", "Math", ".", "pow", "(", "2", ",", "exp", ")", ";", "arr", ".", "push", ".", "apply", "(", "arr", ",", "repeat", "(", "ele", ",", "num", ")", ")", ";", "}", "}", "}", "return", "arr", ";", "}"], "docstring": "Expand exponential ranges\n\n`a{,}{,}` => ['a', 'a', 'a', 'a']", "docstring_tokens": ["Expand", "exponential", "ranges"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L43446-L43487", "partition": "test"}
{"repo": "simonepri/sympact", "path": "index.js", "func_name": "sympact", "original_string": "async function sympact(code, options) {\n  if (typeof code !== 'string') {\n    throw new TypeError(\"The 'code' paramater must a string'\");\n  }\n  if (typeof options === 'undefined') {\n    options = {};\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError(\"The 'options' paramater must an object'\");\n  }\n  const interval = options.interval || 125;\n  const cwd = options.cwd || path.dirname(caller());\n\n  if (interval < 1) {\n    throw new TypeError(\"The 'interval' paramater must be greater than 0'\");\n  }\n\n  return new Promise((resolve, reject) => {\n    const slave = new Worker(code, cwd);\n    const probe = new Profiler(slave.pid(), interval);\n\n    slave.on('ready', async () => {\n      await probe.watch();\n      slave.run();\n    });\n\n    slave.on('after', async (start, end) => {\n      await probe.unwatch();\n      slave.kill();\n\n      resolve(probe.report(start, end));\n    });\n\n    slave.on('error', async err => {\n      await probe.unwatch();\n      slave.kill();\n\n      reject(err);\n    });\n  });\n}", "language": "javascript", "code": "async function sympact(code, options) {\n  if (typeof code !== 'string') {\n    throw new TypeError(\"The 'code' paramater must a string'\");\n  }\n  if (typeof options === 'undefined') {\n    options = {};\n  }\n  if (typeof options !== 'object') {\n    throw new TypeError(\"The 'options' paramater must an object'\");\n  }\n  const interval = options.interval || 125;\n  const cwd = options.cwd || path.dirname(caller());\n\n  if (interval < 1) {\n    throw new TypeError(\"The 'interval' paramater must be greater than 0'\");\n  }\n\n  return new Promise((resolve, reject) => {\n    const slave = new Worker(code, cwd);\n    const probe = new Profiler(slave.pid(), interval);\n\n    slave.on('ready', async () => {\n      await probe.watch();\n      slave.run();\n    });\n\n    slave.on('after', async (start, end) => {\n      await probe.unwatch();\n      slave.kill();\n\n      resolve(probe.report(start, end));\n    });\n\n    slave.on('error', async err => {\n      await probe.unwatch();\n      slave.kill();\n\n      reject(err);\n    });\n  });\n}", "code_tokens": ["async", "function", "sympact", "(", "code", ",", "options", ")", "{", "if", "(", "typeof", "code", "!==", "'string'", ")", "{", "throw", "new", "TypeError", "(", "\"The 'code' paramater must a string'\"", ")", ";", "}", "if", "(", "typeof", "options", "===", "'undefined'", ")", "{", "options", "=", "{", "}", ";", "}", "if", "(", "typeof", "options", "!==", "'object'", ")", "{", "throw", "new", "TypeError", "(", "\"The 'options' paramater must an object'\"", ")", ";", "}", "const", "interval", "=", "options", ".", "interval", "||", "125", ";", "const", "cwd", "=", "options", ".", "cwd", "||", "path", ".", "dirname", "(", "caller", "(", ")", ")", ";", "if", "(", "interval", "<", "1", ")", "{", "throw", "new", "TypeError", "(", "\"The 'interval' paramater must be greater than 0'\"", ")", ";", "}", "return", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "const", "slave", "=", "new", "Worker", "(", "code", ",", "cwd", ")", ";", "const", "probe", "=", "new", "Profiler", "(", "slave", ".", "pid", "(", ")", ",", "interval", ")", ";", "slave", ".", "on", "(", "'ready'", ",", "async", "(", ")", "=>", "{", "await", "probe", ".", "watch", "(", ")", ";", "slave", ".", "run", "(", ")", ";", "}", ")", ";", "slave", ".", "on", "(", "'after'", ",", "async", "(", "start", ",", "end", ")", "=>", "{", "await", "probe", ".", "unwatch", "(", ")", ";", "slave", ".", "kill", "(", ")", ";", "resolve", "(", "probe", ".", "report", "(", "start", ",", "end", ")", ")", ";", "}", ")", ";", "slave", ".", "on", "(", "'error'", ",", "async", "err", "=>", "{", "await", "probe", ".", "unwatch", "(", ")", ";", "slave", ".", "kill", "(", ")", ";", "reject", "(", "err", ")", ";", "}", ")", ";", "}", ")", ";", "}"], "docstring": "Measures the impact of running a certain script on your system.\nMonitors the cpu and memory usage of the whole tree of processes generated by\nthe script provided.\n@public\n@param  {string} code The source code to test.\n@param  {Object} [options] Optional configurations.\n@param  {number} [options.interval=125] Sampling interval in milliseconds.\n@param  {string} [options.cwd=caller] CWD for the script.\n@return {Promise.<Object>} An object containing the results.", "docstring_tokens": ["Measures", "the", "impact", "of", "running", "a", "certain", "script", "on", "your", "system", ".", "Monitors", "the", "cpu", "and", "memory", "usage", "of", "the", "whole", "tree", "of", "processes", "generated", "by", "the", "script", "provided", "."], "sha": "ff60a2325afa2e0aaf8f85d0d0473b41117476e2", "url": "https://github.com/simonepri/sympact/blob/ff60a2325afa2e0aaf8f85d0d0473b41117476e2/index.js#L20-L60", "partition": "test"}
{"repo": "hbouvier/node-tts", "path": "swagger-ui/lib/shred.bundle.js", "func_name": "", "original_string": "function(encoding) {\n        var enc = encoding || \"utf8\";\n        var codecOptions = undefined;\n        while (1) {\n            if (getType(enc) === \"String\")\n                enc = enc.replace(/[- ]/g, \"\").toLowerCase();\n            var codec = iconv.encodings[enc];\n            var type = getType(codec);\n            if (type === \"String\") {\n                // Link to other encoding.\n                codecOptions = {originalEncoding: enc};\n                enc = codec;\n            }\n            else if (type === \"Object\" && codec.type != undefined) {\n                // Options for other encoding.\n                codecOptions = codec;\n                enc = codec.type;\n            } \n            else if (type === \"Function\")\n                // Codec itself.\n                return codec(codecOptions);\n            else\n                throw new Error(\"Encoding not recognized: '\" + encoding + \"' (searched as: '\"+enc+\"')\");\n        }\n    }", "language": "javascript", "code": "function(encoding) {\n        var enc = encoding || \"utf8\";\n        var codecOptions = undefined;\n        while (1) {\n            if (getType(enc) === \"String\")\n                enc = enc.replace(/[- ]/g, \"\").toLowerCase();\n            var codec = iconv.encodings[enc];\n            var type = getType(codec);\n            if (type === \"String\") {\n                // Link to other encoding.\n                codecOptions = {originalEncoding: enc};\n                enc = codec;\n            }\n            else if (type === \"Object\" && codec.type != undefined) {\n                // Options for other encoding.\n                codecOptions = codec;\n                enc = codec.type;\n            } \n            else if (type === \"Function\")\n                // Codec itself.\n                return codec(codecOptions);\n            else\n                throw new Error(\"Encoding not recognized: '\" + encoding + \"' (searched as: '\"+enc+\"')\");\n        }\n    }", "code_tokens": ["function", "(", "encoding", ")", "{", "var", "enc", "=", "encoding", "||", "\"utf8\"", ";", "var", "codecOptions", "=", "undefined", ";", "while", "(", "1", ")", "{", "if", "(", "getType", "(", "enc", ")", "===", "\"String\"", ")", "enc", "=", "enc", ".", "replace", "(", "/", "[- ]", "/", "g", ",", "\"\"", ")", ".", "toLowerCase", "(", ")", ";", "var", "codec", "=", "iconv", ".", "encodings", "[", "enc", "]", ";", "var", "type", "=", "getType", "(", "codec", ")", ";", "if", "(", "type", "===", "\"String\"", ")", "{", "// Link to other encoding.", "codecOptions", "=", "{", "originalEncoding", ":", "enc", "}", ";", "enc", "=", "codec", ";", "}", "else", "if", "(", "type", "===", "\"Object\"", "&&", "codec", ".", "type", "!=", "undefined", ")", "{", "// Options for other encoding.", "codecOptions", "=", "codec", ";", "enc", "=", "codec", ".", "type", ";", "}", "else", "if", "(", "type", "===", "\"Function\"", ")", "// Codec itself.", "return", "codec", "(", "codecOptions", ")", ";", "else", "throw", "new", "Error", "(", "\"Encoding not recognized: '\"", "+", "encoding", "+", "\"' (searched as: '\"", "+", "enc", "+", "\"')\"", ")", ";", "}", "}"], "docstring": "Get correct codec for given encoding.", "docstring_tokens": ["Get", "correct", "codec", "for", "given", "encoding", "."], "sha": "6b49053bb7f667681d526dc21d5d6b71f3bf644d", "url": "https://github.com/hbouvier/node-tts/blob/6b49053bb7f667681d526dc21d5d6b71f3bf644d/swagger-ui/lib/shred.bundle.js#L2233-L2257", "partition": "test"}
{"repo": "aheckmann/gomon", "path": "lib/db.js", "func_name": "wrap", "original_string": "function wrap (proto, name) {\n  var old = proto[name];\n\n  proto[name] = function () {\n    if (global.repl) global.repl.bufferStart();\n    var args = slice(arguments);\n    var last = args[args.length-1];\n    if ('function' == typeof last) {\n      args[args.length-1] = function () {\n        if (global.repl) global.repl.bufferEnd()\n        if (p != last) console.log();\n        last.apply(null, arguments)\n        if (global.repl) {\n          global.repl.displayPrompt();\n          global.repl.moveCursorToEnd();\n        }\n      }\n    } else {\n      args.push(function () {\n        if (global.repl) global.repl.bufferEnd()\n        p.apply(null, arguments);\n        if (global.repl) global.repl.moveCursorToEnd();\n      });\n    }\n    old.apply(this, args);\n  }\n\n  if (old.help) {\n    proto[name].help = old.help;\n  }\n}", "language": "javascript", "code": "function wrap (proto, name) {\n  var old = proto[name];\n\n  proto[name] = function () {\n    if (global.repl) global.repl.bufferStart();\n    var args = slice(arguments);\n    var last = args[args.length-1];\n    if ('function' == typeof last) {\n      args[args.length-1] = function () {\n        if (global.repl) global.repl.bufferEnd()\n        if (p != last) console.log();\n        last.apply(null, arguments)\n        if (global.repl) {\n          global.repl.displayPrompt();\n          global.repl.moveCursorToEnd();\n        }\n      }\n    } else {\n      args.push(function () {\n        if (global.repl) global.repl.bufferEnd()\n        p.apply(null, arguments);\n        if (global.repl) global.repl.moveCursorToEnd();\n      });\n    }\n    old.apply(this, args);\n  }\n\n  if (old.help) {\n    proto[name].help = old.help;\n  }\n}", "code_tokens": ["function", "wrap", "(", "proto", ",", "name", ")", "{", "var", "old", "=", "proto", "[", "name", "]", ";", "proto", "[", "name", "]", "=", "function", "(", ")", "{", "if", "(", "global", ".", "repl", ")", "global", ".", "repl", ".", "bufferStart", "(", ")", ";", "var", "args", "=", "slice", "(", "arguments", ")", ";", "var", "last", "=", "args", "[", "args", ".", "length", "-", "1", "]", ";", "if", "(", "'function'", "==", "typeof", "last", ")", "{", "args", "[", "args", ".", "length", "-", "1", "]", "=", "function", "(", ")", "{", "if", "(", "global", ".", "repl", ")", "global", ".", "repl", ".", "bufferEnd", "(", ")", "if", "(", "p", "!=", "last", ")", "console", ".", "log", "(", ")", ";", "last", ".", "apply", "(", "null", ",", "arguments", ")", "if", "(", "global", ".", "repl", ")", "{", "global", ".", "repl", ".", "displayPrompt", "(", ")", ";", "global", ".", "repl", ".", "moveCursorToEnd", "(", ")", ";", "}", "}", "}", "else", "{", "args", ".", "push", "(", "function", "(", ")", "{", "if", "(", "global", ".", "repl", ")", "global", ".", "repl", ".", "bufferEnd", "(", ")", "p", ".", "apply", "(", "null", ",", "arguments", ")", ";", "if", "(", "global", ".", "repl", ")", "global", ".", "repl", ".", "moveCursorToEnd", "(", ")", ";", "}", ")", ";", "}", "old", ".", "apply", "(", "this", ",", "args", ")", ";", "}", "if", "(", "old", ".", "help", ")", "{", "proto", "[", "name", "]", ".", "help", "=", "old", ".", "help", ";", "}", "}"], "docstring": "Wrap async functions with animation etc", "docstring_tokens": ["Wrap", "async", "functions", "with", "animation", "etc"], "sha": "9b3c8e12f3369b9898f5d3c51bb6554ea03b5a03", "url": "https://github.com/aheckmann/gomon/blob/9b3c8e12f3369b9898f5d3c51bb6554ea03b5a03/lib/db.js#L329-L359", "partition": "test"}
{"repo": "automategreen/home-controller", "path": "lib/Insteon/index.js", "func_name": "_defaultCheckSize", "original_string": "function _defaultCheckSize(size) {\n  return function (raw) {\n    if (raw.length < size) {\n      return false;\n    }\n    this.buffer = raw.substr(size);\n    return raw.substr(0, size);\n  };\n}", "language": "javascript", "code": "function _defaultCheckSize(size) {\n  return function (raw) {\n    if (raw.length < size) {\n      return false;\n    }\n    this.buffer = raw.substr(size);\n    return raw.substr(0, size);\n  };\n}", "code_tokens": ["function", "_defaultCheckSize", "(", "size", ")", "{", "return", "function", "(", "raw", ")", "{", "if", "(", "raw", ".", "length", "<", "size", ")", "{", "return", "false", ";", "}", "this", ".", "buffer", "=", "raw", ".", "substr", "(", "size", ")", ";", "return", "raw", ".", "substr", "(", "0", ",", "size", ")", ";", "}", ";", "}"], "docstring": "A closure factory to build the checkSize function for most of our handlers", "docstring_tokens": ["A", "closure", "factory", "to", "build", "the", "checkSize", "function", "for", "most", "of", "our", "handlers"], "sha": "8879b1e430c2946d2249e5d90c1a70fbe7018646", "url": "https://github.com/automategreen/home-controller/blob/8879b1e430c2946d2249e5d90c1a70fbe7018646/lib/Insteon/index.js#L644-L652", "partition": "test"}
{"repo": "farbelous/bootstrap-popover-picker", "path": "src/js/picker.js", "func_name": "", "original_string": "function(val) {\n                // here you may parse your format when you build your plugin\n                var valueInPicker = this.options.itemProperty ? this.pickerValue[this.options.itemProperty] : this.pickerValue;\n                return (val ? val : valueInPicker);\n            }", "language": "javascript", "code": "function(val) {\n                // here you may parse your format when you build your plugin\n                var valueInPicker = this.options.itemProperty ? this.pickerValue[this.options.itemProperty] : this.pickerValue;\n                return (val ? val : valueInPicker);\n            }", "code_tokens": ["function", "(", "val", ")", "{", "// here you may parse your format when you build your plugin", "var", "valueInPicker", "=", "this", ".", "options", ".", "itemProperty", "?", "this", ".", "pickerValue", "[", "this", ".", "options", ".", "itemProperty", "]", ":", "this", ".", "pickerValue", ";", "return", "(", "val", "?", "val", ":", "valueInPicker", ")", ";", "}"], "docstring": "Returns the formatted item value\n@returns string", "docstring_tokens": ["Returns", "the", "formatted", "item", "value"], "sha": "f0087902fbea37428d677f0eee11fdc2cd3fd0d5", "url": "https://github.com/farbelous/bootstrap-popover-picker/blob/f0087902fbea37428d677f0eee11fdc2cd3fd0d5/src/js/picker.js#L601-L605", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "wrap", "original_string": "function wrap(arr, sep, opts) {\n  if (sep === '~') { sep = '-'; }\n  var str = arr.join(sep);\n  var pre = opts && opts.regexPrefix;\n\n  // regex logical `or`\n  if (sep === '|') {\n    str = pre ? pre + str : str;\n    str = '(' + str + ')';\n  }\n\n  // regex character class\n  if (sep === '-') {\n    str = (pre && pre === '^')\n      ? pre + str\n      : str;\n    str = '[' + str + ']';\n  }\n  return [str];\n}", "language": "javascript", "code": "function wrap(arr, sep, opts) {\n  if (sep === '~') { sep = '-'; }\n  var str = arr.join(sep);\n  var pre = opts && opts.regexPrefix;\n\n  // regex logical `or`\n  if (sep === '|') {\n    str = pre ? pre + str : str;\n    str = '(' + str + ')';\n  }\n\n  // regex character class\n  if (sep === '-') {\n    str = (pre && pre === '^')\n      ? pre + str\n      : str;\n    str = '[' + str + ']';\n  }\n  return [str];\n}", "code_tokens": ["function", "wrap", "(", "arr", ",", "sep", ",", "opts", ")", "{", "if", "(", "sep", "===", "'~'", ")", "{", "sep", "=", "'-'", ";", "}", "var", "str", "=", "arr", ".", "join", "(", "sep", ")", ";", "var", "pre", "=", "opts", "&&", "opts", ".", "regexPrefix", ";", "// regex logical `or`", "if", "(", "sep", "===", "'|'", ")", "{", "str", "=", "pre", "?", "pre", "+", "str", ":", "str", ";", "str", "=", "'('", "+", "str", "+", "')'", ";", "}", "// regex character class", "if", "(", "sep", "===", "'-'", ")", "{", "str", "=", "(", "pre", "&&", "pre", "===", "'^'", ")", "?", "pre", "+", "str", ":", "str", ";", "str", "=", "'['", "+", "str", "+", "']'", ";", "}", "return", "[", "str", "]", ";", "}"], "docstring": "Wrap the string with the correct regex\nsyntax.", "docstring_tokens": ["Wrap", "the", "string", "with", "the", "correct", "regex", "syntax", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L11197-L11216", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "onFullScreenChange", "original_string": "function onFullScreenChange(resize) {\n    if (document.fullscreenElement || document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement) {\n        controls.fullscreen.classList.add('pnlm-fullscreen-toggle-button-active');\n        fullscreenActive = true;\n    } else {\n        controls.fullscreen.classList.remove('pnlm-fullscreen-toggle-button-active');\n        fullscreenActive = false;\n    }\n    if (resize !== 'resize')\n        fireEvent('fullscreenchange', fullscreenActive);\n    // Resize renderer (deal with browser quirks and fixes #155)\n    renderer.resize();\n    setHfov(config.hfov);\n    animateInit();\n}", "language": "javascript", "code": "function onFullScreenChange(resize) {\n    if (document.fullscreenElement || document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement) {\n        controls.fullscreen.classList.add('pnlm-fullscreen-toggle-button-active');\n        fullscreenActive = true;\n    } else {\n        controls.fullscreen.classList.remove('pnlm-fullscreen-toggle-button-active');\n        fullscreenActive = false;\n    }\n    if (resize !== 'resize')\n        fireEvent('fullscreenchange', fullscreenActive);\n    // Resize renderer (deal with browser quirks and fixes #155)\n    renderer.resize();\n    setHfov(config.hfov);\n    animateInit();\n}", "code_tokens": ["function", "onFullScreenChange", "(", "resize", ")", "{", "if", "(", "document", ".", "fullscreenElement", "||", "document", ".", "fullscreen", "||", "document", ".", "mozFullScreen", "||", "document", ".", "webkitIsFullScreen", "||", "document", ".", "msFullscreenElement", ")", "{", "controls", ".", "fullscreen", ".", "classList", ".", "add", "(", "'pnlm-fullscreen-toggle-button-active'", ")", ";", "fullscreenActive", "=", "true", ";", "}", "else", "{", "controls", ".", "fullscreen", ".", "classList", ".", "remove", "(", "'pnlm-fullscreen-toggle-button-active'", ")", ";", "fullscreenActive", "=", "false", ";", "}", "if", "(", "resize", "!==", "'resize'", ")", "fireEvent", "(", "'fullscreenchange'", ",", "fullscreenActive", ")", ";", "// Resize renderer (deal with browser quirks and fixes #155)", "renderer", ".", "resize", "(", ")", ";", "setHfov", "(", "config", ".", "hfov", ")", ";", "animateInit", "(", ")", ";", "}"], "docstring": "Event handler for fullscreen changes.\n@private", "docstring_tokens": ["Event", "handler", "for", "fullscreen", "changes", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L2110-L2124", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/metadata/schema-parser.js", "func_name": "SchemaParserV3", "original_string": "function SchemaParserV3(options, cc, udtResolver) {\n  SchemaParserV2.call(this, options, cc, udtResolver);\n  this.supportsVirtual = true;\n}", "language": "javascript", "code": "function SchemaParserV3(options, cc, udtResolver) {\n  SchemaParserV2.call(this, options, cc, udtResolver);\n  this.supportsVirtual = true;\n}", "code_tokens": ["function", "SchemaParserV3", "(", "options", ",", "cc", ",", "udtResolver", ")", "{", "SchemaParserV2", ".", "call", "(", "this", ",", "options", ",", "cc", ",", "udtResolver", ")", ";", "this", ".", "supportsVirtual", "=", "true", ";", "}"], "docstring": "Used to parse schema information for Cassandra versions 4.x and above.\n\nThis parser similar to [SchemaParserV2] expect it also parses virtual\nkeyspaces.\n\n@param {ClientOptions} options The client options\n@param {ControlConnection} cc The control connection to be used\n@param {Function} udtResolver The function to be used to retrieve the udts.\n@constructor\n@ignore", "docstring_tokens": ["Used", "to", "parse", "schema", "information", "for", "Cassandra", "versions", "4", ".", "x", "and", "above", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/metadata/schema-parser.js#L1081-L1084", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/data/NodeInterface.js", "func_name": "", "original_string": "function(destroy, suppressEvents) {\n                    var cn = this.childNodes,\n                        n;\n\n                    while ((n = cn[0])) {\n                        this.removeChild(n, destroy, suppressEvents);\n                    }\n                    return this;\n                }", "language": "javascript", "code": "function(destroy, suppressEvents) {\n                    var cn = this.childNodes,\n                        n;\n\n                    while ((n = cn[0])) {\n                        this.removeChild(n, destroy, suppressEvents);\n                    }\n                    return this;\n                }", "code_tokens": ["function", "(", "destroy", ",", "suppressEvents", ")", "{", "var", "cn", "=", "this", ".", "childNodes", ",", "n", ";", "while", "(", "(", "n", "=", "cn", "[", "0", "]", ")", ")", "{", "this", ".", "removeChild", "(", "n", ",", "destroy", ",", "suppressEvents", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Removes all child nodes from this node.\n@param {Boolean} [destroy=false] `true` to destroy the node upon removal.\n@return {Ext.data.NodeInterface} this", "docstring_tokens": ["Removes", "all", "child", "nodes", "from", "this", "node", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeInterface.js#L719-L727", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(record, array) {\n    var loadingRecordArrays = record._loadingRecordArrays || [];\n    loadingRecordArrays.push(array);\n    record._loadingRecordArrays = loadingRecordArrays;\n  }", "language": "javascript", "code": "function(record, array) {\n    var loadingRecordArrays = record._loadingRecordArrays || [];\n    loadingRecordArrays.push(array);\n    record._loadingRecordArrays = loadingRecordArrays;\n  }", "code_tokens": ["function", "(", "record", ",", "array", ")", "{", "var", "loadingRecordArrays", "=", "record", ".", "_loadingRecordArrays", "||", "[", "]", ";", "loadingRecordArrays", ".", "push", "(", "array", ")", ";", "record", ".", "_loadingRecordArrays", "=", "loadingRecordArrays", ";", "}"], "docstring": "Internally, we maintain a map of all unloaded IDs requested by a ManyArray. As the adapter loads data into the store, the store notifies any interested ManyArrays. When the ManyArray's total number of loading records drops to zero, it becomes `isLoaded` and fires a `didLoad` event.", "docstring_tokens": ["Internally", "we", "maintain", "a", "map", "of", "all", "unloaded", "IDs", "requested", "by", "a", "ManyArray", ".", "As", "the", "adapter", "loads", "data", "into", "the", "store", "the", "store", "notifies", "any", "interested", "ManyArrays", ".", "When", "the", "ManyArray", "s", "total", "number", "of", "loading", "records", "drops", "to", "zero", "it", "becomes", "isLoaded", "and", "fires", "a", "didLoad", "event", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L7419-L7423", "partition": "test"}
{"repo": "bholloway/browserify-nginject", "path": "lib/infer-angular.js", "func_name": "inferAngular", "original_string": "function inferAngular(ast) {\n  return esprimaTools.breadthFirst(ast)\n    .map(getAnnotationCandidates)\n    .filter(Boolean)\n    .map(followReference)\n    .filter(Boolean);\n}", "language": "javascript", "code": "function inferAngular(ast) {\n  return esprimaTools.breadthFirst(ast)\n    .map(getAnnotationCandidates)\n    .filter(Boolean)\n    .map(followReference)\n    .filter(Boolean);\n}", "code_tokens": ["function", "inferAngular", "(", "ast", ")", "{", "return", "esprimaTools", ".", "breadthFirst", "(", "ast", ")", ".", "map", "(", "getAnnotationCandidates", ")", ".", "filter", "(", "Boolean", ")", ".", "map", "(", "followReference", ")", ".", "filter", "(", "Boolean", ")", ";", "}"], "docstring": "Find functions that are obvious angular entities.\n@param {object} ast An esprima syntax tree", "docstring_tokens": ["Find", "functions", "that", "are", "obvious", "angular", "entities", "."], "sha": "42cff52081b66d77e4e7fac923d4d824de13cfd3", "url": "https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/infer-angular.js#L11-L17", "partition": "test"}
{"repo": "everitoken/evtjs", "path": "src/ecc/aes.js", "func_name": "cryptoJsDecrypt", "original_string": "function cryptoJsDecrypt(message, key, iv) {\n    assert(message, \"Missing cipher text\");\n    message = toBinaryBuffer(message);\n    const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n    // decipher.setAutoPadding(true)\n    message = Buffer.concat([decipher.update(message), decipher.final()]);\n    return message;\n}", "language": "javascript", "code": "function cryptoJsDecrypt(message, key, iv) {\n    assert(message, \"Missing cipher text\");\n    message = toBinaryBuffer(message);\n    const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n    // decipher.setAutoPadding(true)\n    message = Buffer.concat([decipher.update(message), decipher.final()]);\n    return message;\n}", "code_tokens": ["function", "cryptoJsDecrypt", "(", "message", ",", "key", ",", "iv", ")", "{", "assert", "(", "message", ",", "\"Missing cipher text\"", ")", ";", "message", "=", "toBinaryBuffer", "(", "message", ")", ";", "const", "decipher", "=", "crypto", ".", "createDecipheriv", "(", "\"aes-256-cbc\"", ",", "key", ",", "iv", ")", ";", "// decipher.setAutoPadding(true)", "message", "=", "Buffer", ".", "concat", "(", "[", "decipher", ".", "update", "(", "message", ")", ",", "decipher", ".", "final", "(", ")", "]", ")", ";", "return", "message", ";", "}"], "docstring": "This method does not use a checksum, the returned data must be validated some other way.\n\n@arg {string|Buffer} message - ciphertext binary format\n@arg {string<utf8>|Buffer} key - 256bit\n@arg {string<utf8>|Buffer} iv - 128bit\n\n@return {Buffer}", "docstring_tokens": ["This", "method", "does", "not", "use", "a", "checksum", "the", "returned", "data", "must", "be", "validated", "some", "other", "way", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/aes.js#L122-L129", "partition": "test"}
{"repo": "racker/node-keystone-client", "path": "lib/client.js", "func_name": "KeystoneClient", "original_string": "function KeystoneClient(url, options) {\n  options = options || {};\n\n  if (options.username) {\n    if (!options.password && !options.apiKey) {\n      throw new Error('If username is provided you also need to provide password or apiKey');\n    }\n  }\n\n  this._url = url;\n  this._username = options.username;\n  this._apiKey = options.apiKey;\n  this._password = options.password;\n  this._extraArgs = options.extraArgs || {};\n  this._cacheTokenFor = options.cacheTokenFor || DEFAULT_CACHE_TOKEN_FOR;\n\n  this._token = null;\n  this._tokenExpires = null;\n  this._refreshTokenCompletions = [];\n  this._tokenUpdated = 0;\n  this._tenantId = null;\n  this._serviceCatalog = [];\n}", "language": "javascript", "code": "function KeystoneClient(url, options) {\n  options = options || {};\n\n  if (options.username) {\n    if (!options.password && !options.apiKey) {\n      throw new Error('If username is provided you also need to provide password or apiKey');\n    }\n  }\n\n  this._url = url;\n  this._username = options.username;\n  this._apiKey = options.apiKey;\n  this._password = options.password;\n  this._extraArgs = options.extraArgs || {};\n  this._cacheTokenFor = options.cacheTokenFor || DEFAULT_CACHE_TOKEN_FOR;\n\n  this._token = null;\n  this._tokenExpires = null;\n  this._refreshTokenCompletions = [];\n  this._tokenUpdated = 0;\n  this._tenantId = null;\n  this._serviceCatalog = [];\n}", "code_tokens": ["function", "KeystoneClient", "(", "url", ",", "options", ")", "{", "options", "=", "options", "||", "{", "}", ";", "if", "(", "options", ".", "username", ")", "{", "if", "(", "!", "options", ".", "password", "&&", "!", "options", ".", "apiKey", ")", "{", "throw", "new", "Error", "(", "'If username is provided you also need to provide password or apiKey'", ")", ";", "}", "}", "this", ".", "_url", "=", "url", ";", "this", ".", "_username", "=", "options", ".", "username", ";", "this", ".", "_apiKey", "=", "options", ".", "apiKey", ";", "this", ".", "_password", "=", "options", ".", "password", ";", "this", ".", "_extraArgs", "=", "options", ".", "extraArgs", "||", "{", "}", ";", "this", ".", "_cacheTokenFor", "=", "options", ".", "cacheTokenFor", "||", "DEFAULT_CACHE_TOKEN_FOR", ";", "this", ".", "_token", "=", "null", ";", "this", ".", "_tokenExpires", "=", "null", ";", "this", ".", "_refreshTokenCompletions", "=", "[", "]", ";", "this", ".", "_tokenUpdated", "=", "0", ";", "this", ".", "_tenantId", "=", "null", ";", "this", ".", "_serviceCatalog", "=", "[", "]", ";", "}"], "docstring": "OpenStack Keystone Identity API client.\n\n@param {String} url Base keystone server url including the version.\n@param {Object} options Authentication options (username, apiKey, password,\ncacheTokenFor).\n@constructor", "docstring_tokens": ["OpenStack", "Keystone", "Identity", "API", "client", "."], "sha": "fb1f0be6f640740ee914474619ec31440773a747", "url": "https://github.com/racker/node-keystone-client/blob/fb1f0be6f640740ee914474619ec31440773a747/lib/client.js#L44-L66", "partition": "test"}
{"repo": "intelligo-systems/intelligo.js", "path": "formats/arff.js", "func_name": "", "original_string": "function(dataset, relationName, featureLookupTable) {\n\tvar arff = \"% Automatically generated by Node.js\\n\";\n\tarff += \"@relation \"+relationName+\"\\n\";\n\n\tfeatureLookupTable.featureIndexToFeatureName.forEach(function(featureName) {\n\t\tif (_.isUndefined(featureName)) \n\t\t\tarff += \"@attribute undefined {0,1}\"+\"\\n\";\n\t\telse if (!_.isString(featureName))\n\t\t\tthrow new Error(\"Expected featureName to be a string, but found \"+JSON.stringify(featureName));\n\t\telse arff += \"@attribute \"+featureName.replace(/[^a-zA-Z0-9]/g, \"_\")+\" \"+\"{0,1}\"+\"\\n\";\n\t});\n\n\tarff += \"\\n@data\\n\";\n\t\n\tdataset.forEach(function(datum) {\n\t\tvar datumArff = _.clone(datum.input, {});\n\t\tfor (var i=0; i<datum.output.length; ++i)\n\t\t\tdatumArff[datum.output[i]]=1;\n\t\t//console.dir(datumArff);\n\t\tvar array = featureLookupTable.hashToArray(datumArff);\n\t\tarff += array + \"\\n\";\n\t});\n\n\treturn arff;\n}", "language": "javascript", "code": "function(dataset, relationName, featureLookupTable) {\n\tvar arff = \"% Automatically generated by Node.js\\n\";\n\tarff += \"@relation \"+relationName+\"\\n\";\n\n\tfeatureLookupTable.featureIndexToFeatureName.forEach(function(featureName) {\n\t\tif (_.isUndefined(featureName)) \n\t\t\tarff += \"@attribute undefined {0,1}\"+\"\\n\";\n\t\telse if (!_.isString(featureName))\n\t\t\tthrow new Error(\"Expected featureName to be a string, but found \"+JSON.stringify(featureName));\n\t\telse arff += \"@attribute \"+featureName.replace(/[^a-zA-Z0-9]/g, \"_\")+\" \"+\"{0,1}\"+\"\\n\";\n\t});\n\n\tarff += \"\\n@data\\n\";\n\t\n\tdataset.forEach(function(datum) {\n\t\tvar datumArff = _.clone(datum.input, {});\n\t\tfor (var i=0; i<datum.output.length; ++i)\n\t\t\tdatumArff[datum.output[i]]=1;\n\t\t//console.dir(datumArff);\n\t\tvar array = featureLookupTable.hashToArray(datumArff);\n\t\tarff += array + \"\\n\";\n\t});\n\n\treturn arff;\n}", "code_tokens": ["function", "(", "dataset", ",", "relationName", ",", "featureLookupTable", ")", "{", "var", "arff", "=", "\"% Automatically generated by Node.js\\n\"", ";", "arff", "+=", "\"@relation \"", "+", "relationName", "+", "\"\\n\"", ";", "featureLookupTable", ".", "featureIndexToFeatureName", ".", "forEach", "(", "function", "(", "featureName", ")", "{", "if", "(", "_", ".", "isUndefined", "(", "featureName", ")", ")", "arff", "+=", "\"@attribute undefined {0,1}\"", "+", "\"\\n\"", ";", "else", "if", "(", "!", "_", ".", "isString", "(", "featureName", ")", ")", "throw", "new", "Error", "(", "\"Expected featureName to be a string, but found \"", "+", "JSON", ".", "stringify", "(", "featureName", ")", ")", ";", "else", "arff", "+=", "\"@attribute \"", "+", "featureName", ".", "replace", "(", "/", "[^a-zA-Z0-9]", "/", "g", ",", "\"_\"", ")", "+", "\" \"", "+", "\"{0,1}\"", "+", "\"\\n\"", ";", "}", ")", ";", "arff", "+=", "\"\\n@data\\n\"", ";", "dataset", ".", "forEach", "(", "function", "(", "datum", ")", "{", "var", "datumArff", "=", "_", ".", "clone", "(", "datum", ".", "input", ",", "{", "}", ")", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "datum", ".", "output", ".", "length", ";", "++", "i", ")", "datumArff", "[", "datum", ".", "output", "[", "i", "]", "]", "=", "1", ";", "//console.dir(datumArff);", "var", "array", "=", "featureLookupTable", ".", "hashToArray", "(", "datumArff", ")", ";", "arff", "+=", "array", "+", "\"\\n\"", ";", "}", ")", ";", "return", "arff", ";", "}"], "docstring": "convert a single dataset to Weka ARFF string.\n@param dataset an array of samples in the format {input: {feature1: xxx, feature2: yyy, ...}, output: [1,2,3]}\n@param relationName string for the @relation on the top of the file.\n@param featureLookupTable maps features to indices\n@return an ARFF string.", "docstring_tokens": ["convert", "a", "single", "dataset", "to", "Weka", "ARFF", "string", "."], "sha": "9e75d48214fb41d346462f5d886bd92cc9956df6", "url": "https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/formats/arff.js#L98-L122", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/direct/RemotingProvider.js", "func_name": "", "original_string": "function() {\n        var actions = this.getActions(),\n            namespace = this.getNamespace(),\n            action, cls, methods,\n            i, ln, method;\n\n        for (action in actions) {\n            if (actions.hasOwnProperty(action)) {\n                cls = namespace[action];\n                if (!cls) {\n                    cls = namespace[action] = {};\n                }\n                methods = actions[action];\n\n                for (i = 0, ln = methods.length; i < ln; ++i) {\n                    method = Ext.create('Ext.direct.RemotingMethod', methods[i]);\n                    cls[method.getName()] = this.createHandler(action, method);\n                }\n            }\n        }\n    }", "language": "javascript", "code": "function() {\n        var actions = this.getActions(),\n            namespace = this.getNamespace(),\n            action, cls, methods,\n            i, ln, method;\n\n        for (action in actions) {\n            if (actions.hasOwnProperty(action)) {\n                cls = namespace[action];\n                if (!cls) {\n                    cls = namespace[action] = {};\n                }\n                methods = actions[action];\n\n                for (i = 0, ln = methods.length; i < ln; ++i) {\n                    method = Ext.create('Ext.direct.RemotingMethod', methods[i]);\n                    cls[method.getName()] = this.createHandler(action, method);\n                }\n            }\n        }\n    }", "code_tokens": ["function", "(", ")", "{", "var", "actions", "=", "this", ".", "getActions", "(", ")", ",", "namespace", "=", "this", ".", "getNamespace", "(", ")", ",", "action", ",", "cls", ",", "methods", ",", "i", ",", "ln", ",", "method", ";", "for", "(", "action", "in", "actions", ")", "{", "if", "(", "actions", ".", "hasOwnProperty", "(", "action", ")", ")", "{", "cls", "=", "namespace", "[", "action", "]", ";", "if", "(", "!", "cls", ")", "{", "cls", "=", "namespace", "[", "action", "]", "=", "{", "}", ";", "}", "methods", "=", "actions", "[", "action", "]", ";", "for", "(", "i", "=", "0", ",", "ln", "=", "methods", ".", "length", ";", "i", "<", "ln", ";", "++", "i", ")", "{", "method", "=", "Ext", ".", "create", "(", "'Ext.direct.RemotingMethod'", ",", "methods", "[", "i", "]", ")", ";", "cls", "[", "method", ".", "getName", "(", ")", "]", "=", "this", ".", "createHandler", "(", "action", ",", "method", ")", ";", "}", "}", "}", "}"], "docstring": "Initialize the API\n@private", "docstring_tokens": ["Initialize", "the", "API"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/direct/RemotingProvider.js#L165-L185", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "", "original_string": "function () {\n      // Set up request and listen for event\n      this.xhr = new XMLHttpRequest();\n      this.xhr.addEventListener(\"load\", this.testHandler, false);\n      this.xhr.addEventListener(\"error\", this.testHandler, false);\n      var testMethod = evalOpts(this.flowObj.opts.testMethod, this.fileObj, this);\n      var data = this.prepareXhrRequest(testMethod, true);\n      this.xhr.send(data);\n    }", "language": "javascript", "code": "function () {\n      // Set up request and listen for event\n      this.xhr = new XMLHttpRequest();\n      this.xhr.addEventListener(\"load\", this.testHandler, false);\n      this.xhr.addEventListener(\"error\", this.testHandler, false);\n      var testMethod = evalOpts(this.flowObj.opts.testMethod, this.fileObj, this);\n      var data = this.prepareXhrRequest(testMethod, true);\n      this.xhr.send(data);\n    }", "code_tokens": ["function", "(", ")", "{", "// Set up request and listen for event", "this", ".", "xhr", "=", "new", "XMLHttpRequest", "(", ")", ";", "this", ".", "xhr", ".", "addEventListener", "(", "\"load\"", ",", "this", ".", "testHandler", ",", "false", ")", ";", "this", ".", "xhr", ".", "addEventListener", "(", "\"error\"", ",", "this", ".", "testHandler", ",", "false", ")", ";", "var", "testMethod", "=", "evalOpts", "(", "this", ".", "flowObj", ".", "opts", ".", "testMethod", ",", "this", ".", "fileObj", ",", "this", ")", ";", "var", "data", "=", "this", ".", "prepareXhrRequest", "(", "testMethod", ",", "true", ")", ";", "this", ".", "xhr", ".", "send", "(", "data", ")", ";", "}"], "docstring": "Makes a GET request without any data to see if the chunk has already\nbeen uploaded in a previous session\n@function", "docstring_tokens": ["Makes", "a", "GET", "request", "without", "any", "data", "to", "see", "if", "the", "chunk", "has", "already", "been", "uploaded", "in", "a", "previous", "session"], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L1299-L1307", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "peekUnicodeEscape", "original_string": "function peekUnicodeEscape() {\n            if (pos + 5 < end && text.charCodeAt(pos + 1) === 117 /* u */) {\n                var start_1 = pos;\n                pos += 2;\n                var value = scanExactNumberOfHexDigits(4);\n                pos = start_1;\n                return value;\n            }\n            return -1;\n        }", "language": "javascript", "code": "function peekUnicodeEscape() {\n            if (pos + 5 < end && text.charCodeAt(pos + 1) === 117 /* u */) {\n                var start_1 = pos;\n                pos += 2;\n                var value = scanExactNumberOfHexDigits(4);\n                pos = start_1;\n                return value;\n            }\n            return -1;\n        }", "code_tokens": ["function", "peekUnicodeEscape", "(", ")", "{", "if", "(", "pos", "+", "5", "<", "end", "&&", "text", ".", "charCodeAt", "(", "pos", "+", "1", ")", "===", "117", "/* u */", ")", "{", "var", "start_1", "=", "pos", ";", "pos", "+=", "2", ";", "var", "value", "=", "scanExactNumberOfHexDigits", "(", "4", ")", ";", "pos", "=", "start_1", ";", "return", "value", ";", "}", "return", "-", "1", ";", "}"], "docstring": "Current character is known to be a backslash. Check for Unicode escape of the form '\\uXXXX' and return code point value if valid Unicode escape is found. Otherwise return -1.", "docstring_tokens": ["Current", "character", "is", "known", "to", "be", "a", "backslash", ".", "Check", "for", "Unicode", "escape", "of", "the", "form", "\\", "uXXXX", "and", "return", "code", "point", "value", "if", "valid", "Unicode", "escape", "is", "found", ".", "Otherwise", "return", "-", "1", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L3566-L3575", "partition": "test"}
{"repo": "LuccaSA/lui-build", "path": "index.js", "func_name": "loadTheme", "original_string": "function loadTheme(props) {\n\tvar relPath = '/' + props.join('/') + '.yml',\n\t\tdefaultsPath = path.resolve(base + '/scss/themes/default' + relPath),\n\t\tcustomPath = (custom) ? custom + relPath : null,\n\t\tdefaultVars = {},\n\t\tcustomVars = null,\n\t\tresult = {};\n\n\t// Try loading a custom theme file\n\tcustomVars = loadYamlFile(customPath);\n\n\t// If merge mode is set to \"replace\", don't even load the defaults\n\tif (customVars && customVars['merge-mode'] === 'replace') {\n\t\tresult = _.omit(customVars, 'merge-mode');\n\t} else {\n\t\tdefaultVars = loadYamlFile(defaultsPath);\n\t\tresult = _.merge(defaultVars, customVars);\n\t}\n\n\t// Store variables in cached theme var\n\t_.set(theme, props.join('.'), result);\n\n\treturn result;\n}", "language": "javascript", "code": "function loadTheme(props) {\n\tvar relPath = '/' + props.join('/') + '.yml',\n\t\tdefaultsPath = path.resolve(base + '/scss/themes/default' + relPath),\n\t\tcustomPath = (custom) ? custom + relPath : null,\n\t\tdefaultVars = {},\n\t\tcustomVars = null,\n\t\tresult = {};\n\n\t// Try loading a custom theme file\n\tcustomVars = loadYamlFile(customPath);\n\n\t// If merge mode is set to \"replace\", don't even load the defaults\n\tif (customVars && customVars['merge-mode'] === 'replace') {\n\t\tresult = _.omit(customVars, 'merge-mode');\n\t} else {\n\t\tdefaultVars = loadYamlFile(defaultsPath);\n\t\tresult = _.merge(defaultVars, customVars);\n\t}\n\n\t// Store variables in cached theme var\n\t_.set(theme, props.join('.'), result);\n\n\treturn result;\n}", "code_tokens": ["function", "loadTheme", "(", "props", ")", "{", "var", "relPath", "=", "'/'", "+", "props", ".", "join", "(", "'/'", ")", "+", "'.yml'", ",", "defaultsPath", "=", "path", ".", "resolve", "(", "base", "+", "'/scss/themes/default'", "+", "relPath", ")", ",", "customPath", "=", "(", "custom", ")", "?", "custom", "+", "relPath", ":", "null", ",", "defaultVars", "=", "{", "}", ",", "customVars", "=", "null", ",", "result", "=", "{", "}", ";", "// Try loading a custom theme file", "customVars", "=", "loadYamlFile", "(", "customPath", ")", ";", "// If merge mode is set to \"replace\", don't even load the defaults", "if", "(", "customVars", "&&", "customVars", "[", "'merge-mode'", "]", "===", "'replace'", ")", "{", "result", "=", "_", ".", "omit", "(", "customVars", ",", "'merge-mode'", ")", ";", "}", "else", "{", "defaultVars", "=", "loadYamlFile", "(", "defaultsPath", ")", ";", "result", "=", "_", ".", "merge", "(", "defaultVars", ",", "customVars", ")", ";", "}", "// Store variables in cached theme var", "_", ".", "set", "(", "theme", ",", "props", ".", "join", "(", "'.'", ")", ",", "result", ")", ";", "return", "result", ";", "}"], "docstring": "Load theme variables from a YAML file.\n\n@param {Array} props\n@return {Object} result", "docstring_tokens": ["Load", "theme", "variables", "from", "a", "YAML", "file", "."], "sha": "916343e0ba3c36c4e9f97761e402783ca68df44d", "url": "https://github.com/LuccaSA/lui-build/blob/916343e0ba3c36c4e9f97761e402783ca68df44d/index.js#L119-L142", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "onNodeMouseOverOut", "original_string": "function onNodeMouseOverOut(nodes, links, enter, targetNode)\n   {\n      // If there is an existing selected node then exit early.\n      if (isNodeSelected()) { return; }\n\n      // Select / highlight related nodes or remove attributes based on enter state.\n      fadeRelatedNodes(targetNode, enter, nodes, links);\n   }", "language": "javascript", "code": "function onNodeMouseOverOut(nodes, links, enter, targetNode)\n   {\n      // If there is an existing selected node then exit early.\n      if (isNodeSelected()) { return; }\n\n      // Select / highlight related nodes or remove attributes based on enter state.\n      fadeRelatedNodes(targetNode, enter, nodes, links);\n   }", "code_tokens": ["function", "onNodeMouseOverOut", "(", "nodes", ",", "links", ",", "enter", ",", "targetNode", ")", "{", "// If there is an existing selected node then exit early.", "if", "(", "isNodeSelected", "(", ")", ")", "{", "return", ";", "}", "// Select / highlight related nodes or remove attributes based on enter state.", "fadeRelatedNodes", "(", "targetNode", ",", "enter", ",", "nodes", ",", "links", ")", ";", "}"], "docstring": "Handles fading related nodes to the given `targetNode` if there is no currently selected node.\n\n@param {Array}    nodes - All graph nodes.\n@param {Array}    links - All graph links.\n@param {boolean}  enter - true when mouse entering / false when mouse exiting.\n@param {object}   targetNode - The target node.", "docstring_tokens": ["Handles", "fading", "related", "nodes", "to", "the", "given", "targetNode", "if", "there", "is", "no", "currently", "selected", "node", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L762-L769", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getTypeFromClassOrInterfaceReference", "original_string": "function getTypeFromClassOrInterfaceReference(node, symbol) {\n            var type = getDeclaredTypeOfSymbol(symbol);\n            var typeParameters = type.localTypeParameters;\n            if (typeParameters) {\n                if (!node.typeArguments || node.typeArguments.length !== typeParameters.length) {\n                    error(node, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(type, /*enclosingDeclaration*/ undefined, 1 /* WriteArrayAsGenericType */), typeParameters.length);\n                    return unknownType;\n                }\n                // In a type reference, the outer type parameters of the referenced class or interface are automatically\n                // supplied as type arguments and the type reference only specifies arguments for the local type parameters\n                // of the class or interface.\n                return createTypeReference(type, ts.concatenate(type.outerTypeParameters, ts.map(node.typeArguments, getTypeFromTypeNode)));\n            }\n            if (node.typeArguments) {\n                error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));\n                return unknownType;\n            }\n            return type;\n        }", "language": "javascript", "code": "function getTypeFromClassOrInterfaceReference(node, symbol) {\n            var type = getDeclaredTypeOfSymbol(symbol);\n            var typeParameters = type.localTypeParameters;\n            if (typeParameters) {\n                if (!node.typeArguments || node.typeArguments.length !== typeParameters.length) {\n                    error(node, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(type, /*enclosingDeclaration*/ undefined, 1 /* WriteArrayAsGenericType */), typeParameters.length);\n                    return unknownType;\n                }\n                // In a type reference, the outer type parameters of the referenced class or interface are automatically\n                // supplied as type arguments and the type reference only specifies arguments for the local type parameters\n                // of the class or interface.\n                return createTypeReference(type, ts.concatenate(type.outerTypeParameters, ts.map(node.typeArguments, getTypeFromTypeNode)));\n            }\n            if (node.typeArguments) {\n                error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));\n                return unknownType;\n            }\n            return type;\n        }", "code_tokens": ["function", "getTypeFromClassOrInterfaceReference", "(", "node", ",", "symbol", ")", "{", "var", "type", "=", "getDeclaredTypeOfSymbol", "(", "symbol", ")", ";", "var", "typeParameters", "=", "type", ".", "localTypeParameters", ";", "if", "(", "typeParameters", ")", "{", "if", "(", "!", "node", ".", "typeArguments", "||", "node", ".", "typeArguments", ".", "length", "!==", "typeParameters", ".", "length", ")", "{", "error", "(", "node", ",", "ts", ".", "Diagnostics", ".", "Generic_type_0_requires_1_type_argument_s", ",", "typeToString", "(", "type", ",", "/*enclosingDeclaration*/", "undefined", ",", "1", "/* WriteArrayAsGenericType */", ")", ",", "typeParameters", ".", "length", ")", ";", "return", "unknownType", ";", "}", "// In a type reference, the outer type parameters of the referenced class or interface are automatically", "// supplied as type arguments and the type reference only specifies arguments for the local type parameters", "// of the class or interface.", "return", "createTypeReference", "(", "type", ",", "ts", ".", "concatenate", "(", "type", ".", "outerTypeParameters", ",", "ts", ".", "map", "(", "node", ".", "typeArguments", ",", "getTypeFromTypeNode", ")", ")", ")", ";", "}", "if", "(", "node", ".", "typeArguments", ")", "{", "error", "(", "node", ",", "ts", ".", "Diagnostics", ".", "Type_0_is_not_generic", ",", "typeToString", "(", "type", ")", ")", ";", "return", "unknownType", ";", "}", "return", "type", ";", "}"], "docstring": "Get type from reference to class or interface", "docstring_tokens": ["Get", "type", "from", "reference", "to", "class", "or", "interface"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L16958-L16976", "partition": "test"}
{"repo": "blinkylights23/grunt-swigtemplates", "path": "tasks/swigtemplates.js", "func_name": "handleI18nFiles", "original_string": "function handleI18nFiles(files) {\n      options.locales.forEach(function(locale) {\n        grunt.registerTask('swigtemplatesSubtask-' + locale, function() {\n          var done = this.async();\n          var translatorFactory = options.translateFunction(locale);\n          Q.when(translatorFactory, function(translator) { doTranslations(files, locale, translator) }).done(done);\n        });\n        grunt.task.run('swigtemplatesSubtask-' + locale);\n      });\n    }", "language": "javascript", "code": "function handleI18nFiles(files) {\n      options.locales.forEach(function(locale) {\n        grunt.registerTask('swigtemplatesSubtask-' + locale, function() {\n          var done = this.async();\n          var translatorFactory = options.translateFunction(locale);\n          Q.when(translatorFactory, function(translator) { doTranslations(files, locale, translator) }).done(done);\n        });\n        grunt.task.run('swigtemplatesSubtask-' + locale);\n      });\n    }", "code_tokens": ["function", "handleI18nFiles", "(", "files", ")", "{", "options", ".", "locales", ".", "forEach", "(", "function", "(", "locale", ")", "{", "grunt", ".", "registerTask", "(", "'swigtemplatesSubtask-'", "+", "locale", ",", "function", "(", ")", "{", "var", "done", "=", "this", ".", "async", "(", ")", ";", "var", "translatorFactory", "=", "options", ".", "translateFunction", "(", "locale", ")", ";", "Q", ".", "when", "(", "translatorFactory", ",", "function", "(", "translator", ")", "{", "doTranslations", "(", "files", ",", "locale", ",", "translator", ")", "}", ")", ".", "done", "(", "done", ")", ";", "}", ")", ";", "grunt", ".", "task", ".", "run", "(", "'swigtemplatesSubtask-'", "+", "locale", ")", ";", "}", ")", ";", "}"], "docstring": "Handle i18n files", "docstring_tokens": ["Handle", "i18n", "files"], "sha": "3a0d19f45aae7dc35efe3b5a08376be629498b7c", "url": "https://github.com/blinkylights23/grunt-swigtemplates/blob/3a0d19f45aae7dc35efe3b5a08376be629498b7c/tasks/swigtemplates.js#L92-L101", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getImmediatelyContainingArgumentInfo", "original_string": "function getImmediatelyContainingArgumentInfo(node) {\n                if (node.parent.kind === 168 /* CallExpression */ || node.parent.kind === 169 /* NewExpression */) {\n                    var callExpression = node.parent;\n                    // There are 3 cases to handle:\n                    //   1. The token introduces a list, and should begin a sig help session\n                    //   2. The token is either not associated with a list, or ends a list, so the session should end\n                    //   3. The token is buried inside a list, and should give sig help\n                    //\n                    // The following are examples of each:\n                    //\n                    //    Case 1:\n                    //          foo<#T, U>(#a, b)    -> The token introduces a list, and should begin a sig help session\n                    //    Case 2:\n                    //          fo#o<T, U>#(a, b)#   -> The token is either not associated with a list, or ends a list, so the session should end\n                    //    Case 3:\n                    //          foo<T#, U#>(a#, #b#) -> The token is buried inside a list, and should give sig help\n                    // Find out if 'node' is an argument, a type argument, or neither\n                    if (node.kind === 25 /* LessThanToken */ ||\n                        node.kind === 17 /* OpenParenToken */) {\n                        // Find the list that starts right *after* the < or ( token.\n                        // If the user has just opened a list, consider this item 0.\n                        var list = getChildListThatStartsWithOpenerToken(callExpression, node, sourceFile);\n                        var isTypeArgList = callExpression.typeArguments && callExpression.typeArguments.pos === list.pos;\n                        ts.Debug.assert(list !== undefined);\n                        return {\n                            kind: isTypeArgList ? 0 /* TypeArguments */ : 1 /* CallArguments */,\n                            invocation: callExpression,\n                            argumentsSpan: getApplicableSpanForArguments(list),\n                            argumentIndex: 0,\n                            argumentCount: getArgumentCount(list)\n                        };\n                    }\n                    // findListItemInfo can return undefined if we are not in parent's argument list\n                    // or type argument list. This includes cases where the cursor is:\n                    //   - To the right of the closing paren, non-substitution template, or template tail.\n                    //   - Between the type arguments and the arguments (greater than token)\n                    //   - On the target of the call (parent.func)\n                    //   - On the 'new' keyword in a 'new' expression\n                    var listItemInfo = ts.findListItemInfo(node);\n                    if (listItemInfo) {\n                        var list = listItemInfo.list;\n                        var isTypeArgList = callExpression.typeArguments && callExpression.typeArguments.pos === list.pos;\n                        var argumentIndex = getArgumentIndex(list, node);\n                        var argumentCount = getArgumentCount(list);\n                        ts.Debug.assert(argumentIndex === 0 || argumentIndex < argumentCount, \"argumentCount < argumentIndex, \" + argumentCount + \" < \" + argumentIndex);\n                        return {\n                            kind: isTypeArgList ? 0 /* TypeArguments */ : 1 /* CallArguments */,\n                            invocation: callExpression,\n                            argumentsSpan: getApplicableSpanForArguments(list),\n                            argumentIndex: argumentIndex,\n                            argumentCount: argumentCount\n                        };\n                    }\n                }\n                else if (node.kind === 11 /* NoSubstitutionTemplateLiteral */ && node.parent.kind === 170 /* TaggedTemplateExpression */) {\n                    // Check if we're actually inside the template;\n                    // otherwise we'll fall out and return undefined.\n                    if (ts.isInsideTemplateLiteral(node, position)) {\n                        return getArgumentListInfoForTemplate(node.parent, /*argumentIndex*/ 0);\n                    }\n                }\n                else if (node.kind === 12 /* TemplateHead */ && node.parent.parent.kind === 170 /* TaggedTemplateExpression */) {\n                    var templateExpression = node.parent;\n                    var tagExpression = templateExpression.parent;\n                    ts.Debug.assert(templateExpression.kind === 183 /* TemplateExpression */);\n                    var argumentIndex = ts.isInsideTemplateLiteral(node, position) ? 0 : 1;\n                    return getArgumentListInfoForTemplate(tagExpression, argumentIndex);\n                }\n                else if (node.parent.kind === 190 /* TemplateSpan */ && node.parent.parent.parent.kind === 170 /* TaggedTemplateExpression */) {\n                    var templateSpan = node.parent;\n                    var templateExpression = templateSpan.parent;\n                    var tagExpression = templateExpression.parent;\n                    ts.Debug.assert(templateExpression.kind === 183 /* TemplateExpression */);\n                    // If we're just after a template tail, don't show signature help.\n                    if (node.kind === 14 /* TemplateTail */ && !ts.isInsideTemplateLiteral(node, position)) {\n                        return undefined;\n                    }\n                    var spanIndex = templateExpression.templateSpans.indexOf(templateSpan);\n                    var argumentIndex = getArgumentIndexForTemplatePiece(spanIndex, node);\n                    return getArgumentListInfoForTemplate(tagExpression, argumentIndex);\n                }\n                return undefined;\n            }", "language": "javascript", "code": "function getImmediatelyContainingArgumentInfo(node) {\n                if (node.parent.kind === 168 /* CallExpression */ || node.parent.kind === 169 /* NewExpression */) {\n                    var callExpression = node.parent;\n                    // There are 3 cases to handle:\n                    //   1. The token introduces a list, and should begin a sig help session\n                    //   2. The token is either not associated with a list, or ends a list, so the session should end\n                    //   3. The token is buried inside a list, and should give sig help\n                    //\n                    // The following are examples of each:\n                    //\n                    //    Case 1:\n                    //          foo<#T, U>(#a, b)    -> The token introduces a list, and should begin a sig help session\n                    //    Case 2:\n                    //          fo#o<T, U>#(a, b)#   -> The token is either not associated with a list, or ends a list, so the session should end\n                    //    Case 3:\n                    //          foo<T#, U#>(a#, #b#) -> The token is buried inside a list, and should give sig help\n                    // Find out if 'node' is an argument, a type argument, or neither\n                    if (node.kind === 25 /* LessThanToken */ ||\n                        node.kind === 17 /* OpenParenToken */) {\n                        // Find the list that starts right *after* the < or ( token.\n                        // If the user has just opened a list, consider this item 0.\n                        var list = getChildListThatStartsWithOpenerToken(callExpression, node, sourceFile);\n                        var isTypeArgList = callExpression.typeArguments && callExpression.typeArguments.pos === list.pos;\n                        ts.Debug.assert(list !== undefined);\n                        return {\n                            kind: isTypeArgList ? 0 /* TypeArguments */ : 1 /* CallArguments */,\n                            invocation: callExpression,\n                            argumentsSpan: getApplicableSpanForArguments(list),\n                            argumentIndex: 0,\n                            argumentCount: getArgumentCount(list)\n                        };\n                    }\n                    // findListItemInfo can return undefined if we are not in parent's argument list\n                    // or type argument list. This includes cases where the cursor is:\n                    //   - To the right of the closing paren, non-substitution template, or template tail.\n                    //   - Between the type arguments and the arguments (greater than token)\n                    //   - On the target of the call (parent.func)\n                    //   - On the 'new' keyword in a 'new' expression\n                    var listItemInfo = ts.findListItemInfo(node);\n                    if (listItemInfo) {\n                        var list = listItemInfo.list;\n                        var isTypeArgList = callExpression.typeArguments && callExpression.typeArguments.pos === list.pos;\n                        var argumentIndex = getArgumentIndex(list, node);\n                        var argumentCount = getArgumentCount(list);\n                        ts.Debug.assert(argumentIndex === 0 || argumentIndex < argumentCount, \"argumentCount < argumentIndex, \" + argumentCount + \" < \" + argumentIndex);\n                        return {\n                            kind: isTypeArgList ? 0 /* TypeArguments */ : 1 /* CallArguments */,\n                            invocation: callExpression,\n                            argumentsSpan: getApplicableSpanForArguments(list),\n                            argumentIndex: argumentIndex,\n                            argumentCount: argumentCount\n                        };\n                    }\n                }\n                else if (node.kind === 11 /* NoSubstitutionTemplateLiteral */ && node.parent.kind === 170 /* TaggedTemplateExpression */) {\n                    // Check if we're actually inside the template;\n                    // otherwise we'll fall out and return undefined.\n                    if (ts.isInsideTemplateLiteral(node, position)) {\n                        return getArgumentListInfoForTemplate(node.parent, /*argumentIndex*/ 0);\n                    }\n                }\n                else if (node.kind === 12 /* TemplateHead */ && node.parent.parent.kind === 170 /* TaggedTemplateExpression */) {\n                    var templateExpression = node.parent;\n                    var tagExpression = templateExpression.parent;\n                    ts.Debug.assert(templateExpression.kind === 183 /* TemplateExpression */);\n                    var argumentIndex = ts.isInsideTemplateLiteral(node, position) ? 0 : 1;\n                    return getArgumentListInfoForTemplate(tagExpression, argumentIndex);\n                }\n                else if (node.parent.kind === 190 /* TemplateSpan */ && node.parent.parent.parent.kind === 170 /* TaggedTemplateExpression */) {\n                    var templateSpan = node.parent;\n                    var templateExpression = templateSpan.parent;\n                    var tagExpression = templateExpression.parent;\n                    ts.Debug.assert(templateExpression.kind === 183 /* TemplateExpression */);\n                    // If we're just after a template tail, don't show signature help.\n                    if (node.kind === 14 /* TemplateTail */ && !ts.isInsideTemplateLiteral(node, position)) {\n                        return undefined;\n                    }\n                    var spanIndex = templateExpression.templateSpans.indexOf(templateSpan);\n                    var argumentIndex = getArgumentIndexForTemplatePiece(spanIndex, node);\n                    return getArgumentListInfoForTemplate(tagExpression, argumentIndex);\n                }\n                return undefined;\n            }", "code_tokens": ["function", "getImmediatelyContainingArgumentInfo", "(", "node", ")", "{", "if", "(", "node", ".", "parent", ".", "kind", "===", "168", "/* CallExpression */", "||", "node", ".", "parent", ".", "kind", "===", "169", "/* NewExpression */", ")", "{", "var", "callExpression", "=", "node", ".", "parent", ";", "// There are 3 cases to handle:", "//   1. The token introduces a list, and should begin a sig help session", "//   2. The token is either not associated with a list, or ends a list, so the session should end", "//   3. The token is buried inside a list, and should give sig help", "//", "// The following are examples of each:", "//", "//    Case 1:", "//          foo<#T, U>(#a, b)    -> The token introduces a list, and should begin a sig help session", "//    Case 2:", "//          fo#o<T, U>#(a, b)#   -> The token is either not associated with a list, or ends a list, so the session should end", "//    Case 3:", "//          foo<T#, U#>(a#, #b#) -> The token is buried inside a list, and should give sig help", "// Find out if 'node' is an argument, a type argument, or neither", "if", "(", "node", ".", "kind", "===", "25", "/* LessThanToken */", "||", "node", ".", "kind", "===", "17", "/* OpenParenToken */", ")", "{", "// Find the list that starts right *after* the < or ( token.", "// If the user has just opened a list, consider this item 0.", "var", "list", "=", "getChildListThatStartsWithOpenerToken", "(", "callExpression", ",", "node", ",", "sourceFile", ")", ";", "var", "isTypeArgList", "=", "callExpression", ".", "typeArguments", "&&", "callExpression", ".", "typeArguments", ".", "pos", "===", "list", ".", "pos", ";", "ts", ".", "Debug", ".", "assert", "(", "list", "!==", "undefined", ")", ";", "return", "{", "kind", ":", "isTypeArgList", "?", "0", "/* TypeArguments */", ":", "1", "/* CallArguments */", ",", "invocation", ":", "callExpression", ",", "argumentsSpan", ":", "getApplicableSpanForArguments", "(", "list", ")", ",", "argumentIndex", ":", "0", ",", "argumentCount", ":", "getArgumentCount", "(", "list", ")", "}", ";", "}", "// findListItemInfo can return undefined if we are not in parent's argument list", "// or type argument list. This includes cases where the cursor is:", "//   - To the right of the closing paren, non-substitution template, or template tail.", "//   - Between the type arguments and the arguments (greater than token)", "//   - On the target of the call (parent.func)", "//   - On the 'new' keyword in a 'new' expression", "var", "listItemInfo", "=", "ts", ".", "findListItemInfo", "(", "node", ")", ";", "if", "(", "listItemInfo", ")", "{", "var", "list", "=", "listItemInfo", ".", "list", ";", "var", "isTypeArgList", "=", "callExpression", ".", "typeArguments", "&&", "callExpression", ".", "typeArguments", ".", "pos", "===", "list", ".", "pos", ";", "var", "argumentIndex", "=", "getArgumentIndex", "(", "list", ",", "node", ")", ";", "var", "argumentCount", "=", "getArgumentCount", "(", "list", ")", ";", "ts", ".", "Debug", ".", "assert", "(", "argumentIndex", "===", "0", "||", "argumentIndex", "<", "argumentCount", ",", "\"argumentCount < argumentIndex, \"", "+", "argumentCount", "+", "\" < \"", "+", "argumentIndex", ")", ";", "return", "{", "kind", ":", "isTypeArgList", "?", "0", "/* TypeArguments */", ":", "1", "/* CallArguments */", ",", "invocation", ":", "callExpression", ",", "argumentsSpan", ":", "getApplicableSpanForArguments", "(", "list", ")", ",", "argumentIndex", ":", "argumentIndex", ",", "argumentCount", ":", "argumentCount", "}", ";", "}", "}", "else", "if", "(", "node", ".", "kind", "===", "11", "/* NoSubstitutionTemplateLiteral */", "&&", "node", ".", "parent", ".", "kind", "===", "170", "/* TaggedTemplateExpression */", ")", "{", "// Check if we're actually inside the template;", "// otherwise we'll fall out and return undefined.", "if", "(", "ts", ".", "isInsideTemplateLiteral", "(", "node", ",", "position", ")", ")", "{", "return", "getArgumentListInfoForTemplate", "(", "node", ".", "parent", ",", "/*argumentIndex*/", "0", ")", ";", "}", "}", "else", "if", "(", "node", ".", "kind", "===", "12", "/* TemplateHead */", "&&", "node", ".", "parent", ".", "parent", ".", "kind", "===", "170", "/* TaggedTemplateExpression */", ")", "{", "var", "templateExpression", "=", "node", ".", "parent", ";", "var", "tagExpression", "=", "templateExpression", ".", "parent", ";", "ts", ".", "Debug", ".", "assert", "(", "templateExpression", ".", "kind", "===", "183", "/* TemplateExpression */", ")", ";", "var", "argumentIndex", "=", "ts", ".", "isInsideTemplateLiteral", "(", "node", ",", "position", ")", "?", "0", ":", "1", ";", "return", "getArgumentListInfoForTemplate", "(", "tagExpression", ",", "argumentIndex", ")", ";", "}", "else", "if", "(", "node", ".", "parent", ".", "kind", "===", "190", "/* TemplateSpan */", "&&", "node", ".", "parent", ".", "parent", ".", "parent", ".", "kind", "===", "170", "/* TaggedTemplateExpression */", ")", "{", "var", "templateSpan", "=", "node", ".", "parent", ";", "var", "templateExpression", "=", "templateSpan", ".", "parent", ";", "var", "tagExpression", "=", "templateExpression", ".", "parent", ";", "ts", ".", "Debug", ".", "assert", "(", "templateExpression", ".", "kind", "===", "183", "/* TemplateExpression */", ")", ";", "// If we're just after a template tail, don't show signature help.", "if", "(", "node", ".", "kind", "===", "14", "/* TemplateTail */", "&&", "!", "ts", ".", "isInsideTemplateLiteral", "(", "node", ",", "position", ")", ")", "{", "return", "undefined", ";", "}", "var", "spanIndex", "=", "templateExpression", ".", "templateSpans", ".", "indexOf", "(", "templateSpan", ")", ";", "var", "argumentIndex", "=", "getArgumentIndexForTemplatePiece", "(", "spanIndex", ",", "node", ")", ";", "return", "getArgumentListInfoForTemplate", "(", "tagExpression", ",", "argumentIndex", ")", ";", "}", "return", "undefined", ";", "}"], "docstring": "Returns relevant information for the argument list and the current argument if we are\nin the argument of an invocation; returns undefined otherwise.", "docstring_tokens": ["Returns", "relevant", "information", "for", "the", "argument", "list", "and", "the", "current", "argument", "if", "we", "are", "in", "the", "argument", "of", "an", "invocation", ";", "returns", "undefined", "otherwise", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L38955-L39037", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/core/utils/Dom.js", "func_name": "getIEPos", "original_string": "function getIEPos(node) {\n\t\t\tvar bodyElm, rect, x = 0, y = 0;\n\n\t\t\tif (node) {\n\t\t\t\trect = node.getBoundingClientRect();\n\t\t\t\tbodyElm = doc.compatMode === \"CSS1Compat\" ? doc.documentElement : doc.body;\n\t\t\t\tx = rect.left + bodyElm.scrollLeft;\n\t\t\t\ty = rect.top + bodyElm.scrollTop;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx : x,\n\t\t\t\ty : y\n\t\t\t};\n\t\t}", "language": "javascript", "code": "function getIEPos(node) {\n\t\t\tvar bodyElm, rect, x = 0, y = 0;\n\n\t\t\tif (node) {\n\t\t\t\trect = node.getBoundingClientRect();\n\t\t\t\tbodyElm = doc.compatMode === \"CSS1Compat\" ? doc.documentElement : doc.body;\n\t\t\t\tx = rect.left + bodyElm.scrollLeft;\n\t\t\t\ty = rect.top + bodyElm.scrollTop;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx : x,\n\t\t\t\ty : y\n\t\t\t};\n\t\t}", "code_tokens": ["function", "getIEPos", "(", "node", ")", "{", "var", "bodyElm", ",", "rect", ",", "x", "=", "0", ",", "y", "=", "0", ";", "if", "(", "node", ")", "{", "rect", "=", "node", ".", "getBoundingClientRect", "(", ")", ";", "bodyElm", "=", "doc", ".", "compatMode", "===", "\"CSS1Compat\"", "?", "doc", ".", "documentElement", ":", "doc", ".", "body", ";", "x", "=", "rect", ".", "left", "+", "bodyElm", ".", "scrollLeft", ";", "y", "=", "rect", ".", "top", "+", "bodyElm", ".", "scrollTop", ";", "}", "return", "{", "x", ":", "x", ",", "y", ":", "y", "}", ";", "}"], "docstring": "Returns the x, y cordinate for an element on IE 6 and IE 7", "docstring_tokens": ["Returns", "the", "x", "y", "cordinate", "for", "an", "element", "on", "IE", "6", "and", "IE", "7"], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Dom.js#L114-L128", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "callOnce", "original_string": "function callOnce (fn) {\n  let fulfilled = false;\n\n  return function onceWrapper (err) {\n    if (!fulfilled) {\n      fulfilled = true;\n      return fn.apply(this, arguments);\n    }\n    else if (err) {\n      // The callback has already been called, but now an error has occurred\n      // (most likely inside the callback function). So re-throw the error,\n      // so it gets handled further up the call stack\n      throw err;\n    }\n  };\n}", "language": "javascript", "code": "function callOnce (fn) {\n  let fulfilled = false;\n\n  return function onceWrapper (err) {\n    if (!fulfilled) {\n      fulfilled = true;\n      return fn.apply(this, arguments);\n    }\n    else if (err) {\n      // The callback has already been called, but now an error has occurred\n      // (most likely inside the callback function). So re-throw the error,\n      // so it gets handled further up the call stack\n      throw err;\n    }\n  };\n}", "code_tokens": ["function", "callOnce", "(", "fn", ")", "{", "let", "fulfilled", "=", "false", ";", "return", "function", "onceWrapper", "(", "err", ")", "{", "if", "(", "!", "fulfilled", ")", "{", "fulfilled", "=", "true", ";", "return", "fn", ".", "apply", "(", "this", ",", "arguments", ")", ";", "}", "else", "if", "(", "err", ")", "{", "// The callback has already been called, but now an error has occurred", "// (most likely inside the callback function). So re-throw the error,", "// so it gets handled further up the call stack", "throw", "err", ";", "}", "}", ";", "}"], "docstring": "Returns a wrapper function that ensures the given callback function is only called once.\nSubsequent calls are ignored, unless the first argument is an Error, in which case the\nerror is thrown.\n\n@param {function} fn - The function that should only be called once\n@returns {function}", "docstring_tokens": ["Returns", "a", "wrapper", "function", "that", "ensures", "the", "given", "callback", "function", "is", "only", "called", "once", ".", "Subsequent", "calls", "are", "ignored", "unless", "the", "first", "argument", "is", "an", "Error", "in", "which", "case", "the", "error", "is", "thrown", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L123-L138", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function() {\n    var namespaces = Ember.A(Ember.Namespace.NAMESPACES), types = Ember.A();\n\n    namespaces.forEach(function(namespace) {\n      for (var key in namespace) {\n        if (!namespace.hasOwnProperty(key)) { continue; }\n        var name = Ember.String.dasherize(key);\n        if (!(namespace instanceof Ember.Application) && namespace.toString()) {\n          name = namespace + '/' + name;\n        }\n        types.push(name);\n      }\n    });\n    return types;\n  }", "language": "javascript", "code": "function() {\n    var namespaces = Ember.A(Ember.Namespace.NAMESPACES), types = Ember.A();\n\n    namespaces.forEach(function(namespace) {\n      for (var key in namespace) {\n        if (!namespace.hasOwnProperty(key)) { continue; }\n        var name = Ember.String.dasherize(key);\n        if (!(namespace instanceof Ember.Application) && namespace.toString()) {\n          name = namespace + '/' + name;\n        }\n        types.push(name);\n      }\n    });\n    return types;\n  }", "code_tokens": ["function", "(", ")", "{", "var", "namespaces", "=", "Ember", ".", "A", "(", "Ember", ".", "Namespace", ".", "NAMESPACES", ")", ",", "types", "=", "Ember", ".", "A", "(", ")", ";", "namespaces", ".", "forEach", "(", "function", "(", "namespace", ")", "{", "for", "(", "var", "key", "in", "namespace", ")", "{", "if", "(", "!", "namespace", ".", "hasOwnProperty", "(", "key", ")", ")", "{", "continue", ";", "}", "var", "name", "=", "Ember", ".", "String", ".", "dasherize", "(", "key", ")", ";", "if", "(", "!", "(", "namespace", "instanceof", "Ember", ".", "Application", ")", "&&", "namespace", ".", "toString", "(", ")", ")", "{", "name", "=", "namespace", "+", "'/'", "+", "name", ";", "}", "types", ".", "push", "(", "name", ")", ";", "}", "}", ")", ";", "return", "types", ";", "}"], "docstring": "Loops over all namespaces and all objects\nattached to them\n\n@private\n@method _getObjectsOnNamespaces\n@return {Array} Array of model type strings", "docstring_tokens": ["Loops", "over", "all", "namespaces", "and", "all", "objects", "attached", "to", "them"], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L42122-L42136", "partition": "test"}
{"repo": "DTrejo/node-authors", "path": "lib/authors.js", "func_name": "lookupGithubLogin", "original_string": "function lookupGithubLogin (p, print, callback) {\n  var apiURI = 'https://api.github.com/search/users?q='\n  var options = { json: true, headers: { 'user-agent': pkg.name + '/' + pkg.version } }\n  if (process.env.OAUTH_TOKEN) {\n    options.headers['Authorization'] = 'token ' + process.env.OAUTH_TOKEN.trim()\n  }\n  function cb (err, p) {\n    callback(err, p)\n  }\n  if (print) process.stdout.write('.')\n\n  request(apiURI + encodeURIComponent(p.email + ' in:email type:user'), options, onEmail)\n  function onEmail (err, data) {\n    rateLimitExceeded = rateLimitExceeded || data.body.message\n    if (!err && data.body.items && data.body.items[0]) {\n      p.login = data.body.items[0].login\n      return cb(err, p)\n    }\n    request(apiURI + encodeURIComponent(p.name + ' in:fullname type:user'), options, onName)\n  }\n  function onName (err, data) {\n    rateLimitExceeded = rateLimitExceeded || data.body.message\n    if (!err && data.body.items && data.body.items[0]) {\n      p.login = data.body.items[0].login\n      return cb(err, p)\n    }\n    cb(err, p)\n  }\n}", "language": "javascript", "code": "function lookupGithubLogin (p, print, callback) {\n  var apiURI = 'https://api.github.com/search/users?q='\n  var options = { json: true, headers: { 'user-agent': pkg.name + '/' + pkg.version } }\n  if (process.env.OAUTH_TOKEN) {\n    options.headers['Authorization'] = 'token ' + process.env.OAUTH_TOKEN.trim()\n  }\n  function cb (err, p) {\n    callback(err, p)\n  }\n  if (print) process.stdout.write('.')\n\n  request(apiURI + encodeURIComponent(p.email + ' in:email type:user'), options, onEmail)\n  function onEmail (err, data) {\n    rateLimitExceeded = rateLimitExceeded || data.body.message\n    if (!err && data.body.items && data.body.items[0]) {\n      p.login = data.body.items[0].login\n      return cb(err, p)\n    }\n    request(apiURI + encodeURIComponent(p.name + ' in:fullname type:user'), options, onName)\n  }\n  function onName (err, data) {\n    rateLimitExceeded = rateLimitExceeded || data.body.message\n    if (!err && data.body.items && data.body.items[0]) {\n      p.login = data.body.items[0].login\n      return cb(err, p)\n    }\n    cb(err, p)\n  }\n}", "code_tokens": ["function", "lookupGithubLogin", "(", "p", ",", "print", ",", "callback", ")", "{", "var", "apiURI", "=", "'https://api.github.com/search/users?q='", "var", "options", "=", "{", "json", ":", "true", ",", "headers", ":", "{", "'user-agent'", ":", "pkg", ".", "name", "+", "'/'", "+", "pkg", ".", "version", "}", "}", "if", "(", "process", ".", "env", ".", "OAUTH_TOKEN", ")", "{", "options", ".", "headers", "[", "'Authorization'", "]", "=", "'token '", "+", "process", ".", "env", ".", "OAUTH_TOKEN", ".", "trim", "(", ")", "}", "function", "cb", "(", "err", ",", "p", ")", "{", "callback", "(", "err", ",", "p", ")", "}", "if", "(", "print", ")", "process", ".", "stdout", ".", "write", "(", "'.'", ")", "request", "(", "apiURI", "+", "encodeURIComponent", "(", "p", ".", "email", "+", "' in:email type:user'", ")", ",", "options", ",", "onEmail", ")", "function", "onEmail", "(", "err", ",", "data", ")", "{", "rateLimitExceeded", "=", "rateLimitExceeded", "||", "data", ".", "body", ".", "message", "if", "(", "!", "err", "&&", "data", ".", "body", ".", "items", "&&", "data", ".", "body", ".", "items", "[", "0", "]", ")", "{", "p", ".", "login", "=", "data", ".", "body", ".", "items", "[", "0", "]", ".", "login", "return", "cb", "(", "err", ",", "p", ")", "}", "request", "(", "apiURI", "+", "encodeURIComponent", "(", "p", ".", "name", "+", "' in:fullname type:user'", ")", ",", "options", ",", "onName", ")", "}", "function", "onName", "(", "err", ",", "data", ")", "{", "rateLimitExceeded", "=", "rateLimitExceeded", "||", "data", ".", "body", ".", "message", "if", "(", "!", "err", "&&", "data", ".", "body", ".", "items", "&&", "data", ".", "body", ".", "items", "[", "0", "]", ")", "{", "p", ".", "login", "=", "data", ".", "body", ".", "items", "[", "0", "]", ".", "login", "return", "cb", "(", "err", ",", "p", ")", "}", "cb", "(", "err", ",", "p", ")", "}", "}"], "docstring": "look for the email first. if no results, look for the name.", "docstring_tokens": ["look", "for", "the", "email", "first", ".", "if", "no", "results", "look", "for", "the", "name", "."], "sha": "60feb0695eb305f0b466ca14b05a2ecd0544c380", "url": "https://github.com/DTrejo/node-authors/blob/60feb0695eb305f0b466ca14b05a2ecd0544c380/lib/authors.js#L42-L70", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/cordova/util.js", "func_name": "deleteSvnFolders", "original_string": "function deleteSvnFolders (dir) {\n    var contents = fs.readdirSync(dir);\n    contents.forEach(function (entry) {\n        var fullpath = path.join(dir, entry);\n        if (isDirectory(fullpath)) {\n            if (entry === '.svn') {\n                fs.removeSync(fullpath);\n            } else module.exports.deleteSvnFolders(fullpath);\n        }\n    });\n}", "language": "javascript", "code": "function deleteSvnFolders (dir) {\n    var contents = fs.readdirSync(dir);\n    contents.forEach(function (entry) {\n        var fullpath = path.join(dir, entry);\n        if (isDirectory(fullpath)) {\n            if (entry === '.svn') {\n                fs.removeSync(fullpath);\n            } else module.exports.deleteSvnFolders(fullpath);\n        }\n    });\n}", "code_tokens": ["function", "deleteSvnFolders", "(", "dir", ")", "{", "var", "contents", "=", "fs", ".", "readdirSync", "(", "dir", ")", ";", "contents", ".", "forEach", "(", "function", "(", "entry", ")", "{", "var", "fullpath", "=", "path", ".", "join", "(", "dir", ",", "entry", ")", ";", "if", "(", "isDirectory", "(", "fullpath", ")", ")", "{", "if", "(", "entry", "===", "'.svn'", ")", "{", "fs", ".", "removeSync", "(", "fullpath", ")", ";", "}", "else", "module", ".", "exports", ".", "deleteSvnFolders", "(", "fullpath", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Recursively deletes .svn folders from a target path", "docstring_tokens": ["Recursively", "deletes", ".", "svn", "folders", "from", "a", "target", "path"], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/util.js#L212-L222", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/xhr/XMLHttpRequest.js", "func_name": "", "original_string": "function(method, url, async, user, password) {\n\t\t\t\tvar urlp;\n\n\t\t\t\t// first two arguments are required\n\t\t\t\tif (!method || !url) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.SYNTAX_ERR);\n\t\t\t\t}\n\n\t\t\t\t// 2 - check if any code point in method is higher than U+00FF or after deflating method it does not match the method\n\t\t\t\tif (/[\\u0100-\\uffff]/.test(method) || Encode.utf8_encode(method) !== method) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.SYNTAX_ERR);\n\t\t\t\t}\n\n\t\t\t\t// 3\n\t\t\t\tif (!!~Basic.inArray(method.toUpperCase(), ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'TRACE', 'TRACK'])) {\n\t\t\t\t\t_method = method.toUpperCase();\n\t\t\t\t}\n\n\n\t\t\t\t// 4 - allowing these methods poses a security risk\n\t\t\t\tif (!!~Basic.inArray(_method, ['CONNECT', 'TRACE', 'TRACK'])) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.SECURITY_ERR);\n\t\t\t\t}\n\n\t\t\t\t// 5\n\t\t\t\turl = Encode.utf8_encode(url);\n\n\t\t\t\t// 6 - Resolve url relative to the XMLHttpRequest base URL. If the algorithm returns an error, throw a \"SyntaxError\".\n\t\t\t\turlp = Url.parseUrl(url);\n\n\t\t\t\t_same_origin_flag = Url.hasSameOrigin(urlp);\n\n\t\t\t\t// 7 - manually build up absolute url\n\t\t\t\t_url = Url.resolveUrl(url);\n\n\t\t\t\t// 9-10, 12-13\n\t\t\t\tif ((user || password) && !_same_origin_flag) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);\n\t\t\t\t}\n\n\t\t\t\t_user = user || urlp.user;\n\t\t\t\t_password = password || urlp.pass;\n\n\t\t\t\t// 11\n\t\t\t\t_async = async || true;\n\n\t\t\t\tif (_async === false && (_p('timeout') || _p('withCredentials') || _p('responseType') !== \"\")) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);\n\t\t\t\t}\n\n\t\t\t\t// 14 - terminate abort()\n\n\t\t\t\t// 15 - terminate send()\n\n\t\t\t\t// 18\n\t\t\t\t_sync_flag = !_async;\n\t\t\t\t_send_flag = false;\n\t\t\t\t_headers = {};\n\t\t\t\t_reset.call(this);\n\n\t\t\t\t// 19\n\t\t\t\t_p('readyState', XMLHttpRequest.OPENED);\n\n\t\t\t\t// 20\n\t\t\t\tthis.dispatchEvent('readystatechange');\n\t\t\t}", "language": "javascript", "code": "function(method, url, async, user, password) {\n\t\t\t\tvar urlp;\n\n\t\t\t\t// first two arguments are required\n\t\t\t\tif (!method || !url) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.SYNTAX_ERR);\n\t\t\t\t}\n\n\t\t\t\t// 2 - check if any code point in method is higher than U+00FF or after deflating method it does not match the method\n\t\t\t\tif (/[\\u0100-\\uffff]/.test(method) || Encode.utf8_encode(method) !== method) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.SYNTAX_ERR);\n\t\t\t\t}\n\n\t\t\t\t// 3\n\t\t\t\tif (!!~Basic.inArray(method.toUpperCase(), ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'TRACE', 'TRACK'])) {\n\t\t\t\t\t_method = method.toUpperCase();\n\t\t\t\t}\n\n\n\t\t\t\t// 4 - allowing these methods poses a security risk\n\t\t\t\tif (!!~Basic.inArray(_method, ['CONNECT', 'TRACE', 'TRACK'])) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.SECURITY_ERR);\n\t\t\t\t}\n\n\t\t\t\t// 5\n\t\t\t\turl = Encode.utf8_encode(url);\n\n\t\t\t\t// 6 - Resolve url relative to the XMLHttpRequest base URL. If the algorithm returns an error, throw a \"SyntaxError\".\n\t\t\t\turlp = Url.parseUrl(url);\n\n\t\t\t\t_same_origin_flag = Url.hasSameOrigin(urlp);\n\n\t\t\t\t// 7 - manually build up absolute url\n\t\t\t\t_url = Url.resolveUrl(url);\n\n\t\t\t\t// 9-10, 12-13\n\t\t\t\tif ((user || password) && !_same_origin_flag) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);\n\t\t\t\t}\n\n\t\t\t\t_user = user || urlp.user;\n\t\t\t\t_password = password || urlp.pass;\n\n\t\t\t\t// 11\n\t\t\t\t_async = async || true;\n\n\t\t\t\tif (_async === false && (_p('timeout') || _p('withCredentials') || _p('responseType') !== \"\")) {\n\t\t\t\t\tthrow new x.DOMException(x.DOMException.INVALID_ACCESS_ERR);\n\t\t\t\t}\n\n\t\t\t\t// 14 - terminate abort()\n\n\t\t\t\t// 15 - terminate send()\n\n\t\t\t\t// 18\n\t\t\t\t_sync_flag = !_async;\n\t\t\t\t_send_flag = false;\n\t\t\t\t_headers = {};\n\t\t\t\t_reset.call(this);\n\n\t\t\t\t// 19\n\t\t\t\t_p('readyState', XMLHttpRequest.OPENED);\n\n\t\t\t\t// 20\n\t\t\t\tthis.dispatchEvent('readystatechange');\n\t\t\t}", "code_tokens": ["function", "(", "method", ",", "url", ",", "async", ",", "user", ",", "password", ")", "{", "var", "urlp", ";", "// first two arguments are required", "if", "(", "!", "method", "||", "!", "url", ")", "{", "throw", "new", "x", ".", "DOMException", "(", "x", ".", "DOMException", ".", "SYNTAX_ERR", ")", ";", "}", "// 2 - check if any code point in method is higher than U+00FF or after deflating method it does not match the method", "if", "(", "/", "[\\u0100-\\uffff]", "/", ".", "test", "(", "method", ")", "||", "Encode", ".", "utf8_encode", "(", "method", ")", "!==", "method", ")", "{", "throw", "new", "x", ".", "DOMException", "(", "x", ".", "DOMException", ".", "SYNTAX_ERR", ")", ";", "}", "// 3", "if", "(", "!", "!", "~", "Basic", ".", "inArray", "(", "method", ".", "toUpperCase", "(", ")", ",", "[", "'CONNECT'", ",", "'DELETE'", ",", "'GET'", ",", "'HEAD'", ",", "'OPTIONS'", ",", "'POST'", ",", "'PUT'", ",", "'TRACE'", ",", "'TRACK'", "]", ")", ")", "{", "_method", "=", "method", ".", "toUpperCase", "(", ")", ";", "}", "// 4 - allowing these methods poses a security risk", "if", "(", "!", "!", "~", "Basic", ".", "inArray", "(", "_method", ",", "[", "'CONNECT'", ",", "'TRACE'", ",", "'TRACK'", "]", ")", ")", "{", "throw", "new", "x", ".", "DOMException", "(", "x", ".", "DOMException", ".", "SECURITY_ERR", ")", ";", "}", "// 5", "url", "=", "Encode", ".", "utf8_encode", "(", "url", ")", ";", "// 6 - Resolve url relative to the XMLHttpRequest base URL. If the algorithm returns an error, throw a \"SyntaxError\".", "urlp", "=", "Url", ".", "parseUrl", "(", "url", ")", ";", "_same_origin_flag", "=", "Url", ".", "hasSameOrigin", "(", "urlp", ")", ";", "// 7 - manually build up absolute url", "_url", "=", "Url", ".", "resolveUrl", "(", "url", ")", ";", "// 9-10, 12-13", "if", "(", "(", "user", "||", "password", ")", "&&", "!", "_same_origin_flag", ")", "{", "throw", "new", "x", ".", "DOMException", "(", "x", ".", "DOMException", ".", "INVALID_ACCESS_ERR", ")", ";", "}", "_user", "=", "user", "||", "urlp", ".", "user", ";", "_password", "=", "password", "||", "urlp", ".", "pass", ";", "// 11", "_async", "=", "async", "||", "true", ";", "if", "(", "_async", "===", "false", "&&", "(", "_p", "(", "'timeout'", ")", "||", "_p", "(", "'withCredentials'", ")", "||", "_p", "(", "'responseType'", ")", "!==", "\"\"", ")", ")", "{", "throw", "new", "x", ".", "DOMException", "(", "x", ".", "DOMException", ".", "INVALID_ACCESS_ERR", ")", ";", "}", "// 14 - terminate abort()", "// 15 - terminate send()", "// 18", "_sync_flag", "=", "!", "_async", ";", "_send_flag", "=", "false", ";", "_headers", "=", "{", "}", ";", "_reset", ".", "call", "(", "this", ")", ";", "// 19", "_p", "(", "'readyState'", ",", "XMLHttpRequest", ".", "OPENED", ")", ";", "// 20", "this", ".", "dispatchEvent", "(", "'readystatechange'", ")", ";", "}"], "docstring": "Sets the request method, request URL, synchronous flag, request username, and request password.\n\nThrows a \"SyntaxError\" exception if one of the following is true:\n\nmethod is not a valid HTTP method.\nurl cannot be resolved.\nurl contains the \"user:password\" format in the userinfo production.\nThrows a \"SecurityError\" exception if method is a case-insensitive match for CONNECT, TRACE or TRACK.\n\nThrows an \"InvalidAccessError\" exception if one of the following is true:\n\nEither user or password is passed as argument and the origin of url does not match the XMLHttpRequest origin.\nThere is an associated XMLHttpRequest document and either the timeout attribute is not zero,\nthe withCredentials attribute is true, or the responseType attribute is not the empty string.\n\n\n@method open\n@param {String} method HTTP method to use on request\n@param {String} url URL to request\n@param {Boolean} [async=true] If false request will be done in synchronous manner. Asynchronous by default.\n@param {String} [user] Username to use in HTTP authentication process on server-side\n@param {String} [password] Password to use in HTTP authentication process on server-side", "docstring_tokens": ["Sets", "the", "request", "method", "request", "URL", "synchronous", "flag", "request", "username", "and", "request", "password", "."], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/xhr/XMLHttpRequest.js#L292-L357", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "evalOpts", "original_string": "function evalOpts(data, args) {\n    if (typeof data === \"function\") {\n      // `arguments` is an object, not array, in FF, so:\n      args = Array.prototype.slice.call(arguments);\n      data = data.apply(null, args.slice(1));\n    }\n    return data;\n  }", "language": "javascript", "code": "function evalOpts(data, args) {\n    if (typeof data === \"function\") {\n      // `arguments` is an object, not array, in FF, so:\n      args = Array.prototype.slice.call(arguments);\n      data = data.apply(null, args.slice(1));\n    }\n    return data;\n  }", "code_tokens": ["function", "evalOpts", "(", "data", ",", "args", ")", "{", "if", "(", "typeof", "data", "===", "\"function\"", ")", "{", "// `arguments` is an object, not array, in FF, so:", "args", "=", "Array", ".", "prototype", ".", "slice", ".", "call", "(", "arguments", ")", ";", "data", "=", "data", ".", "apply", "(", "null", ",", "args", ".", "slice", "(", "1", ")", ")", ";", "}", "return", "data", ";", "}"], "docstring": "If option is a function, evaluate it with given params\n@param {*} data\n@param {...} args arguments of a callback\n@returns {*}", "docstring_tokens": ["If", "option", "is", "a", "function", "evaluate", "it", "with", "given", "params"], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L1531-L1538", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/device/filesystem/Chrome.js", "func_name": "", "original_string": "function(config) {\n        var me = this;\n        config = Ext.device.filesystem.Abstract.prototype.requestFileSystem(config);\n\n        var successCallback = function(fs) {\n            var fileSystem = Ext.create('Ext.device.filesystem.FileSystem', fs);\n            config.success.call(config.scope || me, fileSystem);\n        };\n\n        if (config.type == window.PERSISTENT) {\n            if(navigator.webkitPersistentStorage) {\n                navigator.webkitPersistentStorage.requestQuota(config.size, function(grantedBytes) {\n                    window.webkitRequestFileSystem(\n                        config.type,\n                        grantedBytes,\n                        successCallback,\n                        config.failure\n                    );\n                })\n            }else {\n                window.webkitStorageInfo.requestQuota(window.PERSISTENT, config.size, function(grantedBytes) {\n                    window.webkitRequestFileSystem(\n                        config.type,\n                        grantedBytes,\n                        successCallback,\n                        config.failure\n                    );\n                })\n            }\n        } else {\n            window.webkitRequestFileSystem(\n                config.type,\n                config.size,\n                successCallback,\n                config.failure\n            );\n        }\n    }", "language": "javascript", "code": "function(config) {\n        var me = this;\n        config = Ext.device.filesystem.Abstract.prototype.requestFileSystem(config);\n\n        var successCallback = function(fs) {\n            var fileSystem = Ext.create('Ext.device.filesystem.FileSystem', fs);\n            config.success.call(config.scope || me, fileSystem);\n        };\n\n        if (config.type == window.PERSISTENT) {\n            if(navigator.webkitPersistentStorage) {\n                navigator.webkitPersistentStorage.requestQuota(config.size, function(grantedBytes) {\n                    window.webkitRequestFileSystem(\n                        config.type,\n                        grantedBytes,\n                        successCallback,\n                        config.failure\n                    );\n                })\n            }else {\n                window.webkitStorageInfo.requestQuota(window.PERSISTENT, config.size, function(grantedBytes) {\n                    window.webkitRequestFileSystem(\n                        config.type,\n                        grantedBytes,\n                        successCallback,\n                        config.failure\n                    );\n                })\n            }\n        } else {\n            window.webkitRequestFileSystem(\n                config.type,\n                config.size,\n                successCallback,\n                config.failure\n            );\n        }\n    }", "code_tokens": ["function", "(", "config", ")", "{", "var", "me", "=", "this", ";", "config", "=", "Ext", ".", "device", ".", "filesystem", ".", "Abstract", ".", "prototype", ".", "requestFileSystem", "(", "config", ")", ";", "var", "successCallback", "=", "function", "(", "fs", ")", "{", "var", "fileSystem", "=", "Ext", ".", "create", "(", "'Ext.device.filesystem.FileSystem'", ",", "fs", ")", ";", "config", ".", "success", ".", "call", "(", "config", ".", "scope", "||", "me", ",", "fileSystem", ")", ";", "}", ";", "if", "(", "config", ".", "type", "==", "window", ".", "PERSISTENT", ")", "{", "if", "(", "navigator", ".", "webkitPersistentStorage", ")", "{", "navigator", ".", "webkitPersistentStorage", ".", "requestQuota", "(", "config", ".", "size", ",", "function", "(", "grantedBytes", ")", "{", "window", ".", "webkitRequestFileSystem", "(", "config", ".", "type", ",", "grantedBytes", ",", "successCallback", ",", "config", ".", "failure", ")", ";", "}", ")", "}", "else", "{", "window", ".", "webkitStorageInfo", ".", "requestQuota", "(", "window", ".", "PERSISTENT", ",", "config", ".", "size", ",", "function", "(", "grantedBytes", ")", "{", "window", ".", "webkitRequestFileSystem", "(", "config", ".", "type", ",", "grantedBytes", ",", "successCallback", ",", "config", ".", "failure", ")", ";", "}", ")", "}", "}", "else", "{", "window", ".", "webkitRequestFileSystem", "(", "config", ".", "type", ",", "config", ".", "size", ",", "successCallback", ",", "config", ".", "failure", ")", ";", "}", "}"], "docstring": "Requests access to the Local File System\n\nvar me = this;\nvar fs = Ext.create(\"Ext.device.File\", {});\nfs.requestFileSystem({\ntype: window.PERSISTENT,\nsize: 1024 * 1024,\nsuccess: function(fileSystem) {\nme.fs = fileSystem;\n},\nfailure: function(err) {\nconsole.log(\"FileSystem Failure: \" + err.code);\n}\n});\n\n\n@param {Object} config An object which contains the follow options\n@param {Number} config.type\nwindow.TEMPORARY (0) or window.PERSISTENT (1)\n\n@param {Number} config.size\nStorage space, in Bytes, needed by the application\n\n@param {Function} config.success\nThe function called when the filesystem is returned successfully\n\n@param {FileSystem} config.success.fs\n\n@param {Function} config.failure\nThe function called when the filesystem request causes and error\n\n@param {FileError} config.failure.error", "docstring_tokens": ["Requests", "access", "to", "the", "Local", "File", "System"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/filesystem/Chrome.js#L41-L78", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/mediaType.js", "func_name": "parseAccept", "original_string": "function parseAccept(accept) {\n  var accepts = splitMediaTypes(accept);\n\n  for (var i = 0, j = 0; i < accepts.length; i++) {\n    var mediaType = parseMediaType(accepts[i].trim(), i);\n\n    if (mediaType) {\n      accepts[j++] = mediaType;\n    }\n  }\n\n  // trim accepts\n  accepts.length = j;\n\n  return accepts;\n}", "language": "javascript", "code": "function parseAccept(accept) {\n  var accepts = splitMediaTypes(accept);\n\n  for (var i = 0, j = 0; i < accepts.length; i++) {\n    var mediaType = parseMediaType(accepts[i].trim(), i);\n\n    if (mediaType) {\n      accepts[j++] = mediaType;\n    }\n  }\n\n  // trim accepts\n  accepts.length = j;\n\n  return accepts;\n}", "code_tokens": ["function", "parseAccept", "(", "accept", ")", "{", "var", "accepts", "=", "splitMediaTypes", "(", "accept", ")", ";", "for", "(", "var", "i", "=", "0", ",", "j", "=", "0", ";", "i", "<", "accepts", ".", "length", ";", "i", "++", ")", "{", "var", "mediaType", "=", "parseMediaType", "(", "accepts", "[", "i", "]", ".", "trim", "(", ")", ",", "i", ")", ";", "if", "(", "mediaType", ")", "{", "accepts", "[", "j", "++", "]", "=", "mediaType", ";", "}", "}", "// trim accepts", "accepts", ".", "length", "=", "j", ";", "return", "accepts", ";", "}"], "docstring": "Parse the Accept header.\n@private", "docstring_tokens": ["Parse", "the", "Accept", "header", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/mediaType.js#L31-L46", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/cordova/platform/index.js", "func_name": "platform", "original_string": "function platform (command, targets, opts) {\n    // CB-10519 wrap function code into promise so throwing error\n    // would result in promise rejection instead of uncaught exception\n    return Promise.resolve().then(function () {\n        var msg;\n        var projectRoot = cordova_util.cdProjectRoot();\n        var hooksRunner = new HooksRunner(projectRoot);\n\n        if (arguments.length === 0) command = 'ls';\n\n        if (targets && !(targets instanceof Array)) targets = [targets];\n\n        // TODO: wouldn't update need a platform, too? what about save?\n        if ((command === 'add' || command === 'rm' || command === 'remove') && (!targets || (targets instanceof Array && targets.length === 0))) {\n            msg = 'You need to qualify `' + command + '` with one or more platforms!';\n            return Promise.reject(new CordovaError(msg));\n        }\n\n        opts = opts || {};\n        opts.platforms = targets;\n        switch (command) {\n        case 'add':\n            return module.exports.add(hooksRunner, projectRoot, targets, opts);\n        case 'rm':\n        case 'remove':\n            return module.exports.remove(hooksRunner, projectRoot, targets, opts);\n        case 'update':\n        case 'up':\n            return module.exports.update(hooksRunner, projectRoot, targets, opts);\n        case 'check':\n            return module.exports.check(hooksRunner, projectRoot);\n        default:\n            return module.exports.list(hooksRunner, projectRoot, opts);\n        }\n    });\n}", "language": "javascript", "code": "function platform (command, targets, opts) {\n    // CB-10519 wrap function code into promise so throwing error\n    // would result in promise rejection instead of uncaught exception\n    return Promise.resolve().then(function () {\n        var msg;\n        var projectRoot = cordova_util.cdProjectRoot();\n        var hooksRunner = new HooksRunner(projectRoot);\n\n        if (arguments.length === 0) command = 'ls';\n\n        if (targets && !(targets instanceof Array)) targets = [targets];\n\n        // TODO: wouldn't update need a platform, too? what about save?\n        if ((command === 'add' || command === 'rm' || command === 'remove') && (!targets || (targets instanceof Array && targets.length === 0))) {\n            msg = 'You need to qualify `' + command + '` with one or more platforms!';\n            return Promise.reject(new CordovaError(msg));\n        }\n\n        opts = opts || {};\n        opts.platforms = targets;\n        switch (command) {\n        case 'add':\n            return module.exports.add(hooksRunner, projectRoot, targets, opts);\n        case 'rm':\n        case 'remove':\n            return module.exports.remove(hooksRunner, projectRoot, targets, opts);\n        case 'update':\n        case 'up':\n            return module.exports.update(hooksRunner, projectRoot, targets, opts);\n        case 'check':\n            return module.exports.check(hooksRunner, projectRoot);\n        default:\n            return module.exports.list(hooksRunner, projectRoot, opts);\n        }\n    });\n}", "code_tokens": ["function", "platform", "(", "command", ",", "targets", ",", "opts", ")", "{", "// CB-10519 wrap function code into promise so throwing error", "// would result in promise rejection instead of uncaught exception", "return", "Promise", ".", "resolve", "(", ")", ".", "then", "(", "function", "(", ")", "{", "var", "msg", ";", "var", "projectRoot", "=", "cordova_util", ".", "cdProjectRoot", "(", ")", ";", "var", "hooksRunner", "=", "new", "HooksRunner", "(", "projectRoot", ")", ";", "if", "(", "arguments", ".", "length", "===", "0", ")", "command", "=", "'ls'", ";", "if", "(", "targets", "&&", "!", "(", "targets", "instanceof", "Array", ")", ")", "targets", "=", "[", "targets", "]", ";", "// TODO: wouldn't update need a platform, too? what about save?", "if", "(", "(", "command", "===", "'add'", "||", "command", "===", "'rm'", "||", "command", "===", "'remove'", ")", "&&", "(", "!", "targets", "||", "(", "targets", "instanceof", "Array", "&&", "targets", ".", "length", "===", "0", ")", ")", ")", "{", "msg", "=", "'You need to qualify `'", "+", "command", "+", "'` with one or more platforms!'", ";", "return", "Promise", ".", "reject", "(", "new", "CordovaError", "(", "msg", ")", ")", ";", "}", "opts", "=", "opts", "||", "{", "}", ";", "opts", ".", "platforms", "=", "targets", ";", "switch", "(", "command", ")", "{", "case", "'add'", ":", "return", "module", ".", "exports", ".", "add", "(", "hooksRunner", ",", "projectRoot", ",", "targets", ",", "opts", ")", ";", "case", "'rm'", ":", "case", "'remove'", ":", "return", "module", ".", "exports", ".", "remove", "(", "hooksRunner", ",", "projectRoot", ",", "targets", ",", "opts", ")", ";", "case", "'update'", ":", "case", "'up'", ":", "return", "module", ".", "exports", ".", "update", "(", "hooksRunner", ",", "projectRoot", ",", "targets", ",", "opts", ")", ";", "case", "'check'", ":", "return", "module", ".", "exports", ".", "check", "(", "hooksRunner", ",", "projectRoot", ")", ";", "default", ":", "return", "module", ".", "exports", ".", "list", "(", "hooksRunner", ",", "projectRoot", ",", "opts", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Handles all cordova platform commands.\n@param {string} command - Command to execute (add, rm, ls, update, save)\n@param {Object[]} targets - Array containing platforms to execute commands on\n@param {Object} opts\n@returns {Promise}", "docstring_tokens": ["Handles", "all", "cordova", "platform", "commands", "."], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/platform/index.js#L49-L84", "partition": "test"}
{"repo": "SoftwarePlumbers/typed-patch", "path": "patch.js", "func_name": "fromJSON", "original_string": "function fromJSON(object) {\n        if (object instanceof ops.Op) return object; // If already patch, return it\n        if (object === undefined) return ops.NOP;\n        if (object.op) {\n            if (object.op === ops.Rpl.name)\n                return new ops.Rpl(object.data);\n            if (object.op === ops.Ins.name)\n                return new ops.Ins(object.data);\n            else if (object.op === ops.NOP.name)\n                return ops.NOP;\n            else if (object.op === ops.DEL.name)\n                return ops.DEL;\n            else if (object.op === ops.Mrg.name) \n                return new ops.Mrg(utils.map(object.data, fromJSON));\n            else if (object.op === ops.Map.name) \n                return new ops.Map(object.data.map(([key,op]) => [key, fromJSON(op)]));\n            else if (object.op === ops.Arr.name) \n                return new ops.Arr(object.data.map(([key,op]) => [key, fromJSON(op)]));\n            else throw new Error('unknown diff.op ' + object.op);\n        } else {\n            return new ops.Rpl(object);   \n        }    \n}", "language": "javascript", "code": "function fromJSON(object) {\n        if (object instanceof ops.Op) return object; // If already patch, return it\n        if (object === undefined) return ops.NOP;\n        if (object.op) {\n            if (object.op === ops.Rpl.name)\n                return new ops.Rpl(object.data);\n            if (object.op === ops.Ins.name)\n                return new ops.Ins(object.data);\n            else if (object.op === ops.NOP.name)\n                return ops.NOP;\n            else if (object.op === ops.DEL.name)\n                return ops.DEL;\n            else if (object.op === ops.Mrg.name) \n                return new ops.Mrg(utils.map(object.data, fromJSON));\n            else if (object.op === ops.Map.name) \n                return new ops.Map(object.data.map(([key,op]) => [key, fromJSON(op)]));\n            else if (object.op === ops.Arr.name) \n                return new ops.Arr(object.data.map(([key,op]) => [key, fromJSON(op)]));\n            else throw new Error('unknown diff.op ' + object.op);\n        } else {\n            return new ops.Rpl(object);   \n        }    \n}", "code_tokens": ["function", "fromJSON", "(", "object", ")", "{", "if", "(", "object", "instanceof", "ops", ".", "Op", ")", "return", "object", ";", "// If already patch, return it", "if", "(", "object", "===", "undefined", ")", "return", "ops", ".", "NOP", ";", "if", "(", "object", ".", "op", ")", "{", "if", "(", "object", ".", "op", "===", "ops", ".", "Rpl", ".", "name", ")", "return", "new", "ops", ".", "Rpl", "(", "object", ".", "data", ")", ";", "if", "(", "object", ".", "op", "===", "ops", ".", "Ins", ".", "name", ")", "return", "new", "ops", ".", "Ins", "(", "object", ".", "data", ")", ";", "else", "if", "(", "object", ".", "op", "===", "ops", ".", "NOP", ".", "name", ")", "return", "ops", ".", "NOP", ";", "else", "if", "(", "object", ".", "op", "===", "ops", ".", "DEL", ".", "name", ")", "return", "ops", ".", "DEL", ";", "else", "if", "(", "object", ".", "op", "===", "ops", ".", "Mrg", ".", "name", ")", "return", "new", "ops", ".", "Mrg", "(", "utils", ".", "map", "(", "object", ".", "data", ",", "fromJSON", ")", ")", ";", "else", "if", "(", "object", ".", "op", "===", "ops", ".", "Map", ".", "name", ")", "return", "new", "ops", ".", "Map", "(", "object", ".", "data", ".", "map", "(", "(", "[", "key", ",", "op", "]", ")", "=>", "[", "key", ",", "fromJSON", "(", "op", ")", "]", ")", ")", ";", "else", "if", "(", "object", ".", "op", "===", "ops", ".", "Arr", ".", "name", ")", "return", "new", "ops", ".", "Arr", "(", "object", ".", "data", ".", "map", "(", "(", "[", "key", ",", "op", "]", ")", "=>", "[", "key", ",", "fromJSON", "(", "op", ")", "]", ")", ")", ";", "else", "throw", "new", "Error", "(", "'unknown diff.op '", "+", "object", ".", "op", ")", ";", "}", "else", "{", "return", "new", "ops", ".", "Rpl", "(", "object", ")", ";", "}", "}"], "docstring": "Convert over-the-wire JSON format back into typed patch object", "docstring_tokens": ["Convert", "over", "-", "the", "-", "wire", "JSON", "format", "back", "into", "typed", "patch", "object"], "sha": "2f34206a74a11ca9866c399049ab6bd3b1d7518a", "url": "https://github.com/SoftwarePlumbers/typed-patch/blob/2f34206a74a11ca9866c399049ab6bd3b1d7518a/patch.js#L156-L178", "partition": "test"}
{"repo": "emmetio/codemirror-plugin", "path": "lib/autocomplete.js", "func_name": "getStylesheetCompletions", "original_string": "function getStylesheetCompletions(editor, pos, config) {\n\tconst line = editor.getLine(pos.line).slice(0, pos.ch);\n\tconst prefix = extractPrefix(line, /[\\w-@$]/);\n\n\tif (prefix) {\n\t\t// Make sure that current position precedes element name (e.g. not attribute,\n\t\t// class, id etc.)\n\t\tconst prefixRange = {\n\t\t\tfrom: { line: pos.line, ch: pos.ch - prefix.length },\n\t\t\tto: pos\n\t\t};\n\n\t\tif (config.options && config.options.property) {\n\t\t\tconst lowerProp = config.options.property.toLowerCase();\n\t\t\t// Find matching CSS property snippet for keyword completions\n\t\t\tconst completion = getSnippetCompletions(editor, pos, config)\n\t\t\t\t.find(item => item.property && item.property === lowerProp);\n\n\t\t\tif (completion && completion.keywords.length) {\n\t\t\t\treturn completion.keywords.map(kw => {\n\t\t\t\t\treturn kw.key.indexOf(prefix) === 0 && new EmmetCompletion('value', editor, prefixRange, kw.key, kw.preview, kw.snippet);\n\t\t\t\t}).filter(Boolean);\n\t\t\t}\n\t\t} else {\n\t\t\treturn getSnippetCompletions(editor, pos, config)\n\t\t\t\t.filter(completion => completion.key !== prefix && completion.key.indexOf(prefix) === 0)\n\t\t\t\t.map(completion => new EmmetCompletion('snippet', editor, prefixRange, completion.key, completion.preview, completion.snippet));\n\t\t}\n\t}\n\n\treturn [];\n}", "language": "javascript", "code": "function getStylesheetCompletions(editor, pos, config) {\n\tconst line = editor.getLine(pos.line).slice(0, pos.ch);\n\tconst prefix = extractPrefix(line, /[\\w-@$]/);\n\n\tif (prefix) {\n\t\t// Make sure that current position precedes element name (e.g. not attribute,\n\t\t// class, id etc.)\n\t\tconst prefixRange = {\n\t\t\tfrom: { line: pos.line, ch: pos.ch - prefix.length },\n\t\t\tto: pos\n\t\t};\n\n\t\tif (config.options && config.options.property) {\n\t\t\tconst lowerProp = config.options.property.toLowerCase();\n\t\t\t// Find matching CSS property snippet for keyword completions\n\t\t\tconst completion = getSnippetCompletions(editor, pos, config)\n\t\t\t\t.find(item => item.property && item.property === lowerProp);\n\n\t\t\tif (completion && completion.keywords.length) {\n\t\t\t\treturn completion.keywords.map(kw => {\n\t\t\t\t\treturn kw.key.indexOf(prefix) === 0 && new EmmetCompletion('value', editor, prefixRange, kw.key, kw.preview, kw.snippet);\n\t\t\t\t}).filter(Boolean);\n\t\t\t}\n\t\t} else {\n\t\t\treturn getSnippetCompletions(editor, pos, config)\n\t\t\t\t.filter(completion => completion.key !== prefix && completion.key.indexOf(prefix) === 0)\n\t\t\t\t.map(completion => new EmmetCompletion('snippet', editor, prefixRange, completion.key, completion.preview, completion.snippet));\n\t\t}\n\t}\n\n\treturn [];\n}", "code_tokens": ["function", "getStylesheetCompletions", "(", "editor", ",", "pos", ",", "config", ")", "{", "const", "line", "=", "editor", ".", "getLine", "(", "pos", ".", "line", ")", ".", "slice", "(", "0", ",", "pos", ".", "ch", ")", ";", "const", "prefix", "=", "extractPrefix", "(", "line", ",", "/", "[\\w-@$]", "/", ")", ";", "if", "(", "prefix", ")", "{", "// Make sure that current position precedes element name (e.g. not attribute,", "// class, id etc.)", "const", "prefixRange", "=", "{", "from", ":", "{", "line", ":", "pos", ".", "line", ",", "ch", ":", "pos", ".", "ch", "-", "prefix", ".", "length", "}", ",", "to", ":", "pos", "}", ";", "if", "(", "config", ".", "options", "&&", "config", ".", "options", ".", "property", ")", "{", "const", "lowerProp", "=", "config", ".", "options", ".", "property", ".", "toLowerCase", "(", ")", ";", "// Find matching CSS property snippet for keyword completions", "const", "completion", "=", "getSnippetCompletions", "(", "editor", ",", "pos", ",", "config", ")", ".", "find", "(", "item", "=>", "item", ".", "property", "&&", "item", ".", "property", "===", "lowerProp", ")", ";", "if", "(", "completion", "&&", "completion", ".", "keywords", ".", "length", ")", "{", "return", "completion", ".", "keywords", ".", "map", "(", "kw", "=>", "{", "return", "kw", ".", "key", ".", "indexOf", "(", "prefix", ")", "===", "0", "&&", "new", "EmmetCompletion", "(", "'value'", ",", "editor", ",", "prefixRange", ",", "kw", ".", "key", ",", "kw", ".", "preview", ",", "kw", ".", "snippet", ")", ";", "}", ")", ".", "filter", "(", "Boolean", ")", ";", "}", "}", "else", "{", "return", "getSnippetCompletions", "(", "editor", ",", "pos", ",", "config", ")", ".", "filter", "(", "completion", "=>", "completion", ".", "key", "!==", "prefix", "&&", "completion", ".", "key", ".", "indexOf", "(", "prefix", ")", "===", "0", ")", ".", "map", "(", "completion", "=>", "new", "EmmetCompletion", "(", "'snippet'", ",", "editor", ",", "prefixRange", ",", "completion", ".", "key", ",", "completion", ".", "preview", ",", "completion", ".", "snippet", ")", ")", ";", "}", "}", "return", "[", "]", ";", "}"], "docstring": "Returns completions for stylesheet syntaxes\n@param  {CodeMirror} editor\n@param  {CodeMirror.Position} pos Cursor position in editor\n@param  {Object} config Resolved Emmet config\n@return {EmmetCompletion[]}", "docstring_tokens": ["Returns", "completions", "for", "stylesheet", "syntaxes"], "sha": "2089c8b15b97858b82b33e6e81ee1b50954581c1", "url": "https://github.com/emmetio/codemirror-plugin/blob/2089c8b15b97858b82b33e6e81ee1b50954581c1/lib/autocomplete.js#L85-L116", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "examples/runner.js", "func_name": "getJsFiles", "original_string": "function getJsFiles(dir, fileArray) {\n  const files = fs.readdirSync(dir);\n  fileArray = fileArray || [];\n  files.forEach(function(file) {\n    if (file === 'node_modules') {\n      return;\n    }\n    if (fs.statSync(dir + file).isDirectory()) {\n      getJsFiles(dir + file + '/', fileArray);\n      return;\n    }\n    if (file.substring(file.length-3, file.length) !== '.js') {\n      return;\n    }\n    fileArray.push(dir+file);\n  });\n  return fileArray;\n}", "language": "javascript", "code": "function getJsFiles(dir, fileArray) {\n  const files = fs.readdirSync(dir);\n  fileArray = fileArray || [];\n  files.forEach(function(file) {\n    if (file === 'node_modules') {\n      return;\n    }\n    if (fs.statSync(dir + file).isDirectory()) {\n      getJsFiles(dir + file + '/', fileArray);\n      return;\n    }\n    if (file.substring(file.length-3, file.length) !== '.js') {\n      return;\n    }\n    fileArray.push(dir+file);\n  });\n  return fileArray;\n}", "code_tokens": ["function", "getJsFiles", "(", "dir", ",", "fileArray", ")", "{", "const", "files", "=", "fs", ".", "readdirSync", "(", "dir", ")", ";", "fileArray", "=", "fileArray", "||", "[", "]", ";", "files", ".", "forEach", "(", "function", "(", "file", ")", "{", "if", "(", "file", "===", "'node_modules'", ")", "{", "return", ";", "}", "if", "(", "fs", ".", "statSync", "(", "dir", "+", "file", ")", ".", "isDirectory", "(", ")", ")", "{", "getJsFiles", "(", "dir", "+", "file", "+", "'/'", ",", "fileArray", ")", ";", "return", ";", "}", "if", "(", "file", ".", "substring", "(", "file", ".", "length", "-", "3", ",", "file", ".", "length", ")", "!==", "'.js'", ")", "{", "return", ";", "}", "fileArray", ".", "push", "(", "dir", "+", "file", ")", ";", "}", ")", ";", "return", "fileArray", ";", "}"], "docstring": "This script is used to check that the samples run correctly.\nIt is not a valid example, see README.md and subdirectories for more information.\n List all js files in the directory", "docstring_tokens": ["This", "script", "is", "used", "to", "check", "that", "the", "samples", "run", "correctly", ".", "It", "is", "not", "a", "valid", "example", "see", "README", ".", "md", "and", "subdirectories", "for", "more", "information", ".", "List", "all", "js", "files", "in", "the", "directory"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/examples/runner.js#L14-L31", "partition": "test"}
{"repo": "appium/appium-xcuitest-driver", "path": "lib/wda/utils.js", "func_name": "resetProjectFile", "original_string": "async function resetProjectFile (agentPath) {\n  let projectFilePath = `${agentPath}/${PROJECT_FILE}`;\n  try {\n    // restore projectFilePath from .old file\n    if (!await fs.exists(`${projectFilePath}.old`)) {\n      return; // no need to reset\n    }\n    await fs.mv(`${projectFilePath}.old`, projectFilePath);\n    log.debug(`Successfully reset '${projectFilePath}' with bundle id '${WDA_RUNNER_BUNDLE_ID}'`);\n  } catch (err) {\n    log.debug(`Error resetting project file: ${err.message}`);\n    log.warn(`Unable to reset project file '${projectFilePath}' with ` +\n             `bundle id '${WDA_RUNNER_BUNDLE_ID}'. WebDriverAgent has been ` +\n             `modified and not returned to the original state.`);\n  }\n}", "language": "javascript", "code": "async function resetProjectFile (agentPath) {\n  let projectFilePath = `${agentPath}/${PROJECT_FILE}`;\n  try {\n    // restore projectFilePath from .old file\n    if (!await fs.exists(`${projectFilePath}.old`)) {\n      return; // no need to reset\n    }\n    await fs.mv(`${projectFilePath}.old`, projectFilePath);\n    log.debug(`Successfully reset '${projectFilePath}' with bundle id '${WDA_RUNNER_BUNDLE_ID}'`);\n  } catch (err) {\n    log.debug(`Error resetting project file: ${err.message}`);\n    log.warn(`Unable to reset project file '${projectFilePath}' with ` +\n             `bundle id '${WDA_RUNNER_BUNDLE_ID}'. WebDriverAgent has been ` +\n             `modified and not returned to the original state.`);\n  }\n}", "code_tokens": ["async", "function", "resetProjectFile", "(", "agentPath", ")", "{", "let", "projectFilePath", "=", "`", "${", "agentPath", "}", "${", "PROJECT_FILE", "}", "`", ";", "try", "{", "// restore projectFilePath from .old file", "if", "(", "!", "await", "fs", ".", "exists", "(", "`", "${", "projectFilePath", "}", "`", ")", ")", "{", "return", ";", "// no need to reset", "}", "await", "fs", ".", "mv", "(", "`", "${", "projectFilePath", "}", "`", ",", "projectFilePath", ")", ";", "log", ".", "debug", "(", "`", "${", "projectFilePath", "}", "${", "WDA_RUNNER_BUNDLE_ID", "}", "`", ")", ";", "}", "catch", "(", "err", ")", "{", "log", ".", "debug", "(", "`", "${", "err", ".", "message", "}", "`", ")", ";", "log", ".", "warn", "(", "`", "${", "projectFilePath", "}", "`", "+", "`", "${", "WDA_RUNNER_BUNDLE_ID", "}", "`", "+", "`", "`", ")", ";", "}", "}"], "docstring": "Reset WebDriverAgentRunner project bundle ID to correct state.\n@param {string} agentPath - Path to the .xcodeproj directory.", "docstring_tokens": ["Reset", "WebDriverAgentRunner", "project", "bundle", "ID", "to", "correct", "state", "."], "sha": "eb8c1348c390314c7ad12294f8eb5c2e52326f57", "url": "https://github.com/appium/appium-xcuitest-driver/blob/eb8c1348c390314c7ad12294f8eb5c2e52326f57/lib/wda/utils.js#L49-L64", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/platform/src/data/sync/CSV.js", "func_name": "", "original_string": "function(config,callback,scope) {\n\t\tvar changed= false;\n\t\tif (config) {\n\t\t\tconfig.config_id= 'csv';\n\t\t\tExt.data.CSV.superclass.constructor.call(this, config);\n\t\t\tif (config.v) {\n\t\t\t\tthis.v= [];\n\t\t\t\tthis.do_add(config.v);\n\t\t\t}\n\t\t}\n\t\tif (this.v===undefined) {\n\t\t\tthis.v= [];\n\t\t\tchanged= true;\n\t\t}\n\t\tthis.writeAndCallback(changed,callback,scope);\n\t}", "language": "javascript", "code": "function(config,callback,scope) {\n\t\tvar changed= false;\n\t\tif (config) {\n\t\t\tconfig.config_id= 'csv';\n\t\t\tExt.data.CSV.superclass.constructor.call(this, config);\n\t\t\tif (config.v) {\n\t\t\t\tthis.v= [];\n\t\t\t\tthis.do_add(config.v);\n\t\t\t}\n\t\t}\n\t\tif (this.v===undefined) {\n\t\t\tthis.v= [];\n\t\t\tchanged= true;\n\t\t}\n\t\tthis.writeAndCallback(changed,callback,scope);\n\t}", "code_tokens": ["function", "(", "config", ",", "callback", ",", "scope", ")", "{", "var", "changed", "=", "false", ";", "if", "(", "config", ")", "{", "config", ".", "config_id", "=", "'csv'", ";", "Ext", ".", "data", ".", "CSV", ".", "superclass", ".", "constructor", ".", "call", "(", "this", ",", "config", ")", ";", "if", "(", "config", ".", "v", ")", "{", "this", ".", "v", "=", "[", "]", ";", "this", ".", "do_add", "(", "config", ".", "v", ")", ";", "}", "}", "if", "(", "this", ".", "v", "===", "undefined", ")", "{", "this", ".", "v", "=", "[", "]", ";", "changed", "=", "true", ";", "}", "this", ".", "writeAndCallback", "(", "changed", ",", "callback", ",", "scope", ")", ";", "}"], "docstring": "array of change stamps", "docstring_tokens": ["array", "of", "change", "stamps"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/platform/src/data/sync/CSV.js#L6-L21", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getReferencedImportDeclaration", "original_string": "function getReferencedImportDeclaration(node) {\n            var symbol = getReferencedValueSymbol(node);\n            return symbol && symbol.flags & 8388608 /* Alias */ ? getDeclarationOfAliasSymbol(symbol) : undefined;\n        }", "language": "javascript", "code": "function getReferencedImportDeclaration(node) {\n            var symbol = getReferencedValueSymbol(node);\n            return symbol && symbol.flags & 8388608 /* Alias */ ? getDeclarationOfAliasSymbol(symbol) : undefined;\n        }", "code_tokens": ["function", "getReferencedImportDeclaration", "(", "node", ")", "{", "var", "symbol", "=", "getReferencedValueSymbol", "(", "node", ")", ";", "return", "symbol", "&&", "symbol", ".", "flags", "&", "8388608", "/* Alias */", "?", "getDeclarationOfAliasSymbol", "(", "symbol", ")", ":", "undefined", ";", "}"], "docstring": "When resolved as an expression identifier, if the given node references an import, return the declaration of that import. Otherwise, return undefined.", "docstring_tokens": ["When", "resolved", "as", "an", "expression", "identifier", "if", "the", "given", "node", "references", "an", "import", "return", "the", "declaration", "of", "that", "import", ".", "Otherwise", "return", "undefined", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L26438-L26441", "partition": "test"}
{"repo": "mcdcorp/opentest", "path": "server/src/public/js/ng/root-ctrl.js", "func_name": "parseVersion", "original_string": "function parseVersion(versionString) {\n\t\tif (typeof versionString !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar versionRegexMatch = versionString.match(/v?(\\d+)\\.(\\d+)\\.(\\d+)/i);\n\t\tif (versionRegexMatch) {\n\t\t\treturn [parseInt(versionRegexMatch[1]), parseInt(versionRegexMatch[2]), parseInt(versionRegexMatch[3])];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "javascript", "code": "function parseVersion(versionString) {\n\t\tif (typeof versionString !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar versionRegexMatch = versionString.match(/v?(\\d+)\\.(\\d+)\\.(\\d+)/i);\n\t\tif (versionRegexMatch) {\n\t\t\treturn [parseInt(versionRegexMatch[1]), parseInt(versionRegexMatch[2]), parseInt(versionRegexMatch[3])];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["function", "parseVersion", "(", "versionString", ")", "{", "if", "(", "typeof", "versionString", "!==", "'string'", ")", "{", "return", "null", ";", "}", "var", "versionRegexMatch", "=", "versionString", ".", "match", "(", "/", "v?(\\d+)\\.(\\d+)\\.(\\d+)", "/", "i", ")", ";", "if", "(", "versionRegexMatch", ")", "{", "return", "[", "parseInt", "(", "versionRegexMatch", "[", "1", "]", ")", ",", "parseInt", "(", "versionRegexMatch", "[", "2", "]", ")", ",", "parseInt", "(", "versionRegexMatch", "[", "3", "]", ")", "]", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "docstring": "Parses a semantic version string into an array of three integers.", "docstring_tokens": ["Parses", "a", "semantic", "version", "string", "into", "an", "array", "of", "three", "integers", "."], "sha": "302967ae09f3d92cd1438f04ed701b2a3006e598", "url": "https://github.com/mcdcorp/opentest/blob/302967ae09f3d92cd1438f04ed701b2a3006e598/server/src/public/js/ng/root-ctrl.js#L248-L259", "partition": "test"}
{"repo": "nfroidure/swagger-http-router", "path": "src/errorHandler.js", "func_name": "initErrorHandler", "original_string": "function initErrorHandler({\n  ENV = {},\n  DEBUG_NODE_ENVS = DEFAULT_DEBUG_NODE_ENVS,\n  STRINGIFYERS = DEFAULT_STRINGIFYERS,\n}) {\n  return Promise.resolve(errorHandler);\n\n  /**\n   * Handle an HTTP transaction error and\n   * map it to a serializable response\n   * @param  {String}  transactionId\n   * A raw NodeJS HTTP incoming message\n   * @param  {Object} responseSpec\n   * The response specification\n   * @param  {HTTPError} err\n   * The encountered error\n   * @return {Promise}\n   * A promise resolving when the operation\n   *  completes\n   */\n  function errorHandler(transactionId, responseSpec, err) {\n    return Promise.resolve().then(() => {\n      const response = {};\n\n      response.status = err.httpCode || 500;\n      response.headers = Object.assign({}, err.headers || {}, {\n        // Avoid caching errors\n        'cache-control': 'private',\n        // Fallback to the default stringifyer to always be\n        // able to display errors\n        'content-type':\n          responseSpec &&\n          responseSpec.contentTypes[0] &&\n          STRINGIFYERS[responseSpec.contentTypes[0]]\n            ? responseSpec.contentTypes[0]\n            : Object.keys(STRINGIFYERS)[0],\n      });\n\n      response.body = {\n        error: {\n          code: err.code || 'E_UNEXPECTED',\n          // Enjoy nerdy stuff:\n          // https://en.wikipedia.org/wiki/Guru_Meditation\n          guruMeditation: transactionId,\n        },\n      };\n\n      if (ENV && DEBUG_NODE_ENVS.includes(ENV.NODE_ENV)) {\n        response.body.error.stack = err.stack;\n        response.body.error.params = err.params;\n      }\n\n      return response;\n    });\n  }\n}", "language": "javascript", "code": "function initErrorHandler({\n  ENV = {},\n  DEBUG_NODE_ENVS = DEFAULT_DEBUG_NODE_ENVS,\n  STRINGIFYERS = DEFAULT_STRINGIFYERS,\n}) {\n  return Promise.resolve(errorHandler);\n\n  /**\n   * Handle an HTTP transaction error and\n   * map it to a serializable response\n   * @param  {String}  transactionId\n   * A raw NodeJS HTTP incoming message\n   * @param  {Object} responseSpec\n   * The response specification\n   * @param  {HTTPError} err\n   * The encountered error\n   * @return {Promise}\n   * A promise resolving when the operation\n   *  completes\n   */\n  function errorHandler(transactionId, responseSpec, err) {\n    return Promise.resolve().then(() => {\n      const response = {};\n\n      response.status = err.httpCode || 500;\n      response.headers = Object.assign({}, err.headers || {}, {\n        // Avoid caching errors\n        'cache-control': 'private',\n        // Fallback to the default stringifyer to always be\n        // able to display errors\n        'content-type':\n          responseSpec &&\n          responseSpec.contentTypes[0] &&\n          STRINGIFYERS[responseSpec.contentTypes[0]]\n            ? responseSpec.contentTypes[0]\n            : Object.keys(STRINGIFYERS)[0],\n      });\n\n      response.body = {\n        error: {\n          code: err.code || 'E_UNEXPECTED',\n          // Enjoy nerdy stuff:\n          // https://en.wikipedia.org/wiki/Guru_Meditation\n          guruMeditation: transactionId,\n        },\n      };\n\n      if (ENV && DEBUG_NODE_ENVS.includes(ENV.NODE_ENV)) {\n        response.body.error.stack = err.stack;\n        response.body.error.params = err.params;\n      }\n\n      return response;\n    });\n  }\n}", "code_tokens": ["function", "initErrorHandler", "(", "{", "ENV", "=", "{", "}", ",", "DEBUG_NODE_ENVS", "=", "DEFAULT_DEBUG_NODE_ENVS", ",", "STRINGIFYERS", "=", "DEFAULT_STRINGIFYERS", ",", "}", ")", "{", "return", "Promise", ".", "resolve", "(", "errorHandler", ")", ";", "/**\n   * Handle an HTTP transaction error and\n   * map it to a serializable response\n   * @param  {String}  transactionId\n   * A raw NodeJS HTTP incoming message\n   * @param  {Object} responseSpec\n   * The response specification\n   * @param  {HTTPError} err\n   * The encountered error\n   * @return {Promise}\n   * A promise resolving when the operation\n   *  completes\n   */", "function", "errorHandler", "(", "transactionId", ",", "responseSpec", ",", "err", ")", "{", "return", "Promise", ".", "resolve", "(", ")", ".", "then", "(", "(", ")", "=>", "{", "const", "response", "=", "{", "}", ";", "response", ".", "status", "=", "err", ".", "httpCode", "||", "500", ";", "response", ".", "headers", "=", "Object", ".", "assign", "(", "{", "}", ",", "err", ".", "headers", "||", "{", "}", ",", "{", "// Avoid caching errors", "'cache-control'", ":", "'private'", ",", "// Fallback to the default stringifyer to always be", "// able to display errors", "'content-type'", ":", "responseSpec", "&&", "responseSpec", ".", "contentTypes", "[", "0", "]", "&&", "STRINGIFYERS", "[", "responseSpec", ".", "contentTypes", "[", "0", "]", "]", "?", "responseSpec", ".", "contentTypes", "[", "0", "]", ":", "Object", ".", "keys", "(", "STRINGIFYERS", ")", "[", "0", "]", ",", "}", ")", ";", "response", ".", "body", "=", "{", "error", ":", "{", "code", ":", "err", ".", "code", "||", "'E_UNEXPECTED'", ",", "// Enjoy nerdy stuff:", "// https://en.wikipedia.org/wiki/Guru_Meditation", "guruMeditation", ":", "transactionId", ",", "}", ",", "}", ";", "if", "(", "ENV", "&&", "DEBUG_NODE_ENVS", ".", "includes", "(", "ENV", ".", "NODE_ENV", ")", ")", "{", "response", ".", "body", ".", "error", ".", "stack", "=", "err", ".", "stack", ";", "response", ".", "body", ".", "error", ".", "params", "=", "err", ".", "params", ";", "}", "return", "response", ";", "}", ")", ";", "}", "}"], "docstring": "Initialize an error handler for the\nHTTP router\n@param  {Object}   services\nThe services the server depends on\n@param  {Object}   [services.ENV]\nThe services the server depends on\n@param  {Array}   [services.DEBUG_NODE_ENVS]\nThe environnement that activate debugging\n(prints stack trace in HTTP errors responses)\n@param  {Object} [services.STRINGIFYERS]\nThe synchronous body stringifyers\n@return {Promise}\nA promise of a function to handle errors", "docstring_tokens": ["Initialize", "an", "error", "handler", "for", "the", "HTTP", "router"], "sha": "298e38c99170dc50c229cf922ebc801d19b03144", "url": "https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/errorHandler.js#L28-L83", "partition": "test"}
{"repo": "sapegin/fledermaus", "path": "src/renderers/markdown.js", "func_name": "render", "original_string": "function render(processor, source) {\n\ttry {\n\t\treturn processor.processSync(source).contents;\n\t} catch (exception) {\n\t\tconst error = `Error while rendering Markdown: ${exception.message}`;\n\t\tconsole.error(error);\n\t\treturn errorInlineHtml(error).toString();\n\t}\n}", "language": "javascript", "code": "function render(processor, source) {\n\ttry {\n\t\treturn processor.processSync(source).contents;\n\t} catch (exception) {\n\t\tconst error = `Error while rendering Markdown: ${exception.message}`;\n\t\tconsole.error(error);\n\t\treturn errorInlineHtml(error).toString();\n\t}\n}", "code_tokens": ["function", "render", "(", "processor", ",", "source", ")", "{", "try", "{", "return", "processor", ".", "processSync", "(", "source", ")", ".", "contents", ";", "}", "catch", "(", "exception", ")", "{", "const", "error", "=", "`", "${", "exception", ".", "message", "}", "`", ";", "console", ".", "error", "(", "error", ")", ";", "return", "errorInlineHtml", "(", "error", ")", ".", "toString", "(", ")", ";", "}", "}"], "docstring": "Render Markdow using given processor.\n\n@param {Object} processor Remark processor.\n@param {string} source Source Markdown.\n@return {string}", "docstring_tokens": ["Render", "Markdow", "using", "given", "processor", "."], "sha": "0c58b1ccd8a0bd82f066e63bd9ee391b0dd38ebc", "url": "https://github.com/sapegin/fledermaus/blob/0c58b1ccd8a0bd82f066e63bd9ee391b0dd38ebc/src/renderers/markdown.js#L134-L142", "partition": "test"}
{"repo": "ctr-lang/ctr", "path": "lib/ctr-nodes/index.js", "func_name": "", "original_string": "function (optionObj) {\n        //@hacky fix for #388\n        if (_.hasIn(optionObj, ['transitionDefault'])) {\n          _M._option.updateTransDefault(optionObj.transitionDefault);\n          delete optionObj.transitionDefault;\n        }\n        //cycle to check if it option object has any global opts\n        _.each(optionObj, function (val, key) {\n          //if sub-object\n          if (_.isObject(val)) {\n            _.each(val, function (_val, _key) {\n              mergeOption(_val, [key, _key]);\n            });\n          }else {\n            mergeOption(val, [key]);\n          }\n        });\n      }", "language": "javascript", "code": "function (optionObj) {\n        //@hacky fix for #388\n        if (_.hasIn(optionObj, ['transitionDefault'])) {\n          _M._option.updateTransDefault(optionObj.transitionDefault);\n          delete optionObj.transitionDefault;\n        }\n        //cycle to check if it option object has any global opts\n        _.each(optionObj, function (val, key) {\n          //if sub-object\n          if (_.isObject(val)) {\n            _.each(val, function (_val, _key) {\n              mergeOption(_val, [key, _key]);\n            });\n          }else {\n            mergeOption(val, [key]);\n          }\n        });\n      }", "code_tokens": ["function", "(", "optionObj", ")", "{", "//@hacky fix for #388", "if", "(", "_", ".", "hasIn", "(", "optionObj", ",", "[", "'transitionDefault'", "]", ")", ")", "{", "_M", ".", "_option", ".", "updateTransDefault", "(", "optionObj", ".", "transitionDefault", ")", ";", "delete", "optionObj", ".", "transitionDefault", ";", "}", "//cycle to check if it option object has any global opts", "_", ".", "each", "(", "optionObj", ",", "function", "(", "val", ",", "key", ")", "{", "//if sub-object", "if", "(", "_", ".", "isObject", "(", "val", ")", ")", "{", "_", ".", "each", "(", "val", ",", "function", "(", "_val", ",", "_key", ")", "{", "mergeOption", "(", "_val", ",", "[", "key", ",", "_key", "]", ")", ";", "}", ")", ";", "}", "else", "{", "mergeOption", "(", "val", ",", "[", "key", "]", ")", ";", "}", "}", ")", ";", "}"], "docstring": "wrapper for set option", "docstring_tokens": ["wrapper", "for", "set", "option"], "sha": "f73465cb7420bcc4f18a892a37529b3b366fb08a", "url": "https://github.com/ctr-lang/ctr/blob/f73465cb7420bcc4f18a892a37529b3b366fb08a/lib/ctr-nodes/index.js#L93-L110", "partition": "test"}
{"repo": "jeffijoe/keyblade", "path": "lib/keyblade.js", "func_name": "keyblade", "original_string": "function keyblade (obj, opts) {\n  opts = Object.assign({\n    message: _defaultMessage,\n    logBeforeThrow: true,\n    ignore: []\n  }, opts)\n  opts.ignore = (opts.ignore && Array.isArray(opts.ignore)) ? opts.ignore : []\n\n  return new Proxy(obj, {\n    get (target, propKey, receiver) {\n      const useGetter = Reflect.has(target, propKey, receiver) || _isReserved(propKey, opts.ignore)\n      if (useGetter) {\n        return Reflect.get(target, propKey, receiver)\n      }\n\n      // Leave symbols alone.\n      if (typeof propKey === 'symbol') {\n        return Reflect.get(target, propKey, receiver)\n      }\n\n      const message = opts.message(propKey)\n      if (opts.logBeforeThrow) {\n        if (typeof opts.logBeforeThrow === 'function') {\n          opts.logBeforeThrow(message, propKey)\n        } else {\n          console.error(message)\n        }\n      }\n\n      throw new UndefinedKeyError(message)\n    }\n  })\n}", "language": "javascript", "code": "function keyblade (obj, opts) {\n  opts = Object.assign({\n    message: _defaultMessage,\n    logBeforeThrow: true,\n    ignore: []\n  }, opts)\n  opts.ignore = (opts.ignore && Array.isArray(opts.ignore)) ? opts.ignore : []\n\n  return new Proxy(obj, {\n    get (target, propKey, receiver) {\n      const useGetter = Reflect.has(target, propKey, receiver) || _isReserved(propKey, opts.ignore)\n      if (useGetter) {\n        return Reflect.get(target, propKey, receiver)\n      }\n\n      // Leave symbols alone.\n      if (typeof propKey === 'symbol') {\n        return Reflect.get(target, propKey, receiver)\n      }\n\n      const message = opts.message(propKey)\n      if (opts.logBeforeThrow) {\n        if (typeof opts.logBeforeThrow === 'function') {\n          opts.logBeforeThrow(message, propKey)\n        } else {\n          console.error(message)\n        }\n      }\n\n      throw new UndefinedKeyError(message)\n    }\n  })\n}", "code_tokens": ["function", "keyblade", "(", "obj", ",", "opts", ")", "{", "opts", "=", "Object", ".", "assign", "(", "{", "message", ":", "_defaultMessage", ",", "logBeforeThrow", ":", "true", ",", "ignore", ":", "[", "]", "}", ",", "opts", ")", "opts", ".", "ignore", "=", "(", "opts", ".", "ignore", "&&", "Array", ".", "isArray", "(", "opts", ".", "ignore", ")", ")", "?", "opts", ".", "ignore", ":", "[", "]", "return", "new", "Proxy", "(", "obj", ",", "{", "get", "(", "target", ",", "propKey", ",", "receiver", ")", "{", "const", "useGetter", "=", "Reflect", ".", "has", "(", "target", ",", "propKey", ",", "receiver", ")", "||", "_isReserved", "(", "propKey", ",", "opts", ".", "ignore", ")", "if", "(", "useGetter", ")", "{", "return", "Reflect", ".", "get", "(", "target", ",", "propKey", ",", "receiver", ")", "}", "// Leave symbols alone.", "if", "(", "typeof", "propKey", "===", "'symbol'", ")", "{", "return", "Reflect", ".", "get", "(", "target", ",", "propKey", ",", "receiver", ")", "}", "const", "message", "=", "opts", ".", "message", "(", "propKey", ")", "if", "(", "opts", ".", "logBeforeThrow", ")", "{", "if", "(", "typeof", "opts", ".", "logBeforeThrow", "===", "'function'", ")", "{", "opts", ".", "logBeforeThrow", "(", "message", ",", "propKey", ")", "}", "else", "{", "console", ".", "error", "(", "message", ")", "}", "}", "throw", "new", "UndefinedKeyError", "(", "message", ")", "}", "}", ")", "}"], "docstring": "Protects the given object by wrapping it in a Proxy.\n\n@param  {object} obj\nThe object to wrap.\n\n@param  {(string) => string} opts.message\nOptional function used to construct the error message.\nWill get the key passed as the only argument.\n\n@param {string[]} ignore\nFields to ignore.\n\n@param {bool|Function(message: string, key: string)}\nIf specified, and is a function, is invoked before throwing.\nIf specified, and is truthy, `console.error` before throwing.\n\n@return {Proxy<object>}", "docstring_tokens": ["Protects", "the", "given", "object", "by", "wrapping", "it", "in", "a", "Proxy", "."], "sha": "f879e6ed451ec199166fd511c4dbbe30d77419c6", "url": "https://github.com/jeffijoe/keyblade/blob/f879e6ed451ec199166fd511c4dbbe30d77419c6/lib/keyblade.js#L24-L56", "partition": "test"}
{"repo": "mysticatea/eslint-utils", "path": "src/reference-tracker.js", "func_name": "isModifiedGlobal", "original_string": "function isModifiedGlobal(variable) {\n    return (\n        variable == null ||\n        variable.defs.length !== 0 ||\n        variable.references.some(r => r.isWrite())\n    )\n}", "language": "javascript", "code": "function isModifiedGlobal(variable) {\n    return (\n        variable == null ||\n        variable.defs.length !== 0 ||\n        variable.references.some(r => r.isWrite())\n    )\n}", "code_tokens": ["function", "isModifiedGlobal", "(", "variable", ")", "{", "return", "(", "variable", "==", "null", "||", "variable", ".", "defs", ".", "length", "!==", "0", "||", "variable", ".", "references", ".", "some", "(", "r", "=>", "r", ".", "isWrite", "(", ")", ")", ")", "}"], "docstring": "Check whether a given variable is modified or not.\n@param {Variable} variable The variable to check.\n@returns {boolean} `true` if the variable is modified.", "docstring_tokens": ["Check", "whether", "a", "given", "variable", "is", "modified", "or", "not", "."], "sha": "b2041e47f3c74e00ef7b746c4b0c43fc3f4732f0", "url": "https://github.com/mysticatea/eslint-utils/blob/b2041e47f3c74e00ef7b746c4b0c43fc3f4732f0/src/reference-tracker.js#L21-L27", "partition": "test"}
{"repo": "makeomatic/ms-users-restify", "path": "src/endpoints/register.js", "func_name": "transformBody", "original_string": "function transformBody(req, input) {\n  req.log.debug('attempting transformation', input);\n\n  const body = input.data;\n  const { attributes } = body;\n  const { password, referral } = attributes;\n  const { autoGeneratePassword } = config;\n\n  if (autoGeneratePassword === true && password) {\n    throw new Errors.ValidationError('password is auto-generated, do not pass it', 400);\n  }\n\n  if (autoGeneratePassword === false && !password) {\n    throw new Errors.ValidationError('password must be provided', 400);\n  }\n\n  const { country } = body;\n  if (country && !countryData.info(country, 'ISO3')) {\n    const err = `country name must be specified as ISO3.\n    Please refer to https://github.com/therebelrobot/countryjs#info for a complete list of codes`;\n    throw new Errors.ValidationError(err, 400, 'data.country');\n  }\n\n  const message = {\n    username: body.id,\n    metadata: ld.pick(attributes, WHITE_LIST),\n    activate: config.usersRequireActivate !== true || !password,\n    audience: getAudience(),\n    ipaddress: proxyaddr(req, config.trustProxy),\n  };\n\n  if (password) {\n    message.password = password;\n  }\n\n  if (attributes.alias) {\n    message.alias = attributes.alias.toLowerCase();\n  }\n\n  if (referral) {\n    message.referral = referral;\n  }\n\n  // BC, remap additionalInformation to longDescription if it is not provided\n  if (attributes.additionalInformation && !message.metadata.longDescription) {\n    message.metadata.longDescription = attributes.additionalInformation;\n  }\n\n  return message;\n}", "language": "javascript", "code": "function transformBody(req, input) {\n  req.log.debug('attempting transformation', input);\n\n  const body = input.data;\n  const { attributes } = body;\n  const { password, referral } = attributes;\n  const { autoGeneratePassword } = config;\n\n  if (autoGeneratePassword === true && password) {\n    throw new Errors.ValidationError('password is auto-generated, do not pass it', 400);\n  }\n\n  if (autoGeneratePassword === false && !password) {\n    throw new Errors.ValidationError('password must be provided', 400);\n  }\n\n  const { country } = body;\n  if (country && !countryData.info(country, 'ISO3')) {\n    const err = `country name must be specified as ISO3.\n    Please refer to https://github.com/therebelrobot/countryjs#info for a complete list of codes`;\n    throw new Errors.ValidationError(err, 400, 'data.country');\n  }\n\n  const message = {\n    username: body.id,\n    metadata: ld.pick(attributes, WHITE_LIST),\n    activate: config.usersRequireActivate !== true || !password,\n    audience: getAudience(),\n    ipaddress: proxyaddr(req, config.trustProxy),\n  };\n\n  if (password) {\n    message.password = password;\n  }\n\n  if (attributes.alias) {\n    message.alias = attributes.alias.toLowerCase();\n  }\n\n  if (referral) {\n    message.referral = referral;\n  }\n\n  // BC, remap additionalInformation to longDescription if it is not provided\n  if (attributes.additionalInformation && !message.metadata.longDescription) {\n    message.metadata.longDescription = attributes.additionalInformation;\n  }\n\n  return message;\n}", "code_tokens": ["function", "transformBody", "(", "req", ",", "input", ")", "{", "req", ".", "log", ".", "debug", "(", "'attempting transformation'", ",", "input", ")", ";", "const", "body", "=", "input", ".", "data", ";", "const", "{", "attributes", "}", "=", "body", ";", "const", "{", "password", ",", "referral", "}", "=", "attributes", ";", "const", "{", "autoGeneratePassword", "}", "=", "config", ";", "if", "(", "autoGeneratePassword", "===", "true", "&&", "password", ")", "{", "throw", "new", "Errors", ".", "ValidationError", "(", "'password is auto-generated, do not pass it'", ",", "400", ")", ";", "}", "if", "(", "autoGeneratePassword", "===", "false", "&&", "!", "password", ")", "{", "throw", "new", "Errors", ".", "ValidationError", "(", "'password must be provided'", ",", "400", ")", ";", "}", "const", "{", "country", "}", "=", "body", ";", "if", "(", "country", "&&", "!", "countryData", ".", "info", "(", "country", ",", "'ISO3'", ")", ")", "{", "const", "err", "=", "`", "`", ";", "throw", "new", "Errors", ".", "ValidationError", "(", "err", ",", "400", ",", "'data.country'", ")", ";", "}", "const", "message", "=", "{", "username", ":", "body", ".", "id", ",", "metadata", ":", "ld", ".", "pick", "(", "attributes", ",", "WHITE_LIST", ")", ",", "activate", ":", "config", ".", "usersRequireActivate", "!==", "true", "||", "!", "password", ",", "audience", ":", "getAudience", "(", ")", ",", "ipaddress", ":", "proxyaddr", "(", "req", ",", "config", ".", "trustProxy", ")", ",", "}", ";", "if", "(", "password", ")", "{", "message", ".", "password", "=", "password", ";", "}", "if", "(", "attributes", ".", "alias", ")", "{", "message", ".", "alias", "=", "attributes", ".", "alias", ".", "toLowerCase", "(", ")", ";", "}", "if", "(", "referral", ")", "{", "message", ".", "referral", "=", "referral", ";", "}", "// BC, remap additionalInformation to longDescription if it is not provided", "if", "(", "attributes", ".", "additionalInformation", "&&", "!", "message", ".", "metadata", ".", "longDescription", ")", "{", "message", ".", "metadata", ".", "longDescription", "=", "attributes", ".", "additionalInformation", ";", "}", "return", "message", ";", "}"], "docstring": "Transform body into ms-users message\n@param  {Request} req\n@param  {Object}  body\n@return {Object}", "docstring_tokens": ["Transform", "body", "into", "ms", "-", "users", "message"], "sha": "f6c1e464458eb35c1dd62ce0bf648a560d6759e0", "url": "https://github.com/makeomatic/ms-users-restify/blob/f6c1e464458eb35c1dd62ce0bf648a560d6759e0/src/endpoints/register.js#L37-L86", "partition": "test"}
{"repo": "wjbryant/taboverride", "path": "build/output/taboverride.js", "func_name": "isValidModifierKeyCombo", "original_string": "function isValidModifierKeyCombo(modifierKeys, e) {\n        var modifierKeyNames = ['alt', 'ctrl', 'meta', 'shift'],\n            numModKeys = modifierKeys.length,\n            i,\n            j,\n            currModifierKey,\n            isValid = true;\n\n        // check that all required modifier keys were pressed\n        for (i = 0; i < numModKeys; i += 1) {\n            if (!e[modifierKeys[i]]) {\n                isValid = false;\n                break;\n            }\n        }\n\n        // if the requirements were met, check for additional modifier keys\n        if (isValid) {\n            for (i = 0; i < modifierKeyNames.length; i += 1) {\n                currModifierKey = modifierKeyNames[i] + 'Key';\n\n                // if this key was pressed\n                if (e[currModifierKey]) {\n                    // if there are required keys, check whether the current key\n                    // is required\n                    if (numModKeys) {\n                        isValid = false;\n\n                        // if this is a required key, continue\n                        for (j = 0; j < numModKeys; j += 1) {\n                            if (currModifierKey === modifierKeys[j]) {\n                                isValid = true;\n                                break;\n                            }\n                        }\n                    } else {\n                        // no required keys, but one was pressed\n                        isValid = false;\n                    }\n                }\n\n                // an extra key was pressed, don't check anymore\n                if (!isValid) {\n                    break;\n                }\n            }\n        }\n\n        return isValid;\n    }", "language": "javascript", "code": "function isValidModifierKeyCombo(modifierKeys, e) {\n        var modifierKeyNames = ['alt', 'ctrl', 'meta', 'shift'],\n            numModKeys = modifierKeys.length,\n            i,\n            j,\n            currModifierKey,\n            isValid = true;\n\n        // check that all required modifier keys were pressed\n        for (i = 0; i < numModKeys; i += 1) {\n            if (!e[modifierKeys[i]]) {\n                isValid = false;\n                break;\n            }\n        }\n\n        // if the requirements were met, check for additional modifier keys\n        if (isValid) {\n            for (i = 0; i < modifierKeyNames.length; i += 1) {\n                currModifierKey = modifierKeyNames[i] + 'Key';\n\n                // if this key was pressed\n                if (e[currModifierKey]) {\n                    // if there are required keys, check whether the current key\n                    // is required\n                    if (numModKeys) {\n                        isValid = false;\n\n                        // if this is a required key, continue\n                        for (j = 0; j < numModKeys; j += 1) {\n                            if (currModifierKey === modifierKeys[j]) {\n                                isValid = true;\n                                break;\n                            }\n                        }\n                    } else {\n                        // no required keys, but one was pressed\n                        isValid = false;\n                    }\n                }\n\n                // an extra key was pressed, don't check anymore\n                if (!isValid) {\n                    break;\n                }\n            }\n        }\n\n        return isValid;\n    }", "code_tokens": ["function", "isValidModifierKeyCombo", "(", "modifierKeys", ",", "e", ")", "{", "var", "modifierKeyNames", "=", "[", "'alt'", ",", "'ctrl'", ",", "'meta'", ",", "'shift'", "]", ",", "numModKeys", "=", "modifierKeys", ".", "length", ",", "i", ",", "j", ",", "currModifierKey", ",", "isValid", "=", "true", ";", "// check that all required modifier keys were pressed", "for", "(", "i", "=", "0", ";", "i", "<", "numModKeys", ";", "i", "+=", "1", ")", "{", "if", "(", "!", "e", "[", "modifierKeys", "[", "i", "]", "]", ")", "{", "isValid", "=", "false", ";", "break", ";", "}", "}", "// if the requirements were met, check for additional modifier keys", "if", "(", "isValid", ")", "{", "for", "(", "i", "=", "0", ";", "i", "<", "modifierKeyNames", ".", "length", ";", "i", "+=", "1", ")", "{", "currModifierKey", "=", "modifierKeyNames", "[", "i", "]", "+", "'Key'", ";", "// if this key was pressed", "if", "(", "e", "[", "currModifierKey", "]", ")", "{", "// if there are required keys, check whether the current key", "// is required", "if", "(", "numModKeys", ")", "{", "isValid", "=", "false", ";", "// if this is a required key, continue", "for", "(", "j", "=", "0", ";", "j", "<", "numModKeys", ";", "j", "+=", "1", ")", "{", "if", "(", "currModifierKey", "===", "modifierKeys", "[", "j", "]", ")", "{", "isValid", "=", "true", ";", "break", ";", "}", "}", "}", "else", "{", "// no required keys, but one was pressed", "isValid", "=", "false", ";", "}", "}", "// an extra key was pressed, don't check anymore", "if", "(", "!", "isValid", ")", "{", "break", ";", "}", "}", "}", "return", "isValid", ";", "}"], "docstring": "Determines whether the specified modifier keys match the modifier keys\nthat were pressed.\n\n@param  {string[]} modifierKeys  the modifier keys to check - ex: ['shiftKey']\n@param  {Event}    e             the event object for the keydown event\n@return {boolean}                whether modifierKeys are valid for the event\n\n@method tabOverride.utils.isValidModifierKeyCombo", "docstring_tokens": ["Determines", "whether", "the", "specified", "modifier", "keys", "match", "the", "modifier", "keys", "that", "were", "pressed", "."], "sha": "02238ec1ab098cb998dcb3c1c38d39316e2ac03d", "url": "https://github.com/wjbryant/taboverride/blob/02238ec1ab098cb998dcb3c1c38d39316e2ac03d/build/output/taboverride.js#L64-L113", "partition": "test"}
{"repo": "yortus/asyncawait", "path": "src/async/makeAsyncFunc.js", "func_name": "makeAsyncNonIterator", "original_string": "function makeAsyncNonIterator(bodyFunc, config, semaphore) {\n    // Return a function that executes fn in a fiber and returns a promise of fn's result.\n    return function nonIterable() {\n        // Get all the arguments passed in, as an array.\n        var argsAsArray = new Array(arguments.length);\n        for (var i = 0; i < argsAsArray.length; ++i)\n            argsAsArray[i] = arguments[i];\n        // Remove concurrency restrictions for nested calls, to avoid race conditions.\n        if (FiberMgr.isExecutingInFiber())\n            this._semaphore = Semaphore.unlimited;\n        // Configure the run context.\n        var runContext = new RunContext(bodyFunc, this, argsAsArray, function () { return semaphore.leave(); });\n        if (config.returnValue !== Config.NONE) {\n            var resolver = defer();\n            runContext.resolver = resolver;\n        }\n        if (config.acceptsCallback && argsAsArray.length && _.isFunction(argsAsArray[argsAsArray.length - 1])) {\n            var callback = argsAsArray.pop();\n            runContext.callback = callback;\n        }\n        // Execute bodyFunc to completion in a coroutine. For thunks, this is a lazy operation.\n        if (config.returnValue === Config.THUNK) {\n            var thunk = function (done) {\n                if (done)\n                    resolver.promise.then(function (val) { return done(null, val); }, function (err) { return done(err); });\n                semaphore.enter(function () { return FiberMgr.create().run(runContext); });\n            };\n        }\n        else {\n            semaphore.enter(function () { return FiberMgr.create().run(runContext); });\n        }\n        // Return the appropriate value.\n        switch (config.returnValue) {\n            case Config.PROMISE: return resolver.promise;\n            case Config.THUNK: return thunk;\n            case Config.RESULT: return await(resolver.promise);\n            case Config.NONE: return;\n        }\n    };\n}", "language": "javascript", "code": "function makeAsyncNonIterator(bodyFunc, config, semaphore) {\n    // Return a function that executes fn in a fiber and returns a promise of fn's result.\n    return function nonIterable() {\n        // Get all the arguments passed in, as an array.\n        var argsAsArray = new Array(arguments.length);\n        for (var i = 0; i < argsAsArray.length; ++i)\n            argsAsArray[i] = arguments[i];\n        // Remove concurrency restrictions for nested calls, to avoid race conditions.\n        if (FiberMgr.isExecutingInFiber())\n            this._semaphore = Semaphore.unlimited;\n        // Configure the run context.\n        var runContext = new RunContext(bodyFunc, this, argsAsArray, function () { return semaphore.leave(); });\n        if (config.returnValue !== Config.NONE) {\n            var resolver = defer();\n            runContext.resolver = resolver;\n        }\n        if (config.acceptsCallback && argsAsArray.length && _.isFunction(argsAsArray[argsAsArray.length - 1])) {\n            var callback = argsAsArray.pop();\n            runContext.callback = callback;\n        }\n        // Execute bodyFunc to completion in a coroutine. For thunks, this is a lazy operation.\n        if (config.returnValue === Config.THUNK) {\n            var thunk = function (done) {\n                if (done)\n                    resolver.promise.then(function (val) { return done(null, val); }, function (err) { return done(err); });\n                semaphore.enter(function () { return FiberMgr.create().run(runContext); });\n            };\n        }\n        else {\n            semaphore.enter(function () { return FiberMgr.create().run(runContext); });\n        }\n        // Return the appropriate value.\n        switch (config.returnValue) {\n            case Config.PROMISE: return resolver.promise;\n            case Config.THUNK: return thunk;\n            case Config.RESULT: return await(resolver.promise);\n            case Config.NONE: return;\n        }\n    };\n}", "code_tokens": ["function", "makeAsyncNonIterator", "(", "bodyFunc", ",", "config", ",", "semaphore", ")", "{", "// Return a function that executes fn in a fiber and returns a promise of fn's result.", "return", "function", "nonIterable", "(", ")", "{", "// Get all the arguments passed in, as an array.", "var", "argsAsArray", "=", "new", "Array", "(", "arguments", ".", "length", ")", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "argsAsArray", ".", "length", ";", "++", "i", ")", "argsAsArray", "[", "i", "]", "=", "arguments", "[", "i", "]", ";", "// Remove concurrency restrictions for nested calls, to avoid race conditions.", "if", "(", "FiberMgr", ".", "isExecutingInFiber", "(", ")", ")", "this", ".", "_semaphore", "=", "Semaphore", ".", "unlimited", ";", "// Configure the run context.", "var", "runContext", "=", "new", "RunContext", "(", "bodyFunc", ",", "this", ",", "argsAsArray", ",", "function", "(", ")", "{", "return", "semaphore", ".", "leave", "(", ")", ";", "}", ")", ";", "if", "(", "config", ".", "returnValue", "!==", "Config", ".", "NONE", ")", "{", "var", "resolver", "=", "defer", "(", ")", ";", "runContext", ".", "resolver", "=", "resolver", ";", "}", "if", "(", "config", ".", "acceptsCallback", "&&", "argsAsArray", ".", "length", "&&", "_", ".", "isFunction", "(", "argsAsArray", "[", "argsAsArray", ".", "length", "-", "1", "]", ")", ")", "{", "var", "callback", "=", "argsAsArray", ".", "pop", "(", ")", ";", "runContext", ".", "callback", "=", "callback", ";", "}", "// Execute bodyFunc to completion in a coroutine. For thunks, this is a lazy operation.", "if", "(", "config", ".", "returnValue", "===", "Config", ".", "THUNK", ")", "{", "var", "thunk", "=", "function", "(", "done", ")", "{", "if", "(", "done", ")", "resolver", ".", "promise", ".", "then", "(", "function", "(", "val", ")", "{", "return", "done", "(", "null", ",", "val", ")", ";", "}", ",", "function", "(", "err", ")", "{", "return", "done", "(", "err", ")", ";", "}", ")", ";", "semaphore", ".", "enter", "(", "function", "(", ")", "{", "return", "FiberMgr", ".", "create", "(", ")", ".", "run", "(", "runContext", ")", ";", "}", ")", ";", "}", ";", "}", "else", "{", "semaphore", ".", "enter", "(", "function", "(", ")", "{", "return", "FiberMgr", ".", "create", "(", ")", ".", "run", "(", "runContext", ")", ";", "}", ")", ";", "}", "// Return the appropriate value.", "switch", "(", "config", ".", "returnValue", ")", "{", "case", "Config", ".", "PROMISE", ":", "return", "resolver", ".", "promise", ";", "case", "Config", ".", "THUNK", ":", "return", "thunk", ";", "case", "Config", ".", "RESULT", ":", "return", "await", "(", "resolver", ".", "promise", ")", ";", "case", "Config", ".", "NONE", ":", "return", ";", "}", "}", ";", "}"], "docstring": "Function for creating non-iterable suspendable functions.", "docstring_tokens": ["Function", "for", "creating", "non", "-", "iterable", "suspendable", "functions", "."], "sha": "7b4f573ecc7e388a1b05fa0c454bbe5d1b0154f2", "url": "https://github.com/yortus/asyncawait/blob/7b4f573ecc7e388a1b05fa0c454bbe5d1b0154f2/src/async/makeAsyncFunc.js#L73-L112", "partition": "test"}
{"repo": "strongloop/microgateway-util", "path": "utils/utils.js", "func_name": "addSignatureHeaders", "original_string": "function addSignatureHeaders(body, headers, keyId, key) {\n  if (!headers) {\n    headers = {};\n  }\n\n  if (!headers.date) {\n    headers.date = (new Date()).toUTCString();\n  }\n\n  if (!headers.digest) {\n    headers.digest = 'SHA256=' + hashMsg(JSON.stringify(body), 'sha256')\n        .toString('base64');\n  }\n\n\n  var combine = function(names, headers) {\n    var parts = [];\n    names.forEach(function(e) {\n      parts.push(e + ': ' + headers[e]);\n    });\n    return parts.join('\\n');\n  };\n\n  headers.authorization = 'Signature ' +\n    'keyId=\"' + keyId + '\", ' +\n    'headers=\"date digest\", ' +\n    'algorithm=\"rsa-sha256\", ' +\n    'signature=\"' +\n    signMsg(combine([ 'date', 'digest' ], headers), key, 'RSA-SHA256')\n      .toString('base64') + '\"';\n\n  return headers;\n}", "language": "javascript", "code": "function addSignatureHeaders(body, headers, keyId, key) {\n  if (!headers) {\n    headers = {};\n  }\n\n  if (!headers.date) {\n    headers.date = (new Date()).toUTCString();\n  }\n\n  if (!headers.digest) {\n    headers.digest = 'SHA256=' + hashMsg(JSON.stringify(body), 'sha256')\n        .toString('base64');\n  }\n\n\n  var combine = function(names, headers) {\n    var parts = [];\n    names.forEach(function(e) {\n      parts.push(e + ': ' + headers[e]);\n    });\n    return parts.join('\\n');\n  };\n\n  headers.authorization = 'Signature ' +\n    'keyId=\"' + keyId + '\", ' +\n    'headers=\"date digest\", ' +\n    'algorithm=\"rsa-sha256\", ' +\n    'signature=\"' +\n    signMsg(combine([ 'date', 'digest' ], headers), key, 'RSA-SHA256')\n      .toString('base64') + '\"';\n\n  return headers;\n}", "code_tokens": ["function", "addSignatureHeaders", "(", "body", ",", "headers", ",", "keyId", ",", "key", ")", "{", "if", "(", "!", "headers", ")", "{", "headers", "=", "{", "}", ";", "}", "if", "(", "!", "headers", ".", "date", ")", "{", "headers", ".", "date", "=", "(", "new", "Date", "(", ")", ")", ".", "toUTCString", "(", ")", ";", "}", "if", "(", "!", "headers", ".", "digest", ")", "{", "headers", ".", "digest", "=", "'SHA256='", "+", "hashMsg", "(", "JSON", ".", "stringify", "(", "body", ")", ",", "'sha256'", ")", ".", "toString", "(", "'base64'", ")", ";", "}", "var", "combine", "=", "function", "(", "names", ",", "headers", ")", "{", "var", "parts", "=", "[", "]", ";", "names", ".", "forEach", "(", "function", "(", "e", ")", "{", "parts", ".", "push", "(", "e", "+", "': '", "+", "headers", "[", "e", "]", ")", ";", "}", ")", ";", "return", "parts", ".", "join", "(", "'\\n'", ")", ";", "}", ";", "headers", ".", "authorization", "=", "'Signature '", "+", "'keyId=\"'", "+", "keyId", "+", "'\", '", "+", "'headers=\"date digest\", '", "+", "'algorithm=\"rsa-sha256\", '", "+", "'signature=\"'", "+", "signMsg", "(", "combine", "(", "[", "'date'", ",", "'digest'", "]", ",", "headers", ")", ",", "key", ",", "'RSA-SHA256'", ")", ".", "toString", "(", "'base64'", ")", "+", "'\"'", ";", "return", "headers", ";", "}"], "docstring": "Compute the signature headers \"date\", \"digest\", and \"authorization\" headers\naccording to IETF I-D draft-cavage-http-signatures-05 using rsa-sha256 algorithm\n\nIf the `date` header already exists in the input, it's used as-is\nIf the `digest` header already exists in the input, it's used as-is (which means that body is ignored)\n\n\n@param body (String): Message body (ignored if there is already a digest header)\n@param headers (Object): Contains the existing list of headers\n@param keyId (String): Identifier for the private key, ends up in the \"keyId\" param of the authorization header\n@param key (String): RSA Private key to be used for the signature\n@returns {*}", "docstring_tokens": ["Compute", "the", "signature", "headers", "date", "digest", "and", "authorization", "headers", "according", "to", "IETF", "I", "-", "D", "draft", "-", "cavage", "-", "http", "-", "signatures", "-", "05", "using", "rsa", "-", "sha256", "algorithm"], "sha": "58631765eac4b0c675f458c3904ee07fbe2bac5b", "url": "https://github.com/strongloop/microgateway-util/blob/58631765eac4b0c675f458c3904ee07fbe2bac5b/utils/utils.js#L142-L174", "partition": "test"}
{"repo": "makeomatic/ms-users-restify", "path": "docs/main.js", "func_name": "loadGoogleFontCss", "original_string": "function loadGoogleFontCss() {\n        var host = document.location.hostname.toLowerCase();\n        var protocol = document.location.protocol.toLowerCase();\n        var googleCss = '//fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:400,600,700';\n        if (host == 'localhost' || !host.length || protocol === 'file:')\n            googleCss = 'http:' + googleCss;\n\n        $('<link/>', {\n            rel: 'stylesheet',\n            type: 'text/css',\n            href: googleCss\n        }).appendTo('head');\n    }", "language": "javascript", "code": "function loadGoogleFontCss() {\n        var host = document.location.hostname.toLowerCase();\n        var protocol = document.location.protocol.toLowerCase();\n        var googleCss = '//fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:400,600,700';\n        if (host == 'localhost' || !host.length || protocol === 'file:')\n            googleCss = 'http:' + googleCss;\n\n        $('<link/>', {\n            rel: 'stylesheet',\n            type: 'text/css',\n            href: googleCss\n        }).appendTo('head');\n    }", "code_tokens": ["function", "loadGoogleFontCss", "(", ")", "{", "var", "host", "=", "document", ".", "location", ".", "hostname", ".", "toLowerCase", "(", ")", ";", "var", "protocol", "=", "document", ".", "location", ".", "protocol", ".", "toLowerCase", "(", ")", ";", "var", "googleCss", "=", "'//fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:400,600,700'", ";", "if", "(", "host", "==", "'localhost'", "||", "!", "host", ".", "length", "||", "protocol", "===", "'file:'", ")", "googleCss", "=", "'http:'", "+", "googleCss", ";", "$", "(", "'<link/>'", ",", "{", "rel", ":", "'stylesheet'", ",", "type", ":", "'text/css'", ",", "href", ":", "googleCss", "}", ")", ".", "appendTo", "(", "'head'", ")", ";", "}"], "docstring": "Load google fonts.", "docstring_tokens": ["Load", "google", "fonts", "."], "sha": "f6c1e464458eb35c1dd62ce0bf648a560d6759e0", "url": "https://github.com/makeomatic/ms-users-restify/blob/f6c1e464458eb35c1dd62ce0bf648a560d6759e0/docs/main.js#L646-L658", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/data/NodeInterface.js", "func_name": "", "original_string": "function(silent) {\n                    var me = this,\n                        parentNode = me.parentNode,\n                        isFirst = (!parentNode ? true : parentNode.firstChild == me),\n                        isLast = (!parentNode ? true : parentNode.lastChild == me),\n                        depth = 0,\n                        parent = me,\n                        children = me.childNodes,\n                        ln = children.length,\n                        i;\n\n                    while (parent.parentNode) {\n                        ++depth;\n                        parent = parent.parentNode;\n                    }\n\n                    me.beginEdit();\n                    me.set({\n                        isFirst: isFirst,\n                        isLast: isLast,\n                        depth: depth,\n                        index: parentNode ? parentNode.indexOf(me) : 0,\n                        parentId: parentNode ? parentNode.getId() : null\n                    });\n                    me.endEdit(silent);\n                    if (silent) {\n                        me.commit(silent);\n                    }\n\n                    for (i = 0; i < ln; i++) {\n                        children[i].updateInfo(silent);\n                    }\n                }", "language": "javascript", "code": "function(silent) {\n                    var me = this,\n                        parentNode = me.parentNode,\n                        isFirst = (!parentNode ? true : parentNode.firstChild == me),\n                        isLast = (!parentNode ? true : parentNode.lastChild == me),\n                        depth = 0,\n                        parent = me,\n                        children = me.childNodes,\n                        ln = children.length,\n                        i;\n\n                    while (parent.parentNode) {\n                        ++depth;\n                        parent = parent.parentNode;\n                    }\n\n                    me.beginEdit();\n                    me.set({\n                        isFirst: isFirst,\n                        isLast: isLast,\n                        depth: depth,\n                        index: parentNode ? parentNode.indexOf(me) : 0,\n                        parentId: parentNode ? parentNode.getId() : null\n                    });\n                    me.endEdit(silent);\n                    if (silent) {\n                        me.commit(silent);\n                    }\n\n                    for (i = 0; i < ln; i++) {\n                        children[i].updateInfo(silent);\n                    }\n                }", "code_tokens": ["function", "(", "silent", ")", "{", "var", "me", "=", "this", ",", "parentNode", "=", "me", ".", "parentNode", ",", "isFirst", "=", "(", "!", "parentNode", "?", "true", ":", "parentNode", ".", "firstChild", "==", "me", ")", ",", "isLast", "=", "(", "!", "parentNode", "?", "true", ":", "parentNode", ".", "lastChild", "==", "me", ")", ",", "depth", "=", "0", ",", "parent", "=", "me", ",", "children", "=", "me", ".", "childNodes", ",", "ln", "=", "children", ".", "length", ",", "i", ";", "while", "(", "parent", ".", "parentNode", ")", "{", "++", "depth", ";", "parent", "=", "parent", ".", "parentNode", ";", "}", "me", ".", "beginEdit", "(", ")", ";", "me", ".", "set", "(", "{", "isFirst", ":", "isFirst", ",", "isLast", ":", "isLast", ",", "depth", ":", "depth", ",", "index", ":", "parentNode", "?", "parentNode", ".", "indexOf", "(", "me", ")", ":", "0", ",", "parentId", ":", "parentNode", "?", "parentNode", ".", "getId", "(", ")", ":", "null", "}", ")", ";", "me", ".", "endEdit", "(", "silent", ")", ";", "if", "(", "silent", ")", "{", "me", ".", "commit", "(", "silent", ")", ";", "}", "for", "(", "i", "=", "0", ";", "i", "<", "ln", ";", "i", "++", ")", "{", "children", "[", "i", "]", ".", "updateInfo", "(", "silent", ")", ";", "}", "}"], "docstring": "Updates general data of this node like isFirst, isLast, depth. This\nmethod is internally called after a node is moved. This shouldn't\nhave to be called by the developer unless they are creating custom\nTree plugins.\n@return {Boolean}", "docstring_tokens": ["Updates", "general", "data", "of", "this", "node", "like", "isFirst", "isLast", "depth", ".", "This", "method", "is", "internally", "called", "after", "a", "node", "is", "moved", ".", "This", "shouldn", "t", "have", "to", "be", "called", "by", "the", "developer", "unless", "they", "are", "creating", "custom", "Tree", "plugins", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeInterface.js#L321-L353", "partition": "test"}
{"repo": "retextjs/retext-indefinite-article", "path": "lib/index.js", "func_name": "factory", "original_string": "function factory(list) {\n  var expressions = []\n  var sensitive = []\n  var insensitive = []\n\n  construct()\n\n  return test\n\n  function construct() {\n    var length = list.length\n    var index = -1\n    var value\n    var normal\n\n    while (++index < length) {\n      value = list[index]\n      normal = value === lower(value)\n\n      if (value.charAt(value.length - 1) === '*') {\n        // Regexes are insensitive now, once we need them this should check for\n        // `normal` as well.\n        expressions.push(new RegExp('^' + value.slice(0, -1), 'i'))\n      } else if (normal) {\n        insensitive.push(value)\n      } else {\n        sensitive.push(value)\n      }\n    }\n  }\n\n  function test(value) {\n    var normal = lower(value)\n    var length\n    var index\n\n    if (sensitive.indexOf(value) !== -1 || insensitive.indexOf(normal) !== -1) {\n      return true\n    }\n\n    length = expressions.length\n    index = -1\n\n    while (++index < length) {\n      if (expressions[index].test(value)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}", "language": "javascript", "code": "function factory(list) {\n  var expressions = []\n  var sensitive = []\n  var insensitive = []\n\n  construct()\n\n  return test\n\n  function construct() {\n    var length = list.length\n    var index = -1\n    var value\n    var normal\n\n    while (++index < length) {\n      value = list[index]\n      normal = value === lower(value)\n\n      if (value.charAt(value.length - 1) === '*') {\n        // Regexes are insensitive now, once we need them this should check for\n        // `normal` as well.\n        expressions.push(new RegExp('^' + value.slice(0, -1), 'i'))\n      } else if (normal) {\n        insensitive.push(value)\n      } else {\n        sensitive.push(value)\n      }\n    }\n  }\n\n  function test(value) {\n    var normal = lower(value)\n    var length\n    var index\n\n    if (sensitive.indexOf(value) !== -1 || insensitive.indexOf(normal) !== -1) {\n      return true\n    }\n\n    length = expressions.length\n    index = -1\n\n    while (++index < length) {\n      if (expressions[index].test(value)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}", "code_tokens": ["function", "factory", "(", "list", ")", "{", "var", "expressions", "=", "[", "]", "var", "sensitive", "=", "[", "]", "var", "insensitive", "=", "[", "]", "construct", "(", ")", "return", "test", "function", "construct", "(", ")", "{", "var", "length", "=", "list", ".", "length", "var", "index", "=", "-", "1", "var", "value", "var", "normal", "while", "(", "++", "index", "<", "length", ")", "{", "value", "=", "list", "[", "index", "]", "normal", "=", "value", "===", "lower", "(", "value", ")", "if", "(", "value", ".", "charAt", "(", "value", ".", "length", "-", "1", ")", "===", "'*'", ")", "{", "// Regexes are insensitive now, once we need them this should check for", "// `normal` as well.", "expressions", ".", "push", "(", "new", "RegExp", "(", "'^'", "+", "value", ".", "slice", "(", "0", ",", "-", "1", ")", ",", "'i'", ")", ")", "}", "else", "if", "(", "normal", ")", "{", "insensitive", ".", "push", "(", "value", ")", "}", "else", "{", "sensitive", ".", "push", "(", "value", ")", "}", "}", "}", "function", "test", "(", "value", ")", "{", "var", "normal", "=", "lower", "(", "value", ")", "var", "length", "var", "index", "if", "(", "sensitive", ".", "indexOf", "(", "value", ")", "!==", "-", "1", "||", "insensitive", ".", "indexOf", "(", "normal", ")", "!==", "-", "1", ")", "{", "return", "true", "}", "length", "=", "expressions", ".", "length", "index", "=", "-", "1", "while", "(", "++", "index", "<", "length", ")", "{", "if", "(", "expressions", "[", "index", "]", ".", "test", "(", "value", ")", ")", "{", "return", "true", "}", "}", "return", "false", "}", "}"], "docstring": "Create a test based on a list of phrases.", "docstring_tokens": ["Create", "a", "test", "based", "on", "a", "list", "of", "phrases", "."], "sha": "abe3642840f416c2f921b6947d9ceb277c271a43", "url": "https://github.com/retextjs/retext-indefinite-article/blob/abe3642840f416c2f921b6947d9ceb277c271a43/lib/index.js#L140-L191", "partition": "test"}
{"repo": "elkdanger/express-autoapi", "path": "index.js", "func_name": "processFileList", "original_string": "function processFileList(files, base, settings, state) {\n\n    for (var i = 0; i < files.length; i++) {\n\n        var modulePath = path.join(base, files[i]);\n\n        var stats = fs.statSync(modulePath);\n\n        if (stats.isFile()) {\n\n            // Try to load the module\n            var module = require(modulePath);            \n            var relative = path.relative(settings.source, modulePath);\n\n            __log('Relative path: %s', relative);\n\n            var pathWithoutExtension = relative.substr(0, relative.lastIndexOf('.'));\n            var routeName = pathWithoutExtension.replace(/\\\\/g, '/').replace(/\\./g, '_');\n            \n            var isRoot = new RegExp(settings.rootModule + '/?$', 'g').test(routeName);\n            var routePath = routeName;\n\n            // Special case for an index file - put these in the root of the api            \n            if (isRoot) {\n\n                if(routePath.lastIndexOf('/') > -1)\n                    routePath = routePath.substr(0, routePath.lastIndexOf('/'));\n                else\n                    routePath = undefined;\n            }\n\n            __log('%s (%s)', routeName, routePath);\n\n            var apiPath = utils.combineApiPath(settings.root, routePath);\n\n            state.endpoints[routeName] = {\n                baseUrl: apiPath,\n                filename: modulePath,\n                routeName: routeName\n            };\n\n            __log(state.endpoints[routeName]);\n\n            settings.app.use(apiPath, module);\n        }\n        else if (stats.isDirectory()) {\n            var dirFiles = fs.readdirSync(modulePath);\n            processFileList(dirFiles, modulePath, settings, state);\n        }\n    }\n}", "language": "javascript", "code": "function processFileList(files, base, settings, state) {\n\n    for (var i = 0; i < files.length; i++) {\n\n        var modulePath = path.join(base, files[i]);\n\n        var stats = fs.statSync(modulePath);\n\n        if (stats.isFile()) {\n\n            // Try to load the module\n            var module = require(modulePath);            \n            var relative = path.relative(settings.source, modulePath);\n\n            __log('Relative path: %s', relative);\n\n            var pathWithoutExtension = relative.substr(0, relative.lastIndexOf('.'));\n            var routeName = pathWithoutExtension.replace(/\\\\/g, '/').replace(/\\./g, '_');\n            \n            var isRoot = new RegExp(settings.rootModule + '/?$', 'g').test(routeName);\n            var routePath = routeName;\n\n            // Special case for an index file - put these in the root of the api            \n            if (isRoot) {\n\n                if(routePath.lastIndexOf('/') > -1)\n                    routePath = routePath.substr(0, routePath.lastIndexOf('/'));\n                else\n                    routePath = undefined;\n            }\n\n            __log('%s (%s)', routeName, routePath);\n\n            var apiPath = utils.combineApiPath(settings.root, routePath);\n\n            state.endpoints[routeName] = {\n                baseUrl: apiPath,\n                filename: modulePath,\n                routeName: routeName\n            };\n\n            __log(state.endpoints[routeName]);\n\n            settings.app.use(apiPath, module);\n        }\n        else if (stats.isDirectory()) {\n            var dirFiles = fs.readdirSync(modulePath);\n            processFileList(dirFiles, modulePath, settings, state);\n        }\n    }\n}", "code_tokens": ["function", "processFileList", "(", "files", ",", "base", ",", "settings", ",", "state", ")", "{", "for", "(", "var", "i", "=", "0", ";", "i", "<", "files", ".", "length", ";", "i", "++", ")", "{", "var", "modulePath", "=", "path", ".", "join", "(", "base", ",", "files", "[", "i", "]", ")", ";", "var", "stats", "=", "fs", ".", "statSync", "(", "modulePath", ")", ";", "if", "(", "stats", ".", "isFile", "(", ")", ")", "{", "// Try to load the module", "var", "module", "=", "require", "(", "modulePath", ")", ";", "var", "relative", "=", "path", ".", "relative", "(", "settings", ".", "source", ",", "modulePath", ")", ";", "__log", "(", "'Relative path: %s'", ",", "relative", ")", ";", "var", "pathWithoutExtension", "=", "relative", ".", "substr", "(", "0", ",", "relative", ".", "lastIndexOf", "(", "'.'", ")", ")", ";", "var", "routeName", "=", "pathWithoutExtension", ".", "replace", "(", "/", "\\\\", "/", "g", ",", "'/'", ")", ".", "replace", "(", "/", "\\.", "/", "g", ",", "'_'", ")", ";", "var", "isRoot", "=", "new", "RegExp", "(", "settings", ".", "rootModule", "+", "'/?$'", ",", "'g'", ")", ".", "test", "(", "routeName", ")", ";", "var", "routePath", "=", "routeName", ";", "// Special case for an index file - put these in the root of the api            ", "if", "(", "isRoot", ")", "{", "if", "(", "routePath", ".", "lastIndexOf", "(", "'/'", ")", ">", "-", "1", ")", "routePath", "=", "routePath", ".", "substr", "(", "0", ",", "routePath", ".", "lastIndexOf", "(", "'/'", ")", ")", ";", "else", "routePath", "=", "undefined", ";", "}", "__log", "(", "'%s (%s)'", ",", "routeName", ",", "routePath", ")", ";", "var", "apiPath", "=", "utils", ".", "combineApiPath", "(", "settings", ".", "root", ",", "routePath", ")", ";", "state", ".", "endpoints", "[", "routeName", "]", "=", "{", "baseUrl", ":", "apiPath", ",", "filename", ":", "modulePath", ",", "routeName", ":", "routeName", "}", ";", "__log", "(", "state", ".", "endpoints", "[", "routeName", "]", ")", ";", "settings", ".", "app", ".", "use", "(", "apiPath", ",", "module", ")", ";", "}", "else", "if", "(", "stats", ".", "isDirectory", "(", ")", ")", "{", "var", "dirFiles", "=", "fs", ".", "readdirSync", "(", "modulePath", ")", ";", "processFileList", "(", "dirFiles", ",", "modulePath", ",", "settings", ",", "state", ")", ";", "}", "}", "}"], "docstring": "Processes a list of files and produces the api routing for them\n@param files The list of files to process\n@param settings express-autoapi settings\n@param state The process state", "docstring_tokens": ["Processes", "a", "list", "of", "files", "and", "produces", "the", "api", "routing", "for", "them"], "sha": "26de6d57ddfe3e8903c6a523486415d20853f1bf", "url": "https://github.com/elkdanger/express-autoapi/blob/26de6d57ddfe3e8903c6a523486415d20853f1bf/index.js#L27-L77", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "safeCall", "original_string": "function safeCall (fn, args) {\n  // Get the function arguments as an array\n  args = Array.prototype.slice.call(arguments, 1);\n\n  // Replace the callback function with a wrapper that ensures it will only be called once\n  let callback = call.once(args.pop());\n  args.push(callback);\n\n  try {\n    fn.apply(null, args);\n  }\n  catch (err) {\n    callback(err);\n  }\n}", "language": "javascript", "code": "function safeCall (fn, args) {\n  // Get the function arguments as an array\n  args = Array.prototype.slice.call(arguments, 1);\n\n  // Replace the callback function with a wrapper that ensures it will only be called once\n  let callback = call.once(args.pop());\n  args.push(callback);\n\n  try {\n    fn.apply(null, args);\n  }\n  catch (err) {\n    callback(err);\n  }\n}", "code_tokens": ["function", "safeCall", "(", "fn", ",", "args", ")", "{", "// Get the function arguments as an array", "args", "=", "Array", ".", "prototype", ".", "slice", ".", "call", "(", "arguments", ",", "1", ")", ";", "// Replace the callback function with a wrapper that ensures it will only be called once", "let", "callback", "=", "call", ".", "once", "(", "args", ".", "pop", "(", ")", ")", ";", "args", ".", "push", "(", "callback", ")", ";", "try", "{", "fn", ".", "apply", "(", "null", ",", "args", ")", ";", "}", "catch", "(", "err", ")", "{", "callback", "(", "err", ")", ";", "}", "}"], "docstring": "Calls a function with the given arguments, and ensures that the error-first callback is _always_\ninvoked exactly once, even if the function throws an error.\n\n@param {function} fn - The function to invoke\n@param {...*} args - The arguments to pass to the function. The final argument must be a callback function.", "docstring_tokens": ["Calls", "a", "function", "with", "the", "given", "arguments", "and", "ensures", "that", "the", "error", "-", "first", "callback", "is", "_always_", "invoked", "exactly", "once", "even", "if", "the", "function", "throws", "an", "error", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L99-L113", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(record, data) {\n    var oldId = get(record, 'id'),\n        id = coerceId(data.id);\n\n    Ember.assert(\"An adapter cannot assign a new id to a record that already has an id. \" + record + \" had id: \" + oldId + \" and you tried to update it with \" + id + \". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent.\", oldId === null || id === oldId);\n\n    this.typeMapFor(record.constructor).idToRecord[id] = record;\n\n    set(record, 'id', id);\n  }", "language": "javascript", "code": "function(record, data) {\n    var oldId = get(record, 'id'),\n        id = coerceId(data.id);\n\n    Ember.assert(\"An adapter cannot assign a new id to a record that already has an id. \" + record + \" had id: \" + oldId + \" and you tried to update it with \" + id + \". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent.\", oldId === null || id === oldId);\n\n    this.typeMapFor(record.constructor).idToRecord[id] = record;\n\n    set(record, 'id', id);\n  }", "code_tokens": ["function", "(", "record", ",", "data", ")", "{", "var", "oldId", "=", "get", "(", "record", ",", "'id'", ")", ",", "id", "=", "coerceId", "(", "data", ".", "id", ")", ";", "Ember", ".", "assert", "(", "\"An adapter cannot assign a new id to a record that already has an id. \"", "+", "record", "+", "\" had id: \"", "+", "oldId", "+", "\" and you tried to update it with \"", "+", "id", "+", "\". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent.\"", ",", "oldId", "===", "null", "||", "id", "===", "oldId", ")", ";", "this", ".", "typeMapFor", "(", "record", ".", "constructor", ")", ".", "idToRecord", "[", "id", "]", "=", "record", ";", "set", "(", "record", ",", "'id'", ",", "id", ")", ";", "}"], "docstring": "When an adapter's `createRecord`, `updateRecord` or `deleteRecord`\nresolves with data, this method extracts the ID from the supplied\ndata.\n\n@method updateId\n@private\n@param {DS.Model} record\n@param {Object} data", "docstring_tokens": ["When", "an", "adapter", "s", "createRecord", "updateRecord", "or", "deleteRecord", "resolves", "with", "data", "this", "method", "extracts", "the", "ID", "from", "the", "supplied", "data", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L2899-L2908", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/metadata/index.js", "func_name": "PreparedQueries", "original_string": "function PreparedQueries(maxPrepared, logger) {\n  this.length = 0;\n  this._maxPrepared = maxPrepared;\n  this._mapByKey = {};\n  this._mapById = {};\n  this._logger = logger;\n}", "language": "javascript", "code": "function PreparedQueries(maxPrepared, logger) {\n  this.length = 0;\n  this._maxPrepared = maxPrepared;\n  this._mapByKey = {};\n  this._mapById = {};\n  this._logger = logger;\n}", "code_tokens": ["function", "PreparedQueries", "(", "maxPrepared", ",", "logger", ")", "{", "this", ".", "length", "=", "0", ";", "this", ".", "_maxPrepared", "=", "maxPrepared", ";", "this", ".", "_mapByKey", "=", "{", "}", ";", "this", ".", "_mapById", "=", "{", "}", ";", "this", ".", "_logger", "=", "logger", ";", "}"], "docstring": "Allows to store prepared queries and retrieval by query or query id.\n@param {Number} maxPrepared\n@param {Function} logger\n@constructor\n@ignore", "docstring_tokens": ["Allows", "to", "store", "prepared", "queries", "and", "retrieval", "by", "query", "or", "query", "id", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/metadata/index.js#L987-L993", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "parsePropertyFunction", "original_string": "function parsePropertyFunction(options) {\n            var previousStrict, previousYieldAllowed, previousAwaitAllowed,\n                params, defaults, body, marker = markerCreate();\n    \n            previousStrict = strict;\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = options.generator;\n            previousAwaitAllowed = state.awaitAllowed;\n            state.awaitAllowed = options.async;\n            params = options.params || [];\n            defaults = options.defaults || [];\n    \n            body = parseConciseBody();\n            if (options.name && strict && isRestrictedWord(params[0].name)) {\n                throwErrorTolerant(options.name, Messages.StrictParamName);\n            }\n            strict = previousStrict;\n            state.yieldAllowed = previousYieldAllowed;\n            state.awaitAllowed = previousAwaitAllowed;\n    \n            return markerApply(marker, delegate.createFunctionExpression(\n                null,\n                params,\n                defaults,\n                body,\n                options.rest || null,\n                options.generator,\n                body.type !== Syntax.BlockStatement,\n                options.async,\n                options.returnType,\n                options.typeParameters\n            ));\n        }", "language": "javascript", "code": "function parsePropertyFunction(options) {\n            var previousStrict, previousYieldAllowed, previousAwaitAllowed,\n                params, defaults, body, marker = markerCreate();\n    \n            previousStrict = strict;\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = options.generator;\n            previousAwaitAllowed = state.awaitAllowed;\n            state.awaitAllowed = options.async;\n            params = options.params || [];\n            defaults = options.defaults || [];\n    \n            body = parseConciseBody();\n            if (options.name && strict && isRestrictedWord(params[0].name)) {\n                throwErrorTolerant(options.name, Messages.StrictParamName);\n            }\n            strict = previousStrict;\n            state.yieldAllowed = previousYieldAllowed;\n            state.awaitAllowed = previousAwaitAllowed;\n    \n            return markerApply(marker, delegate.createFunctionExpression(\n                null,\n                params,\n                defaults,\n                body,\n                options.rest || null,\n                options.generator,\n                body.type !== Syntax.BlockStatement,\n                options.async,\n                options.returnType,\n                options.typeParameters\n            ));\n        }", "code_tokens": ["function", "parsePropertyFunction", "(", "options", ")", "{", "var", "previousStrict", ",", "previousYieldAllowed", ",", "previousAwaitAllowed", ",", "params", ",", "defaults", ",", "body", ",", "marker", "=", "markerCreate", "(", ")", ";", "previousStrict", "=", "strict", ";", "previousYieldAllowed", "=", "state", ".", "yieldAllowed", ";", "state", ".", "yieldAllowed", "=", "options", ".", "generator", ";", "previousAwaitAllowed", "=", "state", ".", "awaitAllowed", ";", "state", ".", "awaitAllowed", "=", "options", ".", "async", ";", "params", "=", "options", ".", "params", "||", "[", "]", ";", "defaults", "=", "options", ".", "defaults", "||", "[", "]", ";", "body", "=", "parseConciseBody", "(", ")", ";", "if", "(", "options", ".", "name", "&&", "strict", "&&", "isRestrictedWord", "(", "params", "[", "0", "]", ".", "name", ")", ")", "{", "throwErrorTolerant", "(", "options", ".", "name", ",", "Messages", ".", "StrictParamName", ")", ";", "}", "strict", "=", "previousStrict", ";", "state", ".", "yieldAllowed", "=", "previousYieldAllowed", ";", "state", ".", "awaitAllowed", "=", "previousAwaitAllowed", ";", "return", "markerApply", "(", "marker", ",", "delegate", ".", "createFunctionExpression", "(", "null", ",", "params", ",", "defaults", ",", "body", ",", "options", ".", "rest", "||", "null", ",", "options", ".", "generator", ",", "body", ".", "type", "!==", "Syntax", ".", "BlockStatement", ",", "options", ".", "async", ",", "options", ".", "returnType", ",", "options", ".", "typeParameters", ")", ")", ";", "}"], "docstring": "11.1.5 Object Initialiser", "docstring_tokens": ["11", ".", "1", ".", "5", "Object", "Initialiser"], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L9914-L9946", "partition": "test"}
{"repo": "HQarroum/Fsm", "path": "examples/elevator/index.js", "func_name": "", "original_string": "function (event) {\n      if (event.name === 'goToLevel'\n        && event.level !== self.level) {\n        self.pushLevel(event.level);\n      }\n    }", "language": "javascript", "code": "function (event) {\n      if (event.name === 'goToLevel'\n        && event.level !== self.level) {\n        self.pushLevel(event.level);\n      }\n    }", "code_tokens": ["function", "(", "event", ")", "{", "if", "(", "event", ".", "name", "===", "'goToLevel'", "&&", "event", ".", "level", "!==", "self", ".", "level", ")", "{", "self", ".", "pushLevel", "(", "event", ".", "level", ")", ";", "}", "}"], "docstring": "As the elevator's doors are currently opened\nwe push any user request to go to\na level on the level stack.", "docstring_tokens": ["As", "the", "elevator", "s", "doors", "are", "currently", "opened", "we", "push", "any", "user", "request", "to", "go", "to", "a", "level", "on", "the", "level", "stack", "."], "sha": "4d46fa0ef2fe8e54976808194312b66f9c7689b1", "url": "https://github.com/HQarroum/Fsm/blob/4d46fa0ef2fe8e54976808194312b66f9c7689b1/examples/elevator/index.js#L40-L45", "partition": "test"}
{"repo": "MicroMinion/mm-services-kademlia", "path": "src/telemetry/transport-decorator.js", "func_name": "TransportDecorator", "original_string": "function TransportDecorator (Transport) {\n\n  function TelemetryTransport (contact, options) {\n    if (!(this instanceof TelemetryTransport)) {\n      return new TelemetryTransport(contact, options)\n    }\n\n    assert.ok(options, 'Missing required options parameter')\n\n    this._telopts = options.telemetry\n    this.telemetry = new Persistence(this._telopts.storage)\n\n    Transport.call(this, contact, options)\n  }\n\n  inherits(TelemetryTransport, Transport)\n\n  TelemetryTransport.DEFAULT_METRICS = [\n    metrics.Latency,\n    metrics.Availability,\n    metrics.Reliability,\n    metrics.Throughput\n  ]\n\n  /**\n   * Wraps _open with telemetry hooks setup\n   * #_open\n   * @param {Function} callback\n   */\n  TelemetryTransport.prototype._open = function (callback) {\n    var self = this\n    var metrics = this._telopts.metrics\n\n    if (!metrics || metrics.length === 0) {\n      this._telopts.metrics = TelemetryTransport.DEFAULT_METRICS\n    }\n\n    this._telopts.metrics.forEach(function (Metric) {\n      var metric = new Metric()\n\n      metric.hooks.forEach(function (hook) {\n        self[hook.trigger](\n          hook.event,\n          hook.handler(metric, self.telemetry)\n        )\n      })\n    })\n\n    return Transport.prototype._open.call(this, callback)\n  }\n\n  return TelemetryTransport\n}", "language": "javascript", "code": "function TransportDecorator (Transport) {\n\n  function TelemetryTransport (contact, options) {\n    if (!(this instanceof TelemetryTransport)) {\n      return new TelemetryTransport(contact, options)\n    }\n\n    assert.ok(options, 'Missing required options parameter')\n\n    this._telopts = options.telemetry\n    this.telemetry = new Persistence(this._telopts.storage)\n\n    Transport.call(this, contact, options)\n  }\n\n  inherits(TelemetryTransport, Transport)\n\n  TelemetryTransport.DEFAULT_METRICS = [\n    metrics.Latency,\n    metrics.Availability,\n    metrics.Reliability,\n    metrics.Throughput\n  ]\n\n  /**\n   * Wraps _open with telemetry hooks setup\n   * #_open\n   * @param {Function} callback\n   */\n  TelemetryTransport.prototype._open = function (callback) {\n    var self = this\n    var metrics = this._telopts.metrics\n\n    if (!metrics || metrics.length === 0) {\n      this._telopts.metrics = TelemetryTransport.DEFAULT_METRICS\n    }\n\n    this._telopts.metrics.forEach(function (Metric) {\n      var metric = new Metric()\n\n      metric.hooks.forEach(function (hook) {\n        self[hook.trigger](\n          hook.event,\n          hook.handler(metric, self.telemetry)\n        )\n      })\n    })\n\n    return Transport.prototype._open.call(this, callback)\n  }\n\n  return TelemetryTransport\n}", "code_tokens": ["function", "TransportDecorator", "(", "Transport", ")", "{", "function", "TelemetryTransport", "(", "contact", ",", "options", ")", "{", "if", "(", "!", "(", "this", "instanceof", "TelemetryTransport", ")", ")", "{", "return", "new", "TelemetryTransport", "(", "contact", ",", "options", ")", "}", "assert", ".", "ok", "(", "options", ",", "'Missing required options parameter'", ")", "this", ".", "_telopts", "=", "options", ".", "telemetry", "this", ".", "telemetry", "=", "new", "Persistence", "(", "this", ".", "_telopts", ".", "storage", ")", "Transport", ".", "call", "(", "this", ",", "contact", ",", "options", ")", "}", "inherits", "(", "TelemetryTransport", ",", "Transport", ")", "TelemetryTransport", ".", "DEFAULT_METRICS", "=", "[", "metrics", ".", "Latency", ",", "metrics", ".", "Availability", ",", "metrics", ".", "Reliability", ",", "metrics", ".", "Throughput", "]", "/**\n   * Wraps _open with telemetry hooks setup\n   * #_open\n   * @param {Function} callback\n   */", "TelemetryTransport", ".", "prototype", ".", "_open", "=", "function", "(", "callback", ")", "{", "var", "self", "=", "this", "var", "metrics", "=", "this", ".", "_telopts", ".", "metrics", "if", "(", "!", "metrics", "||", "metrics", ".", "length", "===", "0", ")", "{", "this", ".", "_telopts", ".", "metrics", "=", "TelemetryTransport", ".", "DEFAULT_METRICS", "}", "this", ".", "_telopts", ".", "metrics", ".", "forEach", "(", "function", "(", "Metric", ")", "{", "var", "metric", "=", "new", "Metric", "(", ")", "metric", ".", "hooks", ".", "forEach", "(", "function", "(", "hook", ")", "{", "self", "[", "hook", ".", "trigger", "]", "(", "hook", ".", "event", ",", "hook", ".", "handler", "(", "metric", ",", "self", ".", "telemetry", ")", ")", "}", ")", "}", ")", "return", "Transport", ".", "prototype", ".", "_open", ".", "call", "(", "this", ",", "callback", ")", "}", "return", "TelemetryTransport", "}"], "docstring": "Returns a decorated transport adapter that writes telemetry data\n@constructor\n@param {kad.RPC} Transport", "docstring_tokens": ["Returns", "a", "decorated", "transport", "adapter", "that", "writes", "telemetry", "data"], "sha": "05792cbc0351ab7d5ca3491cb0a7ff83a95c3407", "url": "https://github.com/MicroMinion/mm-services-kademlia/blob/05792cbc0351ab7d5ca3491cb0a7ff83a95c3407/src/telemetry/transport-decorator.js#L17-L69", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/mediaType.js", "func_name": "specify", "original_string": "function specify(type, spec, index) {\n  var p = parseMediaType(type);\n  var s = 0;\n\n  if (!p) {\n    return null;\n  }\n\n  if(spec.type.toLowerCase() == p.type.toLowerCase()) {\n    s |= 4\n  } else if(spec.type != '*') {\n    return null;\n  }\n\n  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {\n    s |= 2\n  } else if(spec.subtype != '*') {\n    return null;\n  }\n\n  var keys = Object.keys(spec.params);\n  if (keys.length > 0) {\n    if (keys.every(function (k) {\n      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();\n    })) {\n      s |= 1\n    } else {\n      return null\n    }\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s,\n  }\n}", "language": "javascript", "code": "function specify(type, spec, index) {\n  var p = parseMediaType(type);\n  var s = 0;\n\n  if (!p) {\n    return null;\n  }\n\n  if(spec.type.toLowerCase() == p.type.toLowerCase()) {\n    s |= 4\n  } else if(spec.type != '*') {\n    return null;\n  }\n\n  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {\n    s |= 2\n  } else if(spec.subtype != '*') {\n    return null;\n  }\n\n  var keys = Object.keys(spec.params);\n  if (keys.length > 0) {\n    if (keys.every(function (k) {\n      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();\n    })) {\n      s |= 1\n    } else {\n      return null\n    }\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s,\n  }\n}", "code_tokens": ["function", "specify", "(", "type", ",", "spec", ",", "index", ")", "{", "var", "p", "=", "parseMediaType", "(", "type", ")", ";", "var", "s", "=", "0", ";", "if", "(", "!", "p", ")", "{", "return", "null", ";", "}", "if", "(", "spec", ".", "type", ".", "toLowerCase", "(", ")", "==", "p", ".", "type", ".", "toLowerCase", "(", ")", ")", "{", "s", "|=", "4", "}", "else", "if", "(", "spec", ".", "type", "!=", "'*'", ")", "{", "return", "null", ";", "}", "if", "(", "spec", ".", "subtype", ".", "toLowerCase", "(", ")", "==", "p", ".", "subtype", ".", "toLowerCase", "(", ")", ")", "{", "s", "|=", "2", "}", "else", "if", "(", "spec", ".", "subtype", "!=", "'*'", ")", "{", "return", "null", ";", "}", "var", "keys", "=", "Object", ".", "keys", "(", "spec", ".", "params", ")", ";", "if", "(", "keys", ".", "length", ">", "0", ")", "{", "if", "(", "keys", ".", "every", "(", "function", "(", "k", ")", "{", "return", "spec", ".", "params", "[", "k", "]", "==", "'*'", "||", "(", "spec", ".", "params", "[", "k", "]", "||", "''", ")", ".", "toLowerCase", "(", ")", "==", "(", "p", ".", "params", "[", "k", "]", "||", "''", ")", ".", "toLowerCase", "(", ")", ";", "}", ")", ")", "{", "s", "|=", "1", "}", "else", "{", "return", "null", "}", "}", "return", "{", "i", ":", "index", ",", "o", ":", "spec", ".", "i", ",", "q", ":", "spec", ".", "q", ",", "s", ":", "s", ",", "}", "}"], "docstring": "Get the specificity of the media type.\n@private", "docstring_tokens": ["Get", "the", "specificity", "of", "the", "media", "type", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/mediaType.js#L118-L155", "partition": "test"}
{"repo": "IntrospectiveSystems/xGraph", "path": "lib/Nexus.js", "func_name": "GetModule", "original_string": "function GetModule(ModName, fun = _ => _) {\n\t\t\t\tModName = ModName.replace(/:\\//g, '.');\n\t\t\t\tif (ModName in ModCache) return fun(null, ModCache[ModName]);\n\t\t\t\telse cacheInterface.getModule(ModName, (err, moduleZip) => {\n\t\t\t\t\tif (err) return fun(err);\n\t\t\t\t\tModCache[ModName] = moduleZip;\n\t\t\t\t\treturn fun(null, ModCache[ModName]);\n\t\t\t\t});\n\t\t\t}", "language": "javascript", "code": "function GetModule(ModName, fun = _ => _) {\n\t\t\t\tModName = ModName.replace(/:\\//g, '.');\n\t\t\t\tif (ModName in ModCache) return fun(null, ModCache[ModName]);\n\t\t\t\telse cacheInterface.getModule(ModName, (err, moduleZip) => {\n\t\t\t\t\tif (err) return fun(err);\n\t\t\t\t\tModCache[ModName] = moduleZip;\n\t\t\t\t\treturn fun(null, ModCache[ModName]);\n\t\t\t\t});\n\t\t\t}", "code_tokens": ["function", "GetModule", "(", "ModName", ",", "fun", "=", "_", "=>", "_", ")", "{", "ModName", "=", "ModName", ".", "replace", "(", "/", ":\\/", "/", "g", ",", "'.'", ")", ";", "if", "(", "ModName", "in", "ModCache", ")", "return", "fun", "(", "null", ",", "ModCache", "[", "ModName", "]", ")", ";", "else", "cacheInterface", ".", "getModule", "(", "ModName", ",", "(", "err", ",", "moduleZip", ")", "=>", "{", "if", "(", "err", ")", "return", "fun", "(", "err", ")", ";", "ModCache", "[", "ModName", "]", "=", "moduleZip", ";", "return", "fun", "(", "null", ",", "ModCache", "[", "ModName", "]", ")", ";", "}", ")", ";", "}"], "docstring": "For retrieving modules\nModules come from the cache directory on the harddrive or the\nModCache if its already been read to RAM.\n@param {Object} modRequest\n@param {String} modRequest.Module\n@param {String=} modRequest.Source\n@param {Function} fun\n@returns mod", "docstring_tokens": ["For", "retrieving", "modules", "Modules", "come", "from", "the", "cache", "directory", "on", "the", "harddrive", "or", "the", "ModCache", "if", "its", "already", "been", "read", "to", "RAM", "."], "sha": "86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0", "url": "https://github.com/IntrospectiveSystems/xGraph/blob/86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0/lib/Nexus.js#L856-L864", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "advanceTo", "original_string": "function advanceTo(input, endChar) {\n  var ch = input.charAt(0);\n  var tok = { len: 1, val: '', esc: '' };\n  var idx = 0;\n\n  function advance() {\n    if (ch !== '\\\\') {\n      tok.esc += '\\\\' + ch;\n      tok.val += ch;\n    }\n\n    ch = input.charAt(++idx);\n    tok.len++;\n\n    if (ch === '\\\\') {\n      advance();\n      advance();\n    }\n  }\n\n  while (ch && ch !== endChar) {\n    advance();\n  }\n  return tok;\n}", "language": "javascript", "code": "function advanceTo(input, endChar) {\n  var ch = input.charAt(0);\n  var tok = { len: 1, val: '', esc: '' };\n  var idx = 0;\n\n  function advance() {\n    if (ch !== '\\\\') {\n      tok.esc += '\\\\' + ch;\n      tok.val += ch;\n    }\n\n    ch = input.charAt(++idx);\n    tok.len++;\n\n    if (ch === '\\\\') {\n      advance();\n      advance();\n    }\n  }\n\n  while (ch && ch !== endChar) {\n    advance();\n  }\n  return tok;\n}", "code_tokens": ["function", "advanceTo", "(", "input", ",", "endChar", ")", "{", "var", "ch", "=", "input", ".", "charAt", "(", "0", ")", ";", "var", "tok", "=", "{", "len", ":", "1", ",", "val", ":", "''", ",", "esc", ":", "''", "}", ";", "var", "idx", "=", "0", ";", "function", "advance", "(", ")", "{", "if", "(", "ch", "!==", "'\\\\'", ")", "{", "tok", ".", "esc", "+=", "'\\\\'", "+", "ch", ";", "tok", ".", "val", "+=", "ch", ";", "}", "ch", "=", "input", ".", "charAt", "(", "++", "idx", ")", ";", "tok", ".", "len", "++", ";", "if", "(", "ch", "===", "'\\\\'", ")", "{", "advance", "(", ")", ";", "advance", "(", ")", ";", "}", "}", "while", "(", "ch", "&&", "ch", "!==", "endChar", ")", "{", "advance", "(", ")", ";", "}", "return", "tok", ";", "}"], "docstring": "Advance to the next non-escaped character", "docstring_tokens": ["Advance", "to", "the", "next", "non", "-", "escaped", "character"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L46799-L46823", "partition": "test"}
{"repo": "azproduction/lmd", "path": "lib/coverage_apply.js", "func_name": "wrapCondition", "original_string": "function wrapCondition(decision, lineId, parentPos) {\n\t\tif (options.condition === false) {\n\t\t\t// condition coverage is disabled\n\t\t\treturn decision;\n\t\t}\n\n\t\tif (isSingleCondition(decision)) {\n\t\t\tvar pos = getPositionStart(decision, parentPos);\n\t\t\tvar condId = lineId + \":\" + pos;\n\n\t\t\tanalyzing.push(decision);\n\t\t\tallConditions.push(condId);\n\t\t\treturn [\"call\",\n                [\"dot\", [\"name\", \"require\"], \"coverage_condition\"],\n\t\t\t\t[\n\t\t\t\t\t[ \"string\", moduleName ],\n\t\t\t\t\t[ \"string\", condId],\n\t\t\t\t\tdecision\n\t\t\t\t]\n\t\t\t];\n\t\t} else {\n\t\t\tdecision[2] = wrapCondition(decision[2], lineId, getPositionStart(decision, parentPos));\n\t\t\tdecision[3] = wrapCondition(decision[3], lineId, getPositionEnd(decision, parentPos));\n\n\t\t\treturn decision;\n\t\t}\n\t}", "language": "javascript", "code": "function wrapCondition(decision, lineId, parentPos) {\n\t\tif (options.condition === false) {\n\t\t\t// condition coverage is disabled\n\t\t\treturn decision;\n\t\t}\n\n\t\tif (isSingleCondition(decision)) {\n\t\t\tvar pos = getPositionStart(decision, parentPos);\n\t\t\tvar condId = lineId + \":\" + pos;\n\n\t\t\tanalyzing.push(decision);\n\t\t\tallConditions.push(condId);\n\t\t\treturn [\"call\",\n                [\"dot\", [\"name\", \"require\"], \"coverage_condition\"],\n\t\t\t\t[\n\t\t\t\t\t[ \"string\", moduleName ],\n\t\t\t\t\t[ \"string\", condId],\n\t\t\t\t\tdecision\n\t\t\t\t]\n\t\t\t];\n\t\t} else {\n\t\t\tdecision[2] = wrapCondition(decision[2], lineId, getPositionStart(decision, parentPos));\n\t\t\tdecision[3] = wrapCondition(decision[3], lineId, getPositionEnd(decision, parentPos));\n\n\t\t\treturn decision;\n\t\t}\n\t}", "code_tokens": ["function", "wrapCondition", "(", "decision", ",", "lineId", ",", "parentPos", ")", "{", "if", "(", "options", ".", "condition", "===", "false", ")", "{", "// condition coverage is disabled", "return", "decision", ";", "}", "if", "(", "isSingleCondition", "(", "decision", ")", ")", "{", "var", "pos", "=", "getPositionStart", "(", "decision", ",", "parentPos", ")", ";", "var", "condId", "=", "lineId", "+", "\":\"", "+", "pos", ";", "analyzing", ".", "push", "(", "decision", ")", ";", "allConditions", ".", "push", "(", "condId", ")", ";", "return", "[", "\"call\"", ",", "[", "\"dot\"", ",", "[", "\"name\"", ",", "\"require\"", "]", ",", "\"coverage_condition\"", "]", ",", "[", "[", "\"string\"", ",", "moduleName", "]", ",", "[", "\"string\"", ",", "condId", "]", ",", "decision", "]", "]", ";", "}", "else", "{", "decision", "[", "2", "]", "=", "wrapCondition", "(", "decision", "[", "2", "]", ",", "lineId", ",", "getPositionStart", "(", "decision", ",", "parentPos", ")", ")", ";", "decision", "[", "3", "]", "=", "wrapCondition", "(", "decision", "[", "3", "]", ",", "lineId", ",", "getPositionEnd", "(", "decision", ",", "parentPos", ")", ")", ";", "return", "decision", ";", "}", "}"], "docstring": "This is the key function for condition coverage as it wraps every condition in\na function call.\nThe condition id is generated fron the lineId (@see countLine) plus the character\nposition of the condition.", "docstring_tokens": ["This", "is", "the", "key", "function", "for", "condition", "coverage", "as", "it", "wraps", "every", "condition", "in", "a", "function", "call", ".", "The", "condition", "id", "is", "generated", "fron", "the", "lineId", "("], "sha": "03410c36839728de683c697670e1b205dc8193ee", "url": "https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/lib/coverage_apply.js#L169-L195", "partition": "test"}
{"repo": "synacor/jan", "path": "doctemplate/static/scripts/enhancements.js", "func_name": "click", "original_string": "function click(e) {\n\t\tvar op = 'remove';\n\t\tif (this.className==='menuLink') {\n\t\t\top = document.body.classList.contains('menu-open') ? 'remove' : 'add';\n\t\t\te.preventDefault();\n\t\t}\n\t\tdocument.body.classList[op]('menu-open');\n\t}", "language": "javascript", "code": "function click(e) {\n\t\tvar op = 'remove';\n\t\tif (this.className==='menuLink') {\n\t\t\top = document.body.classList.contains('menu-open') ? 'remove' : 'add';\n\t\t\te.preventDefault();\n\t\t}\n\t\tdocument.body.classList[op]('menu-open');\n\t}", "code_tokens": ["function", "click", "(", "e", ")", "{", "var", "op", "=", "'remove'", ";", "if", "(", "this", ".", "className", "===", "'menuLink'", ")", "{", "op", "=", "document", ".", "body", ".", "classList", ".", "contains", "(", "'menu-open'", ")", "?", "'remove'", ":", "'add'", ";", "e", ".", "preventDefault", "(", ")", ";", "}", "document", ".", "body", ".", "classList", "[", "op", "]", "(", "'menu-open'", ")", ";", "}"], "docstring": "menu link is a toggle, sidebar links are close-only", "docstring_tokens": ["menu", "link", "is", "a", "toggle", "sidebar", "links", "are", "close", "-", "only"], "sha": "a53be0a3cda1f9b672b80b3d52588b10a4e0a31c", "url": "https://github.com/synacor/jan/blob/a53be0a3cda1f9b672b80b3d52588b10a4e0a31c/doctemplate/static/scripts/enhancements.js#L49-L56", "partition": "test"}
{"repo": "aliqin/atui", "path": "build/webpack.lib.js", "func_name": "initCompDirs", "original_string": "function initCompDirs(){\n  var compRoot = path.resolve(process.cwd(),'src/components'),\n      compReg  = /^[A-Z]\\w+$/;\n\n  //['Button', 'Select']\n  compDirs = fs.readdirSync(compRoot).filter(function(filename){\n    return compReg.test(filename)\n  })\n\n  return compDirs\n}", "language": "javascript", "code": "function initCompDirs(){\n  var compRoot = path.resolve(process.cwd(),'src/components'),\n      compReg  = /^[A-Z]\\w+$/;\n\n  //['Button', 'Select']\n  compDirs = fs.readdirSync(compRoot).filter(function(filename){\n    return compReg.test(filename)\n  })\n\n  return compDirs\n}", "code_tokens": ["function", "initCompDirs", "(", ")", "{", "var", "compRoot", "=", "path", ".", "resolve", "(", "process", ".", "cwd", "(", ")", ",", "'src/components'", ")", ",", "compReg", "=", "/", "^[A-Z]\\w+$", "/", ";", "//['Button', 'Select']", "compDirs", "=", "fs", ".", "readdirSync", "(", "compRoot", ")", ".", "filter", "(", "function", "(", "filename", ")", "{", "return", "compReg", ".", "test", "(", "filename", ")", "}", ")", "return", "compDirs", "}"], "docstring": "get all components dirs", "docstring_tokens": ["get", "all", "components", "dirs"], "sha": "910e25b2dd8db456b5f7e47b48271c898dcb9a21", "url": "https://github.com/aliqin/atui/blob/910e25b2dd8db456b5f7e47b48271c898dcb9a21/build/webpack.lib.js#L10-L20", "partition": "test"}
{"repo": "Strider-CD/strider", "path": "lib/middleware.js", "func_name": "requireBody", "original_string": "function requireBody(paramsList) {\n  return function (req, res, next) {\n    var errors = [];\n    var status = 'ok';\n\n    for (var i = 0; i < paramsList.length; i++) {\n      var val = req.body[paramsList[i]];\n\n      if (!val) {\n        errors.push(`required parameter \\`${paramsList[i]}\\` not found.`);\n        status = 'error';\n      }\n    }\n\n    if (errors.length === 0) {\n      next();\n    } else {\n      return res.status(400).json({\n        errors: errors,\n        status: status\n      });\n    }\n  };\n}", "language": "javascript", "code": "function requireBody(paramsList) {\n  return function (req, res, next) {\n    var errors = [];\n    var status = 'ok';\n\n    for (var i = 0; i < paramsList.length; i++) {\n      var val = req.body[paramsList[i]];\n\n      if (!val) {\n        errors.push(`required parameter \\`${paramsList[i]}\\` not found.`);\n        status = 'error';\n      }\n    }\n\n    if (errors.length === 0) {\n      next();\n    } else {\n      return res.status(400).json({\n        errors: errors,\n        status: status\n      });\n    }\n  };\n}", "code_tokens": ["function", "requireBody", "(", "paramsList", ")", "{", "return", "function", "(", "req", ",", "res", ",", "next", ")", "{", "var", "errors", "=", "[", "]", ";", "var", "status", "=", "'ok'", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "paramsList", ".", "length", ";", "i", "++", ")", "{", "var", "val", "=", "req", ".", "body", "[", "paramsList", "[", "i", "]", "]", ";", "if", "(", "!", "val", ")", "{", "errors", ".", "push", "(", "`", "\\`", "${", "paramsList", "[", "i", "]", "}", "\\`", "`", ")", ";", "status", "=", "'error'", ";", "}", "}", "if", "(", "errors", ".", "length", "===", "0", ")", "{", "next", "(", ")", ";", "}", "else", "{", "return", "res", ".", "status", "(", "400", ")", ".", "json", "(", "{", "errors", ":", "errors", ",", "status", ":", "status", "}", ")", ";", "}", "}", ";", "}"], "docstring": "Require the specified req.body parameters, or else return a 400 with a descriptive JSON body", "docstring_tokens": ["Require", "the", "specified", "req", ".", "body", "parameters", "or", "else", "return", "a", "400", "with", "a", "descriptive", "JSON", "body"], "sha": "56cafbc9687ebb7b67d485ec387a03cb85791c7c", "url": "https://github.com/Strider-CD/strider/blob/56cafbc9687ebb7b67d485ec387a03cb85791c7c/lib/middleware.js#L49-L72", "partition": "test"}
{"repo": "Kashoo/synctos", "path": "templates/sync-function/authorization-module.js", "func_name": "getAllDocChannels", "original_string": "function getAllDocChannels(docDefinition) {\n    var docChannelMap = utils.resolveDocumentConstraint(docDefinition.channels);\n\n    var allChannels = [ ];\n    if (docChannelMap) {\n      appendToAuthorizationList(allChannels, docChannelMap.view);\n      appendToAuthorizationList(allChannels, docChannelMap.write);\n      appendToAuthorizationList(allChannels, docChannelMap.add);\n      appendToAuthorizationList(allChannels, docChannelMap.replace);\n      appendToAuthorizationList(allChannels, docChannelMap.remove);\n    }\n\n    return allChannels;\n  }", "language": "javascript", "code": "function getAllDocChannels(docDefinition) {\n    var docChannelMap = utils.resolveDocumentConstraint(docDefinition.channels);\n\n    var allChannels = [ ];\n    if (docChannelMap) {\n      appendToAuthorizationList(allChannels, docChannelMap.view);\n      appendToAuthorizationList(allChannels, docChannelMap.write);\n      appendToAuthorizationList(allChannels, docChannelMap.add);\n      appendToAuthorizationList(allChannels, docChannelMap.replace);\n      appendToAuthorizationList(allChannels, docChannelMap.remove);\n    }\n\n    return allChannels;\n  }", "code_tokens": ["function", "getAllDocChannels", "(", "docDefinition", ")", "{", "var", "docChannelMap", "=", "utils", ".", "resolveDocumentConstraint", "(", "docDefinition", ".", "channels", ")", ";", "var", "allChannels", "=", "[", "]", ";", "if", "(", "docChannelMap", ")", "{", "appendToAuthorizationList", "(", "allChannels", ",", "docChannelMap", ".", "view", ")", ";", "appendToAuthorizationList", "(", "allChannels", ",", "docChannelMap", ".", "write", ")", ";", "appendToAuthorizationList", "(", "allChannels", ",", "docChannelMap", ".", "add", ")", ";", "appendToAuthorizationList", "(", "allChannels", ",", "docChannelMap", ".", "replace", ")", ";", "appendToAuthorizationList", "(", "allChannels", ",", "docChannelMap", ".", "remove", ")", ";", "}", "return", "allChannels", ";", "}"], "docstring": "Retrieves a list of channels the document belongs to based on its specified type", "docstring_tokens": ["Retrieves", "a", "list", "of", "channels", "the", "document", "belongs", "to", "based", "on", "its", "specified", "type"], "sha": "a6d59b4d4af2b837842d2107c57064c3fa12cc73", "url": "https://github.com/Kashoo/synctos/blob/a6d59b4d4af2b837842d2107c57064c3fa12cc73/templates/sync-function/authorization-module.js#L20-L33", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(child, collection, opts) {\n      // `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2\n      var index = opts.at !== undefined && (opts.index || collection.indexOf(child));\n  \n      // When filtered or when there is no initial index, calculate index.\n      if (this.getOption('filter') || index === false) {\n        index = _.indexOf(this._filteredSortedModels(index), child);\n      }\n  \n      if (this._shouldAddChild(child, index)) {\n        this.destroyEmptyView();\n        var ChildView = this.getChildView(child);\n        this.addChild(child, ChildView, index);\n      }\n    }", "language": "javascript", "code": "function(child, collection, opts) {\n      // `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2\n      var index = opts.at !== undefined && (opts.index || collection.indexOf(child));\n  \n      // When filtered or when there is no initial index, calculate index.\n      if (this.getOption('filter') || index === false) {\n        index = _.indexOf(this._filteredSortedModels(index), child);\n      }\n  \n      if (this._shouldAddChild(child, index)) {\n        this.destroyEmptyView();\n        var ChildView = this.getChildView(child);\n        this.addChild(child, ChildView, index);\n      }\n    }", "code_tokens": ["function", "(", "child", ",", "collection", ",", "opts", ")", "{", "// `index` is present when adding with `at` since BB 1.2; indexOf fallback for < 1.2", "var", "index", "=", "opts", ".", "at", "!==", "undefined", "&&", "(", "opts", ".", "index", "||", "collection", ".", "indexOf", "(", "child", ")", ")", ";", "// When filtered or when there is no initial index, calculate index.", "if", "(", "this", ".", "getOption", "(", "'filter'", ")", "||", "index", "===", "false", ")", "{", "index", "=", "_", ".", "indexOf", "(", "this", ".", "_filteredSortedModels", "(", "index", ")", ",", "child", ")", ";", "}", "if", "(", "this", ".", "_shouldAddChild", "(", "child", ",", "index", ")", ")", "{", "this", ".", "destroyEmptyView", "(", ")", ";", "var", "ChildView", "=", "this", ".", "getChildView", "(", "child", ")", ";", "this", ".", "addChild", "(", "child", ",", "ChildView", ",", "index", ")", ";", "}", "}"], "docstring": "Handle a child added to the collection", "docstring_tokens": ["Handle", "a", "child", "added", "to", "the", "collection"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18333-L18347", "partition": "test"}
{"repo": "jsantell/GhostTrain", "path": "lib/response.js", "func_name": "", "original_string": "function (body) {\n    var type = this.get('Content-Type');\n\n    if (type === 'application/json')\n      this._callback(JSON.parse(body || '{}'));\n    else\n      this._callback(body);\n  }", "language": "javascript", "code": "function (body) {\n    var type = this.get('Content-Type');\n\n    if (type === 'application/json')\n      this._callback(JSON.parse(body || '{}'));\n    else\n      this._callback(body);\n  }", "code_tokens": ["function", "(", "body", ")", "{", "var", "type", "=", "this", ".", "get", "(", "'Content-Type'", ")", ";", "if", "(", "type", "===", "'application/json'", ")", "this", ".", "_callback", "(", "JSON", ".", "parse", "(", "body", "||", "'{}'", ")", ")", ";", "else", "this", ".", "_callback", "(", "body", ")", ";", "}"], "docstring": "Formats response and calls initial callback\n\n@param {String} body", "docstring_tokens": ["Formats", "response", "and", "calls", "initial", "callback"], "sha": "e69b6cc33669035c1d571bff3805e1b6d8a50ccb", "url": "https://github.com/jsantell/GhostTrain/blob/e69b6cc33669035c1d571bff3805e1b6d8a50ccb/lib/response.js#L218-L225", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( model ) {\n\t\t\tvar coll = this.getCollection( model );\n\n\t\t\tif ( coll ) {\n\t\t\t\tvar modelColl = model.collection;\n\t\t\t\tcoll.add( model );\n\t\t\t\tthis.listenTo( model, 'destroy', this.unregister, this );\n\t\t\t\tthis.listenTo( model, 'relational:unregister', this.unregister, this );\n\t\t\t\tmodel.collection = modelColl;\n\t\t\t}\n\t\t}", "language": "javascript", "code": "function( model ) {\n\t\t\tvar coll = this.getCollection( model );\n\n\t\t\tif ( coll ) {\n\t\t\t\tvar modelColl = model.collection;\n\t\t\t\tcoll.add( model );\n\t\t\t\tthis.listenTo( model, 'destroy', this.unregister, this );\n\t\t\t\tthis.listenTo( model, 'relational:unregister', this.unregister, this );\n\t\t\t\tmodel.collection = modelColl;\n\t\t\t}\n\t\t}", "code_tokens": ["function", "(", "model", ")", "{", "var", "coll", "=", "this", ".", "getCollection", "(", "model", ")", ";", "if", "(", "coll", ")", "{", "var", "modelColl", "=", "model", ".", "collection", ";", "coll", ".", "add", "(", "model", ")", ";", "this", ".", "listenTo", "(", "model", ",", "'destroy'", ",", "this", ".", "unregister", ",", "this", ")", ";", "this", ".", "listenTo", "(", "model", ",", "'relational:unregister'", ",", "this", ".", "unregister", ",", "this", ")", ";", "model", ".", "collection", "=", "modelColl", ";", "}", "}"], "docstring": "Add a 'model' to its appropriate collection. Retain the original contents of 'model.collection'.\n@param {Backbone.RelationalModel} model", "docstring_tokens": ["Add", "a", "model", "to", "its", "appropriate", "collection", ".", "Retain", "the", "original", "contents", "of", "model", ".", "collection", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L418-L428", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/runtime/flash/Runtime.js", "func_name": "removeSWF", "original_string": "function removeSWF(id) {\n        var obj = Dom.get(id);\n        if (obj && obj.nodeName == \"OBJECT\") {\n            if (Env.browser === 'IE') {\n                obj.style.display = \"none\";\n                (function onInit(){\n                \t// http://msdn.microsoft.com/en-us/library/ie/ms534360(v=vs.85).aspx\n                    if (obj.readyState == 4) {\n                        removeObjectInIE(id);\n                    }\n                    else {\n                        setTimeout(onInit, 10);\n                    }\n                })();\n            }\n            else {\n                obj.parentNode.removeChild(obj);\n            }\n        }\n    }", "language": "javascript", "code": "function removeSWF(id) {\n        var obj = Dom.get(id);\n        if (obj && obj.nodeName == \"OBJECT\") {\n            if (Env.browser === 'IE') {\n                obj.style.display = \"none\";\n                (function onInit(){\n                \t// http://msdn.microsoft.com/en-us/library/ie/ms534360(v=vs.85).aspx\n                    if (obj.readyState == 4) {\n                        removeObjectInIE(id);\n                    }\n                    else {\n                        setTimeout(onInit, 10);\n                    }\n                })();\n            }\n            else {\n                obj.parentNode.removeChild(obj);\n            }\n        }\n    }", "code_tokens": ["function", "removeSWF", "(", "id", ")", "{", "var", "obj", "=", "Dom", ".", "get", "(", "id", ")", ";", "if", "(", "obj", "&&", "obj", ".", "nodeName", "==", "\"OBJECT\"", ")", "{", "if", "(", "Env", ".", "browser", "===", "'IE'", ")", "{", "obj", ".", "style", ".", "display", "=", "\"none\"", ";", "(", "function", "onInit", "(", ")", "{", "// http://msdn.microsoft.com/en-us/library/ie/ms534360(v=vs.85).aspx", "if", "(", "obj", ".", "readyState", "==", "4", ")", "{", "removeObjectInIE", "(", "id", ")", ";", "}", "else", "{", "setTimeout", "(", "onInit", ",", "10", ")", ";", "}", "}", ")", "(", ")", ";", "}", "else", "{", "obj", ".", "parentNode", ".", "removeChild", "(", "obj", ")", ";", "}", "}", "}"], "docstring": "Cross-browser SWF removal\n- Especially needed to safely and completely remove a SWF in Internet Explorer\n\nOriginated from SWFObject v2.2 <http://code.google.com/p/swfobject/>", "docstring_tokens": ["Cross", "-", "browser", "SWF", "removal", "-", "Especially", "needed", "to", "safely", "and", "completely", "remove", "a", "SWF", "in", "Internet", "Explorer"], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/runtime/flash/Runtime.js#L60-L79", "partition": "test"}
{"repo": "jeka-kiselyov/mdict", "path": "mdict-parser.js", "func_name": "", "original_string": "function(keyAt) {\n                var hi = (arr.length >> 1) - 1, lo = 0, i = (lo + hi) >> 1, val = arr[(i << 1) + 1];\n\n                if (keyAt > arr[(hi << 1) + 1] || keyAt < 0) {\n                  return;\n                }\n\n                while (true) {                    \n                  if (hi - lo <= 1) {\n                    if (i < hi) {\n                      return {\n                        block_no:     i,\n                        comp_offset:  arr[i <<= 1],\n                        comp_size:    arr[i + 2] - arr[i],\n                        decomp_offset:arr[i + 1],\n                        decomp_size:  arr[i + 3] - arr[i + 1]\n                      };\n                    } else {\n                      return;\n                    }\n                  }\n\n                  (keyAt < val)  ? hi = i : lo = i;\n                  i = (lo + hi) >> 1;\n                  val = arr[(i << 1) + 1];\n                }\n              }", "language": "javascript", "code": "function(keyAt) {\n                var hi = (arr.length >> 1) - 1, lo = 0, i = (lo + hi) >> 1, val = arr[(i << 1) + 1];\n\n                if (keyAt > arr[(hi << 1) + 1] || keyAt < 0) {\n                  return;\n                }\n\n                while (true) {                    \n                  if (hi - lo <= 1) {\n                    if (i < hi) {\n                      return {\n                        block_no:     i,\n                        comp_offset:  arr[i <<= 1],\n                        comp_size:    arr[i + 2] - arr[i],\n                        decomp_offset:arr[i + 1],\n                        decomp_size:  arr[i + 3] - arr[i + 1]\n                      };\n                    } else {\n                      return;\n                    }\n                  }\n\n                  (keyAt < val)  ? hi = i : lo = i;\n                  i = (lo + hi) >> 1;\n                  val = arr[(i << 1) + 1];\n                }\n              }", "code_tokens": ["function", "(", "keyAt", ")", "{", "var", "hi", "=", "(", "arr", ".", "length", ">>", "1", ")", "-", "1", ",", "lo", "=", "0", ",", "i", "=", "(", "lo", "+", "hi", ")", ">>", "1", ",", "val", "=", "arr", "[", "(", "i", "<<", "1", ")", "+", "1", "]", ";", "if", "(", "keyAt", ">", "arr", "[", "(", "hi", "<<", "1", ")", "+", "1", "]", "||", "keyAt", "<", "0", ")", "{", "return", ";", "}", "while", "(", "true", ")", "{", "if", "(", "hi", "-", "lo", "<=", "1", ")", "{", "if", "(", "i", "<", "hi", ")", "{", "return", "{", "block_no", ":", "i", ",", "comp_offset", ":", "arr", "[", "i", "<<=", "1", "]", ",", "comp_size", ":", "arr", "[", "i", "+", "2", "]", "-", "arr", "[", "i", "]", ",", "decomp_offset", ":", "arr", "[", "i", "+", "1", "]", ",", "decomp_size", ":", "arr", "[", "i", "+", "3", "]", "-", "arr", "[", "i", "+", "1", "]", "}", ";", "}", "else", "{", "return", ";", "}", "}", "(", "keyAt", "<", "val", ")", "?", "hi", "=", "i", ":", "lo", "=", "i", ";", "i", "=", "(", "lo", "+", "hi", ")", ">>", "1", ";", "val", "=", "arr", "[", "(", "i", "<<", "1", ")", "+", "1", "]", ";", "}", "}"], "docstring": "Given offset of a keyword after decompression, return a record block info containing it, else undefined if not found.", "docstring_tokens": ["Given", "offset", "of", "a", "keyword", "after", "decompression", "return", "a", "record", "block", "info", "containing", "it", "else", "undefined", "if", "not", "found", "."], "sha": "540898e63991cb0c8985ed8fb29eb11a59f35089", "url": "https://github.com/jeka-kiselyov/mdict/blob/540898e63991cb0c8985ed8fb29eb11a59f35089/mdict-parser.js#L242-L268", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/arraybuffer.js", "func_name": "equals", "original_string": "function equals(buf1, buf2) {\n    if (buf1.byteLength != buf2.byteLength) return false;\n    const dv1 = new Int8Array(buf1);\n    const dv2 = new Int8Array(buf2);\n    for (let i = 0 ; i != buf1.byteLength ; i++) {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}", "language": "javascript", "code": "function equals(buf1, buf2) {\n    if (buf1.byteLength != buf2.byteLength) return false;\n    const dv1 = new Int8Array(buf1);\n    const dv2 = new Int8Array(buf2);\n    for (let i = 0 ; i != buf1.byteLength ; i++) {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}", "code_tokens": ["function", "equals", "(", "buf1", ",", "buf2", ")", "{", "if", "(", "buf1", ".", "byteLength", "!=", "buf2", ".", "byteLength", ")", "return", "false", ";", "const", "dv1", "=", "new", "Int8Array", "(", "buf1", ")", ";", "const", "dv2", "=", "new", "Int8Array", "(", "buf2", ")", ";", "for", "(", "let", "i", "=", "0", ";", "i", "!=", "buf1", ".", "byteLength", ";", "i", "++", ")", "{", "if", "(", "dv1", "[", "i", "]", "!=", "dv2", "[", "i", "]", ")", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Tests equality of two ArrayBuffer\n@param {ArrayBuffer} buf1\n@param {ArrayBuffer} buf2\n@return {Boolean}", "docstring_tokens": ["Tests", "equality", "of", "two", "ArrayBuffer"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/arraybuffer.js#L92-L100", "partition": "test"}
{"repo": "joostlawerman/SnackbarLightjs", "path": "dist/snackbarlight.js", "func_name": "", "original_string": "function(newOptions) {\n\t\tvar __self = this,\n  \t\t\toptions = newOptions || {};\n\n    \tfor (var opt in this.options) {\n        \tif (__self.options.hasOwnProperty(opt) && !options.hasOwnProperty(opt)) {\n            \toptions[opt] = __self.options[opt];\n        \t}\n        }\n       \treturn options;\n\t}", "language": "javascript", "code": "function(newOptions) {\n\t\tvar __self = this,\n  \t\t\toptions = newOptions || {};\n\n    \tfor (var opt in this.options) {\n        \tif (__self.options.hasOwnProperty(opt) && !options.hasOwnProperty(opt)) {\n            \toptions[opt] = __self.options[opt];\n        \t}\n        }\n       \treturn options;\n\t}", "code_tokens": ["function", "(", "newOptions", ")", "{", "var", "__self", "=", "this", ",", "options", "=", "newOptions", "||", "{", "}", ";", "for", "(", "var", "opt", "in", "this", ".", "options", ")", "{", "if", "(", "__self", ".", "options", ".", "hasOwnProperty", "(", "opt", ")", "&&", "!", "options", ".", "hasOwnProperty", "(", "opt", ")", ")", "{", "options", "[", "opt", "]", "=", "__self", ".", "options", "[", "opt", "]", ";", "}", "}", "return", "options", ";", "}"], "docstring": "Compare the options to the default ones.\n\n@param  {Object} newOptions\n@return {Object}", "docstring_tokens": ["Compare", "the", "options", "to", "the", "default", "ones", "."], "sha": "b5a980b8aff9d076cffa33a9e1d88e8ee57a319f", "url": "https://github.com/joostlawerman/SnackbarLightjs/blob/b5a980b8aff9d076cffa33a9e1d88e8ee57a319f/dist/snackbarlight.js#L181-L191", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/encoder.js", "func_name": "Encoder", "original_string": "function Encoder(protocolVersion, options) {\n  this.encodingOptions = options.encoding || utils.emptyObject;\n  defineInstanceMembers.call(this);\n  this.setProtocolVersion(protocolVersion);\n  setEncoders.call(this);\n  if (this.encodingOptions.copyBuffer) {\n    this.handleBuffer = handleBufferCopy;\n  }\n  else {\n    this.handleBuffer = handleBufferRef;\n  }\n}", "language": "javascript", "code": "function Encoder(protocolVersion, options) {\n  this.encodingOptions = options.encoding || utils.emptyObject;\n  defineInstanceMembers.call(this);\n  this.setProtocolVersion(protocolVersion);\n  setEncoders.call(this);\n  if (this.encodingOptions.copyBuffer) {\n    this.handleBuffer = handleBufferCopy;\n  }\n  else {\n    this.handleBuffer = handleBufferRef;\n  }\n}", "code_tokens": ["function", "Encoder", "(", "protocolVersion", ",", "options", ")", "{", "this", ".", "encodingOptions", "=", "options", ".", "encoding", "||", "utils", ".", "emptyObject", ";", "defineInstanceMembers", ".", "call", "(", "this", ")", ";", "this", ".", "setProtocolVersion", "(", "protocolVersion", ")", ";", "setEncoders", ".", "call", "(", "this", ")", ";", "if", "(", "this", ".", "encodingOptions", ".", "copyBuffer", ")", "{", "this", ".", "handleBuffer", "=", "handleBufferCopy", ";", "}", "else", "{", "this", ".", "handleBuffer", "=", "handleBufferRef", ";", "}", "}"], "docstring": "Serializes and deserializes to and from a CQL type and a Javascript Type.\n@param {Number} protocolVersion\n@param {ClientOptions} options\n@constructor", "docstring_tokens": ["Serializes", "and", "deserializes", "to", "and", "from", "a", "CQL", "type", "and", "a", "Javascript", "Type", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/encoder.js#L101-L112", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "match", "original_string": "function match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n    if (negate) {\n      pattern = pattern.slice(1);\n    }\n\n    // we need to remove the character regardless,\n    // so the above logic is still needed\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n  var len = files.length, i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) { continue; }\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  }\n\n  // if `negate` was defined, diff negated files\n  if (negate) { res = utils.diff(files, res); }\n\n  // if `ignore` was defined, diff ignored filed\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n  return res;\n}", "language": "javascript", "code": "function match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n    if (negate) {\n      pattern = pattern.slice(1);\n    }\n\n    // we need to remove the character regardless,\n    // so the above logic is still needed\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n  var len = files.length, i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) { continue; }\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  }\n\n  // if `negate` was defined, diff negated files\n  if (negate) { res = utils.diff(files, res); }\n\n  // if `ignore` was defined, diff ignored filed\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n  return res;\n}", "code_tokens": ["function", "match", "(", "files", ",", "pattern", ",", "opts", ")", "{", "if", "(", "utils", ".", "typeOf", "(", "files", ")", "!==", "'string'", "&&", "!", "Array", ".", "isArray", "(", "files", ")", ")", "{", "throw", "new", "Error", "(", "msg", "(", "'match'", ",", "'files'", ",", "'a string or array'", ")", ")", ";", "}", "files", "=", "utils", ".", "arrayify", "(", "files", ")", ";", "opts", "=", "opts", "||", "{", "}", ";", "var", "negate", "=", "opts", ".", "negate", "||", "false", ";", "var", "orig", "=", "pattern", ";", "if", "(", "typeof", "pattern", "===", "'string'", ")", "{", "negate", "=", "pattern", ".", "charAt", "(", "0", ")", "===", "'!'", ";", "if", "(", "negate", ")", "{", "pattern", "=", "pattern", ".", "slice", "(", "1", ")", ";", "}", "// we need to remove the character regardless,", "// so the above logic is still needed", "if", "(", "opts", ".", "nonegate", "===", "true", ")", "{", "negate", "=", "false", ";", "}", "}", "var", "_isMatch", "=", "matcher", "(", "pattern", ",", "opts", ")", ";", "var", "len", "=", "files", ".", "length", ",", "i", "=", "0", ";", "var", "res", "=", "[", "]", ";", "while", "(", "i", "<", "len", ")", "{", "var", "file", "=", "files", "[", "i", "++", "]", ";", "var", "fp", "=", "utils", ".", "unixify", "(", "file", ",", "opts", ")", ";", "if", "(", "!", "_isMatch", "(", "fp", ")", ")", "{", "continue", ";", "}", "res", ".", "push", "(", "fp", ")", ";", "}", "if", "(", "res", ".", "length", "===", "0", ")", "{", "if", "(", "opts", ".", "failglob", "===", "true", ")", "{", "throw", "new", "Error", "(", "'micromatch.match() found no matches for: \"'", "+", "orig", "+", "'\".'", ")", ";", "}", "if", "(", "opts", ".", "nonull", "||", "opts", ".", "nullglob", ")", "{", "res", ".", "push", "(", "utils", ".", "unescapeGlob", "(", "orig", ")", ")", ";", "}", "}", "// if `negate` was defined, diff negated files", "if", "(", "negate", ")", "{", "res", "=", "utils", ".", "diff", "(", "files", ",", "res", ")", ";", "}", "// if `ignore` was defined, diff ignored filed", "if", "(", "opts", ".", "ignore", "&&", "opts", ".", "ignore", ".", "length", ")", "{", "pattern", "=", "opts", ".", "ignore", ";", "opts", "=", "utils", ".", "omit", "(", "opts", ",", "[", "'ignore'", "]", ")", ";", "res", "=", "utils", ".", "diff", "(", "res", ",", "micromatch", "(", "res", ",", "pattern", ",", "opts", ")", ")", ";", "}", "if", "(", "opts", ".", "nodupes", ")", "{", "return", "utils", ".", "unique", "(", "res", ")", ";", "}", "return", "res", ";", "}"], "docstring": "Return an array of files that match the given glob pattern.\n\nThis function is called by the main `micromatch` function If you only\nneed to pass a single pattern you might get very minor speed improvements\nusing this function.\n\n@param  {Array} `files`\n@param  {String} `pattern`\n@param  {Object} `options`\n@return {Array}", "docstring_tokens": ["Return", "an", "array", "of", "files", "that", "match", "the", "given", "glob", "pattern", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L42098-L42158", "partition": "test"}
{"repo": "emmetio/codemirror-plugin", "path": "lib/autocomplete.js", "func_name": "getSnippetCompletions", "original_string": "function getSnippetCompletions(editor, pos, config) {\n\tconst { type, syntax } = config;\n\n\tif (!editor.state.emmetCompletions) {\n\t\teditor.state.emmetCompletions = {};\n\t}\n\n\tconst cache = editor.state.emmetCompletions;\n\n\tif (!(syntax in cache)) {\n\t\tconst registry = createSnippetsRegistry(type, syntax, config.snippets);\n\n\t\tcache[syntax] = type === 'stylesheet'\n\t\t\t? getStylesheetSnippets(registry, config)\n\t\t\t: getMarkupSnippets(registry, config);\n\t}\n\n\treturn cache[syntax];\n}", "language": "javascript", "code": "function getSnippetCompletions(editor, pos, config) {\n\tconst { type, syntax } = config;\n\n\tif (!editor.state.emmetCompletions) {\n\t\teditor.state.emmetCompletions = {};\n\t}\n\n\tconst cache = editor.state.emmetCompletions;\n\n\tif (!(syntax in cache)) {\n\t\tconst registry = createSnippetsRegistry(type, syntax, config.snippets);\n\n\t\tcache[syntax] = type === 'stylesheet'\n\t\t\t? getStylesheetSnippets(registry, config)\n\t\t\t: getMarkupSnippets(registry, config);\n\t}\n\n\treturn cache[syntax];\n}", "code_tokens": ["function", "getSnippetCompletions", "(", "editor", ",", "pos", ",", "config", ")", "{", "const", "{", "type", ",", "syntax", "}", "=", "config", ";", "if", "(", "!", "editor", ".", "state", ".", "emmetCompletions", ")", "{", "editor", ".", "state", ".", "emmetCompletions", "=", "{", "}", ";", "}", "const", "cache", "=", "editor", ".", "state", ".", "emmetCompletions", ";", "if", "(", "!", "(", "syntax", "in", "cache", ")", ")", "{", "const", "registry", "=", "createSnippetsRegistry", "(", "type", ",", "syntax", ",", "config", ".", "snippets", ")", ";", "cache", "[", "syntax", "]", "=", "type", "===", "'stylesheet'", "?", "getStylesheetSnippets", "(", "registry", ",", "config", ")", ":", "getMarkupSnippets", "(", "registry", ",", "config", ")", ";", "}", "return", "cache", "[", "syntax", "]", ";", "}"], "docstring": "Returns all possible snippets completions for given editor context.\nCompletions are cached in editor for for re-use\n@param  {CodeMirror.Editor} editor\n@param  {CodeMirror.Position} pos\n@param  {Object} config\n@return {Array}", "docstring_tokens": ["Returns", "all", "possible", "snippets", "completions", "for", "given", "editor", "context", ".", "Completions", "are", "cached", "in", "editor", "for", "for", "re", "-", "use"], "sha": "2089c8b15b97858b82b33e6e81ee1b50954581c1", "url": "https://github.com/emmetio/codemirror-plugin/blob/2089c8b15b97858b82b33e6e81ee1b50954581c1/lib/autocomplete.js#L126-L144", "partition": "test"}
{"repo": "acarl005/join-monster", "path": "src/query-ast-to-sql-ast/index.js", "func_name": "keyToASTChild", "original_string": "function keyToASTChild(key, namespace) {\n  if (typeof key === 'string') {\n    return columnToASTChild(key, namespace)\n  }\n  if (Array.isArray(key)) {\n    const clumsyName = toClumsyName(key)\n    return {\n      type: 'composite',\n      name: key,\n      fieldName: clumsyName,\n      as: namespace.generate('column', clumsyName)\n    }\n  }\n}", "language": "javascript", "code": "function keyToASTChild(key, namespace) {\n  if (typeof key === 'string') {\n    return columnToASTChild(key, namespace)\n  }\n  if (Array.isArray(key)) {\n    const clumsyName = toClumsyName(key)\n    return {\n      type: 'composite',\n      name: key,\n      fieldName: clumsyName,\n      as: namespace.generate('column', clumsyName)\n    }\n  }\n}", "code_tokens": ["function", "keyToASTChild", "(", "key", ",", "namespace", ")", "{", "if", "(", "typeof", "key", "===", "'string'", ")", "{", "return", "columnToASTChild", "(", "key", ",", "namespace", ")", "}", "if", "(", "Array", ".", "isArray", "(", "key", ")", ")", "{", "const", "clumsyName", "=", "toClumsyName", "(", "key", ")", "return", "{", "type", ":", "'composite'", ",", "name", ":", "key", ",", "fieldName", ":", "clumsyName", ",", "as", ":", "namespace", ".", "generate", "(", "'column'", ",", "clumsyName", ")", "}", "}", "}"], "docstring": "keys are necessary for deduplication during the hydration process this will handle singular or composite keys", "docstring_tokens": ["keys", "are", "necessary", "for", "deduplication", "during", "the", "hydration", "process", "this", "will", "handle", "singular", "or", "composite", "keys"], "sha": "8db8b54aaefd2fd975d63e2ab3ec05922e25118c", "url": "https://github.com/acarl005/join-monster/blob/8db8b54aaefd2fd975d63e2ab3ec05922e25118c/src/query-ast-to-sql-ast/index.js#L501-L514", "partition": "test"}
{"repo": "bholloway/browserify-nginject", "path": "lib/infer-angular.js", "func_name": "getAnnotationCandidates", "original_string": "function getAnnotationCandidates(node) {\n  var callExpression = testNode.isModuleExpression(node) && node.parent;\n  if (callExpression) {\n    return callExpression['arguments']\n      .filter(testNode.anyOf(testNode.isFunction, testNode.isIdentifier))\n      .pop();\n  } else {\n    return null;\n  }\n}", "language": "javascript", "code": "function getAnnotationCandidates(node) {\n  var callExpression = testNode.isModuleExpression(node) && node.parent;\n  if (callExpression) {\n    return callExpression['arguments']\n      .filter(testNode.anyOf(testNode.isFunction, testNode.isIdentifier))\n      .pop();\n  } else {\n    return null;\n  }\n}", "code_tokens": ["function", "getAnnotationCandidates", "(", "node", ")", "{", "var", "callExpression", "=", "testNode", ".", "isModuleExpression", "(", "node", ")", "&&", "node", ".", "parent", ";", "if", "(", "callExpression", ")", "{", "return", "callExpression", "[", "'arguments'", "]", ".", "filter", "(", "testNode", ".", "anyOf", "(", "testNode", ".", "isFunction", ",", "testNode", ".", "isIdentifier", ")", ")", ".", "pop", "(", ")", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "docstring": "Find inject candidates\n@param {object} node An esprima syntax tree\n@returns {object|null} A node that may need annotation, or null where not suitable", "docstring_tokens": ["Find", "inject", "candidates"], "sha": "42cff52081b66d77e4e7fac923d4d824de13cfd3", "url": "https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/infer-angular.js#L26-L35", "partition": "test"}
{"repo": "Strider-CD/strider", "path": "lib/websockets.js", "func_name": "", "original_string": "function (socket) {\n    var session = socket.handshake.session;\n\n    if (session && session.passport) {\n      this.addSocket(session.passport.user, socket);\n    } else {\n      console.debug('Websocket connection does not have authorization - nothing to do.');\n    }\n  }", "language": "javascript", "code": "function (socket) {\n    var session = socket.handshake.session;\n\n    if (session && session.passport) {\n      this.addSocket(session.passport.user, socket);\n    } else {\n      console.debug('Websocket connection does not have authorization - nothing to do.');\n    }\n  }", "code_tokens": ["function", "(", "socket", ")", "{", "var", "session", "=", "socket", ".", "handshake", ".", "session", ";", "if", "(", "session", "&&", "session", ".", "passport", ")", "{", "this", ".", "addSocket", "(", "session", ".", "passport", ".", "user", ",", "socket", ")", ";", "}", "else", "{", "console", ".", "debug", "(", "'Websocket connection does not have authorization - nothing to do.'", ")", ";", "}", "}"], "docstring": "socket callback. Adds a new socket", "docstring_tokens": ["socket", "callback", ".", "Adds", "a", "new", "socket"], "sha": "56cafbc9687ebb7b67d485ec387a03cb85791c7c", "url": "https://github.com/Strider-CD/strider/blob/56cafbc9687ebb7b67d485ec387a03cb85791c7c/lib/websockets.js#L45-L53", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/Component.js", "func_name": "", "original_string": "function(selector) {\n        var result = this.parent;\n\n        if (selector) {\n            for (; result; result = result.parent) {\n                if (Ext.ComponentQuery.is(result, selector)) {\n                    return result;\n                }\n            }\n        }\n        return result;\n    }", "language": "javascript", "code": "function(selector) {\n        var result = this.parent;\n\n        if (selector) {\n            for (; result; result = result.parent) {\n                if (Ext.ComponentQuery.is(result, selector)) {\n                    return result;\n                }\n            }\n        }\n        return result;\n    }", "code_tokens": ["function", "(", "selector", ")", "{", "var", "result", "=", "this", ".", "parent", ";", "if", "(", "selector", ")", "{", "for", "(", ";", "result", ";", "result", "=", "result", ".", "parent", ")", "{", "if", "(", "Ext", ".", "ComponentQuery", ".", "is", "(", "result", ",", "selector", ")", ")", "{", "return", "result", ";", "}", "}", "}", "return", "result", ";", "}"], "docstring": "Walks up the `ownerCt` axis looking for an ancestor Container which matches\nthe passed simple selector.\n\nExample:\n\nvar owningTabPanel = grid.up('tabpanel');\n\n@param {String} selector (optional) The simple selector to test.\n@return {Ext.Container} The matching ancestor Container (or `undefined` if no match was found).", "docstring_tokens": ["Walks", "up", "the", "ownerCt", "axis", "looking", "for", "an", "ancestor", "Container", "which", "matches", "the", "passed", "simple", "selector", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/Component.js#L2658-L2669", "partition": "test"}
{"repo": "localvoid/karma-snapshot", "path": "lib/format/markdown.js", "func_name": "tryExit", "original_string": "function tryExit(state, depth) {\n  while (state.depth >= depth) {\n    state.suiteStack.pop();\n    state.currentSuite = state.suiteStack[state.suiteStack.length - 1];\n    state.currentSnapshotList = null;\n    state.depth--;\n  }\n}", "language": "javascript", "code": "function tryExit(state, depth) {\n  while (state.depth >= depth) {\n    state.suiteStack.pop();\n    state.currentSuite = state.suiteStack[state.suiteStack.length - 1];\n    state.currentSnapshotList = null;\n    state.depth--;\n  }\n}", "code_tokens": ["function", "tryExit", "(", "state", ",", "depth", ")", "{", "while", "(", "state", ".", "depth", ">=", "depth", ")", "{", "state", ".", "suiteStack", ".", "pop", "(", ")", ";", "state", ".", "currentSuite", "=", "state", ".", "suiteStack", "[", "state", ".", "suiteStack", ".", "length", "-", "1", "]", ";", "state", ".", "currentSnapshotList", "=", "null", ";", "state", ".", "depth", "--", ";", "}", "}"], "docstring": "tryExit tries to pop state until it has correct depth.\n\n@param {SerializerState} state Current state.\n@param {number} depth Current depth.", "docstring_tokens": ["tryExit", "tries", "to", "pop", "state", "until", "it", "has", "correct", "depth", "."], "sha": "ec3f41bab775b5be6d3aa236f55ee12881b25662", "url": "https://github.com/localvoid/karma-snapshot/blob/ec3f41bab775b5be6d3aa236f55ee12881b25662/lib/format/markdown.js#L66-L73", "partition": "test"}
{"repo": "unfoldingWord-dev/node-resource-container", "path": "__mocks__/fs.js", "func_name": "writePath", "original_string": "function writePath(parentDir, path, data) {\n    let files = path.split('/');\n    let file = files.shift();\n\n    // init file\n    if(!parentDir[file]) parentDir[file] = {\n        content: undefined,\n        tree: {}\n    };\n\n    if(files.length > 0) {\n        writePath(parentDir[file].tree, files.join('/'), data);\n    } else if(data) {\n        parentDir[file].content = data.toString();\n    }\n}", "language": "javascript", "code": "function writePath(parentDir, path, data) {\n    let files = path.split('/');\n    let file = files.shift();\n\n    // init file\n    if(!parentDir[file]) parentDir[file] = {\n        content: undefined,\n        tree: {}\n    };\n\n    if(files.length > 0) {\n        writePath(parentDir[file].tree, files.join('/'), data);\n    } else if(data) {\n        parentDir[file].content = data.toString();\n    }\n}", "code_tokens": ["function", "writePath", "(", "parentDir", ",", "path", ",", "data", ")", "{", "let", "files", "=", "path", ".", "split", "(", "'/'", ")", ";", "let", "file", "=", "files", ".", "shift", "(", ")", ";", "// init file", "if", "(", "!", "parentDir", "[", "file", "]", ")", "parentDir", "[", "file", "]", "=", "{", "content", ":", "undefined", ",", "tree", ":", "{", "}", "}", ";", "if", "(", "files", ".", "length", ">", "0", ")", "{", "writePath", "(", "parentDir", "[", "file", "]", ".", "tree", ",", "files", ".", "join", "(", "'/'", ")", ",", "data", ")", ";", "}", "else", "if", "(", "data", ")", "{", "parentDir", "[", "file", "]", ".", "content", "=", "data", ".", "toString", "(", ")", ";", "}", "}"], "docstring": "Recursively creates a file\n@param parentDir\n@param path\n@param data", "docstring_tokens": ["Recursively", "creates", "a", "file"], "sha": "20c4b7bfd2fa3f397ee7e0e743567822912c305b", "url": "https://github.com/unfoldingWord-dev/node-resource-container/blob/20c4b7bfd2fa3f397ee7e0e743567822912c305b/__mocks__/fs.js#L11-L26", "partition": "test"}
{"repo": "Raynos/graphics", "path": "examples/full/todo.js", "func_name": "mainSection", "original_string": "function mainSection(state) {\n    var todos = state.todos\n    var route = state.route\n\n    return h(\"section.main\", { hidden: todos.length === 0 }, [\n        toggleAllPool.change(h(\"input#toggle-all.toggle-all\", {\n            type: \"checkbox\",\n            checked: todos.every(function (todo) {\n                return todo.completed\n            })\n        })),\n        h(\"label\", { htmlFor: \"toggle-all\" }, \"Mark all as complete\"),\n        h(\"ul.todo-list\", todos.filter(function (todo) {\n            return route === \"completed\" && todo.completed ||\n                route === \"active\" && !todo.completed ||\n                route === \"all\"\n        }).map(todoItem))\n    ])\n}", "language": "javascript", "code": "function mainSection(state) {\n    var todos = state.todos\n    var route = state.route\n\n    return h(\"section.main\", { hidden: todos.length === 0 }, [\n        toggleAllPool.change(h(\"input#toggle-all.toggle-all\", {\n            type: \"checkbox\",\n            checked: todos.every(function (todo) {\n                return todo.completed\n            })\n        })),\n        h(\"label\", { htmlFor: \"toggle-all\" }, \"Mark all as complete\"),\n        h(\"ul.todo-list\", todos.filter(function (todo) {\n            return route === \"completed\" && todo.completed ||\n                route === \"active\" && !todo.completed ||\n                route === \"all\"\n        }).map(todoItem))\n    ])\n}", "code_tokens": ["function", "mainSection", "(", "state", ")", "{", "var", "todos", "=", "state", ".", "todos", "var", "route", "=", "state", ".", "route", "return", "h", "(", "\"section.main\"", ",", "{", "hidden", ":", "todos", ".", "length", "===", "0", "}", ",", "[", "toggleAllPool", ".", "change", "(", "h", "(", "\"input#toggle-all.toggle-all\"", ",", "{", "type", ":", "\"checkbox\"", ",", "checked", ":", "todos", ".", "every", "(", "function", "(", "todo", ")", "{", "return", "todo", ".", "completed", "}", ")", "}", ")", ")", ",", "h", "(", "\"label\"", ",", "{", "htmlFor", ":", "\"toggle-all\"", "}", ",", "\"Mark all as complete\"", ")", ",", "h", "(", "\"ul.todo-list\"", ",", "todos", ".", "filter", "(", "function", "(", "todo", ")", "{", "return", "route", "===", "\"completed\"", "&&", "todo", ".", "completed", "||", "route", "===", "\"active\"", "&&", "!", "todo", ".", "completed", "||", "route", "===", "\"all\"", "}", ")", ".", "map", "(", "todoItem", ")", ")", "]", ")", "}"], "docstring": "Various template functions to render subsets of the UI", "docstring_tokens": ["Various", "template", "functions", "to", "render", "subsets", "of", "the", "UI"], "sha": "6c156db7419c9f02b22d277c0579432c7f261e68", "url": "https://github.com/Raynos/graphics/blob/6c156db7419c9f02b22d277c0579432c7f261e68/examples/full/todo.js#L84-L102", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/directory.js", "func_name": "readFilenamesRecursive", "original_string": "function readFilenamesRecursive(repoState, dirName) {\n    dirName = PathUtils.norm(dirName);\n\n    const workingState = repoState.getCurrentState();\n    const fileSet = WorkingUtils.getMergedFileSet(workingState);\n\n    return fileSet.filter((path) => {\n        return PathUtils.contains(dirName, path);\n    }).toArray();\n}", "language": "javascript", "code": "function readFilenamesRecursive(repoState, dirName) {\n    dirName = PathUtils.norm(dirName);\n\n    const workingState = repoState.getCurrentState();\n    const fileSet = WorkingUtils.getMergedFileSet(workingState);\n\n    return fileSet.filter((path) => {\n        return PathUtils.contains(dirName, path);\n    }).toArray();\n}", "code_tokens": ["function", "readFilenamesRecursive", "(", "repoState", ",", "dirName", ")", "{", "dirName", "=", "PathUtils", ".", "norm", "(", "dirName", ")", ";", "const", "workingState", "=", "repoState", ".", "getCurrentState", "(", ")", ";", "const", "fileSet", "=", "WorkingUtils", ".", "getMergedFileSet", "(", "workingState", ")", ";", "return", "fileSet", ".", "filter", "(", "(", "path", ")", "=>", "{", "return", "PathUtils", ".", "contains", "(", "dirName", ",", "path", ")", ";", "}", ")", ".", "toArray", "(", ")", ";", "}"], "docstring": "List files recursively in a directory\n@param {RepositoryState} repoState\n@param {Path} dirName\n@return {Array<Path>}", "docstring_tokens": ["List", "files", "recursively", "in", "a", "directory"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/directory.js#L98-L107", "partition": "test"}
{"repo": "rhysd/rehype-react", "path": "index.js", "func_name": "rehype2react", "original_string": "function rehype2react(options) {\n  var settings = options || {};\n  var createElement = settings.createElement;\n  var components = settings.components || {};\n\n  this.Compiler = compiler;\n\n  /* Compile HAST to React. */\n  function compiler(node) {\n    if (node.type === 'root') {\n      if (node.children.length === 1 && node.children[0].type === 'element') {\n        node = node.children[0];\n      } else {\n        node = {\n          type: 'element',\n          tagName: 'div',\n          properties: node.properties || {},\n          children: node.children\n        };\n      }\n    }\n\n    return toH(h, tableCellStyle(node), settings.prefix);\n  }\n\n  /* Wrap `createElement` to pass components in. */\n  function h(name, props, children) {\n    var component = has(components, name) ? components[name] : name;\n    return createElement(component, props, children);\n  }\n}", "language": "javascript", "code": "function rehype2react(options) {\n  var settings = options || {};\n  var createElement = settings.createElement;\n  var components = settings.components || {};\n\n  this.Compiler = compiler;\n\n  /* Compile HAST to React. */\n  function compiler(node) {\n    if (node.type === 'root') {\n      if (node.children.length === 1 && node.children[0].type === 'element') {\n        node = node.children[0];\n      } else {\n        node = {\n          type: 'element',\n          tagName: 'div',\n          properties: node.properties || {},\n          children: node.children\n        };\n      }\n    }\n\n    return toH(h, tableCellStyle(node), settings.prefix);\n  }\n\n  /* Wrap `createElement` to pass components in. */\n  function h(name, props, children) {\n    var component = has(components, name) ? components[name] : name;\n    return createElement(component, props, children);\n  }\n}", "code_tokens": ["function", "rehype2react", "(", "options", ")", "{", "var", "settings", "=", "options", "||", "{", "}", ";", "var", "createElement", "=", "settings", ".", "createElement", ";", "var", "components", "=", "settings", ".", "components", "||", "{", "}", ";", "this", ".", "Compiler", "=", "compiler", ";", "/* Compile HAST to React. */", "function", "compiler", "(", "node", ")", "{", "if", "(", "node", ".", "type", "===", "'root'", ")", "{", "if", "(", "node", ".", "children", ".", "length", "===", "1", "&&", "node", ".", "children", "[", "0", "]", ".", "type", "===", "'element'", ")", "{", "node", "=", "node", ".", "children", "[", "0", "]", ";", "}", "else", "{", "node", "=", "{", "type", ":", "'element'", ",", "tagName", ":", "'div'", ",", "properties", ":", "node", ".", "properties", "||", "{", "}", ",", "children", ":", "node", ".", "children", "}", ";", "}", "}", "return", "toH", "(", "h", ",", "tableCellStyle", "(", "node", ")", ",", "settings", ".", "prefix", ")", ";", "}", "/* Wrap `createElement` to pass components in. */", "function", "h", "(", "name", ",", "props", ",", "children", ")", "{", "var", "component", "=", "has", "(", "components", ",", "name", ")", "?", "components", "[", "name", "]", ":", "name", ";", "return", "createElement", "(", "component", ",", "props", ",", "children", ")", ";", "}", "}"], "docstring": "Attach a react compiler.\n\n@param {Unified} processor - Instance.\n@param {Object?} [options]\n@param {Object?} [options.components]\n- Components.\n@param {string?} [options.prefix]\n- Key prefix.\n@param {Function?} [options.createElement]\n- `h()`.", "docstring_tokens": ["Attach", "a", "react", "compiler", "."], "sha": "4f352b985ac89383a1d4e38270adb251388a849a", "url": "https://github.com/rhysd/rehype-react/blob/4f352b985ac89383a1d4e38270adb251388a849a/index.js#L23-L53", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "zoomFit", "original_string": "function zoomFit()\n   {\n      var bounds = graph.node().getBBox();\n      var parent = graph.node().parentElement;\n      var fullWidth = parent.clientWidth, fullHeight = parent.clientHeight;\n      var width = bounds.width, height = bounds.height;\n\n      if (width === 0 || height === 0) { return 1; } // nothing to fit\n\n      var scale = 0.75 / Math.max(width / fullWidth, height / fullHeight);\n\n      scale = Math.max(Math.min(scale, maxScaleExtent), minScaleExtent);\n\n      return scale;\n   }", "language": "javascript", "code": "function zoomFit()\n   {\n      var bounds = graph.node().getBBox();\n      var parent = graph.node().parentElement;\n      var fullWidth = parent.clientWidth, fullHeight = parent.clientHeight;\n      var width = bounds.width, height = bounds.height;\n\n      if (width === 0 || height === 0) { return 1; } // nothing to fit\n\n      var scale = 0.75 / Math.max(width / fullWidth, height / fullHeight);\n\n      scale = Math.max(Math.min(scale, maxScaleExtent), minScaleExtent);\n\n      return scale;\n   }", "code_tokens": ["function", "zoomFit", "(", ")", "{", "var", "bounds", "=", "graph", ".", "node", "(", ")", ".", "getBBox", "(", ")", ";", "var", "parent", "=", "graph", ".", "node", "(", ")", ".", "parentElement", ";", "var", "fullWidth", "=", "parent", ".", "clientWidth", ",", "fullHeight", "=", "parent", ".", "clientHeight", ";", "var", "width", "=", "bounds", ".", "width", ",", "height", "=", "bounds", ".", "height", ";", "if", "(", "width", "===", "0", "||", "height", "===", "0", ")", "{", "return", "1", ";", "}", "// nothing to fit", "var", "scale", "=", "0.75", "/", "Math", ".", "max", "(", "width", "/", "fullWidth", ",", "height", "/", "fullHeight", ")", ";", "scale", "=", "Math", ".", "max", "(", "Math", ".", "min", "(", "scale", ",", "maxScaleExtent", ")", ",", "minScaleExtent", ")", ";", "return", "scale", ";", "}"], "docstring": "Determines a new scale that fits the entire graph into view.\n\n@returns {number}", "docstring_tokens": ["Determines", "a", "new", "scale", "that", "fits", "the", "entire", "graph", "into", "view", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L1155-L1169", "partition": "test"}
{"repo": "colinskow/superlogin", "path": "lib/oauth.js", "func_name": "getProviderToken", "original_string": "function getProviderToken(pathname) {\n    var items = pathname.split('/');\n    var index = items.indexOf('token');\n    if(index > 0) {\n      return items[index-1];\n    }\n  }", "language": "javascript", "code": "function getProviderToken(pathname) {\n    var items = pathname.split('/');\n    var index = items.indexOf('token');\n    if(index > 0) {\n      return items[index-1];\n    }\n  }", "code_tokens": ["function", "getProviderToken", "(", "pathname", ")", "{", "var", "items", "=", "pathname", ".", "split", "(", "'/'", ")", ";", "var", "index", "=", "items", ".", "indexOf", "(", "'token'", ")", ";", "if", "(", "index", ">", "0", ")", "{", "return", "items", "[", "index", "-", "1", "]", ";", "}", "}"], "docstring": "Gets the provider name from a callback path for access_token strategy", "docstring_tokens": ["Gets", "the", "provider", "name", "from", "a", "callback", "path", "for", "access_token", "strategy"], "sha": "8e7c7c1a77c1f5303b74f941208349e3a6e0c9ad", "url": "https://github.com/colinskow/superlogin/blob/8e7c7c1a77c1f5303b74f941208349e3a6e0c9ad/lib/oauth.js#L235-L241", "partition": "test"}
{"repo": "yahoo/locator", "path": "lib/bundleLocator.js", "func_name": "", "original_string": "function (bundleSeed) {\n        var self = this,\n            parentName,\n            parent,\n            bundle,\n            filters;\n        // TODO -- merge options (second arg) over bundleSeed.options\n\n        parentName = this._getBundleNameByPath(libpath.dirname(bundleSeed.baseDirectory));\n        parent = this._bundles[parentName];\n\n        bundle = this._makeBundle(bundleSeed, parent);\n        this._bundles[bundle.name] = bundle;\n        filters = this._options.exclude.concat(['node_modules', /^\\./]);\n        // adding the bundle dir itself for BC\n        this._processFile(bundle.baseDirectory);\n        walk.walkSync(bundle.baseDirectory, {\n            filters: [],\n            listeners: {\n                directories: function (root, dirStatsArray, next) {\n                    var i, dirStats, exclude;\n                    function filterDir(filter) {\n                        if (dirStats.name.match(filter)) {\n                            return true;\n                        }\n                    }\n                    for (i = dirStatsArray.length - 1; i >= 0; i -= 1) {\n                        dirStats = dirStatsArray[i];\n                        exclude = filters.some(filterDir);\n                        if (exclude) {\n                            // the sync walk api is pretty bad, it requires to\n                            // mutate the actual dir array\n                            dirStatsArray.splice(i, 1);\n                        } else {\n                            self._processFile(libpath.join(root, dirStats.name));\n                        }\n                    }\n                    next();\n                },\n                file: function(root, fileStats, next) {\n                    self._processFile(libpath.join(root, fileStats.name));\n                    next();\n                },\n                errors: function(root, nodeStatsArray, next) {\n                    next();\n                }\n            }\n        });\n\n        return bundle;\n    }", "language": "javascript", "code": "function (bundleSeed) {\n        var self = this,\n            parentName,\n            parent,\n            bundle,\n            filters;\n        // TODO -- merge options (second arg) over bundleSeed.options\n\n        parentName = this._getBundleNameByPath(libpath.dirname(bundleSeed.baseDirectory));\n        parent = this._bundles[parentName];\n\n        bundle = this._makeBundle(bundleSeed, parent);\n        this._bundles[bundle.name] = bundle;\n        filters = this._options.exclude.concat(['node_modules', /^\\./]);\n        // adding the bundle dir itself for BC\n        this._processFile(bundle.baseDirectory);\n        walk.walkSync(bundle.baseDirectory, {\n            filters: [],\n            listeners: {\n                directories: function (root, dirStatsArray, next) {\n                    var i, dirStats, exclude;\n                    function filterDir(filter) {\n                        if (dirStats.name.match(filter)) {\n                            return true;\n                        }\n                    }\n                    for (i = dirStatsArray.length - 1; i >= 0; i -= 1) {\n                        dirStats = dirStatsArray[i];\n                        exclude = filters.some(filterDir);\n                        if (exclude) {\n                            // the sync walk api is pretty bad, it requires to\n                            // mutate the actual dir array\n                            dirStatsArray.splice(i, 1);\n                        } else {\n                            self._processFile(libpath.join(root, dirStats.name));\n                        }\n                    }\n                    next();\n                },\n                file: function(root, fileStats, next) {\n                    self._processFile(libpath.join(root, fileStats.name));\n                    next();\n                },\n                errors: function(root, nodeStatsArray, next) {\n                    next();\n                }\n            }\n        });\n\n        return bundle;\n    }", "code_tokens": ["function", "(", "bundleSeed", ")", "{", "var", "self", "=", "this", ",", "parentName", ",", "parent", ",", "bundle", ",", "filters", ";", "// TODO -- merge options (second arg) over bundleSeed.options", "parentName", "=", "this", ".", "_getBundleNameByPath", "(", "libpath", ".", "dirname", "(", "bundleSeed", ".", "baseDirectory", ")", ")", ";", "parent", "=", "this", ".", "_bundles", "[", "parentName", "]", ";", "bundle", "=", "this", ".", "_makeBundle", "(", "bundleSeed", ",", "parent", ")", ";", "this", ".", "_bundles", "[", "bundle", ".", "name", "]", "=", "bundle", ";", "filters", "=", "this", ".", "_options", ".", "exclude", ".", "concat", "(", "[", "'node_modules'", ",", "/", "^\\.", "/", "]", ")", ";", "// adding the bundle dir itself for BC", "this", ".", "_processFile", "(", "bundle", ".", "baseDirectory", ")", ";", "walk", ".", "walkSync", "(", "bundle", ".", "baseDirectory", ",", "{", "filters", ":", "[", "]", ",", "listeners", ":", "{", "directories", ":", "function", "(", "root", ",", "dirStatsArray", ",", "next", ")", "{", "var", "i", ",", "dirStats", ",", "exclude", ";", "function", "filterDir", "(", "filter", ")", "{", "if", "(", "dirStats", ".", "name", ".", "match", "(", "filter", ")", ")", "{", "return", "true", ";", "}", "}", "for", "(", "i", "=", "dirStatsArray", ".", "length", "-", "1", ";", "i", ">=", "0", ";", "i", "-=", "1", ")", "{", "dirStats", "=", "dirStatsArray", "[", "i", "]", ";", "exclude", "=", "filters", ".", "some", "(", "filterDir", ")", ";", "if", "(", "exclude", ")", "{", "// the sync walk api is pretty bad, it requires to", "// mutate the actual dir array", "dirStatsArray", ".", "splice", "(", "i", ",", "1", ")", ";", "}", "else", "{", "self", ".", "_processFile", "(", "libpath", ".", "join", "(", "root", ",", "dirStats", ".", "name", ")", ")", ";", "}", "}", "next", "(", ")", ";", "}", ",", "file", ":", "function", "(", "root", ",", "fileStats", ",", "next", ")", "{", "self", ".", "_processFile", "(", "libpath", ".", "join", "(", "root", ",", "fileStats", ".", "name", ")", ")", ";", "next", "(", ")", ";", "}", ",", "errors", ":", "function", "(", "root", ",", "nodeStatsArray", ",", "next", ")", "{", "next", "(", ")", ";", "}", "}", "}", ")", ";", "return", "bundle", ";", "}"], "docstring": "Creates a bundle from an NPM package, and queues up files in the package.\n@private\n@method _walkBundle\n@param {object} bundleSeed Metadata about the package. See the docs for _makeBundleSeed()\nfor format of this metadata.\n@return {Bundle} The bundle made from the NPM package.", "docstring_tokens": ["Creates", "a", "bundle", "from", "an", "NPM", "package", "and", "queues", "up", "files", "in", "the", "package", "."], "sha": "563e6d453556dd776572761bd8e002e6e1ac64b6", "url": "https://github.com/yahoo/locator/blob/563e6d453556dd776572761bd8e002e6e1ac64b6/lib/bundleLocator.js#L795-L845", "partition": "test"}
{"repo": "campsi/campsi-service-docs", "path": "lib/modules/queryBuilder.js", "func_name": "validate", "original_string": "function validate (resource, doc, doValidate) {\n  return new Promise((resolve, reject) => {\n    if (doValidate !== true) {\n      return resolve();\n    }\n    if (resource.validate(doc)) {\n      return resolve();\n    } else {\n      debug('model have %d error(s)', resource.validate.errors.length);\n      return reject(resource.validate.errors);\n    }\n  });\n}", "language": "javascript", "code": "function validate (resource, doc, doValidate) {\n  return new Promise((resolve, reject) => {\n    if (doValidate !== true) {\n      return resolve();\n    }\n    if (resource.validate(doc)) {\n      return resolve();\n    } else {\n      debug('model have %d error(s)', resource.validate.errors.length);\n      return reject(resource.validate.errors);\n    }\n  });\n}", "code_tokens": ["function", "validate", "(", "resource", ",", "doc", ",", "doValidate", ")", "{", "return", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "if", "(", "doValidate", "!==", "true", ")", "{", "return", "resolve", "(", ")", ";", "}", "if", "(", "resource", ".", "validate", "(", "doc", ")", ")", "{", "return", "resolve", "(", ")", ";", "}", "else", "{", "debug", "(", "'model have %d error(s)'", ",", "resource", ".", "validate", ".", "errors", ".", "length", ")", ";", "return", "reject", "(", "resource", ".", "validate", ".", "errors", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Validate a document against its resource\n@param {object} resource\n@param {object} doc\n@param {boolean} doValidate\n@returns {Promise}", "docstring_tokens": ["Validate", "a", "document", "against", "its", "resource"], "sha": "ce08f9599f9e96a6d57daac5975da7b041b0236c", "url": "https://github.com/campsi/campsi-service-docs/blob/ce08f9599f9e96a6d57daac5975da7b041b0236c/lib/modules/queryBuilder.js#L34-L46", "partition": "test"}
{"repo": "cybersettler/websemble", "path": "backend/dao/DAOImplementation.js", "func_name": "DAOImplementation", "original_string": "function DAOImplementation(config) {\n  let basePath = config.basePath || 'backend/persistence/catalog/';\n  let isDBloaded = true;\n  if (config.filename) {\n    config.filename = basePath + config.filename;\n  }\n  if (config.schema) {\n    this.schema = fs.readJSON(path.join(appRoot.toString(),\n      basePath, config.schema));\n  } else {\n    this.schema = {};\n  }\n  let db = new DataStore(config);\n  if (config.filename && !config.autoload) {\n    isDBloaded = false;\n  }\n  this.collection = db;\n  this.isDBloaded = isDBloaded;\n}", "language": "javascript", "code": "function DAOImplementation(config) {\n  let basePath = config.basePath || 'backend/persistence/catalog/';\n  let isDBloaded = true;\n  if (config.filename) {\n    config.filename = basePath + config.filename;\n  }\n  if (config.schema) {\n    this.schema = fs.readJSON(path.join(appRoot.toString(),\n      basePath, config.schema));\n  } else {\n    this.schema = {};\n  }\n  let db = new DataStore(config);\n  if (config.filename && !config.autoload) {\n    isDBloaded = false;\n  }\n  this.collection = db;\n  this.isDBloaded = isDBloaded;\n}", "code_tokens": ["function", "DAOImplementation", "(", "config", ")", "{", "let", "basePath", "=", "config", ".", "basePath", "||", "'backend/persistence/catalog/'", ";", "let", "isDBloaded", "=", "true", ";", "if", "(", "config", ".", "filename", ")", "{", "config", ".", "filename", "=", "basePath", "+", "config", ".", "filename", ";", "}", "if", "(", "config", ".", "schema", ")", "{", "this", ".", "schema", "=", "fs", ".", "readJSON", "(", "path", ".", "join", "(", "appRoot", ".", "toString", "(", ")", ",", "basePath", ",", "config", ".", "schema", ")", ")", ";", "}", "else", "{", "this", ".", "schema", "=", "{", "}", ";", "}", "let", "db", "=", "new", "DataStore", "(", "config", ")", ";", "if", "(", "config", ".", "filename", "&&", "!", "config", ".", "autoload", ")", "{", "isDBloaded", "=", "false", ";", "}", "this", ".", "collection", "=", "db", ";", "this", ".", "isDBloaded", "=", "isDBloaded", ";", "}"], "docstring": "DAO implementation.\n@constructor\n@implements {DAOInterface}\n@param {Object} config - Configuration.\n@param {string} config.collectionName - Collection name.\n@param {Object} config.schema - Collection schema.\n@param {Object} config.basePath - Base path to collection data folder.\n@param {string} [config.filename] - Path to the\nfile where the data is persisted. If left blank,\nthe datastore is automatically considered in-memory\nonly. It cannot end with a ~ which is used in the\ntemporary files NeDB uses to perform crash-safe writes.\n@param {boolean} [config.inMemoryOnly] - Defaults\nto false, as the name implies.\n@param {boolean} [config.timestampData] - Defaults to\nfalse. Timestamp the insertion and last update of all documents,\nwith the fields createdAt and updatedAt. User-specified\nvalues override automatic generation, usually useful\nfor testing.\n@param {boolean} [config.autoload] - Defaults to false.\nIf used, the database will automatically be loaded from\nthe datafile upon creation (you don't need to call\nloadDatabase. Any command issued before load is finished\nis buffered and will be executed when load is done.\n@param {Object} [config.onload] - If you use autoloading,\nthis is the handler called after the loadDatabase.\nIt takes one error argument. If you use autoloading without\nspecifying this handler, and an error happens during load,\nan error will be thrown.\n@param {Object} [config.afterSerialization] - Hook you can use\nto transform data after it was serialized and before it is\nwritten to disk. Can be used for example to encrypt data\nbefore writing database to disk. This function takes a\nstring as parameter (one line of an NeDB data file) and\noutputs the transformed string, which must absolutely not\ncontain a \\n character (or data will be lost).\n@param {Object} [config.beforeDeserialization] - Inverse of\nafterSerialization. Make sure to include both and not just\none or you risk data loss. For the same reason, make sure\nboth functions are inverses of one another. Some failsafe\nmechanisms are in place to prevent data loss if you misuse\nthe serialization hooks: NeDB checks that never one is\ndeclared without the other, and checks that they are reverse\nof one another by testing on random strings of various lengths.\nIn addition, if too much data is detected as corrupt, NeDB will\nrefuse to start as it could mean you're not using the\ndeserialization hook corresponding to the serialization hook\nused before (see below).\n@param {number} [config.corruptAlertThreshold] -\nbetween 0 and 1,\ndefaults to 10%. NeDB will refuse to start if more than this\npercentage of the datafile is corrupt. 0 means you don't tolerate\nany corruption, 1 means you don't care.\n@param {Object} [config.compareStrings] - function\ncompareStrings(a, b)\ncompares strings a and b and return -1, 0 or 1. If specified,\nit overrides default string comparison which is not well adapted\nto non-US characters in particular accented letters. Native\nlocalCompare will most of the time be the right choice.", "docstring_tokens": ["DAO", "implementation", "."], "sha": "2cf2b3343207e7ded03f018310c9ca6680f734e8", "url": "https://github.com/cybersettler/websemble/blob/2cf2b3343207e7ded03f018310c9ca6680f734e8/backend/dao/DAOImplementation.js#L71-L89", "partition": "test"}
{"repo": "gabrielcsapo-graveyard/node-flat-db", "path": "src/index.js", "func_name": "_save", "original_string": "function _save() {\n    if (db.source && db.write && writeOnChange) {\n      var str = JSON.stringify(db.object);\n\n      if (str !== db._checksum) {\n        db._checksum = str;\n        return db.write(db.source, db.object);\n      }\n    }\n  }", "language": "javascript", "code": "function _save() {\n    if (db.source && db.write && writeOnChange) {\n      var str = JSON.stringify(db.object);\n\n      if (str !== db._checksum) {\n        db._checksum = str;\n        return db.write(db.source, db.object);\n      }\n    }\n  }", "code_tokens": ["function", "_save", "(", ")", "{", "if", "(", "db", ".", "source", "&&", "db", ".", "write", "&&", "writeOnChange", ")", "{", "var", "str", "=", "JSON", ".", "stringify", "(", "db", ".", "object", ")", ";", "if", "(", "str", "!==", "db", ".", "_checksum", ")", "{", "db", ".", "_checksum", "=", "str", ";", "return", "db", ".", "write", "(", "db", ".", "source", ",", "db", ".", "object", ")", ";", "}", "}", "}"], "docstring": "Return a promise or nothing in sync mode or if the database hasn't changed", "docstring_tokens": ["Return", "a", "promise", "or", "nothing", "in", "sync", "mode", "or", "if", "the", "database", "hasn", "t", "changed"], "sha": "ca4eac61830ba22fe805d1997dfca8bc6ea254f6", "url": "https://github.com/gabrielcsapo-graveyard/node-flat-db/blob/ca4eac61830ba22fe805d1997dfca8bc6ea254f6/src/index.js#L102-L111", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/dom/Element.js", "func_name": "", "original_string": "function(name, namespace) {\n        var dom = this.dom;\n\n        return dom.getAttributeNS(namespace, name) || dom.getAttribute(namespace + \":\" + name)\n               || dom.getAttribute(name) || dom[name];\n    }", "language": "javascript", "code": "function(name, namespace) {\n        var dom = this.dom;\n\n        return dom.getAttributeNS(namespace, name) || dom.getAttribute(namespace + \":\" + name)\n               || dom.getAttribute(name) || dom[name];\n    }", "code_tokens": ["function", "(", "name", ",", "namespace", ")", "{", "var", "dom", "=", "this", ".", "dom", ";", "return", "dom", ".", "getAttributeNS", "(", "namespace", ",", "name", ")", "||", "dom", ".", "getAttribute", "(", "namespace", "+", "\":\"", "+", "name", ")", "||", "dom", ".", "getAttribute", "(", "name", ")", "||", "dom", "[", "name", "]", ";", "}"], "docstring": "Returns the value of an attribute from the element's underlying DOM node.\n@param {String} name The attribute name.\n@param {String} [namespace] The namespace in which to look for the attribute.\n@return {String} The attribute value.", "docstring_tokens": ["Returns", "the", "value", "of", "an", "attribute", "from", "the", "element", "s", "underlying", "DOM", "node", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/dom/Element.js#L528-L533", "partition": "test"}
{"repo": "h2non/resilient-consul", "path": "consul.js", "func_name": "inHandler", "original_string": "function inHandler (err, res, next) {\n          if (err) return next()\n\n          // resilient.js sometimes calls the middleware function more than once, with the output\n          // of the previous invokation; checking here the type of the items in the response to\n          // only call `mapServers` with service objects, not URLs (strings)\n          if (Array.isArray(res.data) && Object(res.data[0]) === res.data[0]) {\n            res.data = mapServers(res.data)\n          }\n\n          next()\n        }", "language": "javascript", "code": "function inHandler (err, res, next) {\n          if (err) return next()\n\n          // resilient.js sometimes calls the middleware function more than once, with the output\n          // of the previous invokation; checking here the type of the items in the response to\n          // only call `mapServers` with service objects, not URLs (strings)\n          if (Array.isArray(res.data) && Object(res.data[0]) === res.data[0]) {\n            res.data = mapServers(res.data)\n          }\n\n          next()\n        }", "code_tokens": ["function", "inHandler", "(", "err", ",", "res", ",", "next", ")", "{", "if", "(", "err", ")", "return", "next", "(", ")", "// resilient.js sometimes calls the middleware function more than once, with the output", "// of the previous invokation; checking here the type of the items in the response to", "// only call `mapServers` with service objects, not URLs (strings)", "if", "(", "Array", ".", "isArray", "(", "res", ".", "data", ")", "&&", "Object", "(", "res", ".", "data", "[", "0", "]", ")", "===", "res", ".", "data", "[", "0", "]", ")", "{", "res", ".", "data", "=", "mapServers", "(", "res", ".", "data", ")", "}", "next", "(", ")", "}"], "docstring": "Incoming traffic middleware", "docstring_tokens": ["Incoming", "traffic", "middleware"], "sha": "d0ddc58d2dacc3a11a005bcd21b96af41f84aea1", "url": "https://github.com/h2non/resilient-consul/blob/d0ddc58d2dacc3a11a005bcd21b96af41f84aea1/consul.js#L44-L55", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(store, type, payload) {\n    var root = this.keyForAttribute(type.typeKey),\n        partials = payload[Ember.String.pluralize(root)];\n\n    forEach(partials, function(partial) {\n      updatePayloadWithEmbedded(store, this, type, partial, payload);\n    }, this);\n\n    return this._super(store, type, payload);\n  }", "language": "javascript", "code": "function(store, type, payload) {\n    var root = this.keyForAttribute(type.typeKey),\n        partials = payload[Ember.String.pluralize(root)];\n\n    forEach(partials, function(partial) {\n      updatePayloadWithEmbedded(store, this, type, partial, payload);\n    }, this);\n\n    return this._super(store, type, payload);\n  }", "code_tokens": ["function", "(", "store", ",", "type", ",", "payload", ")", "{", "var", "root", "=", "this", ".", "keyForAttribute", "(", "type", ".", "typeKey", ")", ",", "partials", "=", "payload", "[", "Ember", ".", "String", ".", "pluralize", "(", "root", ")", "]", ";", "forEach", "(", "partials", ",", "function", "(", "partial", ")", "{", "updatePayloadWithEmbedded", "(", "store", ",", "this", ",", "type", ",", "partial", ",", "payload", ")", ";", "}", ",", "this", ")", ";", "return", "this", ".", "_super", "(", "store", ",", "type", ",", "payload", ")", ";", "}"], "docstring": "Extract embedded objects out of a standard payload\nand add them as sideloaded objects instead.\n\n@method extractArray", "docstring_tokens": ["Extract", "embedded", "objects", "out", "of", "a", "standard", "payload", "and", "add", "them", "as", "sideloaded", "objects", "instead", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L10348-L10357", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/core/Ext-more.js", "func_name": "", "original_string": "function(node) {\n        if (node && node.parentNode && node.tagName != 'BODY') {\n            Ext.get(node).clearListeners();\n            node.parentNode.removeChild(node);\n            delete Ext.cache[node.id];\n        }\n    }", "language": "javascript", "code": "function(node) {\n        if (node && node.parentNode && node.tagName != 'BODY') {\n            Ext.get(node).clearListeners();\n            node.parentNode.removeChild(node);\n            delete Ext.cache[node.id];\n        }\n    }", "code_tokens": ["function", "(", "node", ")", "{", "if", "(", "node", "&&", "node", ".", "parentNode", "&&", "node", ".", "tagName", "!=", "'BODY'", ")", "{", "Ext", ".", "get", "(", "node", ")", ".", "clearListeners", "(", ")", ";", "node", ".", "parentNode", ".", "removeChild", "(", "node", ")", ";", "delete", "Ext", ".", "cache", "[", "node", ".", "id", "]", ";", "}", "}"], "docstring": "Removes this element from the document, removes all DOM event listeners, and deletes the cache reference.\nAll DOM event listeners are removed from this element.\n@param {HTMLElement} node The node to remove.", "docstring_tokens": ["Removes", "this", "element", "from", "the", "document", "removes", "all", "DOM", "event", "listeners", "and", "deletes", "the", "cache", "reference", ".", "All", "DOM", "event", "listeners", "are", "removed", "from", "this", "element", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/core/Ext-more.js#L236-L242", "partition": "test"}
{"repo": "Katochimoto/xblocks-core", "path": "src/xblocks/block.js", "func_name": "lifecycleInserted", "original_string": "function lifecycleInserted() {\n    if (this[ Constants.INSERTED ]) {\n        return;\n    }\n\n    blockInit(this);\n\n    this[ Constants.INSERTED ] = true;\n\n    const isScriptContent = Boolean(this.querySelector('script'));\n\n    // asynchronous read content\n    // <xb-test><script>...</script><div>not found</div></xb-test>\n    if (isScriptContent) {\n        lazy(blockCreateLazy, this);\n\n    } else {\n        blockCreate(this);\n    }\n}", "language": "javascript", "code": "function lifecycleInserted() {\n    if (this[ Constants.INSERTED ]) {\n        return;\n    }\n\n    blockInit(this);\n\n    this[ Constants.INSERTED ] = true;\n\n    const isScriptContent = Boolean(this.querySelector('script'));\n\n    // asynchronous read content\n    // <xb-test><script>...</script><div>not found</div></xb-test>\n    if (isScriptContent) {\n        lazy(blockCreateLazy, this);\n\n    } else {\n        blockCreate(this);\n    }\n}", "code_tokens": ["function", "lifecycleInserted", "(", ")", "{", "if", "(", "this", "[", "Constants", ".", "INSERTED", "]", ")", "{", "return", ";", "}", "blockInit", "(", "this", ")", ";", "this", "[", "Constants", ".", "INSERTED", "]", "=", "true", ";", "const", "isScriptContent", "=", "Boolean", "(", "this", ".", "querySelector", "(", "'script'", ")", ")", ";", "// asynchronous read content", "// <xb-test><script>...</script><div>not found</div></xb-test>", "if", "(", "isScriptContent", ")", "{", "lazy", "(", "blockCreateLazy", ",", "this", ")", ";", "}", "else", "{", "blockCreate", "(", "this", ")", ";", "}", "}"], "docstring": "The callback of the insert in DOM.\n@this HTMLElement\n@private", "docstring_tokens": ["The", "callback", "of", "the", "insert", "in", "DOM", "."], "sha": "714102b7c2adb4ae197403df252e967a1b967bb1", "url": "https://github.com/Katochimoto/xblocks-core/blob/714102b7c2adb4ae197403df252e967a1b967bb1/src/xblocks/block.js#L417-L436", "partition": "test"}
{"repo": "megahertz/gulp-task-doc", "path": "lib/printer.js", "func_name": "formatColumn", "original_string": "function formatColumn(text, width, offsetLeft, offsetRight) {\n  offsetLeft  = undefined !== offsetLeft  ? offsetLeft  : 3;\n  offsetRight = undefined !== offsetRight ? offsetRight : 3;\n\n  return new Array(offsetLeft + 1).join(' ') +\n    text +\n    new Array(Math.max(width - text.length, 0) + 1).join(' ') +\n    new Array(offsetRight + 1).join(' ');\n}", "language": "javascript", "code": "function formatColumn(text, width, offsetLeft, offsetRight) {\n  offsetLeft  = undefined !== offsetLeft  ? offsetLeft  : 3;\n  offsetRight = undefined !== offsetRight ? offsetRight : 3;\n\n  return new Array(offsetLeft + 1).join(' ') +\n    text +\n    new Array(Math.max(width - text.length, 0) + 1).join(' ') +\n    new Array(offsetRight + 1).join(' ');\n}", "code_tokens": ["function", "formatColumn", "(", "text", ",", "width", ",", "offsetLeft", ",", "offsetRight", ")", "{", "offsetLeft", "=", "undefined", "!==", "offsetLeft", "?", "offsetLeft", ":", "3", ";", "offsetRight", "=", "undefined", "!==", "offsetRight", "?", "offsetRight", ":", "3", ";", "return", "new", "Array", "(", "offsetLeft", "+", "1", ")", ".", "join", "(", "' '", ")", "+", "text", "+", "new", "Array", "(", "Math", ".", "max", "(", "width", "-", "text", ".", "length", ",", "0", ")", "+", "1", ")", ".", "join", "(", "' '", ")", "+", "new", "Array", "(", "offsetRight", "+", "1", ")", ".", "join", "(", "' '", ")", ";", "}"], "docstring": "Return a text surrounded by space\n@param {string} text\n@param {number} width Column width without offsets\n@param {number} [offsetLeft=3]  space count before text\n@param {number} [offsetRight=3] space count after text\n@returns {string}", "docstring_tokens": ["Return", "a", "text", "surrounded", "by", "space"], "sha": "90333aec0ff8a66b63b308c14e7cd90010622bbf", "url": "https://github.com/megahertz/gulp-task-doc/blob/90333aec0ff8a66b63b308c14e7cd90010622bbf/lib/printer.js#L46-L54", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(store, type, ids) {\n    return this.ajax(this.buildURL(type.typeKey), 'GET', { data: { ids: ids } });\n  }", "language": "javascript", "code": "function(store, type, ids) {\n    return this.ajax(this.buildURL(type.typeKey), 'GET', { data: { ids: ids } });\n  }", "code_tokens": ["function", "(", "store", ",", "type", ",", "ids", ")", "{", "return", "this", ".", "ajax", "(", "this", ".", "buildURL", "(", "type", ".", "typeKey", ")", ",", "'GET'", ",", "{", "data", ":", "{", "ids", ":", "ids", "}", "}", ")", ";", "}"], "docstring": "Called by the store in order to fetch a JSON array for\nthe unloaded records in a has-many relationship that were originally\nspecified as IDs.\n\nFor example, if the original payload looks like:\n\n```js\n{\n\"id\": 1,\n\"title\": \"Rails is omakase\",\n\"comments\": [ 1, 2, 3 ]\n}\n```\n\nThe IDs will be passed as a URL-encoded Array of IDs, in this form:\n\n```\nids[]=1&ids[]=2&ids[]=3\n```\n\nMany servers, such as Rails and PHP, will automatically convert this URL-encoded array\ninto an Array for you on the server-side. If you want to encode the\nIDs, differently, just override this (one-line) method.\n\nThe `findMany` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\npromise for the resulting payload.\n\n@method findMany\n@param {DS.Store} store\n@param {subclass of DS.Model} type\n@param {Array} ids\n@returns {Promise} promise", "docstring_tokens": ["Called", "by", "the", "store", "in", "order", "to", "fetch", "a", "JSON", "array", "for", "the", "unloaded", "records", "in", "a", "has", "-", "many", "relationship", "that", "were", "originally", "specified", "as", "IDs", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L9266-L9268", "partition": "test"}
{"repo": "enhancv/popup-tools", "path": "src/PopupTools.js", "func_name": "openPopupWithPost", "original_string": "function openPopupWithPost(url, postData, name, options) {\n    var form = document.createElement(\"form\");\n    var win;\n\n    form.setAttribute(\"method\", \"post\");\n    form.setAttribute(\"action\", url);\n    form.setAttribute(\"target\", name);\n\n    Object.keys(postData).forEach(function addFormItem(key) {\n        var input = document.createElement(\"input\");\n        input.type = \"hidden\";\n        input.name = key;\n        input.value = postData[key];\n        form.appendChild(input);\n    });\n\n    document.body.appendChild(form);\n\n    win = window.open(\"/\", name, options);\n    win.document.write(\"Loading...\");\n\n    form.submit();\n    document.body.removeChild(form);\n\n    return win;\n}", "language": "javascript", "code": "function openPopupWithPost(url, postData, name, options) {\n    var form = document.createElement(\"form\");\n    var win;\n\n    form.setAttribute(\"method\", \"post\");\n    form.setAttribute(\"action\", url);\n    form.setAttribute(\"target\", name);\n\n    Object.keys(postData).forEach(function addFormItem(key) {\n        var input = document.createElement(\"input\");\n        input.type = \"hidden\";\n        input.name = key;\n        input.value = postData[key];\n        form.appendChild(input);\n    });\n\n    document.body.appendChild(form);\n\n    win = window.open(\"/\", name, options);\n    win.document.write(\"Loading...\");\n\n    form.submit();\n    document.body.removeChild(form);\n\n    return win;\n}", "code_tokens": ["function", "openPopupWithPost", "(", "url", ",", "postData", ",", "name", ",", "options", ")", "{", "var", "form", "=", "document", ".", "createElement", "(", "\"form\"", ")", ";", "var", "win", ";", "form", ".", "setAttribute", "(", "\"method\"", ",", "\"post\"", ")", ";", "form", ".", "setAttribute", "(", "\"action\"", ",", "url", ")", ";", "form", ".", "setAttribute", "(", "\"target\"", ",", "name", ")", ";", "Object", ".", "keys", "(", "postData", ")", ".", "forEach", "(", "function", "addFormItem", "(", "key", ")", "{", "var", "input", "=", "document", ".", "createElement", "(", "\"input\"", ")", ";", "input", ".", "type", "=", "\"hidden\"", ";", "input", ".", "name", "=", "key", ";", "input", ".", "value", "=", "postData", "[", "key", "]", ";", "form", ".", "appendChild", "(", "input", ")", ";", "}", ")", ";", "document", ".", "body", ".", "appendChild", "(", "form", ")", ";", "win", "=", "window", ".", "open", "(", "\"/\"", ",", "name", ",", "options", ")", ";", "win", ".", "document", ".", "write", "(", "\"Loading...\"", ")", ";", "form", ".", "submit", "(", ")", ";", "document", ".", "body", ".", "removeChild", "(", "form", ")", ";", "return", "win", ";", "}"], "docstring": "Create a form element, add hidden inputs for all the post data\nand post it into a newly opened popup\n\n@param  {String} url\n@param  {Object} postData\n@param  {String} name\n@param  {Object} options\n@return {Object}", "docstring_tokens": ["Create", "a", "form", "element", "add", "hidden", "inputs", "for", "all", "the", "post", "data", "and", "post", "it", "into", "a", "newly", "opened", "popup"], "sha": "772b192920929112164f261c632d6d201a79f15a", "url": "https://github.com/enhancv/popup-tools/blob/772b192920929112164f261c632d6d201a79f15a/src/PopupTools.js#L89-L114", "partition": "test"}
{"repo": "NiklasGollenstede/es6lib", "path": "observer.js", "func_name": "RemoveObserver_init", "original_string": "function RemoveObserver_init(ref, node) {\n\tlet self = Self.get(node);\n\tif (!self) {\n\t\tself = new RemoveObserverPrivate(node);\n\t\tSelf.set(node, self);\n\t}\n\tSelf.set(ref, self);\n}", "language": "javascript", "code": "function RemoveObserver_init(ref, node) {\n\tlet self = Self.get(node);\n\tif (!self) {\n\t\tself = new RemoveObserverPrivate(node);\n\t\tSelf.set(node, self);\n\t}\n\tSelf.set(ref, self);\n}", "code_tokens": ["function", "RemoveObserver_init", "(", "ref", ",", "node", ")", "{", "let", "self", "=", "Self", ".", "get", "(", "node", ")", ";", "if", "(", "!", "self", ")", "{", "self", "=", "new", "RemoveObserverPrivate", "(", "node", ")", ";", "Self", ".", "set", "(", "node", ",", "self", ")", ";", "}", "Self", ".", "set", "(", "ref", ",", "self", ")", ";", "}"], "docstring": "there are no properties on a `RemoveObserver`, every object that went as ref through this function can be used as `this` in any of the RemoveObserver methods", "docstring_tokens": ["there", "are", "no", "properties", "on", "a", "RemoveObserver", "every", "object", "that", "went", "as", "ref", "through", "this", "function", "can", "be", "used", "as", "this", "in", "any", "of", "the", "RemoveObserver", "methods"], "sha": "8aeabdf5cadafaf9c47c69f13bb8f7f6bec581c8", "url": "https://github.com/NiklasGollenstede/es6lib/blob/8aeabdf5cadafaf9c47c69f13bb8f7f6bec581c8/observer.js#L155-L162", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/error.js", "func_name": "withCode", "original_string": "function withCode(code, msg) {\n    const err = new Error(msg);\n    err.code = code;\n    return err;\n}", "language": "javascript", "code": "function withCode(code, msg) {\n    const err = new Error(msg);\n    err.code = code;\n    return err;\n}", "code_tokens": ["function", "withCode", "(", "code", ",", "msg", ")", "{", "const", "err", "=", "new", "Error", "(", "msg", ")", ";", "err", ".", "code", "=", "code", ";", "return", "err", ";", "}"], "docstring": "Return an error with a specific code", "docstring_tokens": ["Return", "an", "error", "with", "a", "specific", "code"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/error.js#L6-L10", "partition": "test"}
{"repo": "NathanWalker/nativescript-ng2-magic", "path": "install.js", "func_name": "fixNativeScriptPackage", "original_string": "function fixNativeScriptPackage() {\n    var packageJSON = {}, packageFile = '../../package.json';\n    packageJSON.name = \"NativeScriptApp\";\n    packageJSON.version = \"0.0.0\";\n  \n    // var AngularJSON = {};\n    if (fs.existsSync(packageFile)) {\n        packageJSON = require(packageFile);\n    } else {\n        console.log(\"This should not happen, your are missing your package.json file!\");\n        return;\n    }\n    // if (fs.existsSync('../angular2/package.json')) {\n    //     AngularJSON = require('../angular2/package.json');\n    // } else {\n    //     // Copied from the Angular2.0.0-beta-16 package.json, this is a fall back\n    //     AngularJSON.peerDependencies = {\n    //         \"es6-shim\": \"^0.35.0\",\n    //         \"reflect-metadata\": \"0.1.2\",\n    //         \"rxjs\": \"5.0.0-beta.6\",\n    //         \"zone.js\": \"^0.6.12\"\n    //     };\n    // }\n\n    packageJSON.nativescript['tns-ios'] = { version: \"2.3.0\" };\n    packageJSON.nativescript['tns-android'] = {version: \"2.3.0\" };\n\n    // Copy over all the Peer Dependencies\n    // for (var key in AngularJSON.peerDependencies) {\n    //     if (AngularJSON.peerDependencies.hasOwnProperty(key)) {\n    //         packageJSON.dependencies[key] = AngularJSON.peerDependencies[key];\n    //     }\n    // }\n\n\n    // TODO: Can we get these from somewhere rather than hardcoding them, maybe need to pull/download the package.json from the default template?\n    if (!packageJSON.devDependencies) {\n        packageJSON.devDependencies = {};\n    }\n    packageJSON.devDependencies[\"@types/jasmine\"] = \"^2.5.35\";\n    packageJSON.devDependencies[\"babel-traverse\"] = \"6.12.0\";\n    packageJSON.devDependencies[\"babel-types\"] = \"6.11.1\";\n    packageJSON.devDependencies.babylon = \"6.8.4\";\n    packageJSON.devDependencies.filewalker = \"0.1.2\";\n    packageJSON.devDependencies.lazy = \"1.0.11\";\n    // packageJSON.devDependencies[\"nativescript-dev-typescript\"] = \"^0.3.2\";\n    packageJSON.devDependencies.typescript = \"^2.0.2\";\n\n    fs.writeFileSync(packageFile, JSON.stringify(packageJSON, null, 4), 'utf8');\n}", "language": "javascript", "code": "function fixNativeScriptPackage() {\n    var packageJSON = {}, packageFile = '../../package.json';\n    packageJSON.name = \"NativeScriptApp\";\n    packageJSON.version = \"0.0.0\";\n  \n    // var AngularJSON = {};\n    if (fs.existsSync(packageFile)) {\n        packageJSON = require(packageFile);\n    } else {\n        console.log(\"This should not happen, your are missing your package.json file!\");\n        return;\n    }\n    // if (fs.existsSync('../angular2/package.json')) {\n    //     AngularJSON = require('../angular2/package.json');\n    // } else {\n    //     // Copied from the Angular2.0.0-beta-16 package.json, this is a fall back\n    //     AngularJSON.peerDependencies = {\n    //         \"es6-shim\": \"^0.35.0\",\n    //         \"reflect-metadata\": \"0.1.2\",\n    //         \"rxjs\": \"5.0.0-beta.6\",\n    //         \"zone.js\": \"^0.6.12\"\n    //     };\n    // }\n\n    packageJSON.nativescript['tns-ios'] = { version: \"2.3.0\" };\n    packageJSON.nativescript['tns-android'] = {version: \"2.3.0\" };\n\n    // Copy over all the Peer Dependencies\n    // for (var key in AngularJSON.peerDependencies) {\n    //     if (AngularJSON.peerDependencies.hasOwnProperty(key)) {\n    //         packageJSON.dependencies[key] = AngularJSON.peerDependencies[key];\n    //     }\n    // }\n\n\n    // TODO: Can we get these from somewhere rather than hardcoding them, maybe need to pull/download the package.json from the default template?\n    if (!packageJSON.devDependencies) {\n        packageJSON.devDependencies = {};\n    }\n    packageJSON.devDependencies[\"@types/jasmine\"] = \"^2.5.35\";\n    packageJSON.devDependencies[\"babel-traverse\"] = \"6.12.0\";\n    packageJSON.devDependencies[\"babel-types\"] = \"6.11.1\";\n    packageJSON.devDependencies.babylon = \"6.8.4\";\n    packageJSON.devDependencies.filewalker = \"0.1.2\";\n    packageJSON.devDependencies.lazy = \"1.0.11\";\n    // packageJSON.devDependencies[\"nativescript-dev-typescript\"] = \"^0.3.2\";\n    packageJSON.devDependencies.typescript = \"^2.0.2\";\n\n    fs.writeFileSync(packageFile, JSON.stringify(packageJSON, null, 4), 'utf8');\n}", "code_tokens": ["function", "fixNativeScriptPackage", "(", ")", "{", "var", "packageJSON", "=", "{", "}", ",", "packageFile", "=", "'../../package.json'", ";", "packageJSON", ".", "name", "=", "\"NativeScriptApp\"", ";", "packageJSON", ".", "version", "=", "\"0.0.0\"", ";", "// var AngularJSON = {};", "if", "(", "fs", ".", "existsSync", "(", "packageFile", ")", ")", "{", "packageJSON", "=", "require", "(", "packageFile", ")", ";", "}", "else", "{", "console", ".", "log", "(", "\"This should not happen, your are missing your package.json file!\"", ")", ";", "return", ";", "}", "// if (fs.existsSync('../angular2/package.json')) {", "//     AngularJSON = require('../angular2/package.json');", "// } else {", "//     // Copied from the Angular2.0.0-beta-16 package.json, this is a fall back", "//     AngularJSON.peerDependencies = {", "//         \"es6-shim\": \"^0.35.0\",", "//         \"reflect-metadata\": \"0.1.2\",", "//         \"rxjs\": \"5.0.0-beta.6\",", "//         \"zone.js\": \"^0.6.12\"", "//     };", "// }", "packageJSON", ".", "nativescript", "[", "'tns-ios'", "]", "=", "{", "version", ":", "\"2.3.0\"", "}", ";", "packageJSON", ".", "nativescript", "[", "'tns-android'", "]", "=", "{", "version", ":", "\"2.3.0\"", "}", ";", "// Copy over all the Peer Dependencies", "// for (var key in AngularJSON.peerDependencies) {", "//     if (AngularJSON.peerDependencies.hasOwnProperty(key)) {", "//         packageJSON.dependencies[key] = AngularJSON.peerDependencies[key];", "//     }", "// }", "// TODO: Can we get these from somewhere rather than hardcoding them, maybe need to pull/download the package.json from the default template?", "if", "(", "!", "packageJSON", ".", "devDependencies", ")", "{", "packageJSON", ".", "devDependencies", "=", "{", "}", ";", "}", "packageJSON", ".", "devDependencies", "[", "\"@types/jasmine\"", "]", "=", "\"^2.5.35\"", ";", "packageJSON", ".", "devDependencies", "[", "\"babel-traverse\"", "]", "=", "\"6.12.0\"", ";", "packageJSON", ".", "devDependencies", "[", "\"babel-types\"", "]", "=", "\"6.11.1\"", ";", "packageJSON", ".", "devDependencies", ".", "babylon", "=", "\"6.8.4\"", ";", "packageJSON", ".", "devDependencies", ".", "filewalker", "=", "\"0.1.2\"", ";", "packageJSON", ".", "devDependencies", ".", "lazy", "=", "\"1.0.11\"", ";", "// packageJSON.devDependencies[\"nativescript-dev-typescript\"] = \"^0.3.2\";", "packageJSON", ".", "devDependencies", ".", "typescript", "=", "\"^2.0.2\"", ";", "fs", ".", "writeFileSync", "(", "packageFile", ",", "JSON", ".", "stringify", "(", "packageJSON", ",", "null", ",", "4", ")", ",", "'utf8'", ")", ";", "}"], "docstring": "Fix the NativeScript Package file", "docstring_tokens": ["Fix", "the", "NativeScript", "Package", "file"], "sha": "702395cf85add650170ca45ca6f582e6ad609863", "url": "https://github.com/NathanWalker/nativescript-ng2-magic/blob/702395cf85add650170ca45ca6f582e6ad609863/install.js#L342-L391", "partition": "test"}
{"repo": "lps-js/lps.js", "path": "src/engine/Engine.js", "func_name": "actionsSelector", "original_string": "function actionsSelector(goalTrees) {\n    const recursiveActionsSelector = (actionsSoFar, programSoFar, l) => {\n      if (l >= goalTrees.length) {\n        let actions = new LiteralTreeMap();\n        actionsSoFar.forEach((map) => {\n          map.forEach((literal) => {\n            actions.add(literal);\n          });\n        });\n        return actions;\n      }\n      let goalTree = goalTrees[l];\n      let resultSet = null;\n      goalTree.forEachCandidateActions(_currentTime, (candidateActions) => {\n        let cloneProgram = programSoFar.clone();\n\n        let cloneExecutedActions = cloneProgram.getExecutedActions();\n        candidateActions.forEach((a) => {\n          cloneExecutedActions.add(a);\n        });\n\n        // pre-condition check\n        if (!checkConstraintSatisfaction.call(this, cloneProgram)) {\n          return false;\n        }\n\n        // post condition checks\n        let clonePostProgram = programSoFar.clone();\n        clonePostProgram.setExecutedActions(new LiteralTreeMap());\n        let postState = clonePostProgram.getState();\n        updateStateWithFluentActors(\n          this,\n          candidateActions,\n          postState\n        );\n        clonePostProgram.setState(postState);\n\n        if (!checkConstraintSatisfaction.call(this, clonePostProgram)) {\n          return false;\n        }\n\n        resultSet = recursiveActionsSelector(\n          actionsSoFar.concat([candidateActions]),\n          cloneProgram,\n          l + 1\n        );\n        return true;\n      });\n\n      if (resultSet !== null) {\n        return resultSet;\n      }\n\n      return recursiveActionsSelector(\n        actionsSoFar,\n        programSoFar,\n        l + 1\n      );\n    };\n\n    return recursiveActionsSelector([], _program, 0);\n  }", "language": "javascript", "code": "function actionsSelector(goalTrees) {\n    const recursiveActionsSelector = (actionsSoFar, programSoFar, l) => {\n      if (l >= goalTrees.length) {\n        let actions = new LiteralTreeMap();\n        actionsSoFar.forEach((map) => {\n          map.forEach((literal) => {\n            actions.add(literal);\n          });\n        });\n        return actions;\n      }\n      let goalTree = goalTrees[l];\n      let resultSet = null;\n      goalTree.forEachCandidateActions(_currentTime, (candidateActions) => {\n        let cloneProgram = programSoFar.clone();\n\n        let cloneExecutedActions = cloneProgram.getExecutedActions();\n        candidateActions.forEach((a) => {\n          cloneExecutedActions.add(a);\n        });\n\n        // pre-condition check\n        if (!checkConstraintSatisfaction.call(this, cloneProgram)) {\n          return false;\n        }\n\n        // post condition checks\n        let clonePostProgram = programSoFar.clone();\n        clonePostProgram.setExecutedActions(new LiteralTreeMap());\n        let postState = clonePostProgram.getState();\n        updateStateWithFluentActors(\n          this,\n          candidateActions,\n          postState\n        );\n        clonePostProgram.setState(postState);\n\n        if (!checkConstraintSatisfaction.call(this, clonePostProgram)) {\n          return false;\n        }\n\n        resultSet = recursiveActionsSelector(\n          actionsSoFar.concat([candidateActions]),\n          cloneProgram,\n          l + 1\n        );\n        return true;\n      });\n\n      if (resultSet !== null) {\n        return resultSet;\n      }\n\n      return recursiveActionsSelector(\n        actionsSoFar,\n        programSoFar,\n        l + 1\n      );\n    };\n\n    return recursiveActionsSelector([], _program, 0);\n  }", "code_tokens": ["function", "actionsSelector", "(", "goalTrees", ")", "{", "const", "recursiveActionsSelector", "=", "(", "actionsSoFar", ",", "programSoFar", ",", "l", ")", "=>", "{", "if", "(", "l", ">=", "goalTrees", ".", "length", ")", "{", "let", "actions", "=", "new", "LiteralTreeMap", "(", ")", ";", "actionsSoFar", ".", "forEach", "(", "(", "map", ")", "=>", "{", "map", ".", "forEach", "(", "(", "literal", ")", "=>", "{", "actions", ".", "add", "(", "literal", ")", ";", "}", ")", ";", "}", ")", ";", "return", "actions", ";", "}", "let", "goalTree", "=", "goalTrees", "[", "l", "]", ";", "let", "resultSet", "=", "null", ";", "goalTree", ".", "forEachCandidateActions", "(", "_currentTime", ",", "(", "candidateActions", ")", "=>", "{", "let", "cloneProgram", "=", "programSoFar", ".", "clone", "(", ")", ";", "let", "cloneExecutedActions", "=", "cloneProgram", ".", "getExecutedActions", "(", ")", ";", "candidateActions", ".", "forEach", "(", "(", "a", ")", "=>", "{", "cloneExecutedActions", ".", "add", "(", "a", ")", ";", "}", ")", ";", "// pre-condition check", "if", "(", "!", "checkConstraintSatisfaction", ".", "call", "(", "this", ",", "cloneProgram", ")", ")", "{", "return", "false", ";", "}", "// post condition checks", "let", "clonePostProgram", "=", "programSoFar", ".", "clone", "(", ")", ";", "clonePostProgram", ".", "setExecutedActions", "(", "new", "LiteralTreeMap", "(", ")", ")", ";", "let", "postState", "=", "clonePostProgram", ".", "getState", "(", ")", ";", "updateStateWithFluentActors", "(", "this", ",", "candidateActions", ",", "postState", ")", ";", "clonePostProgram", ".", "setState", "(", "postState", ")", ";", "if", "(", "!", "checkConstraintSatisfaction", ".", "call", "(", "this", ",", "clonePostProgram", ")", ")", "{", "return", "false", ";", "}", "resultSet", "=", "recursiveActionsSelector", "(", "actionsSoFar", ".", "concat", "(", "[", "candidateActions", "]", ")", ",", "cloneProgram", ",", "l", "+", "1", ")", ";", "return", "true", ";", "}", ")", ";", "if", "(", "resultSet", "!==", "null", ")", "{", "return", "resultSet", ";", "}", "return", "recursiveActionsSelector", "(", "actionsSoFar", ",", "programSoFar", ",", "l", "+", "1", ")", ";", "}", ";", "return", "recursiveActionsSelector", "(", "[", "]", ",", "_program", ",", "0", ")", ";", "}"], "docstring": "Select the appropriate set of actions from the given goal trees such that\nconstraints are not violated for the current cycle.\n@param  {Array<GoalTree>} goalTrees The goal trees to choose actions from\n@return {LiteralTreeMap}            The set of actions chosen to execute", "docstring_tokens": ["Select", "the", "appropriate", "set", "of", "actions", "from", "the", "given", "goal", "trees", "such", "that", "constraints", "are", "not", "violated", "for", "the", "current", "cycle", "."], "sha": "f91fd5c5e738be909dea7996cb05014c716664d3", "url": "https://github.com/lps-js/lps.js/blob/f91fd5c5e738be909dea7996cb05014c716664d3/src/engine/Engine.js#L200-L261", "partition": "test"}
{"repo": "nicu/grel", "path": "grel.js", "func_name": "GrelRequest", "original_string": "function GrelRequest(grel) {\n    var authString;\n    \n    if (grel.token) {\n        authString = grel.token + ':';\n    } else {\n        authString = grel.user + ':' + grel.password;\n    }\n    \n    this.headers = {\n        'Authorization': 'Basic ' + new Buffer(authString).toString('base64'),\n        'Accept': 'application/vnd.github.manifold-preview',\n        'User-Agent': 'Grel'\n    };\n\n    this.grel = grel;\n    this.content = null;\n}", "language": "javascript", "code": "function GrelRequest(grel) {\n    var authString;\n    \n    if (grel.token) {\n        authString = grel.token + ':';\n    } else {\n        authString = grel.user + ':' + grel.password;\n    }\n    \n    this.headers = {\n        'Authorization': 'Basic ' + new Buffer(authString).toString('base64'),\n        'Accept': 'application/vnd.github.manifold-preview',\n        'User-Agent': 'Grel'\n    };\n\n    this.grel = grel;\n    this.content = null;\n}", "code_tokens": ["function", "GrelRequest", "(", "grel", ")", "{", "var", "authString", ";", "if", "(", "grel", ".", "token", ")", "{", "authString", "=", "grel", ".", "token", "+", "':'", ";", "}", "else", "{", "authString", "=", "grel", ".", "user", "+", "':'", "+", "grel", ".", "password", ";", "}", "this", ".", "headers", "=", "{", "'Authorization'", ":", "'Basic '", "+", "new", "Buffer", "(", "authString", ")", ".", "toString", "(", "'base64'", ")", ",", "'Accept'", ":", "'application/vnd.github.manifold-preview'", ",", "'User-Agent'", ":", "'Grel'", "}", ";", "this", ".", "grel", "=", "grel", ";", "this", ".", "content", "=", "null", ";", "}"], "docstring": "Creates a new instance of the GrelRequest class.\n\nThis class is used when sending HTTP requests to GitHub and it automatically handles\nuser authentication and a few other things.\n\n@param {Grel} grel Grel object that is used for authentication", "docstring_tokens": ["Creates", "a", "new", "instance", "of", "the", "GrelRequest", "class", "."], "sha": "cbcf42c88317e38330ef42902e11a6d3c5fb50cc", "url": "https://github.com/nicu/grel/blob/cbcf42c88317e38330ef42902e11a6d3c5fb50cc/grel.js#L53-L70", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "getValueForProperty", "original_string": "function getValueForProperty(node, name, expected, propertyInfo) {\n  {\n    if (propertyInfo.mustUseProperty) {\n      var propertyName = propertyInfo.propertyName;\n\n      return node[propertyName];\n    } else {\n      var attributeName = propertyInfo.attributeName;\n\n      var stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          var value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          if (value === '' + expected) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}", "language": "javascript", "code": "function getValueForProperty(node, name, expected, propertyInfo) {\n  {\n    if (propertyInfo.mustUseProperty) {\n      var propertyName = propertyInfo.propertyName;\n\n      return node[propertyName];\n    } else {\n      var attributeName = propertyInfo.attributeName;\n\n      var stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          var value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          if (value === '' + expected) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}", "code_tokens": ["function", "getValueForProperty", "(", "node", ",", "name", ",", "expected", ",", "propertyInfo", ")", "{", "{", "if", "(", "propertyInfo", ".", "mustUseProperty", ")", "{", "var", "propertyName", "=", "propertyInfo", ".", "propertyName", ";", "return", "node", "[", "propertyName", "]", ";", "}", "else", "{", "var", "attributeName", "=", "propertyInfo", ".", "attributeName", ";", "var", "stringValue", "=", "null", ";", "if", "(", "propertyInfo", ".", "type", "===", "OVERLOADED_BOOLEAN", ")", "{", "if", "(", "node", ".", "hasAttribute", "(", "attributeName", ")", ")", "{", "var", "value", "=", "node", ".", "getAttribute", "(", "attributeName", ")", ";", "if", "(", "value", "===", "''", ")", "{", "return", "true", ";", "}", "if", "(", "shouldRemoveAttribute", "(", "name", ",", "expected", ",", "propertyInfo", ",", "false", ")", ")", "{", "return", "value", ";", "}", "if", "(", "value", "===", "''", "+", "expected", ")", "{", "return", "expected", ";", "}", "return", "value", ";", "}", "}", "else", "if", "(", "node", ".", "hasAttribute", "(", "attributeName", ")", ")", "{", "if", "(", "shouldRemoveAttribute", "(", "name", ",", "expected", ",", "propertyInfo", ",", "false", ")", ")", "{", "// We had an attribute but shouldn't have had one, so read it", "// for the error message.", "return", "node", ".", "getAttribute", "(", "attributeName", ")", ";", "}", "if", "(", "propertyInfo", ".", "type", "===", "BOOLEAN", ")", "{", "// If this was a boolean, it doesn't matter what the value is", "// the fact that we have it is the same as the expected.", "return", "expected", ";", "}", "// Even if this property uses a namespace we use getAttribute", "// because we assume its namespaced name is the same as our config.", "// To use getAttributeNS we need the local name which we don't have", "// in our config atm.", "stringValue", "=", "node", ".", "getAttribute", "(", "attributeName", ")", ";", "}", "if", "(", "shouldRemoveAttribute", "(", "name", ",", "expected", ",", "propertyInfo", ",", "false", ")", ")", "{", "return", "stringValue", "===", "null", "?", "expected", ":", "stringValue", ";", "}", "else", "if", "(", "stringValue", "===", "''", "+", "expected", ")", "{", "return", "expected", ";", "}", "else", "{", "return", "stringValue", ";", "}", "}", "}", "}"], "docstring": "Get the value for a property on a node. Only used in DEV for SSR validation.\nThe \"expected\" argument is used as a hint of what the expected value is.\nSome properties have multiple equivalent values.", "docstring_tokens": ["Get", "the", "value", "for", "a", "property", "on", "a", "node", ".", "Only", "used", "in", "DEV", "for", "SSR", "validation", ".", "The", "expected", "argument", "is", "used", "as", "a", "hint", "of", "what", "the", "expected", "value", "is", ".", "Some", "properties", "have", "multiple", "equivalent", "values", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L5312-L5364", "partition": "test"}
{"repo": "the-labo/the-story-base", "path": "lib/by.js", "func_name": "byClass", "original_string": "function byClass (c) {\n  c = classnames(c)\n  if (/^\\./.test(c)) {\n    throw new Error('No need to \".\" on start')\n  }\n  return bySelector(`.${c}`)\n}", "language": "javascript", "code": "function byClass (c) {\n  c = classnames(c)\n  if (/^\\./.test(c)) {\n    throw new Error('No need to \".\" on start')\n  }\n  return bySelector(`.${c}`)\n}", "code_tokens": ["function", "byClass", "(", "c", ")", "{", "c", "=", "classnames", "(", "c", ")", "if", "(", "/", "^\\.", "/", ".", "test", "(", "c", ")", ")", "{", "throw", "new", "Error", "(", "'No need to \".\" on start'", ")", "}", "return", "bySelector", "(", "`", "${", "c", "}", "`", ")", "}"], "docstring": "By class name\n@param {string} c - Class name\n@returns {string} Selector by class", "docstring_tokens": ["By", "class", "name"], "sha": "c9a445a0df2286b1e8d6b366fd211eabab3d99e2", "url": "https://github.com/the-labo/the-story-base/blob/c9a445a0df2286b1e8d6b366fd211eabab3d99e2/lib/by.js#L49-L55", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/runtime/Runtime.js", "func_name": "", "original_string": "function(cap, value) {\n\t\t\t\tvar refCaps = arguments[2] || caps;\n\n\t\t\t\t// if cap var is a comma-separated list of caps, convert it to object (key/value)\n\t\t\t\tif (Basic.typeOf(cap) === 'string' && Basic.typeOf(value) === 'undefined') {\n\t\t\t\t\tcap = Runtime.parseCaps(cap);\n\t\t\t\t}\n\n\t\t\t\tif (Basic.typeOf(cap) === 'object') {\n\t\t\t\t\tfor (var key in cap) {\n\t\t\t\t\t\tif (!this.can(key, cap[key], refCaps)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// check the individual cap\n\t\t\t\tif (Basic.typeOf(refCaps[cap]) === 'function') {\n\t\t\t\t\treturn refCaps[cap].call(this, value);\n\t\t\t\t} else {\n\t\t\t\t\treturn (value === refCaps[cap]);\n\t\t\t\t}\n\t\t\t}", "language": "javascript", "code": "function(cap, value) {\n\t\t\t\tvar refCaps = arguments[2] || caps;\n\n\t\t\t\t// if cap var is a comma-separated list of caps, convert it to object (key/value)\n\t\t\t\tif (Basic.typeOf(cap) === 'string' && Basic.typeOf(value) === 'undefined') {\n\t\t\t\t\tcap = Runtime.parseCaps(cap);\n\t\t\t\t}\n\n\t\t\t\tif (Basic.typeOf(cap) === 'object') {\n\t\t\t\t\tfor (var key in cap) {\n\t\t\t\t\t\tif (!this.can(key, cap[key], refCaps)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// check the individual cap\n\t\t\t\tif (Basic.typeOf(refCaps[cap]) === 'function') {\n\t\t\t\t\treturn refCaps[cap].call(this, value);\n\t\t\t\t} else {\n\t\t\t\t\treturn (value === refCaps[cap]);\n\t\t\t\t}\n\t\t\t}", "code_tokens": ["function", "(", "cap", ",", "value", ")", "{", "var", "refCaps", "=", "arguments", "[", "2", "]", "||", "caps", ";", "// if cap var is a comma-separated list of caps, convert it to object (key/value)", "if", "(", "Basic", ".", "typeOf", "(", "cap", ")", "===", "'string'", "&&", "Basic", ".", "typeOf", "(", "value", ")", "===", "'undefined'", ")", "{", "cap", "=", "Runtime", ".", "parseCaps", "(", "cap", ")", ";", "}", "if", "(", "Basic", ".", "typeOf", "(", "cap", ")", "===", "'object'", ")", "{", "for", "(", "var", "key", "in", "cap", ")", "{", "if", "(", "!", "this", ".", "can", "(", "key", ",", "cap", "[", "key", "]", ",", "refCaps", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}", "// check the individual cap", "if", "(", "Basic", ".", "typeOf", "(", "refCaps", "[", "cap", "]", ")", "===", "'function'", ")", "{", "return", "refCaps", "[", "cap", "]", ".", "call", "(", "this", ",", "value", ")", ";", "}", "else", "{", "return", "(", "value", "===", "refCaps", "[", "cap", "]", ")", ";", "}", "}"], "docstring": "Checks if the runtime has specific capability\n\n@method can\n@param {String} cap Name of capability to check\n@param {Mixed} [value] If passed, capability should somehow correlate to the value\n@param {Object} [refCaps] Set of capabilities to check the specified cap against (defaults to internal set)\n@return {Boolean} true if runtime has such capability and false, if - not", "docstring_tokens": ["Checks", "if", "the", "runtime", "has", "specific", "capability"], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/runtime/Runtime.js#L230-L253", "partition": "test"}
{"repo": "cedx/coveralls.js", "path": "bin/coveralls.js", "func_name": "main", "original_string": "async function main() {\n  // Initialize the application.\n  process.title = 'Coveralls.js';\n\n  // Parse the command line arguments.\n  program.name('coveralls')\n    .description('Send a coverage report to the Coveralls service.')\n    .version(packageVersion, '-v, --version')\n    .arguments('<file>').action(file => program.file = file)\n    .parse(process.argv);\n\n  if (!program.file) {\n    program.outputHelp();\n    process.exitCode = 64;\n    return null;\n  }\n\n  // Run the program.\n  const client = new Client('COVERALLS_ENDPOINT' in process.env ? new URL(process.env.COVERALLS_ENDPOINT) : Client.defaultEndPoint);\n  const coverage = await promises.readFile(program.file, 'utf8');\n  console.log(`[Coveralls] Submitting to ${client.endPoint}`);\n  return client.upload(coverage);\n}", "language": "javascript", "code": "async function main() {\n  // Initialize the application.\n  process.title = 'Coveralls.js';\n\n  // Parse the command line arguments.\n  program.name('coveralls')\n    .description('Send a coverage report to the Coveralls service.')\n    .version(packageVersion, '-v, --version')\n    .arguments('<file>').action(file => program.file = file)\n    .parse(process.argv);\n\n  if (!program.file) {\n    program.outputHelp();\n    process.exitCode = 64;\n    return null;\n  }\n\n  // Run the program.\n  const client = new Client('COVERALLS_ENDPOINT' in process.env ? new URL(process.env.COVERALLS_ENDPOINT) : Client.defaultEndPoint);\n  const coverage = await promises.readFile(program.file, 'utf8');\n  console.log(`[Coveralls] Submitting to ${client.endPoint}`);\n  return client.upload(coverage);\n}", "code_tokens": ["async", "function", "main", "(", ")", "{", "// Initialize the application.", "process", ".", "title", "=", "'Coveralls.js'", ";", "// Parse the command line arguments.", "program", ".", "name", "(", "'coveralls'", ")", ".", "description", "(", "'Send a coverage report to the Coveralls service.'", ")", ".", "version", "(", "packageVersion", ",", "'-v, --version'", ")", ".", "arguments", "(", "'<file>'", ")", ".", "action", "(", "file", "=>", "program", ".", "file", "=", "file", ")", ".", "parse", "(", "process", ".", "argv", ")", ";", "if", "(", "!", "program", ".", "file", ")", "{", "program", ".", "outputHelp", "(", ")", ";", "process", ".", "exitCode", "=", "64", ";", "return", "null", ";", "}", "// Run the program.", "const", "client", "=", "new", "Client", "(", "'COVERALLS_ENDPOINT'", "in", "process", ".", "env", "?", "new", "URL", "(", "process", ".", "env", ".", "COVERALLS_ENDPOINT", ")", ":", "Client", ".", "defaultEndPoint", ")", ";", "const", "coverage", "=", "await", "promises", ".", "readFile", "(", "program", ".", "file", ",", "'utf8'", ")", ";", "console", ".", "log", "(", "`", "${", "client", ".", "endPoint", "}", "`", ")", ";", "return", "client", ".", "upload", "(", "coverage", ")", ";", "}"], "docstring": "Application entry point.\n@return {Promise<void>} Completes when the program is terminated.", "docstring_tokens": ["Application", "entry", "point", "."], "sha": "42ee63e3e6f6ffc695809f0c722cef7792edf0c5", "url": "https://github.com/cedx/coveralls.js/blob/42ee63e3e6f6ffc695809f0c722cef7792edf0c5/bin/coveralls.js#L16-L38", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/repo.js", "func_name": "updateWorkingState", "original_string": "function updateWorkingState(repoState, branch, newWorkingState) {\n    let workingStates = repoState.getWorkingStates();\n\n    const key = branch.getFullName();\n    if (newWorkingState === null) {\n        // Delete\n        workingStates = workingStates.delete(key);\n    } else {\n        // Update the entry in the map\n        workingStates = workingStates.set(key, newWorkingState);\n    }\n\n    return repoState.set('workingStates', workingStates);\n}", "language": "javascript", "code": "function updateWorkingState(repoState, branch, newWorkingState) {\n    let workingStates = repoState.getWorkingStates();\n\n    const key = branch.getFullName();\n    if (newWorkingState === null) {\n        // Delete\n        workingStates = workingStates.delete(key);\n    } else {\n        // Update the entry in the map\n        workingStates = workingStates.set(key, newWorkingState);\n    }\n\n    return repoState.set('workingStates', workingStates);\n}", "code_tokens": ["function", "updateWorkingState", "(", "repoState", ",", "branch", ",", "newWorkingState", ")", "{", "let", "workingStates", "=", "repoState", ".", "getWorkingStates", "(", ")", ";", "const", "key", "=", "branch", ".", "getFullName", "(", ")", ";", "if", "(", "newWorkingState", "===", "null", ")", "{", "// Delete", "workingStates", "=", "workingStates", ".", "delete", "(", "key", ")", ";", "}", "else", "{", "// Update the entry in the map", "workingStates", "=", "workingStates", ".", "set", "(", "key", ",", "newWorkingState", ")", ";", "}", "return", "repoState", ".", "set", "(", "'workingStates'", ",", "workingStates", ")", ";", "}"], "docstring": "Change workinState for a specific branch\n@param {RepositoryState} repoState\n@param {Branch} branch\n@param {WorkingState | Null} newWorkingState Pass null to delete\n@return {RepositoryState}", "docstring_tokens": ["Change", "workinState", "for", "a", "specific", "branch"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/repo.js#L12-L25", "partition": "test"}
{"repo": "young-steveo/bottlejs", "path": "dist/bottle.js", "func_name": "register", "original_string": "function register(Obj) {\n        var value = Obj.$value === undefined ? Obj : Obj.$value;\n        return this[Obj.$type || 'service'].apply(this, [Obj.$name, value].concat(Obj.$inject || []));\n    }", "language": "javascript", "code": "function register(Obj) {\n        var value = Obj.$value === undefined ? Obj : Obj.$value;\n        return this[Obj.$type || 'service'].apply(this, [Obj.$name, value].concat(Obj.$inject || []));\n    }", "code_tokens": ["function", "register", "(", "Obj", ")", "{", "var", "value", "=", "Obj", ".", "$value", "===", "undefined", "?", "Obj", ":", "Obj", ".", "$value", ";", "return", "this", "[", "Obj", ".", "$type", "||", "'service'", "]", ".", "apply", "(", "this", ",", "[", "Obj", ".", "$name", ",", "value", "]", ".", "concat", "(", "Obj", ".", "$inject", "||", "[", "]", ")", ")", ";", "}"], "docstring": "Register a service, factory, provider, or value based on properties on the object.\n\nproperties:\n* Obj.$name   String required ex: `'Thing'`\n* Obj.$type   String optional 'service', 'factory', 'provider', 'value'.  Default: 'service'\n* Obj.$inject Mixed  optional only useful with $type 'service' name or array of names\n* Obj.$value  Mixed  optional Normally Obj is registered on the container.  However, if this\nproperty is included, it's value will be registered on the container\ninstead of the object itsself.  Useful for registering objects on the\nbottle container without modifying those objects with bottle specific keys.\n\n@param Function Obj\n@return Bottle", "docstring_tokens": ["Register", "a", "service", "factory", "provider", "or", "value", "based", "on", "properties", "on", "the", "object", "."], "sha": "2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51", "url": "https://github.com/young-steveo/bottlejs/blob/2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51/dist/bottle.js#L512-L515", "partition": "test"}
{"repo": "zdfs/grunt-datadriver", "path": "tasks/datadriver.js", "func_name": "", "original_string": "function(result) {\n                var callback = arguments[arguments.length - 1];\n                grunt.log.debug('finish grunt task');\n\n                if (isLastTask) {\n\n                    // close the file if it was opened\n                    if (fd) {\n                        fs.closeSync(fd);\n                    }\n\n                    // Restore process.stdout.write to its original value\n                    hooker.unhook(process.stdout, 'write');\n\n                }\n\n                done(result);\n                callback();\n            }", "language": "javascript", "code": "function(result) {\n                var callback = arguments[arguments.length - 1];\n                grunt.log.debug('finish grunt task');\n\n                if (isLastTask) {\n\n                    // close the file if it was opened\n                    if (fd) {\n                        fs.closeSync(fd);\n                    }\n\n                    // Restore process.stdout.write to its original value\n                    hooker.unhook(process.stdout, 'write');\n\n                }\n\n                done(result);\n                callback();\n            }", "code_tokens": ["function", "(", "result", ")", "{", "var", "callback", "=", "arguments", "[", "arguments", ".", "length", "-", "1", "]", ";", "grunt", ".", "log", ".", "debug", "(", "'finish grunt task'", ")", ";", "if", "(", "isLastTask", ")", "{", "// close the file if it was opened", "if", "(", "fd", ")", "{", "fs", ".", "closeSync", "(", "fd", ")", ";", "}", "// Restore process.stdout.write to its original value", "hooker", ".", "unhook", "(", "process", ".", "stdout", ",", "'write'", ")", ";", "}", "done", "(", "result", ")", ";", "callback", "(", ")", ";", "}"], "docstring": "finish grunt task", "docstring_tokens": ["finish", "grunt", "task"], "sha": "8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e", "url": "https://github.com/zdfs/grunt-datadriver/blob/8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e/tasks/datadriver.js#L341-L359", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "isFacetRefined", "original_string": "function isFacetRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    return RefinementList.isRefined(this.facetsRefinements, facet, value);\n  }", "language": "javascript", "code": "function isFacetRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    return RefinementList.isRefined(this.facetsRefinements, facet, value);\n  }", "code_tokens": ["function", "isFacetRefined", "(", "facet", ",", "value", ")", "{", "if", "(", "!", "this", ".", "isConjunctiveFacet", "(", "facet", ")", ")", "{", "throw", "new", "Error", "(", "facet", "+", "' is not defined in the facets attribute of the helper configuration'", ")", ";", "}", "return", "RefinementList", ".", "isRefined", "(", "this", ".", "facetsRefinements", ",", "facet", ",", "value", ")", ";", "}"], "docstring": "Returns true if the facet is refined, either for a specific value or in\ngeneral.\n@method\n@param {string} facet name of the attribute for used for faceting\n@param {string} value, optional value. If passed will test that this value\nis filtering the given facet.\n@return {boolean} returns true if refined", "docstring_tokens": ["Returns", "true", "if", "the", "facet", "is", "refined", "either", "for", "a", "specific", "value", "or", "in", "general", "."], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L1383-L1388", "partition": "test"}
{"repo": "blinkylights23/grunt-swigtemplates", "path": "tasks/swigtemplates.js", "func_name": "getContext", "original_string": "function getContext(context, pathInfo) {\n      var globalContext,\n          templateContext;\n\n      try {\n        globalContext = grunt.file.readJSON(path.join(options.templatesDir, \"global.json\"));\n      } catch(err) {\n        globalContext = {};\n      }\n      try {\n        templateContext = grunt.file.readJSON(path.join(pathInfo.dirName, pathInfo.outfileName) + \".json\");\n      } catch(err) {\n        templateContext = {};\n      }\n      return _.extend({}, globalContext, templateContext, options.defaultContext, context);\n    }", "language": "javascript", "code": "function getContext(context, pathInfo) {\n      var globalContext,\n          templateContext;\n\n      try {\n        globalContext = grunt.file.readJSON(path.join(options.templatesDir, \"global.json\"));\n      } catch(err) {\n        globalContext = {};\n      }\n      try {\n        templateContext = grunt.file.readJSON(path.join(pathInfo.dirName, pathInfo.outfileName) + \".json\");\n      } catch(err) {\n        templateContext = {};\n      }\n      return _.extend({}, globalContext, templateContext, options.defaultContext, context);\n    }", "code_tokens": ["function", "getContext", "(", "context", ",", "pathInfo", ")", "{", "var", "globalContext", ",", "templateContext", ";", "try", "{", "globalContext", "=", "grunt", ".", "file", ".", "readJSON", "(", "path", ".", "join", "(", "options", ".", "templatesDir", ",", "\"global.json\"", ")", ")", ";", "}", "catch", "(", "err", ")", "{", "globalContext", "=", "{", "}", ";", "}", "try", "{", "templateContext", "=", "grunt", ".", "file", ".", "readJSON", "(", "path", ".", "join", "(", "pathInfo", ".", "dirName", ",", "pathInfo", ".", "outfileName", ")", "+", "\".json\"", ")", ";", "}", "catch", "(", "err", ")", "{", "templateContext", "=", "{", "}", ";", "}", "return", "_", ".", "extend", "(", "{", "}", ",", "globalContext", ",", "templateContext", ",", "options", ".", "defaultContext", ",", "context", ")", ";", "}"], "docstring": "Get swig context", "docstring_tokens": ["Get", "swig", "context"], "sha": "3a0d19f45aae7dc35efe3b5a08376be629498b7c", "url": "https://github.com/blinkylights23/grunt-swigtemplates/blob/3a0d19f45aae7dc35efe3b5a08376be629498b7c/tasks/swigtemplates.js#L139-L154", "partition": "test"}
{"repo": "nathanfaucett/js-url", "path": "src/index.js", "func_name": "urlFormat", "original_string": "function urlFormat(obj) {\n    // ensure it's an object, and not a string url.\n    // If it's an obj, this is a no-op.\n    // this way, you can call url_format() on strings\n    // to clean up potentially wonky urls.\n    if (isString(obj)) {\n        obj = urlParse(obj);\n    } else if (!isObject(obj) || isNull(obj)) {\n        throw new TypeError('Parameter \"urlObj\" must be an object, not ' +\n            isNull(obj) ? 'null' : typeof obj);\n    } else if (!(obj instanceof Url)) {\n        return Url.prototype.format.call(obj);\n    } else {\n        return obj.format();\n    }\n}", "language": "javascript", "code": "function urlFormat(obj) {\n    // ensure it's an object, and not a string url.\n    // If it's an obj, this is a no-op.\n    // this way, you can call url_format() on strings\n    // to clean up potentially wonky urls.\n    if (isString(obj)) {\n        obj = urlParse(obj);\n    } else if (!isObject(obj) || isNull(obj)) {\n        throw new TypeError('Parameter \"urlObj\" must be an object, not ' +\n            isNull(obj) ? 'null' : typeof obj);\n    } else if (!(obj instanceof Url)) {\n        return Url.prototype.format.call(obj);\n    } else {\n        return obj.format();\n    }\n}", "code_tokens": ["function", "urlFormat", "(", "obj", ")", "{", "// ensure it's an object, and not a string url.", "// If it's an obj, this is a no-op.", "// this way, you can call url_format() on strings", "// to clean up potentially wonky urls.", "if", "(", "isString", "(", "obj", ")", ")", "{", "obj", "=", "urlParse", "(", "obj", ")", ";", "}", "else", "if", "(", "!", "isObject", "(", "obj", ")", "||", "isNull", "(", "obj", ")", ")", "{", "throw", "new", "TypeError", "(", "'Parameter \"urlObj\" must be an object, not '", "+", "isNull", "(", "obj", ")", "?", "'null'", ":", "typeof", "obj", ")", ";", "}", "else", "if", "(", "!", "(", "obj", "instanceof", "Url", ")", ")", "{", "return", "Url", ".", "prototype", ".", "format", ".", "call", "(", "obj", ")", ";", "}", "else", "{", "return", "obj", ".", "format", "(", ")", ";", "}", "}"], "docstring": "format a parsed object into a url string", "docstring_tokens": ["format", "a", "parsed", "object", "into", "a", "url", "string"], "sha": "19b90692d340ada986e86f083fa85be2c09cf855", "url": "https://github.com/nathanfaucett/js-url/blob/19b90692d340ada986e86f083fa85be2c09cf855/src/index.js#L582-L597", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "spec/helpers/various-utils.js", "func_name": "toCamelCasedProperties", "original_string": "function toCamelCasedProperties ( hash ) {\n    var transformed = {};\n\n    _.each( hash, function ( value, key ) {\n        transformed[toCamelCase( key )] = value;\n    } );\n\n    return transformed;\n}", "language": "javascript", "code": "function toCamelCasedProperties ( hash ) {\n    var transformed = {};\n\n    _.each( hash, function ( value, key ) {\n        transformed[toCamelCase( key )] = value;\n    } );\n\n    return transformed;\n}", "code_tokens": ["function", "toCamelCasedProperties", "(", "hash", ")", "{", "var", "transformed", "=", "{", "}", ";", "_", ".", "each", "(", "hash", ",", "function", "(", "value", ",", "key", ")", "{", "transformed", "[", "toCamelCase", "(", "key", ")", "]", "=", "value", ";", "}", ")", ";", "return", "transformed", ";", "}"], "docstring": "Returns a transformed hash in which all dashed property names have been replaced by camelCased property names. The\ninput hash remains untouched.\n\nProperty values are not modified.\n\nSimple implementation, but good enough for the attribute names we deal with here.\n\nExample: { \"foo-bar\": \"what-ever\" } => { fooBar: \"what-ever\" }\n\n@param   {Object} hash\n@returns {Object}", "docstring_tokens": ["Returns", "a", "transformed", "hash", "in", "which", "all", "dashed", "property", "names", "have", "been", "replaced", "by", "camelCased", "property", "names", ".", "The", "input", "hash", "remains", "untouched", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/spec/helpers/various-utils.js#L134-L142", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(className) {\n    // lazily create elementClasses\n    this.elementClasses = (this.elementClasses || new ClassSet());\n    this.elementClasses.add(className);\n    this.classes = this.elementClasses.list;\n\n    return this;\n  }", "language": "javascript", "code": "function(className) {\n    // lazily create elementClasses\n    this.elementClasses = (this.elementClasses || new ClassSet());\n    this.elementClasses.add(className);\n    this.classes = this.elementClasses.list;\n\n    return this;\n  }", "code_tokens": ["function", "(", "className", ")", "{", "// lazily create elementClasses", "this", ".", "elementClasses", "=", "(", "this", ".", "elementClasses", "||", "new", "ClassSet", "(", ")", ")", ";", "this", ".", "elementClasses", ".", "add", "(", "className", ")", ";", "this", ".", "classes", "=", "this", ".", "elementClasses", ".", "list", ";", "return", "this", ";", "}"], "docstring": "Adds a class to the buffer, which will be rendered to the class attribute.\n\n@method addClass\n@param {String} className Class name to add to the buffer\n@chainable", "docstring_tokens": ["Adds", "a", "class", "to", "the", "buffer", "which", "will", "be", "rendered", "to", "the", "class", "attribute", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L21781-L21788", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getUnionSignatures", "original_string": "function getUnionSignatures(types, kind) {\n            var signatureLists = ts.map(types, function (t) { return getSignaturesOfType(t, kind); });\n            var result = undefined;\n            for (var i = 0; i < signatureLists.length; i++) {\n                for (var _i = 0, _a = signatureLists[i]; _i < _a.length; _i++) {\n                    var signature = _a[_i];\n                    // Only process signatures with parameter lists that aren't already in the result list\n                    if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreReturnTypes*/ true)) {\n                        var unionSignatures = findMatchingSignatures(signatureLists, signature, i);\n                        if (unionSignatures) {\n                            var s = signature;\n                            // Union the result types when more than one signature matches\n                            if (unionSignatures.length > 1) {\n                                s = cloneSignature(signature);\n                                // Clear resolved return type we possibly got from cloneSignature\n                                s.resolvedReturnType = undefined;\n                                s.unionSignatures = unionSignatures;\n                            }\n                            (result || (result = [])).push(s);\n                        }\n                    }\n                }\n            }\n            return result || emptyArray;\n        }", "language": "javascript", "code": "function getUnionSignatures(types, kind) {\n            var signatureLists = ts.map(types, function (t) { return getSignaturesOfType(t, kind); });\n            var result = undefined;\n            for (var i = 0; i < signatureLists.length; i++) {\n                for (var _i = 0, _a = signatureLists[i]; _i < _a.length; _i++) {\n                    var signature = _a[_i];\n                    // Only process signatures with parameter lists that aren't already in the result list\n                    if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreReturnTypes*/ true)) {\n                        var unionSignatures = findMatchingSignatures(signatureLists, signature, i);\n                        if (unionSignatures) {\n                            var s = signature;\n                            // Union the result types when more than one signature matches\n                            if (unionSignatures.length > 1) {\n                                s = cloneSignature(signature);\n                                // Clear resolved return type we possibly got from cloneSignature\n                                s.resolvedReturnType = undefined;\n                                s.unionSignatures = unionSignatures;\n                            }\n                            (result || (result = [])).push(s);\n                        }\n                    }\n                }\n            }\n            return result || emptyArray;\n        }", "code_tokens": ["function", "getUnionSignatures", "(", "types", ",", "kind", ")", "{", "var", "signatureLists", "=", "ts", ".", "map", "(", "types", ",", "function", "(", "t", ")", "{", "return", "getSignaturesOfType", "(", "t", ",", "kind", ")", ";", "}", ")", ";", "var", "result", "=", "undefined", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "signatureLists", ".", "length", ";", "i", "++", ")", "{", "for", "(", "var", "_i", "=", "0", ",", "_a", "=", "signatureLists", "[", "i", "]", ";", "_i", "<", "_a", ".", "length", ";", "_i", "++", ")", "{", "var", "signature", "=", "_a", "[", "_i", "]", ";", "// Only process signatures with parameter lists that aren't already in the result list", "if", "(", "!", "result", "||", "!", "findMatchingSignature", "(", "result", ",", "signature", ",", "/*partialMatch*/", "false", ",", "/*ignoreReturnTypes*/", "true", ")", ")", "{", "var", "unionSignatures", "=", "findMatchingSignatures", "(", "signatureLists", ",", "signature", ",", "i", ")", ";", "if", "(", "unionSignatures", ")", "{", "var", "s", "=", "signature", ";", "// Union the result types when more than one signature matches", "if", "(", "unionSignatures", ".", "length", ">", "1", ")", "{", "s", "=", "cloneSignature", "(", "signature", ")", ";", "// Clear resolved return type we possibly got from cloneSignature", "s", ".", "resolvedReturnType", "=", "undefined", ";", "s", ".", "unionSignatures", "=", "unionSignatures", ";", "}", "(", "result", "||", "(", "result", "=", "[", "]", ")", ")", ".", "push", "(", "s", ")", ";", "}", "}", "}", "}", "return", "result", "||", "emptyArray", ";", "}"], "docstring": "The signatures of a union type are those signatures that are present in each of the constituent types. Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional parameters and may differ in return types. When signatures differ in return types, the resulting return type is the union of the constituent return types.", "docstring_tokens": ["The", "signatures", "of", "a", "union", "type", "are", "those", "signatures", "that", "are", "present", "in", "each", "of", "the", "constituent", "types", ".", "Generic", "signatures", "must", "match", "exactly", "but", "non", "-", "generic", "signatures", "are", "allowed", "to", "have", "extra", "optional", "parameters", "and", "may", "differ", "in", "return", "types", ".", "When", "signatures", "differ", "in", "return", "types", "the", "resulting", "return", "type", "is", "the", "union", "of", "the", "constituent", "return", "types", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L16303-L16327", "partition": "test"}
{"repo": "FCOO/fcoo-grunt-plugin", "path": "grunt/config/bower_concat.js", "func_name": "", "original_string": "function(mainFiles /*, component*/) {\n                for (var i=0; i<mainFiles.length; i++ ){\n                    //Use no-minified version if available\n                    var parts = mainFiles[i].split('.'),\n                        ext   = parts.pop(),\n                        min   = parts.pop(),\n                        fName;\n                    if (min == 'min'){\n                      parts.push(ext);\n                        fName = parts.join('.');\n                        if (grunt.file.exists(fName))\n                            mainFiles[i] = fName;\n                    }\n                }\n                return mainFiles;\n            }", "language": "javascript", "code": "function(mainFiles /*, component*/) {\n                for (var i=0; i<mainFiles.length; i++ ){\n                    //Use no-minified version if available\n                    var parts = mainFiles[i].split('.'),\n                        ext   = parts.pop(),\n                        min   = parts.pop(),\n                        fName;\n                    if (min == 'min'){\n                      parts.push(ext);\n                        fName = parts.join('.');\n                        if (grunt.file.exists(fName))\n                            mainFiles[i] = fName;\n                    }\n                }\n                return mainFiles;\n            }", "code_tokens": ["function", "(", "mainFiles", "/*, component*/", ")", "{", "for", "(", "var", "i", "=", "0", ";", "i", "<", "mainFiles", ".", "length", ";", "i", "++", ")", "{", "//Use no-minified version if available", "var", "parts", "=", "mainFiles", "[", "i", "]", ".", "split", "(", "'.'", ")", ",", "ext", "=", "parts", ".", "pop", "(", ")", ",", "min", "=", "parts", ".", "pop", "(", ")", ",", "fName", ";", "if", "(", "min", "==", "'min'", ")", "{", "parts", ".", "push", "(", "ext", ")", ";", "fName", "=", "parts", ".", "join", "(", "'.'", ")", ";", "if", "(", "grunt", ".", "file", ".", "exists", "(", "fName", ")", ")", "mainFiles", "[", "i", "]", "=", "fName", ";", "}", "}", "return", "mainFiles", ";", "}"], "docstring": "Is set by the task \"_read_overrides_and_resolutions\"", "docstring_tokens": ["Is", "set", "by", "the", "task", "_read_overrides_and_resolutions"], "sha": "03d8b5c0b493244b4db3d08844554b31306ca8bf", "url": "https://github.com/FCOO/fcoo-grunt-plugin/blob/03d8b5c0b493244b4db3d08844554b31306ca8bf/grunt/config/bower_concat.js#L23-L38", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "matchKeys", "original_string": "function matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}", "language": "javascript", "code": "function matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}", "code_tokens": ["function", "matchKeys", "(", "obj", ",", "glob", ",", "options", ")", "{", "if", "(", "utils", ".", "typeOf", "(", "obj", ")", "!==", "'object'", ")", "{", "throw", "new", "TypeError", "(", "msg", "(", "'matchKeys'", ",", "'first argument'", ",", "'an object'", ")", ")", ";", "}", "var", "fn", "=", "matcher", "(", "glob", ",", "options", ")", ";", "var", "res", "=", "{", "}", ";", "for", "(", "var", "key", "in", "obj", ")", "{", "if", "(", "obj", ".", "hasOwnProperty", "(", "key", ")", "&&", "fn", "(", "key", ")", ")", "{", "res", "[", "key", "]", "=", "obj", "[", "key", "]", ";", "}", "}", "return", "res", ";", "}"], "docstring": "Filter the keys of an object with the given `glob` pattern\nand `options`\n\n@param  {Object} `object`\n@param  {Pattern} `object`\n@return {Array}", "docstring_tokens": ["Filter", "the", "keys", "of", "an", "object", "with", "the", "given", "glob", "pattern", "and", "options"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L42290-L42304", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "removeDisjunctiveFacetRefinement", "original_string": "function removeDisjunctiveFacetRefinement(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n    if (!RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)) return this;\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.removeRefinement(\n        this.disjunctiveFacetsRefinements, facet, value)\n    });\n  }", "language": "javascript", "code": "function removeDisjunctiveFacetRefinement(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n    if (!RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)) return this;\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.removeRefinement(\n        this.disjunctiveFacetsRefinements, facet, value)\n    });\n  }", "code_tokens": ["function", "removeDisjunctiveFacetRefinement", "(", "facet", ",", "value", ")", "{", "if", "(", "!", "this", ".", "isDisjunctiveFacet", "(", "facet", ")", ")", "{", "throw", "new", "Error", "(", "facet", "+", "' is not defined in the disjunctiveFacets attribute of the helper configuration'", ")", ";", "}", "if", "(", "!", "RefinementList", ".", "isRefined", "(", "this", ".", "disjunctiveFacetsRefinements", ",", "facet", ",", "value", ")", ")", "return", "this", ";", "return", "this", ".", "setQueryParameters", "(", "{", "disjunctiveFacetsRefinements", ":", "RefinementList", ".", "removeRefinement", "(", "this", ".", "disjunctiveFacetsRefinements", ",", "facet", ",", "value", ")", "}", ")", ";", "}"], "docstring": "Remove a refinement on a disjunctive facet\n@method\n@param {string} facet name of the attribute used for faceting\n@param {string} value value used to filter\n@return {SearchParameters}", "docstring_tokens": ["Remove", "a", "refinement", "on", "a", "disjunctive", "facet"], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L1146-L1157", "partition": "test"}
{"repo": "appium/appium-xcuitest-driver", "path": "lib/wda/utils.js", "func_name": "getWDAUpgradeTimestamp", "original_string": "async function getWDAUpgradeTimestamp (bootstrapPath) {\n  const carthageRootPath = path.resolve(bootstrapPath, CARTHAGE_ROOT);\n  if (await fs.exists(carthageRootPath)) {\n    const {mtime} = await fs.stat(carthageRootPath);\n    return mtime.getTime();\n  }\n  return null;\n}", "language": "javascript", "code": "async function getWDAUpgradeTimestamp (bootstrapPath) {\n  const carthageRootPath = path.resolve(bootstrapPath, CARTHAGE_ROOT);\n  if (await fs.exists(carthageRootPath)) {\n    const {mtime} = await fs.stat(carthageRootPath);\n    return mtime.getTime();\n  }\n  return null;\n}", "code_tokens": ["async", "function", "getWDAUpgradeTimestamp", "(", "bootstrapPath", ")", "{", "const", "carthageRootPath", "=", "path", ".", "resolve", "(", "bootstrapPath", ",", "CARTHAGE_ROOT", ")", ";", "if", "(", "await", "fs", ".", "exists", "(", "carthageRootPath", ")", ")", "{", "const", "{", "mtime", "}", "=", "await", "fs", ".", "stat", "(", "carthageRootPath", ")", ";", "return", "mtime", ".", "getTime", "(", ")", ";", "}", "return", "null", ";", "}"], "docstring": "Retrieves WDA upgrade timestamp\n\n@param {string} bootstrapPath The full path to the folder where WDA source is located\n@return {?number} The UNIX timestamp of the carthage root folder, where dependencies are downloaded.\nThis folder is created only once on module upgrade/first install.", "docstring_tokens": ["Retrieves", "WDA", "upgrade", "timestamp"], "sha": "eb8c1348c390314c7ad12294f8eb5c2e52326f57", "url": "https://github.com/appium/appium-xcuitest-driver/blob/eb8c1348c390314c7ad12294f8eb5c2e52326f57/lib/wda/utils.js#L340-L347", "partition": "test"}
{"repo": "apache/cordova-plugin-media", "path": "src/windows/MediaProxy.js", "func_name": "processUri", "original_string": "function processUri(src) {\n    // Collapse double slashes (File plugin issue): ms-appdata:///temp//recs/memos/media.m4a => ms-appdata:///temp/recs/memos/media.m4a\n    src = src.replace(/([^\\/:])(\\/\\/)([^\\/])/g, '$1/$3');\n\n    // Remove beginning slashes\n    src = src.replace(/^[\\\\\\/]{1,2}/, '');\n\n    var uri = setTemporaryFsByDefault(src);\n\n    uri = fullPathToAppData(uri);\n    uri = cdvfileToAppData(uri);\n\n    return uri;\n}", "language": "javascript", "code": "function processUri(src) {\n    // Collapse double slashes (File plugin issue): ms-appdata:///temp//recs/memos/media.m4a => ms-appdata:///temp/recs/memos/media.m4a\n    src = src.replace(/([^\\/:])(\\/\\/)([^\\/])/g, '$1/$3');\n\n    // Remove beginning slashes\n    src = src.replace(/^[\\\\\\/]{1,2}/, '');\n\n    var uri = setTemporaryFsByDefault(src);\n\n    uri = fullPathToAppData(uri);\n    uri = cdvfileToAppData(uri);\n\n    return uri;\n}", "code_tokens": ["function", "processUri", "(", "src", ")", "{", "// Collapse double slashes (File plugin issue): ms-appdata:///temp//recs/memos/media.m4a => ms-appdata:///temp/recs/memos/media.m4a", "src", "=", "src", ".", "replace", "(", "/", "([^\\/:])(\\/\\/)([^\\/])", "/", "g", ",", "'$1/$3'", ")", ";", "// Remove beginning slashes", "src", "=", "src", ".", "replace", "(", "/", "^[\\\\\\/]{1,2}", "/", ",", "''", ")", ";", "var", "uri", "=", "setTemporaryFsByDefault", "(", "src", ")", ";", "uri", "=", "fullPathToAppData", "(", "uri", ")", ";", "uri", "=", "cdvfileToAppData", "(", "uri", ")", ";", "return", "uri", ";", "}"], "docstring": "Prepares media src for internal usage\n@param  {String} src Input media path\n@return {Object}     Windows.Foundation.Uri", "docstring_tokens": ["Prepares", "media", "src", "for", "internal", "usage"], "sha": "b1c135342619f773fee3e8693a46992a133efd56", "url": "https://github.com/apache/cordova-plugin-media/blob/b1c135342619f773fee3e8693a46992a133efd56/src/windows/MediaProxy.js#L368-L381", "partition": "test"}
{"repo": "kuno/node-pachube", "path": "lib/point.js", "func_name": "Point", "original_string": "function Point(masterApikey, feedID, streamID) {\n  /** @private */this.masterApiKey  = masterApikey;\n  /** @private */this.feedID   = feedID.toString();\n  /** @private */this.streamID = streamID.toString();\n}", "language": "javascript", "code": "function Point(masterApikey, feedID, streamID) {\n  /** @private */this.masterApiKey  = masterApikey;\n  /** @private */this.feedID   = feedID.toString();\n  /** @private */this.streamID = streamID.toString();\n}", "code_tokens": ["function", "Point", "(", "masterApikey", ",", "feedID", ",", "streamID", ")", "{", "/** @private */", "this", ".", "masterApiKey", "=", "masterApikey", ";", "/** @private */", "this", ".", "feedID", "=", "feedID", ".", "toString", "(", ")", ";", "/** @private */", "this", ".", "streamID", "=", "streamID", ".", "toString", "(", ")", ";", "}"], "docstring": "Create an instance of Point\n\n@constructor {Point}\n@this        {Point}\n@param       {string}     masterApikey Your pachube api key.", "docstring_tokens": ["Create", "an", "instance", "of", "Point"], "sha": "a72d64c6050c372ccbe1c6eb78db665b6afdb66e", "url": "https://github.com/kuno/node-pachube/blob/a72d64c6050c372ccbe1c6eb78db665b6afdb66e/lib/point.js#L17-L21", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(rootElement, event, eventName) {\n    var self = this;\n\n    rootElement.on(event + '.ember', '.ember-view', function(evt, triggeringManager) {\n      var view = Ember.View.views[this.id],\n          result = true, manager = null;\n\n      manager = self._findNearestEventManager(view, eventName);\n\n      if (manager && manager !== triggeringManager) {\n        result = self._dispatchEvent(manager, evt, eventName, view);\n      } else if (view) {\n        result = self._bubbleEvent(view, evt, eventName);\n      } else {\n        evt.stopPropagation();\n      }\n\n      return result;\n    });\n\n    rootElement.on(event + '.ember', '[data-ember-action]', function(evt) {\n      var actionId = Ember.$(evt.currentTarget).attr('data-ember-action'),\n          action   = Ember.Handlebars.ActionHelper.registeredActions[actionId];\n\n      // We have to check for action here since in some cases, jQuery will trigger\n      // an event on `removeChild` (i.e. focusout) after we've already torn down the\n      // action handlers for the view.\n      if (action && action.eventName === eventName) {\n        return action.handler(evt);\n      }\n    });\n  }", "language": "javascript", "code": "function(rootElement, event, eventName) {\n    var self = this;\n\n    rootElement.on(event + '.ember', '.ember-view', function(evt, triggeringManager) {\n      var view = Ember.View.views[this.id],\n          result = true, manager = null;\n\n      manager = self._findNearestEventManager(view, eventName);\n\n      if (manager && manager !== triggeringManager) {\n        result = self._dispatchEvent(manager, evt, eventName, view);\n      } else if (view) {\n        result = self._bubbleEvent(view, evt, eventName);\n      } else {\n        evt.stopPropagation();\n      }\n\n      return result;\n    });\n\n    rootElement.on(event + '.ember', '[data-ember-action]', function(evt) {\n      var actionId = Ember.$(evt.currentTarget).attr('data-ember-action'),\n          action   = Ember.Handlebars.ActionHelper.registeredActions[actionId];\n\n      // We have to check for action here since in some cases, jQuery will trigger\n      // an event on `removeChild` (i.e. focusout) after we've already torn down the\n      // action handlers for the view.\n      if (action && action.eventName === eventName) {\n        return action.handler(evt);\n      }\n    });\n  }", "code_tokens": ["function", "(", "rootElement", ",", "event", ",", "eventName", ")", "{", "var", "self", "=", "this", ";", "rootElement", ".", "on", "(", "event", "+", "'.ember'", ",", "'.ember-view'", ",", "function", "(", "evt", ",", "triggeringManager", ")", "{", "var", "view", "=", "Ember", ".", "View", ".", "views", "[", "this", ".", "id", "]", ",", "result", "=", "true", ",", "manager", "=", "null", ";", "manager", "=", "self", ".", "_findNearestEventManager", "(", "view", ",", "eventName", ")", ";", "if", "(", "manager", "&&", "manager", "!==", "triggeringManager", ")", "{", "result", "=", "self", ".", "_dispatchEvent", "(", "manager", ",", "evt", ",", "eventName", ",", "view", ")", ";", "}", "else", "if", "(", "view", ")", "{", "result", "=", "self", ".", "_bubbleEvent", "(", "view", ",", "evt", ",", "eventName", ")", ";", "}", "else", "{", "evt", ".", "stopPropagation", "(", ")", ";", "}", "return", "result", ";", "}", ")", ";", "rootElement", ".", "on", "(", "event", "+", "'.ember'", ",", "'[data-ember-action]'", ",", "function", "(", "evt", ")", "{", "var", "actionId", "=", "Ember", ".", "$", "(", "evt", ".", "currentTarget", ")", ".", "attr", "(", "'data-ember-action'", ")", ",", "action", "=", "Ember", ".", "Handlebars", ".", "ActionHelper", ".", "registeredActions", "[", "actionId", "]", ";", "// We have to check for action here since in some cases, jQuery will trigger", "// an event on `removeChild` (i.e. focusout) after we've already torn down the", "// action handlers for the view.", "if", "(", "action", "&&", "action", ".", "eventName", "===", "eventName", ")", "{", "return", "action", ".", "handler", "(", "evt", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Registers an event listener on the document. If the given event is\ntriggered, the provided event handler will be triggered on the target view.\n\nIf the target view does not implement the event handler, or if the handler\nreturns `false`, the parent view will be called. The event will continue to\nbubble to each successive parent view until it reaches the top.\n\nFor example, to have the `mouseDown` method called on the target view when\na `mousedown` event is received from the browser, do the following:\n\n```javascript\nsetupHandler('mousedown', 'mouseDown');\n```\n\n@private\n@method setupHandler\n@param {Element} rootElement\n@param {String} event the browser-originated event to listen to\n@param {String} eventName the name of the method to call on the view", "docstring_tokens": ["Registers", "an", "event", "listener", "on", "the", "document", ".", "If", "the", "given", "event", "is", "triggered", "the", "provided", "event", "handler", "will", "be", "triggered", "on", "the", "target", "view", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L22231-L22262", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "isIdentifierName", "original_string": "function isIdentifierName(node) {\n        var parent = node.parent;\n        switch (parent.kind) {\n            case 141 /* PropertyDeclaration */:\n            case 140 /* PropertySignature */:\n            case 143 /* MethodDeclaration */:\n            case 142 /* MethodSignature */:\n            case 145 /* GetAccessor */:\n            case 146 /* SetAccessor */:\n            case 247 /* EnumMember */:\n            case 245 /* PropertyAssignment */:\n            case 166 /* PropertyAccessExpression */:\n                // Name in member declaration or property name in property access\n                return parent.name === node;\n            case 135 /* QualifiedName */:\n                // Name on right hand side of dot in a type query\n                if (parent.right === node) {\n                    while (parent.kind === 135 /* QualifiedName */) {\n                        parent = parent.parent;\n                    }\n                    return parent.kind === 154 /* TypeQuery */;\n                }\n                return false;\n            case 163 /* BindingElement */:\n            case 226 /* ImportSpecifier */:\n                // Property name in binding element or import specifier\n                return parent.propertyName === node;\n            case 230 /* ExportSpecifier */:\n                // Any name in an export specifier\n                return true;\n        }\n        return false;\n    }", "language": "javascript", "code": "function isIdentifierName(node) {\n        var parent = node.parent;\n        switch (parent.kind) {\n            case 141 /* PropertyDeclaration */:\n            case 140 /* PropertySignature */:\n            case 143 /* MethodDeclaration */:\n            case 142 /* MethodSignature */:\n            case 145 /* GetAccessor */:\n            case 146 /* SetAccessor */:\n            case 247 /* EnumMember */:\n            case 245 /* PropertyAssignment */:\n            case 166 /* PropertyAccessExpression */:\n                // Name in member declaration or property name in property access\n                return parent.name === node;\n            case 135 /* QualifiedName */:\n                // Name on right hand side of dot in a type query\n                if (parent.right === node) {\n                    while (parent.kind === 135 /* QualifiedName */) {\n                        parent = parent.parent;\n                    }\n                    return parent.kind === 154 /* TypeQuery */;\n                }\n                return false;\n            case 163 /* BindingElement */:\n            case 226 /* ImportSpecifier */:\n                // Property name in binding element or import specifier\n                return parent.propertyName === node;\n            case 230 /* ExportSpecifier */:\n                // Any name in an export specifier\n                return true;\n        }\n        return false;\n    }", "code_tokens": ["function", "isIdentifierName", "(", "node", ")", "{", "var", "parent", "=", "node", ".", "parent", ";", "switch", "(", "parent", ".", "kind", ")", "{", "case", "141", "/* PropertyDeclaration */", ":", "case", "140", "/* PropertySignature */", ":", "case", "143", "/* MethodDeclaration */", ":", "case", "142", "/* MethodSignature */", ":", "case", "145", "/* GetAccessor */", ":", "case", "146", "/* SetAccessor */", ":", "case", "247", "/* EnumMember */", ":", "case", "245", "/* PropertyAssignment */", ":", "case", "166", "/* PropertyAccessExpression */", ":", "// Name in member declaration or property name in property access", "return", "parent", ".", "name", "===", "node", ";", "case", "135", "/* QualifiedName */", ":", "// Name on right hand side of dot in a type query", "if", "(", "parent", ".", "right", "===", "node", ")", "{", "while", "(", "parent", ".", "kind", "===", "135", "/* QualifiedName */", ")", "{", "parent", "=", "parent", ".", "parent", ";", "}", "return", "parent", ".", "kind", "===", "154", "/* TypeQuery */", ";", "}", "return", "false", ";", "case", "163", "/* BindingElement */", ":", "case", "226", "/* ImportSpecifier */", ":", "// Property name in binding element or import specifier", "return", "parent", ".", "propertyName", "===", "node", ";", "case", "230", "/* ExportSpecifier */", ":", "// Any name in an export specifier", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Return true if the given identifier is classified as an IdentifierName", "docstring_tokens": ["Return", "true", "if", "the", "given", "identifier", "is", "classified", "as", "an", "IdentifierName"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L6308-L6340", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/conflict.js", "func_name": "solveTree", "original_string": "function solveTree(treeConflict, solved) {\n    solved = treeConflict.getConflicts()\n    .merge(solved)\n    // Solve unresolved conflicts\n    .map(function defaultSolve(conflict) {\n        if (!conflict.isSolved()) {\n            return conflict.keepBase();\n        } else {\n            return conflict;\n        }\n    });\n    return treeConflict.set('conflicts', solved);\n}", "language": "javascript", "code": "function solveTree(treeConflict, solved) {\n    solved = treeConflict.getConflicts()\n    .merge(solved)\n    // Solve unresolved conflicts\n    .map(function defaultSolve(conflict) {\n        if (!conflict.isSolved()) {\n            return conflict.keepBase();\n        } else {\n            return conflict;\n        }\n    });\n    return treeConflict.set('conflicts', solved);\n}", "code_tokens": ["function", "solveTree", "(", "treeConflict", ",", "solved", ")", "{", "solved", "=", "treeConflict", ".", "getConflicts", "(", ")", ".", "merge", "(", "solved", ")", "// Solve unresolved conflicts", ".", "map", "(", "function", "defaultSolve", "(", "conflict", ")", "{", "if", "(", "!", "conflict", ".", "isSolved", "(", ")", ")", "{", "return", "conflict", ".", "keepBase", "(", ")", ";", "}", "else", "{", "return", "conflict", ";", "}", "}", ")", ";", "return", "treeConflict", ".", "set", "(", "'conflicts'", ",", "solved", ")", ";", "}"], "docstring": "Merge solved Conflicts back into a TreeConflict. Unsolved conflicts\ndefault to keep base.\n@param {TreeConflict} treeConflict\n@param {Map<Path, Conflict>} solved\n@return {TreeConflict}", "docstring_tokens": ["Merge", "solved", "Conflicts", "back", "into", "a", "TreeConflict", ".", "Unsolved", "conflicts", "default", "to", "keep", "base", "."], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/conflict.js#L56-L68", "partition": "test"}
{"repo": "mojaie/kiwiii-client", "path": "src/graph/GraphControlBox.js", "func_name": "updateNodeColor", "original_string": "function updateNodeColor(data) {\n  d3.selectAll('.node').select('.node-symbol')\n    .style('fill', d => d3scale.scaleFunction(data.scale)(d[data.column.key]));\n}", "language": "javascript", "code": "function updateNodeColor(data) {\n  d3.selectAll('.node').select('.node-symbol')\n    .style('fill', d => d3scale.scaleFunction(data.scale)(d[data.column.key]));\n}", "code_tokens": ["function", "updateNodeColor", "(", "data", ")", "{", "d3", ".", "selectAll", "(", "'.node'", ")", ".", "select", "(", "'.node-symbol'", ")", ".", "style", "(", "'fill'", ",", "d", "=>", "d3scale", ".", "scaleFunction", "(", "data", ".", "scale", ")", "(", "d", "[", "data", ".", "column", ".", "key", "]", ")", ")", ";", "}"], "docstring": "Update DOM attributes", "docstring_tokens": ["Update", "DOM", "attributes"], "sha": "0f2820e9e0500c845acc36e8e21cb2ee11c28996", "url": "https://github.com/mojaie/kiwiii-client/blob/0f2820e9e0500c845acc36e8e21cb2ee11c28996/src/graph/GraphControlBox.js#L97-L100", "partition": "test"}
{"repo": "makeomatic/ms-users-restify", "path": "docs/main.js", "func_name": "renderArticle", "original_string": "function renderArticle(group, name, version) {\n        var entry = {};\n        $.each(apiByGroupAndName[group][name], function(index, currentEntry) {\n            if (currentEntry.version === version)\n                entry = currentEntry;\n        });\n        var fields = {\n            article: entry,\n            versions: articleVersions[group][name]\n        };\n\n        addArticleSettings(fields, entry);\n\n        return templateArticle(fields);\n    }", "language": "javascript", "code": "function renderArticle(group, name, version) {\n        var entry = {};\n        $.each(apiByGroupAndName[group][name], function(index, currentEntry) {\n            if (currentEntry.version === version)\n                entry = currentEntry;\n        });\n        var fields = {\n            article: entry,\n            versions: articleVersions[group][name]\n        };\n\n        addArticleSettings(fields, entry);\n\n        return templateArticle(fields);\n    }", "code_tokens": ["function", "renderArticle", "(", "group", ",", "name", ",", "version", ")", "{", "var", "entry", "=", "{", "}", ";", "$", ".", "each", "(", "apiByGroupAndName", "[", "group", "]", "[", "name", "]", ",", "function", "(", "index", ",", "currentEntry", ")", "{", "if", "(", "currentEntry", ".", "version", "===", "version", ")", "entry", "=", "currentEntry", ";", "}", ")", ";", "var", "fields", "=", "{", "article", ":", "entry", ",", "versions", ":", "articleVersions", "[", "group", "]", "[", "name", "]", "}", ";", "addArticleSettings", "(", "fields", ",", "entry", ")", ";", "return", "templateArticle", "(", "fields", ")", ";", "}"], "docstring": "Render Article.", "docstring_tokens": ["Render", "Article", "."], "sha": "f6c1e464458eb35c1dd62ce0bf648a560d6759e0", "url": "https://github.com/makeomatic/ms-users-restify/blob/f6c1e464458eb35c1dd62ce0bf648a560d6759e0/docs/main.js#L608-L622", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/client-options.js", "func_name": "validateEncodingOptions", "original_string": "function validateEncodingOptions(encodingOptions) {\n  if (encodingOptions.map) {\n    const mapConstructor = encodingOptions.map;\n    if (typeof mapConstructor !== 'function' ||\n      typeof mapConstructor.prototype.forEach !== 'function' ||\n      typeof mapConstructor.prototype.set !== 'function') {\n      throw new TypeError('Map constructor not valid');\n    }\n  }\n\n  if (encodingOptions.set) {\n    const setConstructor = encodingOptions.set;\n    if (typeof setConstructor !== 'function' ||\n      typeof setConstructor.prototype.forEach !== 'function' ||\n      typeof setConstructor.prototype.add !== 'function') {\n      throw new TypeError('Set constructor not valid');\n    }\n  }\n\n  if ((encodingOptions.useBigIntAsLong || encodingOptions.useBigIntAsVarint) && typeof BigInt === 'undefined') {\n    throw new TypeError('BigInt is not supported by the JavaScript engine');\n  }\n}", "language": "javascript", "code": "function validateEncodingOptions(encodingOptions) {\n  if (encodingOptions.map) {\n    const mapConstructor = encodingOptions.map;\n    if (typeof mapConstructor !== 'function' ||\n      typeof mapConstructor.prototype.forEach !== 'function' ||\n      typeof mapConstructor.prototype.set !== 'function') {\n      throw new TypeError('Map constructor not valid');\n    }\n  }\n\n  if (encodingOptions.set) {\n    const setConstructor = encodingOptions.set;\n    if (typeof setConstructor !== 'function' ||\n      typeof setConstructor.prototype.forEach !== 'function' ||\n      typeof setConstructor.prototype.add !== 'function') {\n      throw new TypeError('Set constructor not valid');\n    }\n  }\n\n  if ((encodingOptions.useBigIntAsLong || encodingOptions.useBigIntAsVarint) && typeof BigInt === 'undefined') {\n    throw new TypeError('BigInt is not supported by the JavaScript engine');\n  }\n}", "code_tokens": ["function", "validateEncodingOptions", "(", "encodingOptions", ")", "{", "if", "(", "encodingOptions", ".", "map", ")", "{", "const", "mapConstructor", "=", "encodingOptions", ".", "map", ";", "if", "(", "typeof", "mapConstructor", "!==", "'function'", "||", "typeof", "mapConstructor", ".", "prototype", ".", "forEach", "!==", "'function'", "||", "typeof", "mapConstructor", ".", "prototype", ".", "set", "!==", "'function'", ")", "{", "throw", "new", "TypeError", "(", "'Map constructor not valid'", ")", ";", "}", "}", "if", "(", "encodingOptions", ".", "set", ")", "{", "const", "setConstructor", "=", "encodingOptions", ".", "set", ";", "if", "(", "typeof", "setConstructor", "!==", "'function'", "||", "typeof", "setConstructor", ".", "prototype", ".", "forEach", "!==", "'function'", "||", "typeof", "setConstructor", ".", "prototype", ".", "add", "!==", "'function'", ")", "{", "throw", "new", "TypeError", "(", "'Set constructor not valid'", ")", ";", "}", "}", "if", "(", "(", "encodingOptions", ".", "useBigIntAsLong", "||", "encodingOptions", ".", "useBigIntAsVarint", ")", "&&", "typeof", "BigInt", "===", "'undefined'", ")", "{", "throw", "new", "TypeError", "(", "'BigInt is not supported by the JavaScript engine'", ")", ";", "}", "}"], "docstring": "Validates the encoding options.\n@param {ClientOptions.encoding} encodingOptions\n@private", "docstring_tokens": ["Validates", "the", "encoding", "options", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/client-options.js#L195-L217", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(options) {\n    if (!options || typeof options === \"string\") {\n      var outletName = options;\n      options = {};\n      options.outlet = outletName;\n    }\n    options.parentView = options.parentView ? options.parentView.replace(/\\//g, '.') : parentTemplate(this);\n    options.outlet = options.outlet || 'main';\n\n    var parentView = this.router._lookupActiveView(options.parentView);\n    if (parentView) { parentView.disconnectOutlet(options.outlet); }\n  }", "language": "javascript", "code": "function(options) {\n    if (!options || typeof options === \"string\") {\n      var outletName = options;\n      options = {};\n      options.outlet = outletName;\n    }\n    options.parentView = options.parentView ? options.parentView.replace(/\\//g, '.') : parentTemplate(this);\n    options.outlet = options.outlet || 'main';\n\n    var parentView = this.router._lookupActiveView(options.parentView);\n    if (parentView) { parentView.disconnectOutlet(options.outlet); }\n  }", "code_tokens": ["function", "(", "options", ")", "{", "if", "(", "!", "options", "||", "typeof", "options", "===", "\"string\"", ")", "{", "var", "outletName", "=", "options", ";", "options", "=", "{", "}", ";", "options", ".", "outlet", "=", "outletName", ";", "}", "options", ".", "parentView", "=", "options", ".", "parentView", "?", "options", ".", "parentView", ".", "replace", "(", "/", "\\/", "/", "g", ",", "'.'", ")", ":", "parentTemplate", "(", "this", ")", ";", "options", ".", "outlet", "=", "options", ".", "outlet", "||", "'main'", ";", "var", "parentView", "=", "this", ".", "router", ".", "_lookupActiveView", "(", "options", ".", "parentView", ")", ";", "if", "(", "parentView", ")", "{", "parentView", ".", "disconnectOutlet", "(", "options", ".", "outlet", ")", ";", "}", "}"], "docstring": "Disconnects a view that has been rendered into an outlet.\n\nYou may pass any or all of the following options to `disconnectOutlet`:\n\n`outlet`: the name of the outlet to clear (default: 'main')\n`parentView`: the name of the view containing the outlet to clear\n(default: the view rendered by the parent route)\n\nExample:\n\n```js\nApp.ApplicationRoute = App.Route.extend({\nactions: {\nshowModal: function(evt) {\nthis.render(evt.modalName, {\noutlet: 'modal',\ninto: 'application'\n});\n},\nhideModal: function(evt) {\nthis.disconnectOutlet({\noutlet: 'modal',\nparentView: 'application'\n});\n}\n}\n});\n```\n\nAlternatively, you can pass the `outlet` name directly as a string.\n\nExample:\n\n```js\nhideModal: function(evt) {\nthis.disconnectOutlet('modal');\n}\n```\n\n@method disconnectOutlet\n@param {Object|String} options the options hash or outlet name", "docstring_tokens": ["Disconnects", "a", "view", "that", "has", "been", "rendered", "into", "an", "outlet", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L37039-L37050", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(store, payload) {\n    payload = this.normalizePayload(null, payload);\n\n    for (var prop in payload) {\n      var typeName = this.typeForRoot(prop),\n          type = store.modelFor(typeName);\n\n      /*jshint loopfunc:true*/\n      var normalizedArray = map.call(Ember.makeArray(payload[prop]), function(hash) {\n        return this.normalize(type, hash, prop);\n      }, this);\n\n      store.pushMany(typeName, normalizedArray);\n    }\n  }", "language": "javascript", "code": "function(store, payload) {\n    payload = this.normalizePayload(null, payload);\n\n    for (var prop in payload) {\n      var typeName = this.typeForRoot(prop),\n          type = store.modelFor(typeName);\n\n      /*jshint loopfunc:true*/\n      var normalizedArray = map.call(Ember.makeArray(payload[prop]), function(hash) {\n        return this.normalize(type, hash, prop);\n      }, this);\n\n      store.pushMany(typeName, normalizedArray);\n    }\n  }", "code_tokens": ["function", "(", "store", ",", "payload", ")", "{", "payload", "=", "this", ".", "normalizePayload", "(", "null", ",", "payload", ")", ";", "for", "(", "var", "prop", "in", "payload", ")", "{", "var", "typeName", "=", "this", ".", "typeForRoot", "(", "prop", ")", ",", "type", "=", "store", ".", "modelFor", "(", "typeName", ")", ";", "/*jshint loopfunc:true*/", "var", "normalizedArray", "=", "map", ".", "call", "(", "Ember", ".", "makeArray", "(", "payload", "[", "prop", "]", ")", ",", "function", "(", "hash", ")", "{", "return", "this", ".", "normalize", "(", "type", ",", "hash", ",", "prop", ")", ";", "}", ",", "this", ")", ";", "store", ".", "pushMany", "(", "typeName", ",", "normalizedArray", ")", ";", "}", "}"], "docstring": "This method allows you to push a payload containing top-level\ncollections of records organized per type.\n\n```js\n{\n\"posts\": [{\n\"id\": \"1\",\n\"title\": \"Rails is omakase\",\n\"author\", \"1\",\n\"comments\": [ \"1\" ]\n}],\n\"comments\": [{\n\"id\": \"1\",\n\"body\": \"FIRST\"\n}],\n\"users\": [{\n\"id\": \"1\",\n\"name\": \"@d2h\"\n}]\n}\n```\n\nIt will first normalize the payload, so you can use this to push\nin data streaming in from your server structured the same way\nthat fetches and saves are structured.\n\n@method pushPayload\n@param {DS.Store} store\n@param {Object} payload", "docstring_tokens": ["This", "method", "allows", "you", "to", "push", "a", "payload", "containing", "top", "-", "level", "collections", "of", "records", "organized", "per", "type", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L8776-L8790", "partition": "test"}
{"repo": "rrrene/inchjs", "path": "lib/docs/retriever.js", "func_name": "getBowerJsonArgs", "original_string": "function getBowerJsonArgs() {\n  var results = [];\n  var config = _loadJson('bower.json');\n  if( config.main ) results = results.concat(getMainFieldAsArray(config.main));\n  return results.length == 0 ? null : results.filter(_uniqfilter);\n}", "language": "javascript", "code": "function getBowerJsonArgs() {\n  var results = [];\n  var config = _loadJson('bower.json');\n  if( config.main ) results = results.concat(getMainFieldAsArray(config.main));\n  return results.length == 0 ? null : results.filter(_uniqfilter);\n}", "code_tokens": ["function", "getBowerJsonArgs", "(", ")", "{", "var", "results", "=", "[", "]", ";", "var", "config", "=", "_loadJson", "(", "'bower.json'", ")", ";", "if", "(", "config", ".", "main", ")", "results", "=", "results", ".", "concat", "(", "getMainFieldAsArray", "(", "config", ".", "main", ")", ")", ";", "return", "results", ".", "length", "==", "0", "?", "null", ":", "results", ".", "filter", "(", "_uniqfilter", ")", ";", "}"], "docstring": "Checks bower.json for possible paths", "docstring_tokens": ["Checks", "bower", ".", "json", "for", "possible", "paths"], "sha": "453b4dac7a75707afc217fbacdea501179e0e5a4", "url": "https://github.com/rrrene/inchjs/blob/453b4dac7a75707afc217fbacdea501179e0e5a4/lib/docs/retriever.js#L51-L56", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "createWatchedFileSet", "original_string": "function createWatchedFileSet(interval, chunkSize) {\n                if (interval === void 0) { interval = 2500; }\n                if (chunkSize === void 0) { chunkSize = 30; }\n                var watchedFiles = [];\n                var nextFileToCheck = 0;\n                var watchTimer;\n                function getModifiedTime(fileName) {\n                    return _fs.statSync(fileName).mtime;\n                }\n                function poll(checkedIndex) {\n                    var watchedFile = watchedFiles[checkedIndex];\n                    if (!watchedFile) {\n                        return;\n                    }\n                    _fs.stat(watchedFile.fileName, function (err, stats) {\n                        if (err) {\n                            watchedFile.callback(watchedFile.fileName);\n                        }\n                        else if (watchedFile.mtime.getTime() !== stats.mtime.getTime()) {\n                            watchedFile.mtime = getModifiedTime(watchedFile.fileName);\n                            watchedFile.callback(watchedFile.fileName, watchedFile.mtime.getTime() === 0);\n                        }\n                    });\n                }\n                // this implementation uses polling and\n                // stat due to inconsistencies of fs.watch\n                // and efficiency of stat on modern filesystems\n                function startWatchTimer() {\n                    watchTimer = setInterval(function () {\n                        var count = 0;\n                        var nextToCheck = nextFileToCheck;\n                        var firstCheck = -1;\n                        while ((count < chunkSize) && (nextToCheck !== firstCheck)) {\n                            poll(nextToCheck);\n                            if (firstCheck < 0) {\n                                firstCheck = nextToCheck;\n                            }\n                            nextToCheck++;\n                            if (nextToCheck === watchedFiles.length) {\n                                nextToCheck = 0;\n                            }\n                            count++;\n                        }\n                        nextFileToCheck = nextToCheck;\n                    }, interval);\n                }\n                function addFile(fileName, callback) {\n                    var file = {\n                        fileName: fileName,\n                        callback: callback,\n                        mtime: getModifiedTime(fileName)\n                    };\n                    watchedFiles.push(file);\n                    if (watchedFiles.length === 1) {\n                        startWatchTimer();\n                    }\n                    return file;\n                }\n                function removeFile(file) {\n                    watchedFiles = ts.copyListRemovingItem(file, watchedFiles);\n                }\n                return {\n                    getModifiedTime: getModifiedTime,\n                    poll: poll,\n                    startWatchTimer: startWatchTimer,\n                    addFile: addFile,\n                    removeFile: removeFile\n                };\n            }", "language": "javascript", "code": "function createWatchedFileSet(interval, chunkSize) {\n                if (interval === void 0) { interval = 2500; }\n                if (chunkSize === void 0) { chunkSize = 30; }\n                var watchedFiles = [];\n                var nextFileToCheck = 0;\n                var watchTimer;\n                function getModifiedTime(fileName) {\n                    return _fs.statSync(fileName).mtime;\n                }\n                function poll(checkedIndex) {\n                    var watchedFile = watchedFiles[checkedIndex];\n                    if (!watchedFile) {\n                        return;\n                    }\n                    _fs.stat(watchedFile.fileName, function (err, stats) {\n                        if (err) {\n                            watchedFile.callback(watchedFile.fileName);\n                        }\n                        else if (watchedFile.mtime.getTime() !== stats.mtime.getTime()) {\n                            watchedFile.mtime = getModifiedTime(watchedFile.fileName);\n                            watchedFile.callback(watchedFile.fileName, watchedFile.mtime.getTime() === 0);\n                        }\n                    });\n                }\n                // this implementation uses polling and\n                // stat due to inconsistencies of fs.watch\n                // and efficiency of stat on modern filesystems\n                function startWatchTimer() {\n                    watchTimer = setInterval(function () {\n                        var count = 0;\n                        var nextToCheck = nextFileToCheck;\n                        var firstCheck = -1;\n                        while ((count < chunkSize) && (nextToCheck !== firstCheck)) {\n                            poll(nextToCheck);\n                            if (firstCheck < 0) {\n                                firstCheck = nextToCheck;\n                            }\n                            nextToCheck++;\n                            if (nextToCheck === watchedFiles.length) {\n                                nextToCheck = 0;\n                            }\n                            count++;\n                        }\n                        nextFileToCheck = nextToCheck;\n                    }, interval);\n                }\n                function addFile(fileName, callback) {\n                    var file = {\n                        fileName: fileName,\n                        callback: callback,\n                        mtime: getModifiedTime(fileName)\n                    };\n                    watchedFiles.push(file);\n                    if (watchedFiles.length === 1) {\n                        startWatchTimer();\n                    }\n                    return file;\n                }\n                function removeFile(file) {\n                    watchedFiles = ts.copyListRemovingItem(file, watchedFiles);\n                }\n                return {\n                    getModifiedTime: getModifiedTime,\n                    poll: poll,\n                    startWatchTimer: startWatchTimer,\n                    addFile: addFile,\n                    removeFile: removeFile\n                };\n            }", "code_tokens": ["function", "createWatchedFileSet", "(", "interval", ",", "chunkSize", ")", "{", "if", "(", "interval", "===", "void", "0", ")", "{", "interval", "=", "2500", ";", "}", "if", "(", "chunkSize", "===", "void", "0", ")", "{", "chunkSize", "=", "30", ";", "}", "var", "watchedFiles", "=", "[", "]", ";", "var", "nextFileToCheck", "=", "0", ";", "var", "watchTimer", ";", "function", "getModifiedTime", "(", "fileName", ")", "{", "return", "_fs", ".", "statSync", "(", "fileName", ")", ".", "mtime", ";", "}", "function", "poll", "(", "checkedIndex", ")", "{", "var", "watchedFile", "=", "watchedFiles", "[", "checkedIndex", "]", ";", "if", "(", "!", "watchedFile", ")", "{", "return", ";", "}", "_fs", ".", "stat", "(", "watchedFile", ".", "fileName", ",", "function", "(", "err", ",", "stats", ")", "{", "if", "(", "err", ")", "{", "watchedFile", ".", "callback", "(", "watchedFile", ".", "fileName", ")", ";", "}", "else", "if", "(", "watchedFile", ".", "mtime", ".", "getTime", "(", ")", "!==", "stats", ".", "mtime", ".", "getTime", "(", ")", ")", "{", "watchedFile", ".", "mtime", "=", "getModifiedTime", "(", "watchedFile", ".", "fileName", ")", ";", "watchedFile", ".", "callback", "(", "watchedFile", ".", "fileName", ",", "watchedFile", ".", "mtime", ".", "getTime", "(", ")", "===", "0", ")", ";", "}", "}", ")", ";", "}", "// this implementation uses polling and", "// stat due to inconsistencies of fs.watch", "// and efficiency of stat on modern filesystems", "function", "startWatchTimer", "(", ")", "{", "watchTimer", "=", "setInterval", "(", "function", "(", ")", "{", "var", "count", "=", "0", ";", "var", "nextToCheck", "=", "nextFileToCheck", ";", "var", "firstCheck", "=", "-", "1", ";", "while", "(", "(", "count", "<", "chunkSize", ")", "&&", "(", "nextToCheck", "!==", "firstCheck", ")", ")", "{", "poll", "(", "nextToCheck", ")", ";", "if", "(", "firstCheck", "<", "0", ")", "{", "firstCheck", "=", "nextToCheck", ";", "}", "nextToCheck", "++", ";", "if", "(", "nextToCheck", "===", "watchedFiles", ".", "length", ")", "{", "nextToCheck", "=", "0", ";", "}", "count", "++", ";", "}", "nextFileToCheck", "=", "nextToCheck", ";", "}", ",", "interval", ")", ";", "}", "function", "addFile", "(", "fileName", ",", "callback", ")", "{", "var", "file", "=", "{", "fileName", ":", "fileName", ",", "callback", ":", "callback", ",", "mtime", ":", "getModifiedTime", "(", "fileName", ")", "}", ";", "watchedFiles", ".", "push", "(", "file", ")", ";", "if", "(", "watchedFiles", ".", "length", "===", "1", ")", "{", "startWatchTimer", "(", ")", ";", "}", "return", "file", ";", "}", "function", "removeFile", "(", "file", ")", "{", "watchedFiles", "=", "ts", ".", "copyListRemovingItem", "(", "file", ",", "watchedFiles", ")", ";", "}", "return", "{", "getModifiedTime", ":", "getModifiedTime", ",", "poll", ":", "poll", ",", "startWatchTimer", ":", "startWatchTimer", ",", "addFile", ":", "addFile", ",", "removeFile", ":", "removeFile", "}", ";", "}"], "docstring": "average async stat takes about 30 microseconds set chunk size to do 30 files in < 1 millisecond", "docstring_tokens": ["average", "async", "stat", "takes", "about", "30", "microseconds", "set", "chunk", "size", "to", "do", "30", "files", "in", "<", "1", "millisecond"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L1774-L1842", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( type, item ) {\n\t\t\tvar id = _.isString( item ) || _.isNumber( item ) ? item : null;\n\n\t\t\tif ( id === null ) {\n\t\t\t\tif ( item instanceof Backbone.RelationalModel ) {\n\t\t\t\t\tid = item.id;\n\t\t\t\t}\n\t\t\t\telse if ( _.isObject( item ) ) {\n\t\t\t\t\tid = item[ type.prototype.idAttribute ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make all falsy values `null` (except for 0, which could be an id.. see '/issues/179')\n\t\t\tif ( !id && id !== 0 ) {\n\t\t\t\tid = null;\n\t\t\t}\n\n\t\t\treturn id;\n\t\t}", "language": "javascript", "code": "function( type, item ) {\n\t\t\tvar id = _.isString( item ) || _.isNumber( item ) ? item : null;\n\n\t\t\tif ( id === null ) {\n\t\t\t\tif ( item instanceof Backbone.RelationalModel ) {\n\t\t\t\t\tid = item.id;\n\t\t\t\t}\n\t\t\t\telse if ( _.isObject( item ) ) {\n\t\t\t\t\tid = item[ type.prototype.idAttribute ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make all falsy values `null` (except for 0, which could be an id.. see '/issues/179')\n\t\t\tif ( !id && id !== 0 ) {\n\t\t\t\tid = null;\n\t\t\t}\n\n\t\t\treturn id;\n\t\t}", "code_tokens": ["function", "(", "type", ",", "item", ")", "{", "var", "id", "=", "_", ".", "isString", "(", "item", ")", "||", "_", ".", "isNumber", "(", "item", ")", "?", "item", ":", "null", ";", "if", "(", "id", "===", "null", ")", "{", "if", "(", "item", "instanceof", "Backbone", ".", "RelationalModel", ")", "{", "id", "=", "item", ".", "id", ";", "}", "else", "if", "(", "_", ".", "isObject", "(", "item", ")", ")", "{", "id", "=", "item", "[", "type", ".", "prototype", ".", "idAttribute", "]", ";", "}", "}", "// Make all falsy values `null` (except for 0, which could be an id.. see '/issues/179')", "if", "(", "!", "id", "&&", "id", "!==", "0", ")", "{", "id", "=", "null", ";", "}", "return", "id", ";", "}"], "docstring": "Find the attribute that is to be used as the `id` on a given object\n@param type\n@param {String|Number|Object|Backbone.RelationalModel} item\n@return {String|Number}", "docstring_tokens": ["Find", "the", "attribute", "that", "is", "to", "be", "used", "as", "the", "id", "on", "a", "given", "object"], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L372-L390", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Utils.js", "func_name": "isJqueryObject", "original_string": "function isJqueryObject(oObj) {\n  var isJquery = false,\n    $ = getRoot().jQuery;\n  if ($) {\n    isJquery = isInstanceOf(oObj, $);\n  }\n  return isJquery;\n}", "language": "javascript", "code": "function isJqueryObject(oObj) {\n  var isJquery = false,\n    $ = getRoot().jQuery;\n  if ($) {\n    isJquery = isInstanceOf(oObj, $);\n  }\n  return isJquery;\n}", "code_tokens": ["function", "isJqueryObject", "(", "oObj", ")", "{", "var", "isJquery", "=", "false", ",", "$", "=", "getRoot", "(", ")", ".", "jQuery", ";", "if", "(", "$", ")", "{", "isJquery", "=", "isInstanceOf", "(", "oObj", ",", "$", ")", ";", "}", "return", "isJquery", ";", "}"], "docstring": "Use jQuery detection\n@param {Object} oObj\n@return {Boolean}\n@private", "docstring_tokens": ["Use", "jQuery", "detection"], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Utils.js#L16-L23", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( attributes, options ) {\n\t\t\toptions || ( options = {} );\n\t\t\toptions.create = false;\n\t\t\treturn this.findOrCreate( attributes, options );\n\t\t}", "language": "javascript", "code": "function( attributes, options ) {\n\t\t\toptions || ( options = {} );\n\t\t\toptions.create = false;\n\t\t\treturn this.findOrCreate( attributes, options );\n\t\t}", "code_tokens": ["function", "(", "attributes", ",", "options", ")", "{", "options", "||", "(", "options", "=", "{", "}", ")", ";", "options", ".", "create", "=", "false", ";", "return", "this", ".", "findOrCreate", "(", "attributes", ",", "options", ")", ";", "}"], "docstring": "Find an instance of `this` type in 'Backbone.Relational.store'.\n- If `attributes` is a string or a number, `find` will just query the `store` and return a model if found.\n- If `attributes` is an object and is found in the store, the model will be updated with `attributes` unless `options.update` is `false`.\n@param {Object|String|Number} attributes Either a model's id, or the attributes used to create or update a model.\n@param {Object} [options]\n@param {Boolean} [options.merge=true]\n@param {Boolean} [options.parse=false]\n@return {Backbone.RelationalModel}", "docstring_tokens": ["Find", "an", "instance", "of", "this", "type", "in", "Backbone", ".", "Relational", ".", "store", ".", "-", "If", "attributes", "is", "a", "string", "or", "a", "number", "find", "will", "just", "query", "the", "store", "and", "return", "a", "model", "if", "found", ".", "-", "If", "attributes", "is", "an", "object", "and", "is", "found", "in", "the", "store", "the", "model", "will", "be", "updated", "with", "attributes", "unless", "options", ".", "update", "is", "false", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L1728-L1732", "partition": "test"}
{"repo": "genify/toolkit2", "path": "lib/cache.js", "func_name": "", "original_string": "function(config){\n    var args = [].slice.call(arguments,0);\n    clearTemp(args.shift());\n    _logger.error.apply(_logger,args);\n    process.abort();\n}", "language": "javascript", "code": "function(config){\n    var args = [].slice.call(arguments,0);\n    clearTemp(args.shift());\n    _logger.error.apply(_logger,args);\n    process.abort();\n}", "code_tokens": ["function", "(", "config", ")", "{", "var", "args", "=", "[", "]", ".", "slice", ".", "call", "(", "arguments", ",", "0", ")", ";", "clearTemp", "(", "args", ".", "shift", "(", ")", ")", ";", "_logger", ".", "error", ".", "apply", "(", "_logger", ",", "args", ")", ";", "process", ".", "abort", "(", ")", ";", "}"], "docstring": "abort process when error\n@param  {Object} config - config object\n@return {Void}", "docstring_tokens": ["abort", "process", "when", "error"], "sha": "bb40480731f363327e055f7120d3fd6de6336cda", "url": "https://github.com/genify/toolkit2/blob/bb40480731f363327e055f7120d3fd6de6336cda/lib/cache.js#L174-L179", "partition": "test"}
{"repo": "StarryInternet/eslint-plugin-starry", "path": "lib/rules/space-in-parens.js", "func_name": "shouldOpenerRejectSpace", "original_string": "function shouldOpenerRejectSpace( left, right ) {\n      if ( right.type === 'Line' ) {\n        return false;\n      }\n\n      if ( !astUtils.isTokenOnSameLine( left, right ) ) {\n        return false;\n      }\n\n      if ( !sourceCode.isSpaceBetweenTokens( left, right ) ) {\n        return false;\n      }\n\n      if ( ALWAYS ) {\n        return isOpenerException( right );\n      }\n      return !isOpenerException( right );\n    }", "language": "javascript", "code": "function shouldOpenerRejectSpace( left, right ) {\n      if ( right.type === 'Line' ) {\n        return false;\n      }\n\n      if ( !astUtils.isTokenOnSameLine( left, right ) ) {\n        return false;\n      }\n\n      if ( !sourceCode.isSpaceBetweenTokens( left, right ) ) {\n        return false;\n      }\n\n      if ( ALWAYS ) {\n        return isOpenerException( right );\n      }\n      return !isOpenerException( right );\n    }", "code_tokens": ["function", "shouldOpenerRejectSpace", "(", "left", ",", "right", ")", "{", "if", "(", "right", ".", "type", "===", "'Line'", ")", "{", "return", "false", ";", "}", "if", "(", "!", "astUtils", ".", "isTokenOnSameLine", "(", "left", ",", "right", ")", ")", "{", "return", "false", ";", "}", "if", "(", "!", "sourceCode", ".", "isSpaceBetweenTokens", "(", "left", ",", "right", ")", ")", "{", "return", "false", ";", "}", "if", "(", "ALWAYS", ")", "{", "return", "isOpenerException", "(", "right", ")", ";", "}", "return", "!", "isOpenerException", "(", "right", ")", ";", "}"], "docstring": "Determines if an opener paren should not have an existing space after it\n@param {Object} left The paren token\n@param {Object} right The token after it\n@returns {boolean} True if the paren should reject the space", "docstring_tokens": ["Determines", "if", "an", "opener", "paren", "should", "not", "have", "an", "existing", "space", "after", "it"], "sha": "6b0a55c4d0263c549e88f80001b8cca417fca5ca", "url": "https://github.com/StarryInternet/eslint-plugin-starry/blob/6b0a55c4d0263c549e88f80001b8cca417fca5ca/lib/rules/space-in-parens.js#L170-L187", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      this._ensureViewIsIntact();\n      this._isRendering = true;\n      this.resetChildViewContainer();\n  \n      this.triggerMethod('before:render', this);\n  \n      this._renderTemplate();\n      this._renderChildren();\n  \n      this._isRendering = false;\n      this.isRendered = true;\n      this.triggerMethod('render', this);\n      return this;\n    }", "language": "javascript", "code": "function() {\n      this._ensureViewIsIntact();\n      this._isRendering = true;\n      this.resetChildViewContainer();\n  \n      this.triggerMethod('before:render', this);\n  \n      this._renderTemplate();\n      this._renderChildren();\n  \n      this._isRendering = false;\n      this.isRendered = true;\n      this.triggerMethod('render', this);\n      return this;\n    }", "code_tokens": ["function", "(", ")", "{", "this", ".", "_ensureViewIsIntact", "(", ")", ";", "this", ".", "_isRendering", "=", "true", ";", "this", ".", "resetChildViewContainer", "(", ")", ";", "this", ".", "triggerMethod", "(", "'before:render'", ",", "this", ")", ";", "this", ".", "_renderTemplate", "(", ")", ";", "this", ".", "_renderChildren", "(", ")", ";", "this", ".", "_isRendering", "=", "false", ";", "this", ".", "isRendered", "=", "true", ";", "this", ".", "triggerMethod", "(", "'render'", ",", "this", ")", ";", "return", "this", ";", "}"], "docstring": "Renders the model and the collection.", "docstring_tokens": ["Renders", "the", "model", "and", "the", "collection", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19014-L19028", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/hooks/HooksRunner.js", "func_name": "extractSheBangInterpreter", "original_string": "function extractSheBangInterpreter (fullpath) {\n    // this is a modern cluster size. no need to read less\n    const chunkSize = 4096;\n    const fileData = readChunk.sync(fullpath, 0, chunkSize);\n    const fileChunk = fileData.toString();\n    const hookCmd = shebangCommand(fileChunk);\n\n    if (hookCmd && fileData.length === chunkSize && !fileChunk.match(/[\\r\\n]/)) {\n        events.emit('warn', 'shebang is too long for \"' + fullpath + '\"');\n    }\n    return hookCmd;\n}", "language": "javascript", "code": "function extractSheBangInterpreter (fullpath) {\n    // this is a modern cluster size. no need to read less\n    const chunkSize = 4096;\n    const fileData = readChunk.sync(fullpath, 0, chunkSize);\n    const fileChunk = fileData.toString();\n    const hookCmd = shebangCommand(fileChunk);\n\n    if (hookCmd && fileData.length === chunkSize && !fileChunk.match(/[\\r\\n]/)) {\n        events.emit('warn', 'shebang is too long for \"' + fullpath + '\"');\n    }\n    return hookCmd;\n}", "code_tokens": ["function", "extractSheBangInterpreter", "(", "fullpath", ")", "{", "// this is a modern cluster size. no need to read less", "const", "chunkSize", "=", "4096", ";", "const", "fileData", "=", "readChunk", ".", "sync", "(", "fullpath", ",", "0", ",", "chunkSize", ")", ";", "const", "fileChunk", "=", "fileData", ".", "toString", "(", ")", ";", "const", "hookCmd", "=", "shebangCommand", "(", "fileChunk", ")", ";", "if", "(", "hookCmd", "&&", "fileData", ".", "length", "===", "chunkSize", "&&", "!", "fileChunk", ".", "match", "(", "/", "[\\r\\n]", "/", ")", ")", "{", "events", ".", "emit", "(", "'warn'", ",", "'shebang is too long for \"'", "+", "fullpath", "+", "'\"'", ")", ";", "}", "return", "hookCmd", ";", "}"], "docstring": "Extracts shebang interpreter from script' source.", "docstring_tokens": ["Extracts", "shebang", "interpreter", "from", "script", "source", "."], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/hooks/HooksRunner.js#L231-L242", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/elements/Label/LabelGroup.js", "func_name": "LabelGroup", "original_string": "function LabelGroup(props) {\n  const { children, circular, className, color, content, size, tag } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(tag, 'tag'),\n    'labels',\n    className,\n  )\n  const rest = getUnhandledProps(LabelGroup, props)\n  const ElementType = getElementType(LabelGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function LabelGroup(props) {\n  const { children, circular, className, color, content, size, tag } = props\n\n  const classes = cx(\n    'ui',\n    color,\n    size,\n    useKeyOnly(circular, 'circular'),\n    useKeyOnly(tag, 'tag'),\n    'labels',\n    className,\n  )\n  const rest = getUnhandledProps(LabelGroup, props)\n  const ElementType = getElementType(LabelGroup, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "LabelGroup", "(", "props", ")", "{", "const", "{", "children", ",", "circular", ",", "className", ",", "color", ",", "content", ",", "size", ",", "tag", "}", "=", "props", "const", "classes", "=", "cx", "(", "'ui'", ",", "color", ",", "size", ",", "useKeyOnly", "(", "circular", ",", "'circular'", ")", ",", "useKeyOnly", "(", "tag", ",", "'tag'", ")", ",", "'labels'", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "LabelGroup", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "LabelGroup", ",", "props", ")", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "childrenUtils", ".", "isNil", "(", "children", ")", "?", "content", ":", "children", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A label can be grouped.", "docstring_tokens": ["A", "label", "can", "be", "grouped", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Label/LabelGroup.js#L17-L37", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( model, collection, options ) {\n\t\t\tthis.stopListening( model );\n\t\t\tvar coll = this.getCollection( model );\n\t\t\tcoll && coll.remove( model, options );\n\t\t}", "language": "javascript", "code": "function( model, collection, options ) {\n\t\t\tthis.stopListening( model );\n\t\t\tvar coll = this.getCollection( model );\n\t\t\tcoll && coll.remove( model, options );\n\t\t}", "code_tokens": ["function", "(", "model", ",", "collection", ",", "options", ")", "{", "this", ".", "stopListening", "(", "model", ")", ";", "var", "coll", "=", "this", ".", "getCollection", "(", "model", ")", ";", "coll", "&&", "coll", ".", "remove", "(", "model", ",", "options", ")", ";", "}"], "docstring": "Remove a 'model' from the store.\n@param {Backbone.RelationalModel} model", "docstring_tokens": ["Remove", "a", "model", "from", "the", "store", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L465-L469", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n  \n      // Bind only after composite view is rendered to avoid adding child views\n      // to nonexistent childViewContainer\n  \n      if (this.collection) {\n        this.listenTo(this.collection, 'add', this._onCollectionAdd);\n        this.listenTo(this.collection, 'remove', this._onCollectionRemove);\n        this.listenTo(this.collection, 'reset', this._renderChildren);\n  \n        if (this.getOption('sort')) {\n          this.listenTo(this.collection, 'sort', this._sortViews);\n        }\n      }\n    }", "language": "javascript", "code": "function() {\n  \n      // Bind only after composite view is rendered to avoid adding child views\n      // to nonexistent childViewContainer\n  \n      if (this.collection) {\n        this.listenTo(this.collection, 'add', this._onCollectionAdd);\n        this.listenTo(this.collection, 'remove', this._onCollectionRemove);\n        this.listenTo(this.collection, 'reset', this._renderChildren);\n  \n        if (this.getOption('sort')) {\n          this.listenTo(this.collection, 'sort', this._sortViews);\n        }\n      }\n    }", "code_tokens": ["function", "(", ")", "{", "// Bind only after composite view is rendered to avoid adding child views", "// to nonexistent childViewContainer", "if", "(", "this", ".", "collection", ")", "{", "this", ".", "listenTo", "(", "this", ".", "collection", ",", "'add'", ",", "this", ".", "_onCollectionAdd", ")", ";", "this", ".", "listenTo", "(", "this", ".", "collection", ",", "'remove'", ",", "this", ".", "_onCollectionRemove", ")", ";", "this", ".", "listenTo", "(", "this", ".", "collection", ",", "'reset'", ",", "this", ".", "_renderChildren", ")", ";", "if", "(", "this", ".", "getOption", "(", "'sort'", ")", ")", "{", "this", ".", "listenTo", "(", "this", ".", "collection", ",", "'sort'", ",", "this", ".", "_sortViews", ")", ";", "}", "}", "}"], "docstring": "Configured the initial events that the composite view binds to. Override this method to prevent the initial events, or to add your own initial events.", "docstring_tokens": ["Configured", "the", "initial", "events", "that", "the", "composite", "view", "binds", "to", ".", "Override", "this", "method", "to", "prevent", "the", "initial", "events", "or", "to", "add", "your", "own", "initial", "events", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18974-L18988", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/change.js", "func_name": "setChange", "original_string": "function setChange(repoState, filepath, change) {\n    let workingState = repoState.getCurrentState();\n    let changes = workingState.getChanges();\n    const type = change.getType();\n\n    // Simplify change when possible\n    if (type === CHANGE_TYPE.REMOVE\n        && !workingState.getTreeEntries().has(filepath)) {\n        // Removing a file that did not exist before\n        changes = changes.delete(filepath);\n\n    } else if (type === CHANGE_TYPE.CREATE\n               && workingState.getTreeEntries().has(filepath)) {\n        // Adding back a file that existed already\n        changes = changes.set(filepath, change.set('type', CHANGE_TYPE.UPDATE));\n\n    } else {\n        // Push changes to list\n        changes = changes.set(filepath, change);\n    }\n\n    // Update workingState and repoState\n    workingState = workingState.set('changes', changes);\n    return RepoUtils.updateCurrentWorkingState(repoState, workingState);\n}", "language": "javascript", "code": "function setChange(repoState, filepath, change) {\n    let workingState = repoState.getCurrentState();\n    let changes = workingState.getChanges();\n    const type = change.getType();\n\n    // Simplify change when possible\n    if (type === CHANGE_TYPE.REMOVE\n        && !workingState.getTreeEntries().has(filepath)) {\n        // Removing a file that did not exist before\n        changes = changes.delete(filepath);\n\n    } else if (type === CHANGE_TYPE.CREATE\n               && workingState.getTreeEntries().has(filepath)) {\n        // Adding back a file that existed already\n        changes = changes.set(filepath, change.set('type', CHANGE_TYPE.UPDATE));\n\n    } else {\n        // Push changes to list\n        changes = changes.set(filepath, change);\n    }\n\n    // Update workingState and repoState\n    workingState = workingState.set('changes', changes);\n    return RepoUtils.updateCurrentWorkingState(repoState, workingState);\n}", "code_tokens": ["function", "setChange", "(", "repoState", ",", "filepath", ",", "change", ")", "{", "let", "workingState", "=", "repoState", ".", "getCurrentState", "(", ")", ";", "let", "changes", "=", "workingState", ".", "getChanges", "(", ")", ";", "const", "type", "=", "change", ".", "getType", "(", ")", ";", "// Simplify change when possible", "if", "(", "type", "===", "CHANGE_TYPE", ".", "REMOVE", "&&", "!", "workingState", ".", "getTreeEntries", "(", ")", ".", "has", "(", "filepath", ")", ")", "{", "// Removing a file that did not exist before", "changes", "=", "changes", ".", "delete", "(", "filepath", ")", ";", "}", "else", "if", "(", "type", "===", "CHANGE_TYPE", ".", "CREATE", "&&", "workingState", ".", "getTreeEntries", "(", ")", ".", "has", "(", "filepath", ")", ")", "{", "// Adding back a file that existed already", "changes", "=", "changes", ".", "set", "(", "filepath", ",", "change", ".", "set", "(", "'type'", ",", "CHANGE_TYPE", ".", "UPDATE", ")", ")", ";", "}", "else", "{", "// Push changes to list", "changes", "=", "changes", ".", "set", "(", "filepath", ",", "change", ")", ";", "}", "// Update workingState and repoState", "workingState", "=", "workingState", ".", "set", "(", "'changes'", ",", "changes", ")", ";", "return", "RepoUtils", ".", "updateCurrentWorkingState", "(", "repoState", ",", "workingState", ")", ";", "}"], "docstring": "Set a new change to the current WorkingState.\nAttempt to resolve some cases like removing a file that was added\nin the first place.\n@param {RepositoryState}\n@param {String}\n@param {Change}", "docstring_tokens": ["Set", "a", "new", "change", "to", "the", "current", "WorkingState", ".", "Attempt", "to", "resolve", "some", "cases", "like", "removing", "a", "file", "that", "was", "added", "in", "the", "first", "place", "."], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/change.js#L26-L50", "partition": "test"}
{"repo": "ctr-lang/ctr", "path": "lib/ctr-nodes/index.js", "func_name": "", "original_string": "function (val, key) {\n        const optVal = _M._option.getIn(key);\n        //check for init key match\n        if (optVal !== null) {\n          if (_.isObject(optVal)) {\n            //merge in option to the defaults\n            _M._option.mergeIn(key, _.defaultsDeep(val, _M._option.getIn(key)));\n          }else {\n            //merge in option to the defaults\n            _M._option.mergeIn(key, val);\n          }\n        }\n      }", "language": "javascript", "code": "function (val, key) {\n        const optVal = _M._option.getIn(key);\n        //check for init key match\n        if (optVal !== null) {\n          if (_.isObject(optVal)) {\n            //merge in option to the defaults\n            _M._option.mergeIn(key, _.defaultsDeep(val, _M._option.getIn(key)));\n          }else {\n            //merge in option to the defaults\n            _M._option.mergeIn(key, val);\n          }\n        }\n      }", "code_tokens": ["function", "(", "val", ",", "key", ")", "{", "const", "optVal", "=", "_M", ".", "_option", ".", "getIn", "(", "key", ")", ";", "//check for init key match", "if", "(", "optVal", "!==", "null", ")", "{", "if", "(", "_", ".", "isObject", "(", "optVal", ")", ")", "{", "//merge in option to the defaults", "_M", ".", "_option", ".", "mergeIn", "(", "key", ",", "_", ".", "defaultsDeep", "(", "val", ",", "_M", ".", "_option", ".", "getIn", "(", "key", ")", ")", ")", ";", "}", "else", "{", "//merge in option to the defaults", "_M", ".", "_option", ".", "mergeIn", "(", "key", ",", "val", ")", ";", "}", "}", "}"], "docstring": "wrapper for bellow each loop", "docstring_tokens": ["wrapper", "for", "bellow", "each", "loop"], "sha": "f73465cb7420bcc4f18a892a37529b3b366fb08a", "url": "https://github.com/ctr-lang/ctr/blob/f73465cb7420bcc4f18a892a37529b3b366fb08a/lib/ctr-nodes/index.js#L78-L90", "partition": "test"}
{"repo": "thgh/rollup-plugin-vue2", "path": "src/index.js", "func_name": "injectTemplate", "original_string": "function injectTemplate (s, node, offset, id) {\n  const t = node.src ? readSrc(id, node.src) : node.content\n\n  // Compile template\n  const compiled = compiler.compile(t)\n  const renderFuncs = '\\nrender: ' + toFunction(compiled.render) + ',' +\n    '\\nstaticRenderFns: [' + compiled.staticRenderFns.map(toFunction).join(',') + '],'\n  s.appendLeft(offset, renderFuncs)\n  return renderFuncs\n}", "language": "javascript", "code": "function injectTemplate (s, node, offset, id) {\n  const t = node.src ? readSrc(id, node.src) : node.content\n\n  // Compile template\n  const compiled = compiler.compile(t)\n  const renderFuncs = '\\nrender: ' + toFunction(compiled.render) + ',' +\n    '\\nstaticRenderFns: [' + compiled.staticRenderFns.map(toFunction).join(',') + '],'\n  s.appendLeft(offset, renderFuncs)\n  return renderFuncs\n}", "code_tokens": ["function", "injectTemplate", "(", "s", ",", "node", ",", "offset", ",", "id", ")", "{", "const", "t", "=", "node", ".", "src", "?", "readSrc", "(", "id", ",", "node", ".", "src", ")", ":", "node", ".", "content", "// Compile template", "const", "compiled", "=", "compiler", ".", "compile", "(", "t", ")", "const", "renderFuncs", "=", "'\\nrender: '", "+", "toFunction", "(", "compiled", ".", "render", ")", "+", "','", "+", "'\\nstaticRenderFns: ['", "+", "compiled", ".", "staticRenderFns", ".", "map", "(", "toFunction", ")", ".", "join", "(", "','", ")", "+", "'],'", "s", ".", "appendLeft", "(", "offset", ",", "renderFuncs", ")", "return", "renderFuncs", "}"], "docstring": "Only support for es5 modules\n\n@param script\n@param template\n@returns {string}", "docstring_tokens": ["Only", "support", "for", "es5", "modules"], "sha": "eb767be8e4b20acb19ad299332898c35f8512da7", "url": "https://github.com/thgh/rollup-plugin-vue2/blob/eb767be8e4b20acb19ad299332898c35f8512da7/src/index.js#L132-L141", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(path) {\n    var state = { path: path };\n\n    get(this, 'history').replaceState(state, null, path);\n\n    // store state if browser doesn't support `history.state`\n    if (!supportsHistoryState) {\n      this._historyState = state;\n    }\n\n    // used for webkit workaround\n    this._previousURL = this.getURL();\n  }", "language": "javascript", "code": "function(path) {\n    var state = { path: path };\n\n    get(this, 'history').replaceState(state, null, path);\n\n    // store state if browser doesn't support `history.state`\n    if (!supportsHistoryState) {\n      this._historyState = state;\n    }\n\n    // used for webkit workaround\n    this._previousURL = this.getURL();\n  }", "code_tokens": ["function", "(", "path", ")", "{", "var", "state", "=", "{", "path", ":", "path", "}", ";", "get", "(", "this", ",", "'history'", ")", ".", "replaceState", "(", "state", ",", "null", ",", "path", ")", ";", "// store state if browser doesn't support `history.state`", "if", "(", "!", "supportsHistoryState", ")", "{", "this", ".", "_historyState", "=", "state", ";", "}", "// used for webkit workaround", "this", ".", "_previousURL", "=", "this", ".", "getURL", "(", ")", ";", "}"], "docstring": "Replaces the current state.\n\n@private\n@method replaceState\n@param path {String}", "docstring_tokens": ["Replaces", "the", "current", "state", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L39647-L39659", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "lib/reflect.js", "func_name": "normalizePropertyDescriptor", "original_string": "function normalizePropertyDescriptor(attributes) {\n  var desc = toPropertyDescriptor(attributes);\n  // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}", "language": "javascript", "code": "function normalizePropertyDescriptor(attributes) {\n  var desc = toPropertyDescriptor(attributes);\n  // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}", "code_tokens": ["function", "normalizePropertyDescriptor", "(", "attributes", ")", "{", "var", "desc", "=", "toPropertyDescriptor", "(", "attributes", ")", ";", "// Note: no need to call FromGenericPropertyDescriptor(desc), as we represent", "// \"internal\" property descriptors as proper Objects from the start", "for", "(", "var", "name", "in", "attributes", ")", "{", "if", "(", "!", "isStandardAttribute", "(", "name", ")", ")", "{", "Object", ".", "defineProperty", "(", "desc", ",", "name", ",", "{", "value", ":", "attributes", "[", "name", "]", ",", "writable", ":", "true", ",", "enumerable", ":", "true", ",", "configurable", ":", "true", "}", ")", ";", "}", "}", "return", "desc", ";", "}"], "docstring": "Returns a fresh property descriptor whose standard\nattributes are guaranteed to be data properties of the right type.\nAdditionally, any non-standard enumerable properties of\nattributes are copied over to the fresh descriptor.\n\nIf attributes is undefined, will throw a TypeError.\n\nSee also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics", "docstring_tokens": ["Returns", "a", "fresh", "property", "descriptor", "whose", "standard", "attributes", "are", "guaranteed", "to", "be", "data", "properties", "of", "the", "right", "type", ".", "Additionally", "any", "non", "-", "standard", "enumerable", "properties", "of", "attributes", "are", "copied", "over", "to", "the", "fresh", "descriptor", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/lib/reflect.js#L325-L339", "partition": "test"}
{"repo": "impaler/ide-template", "path": "util.js", "func_name": "", "original_string": "function (source, destination)\n    {\n      if (!fs.existsSync(destination))\n        mkdir('-p', destination);\n\n      cp('-R', source, destination);\n    }", "language": "javascript", "code": "function (source, destination)\n    {\n      if (!fs.existsSync(destination))\n        mkdir('-p', destination);\n\n      cp('-R', source, destination);\n    }", "code_tokens": ["function", "(", "source", ",", "destination", ")", "{", "if", "(", "!", "fs", ".", "existsSync", "(", "destination", ")", ")", "mkdir", "(", "'-p'", ",", "destination", ")", ";", "cp", "(", "'-R'", ",", "source", ",", "destination", ")", ";", "}"], "docstring": "Shortcut for copying a folder and it's contents recursively to a given destination,\nif the source does not exist, it will do nothing.\n@param source\n@param destination", "docstring_tokens": ["Shortcut", "for", "copying", "a", "folder", "and", "it", "s", "contents", "recursively", "to", "a", "given", "destination", "if", "the", "source", "does", "not", "exist", "it", "will", "do", "nothing", "."], "sha": "d9a9822786075cc0b0de788d8aa4ab2045bf2210", "url": "https://github.com/impaler/ide-template/blob/d9a9822786075cc0b0de788d8aa4ab2045bf2210/util.js#L116-L122", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/field/Select.js", "func_name": "", "original_string": "function() {\n        var me = this,\n            record;\n\n        if (me.getAutoSelect()) {\n            var store = me.getStore();\n\n            record = (me.originalValue) ? me.originalValue : store.getAt(0);\n        } else {\n            var usePicker = me.getUsePicker(),\n                picker = usePicker ? me.picker : me.listPanel;\n\n            if (picker) {\n                picker = picker.child(usePicker ? 'pickerslot' : 'dataview');\n\n                picker.deselectAll();\n            }\n\n            record = null;\n        }\n\n        me.setValue(record);\n\n        return me;\n    }", "language": "javascript", "code": "function() {\n        var me = this,\n            record;\n\n        if (me.getAutoSelect()) {\n            var store = me.getStore();\n\n            record = (me.originalValue) ? me.originalValue : store.getAt(0);\n        } else {\n            var usePicker = me.getUsePicker(),\n                picker = usePicker ? me.picker : me.listPanel;\n\n            if (picker) {\n                picker = picker.child(usePicker ? 'pickerslot' : 'dataview');\n\n                picker.deselectAll();\n            }\n\n            record = null;\n        }\n\n        me.setValue(record);\n\n        return me;\n    }", "code_tokens": ["function", "(", ")", "{", "var", "me", "=", "this", ",", "record", ";", "if", "(", "me", ".", "getAutoSelect", "(", ")", ")", "{", "var", "store", "=", "me", ".", "getStore", "(", ")", ";", "record", "=", "(", "me", ".", "originalValue", ")", "?", "me", ".", "originalValue", ":", "store", ".", "getAt", "(", "0", ")", ";", "}", "else", "{", "var", "usePicker", "=", "me", ".", "getUsePicker", "(", ")", ",", "picker", "=", "usePicker", "?", "me", ".", "picker", ":", "me", ".", "listPanel", ";", "if", "(", "picker", ")", "{", "picker", "=", "picker", ".", "child", "(", "usePicker", "?", "'pickerslot'", ":", "'dataview'", ")", ";", "picker", ".", "deselectAll", "(", ")", ";", "}", "record", "=", "null", ";", "}", "me", ".", "setValue", "(", "record", ")", ";", "return", "me", ";", "}"], "docstring": "Resets the Select field to the value of the first record in the store.\n@return {Ext.field.Select} this\n@chainable", "docstring_tokens": ["Resets", "the", "Select", "field", "to", "the", "value", "of", "the", "first", "record", "in", "the", "store", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/field/Select.js#L609-L633", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( type, create ) {\n\t\t\tif ( type instanceof Backbone.RelationalModel ) {\n\t\t\t\ttype = type.constructor;\n\t\t\t}\n\n\t\t\tvar rootModel = type;\n\t\t\twhile ( rootModel._superModel ) {\n\t\t\t\trootModel = rootModel._superModel;\n\t\t\t}\n\n\t\t\tvar coll = _.find( this._collections, function(item) {\n\t\t\t  return item.model === rootModel;\n\t\t\t});\n\n\t\t\tif ( !coll && create !== false ) {\n\t\t\t\tcoll = this._createCollection( rootModel );\n\t\t\t}\n\n\t\t\treturn coll;\n\t\t}", "language": "javascript", "code": "function( type, create ) {\n\t\t\tif ( type instanceof Backbone.RelationalModel ) {\n\t\t\t\ttype = type.constructor;\n\t\t\t}\n\n\t\t\tvar rootModel = type;\n\t\t\twhile ( rootModel._superModel ) {\n\t\t\t\trootModel = rootModel._superModel;\n\t\t\t}\n\n\t\t\tvar coll = _.find( this._collections, function(item) {\n\t\t\t  return item.model === rootModel;\n\t\t\t});\n\n\t\t\tif ( !coll && create !== false ) {\n\t\t\t\tcoll = this._createCollection( rootModel );\n\t\t\t}\n\n\t\t\treturn coll;\n\t\t}", "code_tokens": ["function", "(", "type", ",", "create", ")", "{", "if", "(", "type", "instanceof", "Backbone", ".", "RelationalModel", ")", "{", "type", "=", "type", ".", "constructor", ";", "}", "var", "rootModel", "=", "type", ";", "while", "(", "rootModel", ".", "_superModel", ")", "{", "rootModel", "=", "rootModel", ".", "_superModel", ";", "}", "var", "coll", "=", "_", ".", "find", "(", "this", ".", "_collections", ",", "function", "(", "item", ")", "{", "return", "item", ".", "model", "===", "rootModel", ";", "}", ")", ";", "if", "(", "!", "coll", "&&", "create", "!==", "false", ")", "{", "coll", "=", "this", ".", "_createCollection", "(", "rootModel", ")", ";", "}", "return", "coll", ";", "}"], "docstring": "Find the Store's collection for a certain type of model.\n@param {Backbone.RelationalModel} type\n@param {Boolean} [create=true] Should a collection be created if none is found?\n@return {Backbone.Collection} A collection if found (or applicable for 'model'), or null", "docstring_tokens": ["Find", "the", "Store", "s", "collection", "for", "a", "certain", "type", "of", "model", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L304-L323", "partition": "test"}
{"repo": "alexiusacademia/electron-db", "path": "index.js", "func_name": "insertTableContent", "original_string": "function insertTableContent() {\n    let tableName = arguments[0];\n    var fname = '';\n    var callback;\n    var tableRow;\n    if (arguments.length === 3) {\n        callback = arguments[2];\n        fname = path.join(userData, arguments[0] + '.json');\n        tableRow = arguments[1];\n    } else if (arguments.length === 4) {\n        fname = path.join(arguments[1], arguments[0] + '.json');\n        callback = arguments[3];\n        tableRow = arguments[2];\n    }\n\n    let exists = fs.existsSync(fname);\n\n    if (exists) {\n        // Table | json parsed\n        let table = JSON.parse(fs.readFileSync(fname));\n\n        let date = new Date();\n        let id = date.getTime();\n        tableRow['id'] = id;\n\n        table[tableName].push(tableRow);\n\n        try {\n            fs.writeFileSync(fname, JSON.stringify(table, null, 2), (err) => {\n\n            })\n\n            callback(true, \"Object written successfully!\");\n            return;\n        } catch (e) {\n            callback(false, \"Error writing object.\");\n            return;\n        }\n    }\n    callback(false, \"Table/json file doesn't exist!\");\n    return;\n}", "language": "javascript", "code": "function insertTableContent() {\n    let tableName = arguments[0];\n    var fname = '';\n    var callback;\n    var tableRow;\n    if (arguments.length === 3) {\n        callback = arguments[2];\n        fname = path.join(userData, arguments[0] + '.json');\n        tableRow = arguments[1];\n    } else if (arguments.length === 4) {\n        fname = path.join(arguments[1], arguments[0] + '.json');\n        callback = arguments[3];\n        tableRow = arguments[2];\n    }\n\n    let exists = fs.existsSync(fname);\n\n    if (exists) {\n        // Table | json parsed\n        let table = JSON.parse(fs.readFileSync(fname));\n\n        let date = new Date();\n        let id = date.getTime();\n        tableRow['id'] = id;\n\n        table[tableName].push(tableRow);\n\n        try {\n            fs.writeFileSync(fname, JSON.stringify(table, null, 2), (err) => {\n\n            })\n\n            callback(true, \"Object written successfully!\");\n            return;\n        } catch (e) {\n            callback(false, \"Error writing object.\");\n            return;\n        }\n    }\n    callback(false, \"Table/json file doesn't exist!\");\n    return;\n}", "code_tokens": ["function", "insertTableContent", "(", ")", "{", "let", "tableName", "=", "arguments", "[", "0", "]", ";", "var", "fname", "=", "''", ";", "var", "callback", ";", "var", "tableRow", ";", "if", "(", "arguments", ".", "length", "===", "3", ")", "{", "callback", "=", "arguments", "[", "2", "]", ";", "fname", "=", "path", ".", "join", "(", "userData", ",", "arguments", "[", "0", "]", "+", "'.json'", ")", ";", "tableRow", "=", "arguments", "[", "1", "]", ";", "}", "else", "if", "(", "arguments", ".", "length", "===", "4", ")", "{", "fname", "=", "path", ".", "join", "(", "arguments", "[", "1", "]", ",", "arguments", "[", "0", "]", "+", "'.json'", ")", ";", "callback", "=", "arguments", "[", "3", "]", ";", "tableRow", "=", "arguments", "[", "2", "]", ";", "}", "let", "exists", "=", "fs", ".", "existsSync", "(", "fname", ")", ";", "if", "(", "exists", ")", "{", "// Table | json parsed", "let", "table", "=", "JSON", ".", "parse", "(", "fs", ".", "readFileSync", "(", "fname", ")", ")", ";", "let", "date", "=", "new", "Date", "(", ")", ";", "let", "id", "=", "date", ".", "getTime", "(", ")", ";", "tableRow", "[", "'id'", "]", "=", "id", ";", "table", "[", "tableName", "]", ".", "push", "(", "tableRow", ")", ";", "try", "{", "fs", ".", "writeFileSync", "(", "fname", ",", "JSON", ".", "stringify", "(", "table", ",", "null", ",", "2", ")", ",", "(", "err", ")", "=>", "{", "}", ")", "callback", "(", "true", ",", "\"Object written successfully!\"", ")", ";", "return", ";", "}", "catch", "(", "e", ")", "{", "callback", "(", "false", ",", "\"Error writing object.\"", ")", ";", "return", ";", "}", "}", "callback", "(", "false", ",", "\"Table/json file doesn't exist!\"", ")", ";", "return", ";", "}"], "docstring": "Insert object to table. The object will be appended with the property, id\nwhich uses timestamp as value.\nThere are 3 required arguments.\n@param  {string} arguments[0]  [Table name]\n@param  {string} arguments[1] [Location of the database file] (Optional)\n@param  {string} arguments[2] [Row object]\n@param  {Function} arguments[3] [Callback function]\n function insertTableContent(tableName, tableRow, callback) {", "docstring_tokens": ["Insert", "object", "to", "table", ".", "The", "object", "will", "be", "appended", "with", "the", "property", "id", "which", "uses", "timestamp", "as", "value", ".", "There", "are", "3", "required", "arguments", "."], "sha": "630ac39969e27d68bd85eb048f99e0d2b64fd67b", "url": "https://github.com/alexiusacademia/electron-db/blob/630ac39969e27d68bd85eb048f99e0d2b64fd67b/index.js#L113-L154", "partition": "test"}
{"repo": "mongodb-js/mongodb-extjson", "path": "lib/ext_json.js", "func_name": "stringify", "original_string": "function stringify(value, replacer, space, options) {\n  if (space != null && typeof space === 'object') (options = space), (space = 0);\n  if (replacer != null && typeof replacer === 'object')\n    (options = replacer), (replacer = null), (space = 0);\n  options = Object.assign({}, { relaxed: true }, options);\n\n  const doc = Array.isArray(value)\n    ? serializeArray(value, options)\n    : serializeDocument(value, options);\n\n  return JSON.stringify(doc, replacer, space);\n}", "language": "javascript", "code": "function stringify(value, replacer, space, options) {\n  if (space != null && typeof space === 'object') (options = space), (space = 0);\n  if (replacer != null && typeof replacer === 'object')\n    (options = replacer), (replacer = null), (space = 0);\n  options = Object.assign({}, { relaxed: true }, options);\n\n  const doc = Array.isArray(value)\n    ? serializeArray(value, options)\n    : serializeDocument(value, options);\n\n  return JSON.stringify(doc, replacer, space);\n}", "code_tokens": ["function", "stringify", "(", "value", ",", "replacer", ",", "space", ",", "options", ")", "{", "if", "(", "space", "!=", "null", "&&", "typeof", "space", "===", "'object'", ")", "(", "options", "=", "space", ")", ",", "(", "space", "=", "0", ")", ";", "if", "(", "replacer", "!=", "null", "&&", "typeof", "replacer", "===", "'object'", ")", "(", "options", "=", "replacer", ")", ",", "(", "replacer", "=", "null", ")", ",", "(", "space", "=", "0", ")", ";", "options", "=", "Object", ".", "assign", "(", "{", "}", ",", "{", "relaxed", ":", "true", "}", ",", "options", ")", ";", "const", "doc", "=", "Array", ".", "isArray", "(", "value", ")", "?", "serializeArray", "(", "value", ",", "options", ")", ":", "serializeDocument", "(", "value", ",", "options", ")", ";", "return", "JSON", ".", "stringify", "(", "doc", ",", "replacer", ",", "space", ")", ";", "}"], "docstring": "Converts a BSON document to an Extended JSON string, optionally replacing values if a replacer\nfunction is specified or optionally including only the specified properties if a replacer array\nis specified.\n\n@param {object} value The value to convert to extended JSON\n@param {function|array} [replacer] A function that alters the behavior of the stringification process, or an array of String and Number objects that serve as a whitelist for selecting/filtering the properties of the value object to be included in the JSON string. If this value is null or not provided, all properties of the object are included in the resulting JSON string\n@param {string|number} [space] A String or Number object that's used to insert white space into the output JSON string for readability purposes.\n@param {object} [options] Optional settings\n@param {boolean} [options.relaxed=true] Enabled Extended JSON's `relaxed` mode\n@returns {string}\n\n@example\nconst EJSON = require('mongodb-extjson');\nconst Int32 = require('mongodb').Int32;\nconst doc = { int32: new Int32(10) };\n\n// prints '{\"int32\":{\"$numberInt\":\"10\"}}'\nconsole.log(EJSON.stringify(doc, { relaxed: false }));\n\n// prints '{\"int32\":10}'\nconsole.log(EJSON.stringify(doc));", "docstring_tokens": ["Converts", "a", "BSON", "document", "to", "an", "Extended", "JSON", "string", "optionally", "replacing", "values", "if", "a", "replacer", "function", "is", "specified", "or", "optionally", "including", "only", "the", "specified", "properties", "if", "a", "replacer", "array", "is", "specified", "."], "sha": "d60c810266dcaa31e124a87a7224567c8330ea62", "url": "https://github.com/mongodb-js/mongodb-extjson/blob/d60c810266dcaa31e124a87a7224567c8330ea62/lib/ext_json.js#L174-L185", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "isExcludeRefined", "original_string": "function isExcludeRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    return RefinementList.isRefined(this.facetsExcludes, facet, value);\n  }", "language": "javascript", "code": "function isExcludeRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    return RefinementList.isRefined(this.facetsExcludes, facet, value);\n  }", "code_tokens": ["function", "isExcludeRefined", "(", "facet", ",", "value", ")", "{", "if", "(", "!", "this", ".", "isConjunctiveFacet", "(", "facet", ")", ")", "{", "throw", "new", "Error", "(", "facet", "+", "' is not defined in the facets attribute of the helper configuration'", ")", ";", "}", "return", "RefinementList", ".", "isRefined", "(", "this", ".", "facetsExcludes", ",", "facet", ",", "value", ")", ";", "}"], "docstring": "Returns true if the facet contains exclusions or if a specific value is\nexcluded.\n\n@method\n@param {string} facet name of the attribute for used for faceting\n@param {string} [value] optional value. If passed will test that this value\nis filtering the given facet.\n@return {boolean} returns true if refined", "docstring_tokens": ["Returns", "true", "if", "the", "facet", "contains", "exclusions", "or", "if", "a", "specific", "value", "is", "excluded", "."], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L1399-L1404", "partition": "test"}
{"repo": "blinkylights23/grunt-swigtemplates", "path": "tasks/swigtemplates.js", "func_name": "handleFiles", "original_string": "function handleFiles(files) {\n      files.forEach(function(f) {\n        f.src.filter(srcExists).map(function(filepath) {\n          var pathInfo = getPathInfo(filepath, f.dest),\n              context = getContext(f.context, pathInfo);\n          renderFile(pathInfo.outfile, filepath, context);\n        });\n      });\n    }", "language": "javascript", "code": "function handleFiles(files) {\n      files.forEach(function(f) {\n        f.src.filter(srcExists).map(function(filepath) {\n          var pathInfo = getPathInfo(filepath, f.dest),\n              context = getContext(f.context, pathInfo);\n          renderFile(pathInfo.outfile, filepath, context);\n        });\n      });\n    }", "code_tokens": ["function", "handleFiles", "(", "files", ")", "{", "files", ".", "forEach", "(", "function", "(", "f", ")", "{", "f", ".", "src", ".", "filter", "(", "srcExists", ")", ".", "map", "(", "function", "(", "filepath", ")", "{", "var", "pathInfo", "=", "getPathInfo", "(", "filepath", ",", "f", ".", "dest", ")", ",", "context", "=", "getContext", "(", "f", ".", "context", ",", "pathInfo", ")", ";", "renderFile", "(", "pathInfo", ".", "outfile", ",", "filepath", ",", "context", ")", ";", "}", ")", ";", "}", ")", ";", "}"], "docstring": "Handle non-i18n files", "docstring_tokens": ["Handle", "non", "-", "i18n", "files"], "sha": "3a0d19f45aae7dc35efe3b5a08376be629498b7c", "url": "https://github.com/blinkylights23/grunt-swigtemplates/blob/3a0d19f45aae7dc35efe3b5a08376be629498b7c/tasks/swigtemplates.js#L81-L89", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "convertPatternGroupsToTasks", "original_string": "function convertPatternGroupsToTasks(positive, negative, dynamic) {\n    var globalNegative = '.' in negative ? negative['.'] : [];\n    return Object.keys(positive).map(function (base) {\n        var localNegative = findLocalNegativePatterns(base, negative);\n        var fullNegative = localNegative.concat(globalNegative);\n        return convertPatternGroupToTask(base, positive[base], fullNegative, dynamic);\n    });\n}", "language": "javascript", "code": "function convertPatternGroupsToTasks(positive, negative, dynamic) {\n    var globalNegative = '.' in negative ? negative['.'] : [];\n    return Object.keys(positive).map(function (base) {\n        var localNegative = findLocalNegativePatterns(base, negative);\n        var fullNegative = localNegative.concat(globalNegative);\n        return convertPatternGroupToTask(base, positive[base], fullNegative, dynamic);\n    });\n}", "code_tokens": ["function", "convertPatternGroupsToTasks", "(", "positive", ",", "negative", ",", "dynamic", ")", "{", "var", "globalNegative", "=", "'.'", "in", "negative", "?", "negative", "[", "'.'", "]", ":", "[", "]", ";", "return", "Object", ".", "keys", "(", "positive", ")", ".", "map", "(", "function", "(", "base", ")", "{", "var", "localNegative", "=", "findLocalNegativePatterns", "(", "base", ",", "negative", ")", ";", "var", "fullNegative", "=", "localNegative", ".", "concat", "(", "globalNegative", ")", ";", "return", "convertPatternGroupToTask", "(", "base", ",", "positive", "[", "base", "]", ",", "fullNegative", ",", "dynamic", ")", ";", "}", ")", ";", "}"], "docstring": "Convert group of patterns to tasks.", "docstring_tokens": ["Convert", "group", "of", "patterns", "to", "tasks", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L14136-L14143", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "mkdirSyncRecursive", "original_string": "function mkdirSyncRecursive(dir) {\n      var baseDir = path.dirname(dir);\n    \n      // Base dir exists, no recursion necessary\n      if (fs.existsSync(baseDir)) {\n        fs.mkdirSync(dir, parseInt('0777', 8));\n        return;\n      }\n    \n      // Base dir does not exist, go recursive\n      mkdirSyncRecursive(baseDir);\n    \n      // Base dir created, can create dir\n      fs.mkdirSync(dir, parseInt('0777', 8));\n    }", "language": "javascript", "code": "function mkdirSyncRecursive(dir) {\n      var baseDir = path.dirname(dir);\n    \n      // Base dir exists, no recursion necessary\n      if (fs.existsSync(baseDir)) {\n        fs.mkdirSync(dir, parseInt('0777', 8));\n        return;\n      }\n    \n      // Base dir does not exist, go recursive\n      mkdirSyncRecursive(baseDir);\n    \n      // Base dir created, can create dir\n      fs.mkdirSync(dir, parseInt('0777', 8));\n    }", "code_tokens": ["function", "mkdirSyncRecursive", "(", "dir", ")", "{", "var", "baseDir", "=", "path", ".", "dirname", "(", "dir", ")", ";", "// Base dir exists, no recursion necessary", "if", "(", "fs", ".", "existsSync", "(", "baseDir", ")", ")", "{", "fs", ".", "mkdirSync", "(", "dir", ",", "parseInt", "(", "'0777'", ",", "8", ")", ")", ";", "return", ";", "}", "// Base dir does not exist, go recursive", "mkdirSyncRecursive", "(", "baseDir", ")", ";", "// Base dir created, can create dir", "fs", ".", "mkdirSync", "(", "dir", ",", "parseInt", "(", "'0777'", ",", "8", ")", ")", ";", "}"], "docstring": "Recursively creates 'dir'", "docstring_tokens": ["Recursively", "creates", "dir"], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L49835-L49849", "partition": "test"}
{"repo": "appium/appium-xcuitest-driver", "path": "lib/utils.js", "func_name": "removeAllSessionWebSocketHandlers", "original_string": "async function removeAllSessionWebSocketHandlers (server, sessionId) {\n  if (!server || !_.isFunction(server.getWebSocketHandlers)) {\n    return;\n  }\n\n  const activeHandlers = await server.getWebSocketHandlers(sessionId);\n  for (const pathname of _.keys(activeHandlers)) {\n    await server.removeWebSocketHandler(pathname);\n  }\n}", "language": "javascript", "code": "async function removeAllSessionWebSocketHandlers (server, sessionId) {\n  if (!server || !_.isFunction(server.getWebSocketHandlers)) {\n    return;\n  }\n\n  const activeHandlers = await server.getWebSocketHandlers(sessionId);\n  for (const pathname of _.keys(activeHandlers)) {\n    await server.removeWebSocketHandler(pathname);\n  }\n}", "code_tokens": ["async", "function", "removeAllSessionWebSocketHandlers", "(", "server", ",", "sessionId", ")", "{", "if", "(", "!", "server", "||", "!", "_", ".", "isFunction", "(", "server", ".", "getWebSocketHandlers", ")", ")", "{", "return", ";", "}", "const", "activeHandlers", "=", "await", "server", ".", "getWebSocketHandlers", "(", "sessionId", ")", ";", "for", "(", "const", "pathname", "of", "_", ".", "keys", "(", "activeHandlers", ")", ")", "{", "await", "server", ".", "removeWebSocketHandler", "(", "pathname", ")", ";", "}", "}"], "docstring": "Stops and removes all web socket handlers that are listening\nin scope of the currect session.\n\n@param {Object} server - The instance of NodeJs HTTP server,\nwhich hosts Appium\n@param {string} sessionId - The id of the current session", "docstring_tokens": ["Stops", "and", "removes", "all", "web", "socket", "handlers", "that", "are", "listening", "in", "scope", "of", "the", "currect", "session", "."], "sha": "eb8c1348c390314c7ad12294f8eb5c2e52326f57", "url": "https://github.com/appium/appium-xcuitest-driver/blob/eb8c1348c390314c7ad12294f8eb5c2e52326f57/lib/utils.js#L400-L409", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(view) {\n    var morph = view.morph;\n\n    view.transitionTo('preRender');\n\n    Ember.run.schedule('render', this, function renderMetamorphView() {\n      if (view.isDestroying) { return; }\n\n      view.clearRenderedChildren();\n      var buffer = view.renderToBuffer();\n\n      view.invokeRecursively(function(view) {\n        view.propertyWillChange('element');\n      });\n      view.triggerRecursively('willInsertElement');\n\n      morph.replaceWith(buffer.string());\n      view.transitionTo('inDOM');\n\n      view.invokeRecursively(function(view) {\n        view.propertyDidChange('element');\n      });\n      view.triggerRecursively('didInsertElement');\n\n      notifyMutationListeners();\n    });\n  }", "language": "javascript", "code": "function(view) {\n    var morph = view.morph;\n\n    view.transitionTo('preRender');\n\n    Ember.run.schedule('render', this, function renderMetamorphView() {\n      if (view.isDestroying) { return; }\n\n      view.clearRenderedChildren();\n      var buffer = view.renderToBuffer();\n\n      view.invokeRecursively(function(view) {\n        view.propertyWillChange('element');\n      });\n      view.triggerRecursively('willInsertElement');\n\n      morph.replaceWith(buffer.string());\n      view.transitionTo('inDOM');\n\n      view.invokeRecursively(function(view) {\n        view.propertyDidChange('element');\n      });\n      view.triggerRecursively('didInsertElement');\n\n      notifyMutationListeners();\n    });\n  }", "code_tokens": ["function", "(", "view", ")", "{", "var", "morph", "=", "view", ".", "morph", ";", "view", ".", "transitionTo", "(", "'preRender'", ")", ";", "Ember", ".", "run", ".", "schedule", "(", "'render'", ",", "this", ",", "function", "renderMetamorphView", "(", ")", "{", "if", "(", "view", ".", "isDestroying", ")", "{", "return", ";", "}", "view", ".", "clearRenderedChildren", "(", ")", ";", "var", "buffer", "=", "view", ".", "renderToBuffer", "(", ")", ";", "view", ".", "invokeRecursively", "(", "function", "(", "view", ")", "{", "view", ".", "propertyWillChange", "(", "'element'", ")", ";", "}", ")", ";", "view", ".", "triggerRecursively", "(", "'willInsertElement'", ")", ";", "morph", ".", "replaceWith", "(", "buffer", ".", "string", "(", ")", ")", ";", "view", ".", "transitionTo", "(", "'inDOM'", ")", ";", "view", ".", "invokeRecursively", "(", "function", "(", "view", ")", "{", "view", ".", "propertyDidChange", "(", "'element'", ")", ";", "}", ")", ";", "view", ".", "triggerRecursively", "(", "'didInsertElement'", ")", ";", "notifyMutationListeners", "(", ")", ";", "}", ")", ";", "}"], "docstring": "This is messed up.", "docstring_tokens": ["This", "is", "messed", "up", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L27943-L27969", "partition": "test"}
{"repo": "phphe/vue-draggable-nested-tree", "path": "dist/vue-draggable-nested-tree.cjs.js", "func_name": "appendPrev", "original_string": "function appendPrev(info) {\n    if (isNodeDroppable(info.targetPrev)) {\n      th.appendTo(info.dplh, info.targetPrev);\n      if (!info.targetPrev.open) info.store.toggleOpen(info.targetPrev);\n    } else {\n      insertDplhAfterTo(info.dplh, info.targetPrev, info);\n    }\n  }", "language": "javascript", "code": "function appendPrev(info) {\n    if (isNodeDroppable(info.targetPrev)) {\n      th.appendTo(info.dplh, info.targetPrev);\n      if (!info.targetPrev.open) info.store.toggleOpen(info.targetPrev);\n    } else {\n      insertDplhAfterTo(info.dplh, info.targetPrev, info);\n    }\n  }", "code_tokens": ["function", "appendPrev", "(", "info", ")", "{", "if", "(", "isNodeDroppable", "(", "info", ".", "targetPrev", ")", ")", "{", "th", ".", "appendTo", "(", "info", ".", "dplh", ",", "info", ".", "targetPrev", ")", ";", "if", "(", "!", "info", ".", "targetPrev", ".", "open", ")", "info", ".", "store", ".", "toggleOpen", "(", "info", ".", "targetPrev", ")", ";", "}", "else", "{", "insertDplhAfterTo", "(", "info", ".", "dplh", ",", "info", ".", "targetPrev", ",", "info", ")", ";", "}", "}"], "docstring": "append to prev sibling", "docstring_tokens": ["append", "to", "prev", "sibling"], "sha": "094b12954d55d449cdebbcbc00c6456fed3c99ce", "url": "https://github.com/phphe/vue-draggable-nested-tree/blob/094b12954d55d449cdebbcbc00c6456fed3c99ce/dist/vue-draggable-nested-tree.cjs.js#L646-L653", "partition": "test"}
{"repo": "wavesoft/gulp-jbb-profile", "path": "lib/ProfileIndex.js", "func_name": "", "original_string": "function() {\n\t\tvar pn = Object.keys(this._properties);\n\t\tvar code = \"var \";\n\t\tfor (var i=0, l=pn.length; i<l; ++i) {\n\t\t\tif (i!==0) code += \",\\n\";\n\t\t\tcode += this.indent + this._properties[pn[i]] + \" = '\"+ pn[i] + \"'\";\n\t\t}\n\t\tcode += \";\\n\";\n\t\treturn code;\n\t}", "language": "javascript", "code": "function() {\n\t\tvar pn = Object.keys(this._properties);\n\t\tvar code = \"var \";\n\t\tfor (var i=0, l=pn.length; i<l; ++i) {\n\t\t\tif (i!==0) code += \",\\n\";\n\t\t\tcode += this.indent + this._properties[pn[i]] + \" = '\"+ pn[i] + \"'\";\n\t\t}\n\t\tcode += \";\\n\";\n\t\treturn code;\n\t}", "code_tokens": ["function", "(", ")", "{", "var", "pn", "=", "Object", ".", "keys", "(", "this", ".", "_properties", ")", ";", "var", "code", "=", "\"var \"", ";", "for", "(", "var", "i", "=", "0", ",", "l", "=", "pn", ".", "length", ";", "i", "<", "l", ";", "++", "i", ")", "{", "if", "(", "i", "!==", "0", ")", "code", "+=", "\",\\n\"", ";", "code", "+=", "this", ".", "indent", "+", "this", ".", "_properties", "[", "pn", "[", "i", "]", "]", "+", "\" = '\"", "+", "pn", "[", "i", "]", "+", "\"'\"", ";", "}", "code", "+=", "\";\\n\"", ";", "return", "code", ";", "}"], "docstring": "Generate a table with all the property constants", "docstring_tokens": ["Generate", "a", "table", "with", "all", "the", "property", "constants"], "sha": "3e9bc0ca733ae0325a09a461f504fc847e256f7a", "url": "https://github.com/wavesoft/gulp-jbb-profile/blob/3e9bc0ca733ae0325a09a461f504fc847e256f7a/lib/ProfileIndex.js#L202-L211", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/object-store/query-engine.js", "func_name": "prepareQuery", "original_string": "function prepareQuery(thisStorage, filter, order) {\n  order = normalizeKeyPath(order)\n  \n  let expectedSortingDirection = order[0].charAt(0) === \"!\"\n  let canSortingBeOptimized\n  canSortingBeOptimized = canOptimizeSorting(expectedSortingDirection, order)\n  \n  let storages = new Map()\n  storages.set(normalizeKeyPath(thisStorage.keyPath), {\n    storage: thisStorage,\n    score: 1 // traversing storage is faster than fetching records by index\n  })\n  \n  for (let indexName of thisStorage.indexNames) {\n    let index = thisStorage.getIndex(indexName)\n    if (!index.multiEntry) {\n      storages.set(normalizeKeyPath(index.keyPath), {\n        storage: index,\n        score: 0\n      })\n    }\n  }\n  \n  let simplifiedOrderFieldPaths = simplifyOrderingFieldPaths(order)\n  \n  if (canSortingBeOptimized) {\n    prepareSortingOptimization(storages, simplifiedOrderFieldPaths)\n  }\n\n  prepareFilteringOptimization(storages, filter)\n  \n  return chooseStorageForQuery(\n    storages,\n    order,\n    simplifiedOrderFieldPaths,\n    canSortingBeOptimized,\n    expectedSortingDirection\n  )\n}", "language": "javascript", "code": "function prepareQuery(thisStorage, filter, order) {\n  order = normalizeKeyPath(order)\n  \n  let expectedSortingDirection = order[0].charAt(0) === \"!\"\n  let canSortingBeOptimized\n  canSortingBeOptimized = canOptimizeSorting(expectedSortingDirection, order)\n  \n  let storages = new Map()\n  storages.set(normalizeKeyPath(thisStorage.keyPath), {\n    storage: thisStorage,\n    score: 1 // traversing storage is faster than fetching records by index\n  })\n  \n  for (let indexName of thisStorage.indexNames) {\n    let index = thisStorage.getIndex(indexName)\n    if (!index.multiEntry) {\n      storages.set(normalizeKeyPath(index.keyPath), {\n        storage: index,\n        score: 0\n      })\n    }\n  }\n  \n  let simplifiedOrderFieldPaths = simplifyOrderingFieldPaths(order)\n  \n  if (canSortingBeOptimized) {\n    prepareSortingOptimization(storages, simplifiedOrderFieldPaths)\n  }\n\n  prepareFilteringOptimization(storages, filter)\n  \n  return chooseStorageForQuery(\n    storages,\n    order,\n    simplifiedOrderFieldPaths,\n    canSortingBeOptimized,\n    expectedSortingDirection\n  )\n}", "code_tokens": ["function", "prepareQuery", "(", "thisStorage", ",", "filter", ",", "order", ")", "{", "order", "=", "normalizeKeyPath", "(", "order", ")", "let", "expectedSortingDirection", "=", "order", "[", "0", "]", ".", "charAt", "(", "0", ")", "===", "\"!\"", "let", "canSortingBeOptimized", "canSortingBeOptimized", "=", "canOptimizeSorting", "(", "expectedSortingDirection", ",", "order", ")", "let", "storages", "=", "new", "Map", "(", ")", "storages", ".", "set", "(", "normalizeKeyPath", "(", "thisStorage", ".", "keyPath", ")", ",", "{", "storage", ":", "thisStorage", ",", "score", ":", "1", "// traversing storage is faster than fetching records by index", "}", ")", "for", "(", "let", "indexName", "of", "thisStorage", ".", "indexNames", ")", "{", "let", "index", "=", "thisStorage", ".", "getIndex", "(", "indexName", ")", "if", "(", "!", "index", ".", "multiEntry", ")", "{", "storages", ".", "set", "(", "normalizeKeyPath", "(", "index", ".", "keyPath", ")", ",", "{", "storage", ":", "index", ",", "score", ":", "0", "}", ")", "}", "}", "let", "simplifiedOrderFieldPaths", "=", "simplifyOrderingFieldPaths", "(", "order", ")", "if", "(", "canSortingBeOptimized", ")", "{", "prepareSortingOptimization", "(", "storages", ",", "simplifiedOrderFieldPaths", ")", "}", "prepareFilteringOptimization", "(", "storages", ",", "filter", ")", "return", "chooseStorageForQuery", "(", "storages", ",", "order", ",", "simplifiedOrderFieldPaths", ",", "canSortingBeOptimized", ",", "expectedSortingDirection", ")", "}"], "docstring": "Prepares the query that uses the specified filter and record order for\nexecution on this storage.\n\nThe method attempts uses a heuristic to determine whether the query should\nbe run directly on this object store or on one of its indexes for maximum\nperformance.\n\nIf the method cannot optimize sorting and filtering, it prefers optimizing\nsorting to optimizing filtering, as optimizing sorting allows the query\nexecutor to skip the requested amount of records and the records following\nthe last record that fills the required amount of records.\n\nIf the sorting cannot be optimized, the method attempts to optimize\nfiltering so that the matching records can be selected by providing a key\nrange to cursor, so that only the matching records will be traversed.\n\nThe method constructs the filtering predicate and sorting comparator if\nneither the sorting nor filtering can be optimized, and prepares the query\nto be executed directly on the object store.\n\n@param {ReadOnlyObjectStore} thisStorage This object store.\n@param {?(undefined|number|string|Date|Array|IDBKeyRange|Object<string, (number|string|Date|Array|IDBKeyRange)>|function(*, (number|string|Date|Array)): boolean)=} filter\nThe filter, restricting the records returned by this method. If a\nfunction is provided, the first argument will be set to the record\nand the second argument will be set to the primary key of the record.\n@param {(string|string[])} order Field paths by which the records should be\nsorted. A field path may be prefixed by an exclamation mark\n({@code \"!\"}) for descending order.\n@return {{storage: AbstractReadOnlyStorage, direction: CursorDirection, comparator: ?function(*, *): number, keyRange: (undefined|IDBKeyRange), filter: (undefined|function(*, (number|string|Date|Array)): boolean)}}\nThe storage on which the query should be executed, the direction in\nwhich the cursor should be opened and the record comparator to use\nto additionally sort the fetched records matching the filter.\nFinally, the returned object has the {@code keyRange} and\n{@code filter} fields set to the key range and custom filter to use\nwith the storage to run the query.", "docstring_tokens": ["Prepares", "the", "query", "that", "uses", "the", "specified", "filter", "and", "record", "order", "for", "execution", "on", "this", "storage", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/object-store/query-engine.js#L329-L367", "partition": "test"}
{"repo": "DeadAlready/node-easy-pipe", "path": "lib/shellStream.js", "func_name": "ShellStream", "original_string": "function ShellStream(args){\n    if(this instanceof ShellStream === false){\n        return new ShellStream(args);\n    }\n\n    this._command = args;\n    this._events = [];\n    var self = this;\n    // Create holders for events to be added\n    streams.forEach(function(stream){\n        self[stream] = {on:this.on, _events:[]};\n    });\n}", "language": "javascript", "code": "function ShellStream(args){\n    if(this instanceof ShellStream === false){\n        return new ShellStream(args);\n    }\n\n    this._command = args;\n    this._events = [];\n    var self = this;\n    // Create holders for events to be added\n    streams.forEach(function(stream){\n        self[stream] = {on:this.on, _events:[]};\n    });\n}", "code_tokens": ["function", "ShellStream", "(", "args", ")", "{", "if", "(", "this", "instanceof", "ShellStream", "===", "false", ")", "{", "return", "new", "ShellStream", "(", "args", ")", ";", "}", "this", ".", "_command", "=", "args", ";", "this", ".", "_events", "=", "[", "]", ";", "var", "self", "=", "this", ";", "// Create holders for events to be added", "streams", ".", "forEach", "(", "function", "(", "stream", ")", "{", "self", "[", "stream", "]", "=", "{", "on", ":", "this", ".", "on", ",", "_events", ":", "[", "]", "}", ";", "}", ")", ";", "}"], "docstring": "Main function for creating a shellstream\n\n@param {Array} args -> arguments to apply to PipeStream\n\n@returns {ShellStream}", "docstring_tokens": ["Main", "function", "for", "creating", "a", "shellstream"], "sha": "e739e052494cd6be96c95bc65e34442042243e7d", "url": "https://github.com/DeadAlready/node-easy-pipe/blob/e739e052494cd6be96c95bc65e34442042243e7d/lib/shellStream.js#L18-L30", "partition": "test"}
{"repo": "danheberden/perform", "path": "lib/perform.js", "func_name": "", "original_string": "function() {\n  this.dones = [];\n  this.doneArgs = [];\n  this.fails = [];\n  this.failArgs = [];\n  this.pendings = [];\n  this.pendingArgs = [];\n  this.state = 'pending';\n\n  // expose the promise\n  this.promise = iPromise.call( this );\n\n}", "language": "javascript", "code": "function() {\n  this.dones = [];\n  this.doneArgs = [];\n  this.fails = [];\n  this.failArgs = [];\n  this.pendings = [];\n  this.pendingArgs = [];\n  this.state = 'pending';\n\n  // expose the promise\n  this.promise = iPromise.call( this );\n\n}", "code_tokens": ["function", "(", ")", "{", "this", ".", "dones", "=", "[", "]", ";", "this", ".", "doneArgs", "=", "[", "]", ";", "this", ".", "fails", "=", "[", "]", ";", "this", ".", "failArgs", "=", "[", "]", ";", "this", ".", "pendings", "=", "[", "]", ";", "this", ".", "pendingArgs", "=", "[", "]", ";", "this", ".", "state", "=", "'pending'", ";", "// expose the promise", "this", ".", "promise", "=", "iPromise", ".", "call", "(", "this", ")", ";", "}"], "docstring": "the heart of the beast", "docstring_tokens": ["the", "heart", "of", "the", "beast"], "sha": "eaff7958f07ae489d660bccdcf3bf38904d29d9a", "url": "https://github.com/danheberden/perform/blob/eaff7958f07ae489d660bccdcf3bf38904d29d9a/lib/perform.js#L113-L125", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getDeclarationName", "original_string": "function getDeclarationName(node) {\n            if (node.name) {\n                if (node.kind === 218 /* ModuleDeclaration */ && node.name.kind === 9 /* StringLiteral */) {\n                    return \"\\\"\" + node.name.text + \"\\\"\";\n                }\n                if (node.name.kind === 136 /* ComputedPropertyName */) {\n                    var nameExpression = node.name.expression;\n                    ts.Debug.assert(ts.isWellKnownSymbolSyntactically(nameExpression));\n                    return ts.getPropertyNameForKnownSymbolName(nameExpression.name.text);\n                }\n                return node.name.text;\n            }\n            switch (node.kind) {\n                case 144 /* Constructor */:\n                    return \"__constructor\";\n                case 152 /* FunctionType */:\n                case 147 /* CallSignature */:\n                    return \"__call\";\n                case 153 /* ConstructorType */:\n                case 148 /* ConstructSignature */:\n                    return \"__new\";\n                case 149 /* IndexSignature */:\n                    return \"__index\";\n                case 228 /* ExportDeclaration */:\n                    return \"__export\";\n                case 227 /* ExportAssignment */:\n                    return node.isExportEquals ? \"export=\" : \"default\";\n                case 213 /* FunctionDeclaration */:\n                case 214 /* ClassDeclaration */:\n                    return node.flags & 1024 /* Default */ ? \"default\" : undefined;\n            }\n        }", "language": "javascript", "code": "function getDeclarationName(node) {\n            if (node.name) {\n                if (node.kind === 218 /* ModuleDeclaration */ && node.name.kind === 9 /* StringLiteral */) {\n                    return \"\\\"\" + node.name.text + \"\\\"\";\n                }\n                if (node.name.kind === 136 /* ComputedPropertyName */) {\n                    var nameExpression = node.name.expression;\n                    ts.Debug.assert(ts.isWellKnownSymbolSyntactically(nameExpression));\n                    return ts.getPropertyNameForKnownSymbolName(nameExpression.name.text);\n                }\n                return node.name.text;\n            }\n            switch (node.kind) {\n                case 144 /* Constructor */:\n                    return \"__constructor\";\n                case 152 /* FunctionType */:\n                case 147 /* CallSignature */:\n                    return \"__call\";\n                case 153 /* ConstructorType */:\n                case 148 /* ConstructSignature */:\n                    return \"__new\";\n                case 149 /* IndexSignature */:\n                    return \"__index\";\n                case 228 /* ExportDeclaration */:\n                    return \"__export\";\n                case 227 /* ExportAssignment */:\n                    return node.isExportEquals ? \"export=\" : \"default\";\n                case 213 /* FunctionDeclaration */:\n                case 214 /* ClassDeclaration */:\n                    return node.flags & 1024 /* Default */ ? \"default\" : undefined;\n            }\n        }", "code_tokens": ["function", "getDeclarationName", "(", "node", ")", "{", "if", "(", "node", ".", "name", ")", "{", "if", "(", "node", ".", "kind", "===", "218", "/* ModuleDeclaration */", "&&", "node", ".", "name", ".", "kind", "===", "9", "/* StringLiteral */", ")", "{", "return", "\"\\\"\"", "+", "node", ".", "name", ".", "text", "+", "\"\\\"\"", ";", "}", "if", "(", "node", ".", "name", ".", "kind", "===", "136", "/* ComputedPropertyName */", ")", "{", "var", "nameExpression", "=", "node", ".", "name", ".", "expression", ";", "ts", ".", "Debug", ".", "assert", "(", "ts", ".", "isWellKnownSymbolSyntactically", "(", "nameExpression", ")", ")", ";", "return", "ts", ".", "getPropertyNameForKnownSymbolName", "(", "nameExpression", ".", "name", ".", "text", ")", ";", "}", "return", "node", ".", "name", ".", "text", ";", "}", "switch", "(", "node", ".", "kind", ")", "{", "case", "144", "/* Constructor */", ":", "return", "\"__constructor\"", ";", "case", "152", "/* FunctionType */", ":", "case", "147", "/* CallSignature */", ":", "return", "\"__call\"", ";", "case", "153", "/* ConstructorType */", ":", "case", "148", "/* ConstructSignature */", ":", "return", "\"__new\"", ";", "case", "149", "/* IndexSignature */", ":", "return", "\"__index\"", ";", "case", "228", "/* ExportDeclaration */", ":", "return", "\"__export\"", ";", "case", "227", "/* ExportAssignment */", ":", "return", "node", ".", "isExportEquals", "?", "\"export=\"", ":", "\"default\"", ";", "case", "213", "/* FunctionDeclaration */", ":", "case", "214", "/* ClassDeclaration */", ":", "return", "node", ".", "flags", "&", "1024", "/* Default */", "?", "\"default\"", ":", "undefined", ";", "}", "}"], "docstring": "Should not be called on a declaration with a computed property name, unless it is a well known Symbol.", "docstring_tokens": ["Should", "not", "be", "called", "on", "a", "declaration", "with", "a", "computed", "property", "name", "unless", "it", "is", "a", "well", "known", "Symbol", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L4276-L4307", "partition": "test"}
{"repo": "Katochimoto/xblocks-core", "path": "src/xblocks/element.js", "func_name": "reduceChildListMutation", "original_string": "function reduceChildListMutation(mutationContent, record) {\n    const isAdded = Boolean(record.addedNodes.length);\n    const isNext = Boolean(record.nextSibling);\n    const isPrev = Boolean(record.previousSibling);\n    const isRemoved = Boolean(record.removedNodes.length);\n\n    // innerHTML or replace\n    if (isAdded && (isRemoved || (!isRemoved && !isNext && !isPrev))) {\n        while (mutationContent.firstChild) {\n            mutationContent.removeChild(mutationContent.firstChild);\n        }\n\n        forEach(record.addedNodes, function (node) {\n            mutationContent.appendChild(node);\n        });\n\n    // appendChild\n    } else if (isAdded && !isRemoved && !isNext && isPrev) {\n        forEach(record.addedNodes, function (node) {\n            mutationContent.appendChild(node);\n        });\n\n    // insertBefore\n    } else if (isAdded && !isRemoved && isNext && !isPrev) {\n        forEach(record.addedNodes, function (node) {\n            mutationContent.insertBefore(node, mutationContent.firstChild);\n        });\n    }\n\n    return mutationContent;\n}", "language": "javascript", "code": "function reduceChildListMutation(mutationContent, record) {\n    const isAdded = Boolean(record.addedNodes.length);\n    const isNext = Boolean(record.nextSibling);\n    const isPrev = Boolean(record.previousSibling);\n    const isRemoved = Boolean(record.removedNodes.length);\n\n    // innerHTML or replace\n    if (isAdded && (isRemoved || (!isRemoved && !isNext && !isPrev))) {\n        while (mutationContent.firstChild) {\n            mutationContent.removeChild(mutationContent.firstChild);\n        }\n\n        forEach(record.addedNodes, function (node) {\n            mutationContent.appendChild(node);\n        });\n\n    // appendChild\n    } else if (isAdded && !isRemoved && !isNext && isPrev) {\n        forEach(record.addedNodes, function (node) {\n            mutationContent.appendChild(node);\n        });\n\n    // insertBefore\n    } else if (isAdded && !isRemoved && isNext && !isPrev) {\n        forEach(record.addedNodes, function (node) {\n            mutationContent.insertBefore(node, mutationContent.firstChild);\n        });\n    }\n\n    return mutationContent;\n}", "code_tokens": ["function", "reduceChildListMutation", "(", "mutationContent", ",", "record", ")", "{", "const", "isAdded", "=", "Boolean", "(", "record", ".", "addedNodes", ".", "length", ")", ";", "const", "isNext", "=", "Boolean", "(", "record", ".", "nextSibling", ")", ";", "const", "isPrev", "=", "Boolean", "(", "record", ".", "previousSibling", ")", ";", "const", "isRemoved", "=", "Boolean", "(", "record", ".", "removedNodes", ".", "length", ")", ";", "// innerHTML or replace", "if", "(", "isAdded", "&&", "(", "isRemoved", "||", "(", "!", "isRemoved", "&&", "!", "isNext", "&&", "!", "isPrev", ")", ")", ")", "{", "while", "(", "mutationContent", ".", "firstChild", ")", "{", "mutationContent", ".", "removeChild", "(", "mutationContent", ".", "firstChild", ")", ";", "}", "forEach", "(", "record", ".", "addedNodes", ",", "function", "(", "node", ")", "{", "mutationContent", ".", "appendChild", "(", "node", ")", ";", "}", ")", ";", "// appendChild", "}", "else", "if", "(", "isAdded", "&&", "!", "isRemoved", "&&", "!", "isNext", "&&", "isPrev", ")", "{", "forEach", "(", "record", ".", "addedNodes", ",", "function", "(", "node", ")", "{", "mutationContent", ".", "appendChild", "(", "node", ")", ";", "}", ")", ";", "// insertBefore", "}", "else", "if", "(", "isAdded", "&&", "!", "isRemoved", "&&", "isNext", "&&", "!", "isPrev", ")", "{", "forEach", "(", "record", ".", "addedNodes", ",", "function", "(", "node", ")", "{", "mutationContent", ".", "insertBefore", "(", "node", ",", "mutationContent", ".", "firstChild", ")", ";", "}", ")", ";", "}", "return", "mutationContent", ";", "}"], "docstring": "The allocation of the changed nodes.\n@param {HTMLElement} mutationContent\n@param {MutationRecord} record\n@returns {HTMLElement}\n@private", "docstring_tokens": ["The", "allocation", "of", "the", "changed", "nodes", "."], "sha": "714102b7c2adb4ae197403df252e967a1b967bb1", "url": "https://github.com/Katochimoto/xblocks-core/blob/714102b7c2adb4ae197403df252e967a1b967bb1/src/xblocks/element.js#L334-L364", "partition": "test"}
{"repo": "Katochimoto/xblocks-core", "path": "src/xblocks/block.js", "func_name": "accessorsIterator", "original_string": "function accessorsIterator(options, name, accessors) {\n    const optionsSetter = get(options, 'set');\n    const updateSetter = wrap(name, wrapperAccessorsSetUpdate);\n\n    accessors[ name ] = merge({}, options, {\n        set: wrap(optionsSetter, wrap(updateSetter, wrapperFunction))\n    });\n}", "language": "javascript", "code": "function accessorsIterator(options, name, accessors) {\n    const optionsSetter = get(options, 'set');\n    const updateSetter = wrap(name, wrapperAccessorsSetUpdate);\n\n    accessors[ name ] = merge({}, options, {\n        set: wrap(optionsSetter, wrap(updateSetter, wrapperFunction))\n    });\n}", "code_tokens": ["function", "accessorsIterator", "(", "options", ",", "name", ",", "accessors", ")", "{", "const", "optionsSetter", "=", "get", "(", "options", ",", "'set'", ")", ";", "const", "updateSetter", "=", "wrap", "(", "name", ",", "wrapperAccessorsSetUpdate", ")", ";", "accessors", "[", "name", "]", "=", "merge", "(", "{", "}", ",", "options", ",", "{", "set", ":", "wrap", "(", "optionsSetter", ",", "wrap", "(", "updateSetter", ",", "wrapperFunction", ")", ")", "}", ")", ";", "}"], "docstring": "The assignment of parameters accessors.\n@example\n_.forEach({}, accessorsIterator);\n@param {Object} options\n@param {string} name\n@param {Object} accessors\n@private", "docstring_tokens": ["The", "assignment", "of", "parameters", "accessors", "."], "sha": "714102b7c2adb4ae197403df252e967a1b967bb1", "url": "https://github.com/Katochimoto/xblocks-core/blob/714102b7c2adb4ae197403df252e967a1b967bb1/src/xblocks/block.js#L361-L368", "partition": "test"}
{"repo": "weikinhuang/closedinterval-git-hooks", "path": "lib/pre-commit/pre-commit-base.js", "func_name": "read", "original_string": "function read() {\n\tvar filename = process.argv[2],\n\t\tsrc = fs.readFileSync(process.argv[3], \"utf8\");\n\n\t// attempt to modify any src passing through the pre-commit hook\n\ttry {\n\t\tsrc = require(path.join(process.cwd(), \".git-hooks/pre-commit-plugins/pre-commit-modifier\"))(filename, src);\n\t} catch (e) {\n\t\t// empty\n\t}\n\t// filename, src\n\treturn Bluebird.resolve({\n\t\tfilename : filename,\n\t\tsrc : src\n\t});\n}", "language": "javascript", "code": "function read() {\n\tvar filename = process.argv[2],\n\t\tsrc = fs.readFileSync(process.argv[3], \"utf8\");\n\n\t// attempt to modify any src passing through the pre-commit hook\n\ttry {\n\t\tsrc = require(path.join(process.cwd(), \".git-hooks/pre-commit-plugins/pre-commit-modifier\"))(filename, src);\n\t} catch (e) {\n\t\t// empty\n\t}\n\t// filename, src\n\treturn Bluebird.resolve({\n\t\tfilename : filename,\n\t\tsrc : src\n\t});\n}", "code_tokens": ["function", "read", "(", ")", "{", "var", "filename", "=", "process", ".", "argv", "[", "2", "]", ",", "src", "=", "fs", ".", "readFileSync", "(", "process", ".", "argv", "[", "3", "]", ",", "\"utf8\"", ")", ";", "// attempt to modify any src passing through the pre-commit hook", "try", "{", "src", "=", "require", "(", "path", ".", "join", "(", "process", ".", "cwd", "(", ")", ",", "\".git-hooks/pre-commit-plugins/pre-commit-modifier\"", ")", ")", "(", "filename", ",", "src", ")", ";", "}", "catch", "(", "e", ")", "{", "// empty", "}", "// filename, src", "return", "Bluebird", ".", "resolve", "(", "{", "filename", ":", "filename", ",", "src", ":", "src", "}", ")", ";", "}"], "docstring": "Get file contents and file name from process.argv\n@returns {Promise.<{filename: *, src}>|String|*}", "docstring_tokens": ["Get", "file", "contents", "and", "file", "name", "from", "process", ".", "argv"], "sha": "42d7e6874a4500bc3d6f9aaadf03324748930e44", "url": "https://github.com/weikinhuang/closedinterval-git-hooks/blob/42d7e6874a4500bc3d6f9aaadf03324748930e44/lib/pre-commit/pre-commit-base.js#L182-L197", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/commit.js", "func_name": "prepare", "original_string": "function prepare(repoState, opts) {\n    const workingState = repoState.getCurrentState();\n    const changes = workingState.getChanges();\n\n    // Is this an empty commit ?\n    opts.empty = workingState.isClean();\n\n    // Parent SHA\n    opts.parents = new Immutable.List([\n        workingState.getHead()\n    ]);\n\n    // Get merged tree (with applied changes)\n    opts.treeEntries = WorkingUtils.getMergedTreeEntries(workingState);\n\n    // Create map of blobs that needs to be created\n    opts.blobs = changes.filter((change) => {\n        return !change.hasSha();\n    }).map((change) => {\n        return change.getContent();\n    });\n\n    return CommitBuilder.create(opts);\n}", "language": "javascript", "code": "function prepare(repoState, opts) {\n    const workingState = repoState.getCurrentState();\n    const changes = workingState.getChanges();\n\n    // Is this an empty commit ?\n    opts.empty = workingState.isClean();\n\n    // Parent SHA\n    opts.parents = new Immutable.List([\n        workingState.getHead()\n    ]);\n\n    // Get merged tree (with applied changes)\n    opts.treeEntries = WorkingUtils.getMergedTreeEntries(workingState);\n\n    // Create map of blobs that needs to be created\n    opts.blobs = changes.filter((change) => {\n        return !change.hasSha();\n    }).map((change) => {\n        return change.getContent();\n    });\n\n    return CommitBuilder.create(opts);\n}", "code_tokens": ["function", "prepare", "(", "repoState", ",", "opts", ")", "{", "const", "workingState", "=", "repoState", ".", "getCurrentState", "(", ")", ";", "const", "changes", "=", "workingState", ".", "getChanges", "(", ")", ";", "// Is this an empty commit ?", "opts", ".", "empty", "=", "workingState", ".", "isClean", "(", ")", ";", "// Parent SHA", "opts", ".", "parents", "=", "new", "Immutable", ".", "List", "(", "[", "workingState", ".", "getHead", "(", ")", "]", ")", ";", "// Get merged tree (with applied changes)", "opts", ".", "treeEntries", "=", "WorkingUtils", ".", "getMergedTreeEntries", "(", "workingState", ")", ";", "// Create map of blobs that needs to be created", "opts", ".", "blobs", "=", "changes", ".", "filter", "(", "(", "change", ")", "=>", "{", "return", "!", "change", ".", "hasSha", "(", ")", ";", "}", ")", ".", "map", "(", "(", "change", ")", "=>", "{", "return", "change", ".", "getContent", "(", ")", ";", "}", ")", ";", "return", "CommitBuilder", ".", "create", "(", "opts", ")", ";", "}"], "docstring": "Create a commit builder from the changes on current branch\n@param {RepositoryState}\n@param {Author} opts.author\n@param {String} [opts.message]\n@return {CommitBuilder}", "docstring_tokens": ["Create", "a", "commit", "builder", "from", "the", "changes", "on", "current", "branch"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/commit.js#L17-L40", "partition": "test"}
{"repo": "hybridables/redolent", "path": "dist/redolent.es.js", "func_name": "arrIncludes", "original_string": "function arrIncludes (arr, values) {\n  if (!Array.isArray(values)) { return inArray(arr, values) }\n  var len = values.length;\n  var i = -1;\n\n  while (i++ < len) {\n    var j = inArray(arr, values[i]);\n    if (j) {\n      return j\n    }\n  }\n\n  return false\n}", "language": "javascript", "code": "function arrIncludes (arr, values) {\n  if (!Array.isArray(values)) { return inArray(arr, values) }\n  var len = values.length;\n  var i = -1;\n\n  while (i++ < len) {\n    var j = inArray(arr, values[i]);\n    if (j) {\n      return j\n    }\n  }\n\n  return false\n}", "code_tokens": ["function", "arrIncludes", "(", "arr", ",", "values", ")", "{", "if", "(", "!", "Array", ".", "isArray", "(", "values", ")", ")", "{", "return", "inArray", "(", "arr", ",", "values", ")", "}", "var", "len", "=", "values", ".", "length", ";", "var", "i", "=", "-", "1", ";", "while", "(", "i", "++", "<", "len", ")", "{", "var", "j", "=", "inArray", "(", "arr", ",", "values", "[", "i", "]", ")", ";", "if", "(", "j", ")", "{", "return", "j", "}", "}", "return", "false", "}"], "docstring": "> Check any of `values` exists on `arr`.\n\n**Example**\n\n```js\nvar arrIncludes = require('arr-includes')\n\nconsole.log(arrIncludes([1, 'bar', 55], 2)) // => false\nconsole.log(arrIncludes([1, 'bar', 3], 3)) // => 2\n\nconsole.log(arrIncludes([1, 'bar', 3, true], false)) // => false\nconsole.log(arrIncludes([1, 'bar', 44, true], true)) // => 3\n\nconsole.log(arrIncludes(['foo', 'bar'], 'baz')) // => false\nconsole.log(arrIncludes(['foo', 'bar'], 'foo')) // => true\nconsole.log(arrIncludes(['qux', 'foo', 'bar'], 'foo')) // => 1\nconsole.log(arrIncludes([true, 'qqq', 'bar'], true)) // => true\nconsole.log(arrIncludes(['true', 'qqq', 'bar'], true)) // => false\nconsole.log(arrIncludes(['qqq', 'bar', true], true)) // => 2\nconsole.log(arrIncludes(['qqq', 'true', 'bar'], true)) // => false\nconsole.log(arrIncludes([false, 'foo', null, 'bar'], null)) // => 2\n\nconsole.log(arrIncludes(['foo', 'bar', 'qux'], ['a', 'b', 'c'])) // => false\nconsole.log(arrIncludes(['b', 'a', 'c'], ['a', 'b', 'c'])) // => 1\nconsole.log(arrIncludes(['foo', 'bb', 'b'], ['a', 'b'])) // => 2\nconsole.log(arrIncludes(['foo', 'bar', 'qux'], ['a', 'b', 'foo'])) // => true\nconsole.log(arrIncludes(['bar', 123, 'foo', 'qux'], ['a', 'b', 'foo'])) // => 2\n```\n\n@param  {Array} `arr` array to check\n@param  {Array|String} `values` array or string\n@return {Boolean|Number} returns `false` if not found, `true` if **index is 0**\nfrom the array, otherwise `number` index\n@api public", "docstring_tokens": [">", "Check", "any", "of", "values", "exists", "on", "arr", "."], "sha": "59fd76047529da2305cf682a0e95528a2279196b", "url": "https://github.com/hybridables/redolent/blob/59fd76047529da2305cf682a0e95528a2279196b/dist/redolent.es.js#L125-L138", "partition": "test"}
{"repo": "vanruesc/postprocessing", "path": "build/postprocessing.esm.js", "func_name": "prefixSubstrings", "original_string": "function prefixSubstrings(prefix, substrings, strings) {\n\n\tlet prefixed, regExp;\n\n\tfor(const substring of substrings) {\n\n\t\tprefixed = \"$1\" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);\n\t\tregExp = new RegExp(\"([^\\\\.])(\\\\b\" + substring + \"\\\\b)\", \"g\");\n\n\t\tfor(const entry of strings.entries()) {\n\n\t\t\tif(entry[1] !== null) {\n\n\t\t\t\tstrings.set(entry[0], entry[1].replace(regExp, prefixed));\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "language": "javascript", "code": "function prefixSubstrings(prefix, substrings, strings) {\n\n\tlet prefixed, regExp;\n\n\tfor(const substring of substrings) {\n\n\t\tprefixed = \"$1\" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);\n\t\tregExp = new RegExp(\"([^\\\\.])(\\\\b\" + substring + \"\\\\b)\", \"g\");\n\n\t\tfor(const entry of strings.entries()) {\n\n\t\t\tif(entry[1] !== null) {\n\n\t\t\t\tstrings.set(entry[0], entry[1].replace(regExp, prefixed));\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "code_tokens": ["function", "prefixSubstrings", "(", "prefix", ",", "substrings", ",", "strings", ")", "{", "let", "prefixed", ",", "regExp", ";", "for", "(", "const", "substring", "of", "substrings", ")", "{", "prefixed", "=", "\"$1\"", "+", "prefix", "+", "substring", ".", "charAt", "(", "0", ")", ".", "toUpperCase", "(", ")", "+", "substring", ".", "slice", "(", "1", ")", ";", "regExp", "=", "new", "RegExp", "(", "\"([^\\\\.])(\\\\b\"", "+", "substring", "+", "\"\\\\b)\"", ",", "\"g\"", ")", ";", "for", "(", "const", "entry", "of", "strings", ".", "entries", "(", ")", ")", "{", "if", "(", "entry", "[", "1", "]", "!==", "null", ")", "{", "strings", ".", "set", "(", "entry", "[", "0", "]", ",", "entry", "[", "1", "]", ".", "replace", "(", "regExp", ",", "prefixed", ")", ")", ";", "}", "}", "}", "}"], "docstring": "Prefixes substrings within the given strings.\n\n@private\n@param {String} prefix - A prefix.\n@param {String[]} substrings - The substrings.\n@param {Map<String, String>} strings - A collection of named strings.", "docstring_tokens": ["Prefixes", "substrings", "within", "the", "given", "strings", "."], "sha": "43a6776c2a391ddd3539262e078b0f35b5563004", "url": "https://github.com/vanruesc/postprocessing/blob/43a6776c2a391ddd3539262e078b0f35b5563004/build/postprocessing.esm.js#L2400-L2421", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/migration/RecordFetcher.js", "func_name": "fetchRecords", "original_string": "function fetchRecords(objectStore, preprocessor) {\n  return new PromiseSync((resolve, reject) => {\n    let records = []\n    \n    objectStore.openCursor(null, CursorDirection.NEXT, (cursor) => {\n      let primaryKey = cursor.primaryKey\n      if (primaryKey instanceof Object) {\n        Object.freeze(primaryKey)\n      }\n      \n      let preprocessedRecord = preprocessor(cursor.record, primaryKey)\n      if (preprocessedRecord === UpgradedDatabaseSchema.DELETE_RECORD) {\n        cursor.delete()\n        cursor.continue()\n        return\n      } else if (preprocessedRecord !== UpgradedDatabaseSchema.SKIP_RECORD) {\n        records.push({\n          key: primaryKey,\n          record: preprocessedRecord\n        })\n      } else {\n        // SKIP_RECORD returned, do nothing\n      }\n      \n      cursor.continue()\n    }).then(() => resolve(records)).catch(error => reject(error))\n  })\n}", "language": "javascript", "code": "function fetchRecords(objectStore, preprocessor) {\n  return new PromiseSync((resolve, reject) => {\n    let records = []\n    \n    objectStore.openCursor(null, CursorDirection.NEXT, (cursor) => {\n      let primaryKey = cursor.primaryKey\n      if (primaryKey instanceof Object) {\n        Object.freeze(primaryKey)\n      }\n      \n      let preprocessedRecord = preprocessor(cursor.record, primaryKey)\n      if (preprocessedRecord === UpgradedDatabaseSchema.DELETE_RECORD) {\n        cursor.delete()\n        cursor.continue()\n        return\n      } else if (preprocessedRecord !== UpgradedDatabaseSchema.SKIP_RECORD) {\n        records.push({\n          key: primaryKey,\n          record: preprocessedRecord\n        })\n      } else {\n        // SKIP_RECORD returned, do nothing\n      }\n      \n      cursor.continue()\n    }).then(() => resolve(records)).catch(error => reject(error))\n  })\n}", "code_tokens": ["function", "fetchRecords", "(", "objectStore", ",", "preprocessor", ")", "{", "return", "new", "PromiseSync", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "let", "records", "=", "[", "]", "objectStore", ".", "openCursor", "(", "null", ",", "CursorDirection", ".", "NEXT", ",", "(", "cursor", ")", "=>", "{", "let", "primaryKey", "=", "cursor", ".", "primaryKey", "if", "(", "primaryKey", "instanceof", "Object", ")", "{", "Object", ".", "freeze", "(", "primaryKey", ")", "}", "let", "preprocessedRecord", "=", "preprocessor", "(", "cursor", ".", "record", ",", "primaryKey", ")", "if", "(", "preprocessedRecord", "===", "UpgradedDatabaseSchema", ".", "DELETE_RECORD", ")", "{", "cursor", ".", "delete", "(", ")", "cursor", ".", "continue", "(", ")", "return", "}", "else", "if", "(", "preprocessedRecord", "!==", "UpgradedDatabaseSchema", ".", "SKIP_RECORD", ")", "{", "records", ".", "push", "(", "{", "key", ":", "primaryKey", ",", "record", ":", "preprocessedRecord", "}", ")", "}", "else", "{", "// SKIP_RECORD returned, do nothing", "}", "cursor", ".", "continue", "(", ")", "}", ")", ".", "then", "(", "(", ")", "=>", "resolve", "(", "records", ")", ")", ".", "catch", "(", "error", "=>", "reject", "(", "error", ")", ")", "}", ")", "}"], "docstring": "Extracts all records from the provided object store and preprocess them\nusing the provided preprocessor.\n\nThe method traverses the records of the object store in ascending order of\ntheir primary keys, deleting the records for which the preprocessor returns\nthe {@linkcode UpgradedDatabaseSchema.DELETE_RECORD} before traversing to\nthe next record.\n\n@param {ObjectStore} objectStore The read-write accessor the object store\nfrom which the records should be read.\n@param {function(*, (number|string|Date|Array)): (*|UpgradedDatabaseSchema.SKIP_RECORD|UpgradedDatabaseSchema.DELETE_RECORD)} preprocessor\nThe callback to call on each record. The value returned by it will be\nstored in the resulting record array instead of the original record.\nThe record will not be included in the resulting record array if the\npreprocessor returns {@linkcode UpgradedDatabaseSchema.SKIP_RECORD}\nor {@linkcode UpgradedDatabaseSchema.DELETE_RECORD}.\n@return {PromiseSync<{key: (number|string|Date|Array), record: *}[]>} A\npromise that resolves once all records in the object store have been\ntraversed. The promise will resolve to an array of the records\nprocessed by the provided record preprocessor, in the order they\nwere traversed, and not containing the records that the preprocessor\nmarked as to be skipped or deleted.", "docstring_tokens": ["Extracts", "all", "records", "from", "the", "provided", "object", "store", "and", "preprocess", "them", "using", "the", "provided", "preprocessor", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/migration/RecordFetcher.js#L108-L135", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(path) {\n    var split = path.split(':'),\n        propertyPath = split[0],\n        classNames = \"\",\n        className,\n        falsyClassName;\n\n    // check if the property is defined as prop:class or prop:trueClass:falseClass\n    if (split.length > 1) {\n      className = split[1];\n      if (split.length === 3) { falsyClassName = split[2]; }\n\n      classNames = ':' + className;\n      if (falsyClassName) { classNames += \":\" + falsyClassName; }\n    }\n\n    return {\n      path: propertyPath,\n      classNames: classNames,\n      className: (className === '') ? undefined : className,\n      falsyClassName: falsyClassName\n    };\n  }", "language": "javascript", "code": "function(path) {\n    var split = path.split(':'),\n        propertyPath = split[0],\n        classNames = \"\",\n        className,\n        falsyClassName;\n\n    // check if the property is defined as prop:class or prop:trueClass:falseClass\n    if (split.length > 1) {\n      className = split[1];\n      if (split.length === 3) { falsyClassName = split[2]; }\n\n      classNames = ':' + className;\n      if (falsyClassName) { classNames += \":\" + falsyClassName; }\n    }\n\n    return {\n      path: propertyPath,\n      classNames: classNames,\n      className: (className === '') ? undefined : className,\n      falsyClassName: falsyClassName\n    };\n  }", "code_tokens": ["function", "(", "path", ")", "{", "var", "split", "=", "path", ".", "split", "(", "':'", ")", ",", "propertyPath", "=", "split", "[", "0", "]", ",", "classNames", "=", "\"\"", ",", "className", ",", "falsyClassName", ";", "// check if the property is defined as prop:class or prop:trueClass:falseClass", "if", "(", "split", ".", "length", ">", "1", ")", "{", "className", "=", "split", "[", "1", "]", ";", "if", "(", "split", ".", "length", "===", "3", ")", "{", "falsyClassName", "=", "split", "[", "2", "]", ";", "}", "classNames", "=", "':'", "+", "className", ";", "if", "(", "falsyClassName", ")", "{", "classNames", "+=", "\":\"", "+", "falsyClassName", ";", "}", "}", "return", "{", "path", ":", "propertyPath", ",", "classNames", ":", "classNames", ",", "className", ":", "(", "className", "===", "''", ")", "?", "undefined", ":", "className", ",", "falsyClassName", ":", "falsyClassName", "}", ";", "}"], "docstring": "Parse a path and return an object which holds the parsed properties.\n\nFor example a path like \"content.isEnabled:enabled:disabled\" will return the\nfollowing object:\n\n```javascript\n{\npath: \"content.isEnabled\",\nclassName: \"enabled\",\nfalsyClassName: \"disabled\",\nclassNames: \":enabled:disabled\"\n}\n```\n\n@method _parsePropertyPath\n@static\n@private", "docstring_tokens": ["Parse", "a", "path", "and", "return", "an", "object", "which", "holds", "the", "parsed", "properties", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L24742-L24764", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "Inflector", "original_string": "function Inflector(ruleSet) {\n  ruleSet = ruleSet || {};\n  ruleSet.uncountable = ruleSet.uncountable || {};\n  ruleSet.irregularPairs = ruleSet.irregularPairs || {};\n\n  var rules = this.rules = {\n    plurals:  ruleSet.plurals || [],\n    singular: ruleSet.singular || [],\n    irregular: {},\n    irregularInverse: {},\n    uncountable: {}\n  };\n\n  loadUncountable(rules, ruleSet.uncountable);\n  loadIrregular(rules, ruleSet.irregularPairs);\n}", "language": "javascript", "code": "function Inflector(ruleSet) {\n  ruleSet = ruleSet || {};\n  ruleSet.uncountable = ruleSet.uncountable || {};\n  ruleSet.irregularPairs = ruleSet.irregularPairs || {};\n\n  var rules = this.rules = {\n    plurals:  ruleSet.plurals || [],\n    singular: ruleSet.singular || [],\n    irregular: {},\n    irregularInverse: {},\n    uncountable: {}\n  };\n\n  loadUncountable(rules, ruleSet.uncountable);\n  loadIrregular(rules, ruleSet.irregularPairs);\n}", "code_tokens": ["function", "Inflector", "(", "ruleSet", ")", "{", "ruleSet", "=", "ruleSet", "||", "{", "}", ";", "ruleSet", ".", "uncountable", "=", "ruleSet", ".", "uncountable", "||", "{", "}", ";", "ruleSet", ".", "irregularPairs", "=", "ruleSet", ".", "irregularPairs", "||", "{", "}", ";", "var", "rules", "=", "this", ".", "rules", "=", "{", "plurals", ":", "ruleSet", ".", "plurals", "||", "[", "]", ",", "singular", ":", "ruleSet", ".", "singular", "||", "[", "]", ",", "irregular", ":", "{", "}", ",", "irregularInverse", ":", "{", "}", ",", "uncountable", ":", "{", "}", "}", ";", "loadUncountable", "(", "rules", ",", "ruleSet", ".", "uncountable", ")", ";", "loadIrregular", "(", "rules", ",", "ruleSet", ".", "irregularPairs", ")", ";", "}"], "docstring": "Inflector.Ember provides a mechanism for supplying inflection rules for your\napplication. Ember includes a default set of inflection rules, and provides an\nAPI for providing additional rules.\n\nExamples:\n\nCreating an inflector with no rules.\n\n```js\nvar inflector = new Ember.Inflector();\n```\n\nCreating an inflector with the default ember ruleset.\n\n```js\nvar inflector = new Ember.Inflector(Ember.Inflector.defaultRules);\n\ninflector.pluralize('cow') //=> 'kine'\ninflector.singularize('kine') //=> 'cow'\n```\n\nCreating an inflector and adding rules later.\n\n```javascript\nvar inflector = Ember.Inflector.inflector;\n\ninflector.pluralize('advice') // => 'advices'\ninflector.uncountable('advice');\ninflector.pluralize('advice') // => 'advice'\n\ninflector.pluralize('formula') // => 'formulas'\ninflector.irregular('formula', 'formulae');\ninflector.pluralize('formula') // => 'formulae'\n\nyou would not need to add these as they are the default rules\ninflector.plural(/$/, 's');\ninflector.singular(/s$/i, '');\n```\n\nCreating an inflector with a nondefault ruleset.\n\n```javascript\nvar rules = {\nplurals:  [ /$/, 's' ],\nsingular: [ /\\s$/, '' ],\nirregularPairs: [\n[ 'cow', 'kine' ]\n],\nuncountable: [ 'fish' ]\n};\n\nvar inflector = new Ember.Inflector(rules);\n```\n\n@class Inflector\n@namespace Ember", "docstring_tokens": ["Inflector", ".", "Ember", "provides", "a", "mechanism", "for", "supplying", "inflection", "rules", "for", "your", "application", ".", "Ember", "includes", "a", "default", "set", "of", "inflection", "rules", "and", "provides", "an", "API", "for", "providing", "additional", "rules", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L9822-L9837", "partition": "test"}
{"repo": "beyo/model", "path": "lib/model.js", "func_name": "Model", "original_string": "function Model(data) {\n  var attributes = this.__proto__.constructor.attributes;\n  var i, ilen;\n  var dirty = false;\n\n  Object.defineProperties(this, {\n    _id: {\n      configurable: false,\n      enumerable: true,\n      writable: false,\n      value: ++uniqueId\n    },\n    _isDirty: {\n      configurable: false,\n      enumerable: true,\n      get: function isDirty() {\n        return dirty;\n      },\n      set: function isDirty(d) {\n        dirty = d;\n        if (!d && this._previousData) {\n          this._previousData = undefined;\n        }\n      }\n    },\n    _isNew: {\n      configurable: false,\n      enumerable: true,\n      get: function isNewModel() {\n        var newModel = false;\n        var attrValue;\n\n        if (this._primaryAttributes) {\n          for (i = 0, ilen = this._primaryAttributes.length; i < ilen && !newModel; ++i) {\n            attrValue = this[this._primaryAttributes[i]];\n\n            if ((attrValue === undefined) || (attrValue === null)) {\n              newModel = true;\n            }\n          }\n        }\n\n        return newModel;\n      }\n    }\n  });\n\n  if (attributes) {\n    Object.defineProperties(this, attributes);\n    Object.defineProperty(this, '_data', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: _defaultData(attributes)\n    });\n  }\n\n  if (Array.isArray(data)) {\n    for (i = 0, ilen = data.length; i < ilen; ++i) {\n      if (this._primaryAttributes[i]) {\n        this[this._primaryAttributes[i]] = data[i];\n      }\n    }\n  } else if (data) {\n    this.fromJSON(data);\n  }\n\n  this._isDirty = false; // overwrite...\n}", "language": "javascript", "code": "function Model(data) {\n  var attributes = this.__proto__.constructor.attributes;\n  var i, ilen;\n  var dirty = false;\n\n  Object.defineProperties(this, {\n    _id: {\n      configurable: false,\n      enumerable: true,\n      writable: false,\n      value: ++uniqueId\n    },\n    _isDirty: {\n      configurable: false,\n      enumerable: true,\n      get: function isDirty() {\n        return dirty;\n      },\n      set: function isDirty(d) {\n        dirty = d;\n        if (!d && this._previousData) {\n          this._previousData = undefined;\n        }\n      }\n    },\n    _isNew: {\n      configurable: false,\n      enumerable: true,\n      get: function isNewModel() {\n        var newModel = false;\n        var attrValue;\n\n        if (this._primaryAttributes) {\n          for (i = 0, ilen = this._primaryAttributes.length; i < ilen && !newModel; ++i) {\n            attrValue = this[this._primaryAttributes[i]];\n\n            if ((attrValue === undefined) || (attrValue === null)) {\n              newModel = true;\n            }\n          }\n        }\n\n        return newModel;\n      }\n    }\n  });\n\n  if (attributes) {\n    Object.defineProperties(this, attributes);\n    Object.defineProperty(this, '_data', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: _defaultData(attributes)\n    });\n  }\n\n  if (Array.isArray(data)) {\n    for (i = 0, ilen = data.length; i < ilen; ++i) {\n      if (this._primaryAttributes[i]) {\n        this[this._primaryAttributes[i]] = data[i];\n      }\n    }\n  } else if (data) {\n    this.fromJSON(data);\n  }\n\n  this._isDirty = false; // overwrite...\n}", "code_tokens": ["function", "Model", "(", "data", ")", "{", "var", "attributes", "=", "this", ".", "__proto__", ".", "constructor", ".", "attributes", ";", "var", "i", ",", "ilen", ";", "var", "dirty", "=", "false", ";", "Object", ".", "defineProperties", "(", "this", ",", "{", "_id", ":", "{", "configurable", ":", "false", ",", "enumerable", ":", "true", ",", "writable", ":", "false", ",", "value", ":", "++", "uniqueId", "}", ",", "_isDirty", ":", "{", "configurable", ":", "false", ",", "enumerable", ":", "true", ",", "get", ":", "function", "isDirty", "(", ")", "{", "return", "dirty", ";", "}", ",", "set", ":", "function", "isDirty", "(", "d", ")", "{", "dirty", "=", "d", ";", "if", "(", "!", "d", "&&", "this", ".", "_previousData", ")", "{", "this", ".", "_previousData", "=", "undefined", ";", "}", "}", "}", ",", "_isNew", ":", "{", "configurable", ":", "false", ",", "enumerable", ":", "true", ",", "get", ":", "function", "isNewModel", "(", ")", "{", "var", "newModel", "=", "false", ";", "var", "attrValue", ";", "if", "(", "this", ".", "_primaryAttributes", ")", "{", "for", "(", "i", "=", "0", ",", "ilen", "=", "this", ".", "_primaryAttributes", ".", "length", ";", "i", "<", "ilen", "&&", "!", "newModel", ";", "++", "i", ")", "{", "attrValue", "=", "this", "[", "this", ".", "_primaryAttributes", "[", "i", "]", "]", ";", "if", "(", "(", "attrValue", "===", "undefined", ")", "||", "(", "attrValue", "===", "null", ")", ")", "{", "newModel", "=", "true", ";", "}", "}", "}", "return", "newModel", ";", "}", "}", "}", ")", ";", "if", "(", "attributes", ")", "{", "Object", ".", "defineProperties", "(", "this", ",", "attributes", ")", ";", "Object", ".", "defineProperty", "(", "this", ",", "'_data'", ",", "{", "configurable", ":", "false", ",", "enumerable", ":", "false", ",", "writable", ":", "false", ",", "value", ":", "_defaultData", "(", "attributes", ")", "}", ")", ";", "}", "if", "(", "Array", ".", "isArray", "(", "data", ")", ")", "{", "for", "(", "i", "=", "0", ",", "ilen", "=", "data", ".", "length", ";", "i", "<", "ilen", ";", "++", "i", ")", "{", "if", "(", "this", ".", "_primaryAttributes", "[", "i", "]", ")", "{", "this", "[", "this", ".", "_primaryAttributes", "[", "i", "]", "]", "=", "data", "[", "i", "]", ";", "}", "}", "}", "else", "if", "(", "data", ")", "{", "this", ".", "fromJSON", "(", "data", ")", ";", "}", "this", ".", "_isDirty", "=", "false", ";", "// overwrite...", "}"], "docstring": "Base Model function constructor\n\n@param {Object} data      the model data", "docstring_tokens": ["Base", "Model", "function", "constructor"], "sha": "625b386b6e1141e1869ede753640850c0c9f0971", "url": "https://github.com/beyo/model/blob/625b386b6e1141e1869ede753640850c0c9f0971/lib/model.js#L439-L507", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( key, options, refresh ) {\n\t\t\t// Set default `options` for fetch\n\t\t\toptions = _.extend( { update: true, remove: false }, options );\n\n\t\t\tvar setUrl,\n\t\t\t\trequests = [],\n\t\t\t\trel = this.getRelation( key ),\n\t\t\t\tidsToFetch = rel && ( ( rel.keyIds && rel.keyIds.slice( 0 ) ) || ( ( rel.keyId || rel.keyId === 0 ) ? [ rel.keyId ] : [] ) );\n\n\t\t\t// On `refresh`, add the ids for current models in the relation to `idsToFetch`\n\t\t\tif ( refresh ) {\n\t\t\t\tvar models = rel.related instanceof Backbone.Collection ? rel.related.models : [ rel.related ];\n\t\t\t\t_.each( models, function( model ) {\n\t\t\t\t\tif ( model.id || model.id === 0 ) {\n\t\t\t\t\t\tidsToFetch.push( model.id );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( idsToFetch && idsToFetch.length ) {\n\t\t\t\t// Find (or create) a model for each one that is to be fetched\n\t\t\t\tvar created = [],\n\t\t\t\t\tmodels = _.map( idsToFetch, function( id ) {\n\t\t\t\t\t\tvar model = Backbone.Relational.store.find( rel.relatedModel, id );\n\n\t\t\t\t\t\tif ( !model ) {\n\t\t\t\t\t\t\tvar attrs = {};\n\t\t\t\t\t\t\tattrs[ rel.relatedModel.prototype.idAttribute ] = id;\n\t\t\t\t\t\t\tmodel = rel.relatedModel.findOrCreate( attrs, options );\n\t\t\t\t\t\t\tcreated.push( model );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn model;\n\t\t\t\t\t}, this );\n\n\t\t\t\t// Try if the 'collection' can provide a url to fetch a set of models in one request.\n\t\t\t\tif ( rel.related instanceof Backbone.Collection && _.isFunction( rel.related.url ) ) {\n\t\t\t\t\tsetUrl = rel.related.url( models );\n\t\t\t\t}\n\n\t\t\t\t// An assumption is that when 'Backbone.Collection.url' is a function, it can handle building of set urls.\n\t\t\t\t// To make sure it can, test if the url we got by supplying a list of models to fetch is different from\n\t\t\t\t// the one supplied for the default fetch action (without args to 'url').\n\t\t\t\tif ( setUrl && setUrl !== rel.related.url() ) {\n\t\t\t\t\tvar opts = _.defaults(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\t\tvar args = arguments;\n\t\t\t\t\t\t\t\t_.each( created, function( model ) {\n\t\t\t\t\t\t\t\t\tmodel.trigger( 'destroy', model, model.collection, options );\n\t\t\t\t\t\t\t\t\toptions.error && options.error.apply( model, args );\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\turl: setUrl\n\t\t\t\t\t\t},\n\t\t\t\t\t\toptions\n\t\t\t\t\t);\n\n\t\t\t\t\trequests = [ rel.related.fetch( opts ) ];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trequests = _.map( models, function( model ) {\n\t\t\t\t\t\tvar opts = _.defaults(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\t\t\tif ( _.contains( created, model ) ) {\n\t\t\t\t\t\t\t\t\t\tmodel.trigger( 'destroy', model, model.collection, options );\n\t\t\t\t\t\t\t\t\t\toptions.error && options.error.apply( model, arguments );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn model.fetch( opts );\n\t\t\t\t\t}, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn requests;\n\t\t}", "language": "javascript", "code": "function( key, options, refresh ) {\n\t\t\t// Set default `options` for fetch\n\t\t\toptions = _.extend( { update: true, remove: false }, options );\n\n\t\t\tvar setUrl,\n\t\t\t\trequests = [],\n\t\t\t\trel = this.getRelation( key ),\n\t\t\t\tidsToFetch = rel && ( ( rel.keyIds && rel.keyIds.slice( 0 ) ) || ( ( rel.keyId || rel.keyId === 0 ) ? [ rel.keyId ] : [] ) );\n\n\t\t\t// On `refresh`, add the ids for current models in the relation to `idsToFetch`\n\t\t\tif ( refresh ) {\n\t\t\t\tvar models = rel.related instanceof Backbone.Collection ? rel.related.models : [ rel.related ];\n\t\t\t\t_.each( models, function( model ) {\n\t\t\t\t\tif ( model.id || model.id === 0 ) {\n\t\t\t\t\t\tidsToFetch.push( model.id );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( idsToFetch && idsToFetch.length ) {\n\t\t\t\t// Find (or create) a model for each one that is to be fetched\n\t\t\t\tvar created = [],\n\t\t\t\t\tmodels = _.map( idsToFetch, function( id ) {\n\t\t\t\t\t\tvar model = Backbone.Relational.store.find( rel.relatedModel, id );\n\n\t\t\t\t\t\tif ( !model ) {\n\t\t\t\t\t\t\tvar attrs = {};\n\t\t\t\t\t\t\tattrs[ rel.relatedModel.prototype.idAttribute ] = id;\n\t\t\t\t\t\t\tmodel = rel.relatedModel.findOrCreate( attrs, options );\n\t\t\t\t\t\t\tcreated.push( model );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn model;\n\t\t\t\t\t}, this );\n\n\t\t\t\t// Try if the 'collection' can provide a url to fetch a set of models in one request.\n\t\t\t\tif ( rel.related instanceof Backbone.Collection && _.isFunction( rel.related.url ) ) {\n\t\t\t\t\tsetUrl = rel.related.url( models );\n\t\t\t\t}\n\n\t\t\t\t// An assumption is that when 'Backbone.Collection.url' is a function, it can handle building of set urls.\n\t\t\t\t// To make sure it can, test if the url we got by supplying a list of models to fetch is different from\n\t\t\t\t// the one supplied for the default fetch action (without args to 'url').\n\t\t\t\tif ( setUrl && setUrl !== rel.related.url() ) {\n\t\t\t\t\tvar opts = _.defaults(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\t\tvar args = arguments;\n\t\t\t\t\t\t\t\t_.each( created, function( model ) {\n\t\t\t\t\t\t\t\t\tmodel.trigger( 'destroy', model, model.collection, options );\n\t\t\t\t\t\t\t\t\toptions.error && options.error.apply( model, args );\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\turl: setUrl\n\t\t\t\t\t\t},\n\t\t\t\t\t\toptions\n\t\t\t\t\t);\n\n\t\t\t\t\trequests = [ rel.related.fetch( opts ) ];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trequests = _.map( models, function( model ) {\n\t\t\t\t\t\tvar opts = _.defaults(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\t\t\tif ( _.contains( created, model ) ) {\n\t\t\t\t\t\t\t\t\t\tmodel.trigger( 'destroy', model, model.collection, options );\n\t\t\t\t\t\t\t\t\t\toptions.error && options.error.apply( model, arguments );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn model.fetch( opts );\n\t\t\t\t\t}, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn requests;\n\t\t}", "code_tokens": ["function", "(", "key", ",", "options", ",", "refresh", ")", "{", "// Set default `options` for fetch", "options", "=", "_", ".", "extend", "(", "{", "update", ":", "true", ",", "remove", ":", "false", "}", ",", "options", ")", ";", "var", "setUrl", ",", "requests", "=", "[", "]", ",", "rel", "=", "this", ".", "getRelation", "(", "key", ")", ",", "idsToFetch", "=", "rel", "&&", "(", "(", "rel", ".", "keyIds", "&&", "rel", ".", "keyIds", ".", "slice", "(", "0", ")", ")", "||", "(", "(", "rel", ".", "keyId", "||", "rel", ".", "keyId", "===", "0", ")", "?", "[", "rel", ".", "keyId", "]", ":", "[", "]", ")", ")", ";", "// On `refresh`, add the ids for current models in the relation to `idsToFetch`", "if", "(", "refresh", ")", "{", "var", "models", "=", "rel", ".", "related", "instanceof", "Backbone", ".", "Collection", "?", "rel", ".", "related", ".", "models", ":", "[", "rel", ".", "related", "]", ";", "_", ".", "each", "(", "models", ",", "function", "(", "model", ")", "{", "if", "(", "model", ".", "id", "||", "model", ".", "id", "===", "0", ")", "{", "idsToFetch", ".", "push", "(", "model", ".", "id", ")", ";", "}", "}", ")", ";", "}", "if", "(", "idsToFetch", "&&", "idsToFetch", ".", "length", ")", "{", "// Find (or create) a model for each one that is to be fetched", "var", "created", "=", "[", "]", ",", "models", "=", "_", ".", "map", "(", "idsToFetch", ",", "function", "(", "id", ")", "{", "var", "model", "=", "Backbone", ".", "Relational", ".", "store", ".", "find", "(", "rel", ".", "relatedModel", ",", "id", ")", ";", "if", "(", "!", "model", ")", "{", "var", "attrs", "=", "{", "}", ";", "attrs", "[", "rel", ".", "relatedModel", ".", "prototype", ".", "idAttribute", "]", "=", "id", ";", "model", "=", "rel", ".", "relatedModel", ".", "findOrCreate", "(", "attrs", ",", "options", ")", ";", "created", ".", "push", "(", "model", ")", ";", "}", "return", "model", ";", "}", ",", "this", ")", ";", "// Try if the 'collection' can provide a url to fetch a set of models in one request.", "if", "(", "rel", ".", "related", "instanceof", "Backbone", ".", "Collection", "&&", "_", ".", "isFunction", "(", "rel", ".", "related", ".", "url", ")", ")", "{", "setUrl", "=", "rel", ".", "related", ".", "url", "(", "models", ")", ";", "}", "// An assumption is that when 'Backbone.Collection.url' is a function, it can handle building of set urls.", "// To make sure it can, test if the url we got by supplying a list of models to fetch is different from", "// the one supplied for the default fetch action (without args to 'url').", "if", "(", "setUrl", "&&", "setUrl", "!==", "rel", ".", "related", ".", "url", "(", ")", ")", "{", "var", "opts", "=", "_", ".", "defaults", "(", "{", "error", ":", "function", "(", ")", "{", "var", "args", "=", "arguments", ";", "_", ".", "each", "(", "created", ",", "function", "(", "model", ")", "{", "model", ".", "trigger", "(", "'destroy'", ",", "model", ",", "model", ".", "collection", ",", "options", ")", ";", "options", ".", "error", "&&", "options", ".", "error", ".", "apply", "(", "model", ",", "args", ")", ";", "}", ")", ";", "}", ",", "url", ":", "setUrl", "}", ",", "options", ")", ";", "requests", "=", "[", "rel", ".", "related", ".", "fetch", "(", "opts", ")", "]", ";", "}", "else", "{", "requests", "=", "_", ".", "map", "(", "models", ",", "function", "(", "model", ")", "{", "var", "opts", "=", "_", ".", "defaults", "(", "{", "error", ":", "function", "(", ")", "{", "if", "(", "_", ".", "contains", "(", "created", ",", "model", ")", ")", "{", "model", ".", "trigger", "(", "'destroy'", ",", "model", ",", "model", ".", "collection", ",", "options", ")", ";", "options", ".", "error", "&&", "options", ".", "error", ".", "apply", "(", "model", ",", "arguments", ")", ";", "}", "}", "}", ",", "options", ")", ";", "return", "model", ".", "fetch", "(", "opts", ")", ";", "}", ",", "this", ")", ";", "}", "}", "return", "requests", ";", "}"], "docstring": "Retrieve related objects.\n@param key {string} The relation key to fetch models for.\n@param [options] {Object} Options for 'Backbone.Model.fetch' and 'Backbone.sync'.\n@param [refresh=false] {boolean} Fetch existing models from the server as well (in order to update them).\n@return {jQuery.when[]} An array of request objects", "docstring_tokens": ["Retrieve", "related", "objects", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L1275-L1354", "partition": "test"}
{"repo": "GitbookIO/theme-default", "path": "src/js/theme/toolbar.js", "func_name": "insertAt", "original_string": "function insertAt(parent, selector, index, element) {\n    var lastIndex = parent.children(selector).length;\n    if (index < 0) {\n        index = Math.max(0, lastIndex + 1 + index);\n    }\n    parent.append(element);\n\n    if (index < lastIndex) {\n        parent.children(selector).eq(index).before(parent.children(selector).last());\n    }\n}", "language": "javascript", "code": "function insertAt(parent, selector, index, element) {\n    var lastIndex = parent.children(selector).length;\n    if (index < 0) {\n        index = Math.max(0, lastIndex + 1 + index);\n    }\n    parent.append(element);\n\n    if (index < lastIndex) {\n        parent.children(selector).eq(index).before(parent.children(selector).last());\n    }\n}", "code_tokens": ["function", "insertAt", "(", "parent", ",", "selector", ",", "index", ",", "element", ")", "{", "var", "lastIndex", "=", "parent", ".", "children", "(", "selector", ")", ".", "length", ";", "if", "(", "index", "<", "0", ")", "{", "index", "=", "Math", ".", "max", "(", "0", ",", "lastIndex", "+", "1", "+", "index", ")", ";", "}", "parent", ".", "append", "(", "element", ")", ";", "if", "(", "index", "<", "lastIndex", ")", "{", "parent", ".", "children", "(", "selector", ")", ".", "eq", "(", "index", ")", ".", "before", "(", "parent", ".", "children", "(", "selector", ")", ".", "last", "(", ")", ")", ";", "}", "}"], "docstring": "Insert a jquery element at a specific position", "docstring_tokens": ["Insert", "a", "jquery", "element", "at", "a", "specific", "position"], "sha": "a8e920453dc8e4eb522840b61606486622848099", "url": "https://github.com/GitbookIO/theme-default/blob/a8e920453dc8e4eb522840b61606486622848099/src/js/theme/toolbar.js#L15-L25", "partition": "test"}
{"repo": "integreat-io/integreat", "path": "lib/actions/set.js", "func_name": "set", "original_string": "async function set (action, { getService, schemas }) {\n  debug('Action: SET')\n\n  const { service: serviceId, data, endpoint, onlyMappedValues = true } = action.payload\n  const type = extractType(action, data)\n  const id = extractId(data)\n\n  const service = getService(type, serviceId)\n  if (!service) {\n    return createUnknownServiceError(type, serviceId, 'SET')\n  }\n\n  const endpointDebug = (endpoint) ? `at endpoint '${endpoint}'` : ''\n  debug('SET: Send to service %s %s', service.id, endpointDebug)\n\n  const { response, authorizedRequestData } = await service.send(appendToAction(action, { id, type, onlyMappedValues }))\n\n  return mergeRequestAndResponseData(response, authorizedRequestData)\n}", "language": "javascript", "code": "async function set (action, { getService, schemas }) {\n  debug('Action: SET')\n\n  const { service: serviceId, data, endpoint, onlyMappedValues = true } = action.payload\n  const type = extractType(action, data)\n  const id = extractId(data)\n\n  const service = getService(type, serviceId)\n  if (!service) {\n    return createUnknownServiceError(type, serviceId, 'SET')\n  }\n\n  const endpointDebug = (endpoint) ? `at endpoint '${endpoint}'` : ''\n  debug('SET: Send to service %s %s', service.id, endpointDebug)\n\n  const { response, authorizedRequestData } = await service.send(appendToAction(action, { id, type, onlyMappedValues }))\n\n  return mergeRequestAndResponseData(response, authorizedRequestData)\n}", "code_tokens": ["async", "function", "set", "(", "action", ",", "{", "getService", ",", "schemas", "}", ")", "{", "debug", "(", "'Action: SET'", ")", "const", "{", "service", ":", "serviceId", ",", "data", ",", "endpoint", ",", "onlyMappedValues", "=", "true", "}", "=", "action", ".", "payload", "const", "type", "=", "extractType", "(", "action", ",", "data", ")", "const", "id", "=", "extractId", "(", "data", ")", "const", "service", "=", "getService", "(", "type", ",", "serviceId", ")", "if", "(", "!", "service", ")", "{", "return", "createUnknownServiceError", "(", "type", ",", "serviceId", ",", "'SET'", ")", "}", "const", "endpointDebug", "=", "(", "endpoint", ")", "?", "`", "${", "endpoint", "}", "`", ":", "''", "debug", "(", "'SET: Send to service %s %s'", ",", "service", ".", "id", ",", "endpointDebug", ")", "const", "{", "response", ",", "authorizedRequestData", "}", "=", "await", "service", ".", "send", "(", "appendToAction", "(", "action", ",", "{", "id", ",", "type", ",", "onlyMappedValues", "}", ")", ")", "return", "mergeRequestAndResponseData", "(", "response", ",", "authorizedRequestData", ")", "}"], "docstring": "Set several items to a service, based on the given action object.\n@param {Object} payload - Payload from action object\n@param {Object} resources - Object with getService\n@returns {Object} Response object with any data returned from the service", "docstring_tokens": ["Set", "several", "items", "to", "a", "service", "based", "on", "the", "given", "action", "object", "."], "sha": "b3092036bfd40d74a082297cace1f678502427c6", "url": "https://github.com/integreat-io/integreat/blob/b3092036bfd40d74a082297cace1f678502427c6/lib/actions/set.js#L37-L55", "partition": "test"}
{"repo": "JedWatson/asyncdi", "path": "index.js", "func_name": "", "original_string": "function(provides) {\n\t\tif (_.isArray(provides)) {\n\t\t\tthis._arguments = this._provides = (!this._provides) ? provides : this._provides.concat(provides);\n\t\t} else {\n\t\t\tthis._provides = _.extend({}, this._provides, provides);\n\t\t\tthis._arguments = _.map(this.deps, function(key) {\n\t\t\t\treturn this._provides[key];\n\t\t\t}, this);\n\t\t}\n\t\treturn this;\n\t}", "language": "javascript", "code": "function(provides) {\n\t\tif (_.isArray(provides)) {\n\t\t\tthis._arguments = this._provides = (!this._provides) ? provides : this._provides.concat(provides);\n\t\t} else {\n\t\t\tthis._provides = _.extend({}, this._provides, provides);\n\t\t\tthis._arguments = _.map(this.deps, function(key) {\n\t\t\t\treturn this._provides[key];\n\t\t\t}, this);\n\t\t}\n\t\treturn this;\n\t}", "code_tokens": ["function", "(", "provides", ")", "{", "if", "(", "_", ".", "isArray", "(", "provides", ")", ")", "{", "this", ".", "_arguments", "=", "this", ".", "_provides", "=", "(", "!", "this", ".", "_provides", ")", "?", "provides", ":", "this", ".", "_provides", ".", "concat", "(", "provides", ")", ";", "}", "else", "{", "this", ".", "_provides", "=", "_", ".", "extend", "(", "{", "}", ",", "this", ".", "_provides", ",", "provides", ")", ";", "this", ".", "_arguments", "=", "_", ".", "map", "(", "this", ".", "deps", ",", "function", "(", "key", ")", "{", "return", "this", ".", "_provides", "[", "key", "]", ";", "}", ",", "this", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Registers dependencies that can be provided to the function\n@param  {Object|Array} provides map of key: value pairs or an array of values\n@return {Wrapper} this instance", "docstring_tokens": ["Registers", "dependencies", "that", "can", "be", "provided", "to", "the", "function"], "sha": "4e9dd53ded83b65fc96f07fd9347931a1c82b302", "url": "https://github.com/JedWatson/asyncdi/blob/4e9dd53ded83b65fc96f07fd9347931a1c82b302/index.js#L94-L104", "partition": "test"}
{"repo": "multiformats/js-multistream-select", "path": "src/listener/match-exact.js", "func_name": "matchExact", "original_string": "function matchExact (myProtocol, senderProtocol, callback) {\n  const result = myProtocol === senderProtocol\n  callback(null, result)\n}", "language": "javascript", "code": "function matchExact (myProtocol, senderProtocol, callback) {\n  const result = myProtocol === senderProtocol\n  callback(null, result)\n}", "code_tokens": ["function", "matchExact", "(", "myProtocol", ",", "senderProtocol", ",", "callback", ")", "{", "const", "result", "=", "myProtocol", "===", "senderProtocol", "callback", "(", "null", ",", "result", ")", "}"], "docstring": "Match protocols exactly.\n\n@param {string} myProtocol\n@param {string} senderProtocol\n@param {function(Error, boolean)} callback\n@returns {undefined}\n@type {matchHandler}", "docstring_tokens": ["Match", "protocols", "exactly", "."], "sha": "9854a1de5f44249a5d75a193f9033b4067403142", "url": "https://github.com/multiformats/js-multistream-select/blob/9854a1de5f44249a5d75a193f9033b4067403142/src/listener/match-exact.js#L12-L15", "partition": "test"}
{"repo": "base/base-config", "path": "index.js", "func_name": "create", "original_string": "function create(prop) {\n  if (typeof prop !== 'string') {\n    throw new Error('expected the first argument to be a string.');\n  }\n\n  return function(app) {\n    if (this.isRegistered('base-' + prop)) return;\n\n    // map config\n    var config = utils.mapper(app)\n      // store/data\n      .map('store', store(app.store))\n      .map('data')\n\n      // options\n      .map('enable')\n      .map('disable')\n      .map('option')\n      .alias('options', 'option')\n\n      // get/set\n      .map('set')\n      .map('del')\n\n    // Expose `prop` (config) on the instance\n    app.define(prop, proxy(config));\n\n    // Expose `process` on app[prop]\n    app[prop].process = config.process;\n  };\n\n  function store(app) {\n    if (!app) return {};\n    var mapper = utils.mapper(app);\n    app.define(prop, proxy(mapper));\n    return mapper;\n  }\n}", "language": "javascript", "code": "function create(prop) {\n  if (typeof prop !== 'string') {\n    throw new Error('expected the first argument to be a string.');\n  }\n\n  return function(app) {\n    if (this.isRegistered('base-' + prop)) return;\n\n    // map config\n    var config = utils.mapper(app)\n      // store/data\n      .map('store', store(app.store))\n      .map('data')\n\n      // options\n      .map('enable')\n      .map('disable')\n      .map('option')\n      .alias('options', 'option')\n\n      // get/set\n      .map('set')\n      .map('del')\n\n    // Expose `prop` (config) on the instance\n    app.define(prop, proxy(config));\n\n    // Expose `process` on app[prop]\n    app[prop].process = config.process;\n  };\n\n  function store(app) {\n    if (!app) return {};\n    var mapper = utils.mapper(app);\n    app.define(prop, proxy(mapper));\n    return mapper;\n  }\n}", "code_tokens": ["function", "create", "(", "prop", ")", "{", "if", "(", "typeof", "prop", "!==", "'string'", ")", "{", "throw", "new", "Error", "(", "'expected the first argument to be a string.'", ")", ";", "}", "return", "function", "(", "app", ")", "{", "if", "(", "this", ".", "isRegistered", "(", "'base-'", "+", "prop", ")", ")", "return", ";", "// map config", "var", "config", "=", "utils", ".", "mapper", "(", "app", ")", "// store/data", ".", "map", "(", "'store'", ",", "store", "(", "app", ".", "store", ")", ")", ".", "map", "(", "'data'", ")", "// options", ".", "map", "(", "'enable'", ")", ".", "map", "(", "'disable'", ")", ".", "map", "(", "'option'", ")", ".", "alias", "(", "'options'", ",", "'option'", ")", "// get/set", ".", "map", "(", "'set'", ")", ".", "map", "(", "'del'", ")", "// Expose `prop` (config) on the instance", "app", ".", "define", "(", "prop", ",", "proxy", "(", "config", ")", ")", ";", "// Expose `process` on app[prop]", "app", "[", "prop", "]", ".", "process", "=", "config", ".", "process", ";", "}", ";", "function", "store", "(", "app", ")", "{", "if", "(", "!", "app", ")", "return", "{", "}", ";", "var", "mapper", "=", "utils", ".", "mapper", "(", "app", ")", ";", "app", ".", "define", "(", "prop", ",", "proxy", "(", "mapper", ")", ")", ";", "return", "mapper", ";", "}", "}"], "docstring": "Create a function for mapping `app` properties onto the\ngiven `prop` namespace.\n\n@param {String} `prop` The namespace to use\n@param {Object} `argv`\n@return {Object}\n@api public", "docstring_tokens": ["Create", "a", "function", "for", "mapping", "app", "properties", "onto", "the", "given", "prop", "namespace", "."], "sha": "c0be0dd8216c0b4ae1c11c785beee4017f69b411", "url": "https://github.com/base/base-config/blob/c0be0dd8216c0b4ae1c11c785beee4017f69b411/index.js#L30-L67", "partition": "test"}
{"repo": "unfoldingWord-dev/node-resource-container", "path": "lib/main.js", "func_name": "inspectContainer", "original_string": "function inspectContainer(container_path, opts) {\n    return new Promise(function(resolve, reject) {\n            if(path.extname(container_path) !== '.' + spec.file_ext) {\n                reject(new Error('Invalid resource container file extension'));\n                return;\n            }\n            try {\n                resolve(fs.statSync(container_path).isFile());\n            } catch(err) {\n                reject(new Error('The resource container does not exist at', container_path));\n            }\n        })\n        .then(function(isFile) {\n            if(isFile) {\n                // TODO: For now we are just opening the container then closing it.\n                // Eventually it would be nice if we can inspect the archive without extracting everything.\n                let containerDir = path.join(path.dirname(container_path), path.basename(container_path, '.' + spec.file_ext));\n                return openContainer(container_path, containerDir, opts)\n                    .then(function(container) {\n                        return closeContainer(containerDir, opts)\n                            .then(function() {\n                                return Promise.resolve(container.info);\n                            });\n                    });\n            } else {\n                loadContainer(container_path)\n                    .then(function(container) {\n                        return Promise.resolve(container.info);\n                    });\n            }\n        });\n}", "language": "javascript", "code": "function inspectContainer(container_path, opts) {\n    return new Promise(function(resolve, reject) {\n            if(path.extname(container_path) !== '.' + spec.file_ext) {\n                reject(new Error('Invalid resource container file extension'));\n                return;\n            }\n            try {\n                resolve(fs.statSync(container_path).isFile());\n            } catch(err) {\n                reject(new Error('The resource container does not exist at', container_path));\n            }\n        })\n        .then(function(isFile) {\n            if(isFile) {\n                // TODO: For now we are just opening the container then closing it.\n                // Eventually it would be nice if we can inspect the archive without extracting everything.\n                let containerDir = path.join(path.dirname(container_path), path.basename(container_path, '.' + spec.file_ext));\n                return openContainer(container_path, containerDir, opts)\n                    .then(function(container) {\n                        return closeContainer(containerDir, opts)\n                            .then(function() {\n                                return Promise.resolve(container.info);\n                            });\n                    });\n            } else {\n                loadContainer(container_path)\n                    .then(function(container) {\n                        return Promise.resolve(container.info);\n                    });\n            }\n        });\n}", "code_tokens": ["function", "inspectContainer", "(", "container_path", ",", "opts", ")", "{", "return", "new", "Promise", "(", "function", "(", "resolve", ",", "reject", ")", "{", "if", "(", "path", ".", "extname", "(", "container_path", ")", "!==", "'.'", "+", "spec", ".", "file_ext", ")", "{", "reject", "(", "new", "Error", "(", "'Invalid resource container file extension'", ")", ")", ";", "return", ";", "}", "try", "{", "resolve", "(", "fs", ".", "statSync", "(", "container_path", ")", ".", "isFile", "(", ")", ")", ";", "}", "catch", "(", "err", ")", "{", "reject", "(", "new", "Error", "(", "'The resource container does not exist at'", ",", "container_path", ")", ")", ";", "}", "}", ")", ".", "then", "(", "function", "(", "isFile", ")", "{", "if", "(", "isFile", ")", "{", "// TODO: For now we are just opening the container then closing it.", "// Eventually it would be nice if we can inspect the archive without extracting everything.", "let", "containerDir", "=", "path", ".", "join", "(", "path", ".", "dirname", "(", "container_path", ")", ",", "path", ".", "basename", "(", "container_path", ",", "'.'", "+", "spec", ".", "file_ext", ")", ")", ";", "return", "openContainer", "(", "container_path", ",", "containerDir", ",", "opts", ")", ".", "then", "(", "function", "(", "container", ")", "{", "return", "closeContainer", "(", "containerDir", ",", "opts", ")", ".", "then", "(", "function", "(", ")", "{", "return", "Promise", ".", "resolve", "(", "container", ".", "info", ")", ";", "}", ")", ";", "}", ")", ";", "}", "else", "{", "loadContainer", "(", "container_path", ")", ".", "then", "(", "function", "(", "container", ")", "{", "return", "Promise", ".", "resolve", "(", "container", ".", "info", ")", ";", "}", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Reads the resource container info without opening it.\nThis will however, work on containers that are both open and closed.\n\n@param container_path {string} path to the container archive or directory\n@param opts {{}}\n@returns {Promise.<{}>} the resource container info (package.json)", "docstring_tokens": ["Reads", "the", "resource", "container", "info", "without", "opening", "it", ".", "This", "will", "however", "work", "on", "containers", "that", "are", "both", "open", "and", "closed", "."], "sha": "20c4b7bfd2fa3f397ee7e0e743567822912c305b", "url": "https://github.com/unfoldingWord-dev/node-resource-container/blob/20c4b7bfd2fa3f397ee7e0e743567822912c305b/lib/main.js#L747-L778", "partition": "test"}
{"repo": "atom/clear-cut", "path": "index.js", "func_name": "", "original_string": "function(selector) {\n  var commaIndex = selector.indexOf(',');\n  if (commaIndex !== -1) {\n    selector = selector.substring(0, commaIndex);\n  }\n\n  var  types = {\n    a: 0,\n    b: 0,\n    c: 0\n  };\n\n  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument\n  selector = selector.replace(notRegex, ' $1 ');\n\n  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector\n  selector = selector.replace(ruleRegex, ' ');\n\n  // Add attribute selectors to parts collection (type b)\n  selector = findMatch(attributeRegex, 'b', types, selector);\n\n  // Add ID selectors to parts collection (type a)\n  selector = findMatch(idRegex, 'a', types, selector);\n\n  // Add class selectors to parts collection (type b)\n  selector = findMatch(classRegex, 'b', types, selector);\n\n  // Add pseudo-element selectors to parts collection (type c)\n  selector = findMatch(pseudoElementRegex, 'c', types, selector);\n\n  // Add pseudo-class selectors to parts collection (type b)\n  selector = findMatch(pseudoClassRegex, 'b', types, selector);\n\n  // Remove universal selector and separator characters\n  selector = selector.replace(separatorRegex, ' ');\n\n  // Remove any stray dots or hashes which aren't attached to words\n  // These may be present if the user is live-editing this selector\n  selector = selector.replace(straysRegex, ' ');\n\n  // The only things left should be element selectors (type c)\n  findMatch(elementRegex, 'c', types, selector);\n\n  return (types.a * 100) + (types.b * 10) + (types.c * 1);\n}", "language": "javascript", "code": "function(selector) {\n  var commaIndex = selector.indexOf(',');\n  if (commaIndex !== -1) {\n    selector = selector.substring(0, commaIndex);\n  }\n\n  var  types = {\n    a: 0,\n    b: 0,\n    c: 0\n  };\n\n  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument\n  selector = selector.replace(notRegex, ' $1 ');\n\n  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector\n  selector = selector.replace(ruleRegex, ' ');\n\n  // Add attribute selectors to parts collection (type b)\n  selector = findMatch(attributeRegex, 'b', types, selector);\n\n  // Add ID selectors to parts collection (type a)\n  selector = findMatch(idRegex, 'a', types, selector);\n\n  // Add class selectors to parts collection (type b)\n  selector = findMatch(classRegex, 'b', types, selector);\n\n  // Add pseudo-element selectors to parts collection (type c)\n  selector = findMatch(pseudoElementRegex, 'c', types, selector);\n\n  // Add pseudo-class selectors to parts collection (type b)\n  selector = findMatch(pseudoClassRegex, 'b', types, selector);\n\n  // Remove universal selector and separator characters\n  selector = selector.replace(separatorRegex, ' ');\n\n  // Remove any stray dots or hashes which aren't attached to words\n  // These may be present if the user is live-editing this selector\n  selector = selector.replace(straysRegex, ' ');\n\n  // The only things left should be element selectors (type c)\n  findMatch(elementRegex, 'c', types, selector);\n\n  return (types.a * 100) + (types.b * 10) + (types.c * 1);\n}", "code_tokens": ["function", "(", "selector", ")", "{", "var", "commaIndex", "=", "selector", ".", "indexOf", "(", "','", ")", ";", "if", "(", "commaIndex", "!==", "-", "1", ")", "{", "selector", "=", "selector", ".", "substring", "(", "0", ",", "commaIndex", ")", ";", "}", "var", "types", "=", "{", "a", ":", "0", ",", "b", ":", "0", ",", "c", ":", "0", "}", ";", "// Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument", "selector", "=", "selector", ".", "replace", "(", "notRegex", ",", "' $1 '", ")", ";", "// Remove anything after a left brace in case a user has pasted in a rule, not just a selector", "selector", "=", "selector", ".", "replace", "(", "ruleRegex", ",", "' '", ")", ";", "// Add attribute selectors to parts collection (type b)", "selector", "=", "findMatch", "(", "attributeRegex", ",", "'b'", ",", "types", ",", "selector", ")", ";", "// Add ID selectors to parts collection (type a)", "selector", "=", "findMatch", "(", "idRegex", ",", "'a'", ",", "types", ",", "selector", ")", ";", "// Add class selectors to parts collection (type b)", "selector", "=", "findMatch", "(", "classRegex", ",", "'b'", ",", "types", ",", "selector", ")", ";", "// Add pseudo-element selectors to parts collection (type c)", "selector", "=", "findMatch", "(", "pseudoElementRegex", ",", "'c'", ",", "types", ",", "selector", ")", ";", "// Add pseudo-class selectors to parts collection (type b)", "selector", "=", "findMatch", "(", "pseudoClassRegex", ",", "'b'", ",", "types", ",", "selector", ")", ";", "// Remove universal selector and separator characters", "selector", "=", "selector", ".", "replace", "(", "separatorRegex", ",", "' '", ")", ";", "// Remove any stray dots or hashes which aren't attached to words", "// These may be present if the user is live-editing this selector", "selector", "=", "selector", ".", "replace", "(", "straysRegex", ",", "' '", ")", ";", "// The only things left should be element selectors (type c)", "findMatch", "(", "elementRegex", ",", "'c'", ",", "types", ",", "selector", ")", ";", "return", "(", "types", ".", "a", "*", "100", ")", "+", "(", "types", ".", "b", "*", "10", ")", "+", "(", "types", ".", "c", "*", "1", ")", ";", "}"], "docstring": "Calculate the specificity for a selector by dividing it into simple selectors and counting them", "docstring_tokens": ["Calculate", "the", "specificity", "for", "a", "selector", "by", "dividing", "it", "into", "simple", "selectors", "and", "counting", "them"], "sha": "d0fdd26e7665b318930589f2b5dd678d320be00f", "url": "https://github.com/atom/clear-cut/blob/d0fdd26e7665b318930589f2b5dd678d320be00f/index.js#L38-L82", "partition": "test"}
{"repo": "steve-jansen/json-proxy", "path": "lib/logger.js", "func_name": "format", "original_string": "function format(color, messages) {\n  var length = messages.length;\n\n  if (length === 0 || typeof(color) !== 'string') {\n    return;\n  }\n\n  return (util.format.apply(null, messages)[color]);\n}", "language": "javascript", "code": "function format(color, messages) {\n  var length = messages.length;\n\n  if (length === 0 || typeof(color) !== 'string') {\n    return;\n  }\n\n  return (util.format.apply(null, messages)[color]);\n}", "code_tokens": ["function", "format", "(", "color", ",", "messages", ")", "{", "var", "length", "=", "messages", ".", "length", ";", "if", "(", "length", "===", "0", "||", "typeof", "(", "color", ")", "!==", "'string'", ")", "{", "return", ";", "}", "return", "(", "util", ".", "format", ".", "apply", "(", "null", ",", "messages", ")", "[", "color", "]", ")", ";", "}"], "docstring": "colorize strings and send to console.log", "docstring_tokens": ["colorize", "strings", "and", "send", "to", "console", ".", "log"], "sha": "b996609b627690774367d8d887f2e8baf102f6bf", "url": "https://github.com/steve-jansen/json-proxy/blob/b996609b627690774367d8d887f2e8baf102f6bf/lib/logger.js#L23-L31", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "lib/reflect.js", "func_name": "", "original_string": "function() {\n    var trap = this.getTrap(\"ownKeys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.ownKeys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    if (trapResult === null || typeof trapResult !== \"object\") {\n      throw new TypeError(\"ownKeys should return an iterator object, got \" +\n                          trapResult);\n    }\n\n    return trapResult;\n  }", "language": "javascript", "code": "function() {\n    var trap = this.getTrap(\"ownKeys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.ownKeys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    if (trapResult === null || typeof trapResult !== \"object\") {\n      throw new TypeError(\"ownKeys should return an iterator object, got \" +\n                          trapResult);\n    }\n\n    return trapResult;\n  }", "code_tokens": ["function", "(", ")", "{", "var", "trap", "=", "this", ".", "getTrap", "(", "\"ownKeys\"", ")", ";", "if", "(", "trap", "===", "undefined", ")", "{", "// default forwarding behavior", "return", "Reflect", ".", "ownKeys", "(", "this", ".", "target", ")", ";", "}", "var", "trapResult", "=", "trap", ".", "call", "(", "this", ".", "handler", ",", "this", ".", "target", ")", ";", "if", "(", "trapResult", "===", "null", "||", "typeof", "trapResult", "!==", "\"object\"", ")", "{", "throw", "new", "TypeError", "(", "\"ownKeys should return an iterator object, got \"", "+", "trapResult", ")", ";", "}", "return", "trapResult", ";", "}"], "docstring": "In ES6, this trap is called for all operations that require a list\nof an object's properties, including Object.getOwnPropertyNames\nand Object.keys.\n\nThe trap should return an iterator. The proxy implementation only\nchecks whether the return value is an object.", "docstring_tokens": ["In", "ES6", "this", "trap", "is", "called", "for", "all", "operations", "that", "require", "a", "list", "of", "an", "object", "s", "properties", "including", "Object", ".", "getOwnPropertyNames", "and", "Object", ".", "keys", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/lib/reflect.js#L1283-L1298", "partition": "test"}
{"repo": "nicu/grel", "path": "grel.js", "func_name": "handleResponse", "original_string": "function handleResponse(res, data, callback) {\n    // HTTP 204 doesn't have a response\n    var json = data && JSON.parse(data) || {};\n\n    if ((res.statusCode >= 200) && (res.statusCode <= 206)) {\n        // Handle a few known responses\n        switch (json.message) {\n            case 'Bad credentials':\n                callback.call(this, json);\n                break;\n\n            default:\n                callback.call(this, null, json);\n        }\n    } else {\n        callback.call(this, json);\n    }\n}", "language": "javascript", "code": "function handleResponse(res, data, callback) {\n    // HTTP 204 doesn't have a response\n    var json = data && JSON.parse(data) || {};\n\n    if ((res.statusCode >= 200) && (res.statusCode <= 206)) {\n        // Handle a few known responses\n        switch (json.message) {\n            case 'Bad credentials':\n                callback.call(this, json);\n                break;\n\n            default:\n                callback.call(this, null, json);\n        }\n    } else {\n        callback.call(this, json);\n    }\n}", "code_tokens": ["function", "handleResponse", "(", "res", ",", "data", ",", "callback", ")", "{", "// HTTP 204 doesn't have a response", "var", "json", "=", "data", "&&", "JSON", ".", "parse", "(", "data", ")", "||", "{", "}", ";", "if", "(", "(", "res", ".", "statusCode", ">=", "200", ")", "&&", "(", "res", ".", "statusCode", "<=", "206", ")", ")", "{", "// Handle a few known responses", "switch", "(", "json", ".", "message", ")", "{", "case", "'Bad credentials'", ":", "callback", ".", "call", "(", "this", ",", "json", ")", ";", "break", ";", "default", ":", "callback", ".", "call", "(", "this", ",", "null", ",", "json", ")", ";", "}", "}", "else", "{", "callback", ".", "call", "(", "this", ",", "json", ")", ";", "}", "}"], "docstring": "Private method that handles HTTP responses we get from GitHub.\nThis method will always be executed in the context of a GrelRequest.\n\n@param  {String}   response HTTP response\n@param  {Function} callback Callback function\n@return {null} No return value", "docstring_tokens": ["Private", "method", "that", "handles", "HTTP", "responses", "we", "get", "from", "GitHub", ".", "This", "method", "will", "always", "be", "executed", "in", "the", "context", "of", "a", "GrelRequest", "."], "sha": "cbcf42c88317e38330ef42902e11a6d3c5fb50cc", "url": "https://github.com/nicu/grel/blob/cbcf42c88317e38330ef42902e11a6d3c5fb50cc/grel.js#L140-L157", "partition": "test"}
{"repo": "jonschlinkert/dry", "path": "lib/lexer.js", "func_name": "", "original_string": "function(file, prop) {\n    return this.createNode(prop, file[prop], `{% ${prop} \"${file[prop]}\" %}`, this.position());\n  }", "language": "javascript", "code": "function(file, prop) {\n    return this.createNode(prop, file[prop], `{% ${prop} \"${file[prop]}\" %}`, this.position());\n  }", "code_tokens": ["function", "(", "file", ",", "prop", ")", "{", "return", "this", ".", "createNode", "(", "prop", ",", "file", "[", "prop", "]", ",", "`", "${", "prop", "}", "${", "file", "[", "prop", "]", "}", "`", ",", "this", ".", "position", "(", ")", ")", ";", "}"], "docstring": "Unshift node `prop` onto the AST", "docstring_tokens": ["Unshift", "node", "prop", "onto", "the", "AST"], "sha": "c841f768d6dbc15a1018ca6927781745e7c83726", "url": "https://github.com/jonschlinkert/dry/blob/c841f768d6dbc15a1018ca6927781745e7c83726/lib/lexer.js#L472-L474", "partition": "test"}
{"repo": "react-dnd/react-dnd", "path": "packages/documentation/gatsby-node.js", "func_name": "createPages", "original_string": "async function createPages({ actions, graphql }) {\n\tconst retrieveMarkdownPages = () =>\n\t\tgraphql(`\n\t\t\t{\n\t\t\t\tallMarkdownRemark(limit: 1000) {\n\t\t\t\t\tedges {\n\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\tfrontmatter {\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`)\n\n\tconst exampleTemplate = path.resolve(`src/templates/exampleTemplate.tsx`)\n\tconst docTemplate = path.resolve(`src/templates/docTemplate.tsx`)\n\tconst result = await retrieveMarkdownPages()\n\n\tif (result.errors) {\n\t\tconsole.error('graphql error', result.errors)\n\t\tthrow new Error('Error invoking graphql for pages')\n\t}\n\n\tresult.data.allMarkdownRemark.edges.forEach(({ node }) => {\n\t\tconst {\n\t\t\tfrontmatter: { path: pagePath },\n\t\t} = node\n\t\tconst category = (pagePath || '/').split('/').filter(t => !!t)[0]\n\t\tconst isExample = category === 'examples'\n\t\tconsole.log(`create page for ${pagePath} - type is ${category}`)\n\t\tactions.createPage({\n\t\t\tpath: pagePath,\n\t\t\tcomponent: isExample ? exampleTemplate : docTemplate,\n\t\t\tcontext: {}, // additional data can be passed via context\n\t\t})\n\t})\n}", "language": "javascript", "code": "async function createPages({ actions, graphql }) {\n\tconst retrieveMarkdownPages = () =>\n\t\tgraphql(`\n\t\t\t{\n\t\t\t\tallMarkdownRemark(limit: 1000) {\n\t\t\t\t\tedges {\n\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\tfrontmatter {\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t`)\n\n\tconst exampleTemplate = path.resolve(`src/templates/exampleTemplate.tsx`)\n\tconst docTemplate = path.resolve(`src/templates/docTemplate.tsx`)\n\tconst result = await retrieveMarkdownPages()\n\n\tif (result.errors) {\n\t\tconsole.error('graphql error', result.errors)\n\t\tthrow new Error('Error invoking graphql for pages')\n\t}\n\n\tresult.data.allMarkdownRemark.edges.forEach(({ node }) => {\n\t\tconst {\n\t\t\tfrontmatter: { path: pagePath },\n\t\t} = node\n\t\tconst category = (pagePath || '/').split('/').filter(t => !!t)[0]\n\t\tconst isExample = category === 'examples'\n\t\tconsole.log(`create page for ${pagePath} - type is ${category}`)\n\t\tactions.createPage({\n\t\t\tpath: pagePath,\n\t\t\tcomponent: isExample ? exampleTemplate : docTemplate,\n\t\t\tcontext: {}, // additional data can be passed via context\n\t\t})\n\t})\n}", "code_tokens": ["async", "function", "createPages", "(", "{", "actions", ",", "graphql", "}", ")", "{", "const", "retrieveMarkdownPages", "=", "(", ")", "=>", "graphql", "(", "`", "`", ")", "const", "exampleTemplate", "=", "path", ".", "resolve", "(", "`", "`", ")", "const", "docTemplate", "=", "path", ".", "resolve", "(", "`", "`", ")", "const", "result", "=", "await", "retrieveMarkdownPages", "(", ")", "if", "(", "result", ".", "errors", ")", "{", "console", ".", "error", "(", "'graphql error'", ",", "result", ".", "errors", ")", "throw", "new", "Error", "(", "'Error invoking graphql for pages'", ")", "}", "result", ".", "data", ".", "allMarkdownRemark", ".", "edges", ".", "forEach", "(", "(", "{", "node", "}", ")", "=>", "{", "const", "{", "frontmatter", ":", "{", "path", ":", "pagePath", "}", ",", "}", "=", "node", "const", "category", "=", "(", "pagePath", "||", "'/'", ")", ".", "split", "(", "'/'", ")", ".", "filter", "(", "t", "=>", "!", "!", "t", ")", "[", "0", "]", "const", "isExample", "=", "category", "===", "'examples'", "console", ".", "log", "(", "`", "${", "pagePath", "}", "${", "category", "}", "`", ")", "actions", ".", "createPage", "(", "{", "path", ":", "pagePath", ",", "component", ":", "isExample", "?", "exampleTemplate", ":", "docTemplate", ",", "context", ":", "{", "}", ",", "// additional data can be passed via context", "}", ")", "}", ")", "}"], "docstring": "Dynamically creates pages in the static website", "docstring_tokens": ["Dynamically", "creates", "pages", "in", "the", "static", "website"], "sha": "5fefffc8c6c1ceced3aa0356fd869354ad74734a", "url": "https://github.com/react-dnd/react-dnd/blob/5fefffc8c6c1ceced3aa0356fd869354ad74734a/packages/documentation/gatsby-node.js#L6-L44", "partition": "test"}
{"repo": "retextjs/retext-indefinite-article", "path": "lib/index.js", "func_name": "after", "original_string": "function after(parent, index) {\n  var siblings = parent.children\n  var sibling = siblings[++index]\n  var other\n\n  if (is('WhiteSpaceNode', sibling)) {\n    sibling = siblings[++index]\n\n    if (is('PunctuationNode', sibling) && punctuation.test(toString(sibling))) {\n      sibling = siblings[++index]\n    }\n\n    if (is('WordNode', sibling)) {\n      other = sibling\n    }\n  }\n\n  return other\n}", "language": "javascript", "code": "function after(parent, index) {\n  var siblings = parent.children\n  var sibling = siblings[++index]\n  var other\n\n  if (is('WhiteSpaceNode', sibling)) {\n    sibling = siblings[++index]\n\n    if (is('PunctuationNode', sibling) && punctuation.test(toString(sibling))) {\n      sibling = siblings[++index]\n    }\n\n    if (is('WordNode', sibling)) {\n      other = sibling\n    }\n  }\n\n  return other\n}", "code_tokens": ["function", "after", "(", "parent", ",", "index", ")", "{", "var", "siblings", "=", "parent", ".", "children", "var", "sibling", "=", "siblings", "[", "++", "index", "]", "var", "other", "if", "(", "is", "(", "'WhiteSpaceNode'", ",", "sibling", ")", ")", "{", "sibling", "=", "siblings", "[", "++", "index", "]", "if", "(", "is", "(", "'PunctuationNode'", ",", "sibling", ")", "&&", "punctuation", ".", "test", "(", "toString", "(", "sibling", ")", ")", ")", "{", "sibling", "=", "siblings", "[", "++", "index", "]", "}", "if", "(", "is", "(", "'WordNode'", ",", "sibling", ")", ")", "{", "other", "=", "sibling", "}", "}", "return", "other", "}"], "docstring": "Get the next word.", "docstring_tokens": ["Get", "the", "next", "word", "."], "sha": "abe3642840f416c2f921b6947d9ceb277c271a43", "url": "https://github.com/retextjs/retext-indefinite-article/blob/abe3642840f416c2f921b6947d9ceb277c271a43/lib/index.js#L96-L114", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/direct/RemotingProvider.js", "func_name": "", "original_string": "function(transaction) {\n        return {\n            action: transaction.getAction(),\n            method: transaction.getMethod(),\n            data: transaction.getData(),\n            type: 'rpc',\n            tid: transaction.getId()\n        };\n    }", "language": "javascript", "code": "function(transaction) {\n        return {\n            action: transaction.getAction(),\n            method: transaction.getMethod(),\n            data: transaction.getData(),\n            type: 'rpc',\n            tid: transaction.getId()\n        };\n    }", "code_tokens": ["function", "(", "transaction", ")", "{", "return", "{", "action", ":", "transaction", ".", "getAction", "(", ")", ",", "method", ":", "transaction", ".", "getMethod", "(", ")", ",", "data", ":", "transaction", ".", "getData", "(", ")", ",", "type", ":", "'rpc'", ",", "tid", ":", "transaction", ".", "getId", "(", ")", "}", ";", "}"], "docstring": "Gets the AJAX call info for a transaction.\n@private\n@param {Ext.direct.Transaction} transaction The transaction.\n@return {Object} The call params.", "docstring_tokens": ["Gets", "the", "AJAX", "call", "info", "for", "a", "transaction", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/direct/RemotingProvider.js#L362-L370", "partition": "test"}
{"repo": "sportngin/ngin_client_node", "path": "src/users/persona.js", "func_name": "scopeUrl", "original_string": "function scopeUrl(options, inst) {\n    options = _.extend(options || {}, inst)\n\n    if (!options.url && !options.user_id && !options.group_id && !(options.query || options.query.owner_type && options.query.owner_id)) {\n      return callback(new Error('user_id or group_id or (owner_type and owner_id) are required'))\n    }\n\n    if (options.user_id) {\n      return ngin.User.urlRoot() + '/' + options.user_id + '/personas'\n    }\n\n    if (options.group_id) {\n      return ngin.Group.urlRoot() + '/' + options.group_id + '/personas'\n    }\n\n    if (options.url || options.query.owner_type && options.query.owner_id) {\n      return Persona.urlRoot()\n    }\n\n  }", "language": "javascript", "code": "function scopeUrl(options, inst) {\n    options = _.extend(options || {}, inst)\n\n    if (!options.url && !options.user_id && !options.group_id && !(options.query || options.query.owner_type && options.query.owner_id)) {\n      return callback(new Error('user_id or group_id or (owner_type and owner_id) are required'))\n    }\n\n    if (options.user_id) {\n      return ngin.User.urlRoot() + '/' + options.user_id + '/personas'\n    }\n\n    if (options.group_id) {\n      return ngin.Group.urlRoot() + '/' + options.group_id + '/personas'\n    }\n\n    if (options.url || options.query.owner_type && options.query.owner_id) {\n      return Persona.urlRoot()\n    }\n\n  }", "code_tokens": ["function", "scopeUrl", "(", "options", ",", "inst", ")", "{", "options", "=", "_", ".", "extend", "(", "options", "||", "{", "}", ",", "inst", ")", "if", "(", "!", "options", ".", "url", "&&", "!", "options", ".", "user_id", "&&", "!", "options", ".", "group_id", "&&", "!", "(", "options", ".", "query", "||", "options", ".", "query", ".", "owner_type", "&&", "options", ".", "query", ".", "owner_id", ")", ")", "{", "return", "callback", "(", "new", "Error", "(", "'user_id or group_id or (owner_type and owner_id) are required'", ")", ")", "}", "if", "(", "options", ".", "user_id", ")", "{", "return", "ngin", ".", "User", ".", "urlRoot", "(", ")", "+", "'/'", "+", "options", ".", "user_id", "+", "'/personas'", "}", "if", "(", "options", ".", "group_id", ")", "{", "return", "ngin", ".", "Group", ".", "urlRoot", "(", ")", "+", "'/'", "+", "options", ".", "group_id", "+", "'/personas'", "}", "if", "(", "options", ".", "url", "||", "options", ".", "query", ".", "owner_type", "&&", "options", ".", "query", ".", "owner_id", ")", "{", "return", "Persona", ".", "urlRoot", "(", ")", "}", "}"], "docstring": "Scopes the url to a user, group, or persona\n\n@param {Object} options\n@returns {String}\n@api private", "docstring_tokens": ["Scopes", "the", "url", "to", "a", "user", "group", "or", "persona"], "sha": "dafed7f3b86e86b01f7d5fd707d4a8d608258fe9", "url": "https://github.com/sportngin/ngin_client_node/blob/dafed7f3b86e86b01f7d5fd707d4a8d608258fe9/src/users/persona.js#L17-L36", "partition": "test"}
{"repo": "kingerking/input-promptify", "path": "prompt.js", "func_name": "calculateFieldColor", "original_string": "function calculateFieldColor(selectedColor, nonSelectedColor, focusedColor, index, out)\n{\n    if(selected.indexOf(index) !== -1 && focused == index)\n    return chalk.bold.rgb(selectedColor.r, selectedColor.g, selectedColor.b)(out);\n    if(selected.indexOf(index) !== -1) // this goes before focused so selected color gets priority over focused values\n        return chalk.rgb(selectedColor.r, selectedColor.g, selectedColor.b)(out);\n    if(focused == index)\n        return chalk.bold.rgb(focusedColor.r, focusedColor.g, focusedColor.b)(out);\n    return chalk.rgb(nonSelectedColor.r, nonSelectedColor.g, nonSelectedColor.b)(out);\n}", "language": "javascript", "code": "function calculateFieldColor(selectedColor, nonSelectedColor, focusedColor, index, out)\n{\n    if(selected.indexOf(index) !== -1 && focused == index)\n    return chalk.bold.rgb(selectedColor.r, selectedColor.g, selectedColor.b)(out);\n    if(selected.indexOf(index) !== -1) // this goes before focused so selected color gets priority over focused values\n        return chalk.rgb(selectedColor.r, selectedColor.g, selectedColor.b)(out);\n    if(focused == index)\n        return chalk.bold.rgb(focusedColor.r, focusedColor.g, focusedColor.b)(out);\n    return chalk.rgb(nonSelectedColor.r, nonSelectedColor.g, nonSelectedColor.b)(out);\n}", "code_tokens": ["function", "calculateFieldColor", "(", "selectedColor", ",", "nonSelectedColor", ",", "focusedColor", ",", "index", ",", "out", ")", "{", "if", "(", "selected", ".", "indexOf", "(", "index", ")", "!==", "-", "1", "&&", "focused", "==", "index", ")", "return", "chalk", ".", "bold", ".", "rgb", "(", "selectedColor", ".", "r", ",", "selectedColor", ".", "g", ",", "selectedColor", ".", "b", ")", "(", "out", ")", ";", "if", "(", "selected", ".", "indexOf", "(", "index", ")", "!==", "-", "1", ")", "// this goes before focused so selected color gets priority over focused values", "return", "chalk", ".", "rgb", "(", "selectedColor", ".", "r", ",", "selectedColor", ".", "g", ",", "selectedColor", ".", "b", ")", "(", "out", ")", ";", "if", "(", "focused", "==", "index", ")", "return", "chalk", ".", "bold", ".", "rgb", "(", "focusedColor", ".", "r", ",", "focusedColor", ".", "g", ",", "focusedColor", ".", "b", ")", "(", "out", ")", ";", "return", "chalk", ".", "rgb", "(", "nonSelectedColor", ".", "r", ",", "nonSelectedColor", ".", "g", ",", "nonSelectedColor", ".", "b", ")", "(", "out", ")", ";", "}"], "docstring": "Will return a chalk function based on selected index, etc..\n@param {*} selectedColor\n@param {*} nonSelectedColor\n@param {*} focusedColor\n@param {*} index", "docstring_tokens": ["Will", "return", "a", "chalk", "function", "based", "on", "selected", "index", "etc", ".."], "sha": "e2aa5436d8d4f6e7d7108d2490d25c35d943c21d", "url": "https://github.com/kingerking/input-promptify/blob/e2aa5436d8d4f6e7d7108d2490d25c35d943c21d/prompt.js#L109-L118", "partition": "test"}
{"repo": "cronvel/kung-fig-common", "path": "lib/parsers.js", "func_name": "locationStr", "original_string": "function locationStr( runtime , line ) {\n\tvar loc ;\n\tloc = 'line: ' + ( line !== undefined ? line : runtime.lineNumber ) ;\n\tif ( runtime.file ) { loc += ' -- file: ' + runtime.file ; }\n\treturn loc ;\n}", "language": "javascript", "code": "function locationStr( runtime , line ) {\n\tvar loc ;\n\tloc = 'line: ' + ( line !== undefined ? line : runtime.lineNumber ) ;\n\tif ( runtime.file ) { loc += ' -- file: ' + runtime.file ; }\n\treturn loc ;\n}", "code_tokens": ["function", "locationStr", "(", "runtime", ",", "line", ")", "{", "var", "loc", ";", "loc", "=", "'line: '", "+", "(", "line", "!==", "undefined", "?", "line", ":", "runtime", ".", "lineNumber", ")", ";", "if", "(", "runtime", ".", "file", ")", "{", "loc", "+=", "' -- file: '", "+", "runtime", ".", "file", ";", "}", "return", "loc", ";", "}"], "docstring": "Used to report errors", "docstring_tokens": ["Used", "to", "report", "errors"], "sha": "136581e57957f4b8636de25f466c31adb80de70e", "url": "https://github.com/cronvel/kung-fig-common/blob/136581e57957f4b8636de25f466c31adb80de70e/lib/parsers.js#L223-L228", "partition": "test"}
{"repo": "GitbookIO/theme-default", "path": "src/js/theme/toolbar.js", "func_name": "createButton", "original_string": "function createButton(opts) {\n    opts = $.extend({\n        // Aria label for the button\n        label: '',\n\n        // Icon to show\n        icon: '',\n\n        // Inner text\n        text: '',\n\n        // Right or left position\n        position: 'left',\n\n        // Other class name to add to the button\n        className: '',\n\n        // Triggered when user click on the button\n        onClick: defaultOnClick,\n\n        // Button is a dropdown\n        dropdown: null,\n\n        // Position in the toolbar\n        index: null,\n\n        // Button id for removal\n        id: generateId()\n    }, opts || {});\n\n    buttons.push(opts);\n    updateButton(opts);\n\n    return opts.id;\n}", "language": "javascript", "code": "function createButton(opts) {\n    opts = $.extend({\n        // Aria label for the button\n        label: '',\n\n        // Icon to show\n        icon: '',\n\n        // Inner text\n        text: '',\n\n        // Right or left position\n        position: 'left',\n\n        // Other class name to add to the button\n        className: '',\n\n        // Triggered when user click on the button\n        onClick: defaultOnClick,\n\n        // Button is a dropdown\n        dropdown: null,\n\n        // Position in the toolbar\n        index: null,\n\n        // Button id for removal\n        id: generateId()\n    }, opts || {});\n\n    buttons.push(opts);\n    updateButton(opts);\n\n    return opts.id;\n}", "code_tokens": ["function", "createButton", "(", "opts", ")", "{", "opts", "=", "$", ".", "extend", "(", "{", "// Aria label for the button", "label", ":", "''", ",", "// Icon to show", "icon", ":", "''", ",", "// Inner text", "text", ":", "''", ",", "// Right or left position", "position", ":", "'left'", ",", "// Other class name to add to the button", "className", ":", "''", ",", "// Triggered when user click on the button", "onClick", ":", "defaultOnClick", ",", "// Button is a dropdown", "dropdown", ":", "null", ",", "// Position in the toolbar", "index", ":", "null", ",", "// Button id for removal", "id", ":", "generateId", "(", ")", "}", ",", "opts", "||", "{", "}", ")", ";", "buttons", ".", "push", "(", "opts", ")", ";", "updateButton", "(", "opts", ")", ";", "return", "opts", ".", "id", ";", "}"], "docstring": "Create a new button in the toolbar", "docstring_tokens": ["Create", "a", "new", "button", "in", "the", "toolbar"], "sha": "a8e920453dc8e4eb522840b61606486622848099", "url": "https://github.com/GitbookIO/theme-default/blob/a8e920453dc8e4eb522840b61606486622848099/src/js/theme/toolbar.js#L82-L116", "partition": "test"}
{"repo": "ethjs/ethjs-format", "path": "src/index.js", "func_name": "formatQuantityOrTag", "original_string": "function formatQuantityOrTag(value, encode) {\n  var output = value; // eslint-disable-line\n\n  // if the value is a tag, bypass\n  if (schema.tags.indexOf(value) === -1) {\n    output = formatQuantity(value, encode);\n  }\n\n  return output;\n}", "language": "javascript", "code": "function formatQuantityOrTag(value, encode) {\n  var output = value; // eslint-disable-line\n\n  // if the value is a tag, bypass\n  if (schema.tags.indexOf(value) === -1) {\n    output = formatQuantity(value, encode);\n  }\n\n  return output;\n}", "code_tokens": ["function", "formatQuantityOrTag", "(", "value", ",", "encode", ")", "{", "var", "output", "=", "value", ";", "// eslint-disable-line", "// if the value is a tag, bypass", "if", "(", "schema", ".", "tags", ".", "indexOf", "(", "value", ")", "===", "-", "1", ")", "{", "output", "=", "formatQuantity", "(", "value", ",", "encode", ")", ";", "}", "return", "output", ";", "}"], "docstring": "Format quantity or tag, if tag bypass return, else format quantity\nshould intake null, stringNumber, number, BN, string tag\n\n@method formatQuantityOrTag\n@param {String|BigNumber|Number} value quantity or tag to convert\n@param {Boolean} encode encode the number to hex or decode to BigNumber\n@returns {Object|String} output to BigNumber or string\n@throws error if value is a float", "docstring_tokens": ["Format", "quantity", "or", "tag", "if", "tag", "bypass", "return", "else", "format", "quantity", "should", "intake", "null", "stringNumber", "number", "BN", "string", "tag"], "sha": "626fe31ed6c7026ab9cc6012b6ea8659bc5faaf0", "url": "https://github.com/ethjs/ethjs-format/blob/626fe31ed6c7026ab9cc6012b6ea8659bc5faaf0/src/index.js#L44-L53", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getJsxAttributePropertySymbol", "original_string": "function getJsxAttributePropertySymbol(attrib) {\n            var attributesType = getJsxElementAttributesType(attrib.parent);\n            var prop = getPropertyOfType(attributesType, attrib.name.text);\n            return prop || unknownSymbol;\n        }", "language": "javascript", "code": "function getJsxAttributePropertySymbol(attrib) {\n            var attributesType = getJsxElementAttributesType(attrib.parent);\n            var prop = getPropertyOfType(attributesType, attrib.name.text);\n            return prop || unknownSymbol;\n        }", "code_tokens": ["function", "getJsxAttributePropertySymbol", "(", "attrib", ")", "{", "var", "attributesType", "=", "getJsxElementAttributesType", "(", "attrib", ".", "parent", ")", ";", "var", "prop", "=", "getPropertyOfType", "(", "attributesType", ",", "attrib", ".", "name", ".", "text", ")", ";", "return", "prop", "||", "unknownSymbol", ";", "}"], "docstring": "Given a JSX attribute, returns the symbol for the corresponds property\nof the element attributes type. Will return unknownSymbol for attributes\nthat have no matching element attributes type property.", "docstring_tokens": ["Given", "a", "JSX", "attribute", "returns", "the", "symbol", "for", "the", "corresponds", "property", "of", "the", "element", "attributes", "type", ".", "Will", "return", "unknownSymbol", "for", "attributes", "that", "have", "no", "matching", "element", "attributes", "type", "property", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L20447-L20451", "partition": "test"}
{"repo": "BeneathTheInk/temple-mustache", "path": "src/model.js", "func_name": "", "original_string": "function(path) {\n\t\tif (typeof path === \"string\") path = parse(path, { startRule: \"path\" });\n\t\tif (!_.isObject(path)) throw new Error(\"Expecting string or object for path.\");\n\t\tvar self = this;\n\t\tthis._dep.depend();\n\n\t\treturn _.reduce(path.parts, function(target, part) {\n\t\t\ttarget = self._get(target, part.key);\n\n\t\t\t_.each(part.children, function(k) {\n\t\t\t\tif (_.isObject(k)) k = self.get(k);\n\t\t\t\ttarget = self._get(target, k);\n\t\t\t});\n\n\t\t\treturn target;\n\t\t}, this.data);\n\t}", "language": "javascript", "code": "function(path) {\n\t\tif (typeof path === \"string\") path = parse(path, { startRule: \"path\" });\n\t\tif (!_.isObject(path)) throw new Error(\"Expecting string or object for path.\");\n\t\tvar self = this;\n\t\tthis._dep.depend();\n\n\t\treturn _.reduce(path.parts, function(target, part) {\n\t\t\ttarget = self._get(target, part.key);\n\n\t\t\t_.each(part.children, function(k) {\n\t\t\t\tif (_.isObject(k)) k = self.get(k);\n\t\t\t\ttarget = self._get(target, k);\n\t\t\t});\n\n\t\t\treturn target;\n\t\t}, this.data);\n\t}", "code_tokens": ["function", "(", "path", ")", "{", "if", "(", "typeof", "path", "===", "\"string\"", ")", "path", "=", "parse", "(", "path", ",", "{", "startRule", ":", "\"path\"", "}", ")", ";", "if", "(", "!", "_", ".", "isObject", "(", "path", ")", ")", "throw", "new", "Error", "(", "\"Expecting string or object for path.\"", ")", ";", "var", "self", "=", "this", ";", "this", ".", "_dep", ".", "depend", "(", ")", ";", "return", "_", ".", "reduce", "(", "path", ".", "parts", ",", "function", "(", "target", ",", "part", ")", "{", "target", "=", "self", ".", "_get", "(", "target", ",", "part", ".", "key", ")", ";", "_", ".", "each", "(", "part", ".", "children", ",", "function", "(", "k", ")", "{", "if", "(", "_", ".", "isObject", "(", "k", ")", ")", "k", "=", "self", ".", "get", "(", "k", ")", ";", "target", "=", "self", ".", "_get", "(", "target", ",", "k", ")", ";", "}", ")", ";", "return", "target", ";", "}", ",", "this", ".", "data", ")", ";", "}"], "docstring": "returns the value at path, but only looks in the data on this model", "docstring_tokens": ["returns", "the", "value", "at", "path", "but", "only", "looks", "in", "the", "data", "on", "this", "model"], "sha": "5a66d6a443f5f98f09483fd03d9ba9ee11fb4ae9", "url": "https://github.com/BeneathTheInk/temple-mustache/blob/5a66d6a443f5f98f09483fd03d9ba9ee11fb4ae9/src/model.js#L97-L113", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "", "original_string": "function (file) {\n      for (var i = this.files.length - 1; i >= 0; i--) {\n        if (this.files[i] === file) {\n          this.files.splice(i, 1);\n          file.abort();\n          this.fire('fileRemoved', file);\n        }\n      }\n    }", "language": "javascript", "code": "function (file) {\n      for (var i = this.files.length - 1; i >= 0; i--) {\n        if (this.files[i] === file) {\n          this.files.splice(i, 1);\n          file.abort();\n          this.fire('fileRemoved', file);\n        }\n      }\n    }", "code_tokens": ["function", "(", "file", ")", "{", "for", "(", "var", "i", "=", "this", ".", "files", ".", "length", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "if", "(", "this", ".", "files", "[", "i", "]", "===", "file", ")", "{", "this", ".", "files", ".", "splice", "(", "i", ",", "1", ")", ";", "file", ".", "abort", "(", ")", ";", "this", ".", "fire", "(", "'fileRemoved'", ",", "file", ")", ";", "}", "}", "}"], "docstring": "Cancel upload of a specific FlowFile object from the list.\n@function\n@param {FlowFile} file", "docstring_tokens": ["Cancel", "upload", "of", "a", "specific", "FlowFile", "object", "from", "the", "list", "."], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L619-L627", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(key, value) {\n    var attributeName = this._unspecifiedAttributeBindings && this._unspecifiedAttributeBindings[key];\n    if (attributeName) {\n      this._setupAttributeBindingObservation(key, attributeName);\n    }\n\n    defineProperty(this, key);\n    return set(this, key, value);\n  }", "language": "javascript", "code": "function(key, value) {\n    var attributeName = this._unspecifiedAttributeBindings && this._unspecifiedAttributeBindings[key];\n    if (attributeName) {\n      this._setupAttributeBindingObservation(key, attributeName);\n    }\n\n    defineProperty(this, key);\n    return set(this, key, value);\n  }", "code_tokens": ["function", "(", "key", ",", "value", ")", "{", "var", "attributeName", "=", "this", ".", "_unspecifiedAttributeBindings", "&&", "this", ".", "_unspecifiedAttributeBindings", "[", "key", "]", ";", "if", "(", "attributeName", ")", "{", "this", ".", "_setupAttributeBindingObservation", "(", "key", ",", "attributeName", ")", ";", "}", "defineProperty", "(", "this", ",", "key", ")", ";", "return", "set", "(", "this", ",", "key", ",", "value", ")", ";", "}"], "docstring": "Gets defined after initialization by _applyAttributeBindings", "docstring_tokens": ["Gets", "defined", "after", "initialization", "by", "_applyAttributeBindings"], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L23740-L23748", "partition": "test"}
{"repo": "frapontillo/angular-bootstrap-switch", "path": "dist/angular-bootstrap-switch.js", "func_name": "", "original_string": "function () {\n\n          if (attrs.type === 'radio') {\n            // when the switch is clicked\n            element.on('change.bootstrapSwitch', function (e) {\n              // discard not real change events\n              if ((controller.$modelValue === controller.$viewValue) && (e.target.checked !== $(e.target).bootstrapSwitch('state'))) {\n                // $setViewValue --> $viewValue --> $parsers --> $modelValue\n                // if the switch is indeed selected\n                if (e.target.checked) {\n                  // set its value into the view\n                  controller.$setViewValue(getTrueValue());\n                } else if (getTrueValue() === controller.$viewValue) {\n                  // otherwise if it's been deselected, delete the view value\n                  controller.$setViewValue(undefined);\n                }\n                switchChange();\n              }\n            });\n          } else {\n            // When the checkbox switch is clicked, set its value into the ngModel\n            element.on('switchChange.bootstrapSwitch', function (e) {\n              // $setViewValue --> $viewValue --> $parsers --> $modelValue\n              controller.$setViewValue(e.target.checked);\n              switchChange();\n            });\n          }\n        }", "language": "javascript", "code": "function () {\n\n          if (attrs.type === 'radio') {\n            // when the switch is clicked\n            element.on('change.bootstrapSwitch', function (e) {\n              // discard not real change events\n              if ((controller.$modelValue === controller.$viewValue) && (e.target.checked !== $(e.target).bootstrapSwitch('state'))) {\n                // $setViewValue --> $viewValue --> $parsers --> $modelValue\n                // if the switch is indeed selected\n                if (e.target.checked) {\n                  // set its value into the view\n                  controller.$setViewValue(getTrueValue());\n                } else if (getTrueValue() === controller.$viewValue) {\n                  // otherwise if it's been deselected, delete the view value\n                  controller.$setViewValue(undefined);\n                }\n                switchChange();\n              }\n            });\n          } else {\n            // When the checkbox switch is clicked, set its value into the ngModel\n            element.on('switchChange.bootstrapSwitch', function (e) {\n              // $setViewValue --> $viewValue --> $parsers --> $modelValue\n              controller.$setViewValue(e.target.checked);\n              switchChange();\n            });\n          }\n        }", "code_tokens": ["function", "(", ")", "{", "if", "(", "attrs", ".", "type", "===", "'radio'", ")", "{", "// when the switch is clicked", "element", ".", "on", "(", "'change.bootstrapSwitch'", ",", "function", "(", "e", ")", "{", "// discard not real change events", "if", "(", "(", "controller", ".", "$modelValue", "===", "controller", ".", "$viewValue", ")", "&&", "(", "e", ".", "target", ".", "checked", "!==", "$", "(", "e", ".", "target", ")", ".", "bootstrapSwitch", "(", "'state'", ")", ")", ")", "{", "// $setViewValue --> $viewValue --> $parsers --> $modelValue", "// if the switch is indeed selected", "if", "(", "e", ".", "target", ".", "checked", ")", "{", "// set its value into the view", "controller", ".", "$setViewValue", "(", "getTrueValue", "(", ")", ")", ";", "}", "else", "if", "(", "getTrueValue", "(", ")", "===", "controller", ".", "$viewValue", ")", "{", "// otherwise if it's been deselected, delete the view value", "controller", ".", "$setViewValue", "(", "undefined", ")", ";", "}", "switchChange", "(", ")", ";", "}", "}", ")", ";", "}", "else", "{", "// When the checkbox switch is clicked, set its value into the ngModel", "element", ".", "on", "(", "'switchChange.bootstrapSwitch'", ",", "function", "(", "e", ")", "{", "// $setViewValue --> $viewValue --> $parsers --> $modelValue", "controller", ".", "$setViewValue", "(", "e", ".", "target", ".", "checked", ")", ";", "switchChange", "(", ")", ";", "}", ")", ";", "}", "}"], "docstring": "Listen to view changes.", "docstring_tokens": ["Listen", "to", "view", "changes", "."], "sha": "e9616e34524ae48dbab730d553438b6657948692", "url": "https://github.com/frapontillo/angular-bootstrap-switch/blob/e9616e34524ae48dbab730d553438b6657948692/dist/angular-bootstrap-switch.js#L237-L264", "partition": "test"}
{"repo": "trendmicro-frontend/react-liquid-gauge", "path": "docs/bundle.js", "func_name": "trapBubbledEvent", "original_string": "function trapBubbledEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n}", "language": "javascript", "code": "function trapBubbledEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n}", "code_tokens": ["function", "trapBubbledEvent", "(", "topLevelType", ",", "handlerBaseName", ",", "element", ")", "{", "if", "(", "!", "element", ")", "{", "return", "null", ";", "}", "return", "EventListener", ".", "listen", "(", "element", ",", "handlerBaseName", ",", "dispatchEvent", ".", "bind", "(", "null", ",", "topLevelType", ")", ")", ";", "}"], "docstring": "Traps top-level events by using event bubbling.\n\n@param {string} topLevelType Record from `BrowserEventConstants`.\n@param {string} handlerBaseName Event name (e.g. \"click\").\n@param {object} element Element on which to attach listener.\n@return {?object} An object with a remove function which will forcefully\nremove the listener.\n@internal", "docstring_tokens": ["Traps", "top", "-", "level", "events", "by", "using", "event", "bubbling", "."], "sha": "c8b24bd48a504539e25553a66097466f75917af6", "url": "https://github.com/trendmicro-frontend/react-liquid-gauge/blob/c8b24bd48a504539e25553a66097466f75917af6/docs/bundle.js#L19662-L19667", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/libpannellum.js", "func_name": "multiresNodeRenderSort", "original_string": "function multiresNodeRenderSort(a, b) {\n        // Lower zoom levels first\n        if (a.level != b.level) {\n            return a.level - b.level;\n        }\n        \n        // Lower distance from center first\n        return a.diff - b.diff;\n    }", "language": "javascript", "code": "function multiresNodeRenderSort(a, b) {\n        // Lower zoom levels first\n        if (a.level != b.level) {\n            return a.level - b.level;\n        }\n        \n        // Lower distance from center first\n        return a.diff - b.diff;\n    }", "code_tokens": ["function", "multiresNodeRenderSort", "(", "a", ",", "b", ")", "{", "// Lower zoom levels first", "if", "(", "a", ".", "level", "!=", "b", ".", "level", ")", "{", "return", "a", ".", "level", "-", "b", ".", "level", ";", "}", "// Lower distance from center first", "return", "a", ".", "diff", "-", "b", ".", "diff", ";", "}"], "docstring": "Sorting method for multires node rendering.\n@private\n@param {MultiresNode} a - First node.\n@param {MultiresNode} b - Second node.\n@returns {number} Lower zoom levels first, then closest to center first.", "docstring_tokens": ["Sorting", "method", "for", "multires", "node", "rendering", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/libpannellum.js#L799-L807", "partition": "test"}
{"repo": "butlerx/event-page", "path": "src/generate.js", "func_name": "render", "original_string": "function render(url) {\n  return async page => {\n    try {\n      const template = `${page.template || 'schedule'}.hbs`;\n      // Load template and compile\n      const filePath = path.join(\n        process.cwd(),\n        config.theme || 'theme',\n        config.template || 'templates',\n        template,\n      );\n      const output = Handlebars.compile(await fs.readFile(filePath, 'utf-8'))(page);\n      await fs.ensureDir(outputDir);\n      // if home page skip else create page dir\n      const dir = url !== 'index' ? path.join(outputDir, url) : outputDir;\n      await fs.ensureDir(dir);\n      await fs.writeFile(path.join(dir, 'index.html'), output, 'utf8');\n    } catch (err) {\n      throw err;\n    }\n  };\n}", "language": "javascript", "code": "function render(url) {\n  return async page => {\n    try {\n      const template = `${page.template || 'schedule'}.hbs`;\n      // Load template and compile\n      const filePath = path.join(\n        process.cwd(),\n        config.theme || 'theme',\n        config.template || 'templates',\n        template,\n      );\n      const output = Handlebars.compile(await fs.readFile(filePath, 'utf-8'))(page);\n      await fs.ensureDir(outputDir);\n      // if home page skip else create page dir\n      const dir = url !== 'index' ? path.join(outputDir, url) : outputDir;\n      await fs.ensureDir(dir);\n      await fs.writeFile(path.join(dir, 'index.html'), output, 'utf8');\n    } catch (err) {\n      throw err;\n    }\n  };\n}", "code_tokens": ["function", "render", "(", "url", ")", "{", "return", "async", "page", "=>", "{", "try", "{", "const", "template", "=", "`", "${", "page", ".", "template", "||", "'schedule'", "}", "`", ";", "// Load template and compile", "const", "filePath", "=", "path", ".", "join", "(", "process", ".", "cwd", "(", ")", ",", "config", ".", "theme", "||", "'theme'", ",", "config", ".", "template", "||", "'templates'", ",", "template", ",", ")", ";", "const", "output", "=", "Handlebars", ".", "compile", "(", "await", "fs", ".", "readFile", "(", "filePath", ",", "'utf-8'", ")", ")", "(", "page", ")", ";", "await", "fs", ".", "ensureDir", "(", "outputDir", ")", ";", "// if home page skip else create page dir", "const", "dir", "=", "url", "!==", "'index'", "?", "path", ".", "join", "(", "outputDir", ",", "url", ")", ":", "outputDir", ";", "await", "fs", ".", "ensureDir", "(", "dir", ")", ";", "await", "fs", ".", "writeFile", "(", "path", ".", "join", "(", "dir", ",", "'index.html'", ")", ",", "output", ",", "'utf8'", ")", ";", "}", "catch", "(", "err", ")", "{", "throw", "err", ";", "}", "}", ";", "}"], "docstring": "Render pages with handle bar template\n@param {string} templateFile - filename of the template\n@param {?} page - data for page\n@param {string} url - url for page to live at\n@return {Promise} - resolves once rendered", "docstring_tokens": ["Render", "pages", "with", "handle", "bar", "template"], "sha": "eddd2b530908c3ad8a95a13e822010691b3d2dc8", "url": "https://github.com/butlerx/event-page/blob/eddd2b530908c3ad8a95a13e822010691b3d2dc8/src/generate.js#L34-L55", "partition": "test"}
{"repo": "dataminr/react-components", "path": "src/js/mixins/PortalMixins.js", "func_name": "", "original_string": "function() {\n        /* eslint-disable no-alert */\n        var close = typeof this.portalConfirmOnCloseMessage === 'string' ? confirm(this.portalConfirmOnCloseMessage) : true;\n        /* eslint-enable no-alert */\n\n        if (this.portalNode && this.portalNode.parentNode && close) {\n            ReactDOM.unmountComponentAtNode(this.portalNode);\n            this.portalNode.parentNode.removeChild(this.portalNode);\n            this.portalNode = null;\n        }\n    }", "language": "javascript", "code": "function() {\n        /* eslint-disable no-alert */\n        var close = typeof this.portalConfirmOnCloseMessage === 'string' ? confirm(this.portalConfirmOnCloseMessage) : true;\n        /* eslint-enable no-alert */\n\n        if (this.portalNode && this.portalNode.parentNode && close) {\n            ReactDOM.unmountComponentAtNode(this.portalNode);\n            this.portalNode.parentNode.removeChild(this.portalNode);\n            this.portalNode = null;\n        }\n    }", "code_tokens": ["function", "(", ")", "{", "/* eslint-disable no-alert */", "var", "close", "=", "typeof", "this", ".", "portalConfirmOnCloseMessage", "===", "'string'", "?", "confirm", "(", "this", ".", "portalConfirmOnCloseMessage", ")", ":", "true", ";", "/* eslint-enable no-alert */", "if", "(", "this", ".", "portalNode", "&&", "this", ".", "portalNode", ".", "parentNode", "&&", "close", ")", "{", "ReactDOM", ".", "unmountComponentAtNode", "(", "this", ".", "portalNode", ")", ";", "this", ".", "portalNode", ".", "parentNode", ".", "removeChild", "(", "this", ".", "portalNode", ")", ";", "this", ".", "portalNode", "=", "null", ";", "}", "}"], "docstring": "Unmounts the components rendered in the portal and removes the associated DOM node.", "docstring_tokens": ["Unmounts", "the", "components", "rendered", "in", "the", "portal", "and", "removes", "the", "associated", "DOM", "node", "."], "sha": "0aa29ed8562ee35fd8e682a5052ac979cd409de7", "url": "https://github.com/dataminr/react-components/blob/0aa29ed8562ee35fd8e682a5052ac979cd409de7/src/js/mixins/PortalMixins.js#L27-L37", "partition": "test"}
{"repo": "reklatsmasters/binary-data", "path": "src/index.js", "func_name": "createEncodeStream", "original_string": "function createEncodeStream(schema) {\n  const stream = new BinaryStream({\n    readableObjectMode: false,\n    writableObjectMode: true,\n    transform: transformEncode,\n  });\n\n  stream[kschema] = schema;\n  return stream;\n}", "language": "javascript", "code": "function createEncodeStream(schema) {\n  const stream = new BinaryStream({\n    readableObjectMode: false,\n    writableObjectMode: true,\n    transform: transformEncode,\n  });\n\n  stream[kschema] = schema;\n  return stream;\n}", "code_tokens": ["function", "createEncodeStream", "(", "schema", ")", "{", "const", "stream", "=", "new", "BinaryStream", "(", "{", "readableObjectMode", ":", "false", ",", "writableObjectMode", ":", "true", ",", "transform", ":", "transformEncode", ",", "}", ")", ";", "stream", "[", "kschema", "]", "=", "schema", ";", "return", "stream", ";", "}"], "docstring": "Create transform stream to encode objects into Buffer.\n@param {Object} [schema]\n@returns {EncodeStream}", "docstring_tokens": ["Create", "transform", "stream", "to", "encode", "objects", "into", "Buffer", "."], "sha": "9d2d3df364e068ccf526f90cada5749a56b6a9c7", "url": "https://github.com/reklatsmasters/binary-data/blob/9d2d3df364e068ccf526f90cada5749a56b6a9c7/src/index.js#L39-L48", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "toggleClass", "original_string": "function toggleClass(element, classToToggle, predicate) {\n\n  // This CANNOT use `classList` internally because IE does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  }\n\n  // If the necessary class operation matches the current state of the\n  // element, no action is required.\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addClass(element, classToToggle);\n  } else {\n    removeClass(element, classToToggle);\n  }\n\n  return element;\n}", "language": "javascript", "code": "function toggleClass(element, classToToggle, predicate) {\n\n  // This CANNOT use `classList` internally because IE does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  }\n\n  // If the necessary class operation matches the current state of the\n  // element, no action is required.\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addClass(element, classToToggle);\n  } else {\n    removeClass(element, classToToggle);\n  }\n\n  return element;\n}", "code_tokens": ["function", "toggleClass", "(", "element", ",", "classToToggle", ",", "predicate", ")", "{", "// This CANNOT use `classList` internally because IE does not support the", "// second parameter to the `classList.toggle()` method! Which is fine because", "// `classList` will be used by the add/remove functions.", "var", "has", "=", "hasClass", "(", "element", ",", "classToToggle", ")", ";", "if", "(", "typeof", "predicate", "===", "'function'", ")", "{", "predicate", "=", "predicate", "(", "element", ",", "classToToggle", ")", ";", "}", "if", "(", "typeof", "predicate", "!==", "'boolean'", ")", "{", "predicate", "=", "!", "has", ";", "}", "// If the necessary class operation matches the current state of the", "// element, no action is required.", "if", "(", "predicate", "===", "has", ")", "{", "return", ";", "}", "if", "(", "predicate", ")", "{", "addClass", "(", "element", ",", "classToToggle", ")", ";", "}", "else", "{", "removeClass", "(", "element", ",", "classToToggle", ")", ";", "}", "return", "element", ";", "}"], "docstring": "The callback definition for toggleElClass.\n\n@callback Dom~PredicateCallback\n@param {Element} element\nThe DOM element of the Component.\n\n@param {string} classToToggle\nThe `className` that wants to be toggled\n\n@return {boolean|undefined}\n- If true the `classToToggle` will get added to `element`.\n- If false the `classToToggle` will get removed from `element`.\n- If undefined this callback will be ignored\n \nAdds or removes a CSS class name on an element depending on an optional\ncondition or the presence/absence of the class name.\n\n@param {Element} element\nThe element to toggle a class name on.\n\n@param {string} classToToggle\nThe class that should be toggled\n\n@param {boolean|PredicateCallback} [predicate]\nSee the return value for {@link Dom~PredicateCallback}\n\n@return {Element}\nThe element with a class that has been toggled.", "docstring_tokens": ["The", "callback", "definition", "for", "toggleElClass", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L919-L947", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "shouldGetter", "original_string": "function shouldGetter() {\n          if (this instanceof String || this instanceof Number || this instanceof Boolean ) {\n            return new Assertion(this.valueOf(), null, shouldGetter);\n          }\n          return new Assertion(this, null, shouldGetter);\n        }", "language": "javascript", "code": "function shouldGetter() {\n          if (this instanceof String || this instanceof Number || this instanceof Boolean ) {\n            return new Assertion(this.valueOf(), null, shouldGetter);\n          }\n          return new Assertion(this, null, shouldGetter);\n        }", "code_tokens": ["function", "shouldGetter", "(", ")", "{", "if", "(", "this", "instanceof", "String", "||", "this", "instanceof", "Number", "||", "this", "instanceof", "Boolean", ")", "{", "return", "new", "Assertion", "(", "this", ".", "valueOf", "(", ")", ",", "null", ",", "shouldGetter", ")", ";", "}", "return", "new", "Assertion", "(", "this", ",", "null", ",", "shouldGetter", ")", ";", "}"], "docstring": "explicitly define this method as function as to have it's name to include as `ssfi`", "docstring_tokens": ["explicitly", "define", "this", "method", "as", "function", "as", "to", "have", "it", "s", "name", "to", "include", "as", "ssfi"], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L71805-L71810", "partition": "test"}
{"repo": "bvellacott/sforce-mocks", "path": "mocks.js", "func_name": "", "original_string": "function(resultAry, isRoot) {\n\t\t\tif(resultAry.length == 0) {\n\t\t\t\tif(isRoot)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone : 'true',\n\t\t\t\t\t\tqueryLocator : null,\n\t\t\t\t\t\tsize : 0,\n\t\t\t\t\t};\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar records = null;\n\t\t\tif(resultAry.length == 1)\n\t\t\t\trecords = resultAry[0];\n\t\t\telse\n\t\t\t\trecords = resultAry;\n\t\t\treturn {\n\t\t\t\tdone : 'true',\n\t\t\t\tqueryLocator : null,\n\t\t\t\trecords : records,\n\t\t\t\tsize : resultAry.length,\n\t\t\t};\n\t\t}", "language": "javascript", "code": "function(resultAry, isRoot) {\n\t\t\tif(resultAry.length == 0) {\n\t\t\t\tif(isRoot)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone : 'true',\n\t\t\t\t\t\tqueryLocator : null,\n\t\t\t\t\t\tsize : 0,\n\t\t\t\t\t};\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar records = null;\n\t\t\tif(resultAry.length == 1)\n\t\t\t\trecords = resultAry[0];\n\t\t\telse\n\t\t\t\trecords = resultAry;\n\t\t\treturn {\n\t\t\t\tdone : 'true',\n\t\t\t\tqueryLocator : null,\n\t\t\t\trecords : records,\n\t\t\t\tsize : resultAry.length,\n\t\t\t};\n\t\t}", "code_tokens": ["function", "(", "resultAry", ",", "isRoot", ")", "{", "if", "(", "resultAry", ".", "length", "==", "0", ")", "{", "if", "(", "isRoot", ")", "return", "{", "done", ":", "'true'", ",", "queryLocator", ":", "null", ",", "size", ":", "0", ",", "}", ";", "return", "null", ";", "}", "var", "records", "=", "null", ";", "if", "(", "resultAry", ".", "length", "==", "1", ")", "records", "=", "resultAry", "[", "0", "]", ";", "else", "records", "=", "resultAry", ";", "return", "{", "done", ":", "'true'", ",", "queryLocator", ":", "null", ",", "records", ":", "records", ",", "size", ":", "resultAry", ".", "length", ",", "}", ";", "}"], "docstring": "Creates a wrapped result in the form that you would expect the salesforce soap api to return a result", "docstring_tokens": ["Creates", "a", "wrapped", "result", "in", "the", "form", "that", "you", "would", "expect", "the", "salesforce", "soap", "api", "to", "return", "a", "result"], "sha": "d49129d81cb41a820621a4cf38766f0e85db7f43", "url": "https://github.com/bvellacott/sforce-mocks/blob/d49129d81cb41a820621a4cf38766f0e85db7f43/mocks.js#L246-L267", "partition": "test"}
{"repo": "gillesfabio/metalsmith-untemplatize", "path": "lib/index.js", "func_name": "plugin", "original_string": "function plugin(options) {\n  options = options || {};\n  options.key = options.key || 'untemplatized';\n  return function(files, metalsmith, done){\n    setImmediate(done);\n    Object.keys(files).forEach(function(file){\n      debug('checking file: %s', file);\n      var data = files[file];\n      var contents = data.contents.toString().replace(/^\\n+/g, '');\n      debug('storing untemplatized content: %s', file);\n      data[options.key] = new Buffer(contents);\n    });\n  };\n}", "language": "javascript", "code": "function plugin(options) {\n  options = options || {};\n  options.key = options.key || 'untemplatized';\n  return function(files, metalsmith, done){\n    setImmediate(done);\n    Object.keys(files).forEach(function(file){\n      debug('checking file: %s', file);\n      var data = files[file];\n      var contents = data.contents.toString().replace(/^\\n+/g, '');\n      debug('storing untemplatized content: %s', file);\n      data[options.key] = new Buffer(contents);\n    });\n  };\n}", "code_tokens": ["function", "plugin", "(", "options", ")", "{", "options", "=", "options", "||", "{", "}", ";", "options", ".", "key", "=", "options", ".", "key", "||", "'untemplatized'", ";", "return", "function", "(", "files", ",", "metalsmith", ",", "done", ")", "{", "setImmediate", "(", "done", ")", ";", "Object", ".", "keys", "(", "files", ")", ".", "forEach", "(", "function", "(", "file", ")", "{", "debug", "(", "'checking file: %s'", ",", "file", ")", ";", "var", "data", "=", "files", "[", "file", "]", ";", "var", "contents", "=", "data", ".", "contents", ".", "toString", "(", ")", ".", "replace", "(", "/", "^\\n+", "/", "g", ",", "''", ")", ";", "debug", "(", "'storing untemplatized content: %s'", ",", "file", ")", ";", "data", "[", "options", ".", "key", "]", "=", "new", "Buffer", "(", "contents", ")", ";", "}", ")", ";", "}", ";", "}"], "docstring": "A Metalsmith plugin to extract untemplatized file contents.\n\n@param  {Object} options\n@return {Function}", "docstring_tokens": ["A", "Metalsmith", "plugin", "to", "extract", "untemplatized", "file", "contents", "."], "sha": "836fbddb05e8548487d15f03f51dae21a4c08475", "url": "https://github.com/gillesfabio/metalsmith-untemplatize/blob/836fbddb05e8548487d15f03f51dae21a4c08475/lib/index.js#L16-L29", "partition": "test"}
{"repo": "yamadapc/jsdoctest", "path": "lib/get-example-code.js", "func_name": "getExampleCode", "original_string": "function getExampleCode(comment) {\n  var expectedResult = comment.expectedResult;\n  var isAsync = comment.isAsync;\n  var testCase = comment.testCase;\n\n  if(isAsync) {\n    return '\\nfunction cb(err, result) {' +\n      'if(err) return done(err);' +\n      'result.should.eql(' + expectedResult + ');' +\n      'done();' +\n    '}\\n' +\n    'var returnValue = ' + testCase + ';' +\n    'if(returnValue && returnValue.then && typeof returnValue.then === \\'function\\') {' +\n      'returnValue.then(cb.bind(null, null), cb);' +\n    '}';\n  } else {\n    return '(' + testCase + ').should.eql(' + expectedResult + ');';\n  }\n}", "language": "javascript", "code": "function getExampleCode(comment) {\n  var expectedResult = comment.expectedResult;\n  var isAsync = comment.isAsync;\n  var testCase = comment.testCase;\n\n  if(isAsync) {\n    return '\\nfunction cb(err, result) {' +\n      'if(err) return done(err);' +\n      'result.should.eql(' + expectedResult + ');' +\n      'done();' +\n    '}\\n' +\n    'var returnValue = ' + testCase + ';' +\n    'if(returnValue && returnValue.then && typeof returnValue.then === \\'function\\') {' +\n      'returnValue.then(cb.bind(null, null), cb);' +\n    '}';\n  } else {\n    return '(' + testCase + ').should.eql(' + expectedResult + ');';\n  }\n}", "code_tokens": ["function", "getExampleCode", "(", "comment", ")", "{", "var", "expectedResult", "=", "comment", ".", "expectedResult", ";", "var", "isAsync", "=", "comment", ".", "isAsync", ";", "var", "testCase", "=", "comment", ".", "testCase", ";", "if", "(", "isAsync", ")", "{", "return", "'\\nfunction cb(err, result) {'", "+", "'if(err) return done(err);'", "+", "'result.should.eql('", "+", "expectedResult", "+", "');'", "+", "'done();'", "+", "'}\\n'", "+", "'var returnValue = '", "+", "testCase", "+", "';'", "+", "'if(returnValue && returnValue.then && typeof returnValue.then === \\'function\\') {'", "+", "'returnValue.then(cb.bind(null, null), cb);'", "+", "'}'", ";", "}", "else", "{", "return", "'('", "+", "testCase", "+", "').should.eql('", "+", "expectedResult", "+", "');'", ";", "}", "}"], "docstring": "Compiles down an `example`. Async examples call an imaginary `done` function\nonce they're done.\n\n@param {Object} comment\n@param {String} comment.testCase\n@param {String} comment.expectedResult\n@param {Boolean} comment.isAsync\n@return {String}", "docstring_tokens": ["Compiles", "down", "an", "example", ".", "Async", "examples", "call", "an", "imaginary", "done", "function", "once", "they", "re", "done", "."], "sha": "ccd6cdbff8a4db98d20da8ac1868558a45913005", "url": "https://github.com/yamadapc/jsdoctest/blob/ccd6cdbff8a4db98d20da8ac1868558a45913005/lib/get-example-code.js#L16-L34", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/xhr/XMLHttpRequest.js", "func_name": "", "original_string": "function() {\n\t\t\t\t_error_flag = true;\n\t\t\t\t_sync_flag = false;\n\n\t\t\t\tif (!~Basic.inArray(_p('readyState'), [XMLHttpRequest.UNSENT, XMLHttpRequest.OPENED, XMLHttpRequest.DONE])) {\n\t\t\t\t\t_p('readyState', XMLHttpRequest.DONE);\n\t\t\t\t\t_send_flag = false;\n\n\t\t\t\t\tif (_xhr) {\n\t\t\t\t\t\t_xhr.getRuntime().exec.call(_xhr, 'XMLHttpRequest', 'abort', _upload_complete_flag);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new x.DOMException(x.DOMException.INVALID_STATE_ERR);\n\t\t\t\t\t}\n\n\t\t\t\t\t_upload_complete_flag = true;\n\t\t\t\t} else {\n\t\t\t\t\t_p('readyState', XMLHttpRequest.UNSENT);\n\t\t\t\t}\n\t\t\t}", "language": "javascript", "code": "function() {\n\t\t\t\t_error_flag = true;\n\t\t\t\t_sync_flag = false;\n\n\t\t\t\tif (!~Basic.inArray(_p('readyState'), [XMLHttpRequest.UNSENT, XMLHttpRequest.OPENED, XMLHttpRequest.DONE])) {\n\t\t\t\t\t_p('readyState', XMLHttpRequest.DONE);\n\t\t\t\t\t_send_flag = false;\n\n\t\t\t\t\tif (_xhr) {\n\t\t\t\t\t\t_xhr.getRuntime().exec.call(_xhr, 'XMLHttpRequest', 'abort', _upload_complete_flag);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new x.DOMException(x.DOMException.INVALID_STATE_ERR);\n\t\t\t\t\t}\n\n\t\t\t\t\t_upload_complete_flag = true;\n\t\t\t\t} else {\n\t\t\t\t\t_p('readyState', XMLHttpRequest.UNSENT);\n\t\t\t\t}\n\t\t\t}", "code_tokens": ["function", "(", ")", "{", "_error_flag", "=", "true", ";", "_sync_flag", "=", "false", ";", "if", "(", "!", "~", "Basic", ".", "inArray", "(", "_p", "(", "'readyState'", ")", ",", "[", "XMLHttpRequest", ".", "UNSENT", ",", "XMLHttpRequest", ".", "OPENED", ",", "XMLHttpRequest", ".", "DONE", "]", ")", ")", "{", "_p", "(", "'readyState'", ",", "XMLHttpRequest", ".", "DONE", ")", ";", "_send_flag", "=", "false", ";", "if", "(", "_xhr", ")", "{", "_xhr", ".", "getRuntime", "(", ")", ".", "exec", ".", "call", "(", "_xhr", ",", "'XMLHttpRequest'", ",", "'abort'", ",", "_upload_complete_flag", ")", ";", "}", "else", "{", "throw", "new", "x", ".", "DOMException", "(", "x", ".", "DOMException", ".", "INVALID_STATE_ERR", ")", ";", "}", "_upload_complete_flag", "=", "true", ";", "}", "else", "{", "_p", "(", "'readyState'", ",", "XMLHttpRequest", ".", "UNSENT", ")", ";", "}", "}"], "docstring": "Cancels any network activity.\n\n@method abort", "docstring_tokens": ["Cancels", "any", "network", "activity", "."], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/xhr/XMLHttpRequest.js#L607-L625", "partition": "test"}
{"repo": "mongodb-js/mongodb-extjson", "path": "lib/bson/binary.js", "func_name": "convert", "original_string": "function convert(integer) {\n  var str = Number(integer).toString(16);\n  return str.length === 1 ? '0' + str : str;\n}", "language": "javascript", "code": "function convert(integer) {\n  var str = Number(integer).toString(16);\n  return str.length === 1 ? '0' + str : str;\n}", "code_tokens": ["function", "convert", "(", "integer", ")", "{", "var", "str", "=", "Number", "(", "integer", ")", ".", "toString", "(", "16", ")", ";", "return", "str", ".", "length", "===", "1", "?", "'0'", "+", "str", ":", "str", ";", "}"], "docstring": "Module dependencies.\n@ignore", "docstring_tokens": ["Module", "dependencies", "."], "sha": "d60c810266dcaa31e124a87a7224567c8330ea62", "url": "https://github.com/mongodb-js/mongodb-extjson/blob/d60c810266dcaa31e124a87a7224567c8330ea62/lib/bson/binary.js#L7-L10", "partition": "test"}
{"repo": "wjbryant/taboverride", "path": "build/output/taboverride.js", "func_name": "overrideKeyDown", "original_string": "function overrideKeyDown(e) {\n        e = e || event;\n\n        // textarea elements can only contain text nodes which don't receive\n        // keydown events, so the event target/srcElement will always be the\n        // textarea element, however, prefer currentTarget in order to support\n        // delegated events in compliant browsers\n        var target = e.currentTarget || e.srcElement, // don't use the \"this\" keyword (doesn't work in old IE)\n            key = e.keyCode, // the key code for the key that was pressed\n            tab, // the string representing a tab\n            tabLen, // the length of a tab\n            text, // initial text in the textarea\n            range, // the IE TextRange object\n            tempRange, // used to calculate selection start and end positions in IE\n            preNewlines, // the number of newline character sequences before the selection start (for IE)\n            selNewlines, // the number of newline character sequences within the selection (for IE)\n            initScrollTop, // initial scrollTop value used to fix scrolling in Firefox\n            selStart, // the selection start position\n            selEnd, // the selection end position\n            sel, // the selected text\n            startLine, // for multi-line selections, the first character position of the first line\n            endLine, // for multi-line selections, the last character position of the last line\n            numTabs, // the number of tabs inserted / removed in the selection\n            startTab, // if a tab was removed from the start of the first line\n            preTab, // if a tab was removed before the start of the selection\n            whitespace, // the whitespace at the beginning of the first selected line\n            whitespaceLen, // the length of the whitespace at the beginning of the first selected line\n            CHARACTER = 'character'; // string constant used for the Range.move methods\n\n        // don't do any unnecessary work\n        if ((target.nodeName && target.nodeName.toLowerCase() !== 'textarea') ||\n                (key !== tabKey && key !== untabKey && (key !== 13 || !autoIndent))) {\n            return;\n        }\n\n        // initialize variables used for tab and enter keys\n        inWhitespace = false; // this will be set to true if enter is pressed in the leading whitespace\n        text = target.value;\n\n        // this is really just for Firefox, but will be used by all browsers that support\n        // selectionStart and selectionEnd - whenever the textarea value property is reset,\n        // Firefox scrolls back to the top - this is used to set it back to the original value\n        // scrollTop is nonstandard, but supported by all modern browsers\n        initScrollTop = target.scrollTop;\n\n        // get the text selection\n        if (typeof target.selectionStart === 'number') {\n            selStart = target.selectionStart;\n            selEnd = target.selectionEnd;\n            sel = text.slice(selStart, selEnd);\n\n        } else if (document.selection) { // IE\n            range = document.selection.createRange();\n            sel = range.text;\n            tempRange = range.duplicate();\n            tempRange.moveToElementText(target);\n            tempRange.setEndPoint('EndToEnd', range);\n            selEnd = tempRange.text.length;\n            selStart = selEnd - sel.length;\n\n            // whenever the value of the textarea is changed, the range needs to be reset\n            // IE <9 (and Opera) use both \\r and \\n for newlines - this adds an extra character\n            // that needs to be accounted for when doing position calculations with ranges\n            // these values are used to offset the selection start and end positions\n            if (newlineLen > 1) {\n                preNewlines = text.slice(0, selStart).split(newline).length - 1;\n                selNewlines = sel.split(newline).length - 1;\n            } else {\n                preNewlines = selNewlines = 0;\n            }\n        } else {\n            return; // cannot access textarea selection - do nothing\n        }\n\n        // tab / untab key - insert / remove tab\n        if (key === tabKey || key === untabKey) {\n\n            // initialize tab variables\n            tab = aTab;\n            tabLen = tab.length;\n            numTabs = 0;\n            startTab = 0;\n            preTab = 0;\n\n            // multi-line selection\n            if (selStart !== selEnd && sel.indexOf('\\n') !== -1) {\n                // for multiple lines, only insert / remove tabs from the beginning of each line\n\n                // find the start of the first selected line\n                if (selStart === 0 || text.charAt(selStart - 1) === '\\n') {\n                    // the selection starts at the beginning of a line\n                    startLine = selStart;\n                } else {\n                    // the selection starts after the beginning of a line\n                    // set startLine to the beginning of the first partially selected line\n                    // subtract 1 from selStart in case the cursor is at the newline character,\n                    // for instance, if the very end of the previous line was selected\n                    // add 1 to get the next character after the newline\n                    // if there is none before the selection, lastIndexOf returns -1\n                    // when 1 is added to that it becomes 0 and the first character is used\n                    startLine = text.lastIndexOf('\\n', selStart - 1) + 1;\n                }\n\n                // find the end of the last selected line\n                if (selEnd === text.length || text.charAt(selEnd) === '\\n') {\n                    // the selection ends at the end of a line\n                    endLine = selEnd;\n                } else if (text.charAt(selEnd - 1) === '\\n') {\n                    // the selection ends at the start of a line, but no\n                    // characters are selected - don't indent this line\n                    endLine = selEnd - 1;\n                } else {\n                    // the selection ends before the end of a line\n                    // set endLine to the end of the last partially selected line\n                    endLine = text.indexOf('\\n', selEnd);\n                    if (endLine === -1) {\n                        endLine = text.length;\n                    }\n                }\n\n                // tab key combo - insert tabs\n                if (tabKeyComboPressed(key, e)) {\n\n                    numTabs = 1; // for the first tab\n\n                    // insert tabs at the beginning of each line of the selection\n                    target.value = text.slice(0, startLine) + tab +\n                        text.slice(startLine, endLine).replace(/\\n/g, function () {\n                            numTabs += 1;\n                            return '\\n' + tab;\n                        }) + text.slice(endLine);\n\n                    // set start and end points\n                    if (range) { // IE\n                        range.collapse();\n                        range.moveEnd(CHARACTER, selEnd + (numTabs * tabLen) - selNewlines - preNewlines);\n                        range.moveStart(CHARACTER, selStart + tabLen - preNewlines);\n                        range.select();\n                    } else {\n                        // the selection start is always moved by 1 character\n                        target.selectionStart = selStart + tabLen;\n                        // move the selection end over by the total number of tabs inserted\n                        target.selectionEnd = selEnd + (numTabs * tabLen);\n                        target.scrollTop = initScrollTop;\n                    }\n                } else if (untabKeyComboPressed(key, e)) {\n                    // if the untab key combo was pressed, remove tabs instead of inserting them\n\n                    if (text.slice(startLine).indexOf(tab) === 0) {\n                        // is this tab part of the selection?\n                        if (startLine === selStart) {\n                            // it is, remove it\n                            sel = sel.slice(tabLen);\n                        } else {\n                            // the tab comes before the selection\n                            preTab = tabLen;\n                        }\n                        startTab = tabLen;\n                    }\n\n                    target.value = text.slice(0, startLine) + text.slice(startLine + preTab, selStart) +\n                        sel.replace(new RegExp('\\n' + tab, 'g'), function () {\n                            numTabs += 1;\n                            return '\\n';\n                        }) + text.slice(selEnd);\n\n                    // set start and end points\n                    if (range) { // IE\n                        // setting end first makes calculations easier\n                        range.collapse();\n                        range.moveEnd(CHARACTER, selEnd - startTab - (numTabs * tabLen) - selNewlines - preNewlines);\n                        range.moveStart(CHARACTER, selStart - preTab - preNewlines);\n                        range.select();\n                    } else {\n                        // set start first for Opera\n                        target.selectionStart = selStart - preTab; // preTab is 0 or tabLen\n                        // move the selection end over by the total number of tabs removed\n                        target.selectionEnd = selEnd - startTab - (numTabs * tabLen);\n                    }\n                } else {\n                    return; // do nothing for invalid key combinations\n                }\n\n            } else { // single line selection\n\n                // tab key combo - insert a tab\n                if (tabKeyComboPressed(key, e)) {\n                    if (range) { // IE\n                        range.text = tab;\n                        range.select();\n                    } else {\n                        target.value = text.slice(0, selStart) + tab + text.slice(selEnd);\n                        target.selectionEnd = target.selectionStart = selStart + tabLen;\n                        target.scrollTop = initScrollTop;\n                    }\n                } else if (untabKeyComboPressed(key, e)) {\n                    // if the untab key combo was pressed, remove a tab instead of inserting one\n\n                    // if the character before the selection is a tab, remove it\n                    if (text.slice(selStart - tabLen).indexOf(tab) === 0) {\n                        target.value = text.slice(0, selStart - tabLen) + text.slice(selStart);\n\n                        // set start and end points\n                        if (range) { // IE\n                            // collapses range and moves it by -1 tab\n                            range.move(CHARACTER, selStart - tabLen - preNewlines);\n                            range.select();\n                        } else {\n                            target.selectionEnd = target.selectionStart = selStart - tabLen;\n                            target.scrollTop = initScrollTop;\n                        }\n                    }\n                } else {\n                    return; // do nothing for invalid key combinations\n                }\n            }\n        } else if (autoIndent) { // Enter key\n            // insert a newline and copy the whitespace from the beginning of the line\n\n            // find the start of the first selected line\n            if (selStart === 0 || text.charAt(selStart - 1) === '\\n') {\n                // the selection starts at the beginning of a line\n                // do nothing special\n                inWhitespace = true;\n                return;\n            }\n\n            // see explanation under \"multi-line selection\" above\n            startLine = text.lastIndexOf('\\n', selStart - 1) + 1;\n\n            // find the end of the first selected line\n            endLine = text.indexOf('\\n', selStart);\n\n            // if no newline is found, set endLine to the end of the text\n            if (endLine === -1) {\n                endLine = text.length;\n            }\n\n            // get the whitespace at the beginning of the first selected line (spaces and tabs only)\n            whitespace = text.slice(startLine, endLine).match(/^[ \\t]*/)[0];\n            whitespaceLen = whitespace.length;\n\n            // the cursor (selStart) is in the whitespace at beginning of the line\n            // do nothing special\n            if (selStart < startLine + whitespaceLen) {\n                inWhitespace = true;\n                return;\n            }\n\n            if (range) { // IE\n                // insert the newline and whitespace\n                range.text = '\\n' + whitespace;\n                range.select();\n            } else {\n                // insert the newline and whitespace\n                target.value = text.slice(0, selStart) + '\\n' + whitespace + text.slice(selEnd);\n                // Opera uses \\r\\n for a newline, instead of \\n,\n                // so use newlineLen instead of a hard-coded value\n                target.selectionEnd = target.selectionStart = selStart + newlineLen + whitespaceLen;\n                target.scrollTop = initScrollTop;\n            }\n        }\n\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n            return false;\n        }\n    }", "language": "javascript", "code": "function overrideKeyDown(e) {\n        e = e || event;\n\n        // textarea elements can only contain text nodes which don't receive\n        // keydown events, so the event target/srcElement will always be the\n        // textarea element, however, prefer currentTarget in order to support\n        // delegated events in compliant browsers\n        var target = e.currentTarget || e.srcElement, // don't use the \"this\" keyword (doesn't work in old IE)\n            key = e.keyCode, // the key code for the key that was pressed\n            tab, // the string representing a tab\n            tabLen, // the length of a tab\n            text, // initial text in the textarea\n            range, // the IE TextRange object\n            tempRange, // used to calculate selection start and end positions in IE\n            preNewlines, // the number of newline character sequences before the selection start (for IE)\n            selNewlines, // the number of newline character sequences within the selection (for IE)\n            initScrollTop, // initial scrollTop value used to fix scrolling in Firefox\n            selStart, // the selection start position\n            selEnd, // the selection end position\n            sel, // the selected text\n            startLine, // for multi-line selections, the first character position of the first line\n            endLine, // for multi-line selections, the last character position of the last line\n            numTabs, // the number of tabs inserted / removed in the selection\n            startTab, // if a tab was removed from the start of the first line\n            preTab, // if a tab was removed before the start of the selection\n            whitespace, // the whitespace at the beginning of the first selected line\n            whitespaceLen, // the length of the whitespace at the beginning of the first selected line\n            CHARACTER = 'character'; // string constant used for the Range.move methods\n\n        // don't do any unnecessary work\n        if ((target.nodeName && target.nodeName.toLowerCase() !== 'textarea') ||\n                (key !== tabKey && key !== untabKey && (key !== 13 || !autoIndent))) {\n            return;\n        }\n\n        // initialize variables used for tab and enter keys\n        inWhitespace = false; // this will be set to true if enter is pressed in the leading whitespace\n        text = target.value;\n\n        // this is really just for Firefox, but will be used by all browsers that support\n        // selectionStart and selectionEnd - whenever the textarea value property is reset,\n        // Firefox scrolls back to the top - this is used to set it back to the original value\n        // scrollTop is nonstandard, but supported by all modern browsers\n        initScrollTop = target.scrollTop;\n\n        // get the text selection\n        if (typeof target.selectionStart === 'number') {\n            selStart = target.selectionStart;\n            selEnd = target.selectionEnd;\n            sel = text.slice(selStart, selEnd);\n\n        } else if (document.selection) { // IE\n            range = document.selection.createRange();\n            sel = range.text;\n            tempRange = range.duplicate();\n            tempRange.moveToElementText(target);\n            tempRange.setEndPoint('EndToEnd', range);\n            selEnd = tempRange.text.length;\n            selStart = selEnd - sel.length;\n\n            // whenever the value of the textarea is changed, the range needs to be reset\n            // IE <9 (and Opera) use both \\r and \\n for newlines - this adds an extra character\n            // that needs to be accounted for when doing position calculations with ranges\n            // these values are used to offset the selection start and end positions\n            if (newlineLen > 1) {\n                preNewlines = text.slice(0, selStart).split(newline).length - 1;\n                selNewlines = sel.split(newline).length - 1;\n            } else {\n                preNewlines = selNewlines = 0;\n            }\n        } else {\n            return; // cannot access textarea selection - do nothing\n        }\n\n        // tab / untab key - insert / remove tab\n        if (key === tabKey || key === untabKey) {\n\n            // initialize tab variables\n            tab = aTab;\n            tabLen = tab.length;\n            numTabs = 0;\n            startTab = 0;\n            preTab = 0;\n\n            // multi-line selection\n            if (selStart !== selEnd && sel.indexOf('\\n') !== -1) {\n                // for multiple lines, only insert / remove tabs from the beginning of each line\n\n                // find the start of the first selected line\n                if (selStart === 0 || text.charAt(selStart - 1) === '\\n') {\n                    // the selection starts at the beginning of a line\n                    startLine = selStart;\n                } else {\n                    // the selection starts after the beginning of a line\n                    // set startLine to the beginning of the first partially selected line\n                    // subtract 1 from selStart in case the cursor is at the newline character,\n                    // for instance, if the very end of the previous line was selected\n                    // add 1 to get the next character after the newline\n                    // if there is none before the selection, lastIndexOf returns -1\n                    // when 1 is added to that it becomes 0 and the first character is used\n                    startLine = text.lastIndexOf('\\n', selStart - 1) + 1;\n                }\n\n                // find the end of the last selected line\n                if (selEnd === text.length || text.charAt(selEnd) === '\\n') {\n                    // the selection ends at the end of a line\n                    endLine = selEnd;\n                } else if (text.charAt(selEnd - 1) === '\\n') {\n                    // the selection ends at the start of a line, but no\n                    // characters are selected - don't indent this line\n                    endLine = selEnd - 1;\n                } else {\n                    // the selection ends before the end of a line\n                    // set endLine to the end of the last partially selected line\n                    endLine = text.indexOf('\\n', selEnd);\n                    if (endLine === -1) {\n                        endLine = text.length;\n                    }\n                }\n\n                // tab key combo - insert tabs\n                if (tabKeyComboPressed(key, e)) {\n\n                    numTabs = 1; // for the first tab\n\n                    // insert tabs at the beginning of each line of the selection\n                    target.value = text.slice(0, startLine) + tab +\n                        text.slice(startLine, endLine).replace(/\\n/g, function () {\n                            numTabs += 1;\n                            return '\\n' + tab;\n                        }) + text.slice(endLine);\n\n                    // set start and end points\n                    if (range) { // IE\n                        range.collapse();\n                        range.moveEnd(CHARACTER, selEnd + (numTabs * tabLen) - selNewlines - preNewlines);\n                        range.moveStart(CHARACTER, selStart + tabLen - preNewlines);\n                        range.select();\n                    } else {\n                        // the selection start is always moved by 1 character\n                        target.selectionStart = selStart + tabLen;\n                        // move the selection end over by the total number of tabs inserted\n                        target.selectionEnd = selEnd + (numTabs * tabLen);\n                        target.scrollTop = initScrollTop;\n                    }\n                } else if (untabKeyComboPressed(key, e)) {\n                    // if the untab key combo was pressed, remove tabs instead of inserting them\n\n                    if (text.slice(startLine).indexOf(tab) === 0) {\n                        // is this tab part of the selection?\n                        if (startLine === selStart) {\n                            // it is, remove it\n                            sel = sel.slice(tabLen);\n                        } else {\n                            // the tab comes before the selection\n                            preTab = tabLen;\n                        }\n                        startTab = tabLen;\n                    }\n\n                    target.value = text.slice(0, startLine) + text.slice(startLine + preTab, selStart) +\n                        sel.replace(new RegExp('\\n' + tab, 'g'), function () {\n                            numTabs += 1;\n                            return '\\n';\n                        }) + text.slice(selEnd);\n\n                    // set start and end points\n                    if (range) { // IE\n                        // setting end first makes calculations easier\n                        range.collapse();\n                        range.moveEnd(CHARACTER, selEnd - startTab - (numTabs * tabLen) - selNewlines - preNewlines);\n                        range.moveStart(CHARACTER, selStart - preTab - preNewlines);\n                        range.select();\n                    } else {\n                        // set start first for Opera\n                        target.selectionStart = selStart - preTab; // preTab is 0 or tabLen\n                        // move the selection end over by the total number of tabs removed\n                        target.selectionEnd = selEnd - startTab - (numTabs * tabLen);\n                    }\n                } else {\n                    return; // do nothing for invalid key combinations\n                }\n\n            } else { // single line selection\n\n                // tab key combo - insert a tab\n                if (tabKeyComboPressed(key, e)) {\n                    if (range) { // IE\n                        range.text = tab;\n                        range.select();\n                    } else {\n                        target.value = text.slice(0, selStart) + tab + text.slice(selEnd);\n                        target.selectionEnd = target.selectionStart = selStart + tabLen;\n                        target.scrollTop = initScrollTop;\n                    }\n                } else if (untabKeyComboPressed(key, e)) {\n                    // if the untab key combo was pressed, remove a tab instead of inserting one\n\n                    // if the character before the selection is a tab, remove it\n                    if (text.slice(selStart - tabLen).indexOf(tab) === 0) {\n                        target.value = text.slice(0, selStart - tabLen) + text.slice(selStart);\n\n                        // set start and end points\n                        if (range) { // IE\n                            // collapses range and moves it by -1 tab\n                            range.move(CHARACTER, selStart - tabLen - preNewlines);\n                            range.select();\n                        } else {\n                            target.selectionEnd = target.selectionStart = selStart - tabLen;\n                            target.scrollTop = initScrollTop;\n                        }\n                    }\n                } else {\n                    return; // do nothing for invalid key combinations\n                }\n            }\n        } else if (autoIndent) { // Enter key\n            // insert a newline and copy the whitespace from the beginning of the line\n\n            // find the start of the first selected line\n            if (selStart === 0 || text.charAt(selStart - 1) === '\\n') {\n                // the selection starts at the beginning of a line\n                // do nothing special\n                inWhitespace = true;\n                return;\n            }\n\n            // see explanation under \"multi-line selection\" above\n            startLine = text.lastIndexOf('\\n', selStart - 1) + 1;\n\n            // find the end of the first selected line\n            endLine = text.indexOf('\\n', selStart);\n\n            // if no newline is found, set endLine to the end of the text\n            if (endLine === -1) {\n                endLine = text.length;\n            }\n\n            // get the whitespace at the beginning of the first selected line (spaces and tabs only)\n            whitespace = text.slice(startLine, endLine).match(/^[ \\t]*/)[0];\n            whitespaceLen = whitespace.length;\n\n            // the cursor (selStart) is in the whitespace at beginning of the line\n            // do nothing special\n            if (selStart < startLine + whitespaceLen) {\n                inWhitespace = true;\n                return;\n            }\n\n            if (range) { // IE\n                // insert the newline and whitespace\n                range.text = '\\n' + whitespace;\n                range.select();\n            } else {\n                // insert the newline and whitespace\n                target.value = text.slice(0, selStart) + '\\n' + whitespace + text.slice(selEnd);\n                // Opera uses \\r\\n for a newline, instead of \\n,\n                // so use newlineLen instead of a hard-coded value\n                target.selectionEnd = target.selectionStart = selStart + newlineLen + whitespaceLen;\n                target.scrollTop = initScrollTop;\n            }\n        }\n\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n            return false;\n        }\n    }", "code_tokens": ["function", "overrideKeyDown", "(", "e", ")", "{", "e", "=", "e", "||", "event", ";", "// textarea elements can only contain text nodes which don't receive", "// keydown events, so the event target/srcElement will always be the", "// textarea element, however, prefer currentTarget in order to support", "// delegated events in compliant browsers", "var", "target", "=", "e", ".", "currentTarget", "||", "e", ".", "srcElement", ",", "// don't use the \"this\" keyword (doesn't work in old IE)", "key", "=", "e", ".", "keyCode", ",", "// the key code for the key that was pressed", "tab", ",", "// the string representing a tab", "tabLen", ",", "// the length of a tab", "text", ",", "// initial text in the textarea", "range", ",", "// the IE TextRange object", "tempRange", ",", "// used to calculate selection start and end positions in IE", "preNewlines", ",", "// the number of newline character sequences before the selection start (for IE)", "selNewlines", ",", "// the number of newline character sequences within the selection (for IE)", "initScrollTop", ",", "// initial scrollTop value used to fix scrolling in Firefox", "selStart", ",", "// the selection start position", "selEnd", ",", "// the selection end position", "sel", ",", "// the selected text", "startLine", ",", "// for multi-line selections, the first character position of the first line", "endLine", ",", "// for multi-line selections, the last character position of the last line", "numTabs", ",", "// the number of tabs inserted / removed in the selection", "startTab", ",", "// if a tab was removed from the start of the first line", "preTab", ",", "// if a tab was removed before the start of the selection", "whitespace", ",", "// the whitespace at the beginning of the first selected line", "whitespaceLen", ",", "// the length of the whitespace at the beginning of the first selected line", "CHARACTER", "=", "'character'", ";", "// string constant used for the Range.move methods", "// don't do any unnecessary work", "if", "(", "(", "target", ".", "nodeName", "&&", "target", ".", "nodeName", ".", "toLowerCase", "(", ")", "!==", "'textarea'", ")", "||", "(", "key", "!==", "tabKey", "&&", "key", "!==", "untabKey", "&&", "(", "key", "!==", "13", "||", "!", "autoIndent", ")", ")", ")", "{", "return", ";", "}", "// initialize variables used for tab and enter keys", "inWhitespace", "=", "false", ";", "// this will be set to true if enter is pressed in the leading whitespace", "text", "=", "target", ".", "value", ";", "// this is really just for Firefox, but will be used by all browsers that support", "// selectionStart and selectionEnd - whenever the textarea value property is reset,", "// Firefox scrolls back to the top - this is used to set it back to the original value", "// scrollTop is nonstandard, but supported by all modern browsers", "initScrollTop", "=", "target", ".", "scrollTop", ";", "// get the text selection", "if", "(", "typeof", "target", ".", "selectionStart", "===", "'number'", ")", "{", "selStart", "=", "target", ".", "selectionStart", ";", "selEnd", "=", "target", ".", "selectionEnd", ";", "sel", "=", "text", ".", "slice", "(", "selStart", ",", "selEnd", ")", ";", "}", "else", "if", "(", "document", ".", "selection", ")", "{", "// IE", "range", "=", "document", ".", "selection", ".", "createRange", "(", ")", ";", "sel", "=", "range", ".", "text", ";", "tempRange", "=", "range", ".", "duplicate", "(", ")", ";", "tempRange", ".", "moveToElementText", "(", "target", ")", ";", "tempRange", ".", "setEndPoint", "(", "'EndToEnd'", ",", "range", ")", ";", "selEnd", "=", "tempRange", ".", "text", ".", "length", ";", "selStart", "=", "selEnd", "-", "sel", ".", "length", ";", "// whenever the value of the textarea is changed, the range needs to be reset", "// IE <9 (and Opera) use both \\r and \\n for newlines - this adds an extra character", "// that needs to be accounted for when doing position calculations with ranges", "// these values are used to offset the selection start and end positions", "if", "(", "newlineLen", ">", "1", ")", "{", "preNewlines", "=", "text", ".", "slice", "(", "0", ",", "selStart", ")", ".", "split", "(", "newline", ")", ".", "length", "-", "1", ";", "selNewlines", "=", "sel", ".", "split", "(", "newline", ")", ".", "length", "-", "1", ";", "}", "else", "{", "preNewlines", "=", "selNewlines", "=", "0", ";", "}", "}", "else", "{", "return", ";", "// cannot access textarea selection - do nothing", "}", "// tab / untab key - insert / remove tab", "if", "(", "key", "===", "tabKey", "||", "key", "===", "untabKey", ")", "{", "// initialize tab variables", "tab", "=", "aTab", ";", "tabLen", "=", "tab", ".", "length", ";", "numTabs", "=", "0", ";", "startTab", "=", "0", ";", "preTab", "=", "0", ";", "// multi-line selection", "if", "(", "selStart", "!==", "selEnd", "&&", "sel", ".", "indexOf", "(", "'\\n'", ")", "!==", "-", "1", ")", "{", "// for multiple lines, only insert / remove tabs from the beginning of each line", "// find the start of the first selected line", "if", "(", "selStart", "===", "0", "||", "text", ".", "charAt", "(", "selStart", "-", "1", ")", "===", "'\\n'", ")", "{", "// the selection starts at the beginning of a line", "startLine", "=", "selStart", ";", "}", "else", "{", "// the selection starts after the beginning of a line", "// set startLine to the beginning of the first partially selected line", "// subtract 1 from selStart in case the cursor is at the newline character,", "// for instance, if the very end of the previous line was selected", "// add 1 to get the next character after the newline", "// if there is none before the selection, lastIndexOf returns -1", "// when 1 is added to that it becomes 0 and the first character is used", "startLine", "=", "text", ".", "lastIndexOf", "(", "'\\n'", ",", "selStart", "-", "1", ")", "+", "1", ";", "}", "// find the end of the last selected line", "if", "(", "selEnd", "===", "text", ".", "length", "||", "text", ".", "charAt", "(", "selEnd", ")", "===", "'\\n'", ")", "{", "// the selection ends at the end of a line", "endLine", "=", "selEnd", ";", "}", "else", "if", "(", "text", ".", "charAt", "(", "selEnd", "-", "1", ")", "===", "'\\n'", ")", "{", "// the selection ends at the start of a line, but no", "// characters are selected - don't indent this line", "endLine", "=", "selEnd", "-", "1", ";", "}", "else", "{", "// the selection ends before the end of a line", "// set endLine to the end of the last partially selected line", "endLine", "=", "text", ".", "indexOf", "(", "'\\n'", ",", "selEnd", ")", ";", "if", "(", "endLine", "===", "-", "1", ")", "{", "endLine", "=", "text", ".", "length", ";", "}", "}", "// tab key combo - insert tabs", "if", "(", "tabKeyComboPressed", "(", "key", ",", "e", ")", ")", "{", "numTabs", "=", "1", ";", "// for the first tab", "// insert tabs at the beginning of each line of the selection", "target", ".", "value", "=", "text", ".", "slice", "(", "0", ",", "startLine", ")", "+", "tab", "+", "text", ".", "slice", "(", "startLine", ",", "endLine", ")", ".", "replace", "(", "/", "\\n", "/", "g", ",", "function", "(", ")", "{", "numTabs", "+=", "1", ";", "return", "'\\n'", "+", "tab", ";", "}", ")", "+", "text", ".", "slice", "(", "endLine", ")", ";", "// set start and end points", "if", "(", "range", ")", "{", "// IE", "range", ".", "collapse", "(", ")", ";", "range", ".", "moveEnd", "(", "CHARACTER", ",", "selEnd", "+", "(", "numTabs", "*", "tabLen", ")", "-", "selNewlines", "-", "preNewlines", ")", ";", "range", ".", "moveStart", "(", "CHARACTER", ",", "selStart", "+", "tabLen", "-", "preNewlines", ")", ";", "range", ".", "select", "(", ")", ";", "}", "else", "{", "// the selection start is always moved by 1 character", "target", ".", "selectionStart", "=", "selStart", "+", "tabLen", ";", "// move the selection end over by the total number of tabs inserted", "target", ".", "selectionEnd", "=", "selEnd", "+", "(", "numTabs", "*", "tabLen", ")", ";", "target", ".", "scrollTop", "=", "initScrollTop", ";", "}", "}", "else", "if", "(", "untabKeyComboPressed", "(", "key", ",", "e", ")", ")", "{", "// if the untab key combo was pressed, remove tabs instead of inserting them", "if", "(", "text", ".", "slice", "(", "startLine", ")", ".", "indexOf", "(", "tab", ")", "===", "0", ")", "{", "// is this tab part of the selection?", "if", "(", "startLine", "===", "selStart", ")", "{", "// it is, remove it", "sel", "=", "sel", ".", "slice", "(", "tabLen", ")", ";", "}", "else", "{", "// the tab comes before the selection", "preTab", "=", "tabLen", ";", "}", "startTab", "=", "tabLen", ";", "}", "target", ".", "value", "=", "text", ".", "slice", "(", "0", ",", "startLine", ")", "+", "text", ".", "slice", "(", "startLine", "+", "preTab", ",", "selStart", ")", "+", "sel", ".", "replace", "(", "new", "RegExp", "(", "'\\n'", "+", "tab", ",", "'g'", ")", ",", "function", "(", ")", "{", "numTabs", "+=", "1", ";", "return", "'\\n'", ";", "}", ")", "+", "text", ".", "slice", "(", "selEnd", ")", ";", "// set start and end points", "if", "(", "range", ")", "{", "// IE", "// setting end first makes calculations easier", "range", ".", "collapse", "(", ")", ";", "range", ".", "moveEnd", "(", "CHARACTER", ",", "selEnd", "-", "startTab", "-", "(", "numTabs", "*", "tabLen", ")", "-", "selNewlines", "-", "preNewlines", ")", ";", "range", ".", "moveStart", "(", "CHARACTER", ",", "selStart", "-", "preTab", "-", "preNewlines", ")", ";", "range", ".", "select", "(", ")", ";", "}", "else", "{", "// set start first for Opera", "target", ".", "selectionStart", "=", "selStart", "-", "preTab", ";", "// preTab is 0 or tabLen", "// move the selection end over by the total number of tabs removed", "target", ".", "selectionEnd", "=", "selEnd", "-", "startTab", "-", "(", "numTabs", "*", "tabLen", ")", ";", "}", "}", "else", "{", "return", ";", "// do nothing for invalid key combinations", "}", "}", "else", "{", "// single line selection", "// tab key combo - insert a tab", "if", "(", "tabKeyComboPressed", "(", "key", ",", "e", ")", ")", "{", "if", "(", "range", ")", "{", "// IE", "range", ".", "text", "=", "tab", ";", "range", ".", "select", "(", ")", ";", "}", "else", "{", "target", ".", "value", "=", "text", ".", "slice", "(", "0", ",", "selStart", ")", "+", "tab", "+", "text", ".", "slice", "(", "selEnd", ")", ";", "target", ".", "selectionEnd", "=", "target", ".", "selectionStart", "=", "selStart", "+", "tabLen", ";", "target", ".", "scrollTop", "=", "initScrollTop", ";", "}", "}", "else", "if", "(", "untabKeyComboPressed", "(", "key", ",", "e", ")", ")", "{", "// if the untab key combo was pressed, remove a tab instead of inserting one", "// if the character before the selection is a tab, remove it", "if", "(", "text", ".", "slice", "(", "selStart", "-", "tabLen", ")", ".", "indexOf", "(", "tab", ")", "===", "0", ")", "{", "target", ".", "value", "=", "text", ".", "slice", "(", "0", ",", "selStart", "-", "tabLen", ")", "+", "text", ".", "slice", "(", "selStart", ")", ";", "// set start and end points", "if", "(", "range", ")", "{", "// IE", "// collapses range and moves it by -1 tab", "range", ".", "move", "(", "CHARACTER", ",", "selStart", "-", "tabLen", "-", "preNewlines", ")", ";", "range", ".", "select", "(", ")", ";", "}", "else", "{", "target", ".", "selectionEnd", "=", "target", ".", "selectionStart", "=", "selStart", "-", "tabLen", ";", "target", ".", "scrollTop", "=", "initScrollTop", ";", "}", "}", "}", "else", "{", "return", ";", "// do nothing for invalid key combinations", "}", "}", "}", "else", "if", "(", "autoIndent", ")", "{", "// Enter key", "// insert a newline and copy the whitespace from the beginning of the line", "// find the start of the first selected line", "if", "(", "selStart", "===", "0", "||", "text", ".", "charAt", "(", "selStart", "-", "1", ")", "===", "'\\n'", ")", "{", "// the selection starts at the beginning of a line", "// do nothing special", "inWhitespace", "=", "true", ";", "return", ";", "}", "// see explanation under \"multi-line selection\" above", "startLine", "=", "text", ".", "lastIndexOf", "(", "'\\n'", ",", "selStart", "-", "1", ")", "+", "1", ";", "// find the end of the first selected line", "endLine", "=", "text", ".", "indexOf", "(", "'\\n'", ",", "selStart", ")", ";", "// if no newline is found, set endLine to the end of the text", "if", "(", "endLine", "===", "-", "1", ")", "{", "endLine", "=", "text", ".", "length", ";", "}", "// get the whitespace at the beginning of the first selected line (spaces and tabs only)", "whitespace", "=", "text", ".", "slice", "(", "startLine", ",", "endLine", ")", ".", "match", "(", "/", "^[ \\t]*", "/", ")", "[", "0", "]", ";", "whitespaceLen", "=", "whitespace", ".", "length", ";", "// the cursor (selStart) is in the whitespace at beginning of the line", "// do nothing special", "if", "(", "selStart", "<", "startLine", "+", "whitespaceLen", ")", "{", "inWhitespace", "=", "true", ";", "return", ";", "}", "if", "(", "range", ")", "{", "// IE", "// insert the newline and whitespace", "range", ".", "text", "=", "'\\n'", "+", "whitespace", ";", "range", ".", "select", "(", ")", ";", "}", "else", "{", "// insert the newline and whitespace", "target", ".", "value", "=", "text", ".", "slice", "(", "0", ",", "selStart", ")", "+", "'\\n'", "+", "whitespace", "+", "text", ".", "slice", "(", "selEnd", ")", ";", "// Opera uses \\r\\n for a newline, instead of \\n,", "// so use newlineLen instead of a hard-coded value", "target", ".", "selectionEnd", "=", "target", ".", "selectionStart", "=", "selStart", "+", "newlineLen", "+", "whitespaceLen", ";", "target", ".", "scrollTop", "=", "initScrollTop", ";", "}", "}", "if", "(", "e", ".", "preventDefault", ")", "{", "e", ".", "preventDefault", "(", ")", ";", "}", "else", "{", "e", ".", "returnValue", "=", "false", ";", "return", "false", ";", "}", "}"], "docstring": "Event handler to insert or remove tabs and newlines on the keydown event\nfor the tab or enter key.\n\n@param {Event} e  the event object\n\n@method tabOverride.handlers.keydown", "docstring_tokens": ["Event", "handler", "to", "insert", "or", "remove", "tabs", "and", "newlines", "on", "the", "keydown", "event", "for", "the", "tab", "or", "enter", "key", "."], "sha": "02238ec1ab098cb998dcb3c1c38d39316e2ac03d", "url": "https://github.com/wjbryant/taboverride/blob/02238ec1ab098cb998dcb3c1c38d39316e2ac03d/build/output/taboverride.js#L188-L457", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/object-store/AbstractReadOnlyStorage.js", "func_name": "list", "original_string": "function list(storage, keyRange, filter, direction, unique, pageSize,\n    storageFactory) {\n  return new Promise((resolve, reject) => {\n    let items = []\n\n    storage.createCursorFactory(keyRange, direction)((cursor) => {\n      if (!filter || filter(cursor.record, cursor.primaryKey, cursor.key)) {\n        if (items.length === pageSize) {\n          finalize(true, cursor.key, cursor.primaryKey)\n          return\n        } else {\n          items.push(cursor.record)\n        }\n      }\n      \n      cursor.continue()\n    }).then(() => finalize(false, null, null)).catch(error => reject(error))\n\n    function finalize(hasNextPage, nextKey, nextPrimaryKey) {\n      resolve(new RecordList(items, storageFactory, nextKey, nextPrimaryKey,\n          direction, unique, filter, pageSize, hasNextPage))\n    }\n  })\n}", "language": "javascript", "code": "function list(storage, keyRange, filter, direction, unique, pageSize,\n    storageFactory) {\n  return new Promise((resolve, reject) => {\n    let items = []\n\n    storage.createCursorFactory(keyRange, direction)((cursor) => {\n      if (!filter || filter(cursor.record, cursor.primaryKey, cursor.key)) {\n        if (items.length === pageSize) {\n          finalize(true, cursor.key, cursor.primaryKey)\n          return\n        } else {\n          items.push(cursor.record)\n        }\n      }\n      \n      cursor.continue()\n    }).then(() => finalize(false, null, null)).catch(error => reject(error))\n\n    function finalize(hasNextPage, nextKey, nextPrimaryKey) {\n      resolve(new RecordList(items, storageFactory, nextKey, nextPrimaryKey,\n          direction, unique, filter, pageSize, hasNextPage))\n    }\n  })\n}", "code_tokens": ["function", "list", "(", "storage", ",", "keyRange", ",", "filter", ",", "direction", ",", "unique", ",", "pageSize", ",", "storageFactory", ")", "{", "return", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "let", "items", "=", "[", "]", "storage", ".", "createCursorFactory", "(", "keyRange", ",", "direction", ")", "(", "(", "cursor", ")", "=>", "{", "if", "(", "!", "filter", "||", "filter", "(", "cursor", ".", "record", ",", "cursor", ".", "primaryKey", ",", "cursor", ".", "key", ")", ")", "{", "if", "(", "items", ".", "length", "===", "pageSize", ")", "{", "finalize", "(", "true", ",", "cursor", ".", "key", ",", "cursor", ".", "primaryKey", ")", "return", "}", "else", "{", "items", ".", "push", "(", "cursor", ".", "record", ")", "}", "}", "cursor", ".", "continue", "(", ")", "}", ")", ".", "then", "(", "(", ")", "=>", "finalize", "(", "false", ",", "null", ",", "null", ")", ")", ".", "catch", "(", "error", "=>", "reject", "(", "error", ")", ")", "function", "finalize", "(", "hasNextPage", ",", "nextKey", ",", "nextPrimaryKey", ")", "{", "resolve", "(", "new", "RecordList", "(", "items", ",", "storageFactory", ",", "nextKey", ",", "nextPrimaryKey", ",", "direction", ",", "unique", ",", "filter", ",", "pageSize", ",", "hasNextPage", ")", ")", "}", "}", ")", "}"], "docstring": "Creates a promise that resolves to a record list containing the first page\nof records matching the provided filter.\n\n@param {AbstractReadOnlyStorage} storage The current storage accessor - will\nbe used to fetch the first page of records.\n@param {(undefined|IDBKeyRange)} keyRange The key range to use for the first\npage or records.\n@param {(undefined|function(*, (number|string|Date|Array), (number|string|Date|Array)): boolean)} filter\nThe filter function restricting the records that will be listed.\nIf a function is provided, the first argument will be set to the\nrecord, the second argument will be set to the primary key of the\nrecord, and the third argument will be set to the key referencing the\nrecord (the primary key if traversing an object store).\n@param {CursorDirection} direction The direction in which the records in the\nstorage should be listed.\n@param {boolean} unique When {@code true}, the keys by which the records are\norganized in the store are always unique for each record.\n@param {number} pageSize The maximum number of records per page. Must be a\npositive integer.\n@param {function(): AbstractReadOnlyStorage} storageFactory A function that\ncreates a new read-only transaction and returns this storage accessor\neach time it is invoked.\n@return {Promise<RecordList<*>>} A promise that resolves to a record list of\nthe fetched records matching the filter.", "docstring_tokens": ["Creates", "a", "promise", "that", "resolves", "to", "a", "record", "list", "containing", "the", "first", "page", "of", "records", "matching", "the", "provided", "filter", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/object-store/AbstractReadOnlyStorage.js#L319-L342", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "recycleGraph", "original_string": "function recycleGraph()\n   {\n      var childNodes = graph.selectAll('g > *').remove();\n\n      if (!Array.isArray(childNodes) && !Array.isArray(childNodes['0'])) { return; }\n\n      // Get the child nodes group from selection.\n      childNodes = childNodes['0'];\n\n      for (var cntr = 0; cntr < childNodes.length; cntr++)\n      {\n         var childNode = childNodes[cntr];\n\n         if (childNode instanceof SVGPathElement) { svgElementMap['path'].push(childNode); }\n         else if (childNode instanceof SVGCircleElement) { svgElementMap['circle'].push(childNode); }\n         else if (childNode instanceof SVGTextElement) { svgElementMap['text'].push(childNode); }\n         else if (childNode instanceof SVGGElement)\n         {\n            childNode.removeAttribute('transform');  // Must remove current transform.\n            svgElementMap['g'].push(childNode);\n         }\n      }\n   }", "language": "javascript", "code": "function recycleGraph()\n   {\n      var childNodes = graph.selectAll('g > *').remove();\n\n      if (!Array.isArray(childNodes) && !Array.isArray(childNodes['0'])) { return; }\n\n      // Get the child nodes group from selection.\n      childNodes = childNodes['0'];\n\n      for (var cntr = 0; cntr < childNodes.length; cntr++)\n      {\n         var childNode = childNodes[cntr];\n\n         if (childNode instanceof SVGPathElement) { svgElementMap['path'].push(childNode); }\n         else if (childNode instanceof SVGCircleElement) { svgElementMap['circle'].push(childNode); }\n         else if (childNode instanceof SVGTextElement) { svgElementMap['text'].push(childNode); }\n         else if (childNode instanceof SVGGElement)\n         {\n            childNode.removeAttribute('transform');  // Must remove current transform.\n            svgElementMap['g'].push(childNode);\n         }\n      }\n   }", "code_tokens": ["function", "recycleGraph", "(", ")", "{", "var", "childNodes", "=", "graph", ".", "selectAll", "(", "'g > *'", ")", ".", "remove", "(", ")", ";", "if", "(", "!", "Array", ".", "isArray", "(", "childNodes", ")", "&&", "!", "Array", ".", "isArray", "(", "childNodes", "[", "'0'", "]", ")", ")", "{", "return", ";", "}", "// Get the child nodes group from selection.", "childNodes", "=", "childNodes", "[", "'0'", "]", ";", "for", "(", "var", "cntr", "=", "0", ";", "cntr", "<", "childNodes", ".", "length", ";", "cntr", "++", ")", "{", "var", "childNode", "=", "childNodes", "[", "cntr", "]", ";", "if", "(", "childNode", "instanceof", "SVGPathElement", ")", "{", "svgElementMap", "[", "'path'", "]", ".", "push", "(", "childNode", ")", ";", "}", "else", "if", "(", "childNode", "instanceof", "SVGCircleElement", ")", "{", "svgElementMap", "[", "'circle'", "]", ".", "push", "(", "childNode", ")", ";", "}", "else", "if", "(", "childNode", "instanceof", "SVGTextElement", ")", "{", "svgElementMap", "[", "'text'", "]", ".", "push", "(", "childNode", ")", ";", "}", "else", "if", "(", "childNode", "instanceof", "SVGGElement", ")", "{", "childNode", ".", "removeAttribute", "(", "'transform'", ")", ";", "// Must remove current transform.", "svgElementMap", "[", "'g'", "]", ".", "push", "(", "childNode", ")", ";", "}", "}", "}"], "docstring": "Recycles all SVG elements above the top level SVGGElement defining the graph.", "docstring_tokens": ["Recycles", "all", "SVG", "elements", "above", "the", "top", "level", "SVGGElement", "defining", "the", "graph", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L833-L855", "partition": "test"}
{"repo": "Katochimoto/xblocks-core", "path": "src/xblocks/block.js", "func_name": "accessorsCustomizer", "original_string": "function accessorsCustomizer(objValue, srcValue) {\n    const objSetter = get(objValue, 'set');\n    const srcSetter = get(srcValue, 'set');\n\n    return merge({}, objValue, srcValue, {\n        set: wrap(objSetter, wrap(srcSetter, wrapperFunction))\n    });\n}", "language": "javascript", "code": "function accessorsCustomizer(objValue, srcValue) {\n    const objSetter = get(objValue, 'set');\n    const srcSetter = get(srcValue, 'set');\n\n    return merge({}, objValue, srcValue, {\n        set: wrap(objSetter, wrap(srcSetter, wrapperFunction))\n    });\n}", "code_tokens": ["function", "accessorsCustomizer", "(", "objValue", ",", "srcValue", ")", "{", "const", "objSetter", "=", "get", "(", "objValue", ",", "'set'", ")", ";", "const", "srcSetter", "=", "get", "(", "srcValue", ",", "'set'", ")", ";", "return", "merge", "(", "{", "}", ",", "objValue", ",", "srcValue", ",", "{", "set", ":", "wrap", "(", "objSetter", ",", "wrap", "(", "srcSetter", ",", "wrapperFunction", ")", ")", "}", ")", ";", "}"], "docstring": "Inheritance events \"set\" property changes.\n@example\n_.mergeWith(objValue, srcValue, accessorsCustomizer);\n@param {Object} [objValue] the current value\n@param {Object} [srcValue] the new value\n@returns {Object}\n@private", "docstring_tokens": ["Inheritance", "events", "set", "property", "changes", "."], "sha": "714102b7c2adb4ae197403df252e967a1b967bb1", "url": "https://github.com/Katochimoto/xblocks-core/blob/714102b7c2adb4ae197403df252e967a1b967bb1/src/xblocks/block.js#L320-L327", "partition": "test"}
{"repo": "koajs/ratelimit", "path": "index.js", "func_name": "thenify", "original_string": "async function thenify(fn) {\n  return await new Promise(function(resolve, reject) {\n    function callback(err, res) {\n      if (err) return reject(err);\n      return resolve(res);\n    }\n\n    fn(callback);\n  });\n}", "language": "javascript", "code": "async function thenify(fn) {\n  return await new Promise(function(resolve, reject) {\n    function callback(err, res) {\n      if (err) return reject(err);\n      return resolve(res);\n    }\n\n    fn(callback);\n  });\n}", "code_tokens": ["async", "function", "thenify", "(", "fn", ")", "{", "return", "await", "new", "Promise", "(", "function", "(", "resolve", ",", "reject", ")", "{", "function", "callback", "(", "err", ",", "res", ")", "{", "if", "(", "err", ")", "return", "reject", "(", "err", ")", ";", "return", "resolve", "(", "res", ")", ";", "}", "fn", "(", "callback", ")", ";", "}", ")", ";", "}"], "docstring": "Helper function to convert a callback to a Promise.", "docstring_tokens": ["Helper", "function", "to", "convert", "a", "callback", "to", "a", "Promise", "."], "sha": "3eb2e7d1694f77628041af0b1a3f1bc4b8dbf275", "url": "https://github.com/koajs/ratelimit/blob/3eb2e7d1694f77628041af0b1a3f1bc4b8dbf275/index.js#L97-L106", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/direct/RemotingProvider.js", "func_name": "", "original_string": "function() {\n        var buffer = this.callBuffer,\n            ln = buffer.length;\n\n        if (ln > 0) {\n            this.sendRequest(ln == 1 ? buffer[0] : buffer);\n            this.callBuffer = [];\n        }\n    }", "language": "javascript", "code": "function() {\n        var buffer = this.callBuffer,\n            ln = buffer.length;\n\n        if (ln > 0) {\n            this.sendRequest(ln == 1 ? buffer[0] : buffer);\n            this.callBuffer = [];\n        }\n    }", "code_tokens": ["function", "(", ")", "{", "var", "buffer", "=", "this", ".", "callBuffer", ",", "ln", "=", "buffer", ".", "length", ";", "if", "(", "ln", ">", "0", ")", "{", "this", ".", "sendRequest", "(", "ln", "==", "1", "?", "buffer", "[", "0", "]", ":", "buffer", ")", ";", "this", ".", "callBuffer", "=", "[", "]", ";", "}", "}"], "docstring": "Combine any buffered requests and send them off.\n@private", "docstring_tokens": ["Combine", "any", "buffered", "requests", "and", "send", "them", "off", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/direct/RemotingProvider.js#L439-L447", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/ComponentQuery.js", "func_name": "", "original_string": "function(component, selector) {\n            if (!selector) {\n                return true;\n            }\n            var query = this.cache[selector];\n            if (!query) {\n                this.cache[selector] = query = this.parse(selector);\n            }\n            return query.is(component);\n        }", "language": "javascript", "code": "function(component, selector) {\n            if (!selector) {\n                return true;\n            }\n            var query = this.cache[selector];\n            if (!query) {\n                this.cache[selector] = query = this.parse(selector);\n            }\n            return query.is(component);\n        }", "code_tokens": ["function", "(", "component", ",", "selector", ")", "{", "if", "(", "!", "selector", ")", "{", "return", "true", ";", "}", "var", "query", "=", "this", ".", "cache", "[", "selector", "]", ";", "if", "(", "!", "query", ")", "{", "this", ".", "cache", "[", "selector", "]", "=", "query", "=", "this", ".", "parse", "(", "selector", ")", ";", "}", "return", "query", ".", "is", "(", "component", ")", ";", "}"], "docstring": "Tests whether the passed Component matches the selector string.\n@param {Ext.Component} component The Component to test.\n@param {String} selector The selector string to test against.\n@return {Boolean} `true` if the Component matches the selector.\n@member Ext.ComponentQuery", "docstring_tokens": ["Tests", "whether", "the", "passed", "Component", "matches", "the", "selector", "string", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/ComponentQuery.js#L475-L484", "partition": "test"}
{"repo": "steve-jansen/json-proxy", "path": "spec/shared/setup.js", "func_name": "configureLanProxy", "original_string": "function configureLanProxy(options, config, done) {\n  var portfinder = require('portfinder'),\n      request = require('request'),\n      credentials = config.proxy.gateway.auth,\n      gatewayPort,\n      expectedAuthorizationHeader,\n      requestViaHeader,\n      responseViaHeader;\n\n  handles = handles || {};\n\n  handles.gatewayServer = require('http').createServer(function (req, res) {\n    expectedAuthorizationHeader = 'Basic ' + new Buffer(credentials).toString('base64');\n\n    // HACK: node 0.12.x appears to inject a slash at the front\n    //       of absolute URLs\n    //       ex., GET http://www.example.com --> GET /http://www.exampel.com\n    if (req.url.charAt(0) === '/') {\n      req.url = req.url.substr(1);\n    }\n\n    // validate the proxy target\n    if (req.url !== req.headers['x-forwarded-url']) {\n        res.writeHead(500);\n        res.end('{ \"error\": 500, \"message\": \"invalid proxy request, expected X-Forwarded-Url header ' + req.headers['x-forwarded-url'] + '\" }');\n        return;\n    }\n\n    // validate the proxy credentials\n    if (req.headers['authorization'] !== expectedAuthorizationHeader) {\n      res.writeHead(401);\n      res.end('{ \"error\": 401, \"message\": \"invalid proxy credentials, expected ' + expectedAuthorizationHeader + '\" }');\n      return;\n    }\n\n    // determine if we are using a proxy that is not RFC compliant\n    requestViaHeader = options.headers['Via'] ||\n                        '127.0.0.1:' + handles.port;\n\n    responseHostHeader = options.headers['Host'] ||\n                        req.headers['host'];\n\n    responseViaHeader = options.headers['Via'] ||\n                        'http://localhost:' + gatewayPort;\n\n    // validate the via header was injected and points to 127.0.0.1 in either ipv4 or ipv6 format\n    if (req.headers['via'] === undefined || req.headers['via'] === null || req.headers['via'].indexOf(requestViaHeader) === -1) {\n      res.writeHead(400);\n      res.end('{ \"error\": 400, \"message\": \"invalid via header, expected ' + requestViaHeader + '\" }');\n      return;\n    }\n\n    // strip the proxy credentials header\n    req.headers['authorization'] = null;\n    // simulate the behavior of x-forwarded-for with multiple proxies\n    req.headers['x-forwarded-for'] = [req.headers['x-forwarded-for'], req.headers['via']].join(', ');\n    // change the via header to this server\n    req.headers['via'] = responseViaHeader;\n    req.headers['host'] = responseHostHeader;\n\n    var errorCallback = function errorCallback(err, repsonse, body) {\n      if (err) {\n        res.writeHead(500);\n        res.end(JSON.stringify({ \"error\": 500, \"message\": err.message  }));\n        return;\n      }\n    }\n\n    request(req, errorCallback).pipe(res);\n  });\n\n  portfinder.getPort(function (err, port) {\n    if (err) done(err);\n\n    config.proxy.gateway.port = port;\n    gatewayPort = port;\n\n    handles.gatewayServer.listen(port, function() {\n      done(null);\n    });\n  });\n}", "language": "javascript", "code": "function configureLanProxy(options, config, done) {\n  var portfinder = require('portfinder'),\n      request = require('request'),\n      credentials = config.proxy.gateway.auth,\n      gatewayPort,\n      expectedAuthorizationHeader,\n      requestViaHeader,\n      responseViaHeader;\n\n  handles = handles || {};\n\n  handles.gatewayServer = require('http').createServer(function (req, res) {\n    expectedAuthorizationHeader = 'Basic ' + new Buffer(credentials).toString('base64');\n\n    // HACK: node 0.12.x appears to inject a slash at the front\n    //       of absolute URLs\n    //       ex., GET http://www.example.com --> GET /http://www.exampel.com\n    if (req.url.charAt(0) === '/') {\n      req.url = req.url.substr(1);\n    }\n\n    // validate the proxy target\n    if (req.url !== req.headers['x-forwarded-url']) {\n        res.writeHead(500);\n        res.end('{ \"error\": 500, \"message\": \"invalid proxy request, expected X-Forwarded-Url header ' + req.headers['x-forwarded-url'] + '\" }');\n        return;\n    }\n\n    // validate the proxy credentials\n    if (req.headers['authorization'] !== expectedAuthorizationHeader) {\n      res.writeHead(401);\n      res.end('{ \"error\": 401, \"message\": \"invalid proxy credentials, expected ' + expectedAuthorizationHeader + '\" }');\n      return;\n    }\n\n    // determine if we are using a proxy that is not RFC compliant\n    requestViaHeader = options.headers['Via'] ||\n                        '127.0.0.1:' + handles.port;\n\n    responseHostHeader = options.headers['Host'] ||\n                        req.headers['host'];\n\n    responseViaHeader = options.headers['Via'] ||\n                        'http://localhost:' + gatewayPort;\n\n    // validate the via header was injected and points to 127.0.0.1 in either ipv4 or ipv6 format\n    if (req.headers['via'] === undefined || req.headers['via'] === null || req.headers['via'].indexOf(requestViaHeader) === -1) {\n      res.writeHead(400);\n      res.end('{ \"error\": 400, \"message\": \"invalid via header, expected ' + requestViaHeader + '\" }');\n      return;\n    }\n\n    // strip the proxy credentials header\n    req.headers['authorization'] = null;\n    // simulate the behavior of x-forwarded-for with multiple proxies\n    req.headers['x-forwarded-for'] = [req.headers['x-forwarded-for'], req.headers['via']].join(', ');\n    // change the via header to this server\n    req.headers['via'] = responseViaHeader;\n    req.headers['host'] = responseHostHeader;\n\n    var errorCallback = function errorCallback(err, repsonse, body) {\n      if (err) {\n        res.writeHead(500);\n        res.end(JSON.stringify({ \"error\": 500, \"message\": err.message  }));\n        return;\n      }\n    }\n\n    request(req, errorCallback).pipe(res);\n  });\n\n  portfinder.getPort(function (err, port) {\n    if (err) done(err);\n\n    config.proxy.gateway.port = port;\n    gatewayPort = port;\n\n    handles.gatewayServer.listen(port, function() {\n      done(null);\n    });\n  });\n}", "code_tokens": ["function", "configureLanProxy", "(", "options", ",", "config", ",", "done", ")", "{", "var", "portfinder", "=", "require", "(", "'portfinder'", ")", ",", "request", "=", "require", "(", "'request'", ")", ",", "credentials", "=", "config", ".", "proxy", ".", "gateway", ".", "auth", ",", "gatewayPort", ",", "expectedAuthorizationHeader", ",", "requestViaHeader", ",", "responseViaHeader", ";", "handles", "=", "handles", "||", "{", "}", ";", "handles", ".", "gatewayServer", "=", "require", "(", "'http'", ")", ".", "createServer", "(", "function", "(", "req", ",", "res", ")", "{", "expectedAuthorizationHeader", "=", "'Basic '", "+", "new", "Buffer", "(", "credentials", ")", ".", "toString", "(", "'base64'", ")", ";", "// HACK: node 0.12.x appears to inject a slash at the front", "//       of absolute URLs", "//       ex., GET http://www.example.com --> GET /http://www.exampel.com", "if", "(", "req", ".", "url", ".", "charAt", "(", "0", ")", "===", "'/'", ")", "{", "req", ".", "url", "=", "req", ".", "url", ".", "substr", "(", "1", ")", ";", "}", "// validate the proxy target", "if", "(", "req", ".", "url", "!==", "req", ".", "headers", "[", "'x-forwarded-url'", "]", ")", "{", "res", ".", "writeHead", "(", "500", ")", ";", "res", ".", "end", "(", "'{ \"error\": 500, \"message\": \"invalid proxy request, expected X-Forwarded-Url header '", "+", "req", ".", "headers", "[", "'x-forwarded-url'", "]", "+", "'\" }'", ")", ";", "return", ";", "}", "// validate the proxy credentials", "if", "(", "req", ".", "headers", "[", "'authorization'", "]", "!==", "expectedAuthorizationHeader", ")", "{", "res", ".", "writeHead", "(", "401", ")", ";", "res", ".", "end", "(", "'{ \"error\": 401, \"message\": \"invalid proxy credentials, expected '", "+", "expectedAuthorizationHeader", "+", "'\" }'", ")", ";", "return", ";", "}", "// determine if we are using a proxy that is not RFC compliant", "requestViaHeader", "=", "options", ".", "headers", "[", "'Via'", "]", "||", "'127.0.0.1:'", "+", "handles", ".", "port", ";", "responseHostHeader", "=", "options", ".", "headers", "[", "'Host'", "]", "||", "req", ".", "headers", "[", "'host'", "]", ";", "responseViaHeader", "=", "options", ".", "headers", "[", "'Via'", "]", "||", "'http://localhost:'", "+", "gatewayPort", ";", "// validate the via header was injected and points to 127.0.0.1 in either ipv4 or ipv6 format", "if", "(", "req", ".", "headers", "[", "'via'", "]", "===", "undefined", "||", "req", ".", "headers", "[", "'via'", "]", "===", "null", "||", "req", ".", "headers", "[", "'via'", "]", ".", "indexOf", "(", "requestViaHeader", ")", "===", "-", "1", ")", "{", "res", ".", "writeHead", "(", "400", ")", ";", "res", ".", "end", "(", "'{ \"error\": 400, \"message\": \"invalid via header, expected '", "+", "requestViaHeader", "+", "'\" }'", ")", ";", "return", ";", "}", "// strip the proxy credentials header", "req", ".", "headers", "[", "'authorization'", "]", "=", "null", ";", "// simulate the behavior of x-forwarded-for with multiple proxies", "req", ".", "headers", "[", "'x-forwarded-for'", "]", "=", "[", "req", ".", "headers", "[", "'x-forwarded-for'", "]", ",", "req", ".", "headers", "[", "'via'", "]", "]", ".", "join", "(", "', '", ")", ";", "// change the via header to this server", "req", ".", "headers", "[", "'via'", "]", "=", "responseViaHeader", ";", "req", ".", "headers", "[", "'host'", "]", "=", "responseHostHeader", ";", "var", "errorCallback", "=", "function", "errorCallback", "(", "err", ",", "repsonse", ",", "body", ")", "{", "if", "(", "err", ")", "{", "res", ".", "writeHead", "(", "500", ")", ";", "res", ".", "end", "(", "JSON", ".", "stringify", "(", "{", "\"error\"", ":", "500", ",", "\"message\"", ":", "err", ".", "message", "}", ")", ")", ";", "return", ";", "}", "}", "request", "(", "req", ",", "errorCallback", ")", ".", "pipe", "(", "res", ")", ";", "}", ")", ";", "portfinder", ".", "getPort", "(", "function", "(", "err", ",", "port", ")", "{", "if", "(", "err", ")", "done", "(", "err", ")", ";", "config", ".", "proxy", ".", "gateway", ".", "port", "=", "port", ";", "gatewayPort", "=", "port", ";", "handles", ".", "gatewayServer", ".", "listen", "(", "port", ",", "function", "(", ")", "{", "done", "(", "null", ")", ";", "}", ")", ";", "}", ")", ";", "}"], "docstring": "Creates a simple LAN proxy using a vanilla HTTP server\nthat verifies the state of the proxy credentials and the x-forwarded-url\nare correct.\n\n@param  {Object.<string, string>} options  the options for configuring this\ntest suite\n@param  {Object.<string, string>} config   the config of the json-proxy for\nthis test suite\n@param  {Function} done", "docstring_tokens": ["Creates", "a", "simple", "LAN", "proxy", "using", "a", "vanilla", "HTTP", "server", "that", "verifies", "the", "state", "of", "the", "proxy", "credentials", "and", "the", "x", "-", "forwarded", "-", "url", "are", "correct", "."], "sha": "b996609b627690774367d8d887f2e8baf102f6bf", "url": "https://github.com/steve-jansen/json-proxy/blob/b996609b627690774367d8d887f2e8baf102f6bf/spec/shared/setup.js#L219-L300", "partition": "test"}
{"repo": "runk/node-chardet", "path": "encoding/sbcs.js", "func_name": "NGramParser", "original_string": "function NGramParser(theNgramList, theByteMap) {\n  var N_GRAM_MASK = 0xFFFFFF;\n\n  this.byteIndex = 0;\n  this.ngram = 0;\n\n  this.ngramList = theNgramList;\n  this.byteMap = theByteMap;\n\n  this.ngramCount = 0;\n  this.hitCount = 0;\n\n  this.spaceChar;\n\n  /*\n   * Binary search for value in table, which must have exactly 64 entries.\n   */\n  this.search = function(table, value) {\n    var index = 0;\n\n    if (table[index + 32] <= value) index += 32;\n    if (table[index + 16] <= value) index += 16;\n    if (table[index + 8]  <= value) index += 8;\n    if (table[index + 4]  <= value) index += 4;\n    if (table[index + 2]  <= value) index += 2;\n    if (table[index + 1]  <= value) index += 1;\n    if (table[index]      > value)  index -= 1;\n\n    if (index < 0 || table[index] != value)\n      return -1;\n\n    return index;\n  };\n\n  this.lookup = function(thisNgram) {\n    this.ngramCount += 1;\n    if (this.search(this.ngramList, thisNgram) >= 0) {\n      this.hitCount += 1;\n    }\n  };\n\n  this.addByte = function(b) {\n    this.ngram = ((this.ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;\n    this.lookup(this.ngram);\n  }\n\n  this.nextByte = function(det) {\n    if (this.byteIndex >= det.fInputLen)\n      return -1;\n\n    return det.fInputBytes[this.byteIndex++] & 0xFF;\n  }\n\n  this.parse = function(det, spaceCh) {\n    var b, ignoreSpace = false;\n    this.spaceChar = spaceCh;\n\n    while ((b = this.nextByte(det)) >= 0) {\n      var mb = this.byteMap[b];\n\n      // TODO: 0x20 might not be a space in all character sets...\n      if (mb != 0) {\n        if (!(mb == this.spaceChar && ignoreSpace)) {\n          this.addByte(mb);\n        }\n\n        ignoreSpace = (mb == this.spaceChar);\n      }\n    }\n\n    // TODO: Is this OK? The buffer could have ended in the middle of a word...\n    this.addByte(this.spaceChar);\n\n    var rawPercent = this.hitCount / this.ngramCount;\n\n    // TODO - This is a bit of a hack to take care of a case\n    // were we were getting a confidence of 135...\n    if (rawPercent > 0.33)\n      return 98;\n\n    return Math.floor(rawPercent * 300.0);\n  };\n}", "language": "javascript", "code": "function NGramParser(theNgramList, theByteMap) {\n  var N_GRAM_MASK = 0xFFFFFF;\n\n  this.byteIndex = 0;\n  this.ngram = 0;\n\n  this.ngramList = theNgramList;\n  this.byteMap = theByteMap;\n\n  this.ngramCount = 0;\n  this.hitCount = 0;\n\n  this.spaceChar;\n\n  /*\n   * Binary search for value in table, which must have exactly 64 entries.\n   */\n  this.search = function(table, value) {\n    var index = 0;\n\n    if (table[index + 32] <= value) index += 32;\n    if (table[index + 16] <= value) index += 16;\n    if (table[index + 8]  <= value) index += 8;\n    if (table[index + 4]  <= value) index += 4;\n    if (table[index + 2]  <= value) index += 2;\n    if (table[index + 1]  <= value) index += 1;\n    if (table[index]      > value)  index -= 1;\n\n    if (index < 0 || table[index] != value)\n      return -1;\n\n    return index;\n  };\n\n  this.lookup = function(thisNgram) {\n    this.ngramCount += 1;\n    if (this.search(this.ngramList, thisNgram) >= 0) {\n      this.hitCount += 1;\n    }\n  };\n\n  this.addByte = function(b) {\n    this.ngram = ((this.ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;\n    this.lookup(this.ngram);\n  }\n\n  this.nextByte = function(det) {\n    if (this.byteIndex >= det.fInputLen)\n      return -1;\n\n    return det.fInputBytes[this.byteIndex++] & 0xFF;\n  }\n\n  this.parse = function(det, spaceCh) {\n    var b, ignoreSpace = false;\n    this.spaceChar = spaceCh;\n\n    while ((b = this.nextByte(det)) >= 0) {\n      var mb = this.byteMap[b];\n\n      // TODO: 0x20 might not be a space in all character sets...\n      if (mb != 0) {\n        if (!(mb == this.spaceChar && ignoreSpace)) {\n          this.addByte(mb);\n        }\n\n        ignoreSpace = (mb == this.spaceChar);\n      }\n    }\n\n    // TODO: Is this OK? The buffer could have ended in the middle of a word...\n    this.addByte(this.spaceChar);\n\n    var rawPercent = this.hitCount / this.ngramCount;\n\n    // TODO - This is a bit of a hack to take care of a case\n    // were we were getting a confidence of 135...\n    if (rawPercent > 0.33)\n      return 98;\n\n    return Math.floor(rawPercent * 300.0);\n  };\n}", "code_tokens": ["function", "NGramParser", "(", "theNgramList", ",", "theByteMap", ")", "{", "var", "N_GRAM_MASK", "=", "0xFFFFFF", ";", "this", ".", "byteIndex", "=", "0", ";", "this", ".", "ngram", "=", "0", ";", "this", ".", "ngramList", "=", "theNgramList", ";", "this", ".", "byteMap", "=", "theByteMap", ";", "this", ".", "ngramCount", "=", "0", ";", "this", ".", "hitCount", "=", "0", ";", "this", ".", "spaceChar", ";", "/*\n   * Binary search for value in table, which must have exactly 64 entries.\n   */", "this", ".", "search", "=", "function", "(", "table", ",", "value", ")", "{", "var", "index", "=", "0", ";", "if", "(", "table", "[", "index", "+", "32", "]", "<=", "value", ")", "index", "+=", "32", ";", "if", "(", "table", "[", "index", "+", "16", "]", "<=", "value", ")", "index", "+=", "16", ";", "if", "(", "table", "[", "index", "+", "8", "]", "<=", "value", ")", "index", "+=", "8", ";", "if", "(", "table", "[", "index", "+", "4", "]", "<=", "value", ")", "index", "+=", "4", ";", "if", "(", "table", "[", "index", "+", "2", "]", "<=", "value", ")", "index", "+=", "2", ";", "if", "(", "table", "[", "index", "+", "1", "]", "<=", "value", ")", "index", "+=", "1", ";", "if", "(", "table", "[", "index", "]", ">", "value", ")", "index", "-=", "1", ";", "if", "(", "index", "<", "0", "||", "table", "[", "index", "]", "!=", "value", ")", "return", "-", "1", ";", "return", "index", ";", "}", ";", "this", ".", "lookup", "=", "function", "(", "thisNgram", ")", "{", "this", ".", "ngramCount", "+=", "1", ";", "if", "(", "this", ".", "search", "(", "this", ".", "ngramList", ",", "thisNgram", ")", ">=", "0", ")", "{", "this", ".", "hitCount", "+=", "1", ";", "}", "}", ";", "this", ".", "addByte", "=", "function", "(", "b", ")", "{", "this", ".", "ngram", "=", "(", "(", "this", ".", "ngram", "<<", "8", ")", "+", "(", "b", "&", "0xFF", ")", ")", "&", "N_GRAM_MASK", ";", "this", ".", "lookup", "(", "this", ".", "ngram", ")", ";", "}", "this", ".", "nextByte", "=", "function", "(", "det", ")", "{", "if", "(", "this", ".", "byteIndex", ">=", "det", ".", "fInputLen", ")", "return", "-", "1", ";", "return", "det", ".", "fInputBytes", "[", "this", ".", "byteIndex", "++", "]", "&", "0xFF", ";", "}", "this", ".", "parse", "=", "function", "(", "det", ",", "spaceCh", ")", "{", "var", "b", ",", "ignoreSpace", "=", "false", ";", "this", ".", "spaceChar", "=", "spaceCh", ";", "while", "(", "(", "b", "=", "this", ".", "nextByte", "(", "det", ")", ")", ">=", "0", ")", "{", "var", "mb", "=", "this", ".", "byteMap", "[", "b", "]", ";", "// TODO: 0x20 might not be a space in all character sets...", "if", "(", "mb", "!=", "0", ")", "{", "if", "(", "!", "(", "mb", "==", "this", ".", "spaceChar", "&&", "ignoreSpace", ")", ")", "{", "this", ".", "addByte", "(", "mb", ")", ";", "}", "ignoreSpace", "=", "(", "mb", "==", "this", ".", "spaceChar", ")", ";", "}", "}", "// TODO: Is this OK? The buffer could have ended in the middle of a word...", "this", ".", "addByte", "(", "this", ".", "spaceChar", ")", ";", "var", "rawPercent", "=", "this", ".", "hitCount", "/", "this", ".", "ngramCount", ";", "// TODO - This is a bit of a hack to take care of a case", "// were we were getting a confidence of 135...", "if", "(", "rawPercent", ">", "0.33", ")", "return", "98", ";", "return", "Math", ".", "floor", "(", "rawPercent", "*", "300.0", ")", ";", "}", ";", "}"], "docstring": "This class recognizes single-byte encodings. Because the encoding scheme is so\nsimple, language statistics are used to do the matching.", "docstring_tokens": ["This", "class", "recognizes", "single", "-", "byte", "encodings", ".", "Because", "the", "encoding", "scheme", "is", "so", "simple", "language", "statistics", "are", "used", "to", "do", "the", "matching", "."], "sha": "5156e3063ae8e8ba7f0d599378d024a4f403993c", "url": "https://github.com/runk/node-chardet/blob/5156e3063ae8e8ba7f0d599378d024a4f403993c/encoding/sbcs.js#L9-L91", "partition": "test"}
{"repo": "tjworks/angoose", "path": "lib/angoose.js", "func_name": "registerClass", "original_string": "function registerClass(nameOrOpts, claz){\n    var opts = typeof(nameOrOpts) == 'object'?nameOrOpts: {name: nameOrOpts};\n    var className = opts.name;\n    if(!className) throw \"Missing module name: \"+ className\n    if(beans[className])\n        logger.warn(\"Overriding existing bean: \", className);\n    if(claz._angoosemeta && (claz._angoosemeta.baseClass == 'Service' || claz._angoosemeta.baseClass == 'Model') ){\n        // already mixed\n    }\n    else{\n        if(typeof(claz) === 'function' && claz.schema  && claz.modelName )\n            opts.baseClass = 'Model';\n        else if(claz instanceof getMongoose().Schema){\n            opts.baseClass = 'Model';\n            claz = getMongoose().model(className, claz);\n        }\n        else\n            opts.baseClass = 'Service';\n        angoose.Remotable.mixin(opts, claz);\n    }\n    _.extend(claz._angoosemeta, nameOrOpts);\n    \n    beans[className] = claz;\n    //if(!nameOrOpts.isExtension)\n        logger.debug(\"Registered module\", claz._angoosemeta.baseClass, className);\n    return claz;\n    // if(claz._angoosemeta && (claz._angoosemeta.baseClass == 'Service' || claz._angoosemeta.baseClass == 'Model') ){\n//         \n    // }\n    // else{\n        // throw \"Invalid class: must be a Model or Service class: \" + claz;\n    // }\n}", "language": "javascript", "code": "function registerClass(nameOrOpts, claz){\n    var opts = typeof(nameOrOpts) == 'object'?nameOrOpts: {name: nameOrOpts};\n    var className = opts.name;\n    if(!className) throw \"Missing module name: \"+ className\n    if(beans[className])\n        logger.warn(\"Overriding existing bean: \", className);\n    if(claz._angoosemeta && (claz._angoosemeta.baseClass == 'Service' || claz._angoosemeta.baseClass == 'Model') ){\n        // already mixed\n    }\n    else{\n        if(typeof(claz) === 'function' && claz.schema  && claz.modelName )\n            opts.baseClass = 'Model';\n        else if(claz instanceof getMongoose().Schema){\n            opts.baseClass = 'Model';\n            claz = getMongoose().model(className, claz);\n        }\n        else\n            opts.baseClass = 'Service';\n        angoose.Remotable.mixin(opts, claz);\n    }\n    _.extend(claz._angoosemeta, nameOrOpts);\n    \n    beans[className] = claz;\n    //if(!nameOrOpts.isExtension)\n        logger.debug(\"Registered module\", claz._angoosemeta.baseClass, className);\n    return claz;\n    // if(claz._angoosemeta && (claz._angoosemeta.baseClass == 'Service' || claz._angoosemeta.baseClass == 'Model') ){\n//         \n    // }\n    // else{\n        // throw \"Invalid class: must be a Model or Service class: \" + claz;\n    // }\n}", "code_tokens": ["function", "registerClass", "(", "nameOrOpts", ",", "claz", ")", "{", "var", "opts", "=", "typeof", "(", "nameOrOpts", ")", "==", "'object'", "?", "nameOrOpts", ":", "{", "name", ":", "nameOrOpts", "}", ";", "var", "className", "=", "opts", ".", "name", ";", "if", "(", "!", "className", ")", "throw", "\"Missing module name: \"", "+", "className", "if", "(", "beans", "[", "className", "]", ")", "logger", ".", "warn", "(", "\"Overriding existing bean: \"", ",", "className", ")", ";", "if", "(", "claz", ".", "_angoosemeta", "&&", "(", "claz", ".", "_angoosemeta", ".", "baseClass", "==", "'Service'", "||", "claz", ".", "_angoosemeta", ".", "baseClass", "==", "'Model'", ")", ")", "{", "// already mixed", "}", "else", "{", "if", "(", "typeof", "(", "claz", ")", "===", "'function'", "&&", "claz", ".", "schema", "&&", "claz", ".", "modelName", ")", "opts", ".", "baseClass", "=", "'Model'", ";", "else", "if", "(", "claz", "instanceof", "getMongoose", "(", ")", ".", "Schema", ")", "{", "opts", ".", "baseClass", "=", "'Model'", ";", "claz", "=", "getMongoose", "(", ")", ".", "model", "(", "className", ",", "claz", ")", ";", "}", "else", "opts", ".", "baseClass", "=", "'Service'", ";", "angoose", ".", "Remotable", ".", "mixin", "(", "opts", ",", "claz", ")", ";", "}", "_", ".", "extend", "(", "claz", ".", "_angoosemeta", ",", "nameOrOpts", ")", ";", "beans", "[", "className", "]", "=", "claz", ";", "//if(!nameOrOpts.isExtension)", "logger", ".", "debug", "(", "\"Registered module\"", ",", "claz", ".", "_angoosemeta", ".", "baseClass", ",", "className", ")", ";", "return", "claz", ";", "// if(claz._angoosemeta && (claz._angoosemeta.baseClass == 'Service' || claz._angoosemeta.baseClass == 'Model') ){", "//         ", "// }", "// else{", "// throw \"Invalid class: must be a Model or Service class: \" + claz;", "// }", "}"], "docstring": "register module with angoose so it knows to publish it", "docstring_tokens": ["register", "module", "with", "angoose", "so", "it", "knows", "to", "publish", "it"], "sha": "2172f7a9f44d1337156792bf4dc382805b47e121", "url": "https://github.com/tjworks/angoose/blob/2172f7a9f44d1337156792bf4dc382805b47e121/lib/angoose.js#L109-L141", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      var EmptyView = this.getEmptyView();\n  \n      if (EmptyView && !this._showingEmptyView) {\n        this.triggerMethod('before:render:empty');\n  \n        this._showingEmptyView = true;\n        var model = new Backbone.Model();\n        this.addEmptyView(model, EmptyView);\n  \n        this.triggerMethod('render:empty');\n      }\n    }", "language": "javascript", "code": "function() {\n      var EmptyView = this.getEmptyView();\n  \n      if (EmptyView && !this._showingEmptyView) {\n        this.triggerMethod('before:render:empty');\n  \n        this._showingEmptyView = true;\n        var model = new Backbone.Model();\n        this.addEmptyView(model, EmptyView);\n  \n        this.triggerMethod('render:empty');\n      }\n    }", "code_tokens": ["function", "(", ")", "{", "var", "EmptyView", "=", "this", ".", "getEmptyView", "(", ")", ";", "if", "(", "EmptyView", "&&", "!", "this", ".", "_showingEmptyView", ")", "{", "this", ".", "triggerMethod", "(", "'before:render:empty'", ")", ";", "this", ".", "_showingEmptyView", "=", "true", ";", "var", "model", "=", "new", "Backbone", ".", "Model", "(", ")", ";", "this", ".", "addEmptyView", "(", "model", ",", "EmptyView", ")", ";", "this", ".", "triggerMethod", "(", "'render:empty'", ")", ";", "}", "}"], "docstring": "Internal method to show an empty view in place of a collection of child views, when the collection is empty", "docstring_tokens": ["Internal", "method", "to", "show", "an", "empty", "view", "in", "place", "of", "a", "collection", "of", "child", "views", "when", "the", "collection", "is", "empty"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18554-L18566", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/device/sqlite/Sencha.js", "func_name": "", "original_string": "function(config) {\n                if (!this.active) {\n                    Ext.Logger.error('Ext.device.sqlite.SQLTransaction#executeSql: An attempt was made to use a SQLTransaction that is no longer usable.');\n                    return null;\n                }\n\n                if (config.sqlStatement == null) {\n                    Ext.Logger.error('Ext.device.sqlite.SQLTransaction#executeSql: You must specify a `sqlStatement` for the transaction.');\n                    return null;\n                }\n\n                this.statements.push({\n                    sqlStatement: config.sqlStatement,\n                    arguments: config.arguments,\n                    callback: config.callback,\n                    failure: config.failure,\n                    scope: config.scope\n                });\n            }", "language": "javascript", "code": "function(config) {\n                if (!this.active) {\n                    Ext.Logger.error('Ext.device.sqlite.SQLTransaction#executeSql: An attempt was made to use a SQLTransaction that is no longer usable.');\n                    return null;\n                }\n\n                if (config.sqlStatement == null) {\n                    Ext.Logger.error('Ext.device.sqlite.SQLTransaction#executeSql: You must specify a `sqlStatement` for the transaction.');\n                    return null;\n                }\n\n                this.statements.push({\n                    sqlStatement: config.sqlStatement,\n                    arguments: config.arguments,\n                    callback: config.callback,\n                    failure: config.failure,\n                    scope: config.scope\n                });\n            }", "code_tokens": ["function", "(", "config", ")", "{", "if", "(", "!", "this", ".", "active", ")", "{", "Ext", ".", "Logger", ".", "error", "(", "'Ext.device.sqlite.SQLTransaction#executeSql: An attempt was made to use a SQLTransaction that is no longer usable.'", ")", ";", "return", "null", ";", "}", "if", "(", "config", ".", "sqlStatement", "==", "null", ")", "{", "Ext", ".", "Logger", ".", "error", "(", "'Ext.device.sqlite.SQLTransaction#executeSql: You must specify a `sqlStatement` for the transaction.'", ")", ";", "return", "null", ";", "}", "this", ".", "statements", ".", "push", "(", "{", "sqlStatement", ":", "config", ".", "sqlStatement", ",", "arguments", ":", "config", ".", "arguments", ",", "callback", ":", "config", ".", "callback", ",", "failure", ":", "config", ".", "failure", ",", "scope", ":", "config", ".", "scope", "}", ")", ";", "}"], "docstring": "Executes an SQL statement.\n\n@param {Object} config\nThe object which contains the following config options:\n\n@param {String} config.sqlStatement This is required.\nThe SQL statement to execute.\n\n@param {Array} config.arguments This is optional.\nThe arguments array to bind each '?' placeholder in the SQL statement.\n\n@param {Function} config.callback This is optional.\nThe callback to be called when the SQL statement succeeded.\n\n@param {Ext.device.sqlite.SQLTransaction} config.callback.transaction\nThe transaction of the SQL statement.\n\n@param {Ext.device.sqlite.SQLTransaction} config.callback.resultSet\nThe result of the SQL statement.\n\n@param {Function} config.failure This is optional.\nThe callback to be called when an error occurred.\nIf the callback returns false, next SQL statement will be executed.\n\n@param {Ext.device.sqlite.SQLTransaction} config.failure.transaction\nThe transaction of the SQL statement.\n\n@param {Object} config.failure.error\nThe occurred error.\n\n@param {Object} config.scope\nThe scope object", "docstring_tokens": ["Executes", "an", "SQL", "statement", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/sqlite/Sencha.js#L386-L404", "partition": "test"}
{"repo": "brython-dev/brython", "path": "www/src/py_int.js", "func_name": "", "original_string": "function(self, other){\n    if(_b_.isinstance(other, int)) {\n        if(other.__class__ === $B.long_int){\n            return $B.long_int.__sub__($B.long_int.$factory(self),\n                $B.long_int.$factory(other))\n        }\n        other = int_value(other)\n        if(self > $B.max_int32 || self < $B.min_int32 ||\n                other > $B.max_int32 || other < $B.min_int32){\n            return $B.long_int.__sub__($B.long_int.$factory(self),\n                $B.long_int.$factory(other))\n        }\n        return self - other\n    }\n    if(_b_.isinstance(other, _b_.bool)){return self - other}\n    var rsub = $B.$getattr(other, \"__rsub__\", _b_.None)\n    if(rsub !== _b_.None){return rsub(self)}\n    $err(\"-\", other)\n}", "language": "javascript", "code": "function(self, other){\n    if(_b_.isinstance(other, int)) {\n        if(other.__class__ === $B.long_int){\n            return $B.long_int.__sub__($B.long_int.$factory(self),\n                $B.long_int.$factory(other))\n        }\n        other = int_value(other)\n        if(self > $B.max_int32 || self < $B.min_int32 ||\n                other > $B.max_int32 || other < $B.min_int32){\n            return $B.long_int.__sub__($B.long_int.$factory(self),\n                $B.long_int.$factory(other))\n        }\n        return self - other\n    }\n    if(_b_.isinstance(other, _b_.bool)){return self - other}\n    var rsub = $B.$getattr(other, \"__rsub__\", _b_.None)\n    if(rsub !== _b_.None){return rsub(self)}\n    $err(\"-\", other)\n}", "code_tokens": ["function", "(", "self", ",", "other", ")", "{", "if", "(", "_b_", ".", "isinstance", "(", "other", ",", "int", ")", ")", "{", "if", "(", "other", ".", "__class__", "===", "$B", ".", "long_int", ")", "{", "return", "$B", ".", "long_int", ".", "__sub__", "(", "$B", ".", "long_int", ".", "$factory", "(", "self", ")", ",", "$B", ".", "long_int", ".", "$factory", "(", "other", ")", ")", "}", "other", "=", "int_value", "(", "other", ")", "if", "(", "self", ">", "$B", ".", "max_int32", "||", "self", "<", "$B", ".", "min_int32", "||", "other", ">", "$B", ".", "max_int32", "||", "other", "<", "$B", ".", "min_int32", ")", "{", "return", "$B", ".", "long_int", ".", "__sub__", "(", "$B", ".", "long_int", ".", "$factory", "(", "self", ")", ",", "$B", ".", "long_int", ".", "$factory", "(", "other", ")", ")", "}", "return", "self", "-", "other", "}", "if", "(", "_b_", ".", "isinstance", "(", "other", ",", "_b_", ".", "bool", ")", ")", "{", "return", "self", "-", "other", "}", "var", "rsub", "=", "$B", ".", "$getattr", "(", "other", ",", "\"__rsub__\"", ",", "_b_", ".", "None", ")", "if", "(", "rsub", "!==", "_b_", ".", "None", ")", "{", "return", "rsub", "(", "self", ")", "}", "$err", "(", "\"-\"", ",", "other", ")", "}"], "docstring": "code for operands & | ^", "docstring_tokens": ["code", "for", "operands", "&", "|", "^"], "sha": "e437d320fce3c649c3028f2f7a8533eeae906440", "url": "https://github.com/brython-dev/brython/blob/e437d320fce3c649c3028f2f7a8533eeae906440/www/src/py_int.js#L507-L525", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Bus.js", "func_name": "_getChannelEvents", "original_string": "function _getChannelEvents(sChannelId, sEvent) {\n  if (oChannels[sChannelId] === und) {\n    oChannels[sChannelId] = {};\n  }\n  if (oChannels[sChannelId][sEvent] === und) {\n    oChannels[sChannelId][sEvent] = [];\n  }\n  return oChannels[sChannelId][sEvent];\n}", "language": "javascript", "code": "function _getChannelEvents(sChannelId, sEvent) {\n  if (oChannels[sChannelId] === und) {\n    oChannels[sChannelId] = {};\n  }\n  if (oChannels[sChannelId][sEvent] === und) {\n    oChannels[sChannelId][sEvent] = [];\n  }\n  return oChannels[sChannelId][sEvent];\n}", "code_tokens": ["function", "_getChannelEvents", "(", "sChannelId", ",", "sEvent", ")", "{", "if", "(", "oChannels", "[", "sChannelId", "]", "===", "und", ")", "{", "oChannels", "[", "sChannelId", "]", "=", "{", "}", ";", "}", "if", "(", "oChannels", "[", "sChannelId", "]", "[", "sEvent", "]", "===", "und", ")", "{", "oChannels", "[", "sChannelId", "]", "[", "sEvent", "]", "=", "[", "]", ";", "}", "return", "oChannels", "[", "sChannelId", "]", "[", "sEvent", "]", ";", "}"], "docstring": "_getChannelEvents return the events array in channel.\n@param {String} sChannelId\n@param {String} sEvent\n@return {Object}\n@private", "docstring_tokens": ["_getChannelEvents", "return", "the", "events", "array", "in", "channel", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Bus.js#L80-L88", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( name ) {\n\t\t\tvar parts = name.split( '.' ),\n\t\t\t\ttype = null;\n\n\t\t\t_.find( this._modelScopes, function( scope ) {\n\t\t\t\ttype = _.reduce( parts || [], function( memo, val ) {\n\t\t\t\t\treturn memo ? memo[ val ] : undefined;\n\t\t\t\t}, scope );\n\n\t\t\t\tif ( type && type !== scope ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}, this );\n\n\t\t\treturn type;\n\t\t}", "language": "javascript", "code": "function( name ) {\n\t\t\tvar parts = name.split( '.' ),\n\t\t\t\ttype = null;\n\n\t\t\t_.find( this._modelScopes, function( scope ) {\n\t\t\t\ttype = _.reduce( parts || [], function( memo, val ) {\n\t\t\t\t\treturn memo ? memo[ val ] : undefined;\n\t\t\t\t}, scope );\n\n\t\t\t\tif ( type && type !== scope ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}, this );\n\n\t\t\treturn type;\n\t\t}", "code_tokens": ["function", "(", "name", ")", "{", "var", "parts", "=", "name", ".", "split", "(", "'.'", ")", ",", "type", "=", "null", ";", "_", ".", "find", "(", "this", ".", "_modelScopes", ",", "function", "(", "scope", ")", "{", "type", "=", "_", ".", "reduce", "(", "parts", "||", "[", "]", ",", "function", "(", "memo", ",", "val", ")", "{", "return", "memo", "?", "memo", "[", "val", "]", ":", "undefined", ";", "}", ",", "scope", ")", ";", "if", "(", "type", "&&", "type", "!==", "scope", ")", "{", "return", "true", ";", "}", "}", ",", "this", ")", ";", "return", "type", ";", "}"], "docstring": "Find a model type on one of the modelScopes by name. Names are split on dots.\n@param {String} name\n@return {Object}", "docstring_tokens": ["Find", "a", "model", "type", "on", "one", "of", "the", "modelScopes", "by", "name", ".", "Names", "are", "split", "on", "dots", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L330-L345", "partition": "test"}
{"repo": "janjakubnanista/simple-imap-inbox", "path": "lib/inbox.js", "func_name": "", "original_string": "function(imapMessage) {\n    var deferred = Q.defer();\n    var message = new Message();\n\n    imapMessage.on('body', function(stream, info) {\n        var buffer = '';\n\n        stream.on('data', function(chunk) {\n            buffer += chunk.toString('utf8');\n        });\n\n        stream.on('end', function() {\n            if (info.which === 'TEXT') {\n                message.body = buffer;\n            } else {\n                message.headers = Imap.parseHeader(buffer);\n            }\n        });\n    });\n\n    imapMessage.on('attributes', function(attrs) {\n        message.attributes = attrs;\n    });\n\n    imapMessage.on('end', function() {\n        deferred.resolve(message);\n    });\n\n    return deferred.promise;\n}", "language": "javascript", "code": "function(imapMessage) {\n    var deferred = Q.defer();\n    var message = new Message();\n\n    imapMessage.on('body', function(stream, info) {\n        var buffer = '';\n\n        stream.on('data', function(chunk) {\n            buffer += chunk.toString('utf8');\n        });\n\n        stream.on('end', function() {\n            if (info.which === 'TEXT') {\n                message.body = buffer;\n            } else {\n                message.headers = Imap.parseHeader(buffer);\n            }\n        });\n    });\n\n    imapMessage.on('attributes', function(attrs) {\n        message.attributes = attrs;\n    });\n\n    imapMessage.on('end', function() {\n        deferred.resolve(message);\n    });\n\n    return deferred.promise;\n}", "code_tokens": ["function", "(", "imapMessage", ")", "{", "var", "deferred", "=", "Q", ".", "defer", "(", ")", ";", "var", "message", "=", "new", "Message", "(", ")", ";", "imapMessage", ".", "on", "(", "'body'", ",", "function", "(", "stream", ",", "info", ")", "{", "var", "buffer", "=", "''", ";", "stream", ".", "on", "(", "'data'", ",", "function", "(", "chunk", ")", "{", "buffer", "+=", "chunk", ".", "toString", "(", "'utf8'", ")", ";", "}", ")", ";", "stream", ".", "on", "(", "'end'", ",", "function", "(", ")", "{", "if", "(", "info", ".", "which", "===", "'TEXT'", ")", "{", "message", ".", "body", "=", "buffer", ";", "}", "else", "{", "message", ".", "headers", "=", "Imap", ".", "parseHeader", "(", "buffer", ")", ";", "}", "}", ")", ";", "}", ")", ";", "imapMessage", ".", "on", "(", "'attributes'", ",", "function", "(", "attrs", ")", "{", "message", ".", "attributes", "=", "attrs", ";", "}", ")", ";", "imapMessage", ".", "on", "(", "'end'", ",", "function", "(", ")", "{", "deferred", ".", "resolve", "(", "message", ")", ";", "}", ")", ";", "return", "deferred", ".", "promise", ";", "}"], "docstring": "Helper function that asynchronously converts ImapMessage instance\nto instance of Message class.\n\n@param  {ImapMessage} imapMessage    Instance of ImapMessage class obtained from Imap server call\n@return {Promise}                    Promise resolved with instance of Message class", "docstring_tokens": ["Helper", "function", "that", "asynchronously", "converts", "ImapMessage", "instance", "to", "instance", "of", "Message", "class", "."], "sha": "c333a46ed21a95f3ccf19bc91148b0fa1c35aeda", "url": "https://github.com/janjakubnanista/simple-imap-inbox/blob/c333a46ed21a95f3ccf19bc91148b0fa1c35aeda/lib/inbox.js#L16-L45", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "getNodeFromInstance$1", "original_string": "function getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}", "language": "javascript", "code": "function getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}", "code_tokens": ["function", "getNodeFromInstance$1", "(", "inst", ")", "{", "if", "(", "inst", ".", "tag", "===", "HostComponent", "||", "inst", ".", "tag", "===", "HostText", ")", "{", "// In Fiber this, is just the state node right now. We assume it will be", "// a host component or host text.", "return", "inst", ".", "stateNode", ";", "}", "// Without this first invariant, passing a non-DOM-component triggers the next", "// invariant for a missing parent, which is super confusing.", "invariant", "(", "false", ",", "'getNodeFromInstance: Invalid argument.'", ")", ";", "}"], "docstring": "Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\nDOM node.", "docstring_tokens": ["Given", "a", "ReactDOMComponent", "or", "ReactDOMTextComponent", "return", "the", "corresponding", "DOM", "node", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L3309-L3319", "partition": "test"}
{"repo": "ifrost/protoplast", "path": "js/utils/common.js", "func_name": "mergeAsObject", "original_string": "function mergeAsObject(destination, source, property) {\n    destination[property] = destination[property] || {};\n    merge(destination[property], source[property]);\n}", "language": "javascript", "code": "function mergeAsObject(destination, source, property) {\n    destination[property] = destination[property] || {};\n    merge(destination[property], source[property]);\n}", "code_tokens": ["function", "mergeAsObject", "(", "destination", ",", "source", ",", "property", ")", "{", "destination", "[", "property", "]", "=", "destination", "[", "property", "]", "||", "{", "}", ";", "merge", "(", "destination", "[", "property", "]", ",", "source", "[", "property", "]", ")", ";", "}"], "docstring": "Merges object recursively using merge function\n\n@param {Object} destination\n@param {Object} source\n@param {String} property", "docstring_tokens": ["Merges", "object", "recursively", "using", "merge", "function"], "sha": "6ff349404c38a92f8715ab746953adf2dc8d8df6", "url": "https://github.com/ifrost/protoplast/blob/6ff349404c38a92f8715ab746953adf2dc8d8df6/js/utils/common.js#L107-L110", "partition": "test"}
{"repo": "kflorence/gulp-data-json", "path": "index.js", "func_name": "json", "original_string": "function json(file) {\n  var filename = path.basename(file.path, path.extname(file.path)) + \".json\";\n  return optional(path.join(path.dirname(file.path), filename)) || {};\n}", "language": "javascript", "code": "function json(file) {\n  var filename = path.basename(file.path, path.extname(file.path)) + \".json\";\n  return optional(path.join(path.dirname(file.path), filename)) || {};\n}", "code_tokens": ["function", "json", "(", "file", ")", "{", "var", "filename", "=", "path", ".", "basename", "(", "file", ".", "path", ",", "path", ".", "extname", "(", "file", ".", "path", ")", ")", "+", "\".json\"", ";", "return", "optional", "(", "path", ".", "join", "(", "path", ".", "dirname", "(", "file", ".", "path", ")", ",", "filename", ")", ")", "||", "{", "}", ";", "}"], "docstring": "Load JSON data from a companion file and store in file data.\n\n@param {Object} file Vinyl File object\n@return JSON data", "docstring_tokens": ["Load", "JSON", "data", "from", "a", "companion", "file", "and", "store", "in", "file", "data", "."], "sha": "13d77ebb11a056f68156dc0153411901bcf2922b", "url": "https://github.com/kflorence/gulp-data-json/blob/13d77ebb11a056f68156dc0153411901bcf2922b/index.js#L11-L14", "partition": "test"}
{"repo": "donmccurdy/aframe-extras", "path": "src/controls/gamepad-controls.js", "func_name": "", "original_string": "function () {\n    const gamepad = this.getGamepad();\n    if (!gamepad.buttons[GamepadButton.DPAD_RIGHT]) {\n      return new THREE.Vector2();\n    }\n    return new THREE.Vector2(\n      (gamepad.buttons[GamepadButton.DPAD_RIGHT].pressed ? 1 : 0)\n      + (gamepad.buttons[GamepadButton.DPAD_LEFT].pressed ? -1 : 0),\n      (gamepad.buttons[GamepadButton.DPAD_UP].pressed ? -1 : 0)\n      + (gamepad.buttons[GamepadButton.DPAD_DOWN].pressed ? 1 : 0)\n    );\n  }", "language": "javascript", "code": "function () {\n    const gamepad = this.getGamepad();\n    if (!gamepad.buttons[GamepadButton.DPAD_RIGHT]) {\n      return new THREE.Vector2();\n    }\n    return new THREE.Vector2(\n      (gamepad.buttons[GamepadButton.DPAD_RIGHT].pressed ? 1 : 0)\n      + (gamepad.buttons[GamepadButton.DPAD_LEFT].pressed ? -1 : 0),\n      (gamepad.buttons[GamepadButton.DPAD_UP].pressed ? -1 : 0)\n      + (gamepad.buttons[GamepadButton.DPAD_DOWN].pressed ? 1 : 0)\n    );\n  }", "code_tokens": ["function", "(", ")", "{", "const", "gamepad", "=", "this", ".", "getGamepad", "(", ")", ";", "if", "(", "!", "gamepad", ".", "buttons", "[", "GamepadButton", ".", "DPAD_RIGHT", "]", ")", "{", "return", "new", "THREE", ".", "Vector2", "(", ")", ";", "}", "return", "new", "THREE", ".", "Vector2", "(", "(", "gamepad", ".", "buttons", "[", "GamepadButton", ".", "DPAD_RIGHT", "]", ".", "pressed", "?", "1", ":", "0", ")", "+", "(", "gamepad", ".", "buttons", "[", "GamepadButton", ".", "DPAD_LEFT", "]", ".", "pressed", "?", "-", "1", ":", "0", ")", ",", "(", "gamepad", ".", "buttons", "[", "GamepadButton", ".", "DPAD_UP", "]", ".", "pressed", "?", "-", "1", ":", "0", ")", "+", "(", "gamepad", ".", "buttons", "[", "GamepadButton", ".", "DPAD_DOWN", "]", ".", "pressed", "?", "1", ":", "0", ")", ")", ";", "}"], "docstring": "Returns the state of the dpad as a THREE.Vector2.\n@return {THREE.Vector2}", "docstring_tokens": ["Returns", "the", "state", "of", "the", "dpad", "as", "a", "THREE", ".", "Vector2", "."], "sha": "dcb4084cc89596cebcd24195a8753d877bea2f92", "url": "https://github.com/donmccurdy/aframe-extras/blob/dcb4084cc89596cebcd24195a8753d877bea2f92/src/controls/gamepad-controls.js#L259-L270", "partition": "test"}
{"repo": "daliwali/simulacra", "path": "lib/bind_keys.js", "func_name": "parentSetter", "original_string": "function parentSetter (x) {\n    var previousValue = memoizedObject[key]\n    var returnValue\n\n    // Optimistically set the memoized value, so it persists even if an error\n    // occurs after this point.\n    memoizedObject[key] = x\n\n    // Check for no-op.\n    if (x === previousValue) return x\n\n    // Need to qualify this check for non-empty value.\n    if (definition && x !== null && x !== void 0)\n      bindKeys(scope, x, definition, parentNode, keyPath)\n\n    else if (change) {\n      returnValue = change(parentNode, x,\n        previousValue === void 0 ? null : previousValue, keyPath)\n      if (returnValue !== void 0)\n        changeValue(parentNode, returnValue, branch[replaceAttributeKey])\n    }\n\n    return x\n  }", "language": "javascript", "code": "function parentSetter (x) {\n    var previousValue = memoizedObject[key]\n    var returnValue\n\n    // Optimistically set the memoized value, so it persists even if an error\n    // occurs after this point.\n    memoizedObject[key] = x\n\n    // Check for no-op.\n    if (x === previousValue) return x\n\n    // Need to qualify this check for non-empty value.\n    if (definition && x !== null && x !== void 0)\n      bindKeys(scope, x, definition, parentNode, keyPath)\n\n    else if (change) {\n      returnValue = change(parentNode, x,\n        previousValue === void 0 ? null : previousValue, keyPath)\n      if (returnValue !== void 0)\n        changeValue(parentNode, returnValue, branch[replaceAttributeKey])\n    }\n\n    return x\n  }", "code_tokens": ["function", "parentSetter", "(", "x", ")", "{", "var", "previousValue", "=", "memoizedObject", "[", "key", "]", "var", "returnValue", "// Optimistically set the memoized value, so it persists even if an error", "// occurs after this point.", "memoizedObject", "[", "key", "]", "=", "x", "// Check for no-op.", "if", "(", "x", "===", "previousValue", ")", "return", "x", "// Need to qualify this check for non-empty value.", "if", "(", "definition", "&&", "x", "!==", "null", "&&", "x", "!==", "void", "0", ")", "bindKeys", "(", "scope", ",", "x", ",", "definition", ",", "parentNode", ",", "keyPath", ")", "else", "if", "(", "change", ")", "{", "returnValue", "=", "change", "(", "parentNode", ",", "x", ",", "previousValue", "===", "void", "0", "?", "null", ":", "previousValue", ",", "keyPath", ")", "if", "(", "returnValue", "!==", "void", "0", ")", "changeValue", "(", "parentNode", ",", "returnValue", ",", "branch", "[", "replaceAttributeKey", "]", ")", "}", "return", "x", "}"], "docstring": "Special case for binding same node as parent.", "docstring_tokens": ["Special", "case", "for", "binding", "same", "node", "as", "parent", "."], "sha": "b6bb7e2486f7722101f9e416ec345d49f3afa901", "url": "https://github.com/daliwali/simulacra/blob/b6bb7e2486f7722101f9e416ec345d49f3afa901/lib/bind_keys.js#L110-L133", "partition": "test"}
{"repo": "formio/angular-formio", "path": "tools/gulp/inline-resources.js", "func_name": "inlineResourcesFromString", "original_string": "function inlineResourcesFromString(content, urlResolver) {\n  // Curry through the inlining functions.\n  return [\n    inlineTemplate,\n    inlineStyle,\n    removeModuleId\n  ].reduce((content, fn) => fn(content, urlResolver), content);\n}", "language": "javascript", "code": "function inlineResourcesFromString(content, urlResolver) {\n  // Curry through the inlining functions.\n  return [\n    inlineTemplate,\n    inlineStyle,\n    removeModuleId\n  ].reduce((content, fn) => fn(content, urlResolver), content);\n}", "code_tokens": ["function", "inlineResourcesFromString", "(", "content", ",", "urlResolver", ")", "{", "// Curry through the inlining functions.", "return", "[", "inlineTemplate", ",", "inlineStyle", ",", "removeModuleId", "]", ".", "reduce", "(", "(", "content", ",", "fn", ")", "=>", "fn", "(", "content", ",", "urlResolver", ")", ",", "content", ")", ";", "}"], "docstring": "Inline resources from a string content.\n@param content {string} The source file's content.\n@param urlResolver {Function} A resolver that takes a URL and return a path.\n@returns {string} The content with resources inlined.", "docstring_tokens": ["Inline", "resources", "from", "a", "string", "content", "."], "sha": "127eb556cb8fa810cdf06b3d7b80901f9ac055f9", "url": "https://github.com/formio/angular-formio/blob/127eb556cb8fa810cdf06b3d7b80901f9ac055f9/tools/gulp/inline-resources.js#L64-L71", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/arraybuffer.js", "func_name": "enforceString", "original_string": "function enforceString(b, encoding) {\n    if (is.string(b)) return b;\n    if (isArrayBuffer(b)) b = toBuffer(b);\n\n    return b.toString(encoding);\n}", "language": "javascript", "code": "function enforceString(b, encoding) {\n    if (is.string(b)) return b;\n    if (isArrayBuffer(b)) b = toBuffer(b);\n\n    return b.toString(encoding);\n}", "code_tokens": ["function", "enforceString", "(", "b", ",", "encoding", ")", "{", "if", "(", "is", ".", "string", "(", "b", ")", ")", "return", "b", ";", "if", "(", "isArrayBuffer", "(", "b", ")", ")", "b", "=", "toBuffer", "(", "b", ")", ";", "return", "b", ".", "toString", "(", "encoding", ")", ";", "}"], "docstring": "Force conversion to string with specific encoding", "docstring_tokens": ["Force", "conversion", "to", "string", "with", "specific", "encoding"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/arraybuffer.js#L79-L84", "partition": "test"}
{"repo": "GraFiddle/angular-chart", "path": "src/js/state.js", "func_name": "addSelections", "original_string": "function addSelections(chart, selections) {\n      service.disableSelectionListener = true;\n      selections.forEach(function (selection) {\n        chart.select([selection.id], [selection.index]);\n      });\n      service.disableSelectionListener = false;\n    }", "language": "javascript", "code": "function addSelections(chart, selections) {\n      service.disableSelectionListener = true;\n      selections.forEach(function (selection) {\n        chart.select([selection.id], [selection.index]);\n      });\n      service.disableSelectionListener = false;\n    }", "code_tokens": ["function", "addSelections", "(", "chart", ",", "selections", ")", "{", "service", ".", "disableSelectionListener", "=", "true", ";", "selections", ".", "forEach", "(", "function", "(", "selection", ")", "{", "chart", ".", "select", "(", "[", "selection", ".", "id", "]", ",", "[", "selection", ".", "index", "]", ")", ";", "}", ")", ";", "service", ".", "disableSelectionListener", "=", "false", ";", "}"], "docstring": "Add passed selection to the chart.", "docstring_tokens": ["Add", "passed", "selection", "to", "the", "chart", "."], "sha": "76620974f0547b5a9c86d2860b6b401af8aee5fc", "url": "https://github.com/GraFiddle/angular-chart/blob/76620974f0547b5a9c86d2860b6b401af8aee5fc/src/js/state.js#L91-L97", "partition": "test"}
{"repo": "jolaleye/snap", "path": "tasks/ls.js", "func_name": "ls", "original_string": "function ls() {\n  const vault = path.join(os.homedir(), '.snap');\n  const list = shell.ls(vault);\n  if (!list.length) {\n    console.log(\"\\nIt seems you don't have anything saved...\");\n    console.log(`You can run ${chalk.yellow('snap save')} to save a directory or Git repo for future use!`);\n    console.log(`Run ${chalk.yellow('snap save -h')} for more info.\\n`);\n    return;\n  }\n\n  console.log('\\nThe following boilerplates have been saved...');\n  console.log(`Run ${chalk.yellow('snap <boilerplate-name> <project-directory>')} to get started with your new project!`);\n  for (const bplate of list) {\n    console.log(`  \u25cb ${bplate}`);\n  }\n  console.log();\n}", "language": "javascript", "code": "function ls() {\n  const vault = path.join(os.homedir(), '.snap');\n  const list = shell.ls(vault);\n  if (!list.length) {\n    console.log(\"\\nIt seems you don't have anything saved...\");\n    console.log(`You can run ${chalk.yellow('snap save')} to save a directory or Git repo for future use!`);\n    console.log(`Run ${chalk.yellow('snap save -h')} for more info.\\n`);\n    return;\n  }\n\n  console.log('\\nThe following boilerplates have been saved...');\n  console.log(`Run ${chalk.yellow('snap <boilerplate-name> <project-directory>')} to get started with your new project!`);\n  for (const bplate of list) {\n    console.log(`  \u25cb ${bplate}`);\n  }\n  console.log();\n}", "code_tokens": ["function", "ls", "(", ")", "{", "const", "vault", "=", "path", ".", "join", "(", "os", ".", "homedir", "(", ")", ",", "'.snap'", ")", ";", "const", "list", "=", "shell", ".", "ls", "(", "vault", ")", ";", "if", "(", "!", "list", ".", "length", ")", "{", "console", ".", "log", "(", "\"\\nIt seems you don't have anything saved...\"", ")", ";", "console", ".", "log", "(", "`", "${", "chalk", ".", "yellow", "(", "'snap save'", ")", "}", "`", ")", ";", "console", ".", "log", "(", "`", "${", "chalk", ".", "yellow", "(", "'snap save -h'", ")", "}", "\\n", "`", ")", ";", "return", ";", "}", "console", ".", "log", "(", "'\\nThe following boilerplates have been saved...'", ")", ";", "console", ".", "log", "(", "`", "${", "chalk", ".", "yellow", "(", "'snap <boilerplate-name> <project-directory>'", ")", "}", "`", ")", ";", "for", "(", "const", "bplate", "of", "list", ")", "{", "console", ".", "log", "(", "`", "bp", "late}`", ")", ";", "", "", "}", "console", ".", "log", "(", ")", ";", "}"], "docstring": "snap ls list saved boilerplates", "docstring_tokens": ["snap", "ls", "list", "saved", "boilerplates"], "sha": "31bc67af9643aeb799ac87f45587e392a41add19", "url": "https://github.com/jolaleye/snap/blob/31bc67af9643aeb799ac87f45587e392a41add19/tasks/ls.js#L10-L26", "partition": "test"}
{"repo": "developmentseed/kes", "path": "src/utils.js", "func_name": "exec", "original_string": "function exec(cmd, verbose) {\n  verbose = verbose === false ? verbose : true;\n\n  const stdout = execSync(cmd);\n  if (verbose) {\n    console.log(stdout.toString());\n  }\n  return stdout;\n}", "language": "javascript", "code": "function exec(cmd, verbose) {\n  verbose = verbose === false ? verbose : true;\n\n  const stdout = execSync(cmd);\n  if (verbose) {\n    console.log(stdout.toString());\n  }\n  return stdout;\n}", "code_tokens": ["function", "exec", "(", "cmd", ",", "verbose", ")", "{", "verbose", "=", "verbose", "===", "false", "?", "verbose", ":", "true", ";", "const", "stdout", "=", "execSync", "(", "cmd", ")", ";", "if", "(", "verbose", ")", "{", "console", ".", "log", "(", "stdout", ".", "toString", "(", ")", ")", ";", "}", "return", "stdout", ";", "}"], "docstring": "Executes shell commands synchronously and logs the\nstdout to console.\n@param {String} cmd  Bash command\n@param {Boolean} [verbose=true] whether to post stdout to console\n@return {Buffer} The command's stdout in for of Buffer", "docstring_tokens": ["Executes", "shell", "commands", "synchronously", "and", "logs", "the", "stdout", "to", "console", "."], "sha": "c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6", "url": "https://github.com/developmentseed/kes/blob/c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6/src/utils.js#L76-L84", "partition": "test"}
{"repo": "dryjs/dry-underscore", "path": "lib/lodash.js", "func_name": "toInteger", "original_string": "function toInteger(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      var remainder = value % 1;\n      return value === value ? (remainder ? value - remainder : value) : 0;\n    }", "language": "javascript", "code": "function toInteger(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      var remainder = value % 1;\n      return value === value ? (remainder ? value - remainder : value) : 0;\n    }", "code_tokens": ["function", "toInteger", "(", "value", ")", "{", "if", "(", "!", "value", ")", "{", "return", "value", "===", "0", "?", "value", ":", "0", ";", "}", "value", "=", "toNumber", "(", "value", ")", ";", "if", "(", "value", "===", "INFINITY", "||", "value", "===", "-", "INFINITY", ")", "{", "var", "sign", "=", "(", "value", "<", "0", "?", "-", "1", ":", "1", ")", ";", "return", "sign", "*", "MAX_INTEGER", ";", "}", "var", "remainder", "=", "value", "%", "1", ";", "return", "value", "===", "value", "?", "(", "remainder", "?", "value", "-", "remainder", ":", "value", ")", ":", "0", ";", "}"], "docstring": "Converts `value` to an integer.\n\n**Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).\n\n@static\n@memberOf _\n@category Lang\n@param {*} value The value to convert.\n@returns {number} Returns the converted integer.\n@example\n\n_.toInteger(3);\n// => 3\n\n_.toInteger(Number.MIN_VALUE);\n// => 0\n\n_.toInteger(Infinity);\n// => 1.7976931348623157e+308\n\n_.toInteger('3');\n// => 3", "docstring_tokens": ["Converts", "value", "to", "an", "integer", "."], "sha": "32dff1d8abf575b3576406049dd02f0f7d946187", "url": "https://github.com/dryjs/dry-underscore/blob/32dff1d8abf575b3576406049dd02f0f7d946187/lib/lodash.js#L783-L794", "partition": "test"}
{"repo": "zdfs/grunt-datadriver", "path": "tasks/datadriver.js", "func_name": "", "original_string": "function(callback) {\n                if (tunnel || isSeleniumServerRunning) {\n                    return callback(null);\n                }\n\n                grunt.log.debug('installing driver if needed');\n                selenium.install(options.seleniumInstallOptions, function(err) {\n                    if (err) {\n                        return callback(err);\n                    }\n\n                    grunt.log.debug('driver installed');\n                    callback(null);\n                });\n            }", "language": "javascript", "code": "function(callback) {\n                if (tunnel || isSeleniumServerRunning) {\n                    return callback(null);\n                }\n\n                grunt.log.debug('installing driver if needed');\n                selenium.install(options.seleniumInstallOptions, function(err) {\n                    if (err) {\n                        return callback(err);\n                    }\n\n                    grunt.log.debug('driver installed');\n                    callback(null);\n                });\n            }", "code_tokens": ["function", "(", "callback", ")", "{", "if", "(", "tunnel", "||", "isSeleniumServerRunning", ")", "{", "return", "callback", "(", "null", ")", ";", "}", "grunt", ".", "log", ".", "debug", "(", "'installing driver if needed'", ")", ";", "selenium", ".", "install", "(", "options", ".", "seleniumInstallOptions", ",", "function", "(", "err", ")", "{", "if", "(", "err", ")", "{", "return", "callback", "(", "err", ")", ";", "}", "grunt", ".", "log", ".", "debug", "(", "'driver installed'", ")", ";", "callback", "(", "null", ")", ";", "}", ")", ";", "}"], "docstring": "install drivers if needed", "docstring_tokens": ["install", "drivers", "if", "needed"], "sha": "8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e", "url": "https://github.com/zdfs/grunt-datadriver/blob/8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e/tasks/datadriver.js#L187-L201", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(content, start, removedCount) {\n    // If the contents were empty before and this template collection has an\n    // empty view remove it now.\n    var emptyView = get(this, 'emptyView');\n    if (emptyView && emptyView instanceof Ember.View) {\n      emptyView.removeFromParent();\n    }\n\n    // Loop through child views that correspond with the removed items.\n    // Note that we loop from the end of the array to the beginning because\n    // we are mutating it as we go.\n    var childViews = this._childViews, childView, idx, len;\n\n    len = this._childViews.length;\n\n    var removingAll = removedCount === len;\n\n    if (removingAll) {\n      this.currentState.empty(this);\n      this.invokeRecursively(function(view) {\n        view.removedFromDOM = true;\n      }, false);\n    }\n\n    for (idx = start + removedCount - 1; idx >= start; idx--) {\n      childView = childViews[idx];\n      childView.destroy();\n    }\n  }", "language": "javascript", "code": "function(content, start, removedCount) {\n    // If the contents were empty before and this template collection has an\n    // empty view remove it now.\n    var emptyView = get(this, 'emptyView');\n    if (emptyView && emptyView instanceof Ember.View) {\n      emptyView.removeFromParent();\n    }\n\n    // Loop through child views that correspond with the removed items.\n    // Note that we loop from the end of the array to the beginning because\n    // we are mutating it as we go.\n    var childViews = this._childViews, childView, idx, len;\n\n    len = this._childViews.length;\n\n    var removingAll = removedCount === len;\n\n    if (removingAll) {\n      this.currentState.empty(this);\n      this.invokeRecursively(function(view) {\n        view.removedFromDOM = true;\n      }, false);\n    }\n\n    for (idx = start + removedCount - 1; idx >= start; idx--) {\n      childView = childViews[idx];\n      childView.destroy();\n    }\n  }", "code_tokens": ["function", "(", "content", ",", "start", ",", "removedCount", ")", "{", "// If the contents were empty before and this template collection has an", "// empty view remove it now.", "var", "emptyView", "=", "get", "(", "this", ",", "'emptyView'", ")", ";", "if", "(", "emptyView", "&&", "emptyView", "instanceof", "Ember", ".", "View", ")", "{", "emptyView", ".", "removeFromParent", "(", ")", ";", "}", "// Loop through child views that correspond with the removed items.", "// Note that we loop from the end of the array to the beginning because", "// we are mutating it as we go.", "var", "childViews", "=", "this", ".", "_childViews", ",", "childView", ",", "idx", ",", "len", ";", "len", "=", "this", ".", "_childViews", ".", "length", ";", "var", "removingAll", "=", "removedCount", "===", "len", ";", "if", "(", "removingAll", ")", "{", "this", ".", "currentState", ".", "empty", "(", "this", ")", ";", "this", ".", "invokeRecursively", "(", "function", "(", "view", ")", "{", "view", ".", "removedFromDOM", "=", "true", ";", "}", ",", "false", ")", ";", "}", "for", "(", "idx", "=", "start", "+", "removedCount", "-", "1", ";", "idx", ">=", "start", ";", "idx", "--", ")", "{", "childView", "=", "childViews", "[", "idx", "]", ";", "childView", ".", "destroy", "(", ")", ";", "}", "}"], "docstring": "Called when a mutation to the underlying content array will occur.\n\nThis method will remove any views that are no longer in the underlying\ncontent array.\n\nInvokes whenever the content array itself will change.\n\n@method arrayWillChange\n@param {Array} content the managed collection of objects\n@param {Number} start the index at which the changes will occurr\n@param {Number} removed number of object to be removed from content", "docstring_tokens": ["Called", "when", "a", "mutation", "to", "the", "underlying", "content", "array", "will", "occur", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L25942-L25970", "partition": "test"}
{"repo": "italia/bootstrap-italia", "path": "src/js/plugins/password-strength-meter/password-strength-meter.js", "func_name": "init", "original_string": "function init() {\n      var shown = true\n      var $text = options.showText\n\n      var $graybar = $('<div>').addClass(\n        'password-meter progress rounded-0 position-absolute'\n      )\n      $graybar.append(`<div class=\"row position-absolute w-100 m-0\">\n        <div class=\"col-3 border-left border-right border-white\"></div>\n        <div class=\"col-3 border-left border-right border-white\"></div>\n        <div class=\"col-3 border-left border-right border-white\"></div>\n        <div class=\"col-3 border-left border-right border-white\"></div>\n      </div>`)\n      var $colorbar = $('<div>').attr({\n        class: 'progress-bar',\n        role: 'progressbar',\n        'aria-valuenow': '0',\n        'aria-valuemin': '0',\n        'aria-valuemax': '100',\n      })\n      var $insert = $('<div>').append($graybar.append($colorbar))\n\n      if (options.showText) {\n        $text = $('<small>')\n          .addClass('form-text text-muted')\n          .html(options.enterPass)\n        $insert.prepend($text)\n      }\n\n      $object.after($insert)\n\n      $object.keyup(function() {\n        var score = calculateScore($object.val())\n        $object.trigger('password.score', [score])\n        var perc = score < 0 ? 0 : score\n        $colorbar.removeClass(function(index, className) {\n          return (className.match(/(^|\\s)bg-\\S+/g) || []).join(' ')\n        })\n        $colorbar.addClass('bg-' + scoreColor(score))\n        $colorbar.css({\n          width: perc + '%',\n        })\n        $colorbar.attr('aria-valuenow', perc)\n\n        if (options.showText) {\n          var text = scoreText(score)\n          if (!$object.val().length && score <= 0) {\n            text = options.enterPass\n          }\n\n          if (\n            $text.html() !==\n            $('<div>')\n              .html(text)\n              .html()\n          ) {\n            $text.html(text)\n            $text.removeClass(function(index, className) {\n              return (className.match(/(^|\\s)text-\\S+/g) || []).join(' ')\n            })\n            $text.addClass('text-' + scoreColor(score))\n            $object.trigger('password.text', [text, score])\n          }\n        }\n      })\n\n      return this\n    }", "language": "javascript", "code": "function init() {\n      var shown = true\n      var $text = options.showText\n\n      var $graybar = $('<div>').addClass(\n        'password-meter progress rounded-0 position-absolute'\n      )\n      $graybar.append(`<div class=\"row position-absolute w-100 m-0\">\n        <div class=\"col-3 border-left border-right border-white\"></div>\n        <div class=\"col-3 border-left border-right border-white\"></div>\n        <div class=\"col-3 border-left border-right border-white\"></div>\n        <div class=\"col-3 border-left border-right border-white\"></div>\n      </div>`)\n      var $colorbar = $('<div>').attr({\n        class: 'progress-bar',\n        role: 'progressbar',\n        'aria-valuenow': '0',\n        'aria-valuemin': '0',\n        'aria-valuemax': '100',\n      })\n      var $insert = $('<div>').append($graybar.append($colorbar))\n\n      if (options.showText) {\n        $text = $('<small>')\n          .addClass('form-text text-muted')\n          .html(options.enterPass)\n        $insert.prepend($text)\n      }\n\n      $object.after($insert)\n\n      $object.keyup(function() {\n        var score = calculateScore($object.val())\n        $object.trigger('password.score', [score])\n        var perc = score < 0 ? 0 : score\n        $colorbar.removeClass(function(index, className) {\n          return (className.match(/(^|\\s)bg-\\S+/g) || []).join(' ')\n        })\n        $colorbar.addClass('bg-' + scoreColor(score))\n        $colorbar.css({\n          width: perc + '%',\n        })\n        $colorbar.attr('aria-valuenow', perc)\n\n        if (options.showText) {\n          var text = scoreText(score)\n          if (!$object.val().length && score <= 0) {\n            text = options.enterPass\n          }\n\n          if (\n            $text.html() !==\n            $('<div>')\n              .html(text)\n              .html()\n          ) {\n            $text.html(text)\n            $text.removeClass(function(index, className) {\n              return (className.match(/(^|\\s)text-\\S+/g) || []).join(' ')\n            })\n            $text.addClass('text-' + scoreColor(score))\n            $object.trigger('password.text', [text, score])\n          }\n        }\n      })\n\n      return this\n    }", "code_tokens": ["function", "init", "(", ")", "{", "var", "shown", "=", "true", "var", "$text", "=", "options", ".", "showText", "var", "$graybar", "=", "$", "(", "'<div>'", ")", ".", "addClass", "(", "'password-meter progress rounded-0 position-absolute'", ")", "$graybar", ".", "append", "(", "`", "`", ")", "var", "$colorbar", "=", "$", "(", "'<div>'", ")", ".", "attr", "(", "{", "class", ":", "'progress-bar'", ",", "role", ":", "'progressbar'", ",", "'aria-valuenow'", ":", "'0'", ",", "'aria-valuemin'", ":", "'0'", ",", "'aria-valuemax'", ":", "'100'", ",", "}", ")", "var", "$insert", "=", "$", "(", "'<div>'", ")", ".", "append", "(", "$graybar", ".", "append", "(", "$colorbar", ")", ")", "if", "(", "options", ".", "showText", ")", "{", "$text", "=", "$", "(", "'<small>'", ")", ".", "addClass", "(", "'form-text text-muted'", ")", ".", "html", "(", "options", ".", "enterPass", ")", "$insert", ".", "prepend", "(", "$text", ")", "}", "$object", ".", "after", "(", "$insert", ")", "$object", ".", "keyup", "(", "function", "(", ")", "{", "var", "score", "=", "calculateScore", "(", "$object", ".", "val", "(", ")", ")", "$object", ".", "trigger", "(", "'password.score'", ",", "[", "score", "]", ")", "var", "perc", "=", "score", "<", "0", "?", "0", ":", "score", "$colorbar", ".", "removeClass", "(", "function", "(", "index", ",", "className", ")", "{", "return", "(", "className", ".", "match", "(", "/", "(^|\\s)bg-\\S+", "/", "g", ")", "||", "[", "]", ")", ".", "join", "(", "' '", ")", "}", ")", "$colorbar", ".", "addClass", "(", "'bg-'", "+", "scoreColor", "(", "score", ")", ")", "$colorbar", ".", "css", "(", "{", "width", ":", "perc", "+", "'%'", ",", "}", ")", "$colorbar", ".", "attr", "(", "'aria-valuenow'", ",", "perc", ")", "if", "(", "options", ".", "showText", ")", "{", "var", "text", "=", "scoreText", "(", "score", ")", "if", "(", "!", "$object", ".", "val", "(", ")", ".", "length", "&&", "score", "<=", "0", ")", "{", "text", "=", "options", ".", "enterPass", "}", "if", "(", "$text", ".", "html", "(", ")", "!==", "$", "(", "'<div>'", ")", ".", "html", "(", "text", ")", ".", "html", "(", ")", ")", "{", "$text", ".", "html", "(", "text", ")", "$text", ".", "removeClass", "(", "function", "(", "index", ",", "className", ")", "{", "return", "(", "className", ".", "match", "(", "/", "(^|\\s)text-\\S+", "/", "g", ")", "||", "[", "]", ")", ".", "join", "(", "' '", ")", "}", ")", "$text", ".", "addClass", "(", "'text-'", "+", "scoreColor", "(", "score", ")", ")", "$object", ".", "trigger", "(", "'password.text'", ",", "[", "text", ",", "score", "]", ")", "}", "}", "}", ")", "return", "this", "}"], "docstring": "Initializes the plugin creating and binding the\nrequired layers and events.\n\n@return void", "docstring_tokens": ["Initializes", "the", "plugin", "creating", "and", "binding", "the", "required", "layers", "and", "events", "."], "sha": "9d2177a1c0c731f83636d2164bd22702ef5767c2", "url": "https://github.com/italia/bootstrap-italia/blob/9d2177a1c0c731f83636d2164bd22702ef5767c2/src/js/plugins/password-strength-meter/password-strength-meter.js#L181-L248", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "scanJsxIdentifier", "original_string": "function scanJsxIdentifier() {\n            if (tokenIsIdentifierOrKeyword(token)) {\n                var firstCharPosition = pos;\n                while (pos < end) {\n                    var ch = text.charCodeAt(pos);\n                    if (ch === 45 /* minus */ || ((firstCharPosition === pos) ? isIdentifierStart(ch, languageVersion) : isIdentifierPart(ch, languageVersion))) {\n                        pos++;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                tokenValue += text.substr(firstCharPosition, pos - firstCharPosition);\n            }\n            return token;\n        }", "language": "javascript", "code": "function scanJsxIdentifier() {\n            if (tokenIsIdentifierOrKeyword(token)) {\n                var firstCharPosition = pos;\n                while (pos < end) {\n                    var ch = text.charCodeAt(pos);\n                    if (ch === 45 /* minus */ || ((firstCharPosition === pos) ? isIdentifierStart(ch, languageVersion) : isIdentifierPart(ch, languageVersion))) {\n                        pos++;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                tokenValue += text.substr(firstCharPosition, pos - firstCharPosition);\n            }\n            return token;\n        }", "code_tokens": ["function", "scanJsxIdentifier", "(", ")", "{", "if", "(", "tokenIsIdentifierOrKeyword", "(", "token", ")", ")", "{", "var", "firstCharPosition", "=", "pos", ";", "while", "(", "pos", "<", "end", ")", "{", "var", "ch", "=", "text", ".", "charCodeAt", "(", "pos", ")", ";", "if", "(", "ch", "===", "45", "/* minus */", "||", "(", "(", "firstCharPosition", "===", "pos", ")", "?", "isIdentifierStart", "(", "ch", ",", "languageVersion", ")", ":", "isIdentifierPart", "(", "ch", ",", "languageVersion", ")", ")", ")", "{", "pos", "++", ";", "}", "else", "{", "break", ";", "}", "}", "tokenValue", "+=", "text", ".", "substr", "(", "firstCharPosition", ",", "pos", "-", "firstCharPosition", ")", ";", "}", "return", "token", ";", "}"], "docstring": "Scans a JSX identifier; these differ from normal identifiers in that they allow dashes", "docstring_tokens": ["Scans", "a", "JSX", "identifier", ";", "these", "differ", "from", "normal", "identifiers", "in", "that", "they", "allow", "dashes"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L4087-L4102", "partition": "test"}
{"repo": "everitoken/evtjs", "path": "src/evtLink.js", "func_name": "parseQRCode", "original_string": "function parseQRCode(text, options) {\n    if (text.length < 3 || text.length > 2000) throw new Error(\"Invalid length of EvtLink\");\n\n    let textSplited = text.split(\"_\");\n    if (textSplited.length > 2) return null;\n\n    let rawText;\n\n    if (textSplited[0].startsWith(qrPrefix)) {\n        rawText = textSplited[0].substr(qrPrefix.length);\n    }\n    else {\n        rawText = textSplited[0];\n    }\n    \n    // decode segments base42\n    let segmentsBytes = EvtLink.dec2b(rawText);\n    if (segmentsBytes.length < 2) throw new Error(\"no flag in segment\");\n    let flag = segmentsBytes.readInt16BE(0);\n    \n    if ((flag & 1) == 0) { // check version of EvtLink\n        throw new Error(\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\");\n    }\n    let segmentsBytesRaw = new Buffer(segmentsBytes.length - 2);\n    segmentsBytes.copy(segmentsBytesRaw, 0, 2, segmentsBytes.length);\n\n    let publicKeys = [ ];\n    let signatures = [ ];\n\n    if (textSplited[1]) {\n        let buf = EvtLink.dec2b(textSplited[1]);\n        let i = 0;\n\n        if (buf.length % 65 !== 0) {\n            throw new Error(\"length of signature is invalid\");\n        }\n\n        while (i * 65 < buf.length) {\n            let current = new Buffer(65);\n            buf.copy(current, 0, i * 65, i * 65 + 65);\n            let signature = ecc.Signature.fromBuffer(current);\n            signatures.push(signature.toString());\n\n            if (!options || options.recoverPublicKeys) {\n                publicKeys.push(signature.recover(segmentsBytes).toString());\n            }\n\n            ++i;\n        }\n    }\n\n    return { flag, segments: parseSegments(segmentsBytesRaw), publicKeys, signatures };\n}", "language": "javascript", "code": "function parseQRCode(text, options) {\n    if (text.length < 3 || text.length > 2000) throw new Error(\"Invalid length of EvtLink\");\n\n    let textSplited = text.split(\"_\");\n    if (textSplited.length > 2) return null;\n\n    let rawText;\n\n    if (textSplited[0].startsWith(qrPrefix)) {\n        rawText = textSplited[0].substr(qrPrefix.length);\n    }\n    else {\n        rawText = textSplited[0];\n    }\n    \n    // decode segments base42\n    let segmentsBytes = EvtLink.dec2b(rawText);\n    if (segmentsBytes.length < 2) throw new Error(\"no flag in segment\");\n    let flag = segmentsBytes.readInt16BE(0);\n    \n    if ((flag & 1) == 0) { // check version of EvtLink\n        throw new Error(\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\");\n    }\n    let segmentsBytesRaw = new Buffer(segmentsBytes.length - 2);\n    segmentsBytes.copy(segmentsBytesRaw, 0, 2, segmentsBytes.length);\n\n    let publicKeys = [ ];\n    let signatures = [ ];\n\n    if (textSplited[1]) {\n        let buf = EvtLink.dec2b(textSplited[1]);\n        let i = 0;\n\n        if (buf.length % 65 !== 0) {\n            throw new Error(\"length of signature is invalid\");\n        }\n\n        while (i * 65 < buf.length) {\n            let current = new Buffer(65);\n            buf.copy(current, 0, i * 65, i * 65 + 65);\n            let signature = ecc.Signature.fromBuffer(current);\n            signatures.push(signature.toString());\n\n            if (!options || options.recoverPublicKeys) {\n                publicKeys.push(signature.recover(segmentsBytes).toString());\n            }\n\n            ++i;\n        }\n    }\n\n    return { flag, segments: parseSegments(segmentsBytesRaw), publicKeys, signatures };\n}", "code_tokens": ["function", "parseQRCode", "(", "text", ",", "options", ")", "{", "if", "(", "text", ".", "length", "<", "3", "||", "text", ".", "length", ">", "2000", ")", "throw", "new", "Error", "(", "\"Invalid length of EvtLink\"", ")", ";", "let", "textSplited", "=", "text", ".", "split", "(", "\"_\"", ")", ";", "if", "(", "textSplited", ".", "length", ">", "2", ")", "return", "null", ";", "let", "rawText", ";", "if", "(", "textSplited", "[", "0", "]", ".", "startsWith", "(", "qrPrefix", ")", ")", "{", "rawText", "=", "textSplited", "[", "0", "]", ".", "substr", "(", "qrPrefix", ".", "length", ")", ";", "}", "else", "{", "rawText", "=", "textSplited", "[", "0", "]", ";", "}", "// decode segments base42", "let", "segmentsBytes", "=", "EvtLink", ".", "dec2b", "(", "rawText", ")", ";", "if", "(", "segmentsBytes", ".", "length", "<", "2", ")", "throw", "new", "Error", "(", "\"no flag in segment\"", ")", ";", "let", "flag", "=", "segmentsBytes", ".", "readInt16BE", "(", "0", ")", ";", "if", "(", "(", "flag", "&", "1", ")", "==", "0", ")", "{", "// check version of EvtLink", "throw", "new", "Error", "(", "\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\"", ")", ";", "}", "let", "segmentsBytesRaw", "=", "new", "Buffer", "(", "segmentsBytes", ".", "length", "-", "2", ")", ";", "segmentsBytes", ".", "copy", "(", "segmentsBytesRaw", ",", "0", ",", "2", ",", "segmentsBytes", ".", "length", ")", ";", "let", "publicKeys", "=", "[", "]", ";", "let", "signatures", "=", "[", "]", ";", "if", "(", "textSplited", "[", "1", "]", ")", "{", "let", "buf", "=", "EvtLink", ".", "dec2b", "(", "textSplited", "[", "1", "]", ")", ";", "let", "i", "=", "0", ";", "if", "(", "buf", ".", "length", "%", "65", "!==", "0", ")", "{", "throw", "new", "Error", "(", "\"length of signature is invalid\"", ")", ";", "}", "while", "(", "i", "*", "65", "<", "buf", ".", "length", ")", "{", "let", "current", "=", "new", "Buffer", "(", "65", ")", ";", "buf", ".", "copy", "(", "current", ",", "0", ",", "i", "*", "65", ",", "i", "*", "65", "+", "65", ")", ";", "let", "signature", "=", "ecc", ".", "Signature", ".", "fromBuffer", "(", "current", ")", ";", "signatures", ".", "push", "(", "signature", ".", "toString", "(", ")", ")", ";", "if", "(", "!", "options", "||", "options", ".", "recoverPublicKeys", ")", "{", "publicKeys", ".", "push", "(", "signature", ".", "recover", "(", "segmentsBytes", ")", ".", "toString", "(", ")", ")", ";", "}", "++", "i", ";", "}", "}", "return", "{", "flag", ",", "segments", ":", "parseSegments", "(", "segmentsBytesRaw", ")", ",", "publicKeys", ",", "signatures", "}", ";", "}"], "docstring": "Parse a everiToken's QRCode Text\n@param {string} text", "docstring_tokens": ["Parse", "a", "everiToken", "s", "QRCode", "Text"], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L211-L263", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(models, options) {\n      options = _.extend({}, options);\n      var singular = !_.isArray(models);\n      models = singular ? [models] : _.clone(models);\n      var removed = this._removeModels(models, options);\n      if (!options.silent && removed) this.trigger('update', this, options);\n      return singular ? removed[0] : removed;\n    }", "language": "javascript", "code": "function(models, options) {\n      options = _.extend({}, options);\n      var singular = !_.isArray(models);\n      models = singular ? [models] : _.clone(models);\n      var removed = this._removeModels(models, options);\n      if (!options.silent && removed) this.trigger('update', this, options);\n      return singular ? removed[0] : removed;\n    }", "code_tokens": ["function", "(", "models", ",", "options", ")", "{", "options", "=", "_", ".", "extend", "(", "{", "}", ",", "options", ")", ";", "var", "singular", "=", "!", "_", ".", "isArray", "(", "models", ")", ";", "models", "=", "singular", "?", "[", "models", "]", ":", "_", ".", "clone", "(", "models", ")", ";", "var", "removed", "=", "this", ".", "_removeModels", "(", "models", ",", "options", ")", ";", "if", "(", "!", "options", ".", "silent", "&&", "removed", ")", "this", ".", "trigger", "(", "'update'", ",", "this", ",", "options", ")", ";", "return", "singular", "?", "removed", "[", "0", "]", ":", "removed", ";", "}"], "docstring": "Remove a model, or a list of models from the set.", "docstring_tokens": ["Remove", "a", "model", "or", "a", "list", "of", "models", "from", "the", "set", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L13372-L13379", "partition": "test"}
{"repo": "blakevanlan/insist", "path": "index.js", "func_name": "", "original_string": "function (expected, args, minimum) {\n   var shiftedArgs = [];\n   var curArg = args.length - 1;\n   var remainingOptionalArgs = expected.length - minimum;\n   var optionalIndiceSegments = [];\n   var optionalIndiceSegment = [];\n   var availableArgsSegments = [];\n   var availableArgsSegment = [];\n\n   // Fill the return array with nulls first.\n   for (var i = 0; i < expected.length; i++) shiftedArgs[i] = null;\n\n   // Capture groups of available arguments separated by ones that have been used.\n   var advanceArg = function () {\n      availableArgsSegment.unshift(curArg);\n      curArg--;\n      remainingOptionalArgs--;\n      if (curArg < 0 || remainingOptionalArgs < 0) {\n         throw Error(getExpectedVsRecieved_(expected, args));\n      }\n   };\n\n   // Fill in all of the required types, starting from the last expected argument and working\n   // towards the first.\n   for (i = expected.length - 1; i >= 0; i--) {\n      var type = expected[i];\n      if (isOptionalType(type)) {\n         optionalIndiceSegment.unshift(i);\n         continue;\n      }\n      // Keep moving down the line of arguments until one matches.\n      while (!isOfType(args[curArg], type)) {\n         advanceArg();\n      }\n\n      // Check if this argument should be left for a trailing optional argument.\n      if (checkIfShouldLeaveArgument_(expected, i, args, curArg)) {\n         // Found enough matches to let this be an optional argument. Advance the argument and\n         // then restart on this same function.\n         advanceArg();\n         i++;\n         continue;\n      }\n\n      // Capture groups of optional arguments separated by required arguments.\n      optionalIndiceSegments.unshift(optionalIndiceSegment);\n      optionalIndiceSegment = [];\n      availableArgsSegments.unshift(availableArgsSegment);\n      availableArgsSegment = []\n      shiftedArgs[i] = args[curArg--];\n   }\n   // Now that we have found all the required arguments, group the rest for processing with optional\n   // arguments.\n   while (curArg >= 0) availableArgsSegment.unshift(curArg--);\n   availableArgsSegments.unshift(availableArgsSegment);\n   optionalIndiceSegments.unshift(optionalIndiceSegment);\n\n   // Make sure that the optional argument count matches up correctly.\n   if (availableArgsSegments.length != optionalIndiceSegments.length) {\n      throw Error(getExpectedVsRecieved_(expected, args));\n   }\n\n   // Go through all the optional segments and argument segments to match up the optional arguments.\n   optionalIndiceSegments.forEach(function (optionalIndices, index) {\n      availableArgsSegment = availableArgsSegments[index];\n      i = 0;\n      availableArgsSegment.forEach(function (argIndex) {\n         arg = args[argIndex]\n         // Skip forward until we find an optional expected argument that matches.\n         while (!isOfType(arg, expected[optionalIndices[i]]) && i < optionalIndices.length) {\n            i++;\n         }\n         // If none match then the arguments are invalid.\n         if (i >= optionalIndices.length) {\n            throw Error(getExpectedVsRecieved_(expected, args));\n         }\n         // Success! This is an optional expected argument.\n         shiftedArgs[optionalIndices[i++]] = arg;\n      });\n   });\n\n   return shiftedArgs;\n}", "language": "javascript", "code": "function (expected, args, minimum) {\n   var shiftedArgs = [];\n   var curArg = args.length - 1;\n   var remainingOptionalArgs = expected.length - minimum;\n   var optionalIndiceSegments = [];\n   var optionalIndiceSegment = [];\n   var availableArgsSegments = [];\n   var availableArgsSegment = [];\n\n   // Fill the return array with nulls first.\n   for (var i = 0; i < expected.length; i++) shiftedArgs[i] = null;\n\n   // Capture groups of available arguments separated by ones that have been used.\n   var advanceArg = function () {\n      availableArgsSegment.unshift(curArg);\n      curArg--;\n      remainingOptionalArgs--;\n      if (curArg < 0 || remainingOptionalArgs < 0) {\n         throw Error(getExpectedVsRecieved_(expected, args));\n      }\n   };\n\n   // Fill in all of the required types, starting from the last expected argument and working\n   // towards the first.\n   for (i = expected.length - 1; i >= 0; i--) {\n      var type = expected[i];\n      if (isOptionalType(type)) {\n         optionalIndiceSegment.unshift(i);\n         continue;\n      }\n      // Keep moving down the line of arguments until one matches.\n      while (!isOfType(args[curArg], type)) {\n         advanceArg();\n      }\n\n      // Check if this argument should be left for a trailing optional argument.\n      if (checkIfShouldLeaveArgument_(expected, i, args, curArg)) {\n         // Found enough matches to let this be an optional argument. Advance the argument and\n         // then restart on this same function.\n         advanceArg();\n         i++;\n         continue;\n      }\n\n      // Capture groups of optional arguments separated by required arguments.\n      optionalIndiceSegments.unshift(optionalIndiceSegment);\n      optionalIndiceSegment = [];\n      availableArgsSegments.unshift(availableArgsSegment);\n      availableArgsSegment = []\n      shiftedArgs[i] = args[curArg--];\n   }\n   // Now that we have found all the required arguments, group the rest for processing with optional\n   // arguments.\n   while (curArg >= 0) availableArgsSegment.unshift(curArg--);\n   availableArgsSegments.unshift(availableArgsSegment);\n   optionalIndiceSegments.unshift(optionalIndiceSegment);\n\n   // Make sure that the optional argument count matches up correctly.\n   if (availableArgsSegments.length != optionalIndiceSegments.length) {\n      throw Error(getExpectedVsRecieved_(expected, args));\n   }\n\n   // Go through all the optional segments and argument segments to match up the optional arguments.\n   optionalIndiceSegments.forEach(function (optionalIndices, index) {\n      availableArgsSegment = availableArgsSegments[index];\n      i = 0;\n      availableArgsSegment.forEach(function (argIndex) {\n         arg = args[argIndex]\n         // Skip forward until we find an optional expected argument that matches.\n         while (!isOfType(arg, expected[optionalIndices[i]]) && i < optionalIndices.length) {\n            i++;\n         }\n         // If none match then the arguments are invalid.\n         if (i >= optionalIndices.length) {\n            throw Error(getExpectedVsRecieved_(expected, args));\n         }\n         // Success! This is an optional expected argument.\n         shiftedArgs[optionalIndices[i++]] = arg;\n      });\n   });\n\n   return shiftedArgs;\n}", "code_tokens": ["function", "(", "expected", ",", "args", ",", "minimum", ")", "{", "var", "shiftedArgs", "=", "[", "]", ";", "var", "curArg", "=", "args", ".", "length", "-", "1", ";", "var", "remainingOptionalArgs", "=", "expected", ".", "length", "-", "minimum", ";", "var", "optionalIndiceSegments", "=", "[", "]", ";", "var", "optionalIndiceSegment", "=", "[", "]", ";", "var", "availableArgsSegments", "=", "[", "]", ";", "var", "availableArgsSegment", "=", "[", "]", ";", "// Fill the return array with nulls first.", "for", "(", "var", "i", "=", "0", ";", "i", "<", "expected", ".", "length", ";", "i", "++", ")", "shiftedArgs", "[", "i", "]", "=", "null", ";", "// Capture groups of available arguments separated by ones that have been used.", "var", "advanceArg", "=", "function", "(", ")", "{", "availableArgsSegment", ".", "unshift", "(", "curArg", ")", ";", "curArg", "--", ";", "remainingOptionalArgs", "--", ";", "if", "(", "curArg", "<", "0", "||", "remainingOptionalArgs", "<", "0", ")", "{", "throw", "Error", "(", "getExpectedVsRecieved_", "(", "expected", ",", "args", ")", ")", ";", "}", "}", ";", "// Fill in all of the required types, starting from the last expected argument and working", "// towards the first.", "for", "(", "i", "=", "expected", ".", "length", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "var", "type", "=", "expected", "[", "i", "]", ";", "if", "(", "isOptionalType", "(", "type", ")", ")", "{", "optionalIndiceSegment", ".", "unshift", "(", "i", ")", ";", "continue", ";", "}", "// Keep moving down the line of arguments until one matches.", "while", "(", "!", "isOfType", "(", "args", "[", "curArg", "]", ",", "type", ")", ")", "{", "advanceArg", "(", ")", ";", "}", "// Check if this argument should be left for a trailing optional argument.", "if", "(", "checkIfShouldLeaveArgument_", "(", "expected", ",", "i", ",", "args", ",", "curArg", ")", ")", "{", "// Found enough matches to let this be an optional argument. Advance the argument and", "// then restart on this same function.", "advanceArg", "(", ")", ";", "i", "++", ";", "continue", ";", "}", "// Capture groups of optional arguments separated by required arguments.", "optionalIndiceSegments", ".", "unshift", "(", "optionalIndiceSegment", ")", ";", "optionalIndiceSegment", "=", "[", "]", ";", "availableArgsSegments", ".", "unshift", "(", "availableArgsSegment", ")", ";", "availableArgsSegment", "=", "[", "]", "shiftedArgs", "[", "i", "]", "=", "args", "[", "curArg", "--", "]", ";", "}", "// Now that we have found all the required arguments, group the rest for processing with optional", "// arguments.", "while", "(", "curArg", ">=", "0", ")", "availableArgsSegment", ".", "unshift", "(", "curArg", "--", ")", ";", "availableArgsSegments", ".", "unshift", "(", "availableArgsSegment", ")", ";", "optionalIndiceSegments", ".", "unshift", "(", "optionalIndiceSegment", ")", ";", "// Make sure that the optional argument count matches up correctly.", "if", "(", "availableArgsSegments", ".", "length", "!=", "optionalIndiceSegments", ".", "length", ")", "{", "throw", "Error", "(", "getExpectedVsRecieved_", "(", "expected", ",", "args", ")", ")", ";", "}", "// Go through all the optional segments and argument segments to match up the optional arguments.", "optionalIndiceSegments", ".", "forEach", "(", "function", "(", "optionalIndices", ",", "index", ")", "{", "availableArgsSegment", "=", "availableArgsSegments", "[", "index", "]", ";", "i", "=", "0", ";", "availableArgsSegment", ".", "forEach", "(", "function", "(", "argIndex", ")", "{", "arg", "=", "args", "[", "argIndex", "]", "// Skip forward until we find an optional expected argument that matches.", "while", "(", "!", "isOfType", "(", "arg", ",", "expected", "[", "optionalIndices", "[", "i", "]", "]", ")", "&&", "i", "<", "optionalIndices", ".", "length", ")", "{", "i", "++", ";", "}", "// If none match then the arguments are invalid.", "if", "(", "i", ">=", "optionalIndices", ".", "length", ")", "{", "throw", "Error", "(", "getExpectedVsRecieved_", "(", "expected", ",", "args", ")", ")", ";", "}", "// Success! This is an optional expected argument.", "shiftedArgs", "[", "optionalIndices", "[", "i", "++", "]", "]", "=", "arg", ";", "}", ")", ";", "}", ")", ";", "return", "shiftedArgs", ";", "}"], "docstring": "Returns an array of all of the arguments shifted into the correct place.\n@param {Array} expected\n@param {Array} actual\n@returns {Array}\n@private", "docstring_tokens": ["Returns", "an", "array", "of", "all", "of", "the", "arguments", "shifted", "into", "the", "correct", "place", "."], "sha": "a5f557f4fd48029e20ae0d66912f701d0577feb5", "url": "https://github.com/blakevanlan/insist/blob/a5f557f4fd48029e20ae0d66912f701d0577feb5/index.js#L74-L156", "partition": "test"}
{"repo": "italia/bootstrap-italia", "path": "src/js/plugins/i-sticky/i-sticky.js", "func_name": "updateScrollPos", "original_string": "function updateScrollPos() {\n    if (!stickies.length) {\n      return\n    }\n\n    lastKnownScrollTop =\n      document.documentElement.scrollTop || document.body.scrollTop\n\n    // Only trigger a layout change if we\u2019re not already waiting for one\n    if (!isAnimationRequested) {\n      isAnimationRequested = true\n\n      // Don\u2019t update until next animation frame if we can, otherwise use a\n      // timeout - either will help avoid too many repaints\n      if (requestAnimationFrame) {\n        requestAnimationFrame(setPositions)\n      } else {\n        if (timeout) {\n          clearTimeout(timeout)\n        }\n\n        timeout = setTimeout(setPositions, 15)\n      }\n    }\n  }", "language": "javascript", "code": "function updateScrollPos() {\n    if (!stickies.length) {\n      return\n    }\n\n    lastKnownScrollTop =\n      document.documentElement.scrollTop || document.body.scrollTop\n\n    // Only trigger a layout change if we\u2019re not already waiting for one\n    if (!isAnimationRequested) {\n      isAnimationRequested = true\n\n      // Don\u2019t update until next animation frame if we can, otherwise use a\n      // timeout - either will help avoid too many repaints\n      if (requestAnimationFrame) {\n        requestAnimationFrame(setPositions)\n      } else {\n        if (timeout) {\n          clearTimeout(timeout)\n        }\n\n        timeout = setTimeout(setPositions, 15)\n      }\n    }\n  }", "code_tokens": ["function", "updateScrollPos", "(", ")", "{", "if", "(", "!", "stickies", ".", "length", ")", "{", "return", "}", "lastKnownScrollTop", "=", "document", ".", "documentElement", ".", "scrollTop", "||", "document", ".", "body", ".", "scrollTop", "// Only trigger a layout change if we\u2019re not already waiting for one", "if", "(", "!", "isAnimationRequested", ")", "{", "isAnimationRequested", "=", "true", "// Don\u2019t update until next animation frame if we can, otherwise use a", "// timeout - either will help avoid too many repaints", "if", "(", "requestAnimationFrame", ")", "{", "requestAnimationFrame", "(", "setPositions", ")", "}", "else", "{", "if", "(", "timeout", ")", "{", "clearTimeout", "(", "timeout", ")", "}", "timeout", "=", "setTimeout", "(", "setPositions", ",", "15", ")", "}", "}", "}"], "docstring": "Debounced scroll handling", "docstring_tokens": ["Debounced", "scroll", "handling"], "sha": "9d2177a1c0c731f83636d2164bd22702ef5767c2", "url": "https://github.com/italia/bootstrap-italia/blob/9d2177a1c0c731f83636d2164bd22702ef5767c2/src/js/plugins/i-sticky/i-sticky.js#L319-L343", "partition": "test"}
{"repo": "emmetio/codemirror-plugin", "path": "lib/autocomplete.js", "func_name": "getStylesheetSnippets", "original_string": "function getStylesheetSnippets(registry) {\n\treturn convertToCSSSnippets(registry).map(snippet => {\n\t\tlet preview = snippet.property;\n\t\tconst keywords = snippet.keywords();\n\t\tif (keywords.length) {\n\t\t\tpreview += `: ${removeFields(keywords.join(' | '))}`;\n\t\t} else if (snippet.value) {\n\t\t\tpreview += `: ${removeFields(snippet.value)}`;\n\t\t}\n\n\t\treturn {\n\t\t\tkey: snippet.key,\n\t\t\tvalue: snippet.value,\n\t\t\tsnippet: snippet.key,\n\t\t\tproperty: snippet.property,\n\t\t\tkeywords: keywords.map(kw => {\n\t\t\t\tconst m = kw.match(/^[\\w-]+/);\n\t\t\t\treturn m && {\n\t\t\t\t\tkey: m[0],\n\t\t\t\t\tpreview: removeFields(kw),\n\t\t\t\t\tsnippet: kw\n\t\t\t\t};\n\t\t\t}).filter(Boolean),\n\t\t\tpreview\n\t\t};\n\t});\n}", "language": "javascript", "code": "function getStylesheetSnippets(registry) {\n\treturn convertToCSSSnippets(registry).map(snippet => {\n\t\tlet preview = snippet.property;\n\t\tconst keywords = snippet.keywords();\n\t\tif (keywords.length) {\n\t\t\tpreview += `: ${removeFields(keywords.join(' | '))}`;\n\t\t} else if (snippet.value) {\n\t\t\tpreview += `: ${removeFields(snippet.value)}`;\n\t\t}\n\n\t\treturn {\n\t\t\tkey: snippet.key,\n\t\t\tvalue: snippet.value,\n\t\t\tsnippet: snippet.key,\n\t\t\tproperty: snippet.property,\n\t\t\tkeywords: keywords.map(kw => {\n\t\t\t\tconst m = kw.match(/^[\\w-]+/);\n\t\t\t\treturn m && {\n\t\t\t\t\tkey: m[0],\n\t\t\t\t\tpreview: removeFields(kw),\n\t\t\t\t\tsnippet: kw\n\t\t\t\t};\n\t\t\t}).filter(Boolean),\n\t\t\tpreview\n\t\t};\n\t});\n}", "code_tokens": ["function", "getStylesheetSnippets", "(", "registry", ")", "{", "return", "convertToCSSSnippets", "(", "registry", ")", ".", "map", "(", "snippet", "=>", "{", "let", "preview", "=", "snippet", ".", "property", ";", "const", "keywords", "=", "snippet", ".", "keywords", "(", ")", ";", "if", "(", "keywords", ".", "length", ")", "{", "preview", "+=", "`", "${", "removeFields", "(", "keywords", ".", "join", "(", "' | '", ")", ")", "}", "`", ";", "}", "else", "if", "(", "snippet", ".", "value", ")", "{", "preview", "+=", "`", "${", "removeFields", "(", "snippet", ".", "value", ")", "}", "`", ";", "}", "return", "{", "key", ":", "snippet", ".", "key", ",", "value", ":", "snippet", ".", "value", ",", "snippet", ":", "snippet", ".", "key", ",", "property", ":", "snippet", ".", "property", ",", "keywords", ":", "keywords", ".", "map", "(", "kw", "=>", "{", "const", "m", "=", "kw", ".", "match", "(", "/", "^[\\w-]+", "/", ")", ";", "return", "m", "&&", "{", "key", ":", "m", "[", "0", "]", ",", "preview", ":", "removeFields", "(", "kw", ")", ",", "snippet", ":", "kw", "}", ";", "}", ")", ".", "filter", "(", "Boolean", ")", ",", "preview", "}", ";", "}", ")", ";", "}"], "docstring": "Returns stylesheet snippets list\n@param {SnippetsRegistry} registry\n@return {Array}", "docstring_tokens": ["Returns", "stylesheet", "snippets", "list"], "sha": "2089c8b15b97858b82b33e6e81ee1b50954581c1", "url": "https://github.com/emmetio/codemirror-plugin/blob/2089c8b15b97858b82b33e6e81ee1b50954581c1/lib/autocomplete.js#L151-L177", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "Growly", "original_string": "function Growly() {\n        this.appname = 'Growly';\n        this.notifications = undefined;\n        this.labels = undefined;\n        this.count = 0;\n        this.registered = false;\n        this.host = undefined;\n        this.port = undefined;\n    }", "language": "javascript", "code": "function Growly() {\n        this.appname = 'Growly';\n        this.notifications = undefined;\n        this.labels = undefined;\n        this.count = 0;\n        this.registered = false;\n        this.host = undefined;\n        this.port = undefined;\n    }", "code_tokens": ["function", "Growly", "(", ")", "{", "this", ".", "appname", "=", "'Growly'", ";", "this", ".", "notifications", "=", "undefined", ";", "this", ".", "labels", "=", "undefined", ";", "this", ".", "count", "=", "0", ";", "this", ".", "registered", "=", "false", ";", "this", ".", "host", "=", "undefined", ";", "this", ".", "port", "=", "undefined", ";", "}"], "docstring": "Interface for registering Growl applications and sending Growl notifications.\n\n@api private", "docstring_tokens": ["Interface", "for", "registering", "Growl", "applications", "and", "sending", "Growl", "notifications", "."], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L52057-L52065", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Module.js", "func_name": "getCallbackToSetObjectFromTemplate", "original_string": "function getCallbackToSetObjectFromTemplate(oMethodsObject, oPropertiesObject) {\n  return function (oValue, sKey) {\n    if (typeof oValue === 'function') {\n      oMethodsObject[sKey] = getSimpleFunction(oValue);\n    } else if (isArray(oValue)) {\n      oPropertiesObject[sKey] = copyArray(oValue);\n    } else if (typeof oValue === 'object' && oValue !== null ) {\n      oPropertiesObject[sKey] = simpleMerge({}, oValue);\n    } else if (isInstanceOf(oValue, Date)) {\n      oPropertiesObject[sKey] = new Date();\n      oPropertiesObject[sKey].setTime(oValue.getTime());\n    } else {\n      oPropertiesObject[sKey] = oValue;\n    }\n  };\n}", "language": "javascript", "code": "function getCallbackToSetObjectFromTemplate(oMethodsObject, oPropertiesObject) {\n  return function (oValue, sKey) {\n    if (typeof oValue === 'function') {\n      oMethodsObject[sKey] = getSimpleFunction(oValue);\n    } else if (isArray(oValue)) {\n      oPropertiesObject[sKey] = copyArray(oValue);\n    } else if (typeof oValue === 'object' && oValue !== null ) {\n      oPropertiesObject[sKey] = simpleMerge({}, oValue);\n    } else if (isInstanceOf(oValue, Date)) {\n      oPropertiesObject[sKey] = new Date();\n      oPropertiesObject[sKey].setTime(oValue.getTime());\n    } else {\n      oPropertiesObject[sKey] = oValue;\n    }\n  };\n}", "code_tokens": ["function", "getCallbackToSetObjectFromTemplate", "(", "oMethodsObject", ",", "oPropertiesObject", ")", "{", "return", "function", "(", "oValue", ",", "sKey", ")", "{", "if", "(", "typeof", "oValue", "===", "'function'", ")", "{", "oMethodsObject", "[", "sKey", "]", "=", "getSimpleFunction", "(", "oValue", ")", ";", "}", "else", "if", "(", "isArray", "(", "oValue", ")", ")", "{", "oPropertiesObject", "[", "sKey", "]", "=", "copyArray", "(", "oValue", ")", ";", "}", "else", "if", "(", "typeof", "oValue", "===", "'object'", "&&", "oValue", "!==", "null", ")", "{", "oPropertiesObject", "[", "sKey", "]", "=", "simpleMerge", "(", "{", "}", ",", "oValue", ")", ";", "}", "else", "if", "(", "isInstanceOf", "(", "oValue", ",", "Date", ")", ")", "{", "oPropertiesObject", "[", "sKey", "]", "=", "new", "Date", "(", ")", ";", "oPropertiesObject", "[", "sKey", "]", ".", "setTime", "(", "oValue", ".", "getTime", "(", ")", ")", ";", "}", "else", "{", "oPropertiesObject", "[", "sKey", "]", "=", "oValue", ";", "}", "}", ";", "}"], "docstring": "Sets properties and methods from a template object.\n@param {Object} oMethodsObject\n@param {Object} oPropertiesObject\n@returns {Function}", "docstring_tokens": ["Sets", "properties", "and", "methods", "from", "a", "template", "object", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Module.js#L343-L358", "partition": "test"}
{"repo": "yahoo/locator", "path": "lib/bundleLocator.js", "func_name": "", "original_string": "function (seed, parent) {\n        var bundle,\n            ruleset = this._loadRuleset(seed),\n            msg;\n\n        if (seed.options.location) {\n            // This is fairly legacy, and we might be able to remove it.\n            seed.baseDirectory = libpath.resolve(seed.baseDirectory, seed.options.location);\n        }\n\n        if (!ruleset) {\n            msg = 'Bundle \"' + seed.name + '\" has unknown ruleset ' + JSON.stringify(seed.options.ruleset);\n            if (seed.options.rulesets) {\n                msg += ' in rulesets ' + JSON.stringify(seed.options.rulesets);\n            }\n            throw new Error(msg);\n        }\n\n        bundle = new Bundle(seed.baseDirectory, seed.options);\n        bundle.name = seed.name;\n        bundle.version = seed.version;\n        bundle.type = ruleset._name;\n        this._bundles[bundle.name] = bundle;\n        this._bundlePaths[libfs.realpathSync(bundle.baseDirectory)] = bundle.name;\n\n        // wire into parent\n        if (parent) {\n            if (!parent.bundles) {\n                parent.bundles = {};\n            }\n            parent.bundles[bundle.name] = bundle;\n        }\n        return bundle;\n    }", "language": "javascript", "code": "function (seed, parent) {\n        var bundle,\n            ruleset = this._loadRuleset(seed),\n            msg;\n\n        if (seed.options.location) {\n            // This is fairly legacy, and we might be able to remove it.\n            seed.baseDirectory = libpath.resolve(seed.baseDirectory, seed.options.location);\n        }\n\n        if (!ruleset) {\n            msg = 'Bundle \"' + seed.name + '\" has unknown ruleset ' + JSON.stringify(seed.options.ruleset);\n            if (seed.options.rulesets) {\n                msg += ' in rulesets ' + JSON.stringify(seed.options.rulesets);\n            }\n            throw new Error(msg);\n        }\n\n        bundle = new Bundle(seed.baseDirectory, seed.options);\n        bundle.name = seed.name;\n        bundle.version = seed.version;\n        bundle.type = ruleset._name;\n        this._bundles[bundle.name] = bundle;\n        this._bundlePaths[libfs.realpathSync(bundle.baseDirectory)] = bundle.name;\n\n        // wire into parent\n        if (parent) {\n            if (!parent.bundles) {\n                parent.bundles = {};\n            }\n            parent.bundles[bundle.name] = bundle;\n        }\n        return bundle;\n    }", "code_tokens": ["function", "(", "seed", ",", "parent", ")", "{", "var", "bundle", ",", "ruleset", "=", "this", ".", "_loadRuleset", "(", "seed", ")", ",", "msg", ";", "if", "(", "seed", ".", "options", ".", "location", ")", "{", "// This is fairly legacy, and we might be able to remove it.", "seed", ".", "baseDirectory", "=", "libpath", ".", "resolve", "(", "seed", ".", "baseDirectory", ",", "seed", ".", "options", ".", "location", ")", ";", "}", "if", "(", "!", "ruleset", ")", "{", "msg", "=", "'Bundle \"'", "+", "seed", ".", "name", "+", "'\" has unknown ruleset '", "+", "JSON", ".", "stringify", "(", "seed", ".", "options", ".", "ruleset", ")", ";", "if", "(", "seed", ".", "options", ".", "rulesets", ")", "{", "msg", "+=", "' in rulesets '", "+", "JSON", ".", "stringify", "(", "seed", ".", "options", ".", "rulesets", ")", ";", "}", "throw", "new", "Error", "(", "msg", ")", ";", "}", "bundle", "=", "new", "Bundle", "(", "seed", ".", "baseDirectory", ",", "seed", ".", "options", ")", ";", "bundle", ".", "name", "=", "seed", ".", "name", ";", "bundle", ".", "version", "=", "seed", ".", "version", ";", "bundle", ".", "type", "=", "ruleset", ".", "_name", ";", "this", ".", "_bundles", "[", "bundle", ".", "name", "]", "=", "bundle", ";", "this", ".", "_bundlePaths", "[", "libfs", ".", "realpathSync", "(", "bundle", ".", "baseDirectory", ")", "]", "=", "bundle", ".", "name", ";", "// wire into parent", "if", "(", "parent", ")", "{", "if", "(", "!", "parent", ".", "bundles", ")", "{", "parent", ".", "bundles", "=", "{", "}", ";", "}", "parent", ".", "bundles", "[", "bundle", ".", "name", "]", "=", "bundle", ";", "}", "return", "bundle", ";", "}"], "docstring": "Makes a bundle out of a directory.\n@private\n@method _makeBundle\n@param {object} seed The seed bundle, @see _makeBundleSeed()\n@param {Bundle} parent Parent bundle. Only the root bundle doesn't have a parent.\n@return {Bundle} The new bundle", "docstring_tokens": ["Makes", "a", "bundle", "out", "of", "a", "directory", "."], "sha": "563e6d453556dd776572761bd8e002e6e1ac64b6", "url": "https://github.com/yahoo/locator/blob/563e6d453556dd776572761bd8e002e6e1ac64b6/lib/bundleLocator.js#L330-L363", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "stripQuotes", "original_string": "function stripQuotes(name) {\n        var length = name.length;\n        if (length >= 2 &&\n            name.charCodeAt(0) === name.charCodeAt(length - 1) &&\n            (name.charCodeAt(0) === 34 /* doubleQuote */ || name.charCodeAt(0) === 39 /* singleQuote */)) {\n            return name.substring(1, length - 1);\n        }\n        ;\n        return name;\n    }", "language": "javascript", "code": "function stripQuotes(name) {\n        var length = name.length;\n        if (length >= 2 &&\n            name.charCodeAt(0) === name.charCodeAt(length - 1) &&\n            (name.charCodeAt(0) === 34 /* doubleQuote */ || name.charCodeAt(0) === 39 /* singleQuote */)) {\n            return name.substring(1, length - 1);\n        }\n        ;\n        return name;\n    }", "code_tokens": ["function", "stripQuotes", "(", "name", ")", "{", "var", "length", "=", "name", ".", "length", ";", "if", "(", "length", ">=", "2", "&&", "name", ".", "charCodeAt", "(", "0", ")", "===", "name", ".", "charCodeAt", "(", "length", "-", "1", ")", "&&", "(", "name", ".", "charCodeAt", "(", "0", ")", "===", "34", "/* doubleQuote */", "||", "name", ".", "charCodeAt", "(", "0", ")", "===", "39", "/* singleQuote */", ")", ")", "{", "return", "name", ".", "substring", "(", "1", ",", "length", "-", "1", ")", ";", "}", ";", "return", "name", ";", "}"], "docstring": "Strip off existed single quotes or double quotes from a given string\n\n@return non-quoted string", "docstring_tokens": ["Strip", "off", "existed", "single", "quotes", "or", "double", "quotes", "from", "a", "given", "string"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L40050-L40059", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(view) {\n    view._notifyWillDestroyElement();\n    view.domManager.remove(view);\n    set(view, 'element', null);\n    if (view._scheduledInsert) {\n      Ember.run.cancel(view._scheduledInsert);\n      view._scheduledInsert = null;\n    }\n    return view;\n  }", "language": "javascript", "code": "function(view) {\n    view._notifyWillDestroyElement();\n    view.domManager.remove(view);\n    set(view, 'element', null);\n    if (view._scheduledInsert) {\n      Ember.run.cancel(view._scheduledInsert);\n      view._scheduledInsert = null;\n    }\n    return view;\n  }", "code_tokens": ["function", "(", "view", ")", "{", "view", ".", "_notifyWillDestroyElement", "(", ")", ";", "view", ".", "domManager", ".", "remove", "(", "view", ")", ";", "set", "(", "view", ",", "'element'", ",", "null", ")", ";", "if", "(", "view", ".", "_scheduledInsert", ")", "{", "Ember", ".", "run", ".", "cancel", "(", "view", ".", "_scheduledInsert", ")", ";", "view", ".", "_scheduledInsert", "=", "null", ";", "}", "return", "view", ";", "}"], "docstring": "once the view is already in the DOM, destroying it removes it from the DOM, nukes its element, and puts it back into the preRender state if inDOM.", "docstring_tokens": ["once", "the", "view", "is", "already", "in", "the", "DOM", "destroying", "it", "removes", "it", "from", "the", "DOM", "nukes", "its", "element", "and", "puts", "it", "back", "into", "the", "preRender", "state", "if", "inDOM", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L25118-L25127", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "onDocumentMouseWheel", "original_string": "function onDocumentMouseWheel(event) {\n    // Only do something if the panorama is loaded and mouse wheel zoom is enabled\n    if (!loaded || (config.mouseZoom == 'fullscreenonly' && !fullscreenActive)) {\n        return;\n    }\n\n    event.preventDefault();\n\n    // Turn off auto-rotation if enabled\n    stopAnimation();\n    latestInteraction = Date.now();\n\n    if (event.wheelDeltaY) {\n        // WebKit\n        setHfov(config.hfov - event.wheelDeltaY * 0.05);\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\n    } else if (event.wheelDelta) {\n        // Opera / Explorer 9\n        setHfov(config.hfov - event.wheelDelta * 0.05);\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\n    } else if (event.detail) {\n        // Firefox\n        setHfov(config.hfov + event.detail * 1.5);\n        speed.hfov = event.detail > 0 ? 1 : -1;\n    }\n    animateInit();\n}", "language": "javascript", "code": "function onDocumentMouseWheel(event) {\n    // Only do something if the panorama is loaded and mouse wheel zoom is enabled\n    if (!loaded || (config.mouseZoom == 'fullscreenonly' && !fullscreenActive)) {\n        return;\n    }\n\n    event.preventDefault();\n\n    // Turn off auto-rotation if enabled\n    stopAnimation();\n    latestInteraction = Date.now();\n\n    if (event.wheelDeltaY) {\n        // WebKit\n        setHfov(config.hfov - event.wheelDeltaY * 0.05);\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\n    } else if (event.wheelDelta) {\n        // Opera / Explorer 9\n        setHfov(config.hfov - event.wheelDelta * 0.05);\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\n    } else if (event.detail) {\n        // Firefox\n        setHfov(config.hfov + event.detail * 1.5);\n        speed.hfov = event.detail > 0 ? 1 : -1;\n    }\n    animateInit();\n}", "code_tokens": ["function", "onDocumentMouseWheel", "(", "event", ")", "{", "// Only do something if the panorama is loaded and mouse wheel zoom is enabled", "if", "(", "!", "loaded", "||", "(", "config", ".", "mouseZoom", "==", "'fullscreenonly'", "&&", "!", "fullscreenActive", ")", ")", "{", "return", ";", "}", "event", ".", "preventDefault", "(", ")", ";", "// Turn off auto-rotation if enabled", "stopAnimation", "(", ")", ";", "latestInteraction", "=", "Date", ".", "now", "(", ")", ";", "if", "(", "event", ".", "wheelDeltaY", ")", "{", "// WebKit", "setHfov", "(", "config", ".", "hfov", "-", "event", ".", "wheelDeltaY", "*", "0.05", ")", ";", "speed", ".", "hfov", "=", "event", ".", "wheelDelta", "<", "0", "?", "1", ":", "-", "1", ";", "}", "else", "if", "(", "event", ".", "wheelDelta", ")", "{", "// Opera / Explorer 9", "setHfov", "(", "config", ".", "hfov", "-", "event", ".", "wheelDelta", "*", "0.05", ")", ";", "speed", ".", "hfov", "=", "event", ".", "wheelDelta", "<", "0", "?", "1", ":", "-", "1", ";", "}", "else", "if", "(", "event", ".", "detail", ")", "{", "// Firefox", "setHfov", "(", "config", ".", "hfov", "+", "event", ".", "detail", "*", "1.5", ")", ";", "speed", ".", "hfov", "=", "event", ".", "detail", ">", "0", "?", "1", ":", "-", "1", ";", "}", "animateInit", "(", ")", ";", "}"], "docstring": "Event handler for mouse wheel. Changes zoom.\n@private\n@param {WheelEvent} event - Document mouse wheel event.", "docstring_tokens": ["Event", "handler", "for", "mouse", "wheel", ".", "Changes", "zoom", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L982-L1008", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(store, primaryType, payload) {\n    payload = this.normalizePayload(primaryType, payload);\n\n    var primaryTypeName = primaryType.typeKey,\n        primaryArray;\n\n    for (var prop in payload) {\n      var typeKey = prop,\n          forcedSecondary = false;\n\n      if (prop.charAt(0) === '_') {\n        forcedSecondary = true;\n        typeKey = prop.substr(1);\n      }\n\n      var typeName = this.typeForRoot(typeKey),\n          type = store.modelFor(typeName),\n          typeSerializer = store.serializerFor(type),\n          isPrimary = (!forcedSecondary && (typeName === primaryTypeName));\n\n      /*jshint loopfunc:true*/\n      var normalizedArray = map.call(payload[prop], function(hash) {\n        return typeSerializer.normalize(type, hash, prop);\n      }, this);\n\n      if (isPrimary) {\n        primaryArray = normalizedArray;\n      } else {\n        store.pushMany(typeName, normalizedArray);\n      }\n    }\n\n    return primaryArray;\n  }", "language": "javascript", "code": "function(store, primaryType, payload) {\n    payload = this.normalizePayload(primaryType, payload);\n\n    var primaryTypeName = primaryType.typeKey,\n        primaryArray;\n\n    for (var prop in payload) {\n      var typeKey = prop,\n          forcedSecondary = false;\n\n      if (prop.charAt(0) === '_') {\n        forcedSecondary = true;\n        typeKey = prop.substr(1);\n      }\n\n      var typeName = this.typeForRoot(typeKey),\n          type = store.modelFor(typeName),\n          typeSerializer = store.serializerFor(type),\n          isPrimary = (!forcedSecondary && (typeName === primaryTypeName));\n\n      /*jshint loopfunc:true*/\n      var normalizedArray = map.call(payload[prop], function(hash) {\n        return typeSerializer.normalize(type, hash, prop);\n      }, this);\n\n      if (isPrimary) {\n        primaryArray = normalizedArray;\n      } else {\n        store.pushMany(typeName, normalizedArray);\n      }\n    }\n\n    return primaryArray;\n  }", "code_tokens": ["function", "(", "store", ",", "primaryType", ",", "payload", ")", "{", "payload", "=", "this", ".", "normalizePayload", "(", "primaryType", ",", "payload", ")", ";", "var", "primaryTypeName", "=", "primaryType", ".", "typeKey", ",", "primaryArray", ";", "for", "(", "var", "prop", "in", "payload", ")", "{", "var", "typeKey", "=", "prop", ",", "forcedSecondary", "=", "false", ";", "if", "(", "prop", ".", "charAt", "(", "0", ")", "===", "'_'", ")", "{", "forcedSecondary", "=", "true", ";", "typeKey", "=", "prop", ".", "substr", "(", "1", ")", ";", "}", "var", "typeName", "=", "this", ".", "typeForRoot", "(", "typeKey", ")", ",", "type", "=", "store", ".", "modelFor", "(", "typeName", ")", ",", "typeSerializer", "=", "store", ".", "serializerFor", "(", "type", ")", ",", "isPrimary", "=", "(", "!", "forcedSecondary", "&&", "(", "typeName", "===", "primaryTypeName", ")", ")", ";", "/*jshint loopfunc:true*/", "var", "normalizedArray", "=", "map", ".", "call", "(", "payload", "[", "prop", "]", ",", "function", "(", "hash", ")", "{", "return", "typeSerializer", ".", "normalize", "(", "type", ",", "hash", ",", "prop", ")", ";", "}", ",", "this", ")", ";", "if", "(", "isPrimary", ")", "{", "primaryArray", "=", "normalizedArray", ";", "}", "else", "{", "store", ".", "pushMany", "(", "typeName", ",", "normalizedArray", ")", ";", "}", "}", "return", "primaryArray", ";", "}"], "docstring": "Called when the server has returned a payload representing\nmultiple records, such as in response to a `findAll` or `findQuery`.\n\nIt is your opportunity to clean up the server's response into the normalized\nform expected by Ember Data.\n\nIf you want, you can just restructure the top-level of your payload, and\ndo more fine-grained normalization in the `normalize` method.\n\nFor example, if you have a payload like this in response to a request for\nall posts:\n\n```js\n{\n\"_embedded\": {\n\"post\": [{\n\"id\": 1,\n\"title\": \"Rails is omakase\"\n}, {\n\"id\": 2,\n\"title\": \"The Parley Letter\"\n}],\n\"comment\": [{\n\"_id\": 1,\n\"comment_title\": \"Rails is unagi\"\n\"post_id\": 1\n}, {\n\"_id\": 2,\n\"comment_title\": \"Don't tread on me\",\n\"post_id\": 2\n}]\n}\n}\n```\n\nYou could implement a serializer that looks like this to get your payload\ninto shape:\n\n```js\nApp.PostSerializer = DS.RESTSerializer.extend({\nFirst, restructure the top-level so it's organized by type\nand the comments are listed under a post's `comments` key.\nextractArray: function(store, type, payload, id, requestType) {\nvar posts = payload._embedded.post;\nvar comments = [];\nvar postCache = {};\n\nposts.forEach(function(post) {\npost.comments = [];\npostCache[post.id] = post;\n});\n\npayload._embedded.comment.forEach(function(comment) {\ncomments.push(comment);\npostCache[comment.post_id].comments.push(comment);\ndelete comment.post_id;\n}\n\npayload = { comments: comments, posts: payload };\n\nreturn this._super(store, type, payload, id, requestType);\n},\n\nnormalizeHash: {\nNext, normalize individual comments, which (after `extract`)\nare now located under `comments`\ncomments: function(hash) {\nhash.id = hash._id;\nhash.title = hash.comment_title;\ndelete hash._id;\ndelete hash.comment_title;\nreturn hash;\n}\n}\n})\n```\n\nWhen you call super from your own implementation of `extractArray`, the\nbuilt-in implementation will find the primary array in your normalized\npayload and push the remaining records into the store.\n\nThe primary array is the array found under `posts`.\n\nThe primary record has special meaning when responding to `findQuery`\nor `findHasMany`. In particular, the primary array will become the\nlist of records in the record array that kicked off the request.\n\nIf your primary array contains secondary (embedded) records of the same type,\nyou cannot place these into the primary array `posts`. Instead, place the\nsecondary items into an underscore prefixed property `_posts`, which will\npush these items into the store and will not affect the resulting query.\n\n@method extractArray\n@param {DS.Store} store\n@param {subclass of DS.Model} type\n@param {Object} payload\n@param {'findAll'|'findMany'|'findHasMany'|'findQuery'} requestType\n@returns {Array} The primary array that was returned in response\nto the original query.", "docstring_tokens": ["Called", "when", "the", "server", "has", "returned", "a", "payload", "representing", "multiple", "records", "such", "as", "in", "response", "to", "a", "findAll", "or", "findQuery", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L8710-L8743", "partition": "test"}
{"repo": "kevincennis/promise", "path": "promise.js", "func_name": "PromiseResolve", "original_string": "function PromiseResolve () {\n    return function F ( resolution ) {\n      var promise = F['[[Promise]]'], reactions;\n      if ( Type(promise) !== 'object' ) {\n        throw TypeError();\n      }\n      if ( promise['[[PromiseStatus]]'] !== 'unresolved' ) {\n        return undefined;\n      }\n      reactions = promise['[[PromiseResolveReactions]]'];\n      defineInternal(promise, '[[PromiseResult]]', resolution);\n      defineInternal(promise, '[[PromiseResolveReactions]]', undefined);\n      defineInternal(promise, '[[PromiseRejectReactions]]', undefined);\n      defineInternal(promise, '[[PromiseStatus]]', 'has-resolution');\n      return TriggerPromiseReactions(reactions, resolution);\n    };\n  }", "language": "javascript", "code": "function PromiseResolve () {\n    return function F ( resolution ) {\n      var promise = F['[[Promise]]'], reactions;\n      if ( Type(promise) !== 'object' ) {\n        throw TypeError();\n      }\n      if ( promise['[[PromiseStatus]]'] !== 'unresolved' ) {\n        return undefined;\n      }\n      reactions = promise['[[PromiseResolveReactions]]'];\n      defineInternal(promise, '[[PromiseResult]]', resolution);\n      defineInternal(promise, '[[PromiseResolveReactions]]', undefined);\n      defineInternal(promise, '[[PromiseRejectReactions]]', undefined);\n      defineInternal(promise, '[[PromiseStatus]]', 'has-resolution');\n      return TriggerPromiseReactions(reactions, resolution);\n    };\n  }", "code_tokens": ["function", "PromiseResolve", "(", ")", "{", "return", "function", "F", "(", "resolution", ")", "{", "var", "promise", "=", "F", "[", "'[[Promise]]'", "]", ",", "reactions", ";", "if", "(", "Type", "(", "promise", ")", "!==", "'object'", ")", "{", "throw", "TypeError", "(", ")", ";", "}", "if", "(", "promise", "[", "'[[PromiseStatus]]'", "]", "!==", "'unresolved'", ")", "{", "return", "undefined", ";", "}", "reactions", "=", "promise", "[", "'[[PromiseResolveReactions]]'", "]", ";", "defineInternal", "(", "promise", ",", "'[[PromiseResult]]'", ",", "resolution", ")", ";", "defineInternal", "(", "promise", ",", "'[[PromiseResolveReactions]]'", ",", "undefined", ")", ";", "defineInternal", "(", "promise", ",", "'[[PromiseRejectReactions]]'", ",", "undefined", ")", ";", "defineInternal", "(", "promise", ",", "'[[PromiseStatus]]'", ",", "'has-resolution'", ")", ";", "return", "TriggerPromiseReactions", "(", "reactions", ",", "resolution", ")", ";", "}", ";", "}"], "docstring": "25.4.1.4.1 Promise Resolve Functions", "docstring_tokens": ["25", ".", "4", ".", "1", ".", "4", ".", "1", "Promise", "Resolve", "Functions"], "sha": "b58ef67dd4023139d0aad98ccd0cb60d8a4f9eec", "url": "https://github.com/kevincennis/promise/blob/b58ef67dd4023139d0aad98ccd0cb60d8a4f9eec/promise.js#L303-L319", "partition": "test"}
{"repo": "westoque/gauges-node", "path": "docs/jsdoc/templates/codeview/publish.js", "func_name": "makeSignature", "original_string": "function makeSignature(params) {\n\tif (!params) return \"()\";\n\tvar signature = \"(\"\n\t+\n\tparams.filter(\n\t\tfunction($) {\n      return !/\\w+\\.\\w+/.test($.name);\n\t\t}\n\t).map(\n\t\tfunction($) {\n      var name = $.isOptional ?\n          '[' + $.name + ']' : $.name;\n\t\t\treturn name;\n\t\t}\n\t).join(\", \")\n\t+\n\t\")\";\n\treturn signature;\n}", "language": "javascript", "code": "function makeSignature(params) {\n\tif (!params) return \"()\";\n\tvar signature = \"(\"\n\t+\n\tparams.filter(\n\t\tfunction($) {\n      return !/\\w+\\.\\w+/.test($.name);\n\t\t}\n\t).map(\n\t\tfunction($) {\n      var name = $.isOptional ?\n          '[' + $.name + ']' : $.name;\n\t\t\treturn name;\n\t\t}\n\t).join(\", \")\n\t+\n\t\")\";\n\treturn signature;\n}", "code_tokens": ["function", "makeSignature", "(", "params", ")", "{", "if", "(", "!", "params", ")", "return", "\"()\"", ";", "var", "signature", "=", "\"(\"", "+", "params", ".", "filter", "(", "function", "(", "$", ")", "{", "return", "!", "/", "\\w+\\.\\w+", "/", ".", "test", "(", "$", ".", "name", ")", ";", "}", ")", ".", "map", "(", "function", "(", "$", ")", "{", "var", "name", "=", "$", ".", "isOptional", "?", "'['", "+", "$", ".", "name", "+", "']'", ":", "$", ".", "name", ";", "return", "name", ";", "}", ")", ".", "join", "(", "\", \"", ")", "+", "\")\"", ";", "return", "signature", ";", "}"], "docstring": "Build output for displaying function parameters.", "docstring_tokens": ["Build", "output", "for", "displaying", "function", "parameters", "."], "sha": "4dfc962cc58fb03d97e0137d89703e321d4f8ec3", "url": "https://github.com/westoque/gauges-node/blob/4dfc962cc58fb03d97e0137d89703e321d4f8ec3/docs/jsdoc/templates/codeview/publish.js#L202-L220", "partition": "test"}
{"repo": "commonform-archive/commonform-serve", "path": "routes/post.js", "func_name": "parseJSON", "original_string": "function parseJSON(input, callback) {\n  var error\n  var result\n  try {\n    result = JSON.parse(input) }\n  catch (e) {\n    error = e }\n  callback(error, result) }", "language": "javascript", "code": "function parseJSON(input, callback) {\n  var error\n  var result\n  try {\n    result = JSON.parse(input) }\n  catch (e) {\n    error = e }\n  callback(error, result) }", "code_tokens": ["function", "parseJSON", "(", "input", ",", "callback", ")", "{", "var", "error", "var", "result", "try", "{", "result", "=", "JSON", ".", "parse", "(", "input", ")", "}", "catch", "(", "e", ")", "{", "error", "=", "e", "}", "callback", "(", "error", ",", "result", ")", "}"], "docstring": "JSON.parse, wrapped to take an errback.", "docstring_tokens": ["JSON", ".", "parse", "wrapped", "to", "take", "an", "errback", "."], "sha": "b7ff827ba9b0262cfa9fb3f149c27203934eb00a", "url": "https://github.com/commonform-archive/commonform-serve/blob/b7ff827ba9b0262cfa9fb3f149c27203934eb00a/routes/post.js#L100-L107", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(actionName) {\n    var args = [].slice.call(arguments, 1), target;\n\n    if (this._actions && this._actions[actionName]) {\n      if (this._actions[actionName].apply(this, args) === true) {\n        // handler returned true, so this action will bubble\n      } else {\n        return;\n      }\n    } else if (!Ember.FEATURES.isEnabled('ember-routing-drop-deprecated-action-style') && this.deprecatedSend && this.deprecatedSendHandles && this.deprecatedSendHandles(actionName)) {\n      Ember.warn(\"The current default is deprecated but will prefer to handle actions directly on the controller instead of a similarly named action in the actions hash. To turn off this deprecated feature set: Ember.FEATURES['ember-routing-drop-deprecated-action-style'] = true\");\n      if (this.deprecatedSend.apply(this, [].slice.call(arguments)) === true) {\n        // handler return true, so this action will bubble\n      } else {\n        return;\n      }\n    }\n\n    if (target = get(this, 'target')) {\n      Ember.assert(\"The `target` for \" + this + \" (\" + target + \") does not have a `send` method\", typeof target.send === 'function');\n      target.send.apply(target, arguments);\n    }\n  }", "language": "javascript", "code": "function(actionName) {\n    var args = [].slice.call(arguments, 1), target;\n\n    if (this._actions && this._actions[actionName]) {\n      if (this._actions[actionName].apply(this, args) === true) {\n        // handler returned true, so this action will bubble\n      } else {\n        return;\n      }\n    } else if (!Ember.FEATURES.isEnabled('ember-routing-drop-deprecated-action-style') && this.deprecatedSend && this.deprecatedSendHandles && this.deprecatedSendHandles(actionName)) {\n      Ember.warn(\"The current default is deprecated but will prefer to handle actions directly on the controller instead of a similarly named action in the actions hash. To turn off this deprecated feature set: Ember.FEATURES['ember-routing-drop-deprecated-action-style'] = true\");\n      if (this.deprecatedSend.apply(this, [].slice.call(arguments)) === true) {\n        // handler return true, so this action will bubble\n      } else {\n        return;\n      }\n    }\n\n    if (target = get(this, 'target')) {\n      Ember.assert(\"The `target` for \" + this + \" (\" + target + \") does not have a `send` method\", typeof target.send === 'function');\n      target.send.apply(target, arguments);\n    }\n  }", "code_tokens": ["function", "(", "actionName", ")", "{", "var", "args", "=", "[", "]", ".", "slice", ".", "call", "(", "arguments", ",", "1", ")", ",", "target", ";", "if", "(", "this", ".", "_actions", "&&", "this", ".", "_actions", "[", "actionName", "]", ")", "{", "if", "(", "this", ".", "_actions", "[", "actionName", "]", ".", "apply", "(", "this", ",", "args", ")", "===", "true", ")", "{", "// handler returned true, so this action will bubble", "}", "else", "{", "return", ";", "}", "}", "else", "if", "(", "!", "Ember", ".", "FEATURES", ".", "isEnabled", "(", "'ember-routing-drop-deprecated-action-style'", ")", "&&", "this", ".", "deprecatedSend", "&&", "this", ".", "deprecatedSendHandles", "&&", "this", ".", "deprecatedSendHandles", "(", "actionName", ")", ")", "{", "Ember", ".", "warn", "(", "\"The current default is deprecated but will prefer to handle actions directly on the controller instead of a similarly named action in the actions hash. To turn off this deprecated feature set: Ember.FEATURES['ember-routing-drop-deprecated-action-style'] = true\"", ")", ";", "if", "(", "this", ".", "deprecatedSend", ".", "apply", "(", "this", ",", "[", "]", ".", "slice", ".", "call", "(", "arguments", ")", ")", "===", "true", ")", "{", "// handler return true, so this action will bubble", "}", "else", "{", "return", ";", "}", "}", "if", "(", "target", "=", "get", "(", "this", ",", "'target'", ")", ")", "{", "Ember", ".", "assert", "(", "\"The `target` for \"", "+", "this", "+", "\" (\"", "+", "target", "+", "\") does not have a `send` method\"", ",", "typeof", "target", ".", "send", "===", "'function'", ")", ";", "target", ".", "send", ".", "apply", "(", "target", ",", "arguments", ")", ";", "}", "}"], "docstring": "Triggers a named action on the `ActionHandler`. Any parameters\nsupplied after the `actionName` string will be passed as arguments\nto the action target function.\n\nIf the `ActionHandler` has its `target` property set, actions may\nbubble to the `target`. Bubbling happens when an `actionName` can\nnot be found in the `ActionHandler`'s `actions` hash or if the\naction target function returns `true`.\n\nExample\n\n```js\nApp.WelcomeRoute = Ember.Route.extend({\nactions: {\nplayTheme: function() {\nthis.send('playMusic', 'theme.mp3');\n},\nplayMusic: function(track) {\n...\n}\n}\n});\n```\n\n@method send\n@param {String} actionName The action to trigger\n@param {*} context a context to send with the action", "docstring_tokens": ["Triggers", "a", "named", "action", "on", "the", "ActionHandler", ".", "Any", "parameters", "supplied", "after", "the", "actionName", "string", "will", "be", "passed", "as", "arguments", "to", "the", "action", "target", "function", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L18668-L18690", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "clearViewTemplateCache", "original_string": "function clearViewTemplateCache ( view ) {\n        var meta = view.declarativeViews.meta;\n\n        if ( meta.processed ) {\n            if ( meta.inGlobalCache ) _clearCachedTemplate( meta.originalTemplateProp );\n        } else if ( view.template && _.isString( view.template ) ) {\n            _clearCachedTemplate( view.template );\n        }\n    }", "language": "javascript", "code": "function clearViewTemplateCache ( view ) {\n        var meta = view.declarativeViews.meta;\n\n        if ( meta.processed ) {\n            if ( meta.inGlobalCache ) _clearCachedTemplate( meta.originalTemplateProp );\n        } else if ( view.template && _.isString( view.template ) ) {\n            _clearCachedTemplate( view.template );\n        }\n    }", "code_tokens": ["function", "clearViewTemplateCache", "(", "view", ")", "{", "var", "meta", "=", "view", ".", "declarativeViews", ".", "meta", ";", "if", "(", "meta", ".", "processed", ")", "{", "if", "(", "meta", ".", "inGlobalCache", ")", "_clearCachedTemplate", "(", "meta", ".", "originalTemplateProp", ")", ";", "}", "else", "if", "(", "view", ".", "template", "&&", "_", ".", "isString", "(", "view", ".", "template", ")", ")", "{", "_clearCachedTemplate", "(", "view", ".", "template", ")", ";", "}", "}"], "docstring": "Removes the template cache entry associated with a given view, provided that a cache entry exists.\n\n@param {Backbone.View} view", "docstring_tokens": ["Removes", "the", "template", "cache", "entry", "associated", "with", "a", "given", "view", "provided", "that", "a", "cache", "entry", "exists", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L15404-L15412", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/types/duration.js", "func_name": "numberOfLeadingZeros", "original_string": "function numberOfLeadingZeros(value) {\n    if (value.equals(Long.ZERO)) {\n      return 64;\n    }\n    let n = 1;\n    let x = value.getHighBits();\n    if (x === 0) {\n      n += 32;\n      x = value.getLowBits();\n    }\n    if (x >>> 16 === 0) {\n      n += 16;\n      x <<= 16;\n    }\n    if (x >>> 24 === 0) {\n      n += 8;\n      x <<= 8;\n    }\n    if (x >>> 28 === 0) {\n      n += 4;\n      x <<= 4;\n    }\n    if (x >>> 30 === 0) {\n      n += 2;\n      x <<= 2;\n    }\n    n -= x >>> 31;\n    return n;\n  }", "language": "javascript", "code": "function numberOfLeadingZeros(value) {\n    if (value.equals(Long.ZERO)) {\n      return 64;\n    }\n    let n = 1;\n    let x = value.getHighBits();\n    if (x === 0) {\n      n += 32;\n      x = value.getLowBits();\n    }\n    if (x >>> 16 === 0) {\n      n += 16;\n      x <<= 16;\n    }\n    if (x >>> 24 === 0) {\n      n += 8;\n      x <<= 8;\n    }\n    if (x >>> 28 === 0) {\n      n += 4;\n      x <<= 4;\n    }\n    if (x >>> 30 === 0) {\n      n += 2;\n      x <<= 2;\n    }\n    n -= x >>> 31;\n    return n;\n  }", "code_tokens": ["function", "numberOfLeadingZeros", "(", "value", ")", "{", "if", "(", "value", ".", "equals", "(", "Long", ".", "ZERO", ")", ")", "{", "return", "64", ";", "}", "let", "n", "=", "1", ";", "let", "x", "=", "value", ".", "getHighBits", "(", ")", ";", "if", "(", "x", "===", "0", ")", "{", "n", "+=", "32", ";", "x", "=", "value", ".", "getLowBits", "(", ")", ";", "}", "if", "(", "x", ">>>", "16", "===", "0", ")", "{", "n", "+=", "16", ";", "x", "<<=", "16", ";", "}", "if", "(", "x", ">>>", "24", "===", "0", ")", "{", "n", "+=", "8", ";", "x", "<<=", "8", ";", "}", "if", "(", "x", ">>>", "28", "===", "0", ")", "{", "n", "+=", "4", ";", "x", "<<=", "4", ";", "}", "if", "(", "x", ">>>", "30", "===", "0", ")", "{", "n", "+=", "2", ";", "x", "<<=", "2", ";", "}", "n", "-=", "x", ">>>", "31", ";", "return", "n", ";", "}"], "docstring": "Returns the number of zero bits preceding the highest-order one-bit in the binary representation of the value.\n@param {Long} value\n@returns {Number}", "docstring_tokens": ["Returns", "the", "number", "of", "zero", "bits", "preceding", "the", "highest", "-", "order", "one", "-", "bit", "in", "the", "binary", "representation", "of", "the", "value", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/types/duration.js#L579-L607", "partition": "test"}
{"repo": "jahnestacado/logia", "path": "lib/factory.js", "func_name": "", "original_string": "function(event, listener){\n        switch (event) {\n            case \"log\":\n                bus.subscribe(EVENT_BUSLINE, {\n                    onRemoteLogReceived: function(logObj){\n                        listener(logObj);\n                    }\n                });\n                break;\n            default: console.error(\"[LOGIA] Unknown event name: '\" + event + \"'\");\n        }\n    }", "language": "javascript", "code": "function(event, listener){\n        switch (event) {\n            case \"log\":\n                bus.subscribe(EVENT_BUSLINE, {\n                    onRemoteLogReceived: function(logObj){\n                        listener(logObj);\n                    }\n                });\n                break;\n            default: console.error(\"[LOGIA] Unknown event name: '\" + event + \"'\");\n        }\n    }", "code_tokens": ["function", "(", "event", ",", "listener", ")", "{", "switch", "(", "event", ")", "{", "case", "\"log\"", ":", "bus", ".", "subscribe", "(", "EVENT_BUSLINE", ",", "{", "onRemoteLogReceived", ":", "function", "(", "logObj", ")", "{", "listener", "(", "logObj", ")", ";", "}", "}", ")", ";", "break", ";", "default", ":", "console", ".", "error", "(", "\"[LOGIA] Unknown event name: '\"", "+", "event", "+", "\"'\"", ")", ";", "}", "}"], "docstring": "Listens for certain server events.\nCurrently the only supported event is the \"log\" event which is triggered when Logia server receives a log.\n@alias server.on\n@method server.on\n@memberof Logia\n@param {string} event\n@param {function} callback", "docstring_tokens": ["Listens", "for", "certain", "server", "events", ".", "Currently", "the", "only", "supported", "event", "is", "the", "log", "event", "which", "is", "triggered", "when", "Logia", "server", "receives", "a", "log", "."], "sha": "a198aa71adbd45e3ddd1dba4115c0521a265afc5", "url": "https://github.com/jahnestacado/logia/blob/a198aa71adbd45e3ddd1dba4115c0521a265afc5/lib/factory.js#L184-L195", "partition": "test"}
{"repo": "Strider-CD/strider", "path": "lib/plugin-templates.js", "func_name": "engine", "original_string": "function engine(path, options, fn) {\n  options.filename = path;\n\n  fs.readFile(path, 'utf8', function (err, str) {\n    if (err) return fn(err);\n    engine.render(str, options, fn);\n  });\n}", "language": "javascript", "code": "function engine(path, options, fn) {\n  options.filename = path;\n\n  fs.readFile(path, 'utf8', function (err, str) {\n    if (err) return fn(err);\n    engine.render(str, options, fn);\n  });\n}", "code_tokens": ["function", "engine", "(", "path", ",", "options", ",", "fn", ")", "{", "options", ".", "filename", "=", "path", ";", "fs", ".", "readFile", "(", "path", ",", "'utf8'", ",", "function", "(", "err", ",", "str", ")", "{", "if", "(", "err", ")", "return", "fn", "(", "err", ")", ";", "engine", ".", "render", "(", "str", ",", "options", ",", "fn", ")", ";", "}", ")", ";", "}"], "docstring": "Express 3 Template Engine", "docstring_tokens": ["Express", "3", "Template", "Engine"], "sha": "56cafbc9687ebb7b67d485ec387a03cb85791c7c", "url": "https://github.com/Strider-CD/strider/blob/56cafbc9687ebb7b67d485ec387a03cb85791c7c/lib/plugin-templates.js#L47-L54", "partition": "test"}
{"repo": "integreat-io/integreat", "path": "lib/service/authorizeRequest.js", "func_name": "authorizeRequest", "original_string": "function authorizeRequest ({ schemas }) {\n  return ({ request }) => {\n    const { access = {}, params = {}, action } = request\n\n    const { ident = null } = access\n\n    if (ident && ident.root) {\n      return authItemsAndWrap(request, { status: 'granted', ident, scheme: 'root' }, schemas)\n    }\n    if (!params.type) {\n      return authItemsAndWrap(request, { status: 'granted', ident, scheme: null }, schemas)\n    }\n\n    const requireAuth = !!request.auth\n    const schema = schemas[params.type]\n    const scheme = getScheme(schema, action)\n    const status = (doAuth(scheme, ident, requireAuth)) ? 'granted' : 'refused'\n\n    return authItemsAndWrap(request, { status, ident, scheme }, schemas)\n  }\n}", "language": "javascript", "code": "function authorizeRequest ({ schemas }) {\n  return ({ request }) => {\n    const { access = {}, params = {}, action } = request\n\n    const { ident = null } = access\n\n    if (ident && ident.root) {\n      return authItemsAndWrap(request, { status: 'granted', ident, scheme: 'root' }, schemas)\n    }\n    if (!params.type) {\n      return authItemsAndWrap(request, { status: 'granted', ident, scheme: null }, schemas)\n    }\n\n    const requireAuth = !!request.auth\n    const schema = schemas[params.type]\n    const scheme = getScheme(schema, action)\n    const status = (doAuth(scheme, ident, requireAuth)) ? 'granted' : 'refused'\n\n    return authItemsAndWrap(request, { status, ident, scheme }, schemas)\n  }\n}", "code_tokens": ["function", "authorizeRequest", "(", "{", "schemas", "}", ")", "{", "return", "(", "{", "request", "}", ")", "=>", "{", "const", "{", "access", "=", "{", "}", ",", "params", "=", "{", "}", ",", "action", "}", "=", "request", "const", "{", "ident", "=", "null", "}", "=", "access", "if", "(", "ident", "&&", "ident", ".", "root", ")", "{", "return", "authItemsAndWrap", "(", "request", ",", "{", "status", ":", "'granted'", ",", "ident", ",", "scheme", ":", "'root'", "}", ",", "schemas", ")", "}", "if", "(", "!", "params", ".", "type", ")", "{", "return", "authItemsAndWrap", "(", "request", ",", "{", "status", ":", "'granted'", ",", "ident", ",", "scheme", ":", "null", "}", ",", "schemas", ")", "}", "const", "requireAuth", "=", "!", "!", "request", ".", "auth", "const", "schema", "=", "schemas", "[", "params", ".", "type", "]", "const", "scheme", "=", "getScheme", "(", "schema", ",", "action", ")", "const", "status", "=", "(", "doAuth", "(", "scheme", ",", "ident", ",", "requireAuth", ")", ")", "?", "'granted'", ":", "'refused'", "return", "authItemsAndWrap", "(", "request", ",", "{", "status", ",", "ident", ",", "scheme", "}", ",", "schemas", ")", "}", "}"], "docstring": "Authorize the request according to the setting on the relevant schema.\nSets the access object with `status` property specifying whether access\nis `granted` or `refused`, and returns the request.\n\nThe access object also includes the `ident` and the  `scheme`used for\nauthentication.\n\n@param {Object} request - The request object to authorize\n@param {Object} schemas - An object with all schemas that may be needed\n@returns {Object} The request object with updated access object", "docstring_tokens": ["Authorize", "the", "request", "according", "to", "the", "setting", "on", "the", "relevant", "schema", ".", "Sets", "the", "access", "object", "with", "status", "property", "specifying", "whether", "access", "is", "granted", "or", "refused", "and", "returns", "the", "request", "."], "sha": "b3092036bfd40d74a082297cace1f678502427c6", "url": "https://github.com/integreat-io/integreat/blob/b3092036bfd40d74a082297cace1f678502427c6/lib/service/authorizeRequest.js#L33-L53", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      if (this.collection) {\n        this.listenTo(this.collection, 'add', this._onCollectionAdd);\n        this.listenTo(this.collection, 'remove', this._onCollectionRemove);\n        this.listenTo(this.collection, 'reset', this.render);\n  \n        if (this.getOption('sort')) {\n          this.listenTo(this.collection, 'sort', this._sortViews);\n        }\n      }\n    }", "language": "javascript", "code": "function() {\n      if (this.collection) {\n        this.listenTo(this.collection, 'add', this._onCollectionAdd);\n        this.listenTo(this.collection, 'remove', this._onCollectionRemove);\n        this.listenTo(this.collection, 'reset', this.render);\n  \n        if (this.getOption('sort')) {\n          this.listenTo(this.collection, 'sort', this._sortViews);\n        }\n      }\n    }", "code_tokens": ["function", "(", ")", "{", "if", "(", "this", ".", "collection", ")", "{", "this", ".", "listenTo", "(", "this", ".", "collection", ",", "'add'", ",", "this", ".", "_onCollectionAdd", ")", ";", "this", ".", "listenTo", "(", "this", ".", "collection", ",", "'remove'", ",", "this", ".", "_onCollectionRemove", ")", ";", "this", ".", "listenTo", "(", "this", ".", "collection", ",", "'reset'", ",", "this", ".", "render", ")", ";", "if", "(", "this", ".", "getOption", "(", "'sort'", ")", ")", "{", "this", ".", "listenTo", "(", "this", ".", "collection", ",", "'sort'", ",", "this", ".", "_sortViews", ")", ";", "}", "}", "}"], "docstring": "Configured the initial events that the collection view binds to.", "docstring_tokens": ["Configured", "the", "initial", "events", "that", "the", "collection", "view", "binds", "to", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18320-L18330", "partition": "test"}
{"repo": "westoque/gauges-node", "path": "docs/jsdoc/templates/codeview/javascript/all.js", "func_name": "getWindowWidth", "original_string": "function getWindowWidth() {\r\n\t\tif (window.innerWidth) {\r\n\t\t\treturn window.innerWidth;\r\n\t\t} else if (document.documentElement.clientWidth) {\r\n\t\t\treturn document.documentElement.clientWidth;\r\n\t\t} else if (document.body.clientWidth) {\r\n\t\t\treturn document.body.clientWidth;\r\n\t\t} else{\r\n\t\t\treturn 0;\t\r\n\t\t}\r\n\t}", "language": "javascript", "code": "function getWindowWidth() {\r\n\t\tif (window.innerWidth) {\r\n\t\t\treturn window.innerWidth;\r\n\t\t} else if (document.documentElement.clientWidth) {\r\n\t\t\treturn document.documentElement.clientWidth;\r\n\t\t} else if (document.body.clientWidth) {\r\n\t\t\treturn document.body.clientWidth;\r\n\t\t} else{\r\n\t\t\treturn 0;\t\r\n\t\t}\r\n\t}", "code_tokens": ["function", "getWindowWidth", "(", ")", "{", "if", "(", "window", ".", "innerWidth", ")", "{", "return", "window", ".", "innerWidth", ";", "}", "else", "if", "(", "document", ".", "documentElement", ".", "clientWidth", ")", "{", "return", "document", ".", "documentElement", ".", "clientWidth", ";", "}", "else", "if", "(", "document", ".", "body", ".", "clientWidth", ")", "{", "return", "document", ".", "body", ".", "clientWidth", ";", "}", "else", "{", "return", "0", ";", "}", "}"], "docstring": "Get the the inner width of the browser window", "docstring_tokens": ["Get", "the", "the", "inner", "width", "of", "the", "browser", "window"], "sha": "4dfc962cc58fb03d97e0137d89703e321d4f8ec3", "url": "https://github.com/westoque/gauges-node/blob/4dfc962cc58fb03d97e0137d89703e321d4f8ec3/docs/jsdoc/templates/codeview/javascript/all.js#L61-L71", "partition": "test"}
{"repo": "bvellacott/sforce-mocks", "path": "mocks.js", "func_name": "", "original_string": "function(typeName, obj) {\n\t\tthis.type = typeName;\n\t\tif(typeof obj !== 'undefined')\n\t\t\tfor(var key in obj) \n\t\t\t\tthis[key] = obj[key];\n\t}", "language": "javascript", "code": "function(typeName, obj) {\n\t\tthis.type = typeName;\n\t\tif(typeof obj !== 'undefined')\n\t\t\tfor(var key in obj) \n\t\t\t\tthis[key] = obj[key];\n\t}", "code_tokens": ["function", "(", "typeName", ",", "obj", ")", "{", "this", ".", "type", "=", "typeName", ";", "if", "(", "typeof", "obj", "!==", "'undefined'", ")", "for", "(", "var", "key", "in", "obj", ")", "this", "[", "key", "]", "=", "obj", "[", "key", "]", ";", "}"], "docstring": "A mock of the salesforce SObject object", "docstring_tokens": ["A", "mock", "of", "the", "salesforce", "SObject", "object"], "sha": "d49129d81cb41a820621a4cf38766f0e85db7f43", "url": "https://github.com/bvellacott/sforce-mocks/blob/d49129d81cb41a820621a4cf38766f0e85db7f43/mocks.js#L53-L58", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Module.js", "func_name": "_multiModuleStop", "original_string": "function _multiModuleStop(oModule) {\n  iterateObject(oModule.instances, function (oInstance) {\n    if (!isTypeOf(oModule, sNotDefined) && !isTypeOf(oInstance, sNotDefined)) {\n      oInstance.destroy();\n    }\n  });\n  oModule.instances = {};\n}", "language": "javascript", "code": "function _multiModuleStop(oModule) {\n  iterateObject(oModule.instances, function (oInstance) {\n    if (!isTypeOf(oModule, sNotDefined) && !isTypeOf(oInstance, sNotDefined)) {\n      oInstance.destroy();\n    }\n  });\n  oModule.instances = {};\n}", "code_tokens": ["function", "_multiModuleStop", "(", "oModule", ")", "{", "iterateObject", "(", "oModule", ".", "instances", ",", "function", "(", "oInstance", ")", "{", "if", "(", "!", "isTypeOf", "(", "oModule", ",", "sNotDefined", ")", "&&", "!", "isTypeOf", "(", "oInstance", ",", "sNotDefined", ")", ")", "{", "oInstance", ".", "destroy", "(", ")", ";", "}", "}", ")", ";", "oModule", ".", "instances", "=", "{", "}", ";", "}"], "docstring": "stop more than one module at the same time.\n@param {Object} oModule\n@private", "docstring_tokens": ["stop", "more", "than", "one", "module", "at", "the", "same", "time", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Module.js#L502-L509", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(views, start, removed, added) {\n    if (added > 0) {\n      var changedViews = views.slice(start, start+added);\n      this.initializeViews(changedViews, this, get(this, 'templateData'));\n      this.currentState.childViewsDidChange(this, views, start, added);\n    }\n    this.propertyDidChange('childViews');\n  }", "language": "javascript", "code": "function(views, start, removed, added) {\n    if (added > 0) {\n      var changedViews = views.slice(start, start+added);\n      this.initializeViews(changedViews, this, get(this, 'templateData'));\n      this.currentState.childViewsDidChange(this, views, start, added);\n    }\n    this.propertyDidChange('childViews');\n  }", "code_tokens": ["function", "(", "views", ",", "start", ",", "removed", ",", "added", ")", "{", "if", "(", "added", ">", "0", ")", "{", "var", "changedViews", "=", "views", ".", "slice", "(", "start", ",", "start", "+", "added", ")", ";", "this", ".", "initializeViews", "(", "changedViews", ",", "this", ",", "get", "(", "this", ",", "'templateData'", ")", ")", ";", "this", ".", "currentState", ".", "childViewsDidChange", "(", "this", ",", "views", ",", "start", ",", "added", ")", ";", "}", "this", ".", "propertyDidChange", "(", "'childViews'", ")", ";", "}"], "docstring": "When a child view is added, make sure the DOM gets updated appropriately.\n\nIf the view has already rendered an element, we tell the child view to\ncreate an element and insert it into the DOM. If the enclosing container\nview has already written to a buffer, but not yet converted that buffer\ninto an element, we insert the string representation of the child into the\nappropriate place in the buffer.\n\n@private\n@method childViewsDidChange\n@param {Ember.Array} views the array of child views afte the mutation has occurred\n@param {Number} start the start position of the mutation\n@param {Number} removed the number of child views removed\n@param {Number} the number of child views added", "docstring_tokens": ["When", "a", "child", "view", "is", "added", "make", "sure", "the", "DOM", "gets", "updated", "appropriately", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L25546-L25553", "partition": "test"}
{"repo": "yahoo/locator", "path": "lib/bundleLocator.js", "func_name": "", "original_string": "function (fullPath) {\n        var bundleName,\n            bundle,\n            ruleset,\n            relativePath,\n            pathParts,\n            subBundleSeed,\n            res;\n\n        bundleName = this._getBundleNameByPath(fullPath);\n        bundle = this._bundles[bundleName];\n        if (bundle.baseDirectory === fullPath.substr(0, bundle.baseDirectory.length)) {\n            relativePath = fullPath.substr(bundle.baseDirectory.length + 1);\n        }\n\n        // This mainly happens during watch(), since we skip node_modules\n        // in _walkBundle().\n        if (relativePath.indexOf('node_modules') === 0) {\n            pathParts = relativePath.split(libpath.sep);\n            while (pathParts[0] === 'node_modules' && pathParts.length >= 2) {\n                pathParts.shift();\n                bundleName = pathParts.shift();\n            }\n            relativePath = pathParts.join(libpath.sep);\n            bundle = this._bundles[bundleName];\n\n            // The package's directory is not a resource (... and is mostly uninteresting).\n            if (!relativePath) {\n                return;\n            }\n\n            // unknown bundle\n            if (!bundle) {\n                return;\n            }\n        }\n\n        ruleset = this._loadRuleset(bundle);\n        if (ruleset._skip && this._ruleSkip(fullPath, relativePath, ruleset._skip)) {\n            return;\n        }\n        if (ruleset._bundles) {\n            subBundleSeed = this._ruleBundles(fullPath, relativePath, ruleset._bundles, bundle);\n            if (subBundleSeed) {\n                // sub-bundle inherits options.rulesets from parent\n                if (!subBundleSeed.options) {\n                    subBundleSeed.options = {};\n                }\n                if (!subBundleSeed.options.rulesets) {\n                    subBundleSeed.options.rulesets = bundle.options.rulesets;\n                }\n                this._makeBundle(subBundleSeed, bundle);\n                return;\n            }\n        }\n\n        // This is the base \"meta\" for a file.  If a rule matches we'll\n        // augment this.\n        res = {\n            bundleName: bundleName,\n            fullPath: fullPath,\n            relativePath: relativePath,\n            ext: libpath.extname(fullPath).substr(1)\n        };\n\n        this._onFile(res, ruleset);\n    }", "language": "javascript", "code": "function (fullPath) {\n        var bundleName,\n            bundle,\n            ruleset,\n            relativePath,\n            pathParts,\n            subBundleSeed,\n            res;\n\n        bundleName = this._getBundleNameByPath(fullPath);\n        bundle = this._bundles[bundleName];\n        if (bundle.baseDirectory === fullPath.substr(0, bundle.baseDirectory.length)) {\n            relativePath = fullPath.substr(bundle.baseDirectory.length + 1);\n        }\n\n        // This mainly happens during watch(), since we skip node_modules\n        // in _walkBundle().\n        if (relativePath.indexOf('node_modules') === 0) {\n            pathParts = relativePath.split(libpath.sep);\n            while (pathParts[0] === 'node_modules' && pathParts.length >= 2) {\n                pathParts.shift();\n                bundleName = pathParts.shift();\n            }\n            relativePath = pathParts.join(libpath.sep);\n            bundle = this._bundles[bundleName];\n\n            // The package's directory is not a resource (... and is mostly uninteresting).\n            if (!relativePath) {\n                return;\n            }\n\n            // unknown bundle\n            if (!bundle) {\n                return;\n            }\n        }\n\n        ruleset = this._loadRuleset(bundle);\n        if (ruleset._skip && this._ruleSkip(fullPath, relativePath, ruleset._skip)) {\n            return;\n        }\n        if (ruleset._bundles) {\n            subBundleSeed = this._ruleBundles(fullPath, relativePath, ruleset._bundles, bundle);\n            if (subBundleSeed) {\n                // sub-bundle inherits options.rulesets from parent\n                if (!subBundleSeed.options) {\n                    subBundleSeed.options = {};\n                }\n                if (!subBundleSeed.options.rulesets) {\n                    subBundleSeed.options.rulesets = bundle.options.rulesets;\n                }\n                this._makeBundle(subBundleSeed, bundle);\n                return;\n            }\n        }\n\n        // This is the base \"meta\" for a file.  If a rule matches we'll\n        // augment this.\n        res = {\n            bundleName: bundleName,\n            fullPath: fullPath,\n            relativePath: relativePath,\n            ext: libpath.extname(fullPath).substr(1)\n        };\n\n        this._onFile(res, ruleset);\n    }", "code_tokens": ["function", "(", "fullPath", ")", "{", "var", "bundleName", ",", "bundle", ",", "ruleset", ",", "relativePath", ",", "pathParts", ",", "subBundleSeed", ",", "res", ";", "bundleName", "=", "this", ".", "_getBundleNameByPath", "(", "fullPath", ")", ";", "bundle", "=", "this", ".", "_bundles", "[", "bundleName", "]", ";", "if", "(", "bundle", ".", "baseDirectory", "===", "fullPath", ".", "substr", "(", "0", ",", "bundle", ".", "baseDirectory", ".", "length", ")", ")", "{", "relativePath", "=", "fullPath", ".", "substr", "(", "bundle", ".", "baseDirectory", ".", "length", "+", "1", ")", ";", "}", "// This mainly happens during watch(), since we skip node_modules", "// in _walkBundle().", "if", "(", "relativePath", ".", "indexOf", "(", "'node_modules'", ")", "===", "0", ")", "{", "pathParts", "=", "relativePath", ".", "split", "(", "libpath", ".", "sep", ")", ";", "while", "(", "pathParts", "[", "0", "]", "===", "'node_modules'", "&&", "pathParts", ".", "length", ">=", "2", ")", "{", "pathParts", ".", "shift", "(", ")", ";", "bundleName", "=", "pathParts", ".", "shift", "(", ")", ";", "}", "relativePath", "=", "pathParts", ".", "join", "(", "libpath", ".", "sep", ")", ";", "bundle", "=", "this", ".", "_bundles", "[", "bundleName", "]", ";", "// The package's directory is not a resource (... and is mostly uninteresting).", "if", "(", "!", "relativePath", ")", "{", "return", ";", "}", "// unknown bundle", "if", "(", "!", "bundle", ")", "{", "return", ";", "}", "}", "ruleset", "=", "this", ".", "_loadRuleset", "(", "bundle", ")", ";", "if", "(", "ruleset", ".", "_skip", "&&", "this", ".", "_ruleSkip", "(", "fullPath", ",", "relativePath", ",", "ruleset", ".", "_skip", ")", ")", "{", "return", ";", "}", "if", "(", "ruleset", ".", "_bundles", ")", "{", "subBundleSeed", "=", "this", ".", "_ruleBundles", "(", "fullPath", ",", "relativePath", ",", "ruleset", ".", "_bundles", ",", "bundle", ")", ";", "if", "(", "subBundleSeed", ")", "{", "// sub-bundle inherits options.rulesets from parent", "if", "(", "!", "subBundleSeed", ".", "options", ")", "{", "subBundleSeed", ".", "options", "=", "{", "}", ";", "}", "if", "(", "!", "subBundleSeed", ".", "options", ".", "rulesets", ")", "{", "subBundleSeed", ".", "options", ".", "rulesets", "=", "bundle", ".", "options", ".", "rulesets", ";", "}", "this", ".", "_makeBundle", "(", "subBundleSeed", ",", "bundle", ")", ";", "return", ";", "}", "}", "// This is the base \"meta\" for a file.  If a rule matches we'll", "// augment this.", "res", "=", "{", "bundleName", ":", "bundleName", ",", "fullPath", ":", "fullPath", ",", "relativePath", ":", "relativePath", ",", "ext", ":", "libpath", ".", "extname", "(", "fullPath", ")", ".", "substr", "(", "1", ")", "}", ";", "this", ".", "_onFile", "(", "res", ",", "ruleset", ")", ";", "}"], "docstring": "Turns the path into a resource in the associated bundle, if applicable.\n@private\n@method _processFile\n@param {string} fullPath the path to the file to be processed", "docstring_tokens": ["Turns", "the", "path", "into", "a", "resource", "in", "the", "associated", "bundle", "if", "applicable", "."], "sha": "563e6d453556dd776572761bd8e002e6e1ac64b6", "url": "https://github.com/yahoo/locator/blob/563e6d453556dd776572761bd8e002e6e1ac64b6/lib/bundleLocator.js#L372-L438", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/SegmentedButton.js", "func_name": "", "original_string": "function(newButtons, oldButtons) {\n        var me    = this,\n            items = me.getItems(),\n            pressedCls = me.getPressedCls(),\n            events = [],\n            item, button, ln, i, e;\n\n        //loop through existing items and remove the pressed cls from them\n        ln = items.length;\n        if (oldButtons && oldButtons.length) {\n            for (i = 0; i < ln; i++) {\n                item = items.items[i];\n\n                if (oldButtons.indexOf(item) != -1 && newButtons.indexOf(item) == -1) {\n                    item.removeCls([pressedCls, item.getPressedCls()]);\n                    events.push({\n                        item: item,\n                        toggle: false\n                    });\n                }\n            }\n        }\n\n        //loop through the new pressed buttons and add the pressed cls to them\n        ln = newButtons.length;\n        for (i = 0; i < ln; i++) {\n            button = newButtons[i];\n            if (!oldButtons || oldButtons.indexOf(button) == -1) {\n                button.addCls(pressedCls);\n                events.push({\n                    item: button,\n                    toggle: true\n                });\n            }\n        }\n\n        //loop through each of the events and fire them after a delay\n        ln = events.length;\n        if (ln && oldButtons !== undefined) {\n            Ext.defer(function() {\n                for (i = 0; i < ln; i++) {\n                    e = events[i];\n                    me.fireEvent('toggle', me, e.item, e.toggle);\n                }\n            }, 50);\n        }\n    }", "language": "javascript", "code": "function(newButtons, oldButtons) {\n        var me    = this,\n            items = me.getItems(),\n            pressedCls = me.getPressedCls(),\n            events = [],\n            item, button, ln, i, e;\n\n        //loop through existing items and remove the pressed cls from them\n        ln = items.length;\n        if (oldButtons && oldButtons.length) {\n            for (i = 0; i < ln; i++) {\n                item = items.items[i];\n\n                if (oldButtons.indexOf(item) != -1 && newButtons.indexOf(item) == -1) {\n                    item.removeCls([pressedCls, item.getPressedCls()]);\n                    events.push({\n                        item: item,\n                        toggle: false\n                    });\n                }\n            }\n        }\n\n        //loop through the new pressed buttons and add the pressed cls to them\n        ln = newButtons.length;\n        for (i = 0; i < ln; i++) {\n            button = newButtons[i];\n            if (!oldButtons || oldButtons.indexOf(button) == -1) {\n                button.addCls(pressedCls);\n                events.push({\n                    item: button,\n                    toggle: true\n                });\n            }\n        }\n\n        //loop through each of the events and fire them after a delay\n        ln = events.length;\n        if (ln && oldButtons !== undefined) {\n            Ext.defer(function() {\n                for (i = 0; i < ln; i++) {\n                    e = events[i];\n                    me.fireEvent('toggle', me, e.item, e.toggle);\n                }\n            }, 50);\n        }\n    }", "code_tokens": ["function", "(", "newButtons", ",", "oldButtons", ")", "{", "var", "me", "=", "this", ",", "items", "=", "me", ".", "getItems", "(", ")", ",", "pressedCls", "=", "me", ".", "getPressedCls", "(", ")", ",", "events", "=", "[", "]", ",", "item", ",", "button", ",", "ln", ",", "i", ",", "e", ";", "//loop through existing items and remove the pressed cls from them", "ln", "=", "items", ".", "length", ";", "if", "(", "oldButtons", "&&", "oldButtons", ".", "length", ")", "{", "for", "(", "i", "=", "0", ";", "i", "<", "ln", ";", "i", "++", ")", "{", "item", "=", "items", ".", "items", "[", "i", "]", ";", "if", "(", "oldButtons", ".", "indexOf", "(", "item", ")", "!=", "-", "1", "&&", "newButtons", ".", "indexOf", "(", "item", ")", "==", "-", "1", ")", "{", "item", ".", "removeCls", "(", "[", "pressedCls", ",", "item", ".", "getPressedCls", "(", ")", "]", ")", ";", "events", ".", "push", "(", "{", "item", ":", "item", ",", "toggle", ":", "false", "}", ")", ";", "}", "}", "}", "//loop through the new pressed buttons and add the pressed cls to them", "ln", "=", "newButtons", ".", "length", ";", "for", "(", "i", "=", "0", ";", "i", "<", "ln", ";", "i", "++", ")", "{", "button", "=", "newButtons", "[", "i", "]", ";", "if", "(", "!", "oldButtons", "||", "oldButtons", ".", "indexOf", "(", "button", ")", "==", "-", "1", ")", "{", "button", ".", "addCls", "(", "pressedCls", ")", ";", "events", ".", "push", "(", "{", "item", ":", "button", ",", "toggle", ":", "true", "}", ")", ";", "}", "}", "//loop through each of the events and fire them after a delay", "ln", "=", "events", ".", "length", ";", "if", "(", "ln", "&&", "oldButtons", "!==", "undefined", ")", "{", "Ext", ".", "defer", "(", "function", "(", ")", "{", "for", "(", "i", "=", "0", ";", "i", "<", "ln", ";", "i", "++", ")", "{", "e", "=", "events", "[", "i", "]", ";", "me", ".", "fireEvent", "(", "'toggle'", ",", "me", ",", "e", ".", "item", ",", "e", ".", "toggle", ")", ";", "}", "}", ",", "50", ")", ";", "}", "}"], "docstring": "Updates the pressed buttons.\n@private", "docstring_tokens": ["Updates", "the", "pressed", "buttons", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/SegmentedButton.js#L268-L314", "partition": "test"}
{"repo": "StarryInternet/eslint-plugin-starry", "path": "lib/rules/space-in-parens.js", "func_name": "shouldCloserRejectSpace", "original_string": "function shouldCloserRejectSpace( left, right ) {\n      if ( astUtils.isOpeningParenToken( left ) ) {\n        return false;\n      }\n\n      if ( !astUtils.isTokenOnSameLine( left, right ) ) {\n        return false;\n      }\n\n      if ( !sourceCode.isSpaceBetweenTokens( left, right ) ) {\n        return false;\n      }\n\n      if ( ALWAYS ) {\n        return isCloserException( left );\n      }\n      return !isCloserException( left );\n    }", "language": "javascript", "code": "function shouldCloserRejectSpace( left, right ) {\n      if ( astUtils.isOpeningParenToken( left ) ) {\n        return false;\n      }\n\n      if ( !astUtils.isTokenOnSameLine( left, right ) ) {\n        return false;\n      }\n\n      if ( !sourceCode.isSpaceBetweenTokens( left, right ) ) {\n        return false;\n      }\n\n      if ( ALWAYS ) {\n        return isCloserException( left );\n      }\n      return !isCloserException( left );\n    }", "code_tokens": ["function", "shouldCloserRejectSpace", "(", "left", ",", "right", ")", "{", "if", "(", "astUtils", ".", "isOpeningParenToken", "(", "left", ")", ")", "{", "return", "false", ";", "}", "if", "(", "!", "astUtils", ".", "isTokenOnSameLine", "(", "left", ",", "right", ")", ")", "{", "return", "false", ";", "}", "if", "(", "!", "sourceCode", ".", "isSpaceBetweenTokens", "(", "left", ",", "right", ")", ")", "{", "return", "false", ";", "}", "if", "(", "ALWAYS", ")", "{", "return", "isCloserException", "(", "left", ")", ";", "}", "return", "!", "isCloserException", "(", "left", ")", ";", "}"], "docstring": "Determines if an closer paren should not have an existing space after it\n@param {Object} left The token before the paren\n@param {Object} right The paren token\n@returns {boolean} True if the paren should reject the space", "docstring_tokens": ["Determines", "if", "an", "closer", "paren", "should", "not", "have", "an", "existing", "space", "after", "it"], "sha": "6b0a55c4d0263c549e88f80001b8cca417fca5ca", "url": "https://github.com/StarryInternet/eslint-plugin-starry/blob/6b0a55c4d0263c549e88f80001b8cca417fca5ca/lib/rules/space-in-parens.js#L195-L212", "partition": "test"}
{"repo": "developmentseed/kes", "path": "src/utils.js", "func_name": "failure", "original_string": "function failure(e) {\n  if (e.message) {\n    console.log(e.message);\n  }\n  else {\n    console.log(e);\n  }\n  process.exit(1);\n}", "language": "javascript", "code": "function failure(e) {\n  if (e.message) {\n    console.log(e.message);\n  }\n  else {\n    console.log(e);\n  }\n  process.exit(1);\n}", "code_tokens": ["function", "failure", "(", "e", ")", "{", "if", "(", "e", ".", "message", ")", "{", "console", ".", "log", "(", "e", ".", "message", ")", ";", "}", "else", "{", "console", ".", "log", "(", "e", ")", ";", "}", "process", ".", "exit", "(", "1", ")", ";", "}"], "docstring": "In case of error logs the error and exit with error 1\n@param {Error} e error object", "docstring_tokens": ["In", "case", "of", "error", "logs", "the", "error", "and", "exit", "with", "error", "1"], "sha": "c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6", "url": "https://github.com/developmentseed/kes/blob/c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6/src/utils.js#L249-L257", "partition": "test"}
{"repo": "shystruk/famulus", "path": "dateDifference.js", "func_name": "dateDifference", "original_string": "function dateDifference(date1, date2, differenceType) {\n    var diffMilliseconds = Math.abs(date1 - date2);\n\n    switch(differenceType) {\n        case 'days':\n            return dates._getDaysDiff(diffMilliseconds);\n        case 'hours':\n            return dates._differenceInHours(diffMilliseconds);\n        case 'minutes':\n            return dates._differenceInMinutes(diffMilliseconds);\n        case 'milliseconds':\n            return diffMilliseconds;\n\n        default:\n            return {\n                days: dates._getDaysDiff(diffMilliseconds),\n                hours: dates._getHoursDiff(diffMilliseconds),\n                minutes: dates._getMinutesDiff(diffMilliseconds),\n                milliseconds: diffMilliseconds\n            }\n    }\n}", "language": "javascript", "code": "function dateDifference(date1, date2, differenceType) {\n    var diffMilliseconds = Math.abs(date1 - date2);\n\n    switch(differenceType) {\n        case 'days':\n            return dates._getDaysDiff(diffMilliseconds);\n        case 'hours':\n            return dates._differenceInHours(diffMilliseconds);\n        case 'minutes':\n            return dates._differenceInMinutes(diffMilliseconds);\n        case 'milliseconds':\n            return diffMilliseconds;\n\n        default:\n            return {\n                days: dates._getDaysDiff(diffMilliseconds),\n                hours: dates._getHoursDiff(diffMilliseconds),\n                minutes: dates._getMinutesDiff(diffMilliseconds),\n                milliseconds: diffMilliseconds\n            }\n    }\n}", "code_tokens": ["function", "dateDifference", "(", "date1", ",", "date2", ",", "differenceType", ")", "{", "var", "diffMilliseconds", "=", "Math", ".", "abs", "(", "date1", "-", "date2", ")", ";", "switch", "(", "differenceType", ")", "{", "case", "'days'", ":", "return", "dates", ".", "_getDaysDiff", "(", "diffMilliseconds", ")", ";", "case", "'hours'", ":", "return", "dates", ".", "_differenceInHours", "(", "diffMilliseconds", ")", ";", "case", "'minutes'", ":", "return", "dates", ".", "_differenceInMinutes", "(", "diffMilliseconds", ")", ";", "case", "'milliseconds'", ":", "return", "diffMilliseconds", ";", "default", ":", "return", "{", "days", ":", "dates", ".", "_getDaysDiff", "(", "diffMilliseconds", ")", ",", "hours", ":", "dates", ".", "_getHoursDiff", "(", "diffMilliseconds", ")", ",", "minutes", ":", "dates", ".", "_getMinutesDiff", "(", "diffMilliseconds", ")", ",", "milliseconds", ":", "diffMilliseconds", "}", "}", "}"], "docstring": "Difference between dates which are passed, in formats 'milliseconds', 'days', 'hours', 'minutes'\n\n@customNeeds -\n\n@since 2.0.0\n@category Date\n\n@param {Date} date1 - The Date for compare\n@param {Date} date2 - The Date for compare\n@param {String} differenceType - [ 'days', 'hours', 'minutes', 'milliseconds', 'all' ]\n\n@returns {Number|Object} Returns the numeric value or object depends on passed differenceType param\n\n@example\n\nfamulus.dateDifference(new Date('06-20-2018'), new Date('06-26-2018'), 'days')\n// => 6\n\nfamulus.dateDifference(new Date('06-20-2018'), new Date('06-26-2018'), 'hours')\n// => 144\n\nfamulus.dateDifference(new Date('06-20-2018'), new Date('06-26-2018'), 'minutes')\n// => 8640\n\nfamulus.dateDifference(new Date('06-26-2018'), new Date('06-20-2018'), 'milliseconds')\n// => 518400000\n\nfamulus.dateDifference(new Date('06-26-2018 10:10'), new Date('06-20-2018 08:00'), 'all')\n// => {days: 6, hours: 2, minutes: 10, milliseconds: 526200000}", "docstring_tokens": ["Difference", "between", "dates", "which", "are", "passed", "in", "formats", "milliseconds", "days", "hours", "minutes"], "sha": "6b97c007f85b71c36b4981fa94c34ebbdb44837a", "url": "https://github.com/shystruk/famulus/blob/6b97c007f85b71c36b4981fa94c34ebbdb44837a/dateDifference.js#L34-L55", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/async/index.js", "func_name": "remove", "original_string": "function remove (outputFile, done) {\n    this.csFactory(function (_done) {\n      this._remove(outputFile, done);\n      _done();\n    }.bind(this), L_WAIT)();\n  }", "language": "javascript", "code": "function remove (outputFile, done) {\n    this.csFactory(function (_done) {\n      this._remove(outputFile, done);\n      _done();\n    }.bind(this), L_WAIT)();\n  }", "code_tokens": ["function", "remove", "(", "outputFile", ",", "done", ")", "{", "this", ".", "csFactory", "(", "function", "(", "_done", ")", "{", "this", ".", "_remove", "(", "outputFile", ",", "done", ")", ";", "_done", "(", ")", ";", "}", ".", "bind", "(", "this", ")", ",", "L_WAIT", ")", "(", ")", ";", "}"], "docstring": "Remove a file from the files array if it's there.\nProtected version.\n\n@param {String} outputFile - The outputFile to remove.\n@param {Boolean} done - If true, add to filesDone collection.", "docstring_tokens": ["Remove", "a", "file", "from", "the", "files", "array", "if", "it", "s", "there", ".", "Protected", "version", "."], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/async/index.js#L300-L305", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(root) {\n    var camelized = Ember.String.camelize(root);\n    return Ember.String.singularize(camelized);\n  }", "language": "javascript", "code": "function(root) {\n    var camelized = Ember.String.camelize(root);\n    return Ember.String.singularize(camelized);\n  }", "code_tokens": ["function", "(", "root", ")", "{", "var", "camelized", "=", "Ember", ".", "String", ".", "camelize", "(", "root", ")", ";", "return", "Ember", ".", "String", ".", "singularize", "(", "camelized", ")", ";", "}"], "docstring": "EXTRACT \nExtracts the model typeKey from underscored root objects.\n\n@method typeForRoot\n@param {String} root\n@returns String the model's typeKey", "docstring_tokens": ["EXTRACT", "Extracts", "the", "model", "typeKey", "from", "underscored", "root", "objects", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L10156-L10159", "partition": "test"}
{"repo": "young-steveo/bottlejs", "path": "dist/bottle.js", "func_name": "defineValue", "original_string": "function defineValue(name, val) {\n        Object.defineProperty(this, name, {\n            configurable : true,\n            enumerable : true,\n            value : val,\n            writable : true\n        });\n    }", "language": "javascript", "code": "function defineValue(name, val) {\n        Object.defineProperty(this, name, {\n            configurable : true,\n            enumerable : true,\n            value : val,\n            writable : true\n        });\n    }", "code_tokens": ["function", "defineValue", "(", "name", ",", "val", ")", "{", "Object", ".", "defineProperty", "(", "this", ",", "name", ",", "{", "configurable", ":", "true", ",", "enumerable", ":", "true", ",", "value", ":", "val", ",", "writable", ":", "true", "}", ")", ";", "}"], "docstring": "Define a mutable property on the container.\n\n@param String name\n@param mixed val\n@return void\n@scope container", "docstring_tokens": ["Define", "a", "mutable", "property", "on", "the", "container", "."], "sha": "2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51", "url": "https://github.com/young-steveo/bottlejs/blob/2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51/dist/bottle.js#L305-L312", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Utils.js", "func_name": "isEvent", "original_string": "function isEvent(oObj) {\n  try {\n    return isInstanceOf(oObj, Event);\n  } catch (erError) {\n    // Duck typing detection (If it sounds like a duck and it moves like a duck, it's a duck)\n    if (oObj.altKey !== und && ( oObj.srcElement || oObj.target )) {\n      return true;\n    }\n  }\n  return false;\n}", "language": "javascript", "code": "function isEvent(oObj) {\n  try {\n    return isInstanceOf(oObj, Event);\n  } catch (erError) {\n    // Duck typing detection (If it sounds like a duck and it moves like a duck, it's a duck)\n    if (oObj.altKey !== und && ( oObj.srcElement || oObj.target )) {\n      return true;\n    }\n  }\n  return false;\n}", "code_tokens": ["function", "isEvent", "(", "oObj", ")", "{", "try", "{", "return", "isInstanceOf", "(", "oObj", ",", "Event", ")", ";", "}", "catch", "(", "erError", ")", "{", "// Duck typing detection (If it sounds like a duck and it moves like a duck, it's a duck)", "if", "(", "oObj", ".", "altKey", "!==", "und", "&&", "(", "oObj", ".", "srcElement", "||", "oObj", ".", "target", ")", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "Use Event detection and if it fails it degrades to use duck typing detection to\ntest if the supplied object is an Event\n@param {Object} oObj\n@return {Boolean}\n@private", "docstring_tokens": ["Use", "Event", "detection", "and", "if", "it", "fails", "it", "degrades", "to", "use", "duck", "typing", "detection", "to", "test", "if", "the", "supplied", "object", "is", "an", "Event"], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Utils.js#L31-L41", "partition": "test"}
{"repo": "IntrospectiveSystems/xGraph", "path": "lib/Genesis.js", "func_name": "cacheModules", "original_string": "async function cacheModules(ModCache) {\n\t\t\t\tlet timer = log.time('cacheModules');\n\t\t\t\tlet ModulePromiseArray = [];\n\t\t\t\tfor (let folder in ModCache) {\n\t\t\t\t\tModulePromiseArray.push(new Promise(async (res) => {\n\t\t\t\t\t\tawait cacheInterface.addModule(folder, ModCache[folder]);\n\t\t\t\t\t\tlog.v(`Finished installing dependencies for ${folder}`);\n\t\t\t\t\t\tres();\n\t\t\t\t\t}));\n\n\t\t\t\t}\n\t\t\t\tawait Promise.all(ModulePromiseArray);\n\n\t\t\t\tlog.timeEnd(timer);\n\t\t\t}", "language": "javascript", "code": "async function cacheModules(ModCache) {\n\t\t\t\tlet timer = log.time('cacheModules');\n\t\t\t\tlet ModulePromiseArray = [];\n\t\t\t\tfor (let folder in ModCache) {\n\t\t\t\t\tModulePromiseArray.push(new Promise(async (res) => {\n\t\t\t\t\t\tawait cacheInterface.addModule(folder, ModCache[folder]);\n\t\t\t\t\t\tlog.v(`Finished installing dependencies for ${folder}`);\n\t\t\t\t\t\tres();\n\t\t\t\t\t}));\n\n\t\t\t\t}\n\t\t\t\tawait Promise.all(ModulePromiseArray);\n\n\t\t\t\tlog.timeEnd(timer);\n\t\t\t}", "code_tokens": ["async", "function", "cacheModules", "(", "ModCache", ")", "{", "let", "timer", "=", "log", ".", "time", "(", "'cacheModules'", ")", ";", "let", "ModulePromiseArray", "=", "[", "]", ";", "for", "(", "let", "folder", "in", "ModCache", ")", "{", "ModulePromiseArray", ".", "push", "(", "new", "Promise", "(", "async", "(", "res", ")", "=>", "{", "await", "cacheInterface", ".", "addModule", "(", "folder", ",", "ModCache", "[", "folder", "]", ")", ";", "log", ".", "v", "(", "`", "${", "folder", "}", "`", ")", ";", "res", "(", ")", ";", "}", ")", ")", ";", "}", "await", "Promise", ".", "all", "(", "ModulePromiseArray", ")", ";", "log", ".", "timeEnd", "(", "timer", ")", ";", "}"], "docstring": "Write the modules to the cache\n@param {Object} ModCache \t//the set of module zips required for this system", "docstring_tokens": ["Write", "the", "modules", "to", "the", "cache"], "sha": "86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0", "url": "https://github.com/IntrospectiveSystems/xGraph/blob/86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0/lib/Genesis.js#L678-L692", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/PluginInfo.js", "func_name": "createReplacement", "original_string": "function createReplacement(manifestFile, originalChange) {\n    var replacement = {\n        target:         manifestFile,\n        parent:         originalChange.parent,\n        after:          originalChange.after,\n        xmls:           originalChange.xmls,\n        versions:       originalChange.versions,\n        deviceTarget:   originalChange.deviceTarget\n    };\n    return replacement;\n}", "language": "javascript", "code": "function createReplacement(manifestFile, originalChange) {\n    var replacement = {\n        target:         manifestFile,\n        parent:         originalChange.parent,\n        after:          originalChange.after,\n        xmls:           originalChange.xmls,\n        versions:       originalChange.versions,\n        deviceTarget:   originalChange.deviceTarget\n    };\n    return replacement;\n}", "code_tokens": ["function", "createReplacement", "(", "manifestFile", ",", "originalChange", ")", "{", "var", "replacement", "=", "{", "target", ":", "manifestFile", ",", "parent", ":", "originalChange", ".", "parent", ",", "after", ":", "originalChange", ".", "after", ",", "xmls", ":", "originalChange", ".", "xmls", ",", "versions", ":", "originalChange", ".", "versions", ",", "deviceTarget", ":", "originalChange", ".", "deviceTarget", "}", ";", "return", "replacement", ";", "}"], "docstring": "This is a local function that creates the new replacement representing the mutation.  Used to save code further down.", "docstring_tokens": ["This", "is", "a", "local", "function", "that", "creates", "the", "new", "replacement", "representing", "the", "mutation", ".", "Used", "to", "save", "code", "further", "down", "."], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/PluginInfo.js#L103-L113", "partition": "test"}
{"repo": "duaraghav8/Ethlint", "path": "lib/utils/rule-loader.js", "func_name": "resolvePluginConfig", "original_string": "function resolvePluginConfig(name, plugin) {\n    let config = {};\n\n    Object.keys(plugin.rules).forEach(function(ruleName) {\n        config [name + \"/\" + ruleName] = plugin.rules [ruleName].meta.docs.type;\n    });\n\n    return config;\n}", "language": "javascript", "code": "function resolvePluginConfig(name, plugin) {\n    let config = {};\n\n    Object.keys(plugin.rules).forEach(function(ruleName) {\n        config [name + \"/\" + ruleName] = plugin.rules [ruleName].meta.docs.type;\n    });\n\n    return config;\n}", "code_tokens": ["function", "resolvePluginConfig", "(", "name", ",", "plugin", ")", "{", "let", "config", "=", "{", "}", ";", "Object", ".", "keys", "(", "plugin", ".", "rules", ")", ".", "forEach", "(", "function", "(", "ruleName", ")", "{", "config", "[", "name", "+", "\"/\"", "+", "ruleName", "]", "=", "plugin", ".", "rules", "[", "ruleName", "]", ".", "meta", ".", "docs", ".", "type", ";", "}", ")", ";", "return", "config", ";", "}"], "docstring": "Create provided plugin's default rule configuration\n@param {String} name Plugin name without 'solium-plugin-' prefix\n@param {Object} plugin The plugin Object as exported by the solium plugin\n@returns {Object} config Rule configuration object for the given plugin", "docstring_tokens": ["Create", "provided", "plugin", "s", "default", "rule", "configuration"], "sha": "7d264373709561148c7166601ac39370e78f74b1", "url": "https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/utils/rule-loader.js#L73-L81", "partition": "test"}
{"repo": "viridia/certainty", "path": "lib/subject/subject.js", "func_name": "Subject", "original_string": "function Subject(failureStrategy, value) {\n  this.failureStrategy = failureStrategy;\n  this.value = value;\n  this.name = null;\n  this.format = format;\n  this.failureMessage = null;\n}", "language": "javascript", "code": "function Subject(failureStrategy, value) {\n  this.failureStrategy = failureStrategy;\n  this.value = value;\n  this.name = null;\n  this.format = format;\n  this.failureMessage = null;\n}", "code_tokens": ["function", "Subject", "(", "failureStrategy", ",", "value", ")", "{", "this", ".", "failureStrategy", "=", "failureStrategy", ";", "this", ".", "value", "=", "value", ";", "this", ".", "name", "=", "null", ";", "this", ".", "format", "=", "format", ";", "this", ".", "failureMessage", "=", "null", ";", "}"], "docstring": "Represents the value being checked, and provides assertion methods. Can be subclassed to\nprovide assertion methods that are type-specific.\n@param {FailureStrategy} failureStrategy The failure strategy to use when an assertion fails.\n@param {*} value The value being checked.\n@constructor", "docstring_tokens": ["Represents", "the", "value", "being", "checked", "and", "provides", "assertion", "methods", ".", "Can", "be", "subclassed", "to", "provide", "assertion", "methods", "that", "are", "type", "-", "specific", "."], "sha": "ab4294df65dfda324ef0713a3a22657959958f80", "url": "https://github.com/viridia/certainty/blob/ab4294df65dfda324ef0713a3a22657959958f80/lib/subject/subject.js#L12-L18", "partition": "test"}
{"repo": "expressjs/generator", "path": "bin/express-cli.js", "func_name": "write", "original_string": "function write (file, str, mode) {\n  fs.writeFileSync(file, str, { mode: mode || MODE_0666 })\n  console.log('   \\x1b[36mcreate\\x1b[0m : ' + file)\n}", "language": "javascript", "code": "function write (file, str, mode) {\n  fs.writeFileSync(file, str, { mode: mode || MODE_0666 })\n  console.log('   \\x1b[36mcreate\\x1b[0m : ' + file)\n}", "code_tokens": ["function", "write", "(", "file", ",", "str", ",", "mode", ")", "{", "fs", ".", "writeFileSync", "(", "file", ",", "str", ",", "{", "mode", ":", "mode", "||", "MODE_0666", "}", ")", "console", ".", "log", "(", "'   \\x1b[36mcreate\\x1b[0m : '", "+", "file", ")", "}"], "docstring": "echo str > file.\n\n@param {String} file\n@param {String} str", "docstring_tokens": ["echo", "str", ">", "file", "."], "sha": "d1f3fcc6ccc7ab8986fb3438c82ab1a1f20dc50d", "url": "https://github.com/expressjs/generator/blob/d1f3fcc6ccc7ab8986fb3438c82ab1a1f20dc50d/bin/express-cli.js#L536-L539", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/html-snapshots.js", "func_name": "", "original_string": "function (options, listener) {\n    var inputGenerator, notifier, started, result, q, emitter, completion;\n\n    options = options || {};\n    prepOptions(options);\n\n    // create the inputGenerator, default to robots\n    inputGenerator = inputFactory.create(options.input);\n\n    // clean the snapshot output directory\n    if (options.outputDirClean) {\n      rimraf(options.outputDir);\n    }\n\n    // start async completion notification.\n    notifier = new Notifier();\n    emitter = new EventEmitter();\n    started = notifier.start(options.pollInterval, inputGenerator,\n      function (err, completed) {\n        emitter.emit(\"complete\", err, completed);\n      });\n\n    if (started) {\n      // create the completion Promise.\n      completion = new Promise(function (resolve, reject) {\n        function completionResolver (err, completed) {\n          try {\n            _.isFunction(listener) && listener(err, completed);\n          } catch (e) {\n            console.error(\"User supplied listener exception\", e);\n          }\n          if (err) {\n            err.notCompleted = notifier.filesNotDone;\n            err.completed = completed;\n            reject(err);\n          } else {\n            resolve(completed);\n          }\n        }\n        emitter.addListener(\"complete\", completionResolver);\n      });\n\n      // create a worker queue with a parallel process limit.\n      q = asyncLib.queue(function (task, callback) {\n        task(_.once(callback));\n      }, options.processLimit);\n\n      // have the queue call notifier.empty when last item\n      //  from the queue is given to a worker.\n      q.empty = notifier.qEmpty.bind(notifier);\n\n      // expose abort callback to input generators via options.\n      options._abort = function (err) {\n        notifier.abort(q, err);\n      };\n\n      // generate input for the snapshots.\n      result = inputGenerator.run(options, function (input) {\n        // give the worker the input and place into the queue\n        q.push(_.partial(worker, input, options, notifier));\n      })\n        // after input generation, resolve on browser completion.\n        .then(function () {\n          return completion;\n        });\n    } else {\n      result = Promise.reject(\"failed to start async notifier\");\n    }\n\n    return result;\n  }", "language": "javascript", "code": "function (options, listener) {\n    var inputGenerator, notifier, started, result, q, emitter, completion;\n\n    options = options || {};\n    prepOptions(options);\n\n    // create the inputGenerator, default to robots\n    inputGenerator = inputFactory.create(options.input);\n\n    // clean the snapshot output directory\n    if (options.outputDirClean) {\n      rimraf(options.outputDir);\n    }\n\n    // start async completion notification.\n    notifier = new Notifier();\n    emitter = new EventEmitter();\n    started = notifier.start(options.pollInterval, inputGenerator,\n      function (err, completed) {\n        emitter.emit(\"complete\", err, completed);\n      });\n\n    if (started) {\n      // create the completion Promise.\n      completion = new Promise(function (resolve, reject) {\n        function completionResolver (err, completed) {\n          try {\n            _.isFunction(listener) && listener(err, completed);\n          } catch (e) {\n            console.error(\"User supplied listener exception\", e);\n          }\n          if (err) {\n            err.notCompleted = notifier.filesNotDone;\n            err.completed = completed;\n            reject(err);\n          } else {\n            resolve(completed);\n          }\n        }\n        emitter.addListener(\"complete\", completionResolver);\n      });\n\n      // create a worker queue with a parallel process limit.\n      q = asyncLib.queue(function (task, callback) {\n        task(_.once(callback));\n      }, options.processLimit);\n\n      // have the queue call notifier.empty when last item\n      //  from the queue is given to a worker.\n      q.empty = notifier.qEmpty.bind(notifier);\n\n      // expose abort callback to input generators via options.\n      options._abort = function (err) {\n        notifier.abort(q, err);\n      };\n\n      // generate input for the snapshots.\n      result = inputGenerator.run(options, function (input) {\n        // give the worker the input and place into the queue\n        q.push(_.partial(worker, input, options, notifier));\n      })\n        // after input generation, resolve on browser completion.\n        .then(function () {\n          return completion;\n        });\n    } else {\n      result = Promise.reject(\"failed to start async notifier\");\n    }\n\n    return result;\n  }", "code_tokens": ["function", "(", "options", ",", "listener", ")", "{", "var", "inputGenerator", ",", "notifier", ",", "started", ",", "result", ",", "q", ",", "emitter", ",", "completion", ";", "options", "=", "options", "||", "{", "}", ";", "prepOptions", "(", "options", ")", ";", "// create the inputGenerator, default to robots", "inputGenerator", "=", "inputFactory", ".", "create", "(", "options", ".", "input", ")", ";", "// clean the snapshot output directory", "if", "(", "options", ".", "outputDirClean", ")", "{", "rimraf", "(", "options", ".", "outputDir", ")", ";", "}", "// start async completion notification.", "notifier", "=", "new", "Notifier", "(", ")", ";", "emitter", "=", "new", "EventEmitter", "(", ")", ";", "started", "=", "notifier", ".", "start", "(", "options", ".", "pollInterval", ",", "inputGenerator", ",", "function", "(", "err", ",", "completed", ")", "{", "emitter", ".", "emit", "(", "\"complete\"", ",", "err", ",", "completed", ")", ";", "}", ")", ";", "if", "(", "started", ")", "{", "// create the completion Promise.", "completion", "=", "new", "Promise", "(", "function", "(", "resolve", ",", "reject", ")", "{", "function", "completionResolver", "(", "err", ",", "completed", ")", "{", "try", "{", "_", ".", "isFunction", "(", "listener", ")", "&&", "listener", "(", "err", ",", "completed", ")", ";", "}", "catch", "(", "e", ")", "{", "console", ".", "error", "(", "\"User supplied listener exception\"", ",", "e", ")", ";", "}", "if", "(", "err", ")", "{", "err", ".", "notCompleted", "=", "notifier", ".", "filesNotDone", ";", "err", ".", "completed", "=", "completed", ";", "reject", "(", "err", ")", ";", "}", "else", "{", "resolve", "(", "completed", ")", ";", "}", "}", "emitter", ".", "addListener", "(", "\"complete\"", ",", "completionResolver", ")", ";", "}", ")", ";", "// create a worker queue with a parallel process limit.", "q", "=", "asyncLib", ".", "queue", "(", "function", "(", "task", ",", "callback", ")", "{", "task", "(", "_", ".", "once", "(", "callback", ")", ")", ";", "}", ",", "options", ".", "processLimit", ")", ";", "// have the queue call notifier.empty when last item", "//  from the queue is given to a worker.", "q", ".", "empty", "=", "notifier", ".", "qEmpty", ".", "bind", "(", "notifier", ")", ";", "// expose abort callback to input generators via options.", "options", ".", "_abort", "=", "function", "(", "err", ")", "{", "notifier", ".", "abort", "(", "q", ",", "err", ")", ";", "}", ";", "// generate input for the snapshots.", "result", "=", "inputGenerator", ".", "run", "(", "options", ",", "function", "(", "input", ")", "{", "// give the worker the input and place into the queue", "q", ".", "push", "(", "_", ".", "partial", "(", "worker", ",", "input", ",", "options", ",", "notifier", ")", ")", ";", "}", ")", "// after input generation, resolve on browser completion.", ".", "then", "(", "function", "(", ")", "{", "return", "completion", ";", "}", ")", ";", "}", "else", "{", "result", "=", "Promise", ".", "reject", "(", "\"failed to start async notifier\"", ")", ";", "}", "return", "result", ";", "}"], "docstring": "Run all the snapshots using the requested inputGenerator\n\n@param {Object} options - ALL user supplied html snapshots options.\n@param {String} options.outputDir - Directory to write the html files to.\n@param {String} [options.input] - Input source type \"robots\", \"sitemap\", \"array\";\nDefaults to \"robots\".\n@param {Boolean} [options.outputDirClean] - True if output dir should be rm -rf;\nDefaults to false.\n@param {Number} [options.pollInterval] -\n@param {Function} [listener] - User supplied optional callback.\n@returns {Promise} Resolves on completion.", "docstring_tokens": ["Run", "all", "the", "snapshots", "using", "the", "requested", "inputGenerator"], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/html-snapshots.js#L177-L247", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "wrap", "original_string": "function wrap(type, fn) {\n    return function plugin() {\n      return this.type === type ? fn.apply(this, arguments) : plugin;\n    };\n  }", "language": "javascript", "code": "function wrap(type, fn) {\n    return function plugin() {\n      return this.type === type ? fn.apply(this, arguments) : plugin;\n    };\n  }", "code_tokens": ["function", "wrap", "(", "type", ",", "fn", ")", "{", "return", "function", "plugin", "(", ")", "{", "return", "this", ".", "type", "===", "type", "?", "fn", ".", "apply", "(", "this", ",", "arguments", ")", ":", "plugin", ";", "}", ";", "}"], "docstring": "Wrap a named plugin function so that it's only called on objects of the\ngiven `type`\n\n@param {String} `type`\n@param {Function} `fn` Plugin function\n@return {Function}", "docstring_tokens": ["Wrap", "a", "named", "plugin", "function", "so", "that", "it", "s", "only", "called", "on", "objects", "of", "the", "given", "type"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L73032-L73036", "partition": "test"}
{"repo": "ForbesLindesay/handle", "path": "index.js", "func_name": "on", "original_string": "function on(top) {\n  top = typeof top === 'string' ? document.querySelector(top) : top;\n  var h = handle.bind(this, top);\n  h.once = once.bind(this, top);\n  return h;\n}", "language": "javascript", "code": "function on(top) {\n  top = typeof top === 'string' ? document.querySelector(top) : top;\n  var h = handle.bind(this, top);\n  h.once = once.bind(this, top);\n  return h;\n}", "code_tokens": ["function", "on", "(", "top", ")", "{", "top", "=", "typeof", "top", "===", "'string'", "?", "document", ".", "querySelector", "(", "top", ")", ":", "top", ";", "var", "h", "=", "handle", ".", "bind", "(", "this", ",", "top", ")", ";", "h", ".", "once", "=", "once", ".", "bind", "(", "this", ",", "top", ")", ";", "return", "h", ";", "}"], "docstring": "Get a handle function for a given top\n\n@param {Element} top The element to begin delegating from\n@return {Function}\n@api public", "docstring_tokens": ["Get", "a", "handle", "function", "for", "a", "given", "top"], "sha": "b87a9091e39a8a528b86bae766a14d9c026cbcff", "url": "https://github.com/ForbesLindesay/handle/blob/b87a9091e39a8a528b86bae766a14d9c026cbcff/index.js#L17-L22", "partition": "test"}
{"repo": "blakevanlan/insist", "path": "index.js", "func_name": "", "original_string": "function (expected, expectedIndex, actual, actualIndex) {\n   // Check how many optional types in front of this argument that match the current value.\n   var consecutiveOptionals = countTrailingOptionals_(expected, expectedIndex, actual[actualIndex]);\n\n   // Check how many required types are behind this argument that match the current value. We\n   // will then use this value to determine if the current argument can be allowed to fill an\n   // optional spot instead of a required one.\n   var matchingRequires = countLeadingMatchingRequires_(expected, expectedIndex,\n         actual[actualIndex]);\n\n   // Now that we have found the consecutive matching types, more forward through the arguments\n   // to see if there are enough to fill the option types.\n   var matchesRequired = 1 + matchingRequires;\n   var availableDistance = matchingRequires + consecutiveOptionals;\n\n   // Determine if there are enough optional arguments.\n   var i = actualIndex - 1;\n   var type = expected[expectedIndex];\n   while (i >= 0 && availableDistance > 0 && matchesRequired > 0) {\n      if (isOfType(actual[i], type)) {\n         matchesRequired--;\n      }\n      availableDistance--;\n      i--;\n   }\n   return matchesRequired <= 0;\n}", "language": "javascript", "code": "function (expected, expectedIndex, actual, actualIndex) {\n   // Check how many optional types in front of this argument that match the current value.\n   var consecutiveOptionals = countTrailingOptionals_(expected, expectedIndex, actual[actualIndex]);\n\n   // Check how many required types are behind this argument that match the current value. We\n   // will then use this value to determine if the current argument can be allowed to fill an\n   // optional spot instead of a required one.\n   var matchingRequires = countLeadingMatchingRequires_(expected, expectedIndex,\n         actual[actualIndex]);\n\n   // Now that we have found the consecutive matching types, more forward through the arguments\n   // to see if there are enough to fill the option types.\n   var matchesRequired = 1 + matchingRequires;\n   var availableDistance = matchingRequires + consecutiveOptionals;\n\n   // Determine if there are enough optional arguments.\n   var i = actualIndex - 1;\n   var type = expected[expectedIndex];\n   while (i >= 0 && availableDistance > 0 && matchesRequired > 0) {\n      if (isOfType(actual[i], type)) {\n         matchesRequired--;\n      }\n      availableDistance--;\n      i--;\n   }\n   return matchesRequired <= 0;\n}", "code_tokens": ["function", "(", "expected", ",", "expectedIndex", ",", "actual", ",", "actualIndex", ")", "{", "// Check how many optional types in front of this argument that match the current value.", "var", "consecutiveOptionals", "=", "countTrailingOptionals_", "(", "expected", ",", "expectedIndex", ",", "actual", "[", "actualIndex", "]", ")", ";", "// Check how many required types are behind this argument that match the current value. We", "// will then use this value to determine if the current argument can be allowed to fill an", "// optional spot instead of a required one.", "var", "matchingRequires", "=", "countLeadingMatchingRequires_", "(", "expected", ",", "expectedIndex", ",", "actual", "[", "actualIndex", "]", ")", ";", "// Now that we have found the consecutive matching types, more forward through the arguments", "// to see if there are enough to fill the option types.", "var", "matchesRequired", "=", "1", "+", "matchingRequires", ";", "var", "availableDistance", "=", "matchingRequires", "+", "consecutiveOptionals", ";", "// Determine if there are enough optional arguments.", "var", "i", "=", "actualIndex", "-", "1", ";", "var", "type", "=", "expected", "[", "expectedIndex", "]", ";", "while", "(", "i", ">=", "0", "&&", "availableDistance", ">", "0", "&&", "matchesRequired", ">", "0", ")", "{", "if", "(", "isOfType", "(", "actual", "[", "i", "]", ",", "type", ")", ")", "{", "matchesRequired", "--", ";", "}", "availableDistance", "--", ";", "i", "--", ";", "}", "return", "matchesRequired", "<=", "0", ";", "}"], "docstring": "Checks if the current argument should be left for an optional argument.\n@param {Array} expected\n@param {number} expectedIndex\n@param {?} value\n@returns {bool}\n@private", "docstring_tokens": ["Checks", "if", "the", "current", "argument", "should", "be", "left", "for", "an", "optional", "argument", "."], "sha": "a5f557f4fd48029e20ae0d66912f701d0577feb5", "url": "https://github.com/blakevanlan/insist/blob/a5f557f4fd48029e20ae0d66912f701d0577feb5/index.js#L166-L192", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "use", "original_string": "function use(type, fn, options) {\n    var offset = 1;\n\n    if (typeof type === 'string' || Array.isArray(type)) {\n      fn = wrap(type, fn);\n      offset++;\n    } else {\n      options = fn;\n      fn = type;\n    }\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('expected a function');\n    }\n\n    var self = this || app;\n    var fns = self[prop];\n\n    var args = [].slice.call(arguments, offset);\n    args.unshift(self);\n\n    if (typeof opts.hook === 'function') {\n      opts.hook.apply(self, args);\n    }\n\n    var val = fn.apply(self, args);\n    if (typeof val === 'function' && fns.indexOf(val) === -1) {\n      fns.push(val);\n    }\n    return self;\n  }", "language": "javascript", "code": "function use(type, fn, options) {\n    var offset = 1;\n\n    if (typeof type === 'string' || Array.isArray(type)) {\n      fn = wrap(type, fn);\n      offset++;\n    } else {\n      options = fn;\n      fn = type;\n    }\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('expected a function');\n    }\n\n    var self = this || app;\n    var fns = self[prop];\n\n    var args = [].slice.call(arguments, offset);\n    args.unshift(self);\n\n    if (typeof opts.hook === 'function') {\n      opts.hook.apply(self, args);\n    }\n\n    var val = fn.apply(self, args);\n    if (typeof val === 'function' && fns.indexOf(val) === -1) {\n      fns.push(val);\n    }\n    return self;\n  }", "code_tokens": ["function", "use", "(", "type", ",", "fn", ",", "options", ")", "{", "var", "offset", "=", "1", ";", "if", "(", "typeof", "type", "===", "'string'", "||", "Array", ".", "isArray", "(", "type", ")", ")", "{", "fn", "=", "wrap", "(", "type", ",", "fn", ")", ";", "offset", "++", ";", "}", "else", "{", "options", "=", "fn", ";", "fn", "=", "type", ";", "}", "if", "(", "typeof", "fn", "!==", "'function'", ")", "{", "throw", "new", "TypeError", "(", "'expected a function'", ")", ";", "}", "var", "self", "=", "this", "||", "app", ";", "var", "fns", "=", "self", "[", "prop", "]", ";", "var", "args", "=", "[", "]", ".", "slice", ".", "call", "(", "arguments", ",", "offset", ")", ";", "args", ".", "unshift", "(", "self", ")", ";", "if", "(", "typeof", "opts", ".", "hook", "===", "'function'", ")", "{", "opts", ".", "hook", ".", "apply", "(", "self", ",", "args", ")", ";", "}", "var", "val", "=", "fn", ".", "apply", "(", "self", ",", "args", ")", ";", "if", "(", "typeof", "val", "===", "'function'", "&&", "fns", ".", "indexOf", "(", "val", ")", "===", "-", "1", ")", "{", "fns", ".", "push", "(", "val", ")", ";", "}", "return", "self", ";", "}"], "docstring": "Call plugin `fn`. If a function is returned push it into the\n`fns` array to be called by the `run` method.", "docstring_tokens": ["Call", "plugin", "fn", ".", "If", "a", "function", "is", "returned", "push", "it", "into", "the", "fns", "array", "to", "be", "called", "by", "the", "run", "method", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L72991-L73021", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "clearCachedTemplate", "original_string": "function clearCachedTemplate ( templateProp ) {\n\n        var fromMarionette = false,\n            args = _.toArray( arguments ),\n            lastArg = _.last( args );\n\n        // When called from Marionette, or called recursively, the last argument is a \"fromMarionette\" boolean. Splice\n        // it off before proceeding.\n        if ( args.length && _.isBoolean( lastArg ) ) fromMarionette = args.pop();\n\n        // Handle multiple template props passed in as a varargs list, or as an array, with recursive calls for each\n        // template property.\n        if ( args.length > 1 ) {\n            _.each( args, function ( singleProp ) { clearCachedTemplate( singleProp, fromMarionette ); } );\n        } else if ( _.isArray( templateProp ) || _.isArguments( templateProp ) ) {\n            _.each( templateProp, function ( singleProp ) { clearCachedTemplate( singleProp, fromMarionette ); } );\n        } else {\n\n            if ( ! templateProp ) throw new GenericError( \"Missing argument: string identifying the template. The string should be a template selector or the raw HTML of a template, as provided to the template property of a view when the cache entry was created\" );\n\n            // Dealing with a single templateProp argument.\n            //\n            // Delete the corresponding cache entry. Try to clear it from the Marionette cache as well. The\n            // templateProp must be a string - non-string arguments are quietly ignored.\n            if ( _.isString( templateProp ) ) {\n\n                _clearCachedTemplate( templateProp );\n\n                if ( ! fromMarionette && Backbone.Marionette && Backbone.Marionette.TemplateCache ) {\n                    try {\n                        Backbone.Marionette.TemplateCache.clear( templateProp );\n                    } catch ( err ) {}\n                }\n\n            }\n\n        }\n\n    }", "language": "javascript", "code": "function clearCachedTemplate ( templateProp ) {\n\n        var fromMarionette = false,\n            args = _.toArray( arguments ),\n            lastArg = _.last( args );\n\n        // When called from Marionette, or called recursively, the last argument is a \"fromMarionette\" boolean. Splice\n        // it off before proceeding.\n        if ( args.length && _.isBoolean( lastArg ) ) fromMarionette = args.pop();\n\n        // Handle multiple template props passed in as a varargs list, or as an array, with recursive calls for each\n        // template property.\n        if ( args.length > 1 ) {\n            _.each( args, function ( singleProp ) { clearCachedTemplate( singleProp, fromMarionette ); } );\n        } else if ( _.isArray( templateProp ) || _.isArguments( templateProp ) ) {\n            _.each( templateProp, function ( singleProp ) { clearCachedTemplate( singleProp, fromMarionette ); } );\n        } else {\n\n            if ( ! templateProp ) throw new GenericError( \"Missing argument: string identifying the template. The string should be a template selector or the raw HTML of a template, as provided to the template property of a view when the cache entry was created\" );\n\n            // Dealing with a single templateProp argument.\n            //\n            // Delete the corresponding cache entry. Try to clear it from the Marionette cache as well. The\n            // templateProp must be a string - non-string arguments are quietly ignored.\n            if ( _.isString( templateProp ) ) {\n\n                _clearCachedTemplate( templateProp );\n\n                if ( ! fromMarionette && Backbone.Marionette && Backbone.Marionette.TemplateCache ) {\n                    try {\n                        Backbone.Marionette.TemplateCache.clear( templateProp );\n                    } catch ( err ) {}\n                }\n\n            }\n\n        }\n\n    }", "code_tokens": ["function", "clearCachedTemplate", "(", "templateProp", ")", "{", "var", "fromMarionette", "=", "false", ",", "args", "=", "_", ".", "toArray", "(", "arguments", ")", ",", "lastArg", "=", "_", ".", "last", "(", "args", ")", ";", "// When called from Marionette, or called recursively, the last argument is a \"fromMarionette\" boolean. Splice", "// it off before proceeding.", "if", "(", "args", ".", "length", "&&", "_", ".", "isBoolean", "(", "lastArg", ")", ")", "fromMarionette", "=", "args", ".", "pop", "(", ")", ";", "// Handle multiple template props passed in as a varargs list, or as an array, with recursive calls for each", "// template property.", "if", "(", "args", ".", "length", ">", "1", ")", "{", "_", ".", "each", "(", "args", ",", "function", "(", "singleProp", ")", "{", "clearCachedTemplate", "(", "singleProp", ",", "fromMarionette", ")", ";", "}", ")", ";", "}", "else", "if", "(", "_", ".", "isArray", "(", "templateProp", ")", "||", "_", ".", "isArguments", "(", "templateProp", ")", ")", "{", "_", ".", "each", "(", "templateProp", ",", "function", "(", "singleProp", ")", "{", "clearCachedTemplate", "(", "singleProp", ",", "fromMarionette", ")", ";", "}", ")", ";", "}", "else", "{", "if", "(", "!", "templateProp", ")", "throw", "new", "GenericError", "(", "\"Missing argument: string identifying the template. The string should be a template selector or the raw HTML of a template, as provided to the template property of a view when the cache entry was created\"", ")", ";", "// Dealing with a single templateProp argument.", "//", "// Delete the corresponding cache entry. Try to clear it from the Marionette cache as well. The", "// templateProp must be a string - non-string arguments are quietly ignored.", "if", "(", "_", ".", "isString", "(", "templateProp", ")", ")", "{", "_clearCachedTemplate", "(", "templateProp", ")", ";", "if", "(", "!", "fromMarionette", "&&", "Backbone", ".", "Marionette", "&&", "Backbone", ".", "Marionette", ".", "TemplateCache", ")", "{", "try", "{", "Backbone", ".", "Marionette", ".", "TemplateCache", ".", "clear", "(", "templateProp", ")", ";", "}", "catch", "(", "err", ")", "{", "}", "}", "}", "}", "}"], "docstring": "Removes one or more cache entries.\n\nArguments\n---------\n\nThe strings identifying the cache entries can be passed in as individual arguments (prop1, prop2, ...), or as an\narray. Each string must be\n\n- a template selector\n- raw HTML of a template, if that's what the template property held when a view made use of it.\n\nA template selector must be identical to the one which was used when creating the cache entry, ie the selector\nspecified in the template property or template option of a view. Mere selector equivalence (e.g. \"#template\" and\n\"script#template\") won't match the cache.\n\nStrings not matching a cache entry are ignored, as are non-string arguments.\n\nMarionette.TemplateCache\n------------------------\n\nWhen templates are cleared here, they are removed from the Marionette template cache as well (if Marionette is\nloaded).\n\n@param {...string|string[]} [templateProp]  template selector(s), or raw template HTML, identifying the cache\nentry. NB The last argument can also be an internal \"fromMarionette\"\nflag to prevent circular calls to and from Marionette", "docstring_tokens": ["Removes", "one", "or", "more", "cache", "entries", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L15359-L15397", "partition": "test"}
{"repo": "zdfs/grunt-datadriver", "path": "tasks/datadriver.js", "func_name": "", "original_string": "function() {\n                var callback = arguments[arguments.length - 1];\n                grunt.log.debug('init WebdriverIO instance');\n\n                GLOBAL.browser.init(function(err) {\n                    /**\n                     * gracefully kill process if init fails\n                     */\n                    callback(err);\n                });\n            }", "language": "javascript", "code": "function() {\n                var callback = arguments[arguments.length - 1];\n                grunt.log.debug('init WebdriverIO instance');\n\n                GLOBAL.browser.init(function(err) {\n                    /**\n                     * gracefully kill process if init fails\n                     */\n                    callback(err);\n                });\n            }", "code_tokens": ["function", "(", ")", "{", "var", "callback", "=", "arguments", "[", "arguments", ".", "length", "-", "1", "]", ";", "grunt", ".", "log", ".", "debug", "(", "'init WebdriverIO instance'", ")", ";", "GLOBAL", ".", "browser", ".", "init", "(", "function", "(", "err", ")", "{", "/**\n                     * gracefully kill process if init fails\n                     */", "callback", "(", "err", ")", ";", "}", ")", ";", "}"], "docstring": "init WebdriverIO instance", "docstring_tokens": ["init", "WebdriverIO", "instance"], "sha": "8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e", "url": "https://github.com/zdfs/grunt-datadriver/blob/8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e/tasks/datadriver.js#L259-L269", "partition": "test"}
{"repo": "NathanWalker/nativescript-ng2-magic", "path": "install.js", "func_name": "processBootStrap", "original_string": "function processBootStrap(file) {\n    var data = fs.readFileSync(file).toString();\n    var idx = data.indexOf('bootstrap(');\n    if (idx === -1) { return null; }\n    else { idx+=10; }\n\n    var odx1 = data.indexOf(',', idx);\n    var odx2 = data.indexOf(')', idx);\n    if (odx2 < odx1 && odx2 !== -1 || odx1 === -1) { odx1 = odx2; }\n    if (odx1 === -1) { return null; }\n    var componentRef = data.substring(idx, odx1);\n    var exp = \"import\\\\s+\\\\{(\"+componentRef+\")\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\";\n    if (debugging) {\n        console.log(\"Searching for\", exp);\n    }\n\n    var result = function (r) {\n      return {\n        name: r[1],\n        path: r[r.length - 1]\n      };\n    };\n    //noinspection JSPotentiallyInvalidConstructorUsage\n    var r = RegExp(exp, 'i').exec(data);\n    if (r === null || r.length <= 1) {\n      // check if using current style guide with spaces\n      exp = \"import\\\\s+\\\\{\\\\s+(\"+componentRef+\")\\\\,\\\\s+([A-Z]{0,300})\\\\w+\\\\s+\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\";\n      if (debugging) {\n        console.log(\"Searching for\", exp);\n      }\n      r = RegExp(exp, 'i').exec(data);\n      if (r === null || r.length <= 1) {\n        // try just spaces with no angular cli style (, environment) etc.\n        exp = \"import\\\\s+\\\\{\\\\s+(\" + componentRef + \")\\\\s+\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\";\n        if (debugging) {\n          console.log(\"Searching for\", exp);\n        }\n        r = RegExp(exp, 'i').exec(data);\n        if (r !== null && r.length > 1) {\n          return result(r);\n        }\n      } else {\n        // angular cli\n        return result(r);\n      }     \n      return null;\n    }\n    return result(r);\n}", "language": "javascript", "code": "function processBootStrap(file) {\n    var data = fs.readFileSync(file).toString();\n    var idx = data.indexOf('bootstrap(');\n    if (idx === -1) { return null; }\n    else { idx+=10; }\n\n    var odx1 = data.indexOf(',', idx);\n    var odx2 = data.indexOf(')', idx);\n    if (odx2 < odx1 && odx2 !== -1 || odx1 === -1) { odx1 = odx2; }\n    if (odx1 === -1) { return null; }\n    var componentRef = data.substring(idx, odx1);\n    var exp = \"import\\\\s+\\\\{(\"+componentRef+\")\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\";\n    if (debugging) {\n        console.log(\"Searching for\", exp);\n    }\n\n    var result = function (r) {\n      return {\n        name: r[1],\n        path: r[r.length - 1]\n      };\n    };\n    //noinspection JSPotentiallyInvalidConstructorUsage\n    var r = RegExp(exp, 'i').exec(data);\n    if (r === null || r.length <= 1) {\n      // check if using current style guide with spaces\n      exp = \"import\\\\s+\\\\{\\\\s+(\"+componentRef+\")\\\\,\\\\s+([A-Z]{0,300})\\\\w+\\\\s+\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\";\n      if (debugging) {\n        console.log(\"Searching for\", exp);\n      }\n      r = RegExp(exp, 'i').exec(data);\n      if (r === null || r.length <= 1) {\n        // try just spaces with no angular cli style (, environment) etc.\n        exp = \"import\\\\s+\\\\{\\\\s+(\" + componentRef + \")\\\\s+\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\";\n        if (debugging) {\n          console.log(\"Searching for\", exp);\n        }\n        r = RegExp(exp, 'i').exec(data);\n        if (r !== null && r.length > 1) {\n          return result(r);\n        }\n      } else {\n        // angular cli\n        return result(r);\n      }     \n      return null;\n    }\n    return result(r);\n}", "code_tokens": ["function", "processBootStrap", "(", "file", ")", "{", "var", "data", "=", "fs", ".", "readFileSync", "(", "file", ")", ".", "toString", "(", ")", ";", "var", "idx", "=", "data", ".", "indexOf", "(", "'bootstrap('", ")", ";", "if", "(", "idx", "===", "-", "1", ")", "{", "return", "null", ";", "}", "else", "{", "idx", "+=", "10", ";", "}", "var", "odx1", "=", "data", ".", "indexOf", "(", "','", ",", "idx", ")", ";", "var", "odx2", "=", "data", ".", "indexOf", "(", "')'", ",", "idx", ")", ";", "if", "(", "odx2", "<", "odx1", "&&", "odx2", "!==", "-", "1", "||", "odx1", "===", "-", "1", ")", "{", "odx1", "=", "odx2", ";", "}", "if", "(", "odx1", "===", "-", "1", ")", "{", "return", "null", ";", "}", "var", "componentRef", "=", "data", ".", "substring", "(", "idx", ",", "odx1", ")", ";", "var", "exp", "=", "\"import\\\\s+\\\\{(\"", "+", "componentRef", "+", "\")\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\"", ";", "if", "(", "debugging", ")", "{", "console", ".", "log", "(", "\"Searching for\"", ",", "exp", ")", ";", "}", "var", "result", "=", "function", "(", "r", ")", "{", "return", "{", "name", ":", "r", "[", "1", "]", ",", "path", ":", "r", "[", "r", ".", "length", "-", "1", "]", "}", ";", "}", ";", "//noinspection JSPotentiallyInvalidConstructorUsage", "var", "r", "=", "RegExp", "(", "exp", ",", "'i'", ")", ".", "exec", "(", "data", ")", ";", "if", "(", "r", "===", "null", "||", "r", ".", "length", "<=", "1", ")", "{", "// check if using current style guide with spaces", "exp", "=", "\"import\\\\s+\\\\{\\\\s+(\"", "+", "componentRef", "+", "\")\\\\,\\\\s+([A-Z]{0,300})\\\\w+\\\\s+\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\"", ";", "if", "(", "debugging", ")", "{", "console", ".", "log", "(", "\"Searching for\"", ",", "exp", ")", ";", "}", "r", "=", "RegExp", "(", "exp", ",", "'i'", ")", ".", "exec", "(", "data", ")", ";", "if", "(", "r", "===", "null", "||", "r", ".", "length", "<=", "1", ")", "{", "// try just spaces with no angular cli style (, environment) etc.", "exp", "=", "\"import\\\\s+\\\\{\\\\s+(\"", "+", "componentRef", "+", "\")\\\\s+\\\\}\\\\s+from+\\\\s+[\\'|\\\"](\\\\S+)[\\'|\\\"][;?]\"", ";", "if", "(", "debugging", ")", "{", "console", ".", "log", "(", "\"Searching for\"", ",", "exp", ")", ";", "}", "r", "=", "RegExp", "(", "exp", ",", "'i'", ")", ".", "exec", "(", "data", ")", ";", "if", "(", "r", "!==", "null", "&&", "r", ".", "length", ">", "1", ")", "{", "return", "result", "(", "r", ")", ";", "}", "}", "else", "{", "// angular cli", "return", "result", "(", "r", ")", ";", "}", "return", "null", ";", "}", "return", "result", "(", "r", ")", ";", "}"], "docstring": "Parses the bootstrap to figure out the default bootstrap component\n@param file\n@returns {*}", "docstring_tokens": ["Parses", "the", "bootstrap", "to", "figure", "out", "the", "default", "bootstrap", "component"], "sha": "702395cf85add650170ca45ca6f582e6ad609863", "url": "https://github.com/NathanWalker/nativescript-ng2-magic/blob/702395cf85add650170ca45ca6f582e6ad609863/install.js#L172-L220", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/field/Input.js", "func_name": "", "original_string": "function() {\n        var me = this,\n            el = this.input;\n\n        if (el && el.dom.blur) {\n            el.dom.blur();\n        }\n        return me;\n    }", "language": "javascript", "code": "function() {\n        var me = this,\n            el = this.input;\n\n        if (el && el.dom.blur) {\n            el.dom.blur();\n        }\n        return me;\n    }", "code_tokens": ["function", "(", ")", "{", "var", "me", "=", "this", ",", "el", "=", "this", ".", "input", ";", "if", "(", "el", "&&", "el", ".", "dom", ".", "blur", ")", "{", "el", ".", "dom", ".", "blur", "(", ")", ";", "}", "return", "me", ";", "}"], "docstring": "Attempts to forcefully blur input focus for the field.\n@return {Ext.field.Input} this\n@chainable", "docstring_tokens": ["Attempts", "to", "forcefully", "blur", "input", "focus", "for", "the", "field", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/field/Input.js#L740-L748", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(parentModule, module, def, args) {\n      var fn = this._getDefine(def);\n      var startWithParent = this._getStartWithParent(def, module);\n  \n      if (fn) {\n        module.addDefinition(fn, args);\n      }\n  \n      this._addStartWithParent(parentModule, module, startWithParent);\n    }", "language": "javascript", "code": "function(parentModule, module, def, args) {\n      var fn = this._getDefine(def);\n      var startWithParent = this._getStartWithParent(def, module);\n  \n      if (fn) {\n        module.addDefinition(fn, args);\n      }\n  \n      this._addStartWithParent(parentModule, module, startWithParent);\n    }", "code_tokens": ["function", "(", "parentModule", ",", "module", ",", "def", ",", "args", ")", "{", "var", "fn", "=", "this", ".", "_getDefine", "(", "def", ")", ";", "var", "startWithParent", "=", "this", ".", "_getStartWithParent", "(", "def", ",", "module", ")", ";", "if", "(", "fn", ")", "{", "module", ".", "addDefinition", "(", "fn", ",", "args", ")", ";", "}", "this", ".", "_addStartWithParent", "(", "parentModule", ",", "module", ",", "startWithParent", ")", ";", "}"], "docstring": "Add the module definition and add a startWithParent initializer function. This is complicated because module definitions are heavily overloaded and support an anonymous function, module class, or options object", "docstring_tokens": ["Add", "the", "module", "definition", "and", "add", "a", "startWithParent", "initializer", "function", ".", "This", "is", "complicated", "because", "module", "definitions", "are", "heavily", "overloaded", "and", "support", "an", "anonymous", "function", "module", "class", "or", "options", "object"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19994-L20003", "partition": "test"}
{"repo": "Wiredcraft/env-var-defaults", "path": "lib/builder.js", "func_name": "builder", "original_string": "function builder(envList, envName) {\n  if (envList == null) {\n    envList = DEFAULT_ENV_LIST;\n  }\n  if (envName == null) {\n    envName = DEFAULT_ENV_NAME;\n  }\n  if (!Array.isArray(envList)) {\n    throw new Error('envList must be an array');\n  }\n  if (typeof envName !== 'string') {\n    throw new Error('envName must be a string');\n  }\n\n  // .\n  const index = envList.indexOf(env.get(envName, DEFAULT_ENV).required().asString());\n\n  /**\n   * .\n   */\n  // return function defaults(obj) {\n  //   return 'object' !== typeof obj ? obj : obj[index];\n  // };\n  let body;\n  if (index < 0) {\n    body = 'return function defaults() {}';\n  } else {\n    body = `return function defaults(obj) { return 'object' !== typeof obj ? obj : obj[${index}] }`;\n  }\n  return new Function(body)();\n}", "language": "javascript", "code": "function builder(envList, envName) {\n  if (envList == null) {\n    envList = DEFAULT_ENV_LIST;\n  }\n  if (envName == null) {\n    envName = DEFAULT_ENV_NAME;\n  }\n  if (!Array.isArray(envList)) {\n    throw new Error('envList must be an array');\n  }\n  if (typeof envName !== 'string') {\n    throw new Error('envName must be a string');\n  }\n\n  // .\n  const index = envList.indexOf(env.get(envName, DEFAULT_ENV).required().asString());\n\n  /**\n   * .\n   */\n  // return function defaults(obj) {\n  //   return 'object' !== typeof obj ? obj : obj[index];\n  // };\n  let body;\n  if (index < 0) {\n    body = 'return function defaults() {}';\n  } else {\n    body = `return function defaults(obj) { return 'object' !== typeof obj ? obj : obj[${index}] }`;\n  }\n  return new Function(body)();\n}", "code_tokens": ["function", "builder", "(", "envList", ",", "envName", ")", "{", "if", "(", "envList", "==", "null", ")", "{", "envList", "=", "DEFAULT_ENV_LIST", ";", "}", "if", "(", "envName", "==", "null", ")", "{", "envName", "=", "DEFAULT_ENV_NAME", ";", "}", "if", "(", "!", "Array", ".", "isArray", "(", "envList", ")", ")", "{", "throw", "new", "Error", "(", "'envList must be an array'", ")", ";", "}", "if", "(", "typeof", "envName", "!==", "'string'", ")", "{", "throw", "new", "Error", "(", "'envName must be a string'", ")", ";", "}", "// .", "const", "index", "=", "envList", ".", "indexOf", "(", "env", ".", "get", "(", "envName", ",", "DEFAULT_ENV", ")", ".", "required", "(", ")", ".", "asString", "(", ")", ")", ";", "/**\n   * .\n   */", "// return function defaults(obj) {", "//   return 'object' !== typeof obj ? obj : obj[index];", "// };", "let", "body", ";", "if", "(", "index", "<", "0", ")", "{", "body", "=", "'return function defaults() {}'", ";", "}", "else", "{", "body", "=", "`", "${", "index", "}", "`", ";", "}", "return", "new", "Function", "(", "body", ")", "(", ")", ";", "}"], "docstring": "Build a default value getter.\n\n@param {Array} envList the list of supported NODE_ENV, default to `['test', 'development', 'staging', 'production']`\n@param {String} envName you can use a different variable name for your `NODE_ENV` if you want\n@return {Function} the builder", "docstring_tokens": ["Build", "a", "default", "value", "getter", "."], "sha": "535c4e6a738f4870263b9f6136fef18f19ce8881", "url": "https://github.com/Wiredcraft/env-var-defaults/blob/535c4e6a738f4870263b9f6136fef18f19ce8881/lib/builder.js#L16-L46", "partition": "test"}
{"repo": "YannickBochatay/JSYG.CropAndResize", "path": "JSYG.CropAndResize.js", "func_name": "", "original_string": "function(opt) {\n\t\t\t\n            this.disable();\n\t\t\t\n            if (opt) this.set(opt);\n\t\t\t\n            var jNode = new JSYG(this.node),\n            dim = jNode.getDim(),\n            color = jNode.fill(),\n            svg = jNode.offsetParent(),\n            id = 'idpattern'+JSYG.rand(0,5000),\n            g,rect,selection;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n            if (!color || color == 'transparent' || color == 'none') color = 'white';\n            \n            if (dim.width < this.boxInit.width) this.boxInit.width = dim.width;\n            if (dim.height < this.boxInit.height) this.boxInit.height= dim.height;\n\n\t\t\t\n            rect = new JSYG('<rect>').fill(color);\n            g = new JSYG('<g>').append(rect);\n\t\t\t\n            new JSYG(this.pattern)\n                .attr({id:id,patternUnits:'userSpaceOnUse'})\n                .append(g).appendTo(svg);\n\t\t\t\t\t\t\n            new JSYG(this.mask)\n                .css('fill-opacity',0.5)\n                .appendTo(svg);\n\t\t\t\n            if (this.keepRatio) this.boxInit.height = dim.height * this.boxInit.width / dim.width;\n\t\t\t\n            selection = new JSYG(this.selection)\n                .attr(this.boxInit)\n                .attr('fill',\"url(#\"+id+\")\")\n                .appendTo(svg);\n\t\t\t\t\t\t\t\t\t\n            this.editor.target(selection);\n            this.editor.displayShadow = false;\n\t\t\t\t\t\t\n            new JSYG(this.editor.pathBox).css('fill-opacity',0);\n\t\t\t\n            this.editor.ctrlsDrag.enable({\n                bounds:0\n            });\n\t\t\t\n            this.editor.ctrlsResize.enable({\n                keepRatio : this.keepRatio,\n                bounds : 0\n            });\n\t\t\t\n            this.editor.show();\n\t\t\t\t\t\t\n            this.enabled = true;\n\t\t\t\n            this.update();\n\t\t\t\n            return this;\n        }", "language": "javascript", "code": "function(opt) {\n\t\t\t\n            this.disable();\n\t\t\t\n            if (opt) this.set(opt);\n\t\t\t\n            var jNode = new JSYG(this.node),\n            dim = jNode.getDim(),\n            color = jNode.fill(),\n            svg = jNode.offsetParent(),\n            id = 'idpattern'+JSYG.rand(0,5000),\n            g,rect,selection;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n            if (!color || color == 'transparent' || color == 'none') color = 'white';\n            \n            if (dim.width < this.boxInit.width) this.boxInit.width = dim.width;\n            if (dim.height < this.boxInit.height) this.boxInit.height= dim.height;\n\n\t\t\t\n            rect = new JSYG('<rect>').fill(color);\n            g = new JSYG('<g>').append(rect);\n\t\t\t\n            new JSYG(this.pattern)\n                .attr({id:id,patternUnits:'userSpaceOnUse'})\n                .append(g).appendTo(svg);\n\t\t\t\t\t\t\n            new JSYG(this.mask)\n                .css('fill-opacity',0.5)\n                .appendTo(svg);\n\t\t\t\n            if (this.keepRatio) this.boxInit.height = dim.height * this.boxInit.width / dim.width;\n\t\t\t\n            selection = new JSYG(this.selection)\n                .attr(this.boxInit)\n                .attr('fill',\"url(#\"+id+\")\")\n                .appendTo(svg);\n\t\t\t\t\t\t\t\t\t\n            this.editor.target(selection);\n            this.editor.displayShadow = false;\n\t\t\t\t\t\t\n            new JSYG(this.editor.pathBox).css('fill-opacity',0);\n\t\t\t\n            this.editor.ctrlsDrag.enable({\n                bounds:0\n            });\n\t\t\t\n            this.editor.ctrlsResize.enable({\n                keepRatio : this.keepRatio,\n                bounds : 0\n            });\n\t\t\t\n            this.editor.show();\n\t\t\t\t\t\t\n            this.enabled = true;\n\t\t\t\n            this.update();\n\t\t\t\n            return this;\n        }", "code_tokens": ["function", "(", "opt", ")", "{", "this", ".", "disable", "(", ")", ";", "if", "(", "opt", ")", "this", ".", "set", "(", "opt", ")", ";", "var", "jNode", "=", "new", "JSYG", "(", "this", ".", "node", ")", ",", "dim", "=", "jNode", ".", "getDim", "(", ")", ",", "color", "=", "jNode", ".", "fill", "(", ")", ",", "svg", "=", "jNode", ".", "offsetParent", "(", ")", ",", "id", "=", "'idpattern'", "+", "JSYG", ".", "rand", "(", "0", ",", "5000", ")", ",", "g", ",", "rect", ",", "selection", ";", "if", "(", "!", "color", "||", "color", "==", "'transparent'", "||", "color", "==", "'none'", ")", "color", "=", "'white'", ";", "if", "(", "dim", ".", "width", "<", "this", ".", "boxInit", ".", "width", ")", "this", ".", "boxInit", ".", "width", "=", "dim", ".", "width", ";", "if", "(", "dim", ".", "height", "<", "this", ".", "boxInit", ".", "height", ")", "this", ".", "boxInit", ".", "height", "=", "dim", ".", "height", ";", "rect", "=", "new", "JSYG", "(", "'<rect>'", ")", ".", "fill", "(", "color", ")", ";", "g", "=", "new", "JSYG", "(", "'<g>'", ")", ".", "append", "(", "rect", ")", ";", "new", "JSYG", "(", "this", ".", "pattern", ")", ".", "attr", "(", "{", "id", ":", "id", ",", "patternUnits", ":", "'userSpaceOnUse'", "}", ")", ".", "append", "(", "g", ")", ".", "appendTo", "(", "svg", ")", ";", "new", "JSYG", "(", "this", ".", "mask", ")", ".", "css", "(", "'fill-opacity'", ",", "0.5", ")", ".", "appendTo", "(", "svg", ")", ";", "if", "(", "this", ".", "keepRatio", ")", "this", ".", "boxInit", ".", "height", "=", "dim", ".", "height", "*", "this", ".", "boxInit", ".", "width", "/", "dim", ".", "width", ";", "selection", "=", "new", "JSYG", "(", "this", ".", "selection", ")", ".", "attr", "(", "this", ".", "boxInit", ")", ".", "attr", "(", "'fill'", ",", "\"url(#\"", "+", "id", "+", "\")\"", ")", ".", "appendTo", "(", "svg", ")", ";", "this", ".", "editor", ".", "target", "(", "selection", ")", ";", "this", ".", "editor", ".", "displayShadow", "=", "false", ";", "new", "JSYG", "(", "this", ".", "editor", ".", "pathBox", ")", ".", "css", "(", "'fill-opacity'", ",", "0", ")", ";", "this", ".", "editor", ".", "ctrlsDrag", ".", "enable", "(", "{", "bounds", ":", "0", "}", ")", ";", "this", ".", "editor", ".", "ctrlsResize", ".", "enable", "(", "{", "keepRatio", ":", "this", ".", "keepRatio", ",", "bounds", ":", "0", "}", ")", ";", "this", ".", "editor", ".", "show", "(", ")", ";", "this", ".", "enabled", "=", "true", ";", "this", ".", "update", "(", ")", ";", "return", "this", ";", "}"], "docstring": "Active le recadrage\n@param opt optionnel, objet d\u00e9finissant les options\n@returns {CropAndResize}", "docstring_tokens": ["Active", "le", "recadrage"], "sha": "a48e13e5dfa393dc88fbd7d34118cabc7da7db75", "url": "https://github.com/YannickBochatay/JSYG.CropAndResize/blob/a48e13e5dfa393dc88fbd7d34118cabc7da7db75/JSYG.CropAndResize.js#L149-L207", "partition": "test"}
{"repo": "sebleedelisle/rpi-led-control", "path": "rpi-led-control.js", "func_name": "setBrightness", "original_string": "function setBrightness(addr, intensity) {\n\t    if(addr<0 || addr>=maxDevices)\n\t\t\treturn;\n\t \tif (typeof intensity == 'undefined') return; \n\t\t\n\t\tintensity = constrain(intensity, 0, 15); \n\t    \t\n\t\tspiTransfer(addr, OP_INTENSITY,intensity);\n\n\t}", "language": "javascript", "code": "function setBrightness(addr, intensity) {\n\t    if(addr<0 || addr>=maxDevices)\n\t\t\treturn;\n\t \tif (typeof intensity == 'undefined') return; \n\t\t\n\t\tintensity = constrain(intensity, 0, 15); \n\t    \t\n\t\tspiTransfer(addr, OP_INTENSITY,intensity);\n\n\t}", "code_tokens": ["function", "setBrightness", "(", "addr", ",", "intensity", ")", "{", "if", "(", "addr", "<", "0", "||", "addr", ">=", "maxDevices", ")", "return", ";", "if", "(", "typeof", "intensity", "==", "'undefined'", ")", "return", ";", "intensity", "=", "constrain", "(", "intensity", ",", "0", ",", "15", ")", ";", "spiTransfer", "(", "addr", ",", "OP_INTENSITY", ",", "intensity", ")", ";", "}"], "docstring": "sets the brightness of the LEDs, 0 to 15", "docstring_tokens": ["sets", "the", "brightness", "of", "the", "LEDs", "0", "to", "15"], "sha": "4214ebc13f72228c0a66032a1aab0e43d56c58cd", "url": "https://github.com/sebleedelisle/rpi-led-control/blob/4214ebc13f72228c0a66032a1aab0e43d56c58cd/rpi-led-control.js#L160-L169", "partition": "test"}
{"repo": "young-steveo/bottlejs", "path": "dist/bottle.js", "func_name": "createProvider", "original_string": "function createProvider(name, Provider) {\n        var providerName, properties, container, id, decorators, middlewares;\n    \n        id = this.id;\n        container = this.container;\n        decorators = this.decorators;\n        middlewares = this.middlewares;\n        providerName = name + PROVIDER_SUFFIX;\n    \n        properties = Object.create(null);\n        properties[providerName] = {\n            configurable : true,\n            enumerable : true,\n            get : function getProvider() {\n                var instance = new Provider();\n                delete container[providerName];\n                container[providerName] = instance;\n                return instance;\n            }\n        };\n    \n        properties[name] = {\n            configurable : true,\n            enumerable : true,\n            get : function getService() {\n                var provider = container[providerName];\n                var instance;\n                if (provider) {\n                    // filter through decorators\n                    instance = getWithGlobal(decorators, name).reduce(reducer, provider.$get(container));\n    \n                    delete container[providerName];\n                    delete container[name];\n                }\n                return instance === undefined ? instance : applyMiddleware(getWithGlobal(middlewares, name),\n                    name, instance, container);\n            }\n        };\n    \n        Object.defineProperties(container, properties);\n        return this;\n    }", "language": "javascript", "code": "function createProvider(name, Provider) {\n        var providerName, properties, container, id, decorators, middlewares;\n    \n        id = this.id;\n        container = this.container;\n        decorators = this.decorators;\n        middlewares = this.middlewares;\n        providerName = name + PROVIDER_SUFFIX;\n    \n        properties = Object.create(null);\n        properties[providerName] = {\n            configurable : true,\n            enumerable : true,\n            get : function getProvider() {\n                var instance = new Provider();\n                delete container[providerName];\n                container[providerName] = instance;\n                return instance;\n            }\n        };\n    \n        properties[name] = {\n            configurable : true,\n            enumerable : true,\n            get : function getService() {\n                var provider = container[providerName];\n                var instance;\n                if (provider) {\n                    // filter through decorators\n                    instance = getWithGlobal(decorators, name).reduce(reducer, provider.$get(container));\n    \n                    delete container[providerName];\n                    delete container[name];\n                }\n                return instance === undefined ? instance : applyMiddleware(getWithGlobal(middlewares, name),\n                    name, instance, container);\n            }\n        };\n    \n        Object.defineProperties(container, properties);\n        return this;\n    }", "code_tokens": ["function", "createProvider", "(", "name", ",", "Provider", ")", "{", "var", "providerName", ",", "properties", ",", "container", ",", "id", ",", "decorators", ",", "middlewares", ";", "id", "=", "this", ".", "id", ";", "container", "=", "this", ".", "container", ";", "decorators", "=", "this", ".", "decorators", ";", "middlewares", "=", "this", ".", "middlewares", ";", "providerName", "=", "name", "+", "PROVIDER_SUFFIX", ";", "properties", "=", "Object", ".", "create", "(", "null", ")", ";", "properties", "[", "providerName", "]", "=", "{", "configurable", ":", "true", ",", "enumerable", ":", "true", ",", "get", ":", "function", "getProvider", "(", ")", "{", "var", "instance", "=", "new", "Provider", "(", ")", ";", "delete", "container", "[", "providerName", "]", ";", "container", "[", "providerName", "]", "=", "instance", ";", "return", "instance", ";", "}", "}", ";", "properties", "[", "name", "]", "=", "{", "configurable", ":", "true", ",", "enumerable", ":", "true", ",", "get", ":", "function", "getService", "(", ")", "{", "var", "provider", "=", "container", "[", "providerName", "]", ";", "var", "instance", ";", "if", "(", "provider", ")", "{", "// filter through decorators", "instance", "=", "getWithGlobal", "(", "decorators", ",", "name", ")", ".", "reduce", "(", "reducer", ",", "provider", ".", "$get", "(", "container", ")", ")", ";", "delete", "container", "[", "providerName", "]", ";", "delete", "container", "[", "name", "]", ";", "}", "return", "instance", "===", "undefined", "?", "instance", ":", "applyMiddleware", "(", "getWithGlobal", "(", "middlewares", ",", "name", ")", ",", "name", ",", "instance", ",", "container", ")", ";", "}", "}", ";", "Object", ".", "defineProperties", "(", "container", ",", "properties", ")", ";", "return", "this", ";", "}"], "docstring": "Create the provider properties on the container\n\n@param String name\n@param Function Provider\n@return Bottle", "docstring_tokens": ["Create", "the", "provider", "properties", "on", "the", "container"], "sha": "2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51", "url": "https://github.com/young-steveo/bottlejs/blob/2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51/dist/bottle.js#L176-L217", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "", "original_string": "function () {\n      var sizeDelta = 0;\n      var averageSpeed = 0;\n      each(this.files, function (file) {\n        if (!file.paused && !file.error) {\n          sizeDelta += file.size - file.sizeUploaded();\n          averageSpeed += file.averageSpeed;\n        }\n      });\n      if (sizeDelta && !averageSpeed) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (!sizeDelta && !averageSpeed) {\n        return 0;\n      }\n      return Math.floor(sizeDelta / averageSpeed);\n    }", "language": "javascript", "code": "function () {\n      var sizeDelta = 0;\n      var averageSpeed = 0;\n      each(this.files, function (file) {\n        if (!file.paused && !file.error) {\n          sizeDelta += file.size - file.sizeUploaded();\n          averageSpeed += file.averageSpeed;\n        }\n      });\n      if (sizeDelta && !averageSpeed) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (!sizeDelta && !averageSpeed) {\n        return 0;\n      }\n      return Math.floor(sizeDelta / averageSpeed);\n    }", "code_tokens": ["function", "(", ")", "{", "var", "sizeDelta", "=", "0", ";", "var", "averageSpeed", "=", "0", ";", "each", "(", "this", ".", "files", ",", "function", "(", "file", ")", "{", "if", "(", "!", "file", ".", "paused", "&&", "!", "file", ".", "error", ")", "{", "sizeDelta", "+=", "file", ".", "size", "-", "file", ".", "sizeUploaded", "(", ")", ";", "averageSpeed", "+=", "file", ".", "averageSpeed", ";", "}", "}", ")", ";", "if", "(", "sizeDelta", "&&", "!", "averageSpeed", ")", "{", "return", "Number", ".", "POSITIVE_INFINITY", ";", "}", "if", "(", "!", "sizeDelta", "&&", "!", "averageSpeed", ")", "{", "return", "0", ";", "}", "return", "Math", ".", "floor", "(", "sizeDelta", "/", "averageSpeed", ")", ";", "}"], "docstring": "Returns remaining time to upload all files in seconds. Accuracy is based on average speed.\nIf speed is zero, time remaining will be equal to positive infinity `Number.POSITIVE_INFINITY`\n@function\n@returns {number}", "docstring_tokens": ["Returns", "remaining", "time", "to", "upload", "all", "files", "in", "seconds", ".", "Accuracy", "is", "based", "on", "average", "speed", ".", "If", "speed", "is", "zero", "time", "remaining", "will", "be", "equal", "to", "positive", "infinity", "Number", ".", "POSITIVE_INFINITY"], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L677-L693", "partition": "test"}
{"repo": "malko/whitewalker-adapters", "path": "utils.js", "func_name": "writeConfig", "original_string": "function writeConfig(adapterName, path, config){\n\tvar adapter = getAdapterInstance(adapterName);\n\treturn adapter.configWriter(normalizeAdapterConfigPath(adapter, path), config);\n}", "language": "javascript", "code": "function writeConfig(adapterName, path, config){\n\tvar adapter = getAdapterInstance(adapterName);\n\treturn adapter.configWriter(normalizeAdapterConfigPath(adapter, path), config);\n}", "code_tokens": ["function", "writeConfig", "(", "adapterName", ",", "path", ",", "config", ")", "{", "var", "adapter", "=", "getAdapterInstance", "(", "adapterName", ")", ";", "return", "adapter", ".", "configWriter", "(", "normalizeAdapterConfigPath", "(", "adapter", ",", "path", ")", ",", "config", ")", ";", "}"], "docstring": "write a config for given adapter in given path\n@param {string} adapterName the name of the adapter we want to use\n@param {string} path file or directory where to write the config. In case of a directory will automatically append the adapter.configFileName\n@param {object} config the config to write", "docstring_tokens": ["write", "a", "config", "for", "given", "adapter", "in", "given", "path"], "sha": "7ad332f061e034a3722a1892510e40b7d5b48338", "url": "https://github.com/malko/whitewalker-adapters/blob/7ad332f061e034a3722a1892510e40b7d5b48338/utils.js#L69-L72", "partition": "test"}
{"repo": "othiym23/async-listener", "path": "glue.js", "func_name": "simpleWrap", "original_string": "function simpleWrap(original, list, length) {\n  inAsyncTick = true;\n  for (var i = 0; i < length; ++i) {\n    var listener = list[i];\n    if (listener.create) listener.create(listener.data);\n  }\n  inAsyncTick = false;\n\n  // still need to make sure nested async calls are made in the context\n  // of the listeners active at their creation\n  return function () {\n    listenerStack.push(listeners);\n    listeners = union(list, listeners);\n\n    var returned = original.apply(this, arguments);\n\n    listeners = listenerStack.pop();\n\n    return returned;\n  };\n}", "language": "javascript", "code": "function simpleWrap(original, list, length) {\n  inAsyncTick = true;\n  for (var i = 0; i < length; ++i) {\n    var listener = list[i];\n    if (listener.create) listener.create(listener.data);\n  }\n  inAsyncTick = false;\n\n  // still need to make sure nested async calls are made in the context\n  // of the listeners active at their creation\n  return function () {\n    listenerStack.push(listeners);\n    listeners = union(list, listeners);\n\n    var returned = original.apply(this, arguments);\n\n    listeners = listenerStack.pop();\n\n    return returned;\n  };\n}", "code_tokens": ["function", "simpleWrap", "(", "original", ",", "list", ",", "length", ")", "{", "inAsyncTick", "=", "true", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "length", ";", "++", "i", ")", "{", "var", "listener", "=", "list", "[", "i", "]", ";", "if", "(", "listener", ".", "create", ")", "listener", ".", "create", "(", "listener", ".", "data", ")", ";", "}", "inAsyncTick", "=", "false", ";", "// still need to make sure nested async calls are made in the context", "// of the listeners active at their creation", "return", "function", "(", ")", "{", "listenerStack", ".", "push", "(", "listeners", ")", ";", "listeners", "=", "union", "(", "list", ",", "listeners", ")", ";", "var", "returned", "=", "original", ".", "apply", "(", "this", ",", "arguments", ")", ";", "listeners", "=", "listenerStack", ".", "pop", "(", ")", ";", "return", "returned", ";", "}", ";", "}"], "docstring": "for performance in the case where there are no handlers, just the listener", "docstring_tokens": ["for", "performance", "in", "the", "case", "where", "there", "are", "no", "handlers", "just", "the", "listener"], "sha": "01a02ee123db3d4a98e0cc5dda6f8ef82c55f81e", "url": "https://github.com/othiym23/async-listener/blob/01a02ee123db3d4a98e0cc5dda6f8ef82c55f81e/glue.js#L363-L383", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Module.js", "func_name": "_multiModuleStart", "original_string": "function _multiModuleStart(oInstance, aModulesIds, sIdInstance, oData, bSingle) {\n  var aInstancesIds, aData, aSingle, nIndex, nLenModules, sModuleId;\n  if (isArray(sIdInstance)) {\n    aInstancesIds = copyArray(sIdInstance);\n  }\n  if (isArray(oData)) {\n    aData = copyArray(oData);\n  }\n  if (isArray(bSingle)) {\n    aSingle = copyArray(bSingle);\n  }\n  for (nIndex = 0, nLenModules = aModulesIds.length; nIndex < nLenModules; nIndex++) {\n    sModuleId = aModulesIds[nIndex];\n    sIdInstance = aInstancesIds && aInstancesIds[nIndex] || generateUniqueKey();\n    oData = aData && aData[nIndex] || oData;\n    bSingle = aSingle && aSingle[nIndex] || bSingle;\n    startSingleModule(oInstance, sModuleId, sIdInstance, oData, bSingle);\n  }\n}", "language": "javascript", "code": "function _multiModuleStart(oInstance, aModulesIds, sIdInstance, oData, bSingle) {\n  var aInstancesIds, aData, aSingle, nIndex, nLenModules, sModuleId;\n  if (isArray(sIdInstance)) {\n    aInstancesIds = copyArray(sIdInstance);\n  }\n  if (isArray(oData)) {\n    aData = copyArray(oData);\n  }\n  if (isArray(bSingle)) {\n    aSingle = copyArray(bSingle);\n  }\n  for (nIndex = 0, nLenModules = aModulesIds.length; nIndex < nLenModules; nIndex++) {\n    sModuleId = aModulesIds[nIndex];\n    sIdInstance = aInstancesIds && aInstancesIds[nIndex] || generateUniqueKey();\n    oData = aData && aData[nIndex] || oData;\n    bSingle = aSingle && aSingle[nIndex] || bSingle;\n    startSingleModule(oInstance, sModuleId, sIdInstance, oData, bSingle);\n  }\n}", "code_tokens": ["function", "_multiModuleStart", "(", "oInstance", ",", "aModulesIds", ",", "sIdInstance", ",", "oData", ",", "bSingle", ")", "{", "var", "aInstancesIds", ",", "aData", ",", "aSingle", ",", "nIndex", ",", "nLenModules", ",", "sModuleId", ";", "if", "(", "isArray", "(", "sIdInstance", ")", ")", "{", "aInstancesIds", "=", "copyArray", "(", "sIdInstance", ")", ";", "}", "if", "(", "isArray", "(", "oData", ")", ")", "{", "aData", "=", "copyArray", "(", "oData", ")", ";", "}", "if", "(", "isArray", "(", "bSingle", ")", ")", "{", "aSingle", "=", "copyArray", "(", "bSingle", ")", ";", "}", "for", "(", "nIndex", "=", "0", ",", "nLenModules", "=", "aModulesIds", ".", "length", ";", "nIndex", "<", "nLenModules", ";", "nIndex", "++", ")", "{", "sModuleId", "=", "aModulesIds", "[", "nIndex", "]", ";", "sIdInstance", "=", "aInstancesIds", "&&", "aInstancesIds", "[", "nIndex", "]", "||", "generateUniqueKey", "(", ")", ";", "oData", "=", "aData", "&&", "aData", "[", "nIndex", "]", "||", "oData", ";", "bSingle", "=", "aSingle", "&&", "aSingle", "[", "nIndex", "]", "||", "bSingle", ";", "startSingleModule", "(", "oInstance", ",", "sModuleId", ",", "sIdInstance", ",", "oData", ",", "bSingle", ")", ";", "}", "}"], "docstring": "start more than one module at the same time.\n@param {Object} oInstance\n@param {Array<String>} aModulesIds\n@param {String} sIdInstance\n@param {Object} oData\n@param {Boolean} bSingle\n@private", "docstring_tokens": ["start", "more", "than", "one", "module", "at", "the", "same", "time", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Module.js#L207-L225", "partition": "test"}
{"repo": "Rudellandy/console2file", "path": "lib/index.js", "func_name": "getOptions", "original_string": "function getOptions(messageType) {\n        const options = Object.assign({}, _defaults);\n        if (messageType in _options) {\n            Object.assign(options, _options[messageType]);\n        }\n        return options;\n    }", "language": "javascript", "code": "function getOptions(messageType) {\n        const options = Object.assign({}, _defaults);\n        if (messageType in _options) {\n            Object.assign(options, _options[messageType]);\n        }\n        return options;\n    }", "code_tokens": ["function", "getOptions", "(", "messageType", ")", "{", "const", "options", "=", "Object", ".", "assign", "(", "{", "}", ",", "_defaults", ")", ";", "if", "(", "messageType", "in", "_options", ")", "{", "Object", ".", "assign", "(", "options", ",", "_options", "[", "messageType", "]", ")", ";", "}", "return", "options", ";", "}"], "docstring": "Returns options for specified message type\n@param {string} messageType\n@returns {IOptions}", "docstring_tokens": ["Returns", "options", "for", "specified", "message", "type"], "sha": "221ac5b86c72b620dd9804b39fb6433c79d83111", "url": "https://github.com/Rudellandy/console2file/blob/221ac5b86c72b620dd9804b39fb6433c79d83111/lib/index.js#L47-L53", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/collections/Form/FormField.js", "func_name": "FormField", "original_string": "function FormField(props) {\n  const {\n    children,\n    className,\n    content,\n    control,\n    disabled,\n    error,\n    inline,\n    label,\n    required,\n    type,\n    width,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(required, 'required'),\n    useWidthProp(width, 'wide'),\n    'field',\n    className,\n  )\n  const rest = getUnhandledProps(FormField, props)\n  const ElementType = getElementType(FormField, props)\n\n  // ----------------------------------------\n  // No Control\n  // ----------------------------------------\n\n  if (_.isNil(control)) {\n    if (_.isNil(label)) {\n      return (\n        <ElementType {...rest} className={classes}>\n          {childrenUtils.isNil(children) ? content : children}\n        </ElementType>\n      )\n    }\n\n    return (\n      <ElementType {...rest} className={classes}>\n        {createHTMLLabel(label, { autoGenerateKey: false })}\n      </ElementType>\n    )\n  }\n\n  // ----------------------------------------\n  // Checkbox/Radio Control\n  // ----------------------------------------\n  const controlProps = { ...rest, content, children, disabled, required, type }\n\n  // wrap HTML checkboxes/radios in the label\n  if (control === 'input' && (type === 'checkbox' || type === 'radio')) {\n    return (\n      <ElementType className={classes}>\n        <label>\n          {createElement(control, controlProps)} {label}\n        </label>\n      </ElementType>\n    )\n  }\n\n  // pass label prop to controls that support it\n  if (control === Checkbox || control === Radio) {\n    return (\n      <ElementType className={classes}>\n        {createElement(control, { ...controlProps, label })}\n      </ElementType>\n    )\n  }\n\n  // ----------------------------------------\n  // Other Control\n  // ----------------------------------------\n\n  return (\n    <ElementType className={classes}>\n      {createHTMLLabel(label, {\n        defaultProps: { htmlFor: _.get(controlProps, 'id') },\n        autoGenerateKey: false,\n      })}\n      {createElement(control, controlProps)}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function FormField(props) {\n  const {\n    children,\n    className,\n    content,\n    control,\n    disabled,\n    error,\n    inline,\n    label,\n    required,\n    type,\n    width,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(inline, 'inline'),\n    useKeyOnly(required, 'required'),\n    useWidthProp(width, 'wide'),\n    'field',\n    className,\n  )\n  const rest = getUnhandledProps(FormField, props)\n  const ElementType = getElementType(FormField, props)\n\n  // ----------------------------------------\n  // No Control\n  // ----------------------------------------\n\n  if (_.isNil(control)) {\n    if (_.isNil(label)) {\n      return (\n        <ElementType {...rest} className={classes}>\n          {childrenUtils.isNil(children) ? content : children}\n        </ElementType>\n      )\n    }\n\n    return (\n      <ElementType {...rest} className={classes}>\n        {createHTMLLabel(label, { autoGenerateKey: false })}\n      </ElementType>\n    )\n  }\n\n  // ----------------------------------------\n  // Checkbox/Radio Control\n  // ----------------------------------------\n  const controlProps = { ...rest, content, children, disabled, required, type }\n\n  // wrap HTML checkboxes/radios in the label\n  if (control === 'input' && (type === 'checkbox' || type === 'radio')) {\n    return (\n      <ElementType className={classes}>\n        <label>\n          {createElement(control, controlProps)} {label}\n        </label>\n      </ElementType>\n    )\n  }\n\n  // pass label prop to controls that support it\n  if (control === Checkbox || control === Radio) {\n    return (\n      <ElementType className={classes}>\n        {createElement(control, { ...controlProps, label })}\n      </ElementType>\n    )\n  }\n\n  // ----------------------------------------\n  // Other Control\n  // ----------------------------------------\n\n  return (\n    <ElementType className={classes}>\n      {createHTMLLabel(label, {\n        defaultProps: { htmlFor: _.get(controlProps, 'id') },\n        autoGenerateKey: false,\n      })}\n      {createElement(control, controlProps)}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "FormField", "(", "props", ")", "{", "const", "{", "children", ",", "className", ",", "content", ",", "control", ",", "disabled", ",", "error", ",", "inline", ",", "label", ",", "required", ",", "type", ",", "width", ",", "}", "=", "props", "const", "classes", "=", "cx", "(", "useKeyOnly", "(", "disabled", ",", "'disabled'", ")", ",", "useKeyOnly", "(", "error", ",", "'error'", ")", ",", "useKeyOnly", "(", "inline", ",", "'inline'", ")", ",", "useKeyOnly", "(", "required", ",", "'required'", ")", ",", "useWidthProp", "(", "width", ",", "'wide'", ")", ",", "'field'", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "FormField", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "FormField", ",", "props", ")", "// ----------------------------------------", "// No Control", "// ----------------------------------------", "if", "(", "_", ".", "isNil", "(", "control", ")", ")", "{", "if", "(", "_", ".", "isNil", "(", "label", ")", ")", "{", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n          ", "{", "childrenUtils", ".", "isNil", "(", "children", ")", "?", "content", ":", "children", "}", "\n        ", "<", "/", "ElementType", ">", ")", "}", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "createHTMLLabel", "(", "label", ",", "{", "autoGenerateKey", ":", "false", "}", ")", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "// ----------------------------------------", "// Checkbox/Radio Control", "// ----------------------------------------", "const", "controlProps", "=", "{", "...", "rest", ",", "content", ",", "children", ",", "disabled", ",", "required", ",", "type", "}", "// wrap HTML checkboxes/radios in the label", "if", "(", "control", "===", "'input'", "&&", "(", "type", "===", "'checkbox'", "||", "type", "===", "'radio'", ")", ")", "{", "return", "(", "<", "ElementType", "className", "=", "{", "classes", "}", ">", "\n        ", "<", "label", ">", "\n          ", "{", "createElement", "(", "control", ",", "controlProps", ")", "}", " ", "{", "label", "}", "\n        ", "<", "/", "label", ">", "\n      ", "<", "/", "ElementType", ">", ")", "}", "// pass label prop to controls that support it", "if", "(", "control", "===", "Checkbox", "||", "control", "===", "Radio", ")", "{", "return", "(", "<", "ElementType", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "createElement", "(", "control", ",", "{", "...", "controlProps", ",", "label", "}", ")", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "// ----------------------------------------", "// Other Control", "// ----------------------------------------", "return", "(", "<", "ElementType", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "createHTMLLabel", "(", "label", ",", "{", "defaultProps", ":", "{", "htmlFor", ":", "_", ".", "get", "(", "controlProps", ",", "'id'", ")", "}", ",", "autoGenerateKey", ":", "false", ",", "}", ")", "}", "\n      ", "{", "createElement", "(", "control", ",", "controlProps", ")", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A field is a form element containing a label and an input.\n@see Form\n@see Button\n@see Checkbox\n@see Dropdown\n@see Input\n@see Radio\n@see Select\n@see Visibility", "docstring_tokens": ["A", "field", "is", "a", "form", "element", "containing", "a", "label", "and", "an", "input", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Form/FormField.js#L30-L115", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/ComponentManager.js", "func_name": "", "original_string": "function(component, defaultType) {\n        if (component.isComponent) {\n            return component;\n        }\n        else if (Ext.isString(component)) {\n            return Ext.createByAlias('widget.' + component);\n        }\n        else {\n            var type = component.xtype || defaultType;\n\n            return Ext.createByAlias('widget.' + type, component);\n        }\n    }", "language": "javascript", "code": "function(component, defaultType) {\n        if (component.isComponent) {\n            return component;\n        }\n        else if (Ext.isString(component)) {\n            return Ext.createByAlias('widget.' + component);\n        }\n        else {\n            var type = component.xtype || defaultType;\n\n            return Ext.createByAlias('widget.' + type, component);\n        }\n    }", "code_tokens": ["function", "(", "component", ",", "defaultType", ")", "{", "if", "(", "component", ".", "isComponent", ")", "{", "return", "component", ";", "}", "else", "if", "(", "Ext", ".", "isString", "(", "component", ")", ")", "{", "return", "Ext", ".", "createByAlias", "(", "'widget.'", "+", "component", ")", ";", "}", "else", "{", "var", "type", "=", "component", ".", "xtype", "||", "defaultType", ";", "return", "Ext", ".", "createByAlias", "(", "'widget.'", "+", "type", ",", "component", ")", ";", "}", "}"], "docstring": "Creates a new Component from the specified config object using the\nconfig object's `xtype` to determine the class to instantiate.\n@param {Object} component A configuration object for the Component you wish to create.\n@param {Function} [defaultType] The constructor to provide the default Component type if\nthe config object does not contain a `xtype`. (Optional if the config contains an `xtype`).\n@return {Ext.Component} The newly instantiated Component.", "docstring_tokens": ["Creates", "a", "new", "Component", "from", "the", "specified", "config", "object", "using", "the", "config", "object", "s", "xtype", "to", "determine", "the", "class", "to", "instantiate", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/ComponentManager.js#L97-L109", "partition": "test"}
{"repo": "mysticatea/event-target-shim", "path": "dist/event-target-shim.js", "func_name": "defineEventAttributeDescriptor", "original_string": "function defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}", "language": "javascript", "code": "function defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}", "code_tokens": ["function", "defineEventAttributeDescriptor", "(", "eventName", ")", "{", "return", "{", "get", "(", ")", "{", "const", "listeners", "=", "getListeners", "(", "this", ")", ";", "let", "node", "=", "listeners", ".", "get", "(", "eventName", ")", ";", "while", "(", "node", "!=", "null", ")", "{", "if", "(", "node", ".", "listenerType", "===", "ATTRIBUTE", ")", "{", "return", "node", ".", "listener", "}", "node", "=", "node", ".", "next", ";", "}", "return", "null", "}", ",", "set", "(", "listener", ")", "{", "if", "(", "typeof", "listener", "!==", "\"function\"", "&&", "!", "isObject", "(", "listener", ")", ")", "{", "listener", "=", "null", ";", "// eslint-disable-line no-param-reassign", "}", "const", "listeners", "=", "getListeners", "(", "this", ")", ";", "// Traverse to the tail while removing old value.", "let", "prev", "=", "null", ";", "let", "node", "=", "listeners", ".", "get", "(", "eventName", ")", ";", "while", "(", "node", "!=", "null", ")", "{", "if", "(", "node", ".", "listenerType", "===", "ATTRIBUTE", ")", "{", "// Remove old value.", "if", "(", "prev", "!==", "null", ")", "{", "prev", ".", "next", "=", "node", ".", "next", ";", "}", "else", "if", "(", "node", ".", "next", "!==", "null", ")", "{", "listeners", ".", "set", "(", "eventName", ",", "node", ".", "next", ")", ";", "}", "else", "{", "listeners", ".", "delete", "(", "eventName", ")", ";", "}", "}", "else", "{", "prev", "=", "node", ";", "}", "node", "=", "node", ".", "next", ";", "}", "// Add new value.", "if", "(", "listener", "!==", "null", ")", "{", "const", "newNode", "=", "{", "listener", ",", "listenerType", ":", "ATTRIBUTE", ",", "passive", ":", "false", ",", "once", ":", "false", ",", "next", ":", "null", ",", "}", ";", "if", "(", "prev", "===", "null", ")", "{", "listeners", ".", "set", "(", "eventName", ",", "newNode", ")", ";", "}", "else", "{", "prev", ".", "next", "=", "newNode", ";", "}", "}", "}", ",", "configurable", ":", "true", ",", "enumerable", ":", "true", ",", "}", "}"], "docstring": "Get the property descriptor for the event attribute of a given event.\n@param {string} eventName The event name to get property descriptor.\n@returns {PropertyDescriptor} The property descriptor.\n@private", "docstring_tokens": ["Get", "the", "property", "descriptor", "for", "the", "event", "attribute", "of", "a", "given", "event", "."], "sha": "89a7c7cb62971c45ae566a47f42436af923011b9", "url": "https://github.com/mysticatea/event-target-shim/blob/89a7c7cb62971c45ae566a47f42436af923011b9/dist/event-target-shim.js#L542-L601", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/dom/Element.static.js", "func_name": "", "original_string": "function(form) {\n        var fElements = form.elements || (document.forms[form] || Ext.getDom(form)).elements,\n            hasSubmit = false,\n            encoder = encodeURIComponent,\n            name,\n            data = '',\n            type,\n            hasValue;\n\n        Ext.each(fElements, function(element) {\n            name = element.name;\n            type = element.type;\n\n            if (!element.disabled && name) {\n                if (/select-(one|multiple)/i.test(type)) {\n                    Ext.each(element.options, function(opt) {\n                        if (opt.selected) {\n                            hasValue = opt.hasAttribute ? opt.hasAttribute('value') : opt.getAttributeNode('value').specified;\n                            data += Ext.String.format(\"{0}={1}&\", encoder(name), encoder(hasValue ? opt.value : opt.text));\n                        }\n                    });\n                } else if (!(/file|undefined|reset|button/i.test(type))) {\n                    if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {\n                        data += encoder(name) + '=' + encoder(element.value) + '&';\n                        hasSubmit = /submit/i.test(type);\n                    }\n                }\n            }\n        });\n\n        return data.substr(0, data.length - 1);\n    }", "language": "javascript", "code": "function(form) {\n        var fElements = form.elements || (document.forms[form] || Ext.getDom(form)).elements,\n            hasSubmit = false,\n            encoder = encodeURIComponent,\n            name,\n            data = '',\n            type,\n            hasValue;\n\n        Ext.each(fElements, function(element) {\n            name = element.name;\n            type = element.type;\n\n            if (!element.disabled && name) {\n                if (/select-(one|multiple)/i.test(type)) {\n                    Ext.each(element.options, function(opt) {\n                        if (opt.selected) {\n                            hasValue = opt.hasAttribute ? opt.hasAttribute('value') : opt.getAttributeNode('value').specified;\n                            data += Ext.String.format(\"{0}={1}&\", encoder(name), encoder(hasValue ? opt.value : opt.text));\n                        }\n                    });\n                } else if (!(/file|undefined|reset|button/i.test(type))) {\n                    if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {\n                        data += encoder(name) + '=' + encoder(element.value) + '&';\n                        hasSubmit = /submit/i.test(type);\n                    }\n                }\n            }\n        });\n\n        return data.substr(0, data.length - 1);\n    }", "code_tokens": ["function", "(", "form", ")", "{", "var", "fElements", "=", "form", ".", "elements", "||", "(", "document", ".", "forms", "[", "form", "]", "||", "Ext", ".", "getDom", "(", "form", ")", ")", ".", "elements", ",", "hasSubmit", "=", "false", ",", "encoder", "=", "encodeURIComponent", ",", "name", ",", "data", "=", "''", ",", "type", ",", "hasValue", ";", "Ext", ".", "each", "(", "fElements", ",", "function", "(", "element", ")", "{", "name", "=", "element", ".", "name", ";", "type", "=", "element", ".", "type", ";", "if", "(", "!", "element", ".", "disabled", "&&", "name", ")", "{", "if", "(", "/", "select-(one|multiple)", "/", "i", ".", "test", "(", "type", ")", ")", "{", "Ext", ".", "each", "(", "element", ".", "options", ",", "function", "(", "opt", ")", "{", "if", "(", "opt", ".", "selected", ")", "{", "hasValue", "=", "opt", ".", "hasAttribute", "?", "opt", ".", "hasAttribute", "(", "'value'", ")", ":", "opt", ".", "getAttributeNode", "(", "'value'", ")", ".", "specified", ";", "data", "+=", "Ext", ".", "String", ".", "format", "(", "\"{0}={1}&\"", ",", "encoder", "(", "name", ")", ",", "encoder", "(", "hasValue", "?", "opt", ".", "value", ":", "opt", ".", "text", ")", ")", ";", "}", "}", ")", ";", "}", "else", "if", "(", "!", "(", "/", "file|undefined|reset|button", "/", "i", ".", "test", "(", "type", ")", ")", ")", "{", "if", "(", "!", "(", "/", "radio|checkbox", "/", "i", ".", "test", "(", "type", ")", "&&", "!", "element", ".", "checked", ")", "&&", "!", "(", "type", "==", "'submit'", "&&", "hasSubmit", ")", ")", "{", "data", "+=", "encoder", "(", "name", ")", "+", "'='", "+", "encoder", "(", "element", ".", "value", ")", "+", "'&'", ";", "hasSubmit", "=", "/", "submit", "/", "i", ".", "test", "(", "type", ")", ";", "}", "}", "}", "}", ")", ";", "return", "data", ".", "substr", "(", "0", ",", "data", ".", "length", "-", "1", ")", ";", "}"], "docstring": "Serializes a DOM form into a url encoded string\n@deprecated 2.0.0 Please see {@link Ext.form.Panel#getValues} instead\n@param {Object} form The form\n@return {String} The url encoded form", "docstring_tokens": ["Serializes", "a", "DOM", "form", "into", "a", "url", "encoded", "string"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/dom/Element.static.js#L200-L231", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/input-generators/sitemap-index.js", "func_name": "prepareWrite", "original_string": "function prepareWrite (outputPath, callback) {\n  var path = pathLib.parse(outputPath);\n  var dir = pathLib.join(path.root, path.dir);\n  mkdirp(dir, callback);\n}", "language": "javascript", "code": "function prepareWrite (outputPath, callback) {\n  var path = pathLib.parse(outputPath);\n  var dir = pathLib.join(path.root, path.dir);\n  mkdirp(dir, callback);\n}", "code_tokens": ["function", "prepareWrite", "(", "outputPath", ",", "callback", ")", "{", "var", "path", "=", "pathLib", ".", "parse", "(", "outputPath", ")", ";", "var", "dir", "=", "pathLib", ".", "join", "(", "path", ".", "root", ",", "path", ".", "dir", ")", ";", "mkdirp", "(", "dir", ",", "callback", ")", ";", "}"], "docstring": "Make sure path exists so a sitemap write can succeed.\n\n@param {String} outputPath - File path and name.\n@param {Funcion} callback - Completion callback.", "docstring_tokens": ["Make", "sure", "path", "exists", "so", "a", "sitemap", "write", "can", "succeed", "."], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/input-generators/sitemap-index.js#L39-L43", "partition": "test"}
{"repo": "apache/cordova-plugin-media", "path": "src/windows/MediaProxy.js", "func_name": "", "original_string": "function(win, lose, args) {\n        var id = args[0];\n        var srcUri = processUri(args[1]);\n\n        var dest = parseUriToPathAndFilename(srcUri);\n        var destFileName = dest.fileName;\n\n        var success = function () {\n            Media.onStatus(id, Media.MEDIA_STATE, Media.MEDIA_RUNNING);\n        };\n\n        var error = function (reason) {\n            Media.onStatus(id, Media.MEDIA_ERROR, reason);\n        };\n\n        // Initialize device\n        Media.prototype.mediaCaptureMgr = null;\n        var thisM = (Media.get(id));\n        var captureInitSettings = new Windows.Media.Capture.MediaCaptureInitializationSettings();\n        captureInitSettings.streamingCaptureMode = Windows.Media.Capture.StreamingCaptureMode.audio;\n        thisM.mediaCaptureMgr = new Windows.Media.Capture.MediaCapture();\n        thisM.mediaCaptureMgr.addEventListener(\"failed\", error);\n\n        thisM.mediaCaptureMgr.initializeAsync(captureInitSettings).done(function (result) {\n            thisM.mediaCaptureMgr.addEventListener(\"recordlimitationexceeded\", error);\n            thisM.mediaCaptureMgr.addEventListener(\"failed\", error);\n\n            // Start recording\n            Windows.Storage.ApplicationData.current.temporaryFolder.createFileAsync(destFileName, Windows.Storage.CreationCollisionOption.replaceExisting).done(function (newFile) {\n                recordedFile = newFile;\n                var encodingProfile = null;\n                switch (newFile.fileType) {\n                    case '.m4a':\n                        encodingProfile = Windows.Media.MediaProperties.MediaEncodingProfile.createM4a(Windows.Media.MediaProperties.AudioEncodingQuality.auto);\n                        break;\n                    case '.mp3':\n                        encodingProfile = Windows.Media.MediaProperties.MediaEncodingProfile.createMp3(Windows.Media.MediaProperties.AudioEncodingQuality.auto);\n                        break;\n                    case '.wma':\n                        encodingProfile = Windows.Media.MediaProperties.MediaEncodingProfile.createWma(Windows.Media.MediaProperties.AudioEncodingQuality.auto);\n                        break;\n                    default:\n                        error(\"Invalid file type for record\");\n                        break;\n                }\n                thisM.mediaCaptureMgr.startRecordToStorageFileAsync(encodingProfile, newFile).done(success, error);\n            }, error);\n        }, error);\n    }", "language": "javascript", "code": "function(win, lose, args) {\n        var id = args[0];\n        var srcUri = processUri(args[1]);\n\n        var dest = parseUriToPathAndFilename(srcUri);\n        var destFileName = dest.fileName;\n\n        var success = function () {\n            Media.onStatus(id, Media.MEDIA_STATE, Media.MEDIA_RUNNING);\n        };\n\n        var error = function (reason) {\n            Media.onStatus(id, Media.MEDIA_ERROR, reason);\n        };\n\n        // Initialize device\n        Media.prototype.mediaCaptureMgr = null;\n        var thisM = (Media.get(id));\n        var captureInitSettings = new Windows.Media.Capture.MediaCaptureInitializationSettings();\n        captureInitSettings.streamingCaptureMode = Windows.Media.Capture.StreamingCaptureMode.audio;\n        thisM.mediaCaptureMgr = new Windows.Media.Capture.MediaCapture();\n        thisM.mediaCaptureMgr.addEventListener(\"failed\", error);\n\n        thisM.mediaCaptureMgr.initializeAsync(captureInitSettings).done(function (result) {\n            thisM.mediaCaptureMgr.addEventListener(\"recordlimitationexceeded\", error);\n            thisM.mediaCaptureMgr.addEventListener(\"failed\", error);\n\n            // Start recording\n            Windows.Storage.ApplicationData.current.temporaryFolder.createFileAsync(destFileName, Windows.Storage.CreationCollisionOption.replaceExisting).done(function (newFile) {\n                recordedFile = newFile;\n                var encodingProfile = null;\n                switch (newFile.fileType) {\n                    case '.m4a':\n                        encodingProfile = Windows.Media.MediaProperties.MediaEncodingProfile.createM4a(Windows.Media.MediaProperties.AudioEncodingQuality.auto);\n                        break;\n                    case '.mp3':\n                        encodingProfile = Windows.Media.MediaProperties.MediaEncodingProfile.createMp3(Windows.Media.MediaProperties.AudioEncodingQuality.auto);\n                        break;\n                    case '.wma':\n                        encodingProfile = Windows.Media.MediaProperties.MediaEncodingProfile.createWma(Windows.Media.MediaProperties.AudioEncodingQuality.auto);\n                        break;\n                    default:\n                        error(\"Invalid file type for record\");\n                        break;\n                }\n                thisM.mediaCaptureMgr.startRecordToStorageFileAsync(encodingProfile, newFile).done(success, error);\n            }, error);\n        }, error);\n    }", "code_tokens": ["function", "(", "win", ",", "lose", ",", "args", ")", "{", "var", "id", "=", "args", "[", "0", "]", ";", "var", "srcUri", "=", "processUri", "(", "args", "[", "1", "]", ")", ";", "var", "dest", "=", "parseUriToPathAndFilename", "(", "srcUri", ")", ";", "var", "destFileName", "=", "dest", ".", "fileName", ";", "var", "success", "=", "function", "(", ")", "{", "Media", ".", "onStatus", "(", "id", ",", "Media", ".", "MEDIA_STATE", ",", "Media", ".", "MEDIA_RUNNING", ")", ";", "}", ";", "var", "error", "=", "function", "(", "reason", ")", "{", "Media", ".", "onStatus", "(", "id", ",", "Media", ".", "MEDIA_ERROR", ",", "reason", ")", ";", "}", ";", "// Initialize device", "Media", ".", "prototype", ".", "mediaCaptureMgr", "=", "null", ";", "var", "thisM", "=", "(", "Media", ".", "get", "(", "id", ")", ")", ";", "var", "captureInitSettings", "=", "new", "Windows", ".", "Media", ".", "Capture", ".", "MediaCaptureInitializationSettings", "(", ")", ";", "captureInitSettings", ".", "streamingCaptureMode", "=", "Windows", ".", "Media", ".", "Capture", ".", "StreamingCaptureMode", ".", "audio", ";", "thisM", ".", "mediaCaptureMgr", "=", "new", "Windows", ".", "Media", ".", "Capture", ".", "MediaCapture", "(", ")", ";", "thisM", ".", "mediaCaptureMgr", ".", "addEventListener", "(", "\"failed\"", ",", "error", ")", ";", "thisM", ".", "mediaCaptureMgr", ".", "initializeAsync", "(", "captureInitSettings", ")", ".", "done", "(", "function", "(", "result", ")", "{", "thisM", ".", "mediaCaptureMgr", ".", "addEventListener", "(", "\"recordlimitationexceeded\"", ",", "error", ")", ";", "thisM", ".", "mediaCaptureMgr", ".", "addEventListener", "(", "\"failed\"", ",", "error", ")", ";", "// Start recording", "Windows", ".", "Storage", ".", "ApplicationData", ".", "current", ".", "temporaryFolder", ".", "createFileAsync", "(", "destFileName", ",", "Windows", ".", "Storage", ".", "CreationCollisionOption", ".", "replaceExisting", ")", ".", "done", "(", "function", "(", "newFile", ")", "{", "recordedFile", "=", "newFile", ";", "var", "encodingProfile", "=", "null", ";", "switch", "(", "newFile", ".", "fileType", ")", "{", "case", "'.m4a'", ":", "encodingProfile", "=", "Windows", ".", "Media", ".", "MediaProperties", ".", "MediaEncodingProfile", ".", "createM4a", "(", "Windows", ".", "Media", ".", "MediaProperties", ".", "AudioEncodingQuality", ".", "auto", ")", ";", "break", ";", "case", "'.mp3'", ":", "encodingProfile", "=", "Windows", ".", "Media", ".", "MediaProperties", ".", "MediaEncodingProfile", ".", "createMp3", "(", "Windows", ".", "Media", ".", "MediaProperties", ".", "AudioEncodingQuality", ".", "auto", ")", ";", "break", ";", "case", "'.wma'", ":", "encodingProfile", "=", "Windows", ".", "Media", ".", "MediaProperties", ".", "MediaEncodingProfile", ".", "createWma", "(", "Windows", ".", "Media", ".", "MediaProperties", ".", "AudioEncodingQuality", ".", "auto", ")", ";", "break", ";", "default", ":", "error", "(", "\"Invalid file type for record\"", ")", ";", "break", ";", "}", "thisM", ".", "mediaCaptureMgr", ".", "startRecordToStorageFileAsync", "(", "encodingProfile", ",", "newFile", ")", ".", "done", "(", "success", ",", "error", ")", ";", "}", ",", "error", ")", ";", "}", ",", "error", ")", ";", "}"], "docstring": "Start recording audio", "docstring_tokens": ["Start", "recording", "audio"], "sha": "b1c135342619f773fee3e8693a46992a133efd56", "url": "https://github.com/apache/cordova-plugin-media/blob/b1c135342619f773fee3e8693a46992a133efd56/src/windows/MediaProxy.js#L182-L230", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "setParameter", "original_string": "function setParameter(parameter, value) {\n    if (this[parameter] === value) return this;\n\n    var modification = {};\n\n    modification[parameter] = value;\n\n    return this.setQueryParameters(modification);\n  }", "language": "javascript", "code": "function setParameter(parameter, value) {\n    if (this[parameter] === value) return this;\n\n    var modification = {};\n\n    modification[parameter] = value;\n\n    return this.setQueryParameters(modification);\n  }", "code_tokens": ["function", "setParameter", "(", "parameter", ",", "value", ")", "{", "if", "(", "this", "[", "parameter", "]", "===", "value", ")", "return", "this", ";", "var", "modification", "=", "{", "}", ";", "modification", "[", "parameter", "]", "=", "value", ";", "return", "this", ".", "setQueryParameters", "(", "modification", ")", ";", "}"], "docstring": "Let the user set a specific value for a given parameter. Will return the\nsame instance if the parameter is invalid or if the value is the same as the\nprevious one.\n@method\n@param {string} parameter the parameter name\n@param {any} value the value to be set, must be compliant with the definition\nof the attribute on the object\n@return {SearchParameters} the updated state", "docstring_tokens": ["Let", "the", "user", "set", "a", "specific", "value", "for", "a", "given", "parameter", ".", "Will", "return", "the", "same", "instance", "if", "the", "parameter", "is", "invalid", "or", "if", "the", "value", "is", "the", "same", "as", "the", "previous", "one", "."], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L1571-L1579", "partition": "test"}
{"repo": "genify/toolkit2", "path": "lib/meta/html.js", "func_name": "", "original_string": "function(uri,config){\n        return this._formatURI(uri,{\n            fromPage:config.fromPage,\n            pathRoot:config.output,\n            webRoot:config.webRoot\n        });\n    }", "language": "javascript", "code": "function(uri,config){\n        return this._formatURI(uri,{\n            fromPage:config.fromPage,\n            pathRoot:config.output,\n            webRoot:config.webRoot\n        });\n    }", "code_tokens": ["function", "(", "uri", ",", "config", ")", "{", "return", "this", ".", "_formatURI", "(", "uri", ",", "{", "fromPage", ":", "config", ".", "fromPage", ",", "pathRoot", ":", "config", ".", "output", ",", "webRoot", ":", "config", ".", "webRoot", "}", ")", ";", "}"], "docstring": "source map file path", "docstring_tokens": ["source", "map", "file", "path"], "sha": "bb40480731f363327e055f7120d3fd6de6336cda", "url": "https://github.com/genify/toolkit2/blob/bb40480731f363327e055f7120d3fd6de6336cda/lib/meta/html.js#L108-L114", "partition": "test"}
{"repo": "duaraghav8/Ethlint", "path": "lib/cli.js", "func_name": "createCliOptions", "original_string": "function createCliOptions(cliObject) {\n    function collect(val, memo) {\n        memo.push(val);\n        return memo;\n    }\n\n    cliObject\n        .version(`Solium version ${version}`)\n        .description(\"Linter to find & fix style and security issues in Solidity smart contracts.\")\n        .usage(\"[options] <keyword>\")\n\n        .option(\"-i, --init\", \"Create default rule configuration files\")\n        .option(\"-f, --file [filepath::String]\", \"Solidity file to lint\")\n        .option(\"-d, --dir [dirpath::String]\", \"Directory containing Solidity files to lint\")\n        .option(\"-R, --reporter [name::String]\", \"Format to report lint issues in (pretty | gcc)\", \"pretty\")\n        .option(\"-c, --config [filepath::String]\", \"Path to the .soliumrc configuration file\")\n        .option(\"-, --stdin\", \"Read input file from stdin\")\n        .option(\"--fix\", \"Fix Lint issues where possible\")\n        .option(\"--fix-dry-run\", \"Output fix diff without applying it\")\n        .option(\"--debug\", \"Display debug information\")\n        .option(\"--watch\", \"Watch for file changes\")\n        .option(\"--hot\", \"(Deprecated) Same as --watch\")\n        .option(\"--no-soliumignore\", \"Do not look for .soliumignore file\")\n        .option(\"--no-soliumrc\", \"Do not look for soliumrc configuration file\")\n        .option(\n            \"--rule [rule]\",\n            \"Rule to execute. This overrides the specified rule's configuration in soliumrc if present\",\n            collect,\n            []\n        )\n        .option(\n            \"--plugin [plugin]\",\n            \"Plugin to execute. This overrides the specified plugin's configuration in soliumrc if present\",\n            collect,\n            []\n        );\n}", "language": "javascript", "code": "function createCliOptions(cliObject) {\n    function collect(val, memo) {\n        memo.push(val);\n        return memo;\n    }\n\n    cliObject\n        .version(`Solium version ${version}`)\n        .description(\"Linter to find & fix style and security issues in Solidity smart contracts.\")\n        .usage(\"[options] <keyword>\")\n\n        .option(\"-i, --init\", \"Create default rule configuration files\")\n        .option(\"-f, --file [filepath::String]\", \"Solidity file to lint\")\n        .option(\"-d, --dir [dirpath::String]\", \"Directory containing Solidity files to lint\")\n        .option(\"-R, --reporter [name::String]\", \"Format to report lint issues in (pretty | gcc)\", \"pretty\")\n        .option(\"-c, --config [filepath::String]\", \"Path to the .soliumrc configuration file\")\n        .option(\"-, --stdin\", \"Read input file from stdin\")\n        .option(\"--fix\", \"Fix Lint issues where possible\")\n        .option(\"--fix-dry-run\", \"Output fix diff without applying it\")\n        .option(\"--debug\", \"Display debug information\")\n        .option(\"--watch\", \"Watch for file changes\")\n        .option(\"--hot\", \"(Deprecated) Same as --watch\")\n        .option(\"--no-soliumignore\", \"Do not look for .soliumignore file\")\n        .option(\"--no-soliumrc\", \"Do not look for soliumrc configuration file\")\n        .option(\n            \"--rule [rule]\",\n            \"Rule to execute. This overrides the specified rule's configuration in soliumrc if present\",\n            collect,\n            []\n        )\n        .option(\n            \"--plugin [plugin]\",\n            \"Plugin to execute. This overrides the specified plugin's configuration in soliumrc if present\",\n            collect,\n            []\n        );\n}", "code_tokens": ["function", "createCliOptions", "(", "cliObject", ")", "{", "function", "collect", "(", "val", ",", "memo", ")", "{", "memo", ".", "push", "(", "val", ")", ";", "return", "memo", ";", "}", "cliObject", ".", "version", "(", "`", "${", "version", "}", "`", ")", ".", "description", "(", "\"Linter to find & fix style and security issues in Solidity smart contracts.\"", ")", ".", "usage", "(", "\"[options] <keyword>\"", ")", ".", "option", "(", "\"-i, --init\"", ",", "\"Create default rule configuration files\"", ")", ".", "option", "(", "\"-f, --file [filepath::String]\"", ",", "\"Solidity file to lint\"", ")", ".", "option", "(", "\"-d, --dir [dirpath::String]\"", ",", "\"Directory containing Solidity files to lint\"", ")", ".", "option", "(", "\"-R, --reporter [name::String]\"", ",", "\"Format to report lint issues in (pretty | gcc)\"", ",", "\"pretty\"", ")", ".", "option", "(", "\"-c, --config [filepath::String]\"", ",", "\"Path to the .soliumrc configuration file\"", ")", ".", "option", "(", "\"-, --stdin\"", ",", "\"Read input file from stdin\"", ")", ".", "option", "(", "\"--fix\"", ",", "\"Fix Lint issues where possible\"", ")", ".", "option", "(", "\"--fix-dry-run\"", ",", "\"Output fix diff without applying it\"", ")", ".", "option", "(", "\"--debug\"", ",", "\"Display debug information\"", ")", ".", "option", "(", "\"--watch\"", ",", "\"Watch for file changes\"", ")", ".", "option", "(", "\"--hot\"", ",", "\"(Deprecated) Same as --watch\"", ")", ".", "option", "(", "\"--no-soliumignore\"", ",", "\"Do not look for .soliumignore file\"", ")", ".", "option", "(", "\"--no-soliumrc\"", ",", "\"Do not look for soliumrc configuration file\"", ")", ".", "option", "(", "\"--rule [rule]\"", ",", "\"Rule to execute. This overrides the specified rule's configuration in soliumrc if present\"", ",", "collect", ",", "[", "]", ")", ".", "option", "(", "\"--plugin [plugin]\"", ",", "\"Plugin to execute. This overrides the specified plugin's configuration in soliumrc if present\"", ",", "collect", ",", "[", "]", ")", ";", "}"], "docstring": "Function responsible for defining all the available commandline options & version information\n@param {Object} cliObject Commander Object handling the cli", "docstring_tokens": ["Function", "responsible", "for", "defining", "all", "the", "available", "commandline", "options", "&", "version", "information"], "sha": "7d264373709561148c7166601ac39370e78f74b1", "url": "https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/cli.js#L211-L247", "partition": "test"}
{"repo": "graphology/graphology-generators", "path": "random/erdos-renyi.js", "func_name": "erdosRenyiSparse", "original_string": "function erdosRenyiSparse(GraphClass, options) {\n  if (!isGraphConstructor(GraphClass))\n    throw new Error('graphology-generators/random/erdos-renyi: invalid Graph constructor.');\n\n  var order = options.order,\n      probability = options.probability,\n      rng = options.rng || Math.random;\n\n  var graph = new GraphClass();\n\n  // If user gave a size, we need to compute probability\n  if (typeof options.approximateSize === 'number') {\n    var densityFunction = density[graph.type + 'Density'];\n    probability = densityFunction(order, options.approximateSize);\n  }\n\n  if (typeof order !== 'number' || order <= 0)\n    throw new Error('graphology-generators/random/erdos-renyi: invalid `order`. Should be a positive number.');\n\n  if (typeof probability !== 'number' || probability < 0 || probability > 1)\n    throw new Error('graphology-generators/random/erdos-renyi: invalid `probability`. Should be a number between 0 and 1. Or maybe you gave an `approximateSize` exceeding the graph\\'s density.');\n\n  if (typeof rng !== 'function')\n    throw new Error('graphology-generators/random/erdos-renyi: invalid `rng`. Should be a function.');\n\n  for (var i = 0; i < order; i++)\n    graph.addNode(i);\n\n  if (probability <= 0)\n    return graph;\n\n  var w = -1,\n      lp = Math.log(1 - probability),\n      lr,\n      v;\n\n  if (graph.type !== 'undirected') {\n    v = 0;\n\n    while (v < order) {\n      lr = Math.log(1 - rng());\n      w += 1 + ((lr / lp) | 0);\n\n      // Avoiding self loops\n      if (v === w) {\n        w++;\n      }\n\n      while (v < order && order <= w) {\n        w -= order;\n        v++;\n\n        // Avoiding self loops\n        if (v === w)\n          w++;\n      }\n\n      if (v < order)\n        graph.addDirectedEdge(v, w);\n    }\n  }\n\n  w = -1;\n\n  if (graph.type !== 'directed') {\n    v = 1;\n\n    while (v < order) {\n      lr = Math.log(1 - rng());\n\n      w += 1 + ((lr / lp) | 0);\n\n      while (w >= v && v < order) {\n        w -= v;\n        v++;\n      }\n\n      if (v < order)\n        graph.addUndirectedEdge(v, w);\n    }\n  }\n\n  return graph;\n}", "language": "javascript", "code": "function erdosRenyiSparse(GraphClass, options) {\n  if (!isGraphConstructor(GraphClass))\n    throw new Error('graphology-generators/random/erdos-renyi: invalid Graph constructor.');\n\n  var order = options.order,\n      probability = options.probability,\n      rng = options.rng || Math.random;\n\n  var graph = new GraphClass();\n\n  // If user gave a size, we need to compute probability\n  if (typeof options.approximateSize === 'number') {\n    var densityFunction = density[graph.type + 'Density'];\n    probability = densityFunction(order, options.approximateSize);\n  }\n\n  if (typeof order !== 'number' || order <= 0)\n    throw new Error('graphology-generators/random/erdos-renyi: invalid `order`. Should be a positive number.');\n\n  if (typeof probability !== 'number' || probability < 0 || probability > 1)\n    throw new Error('graphology-generators/random/erdos-renyi: invalid `probability`. Should be a number between 0 and 1. Or maybe you gave an `approximateSize` exceeding the graph\\'s density.');\n\n  if (typeof rng !== 'function')\n    throw new Error('graphology-generators/random/erdos-renyi: invalid `rng`. Should be a function.');\n\n  for (var i = 0; i < order; i++)\n    graph.addNode(i);\n\n  if (probability <= 0)\n    return graph;\n\n  var w = -1,\n      lp = Math.log(1 - probability),\n      lr,\n      v;\n\n  if (graph.type !== 'undirected') {\n    v = 0;\n\n    while (v < order) {\n      lr = Math.log(1 - rng());\n      w += 1 + ((lr / lp) | 0);\n\n      // Avoiding self loops\n      if (v === w) {\n        w++;\n      }\n\n      while (v < order && order <= w) {\n        w -= order;\n        v++;\n\n        // Avoiding self loops\n        if (v === w)\n          w++;\n      }\n\n      if (v < order)\n        graph.addDirectedEdge(v, w);\n    }\n  }\n\n  w = -1;\n\n  if (graph.type !== 'directed') {\n    v = 1;\n\n    while (v < order) {\n      lr = Math.log(1 - rng());\n\n      w += 1 + ((lr / lp) | 0);\n\n      while (w >= v && v < order) {\n        w -= v;\n        v++;\n      }\n\n      if (v < order)\n        graph.addUndirectedEdge(v, w);\n    }\n  }\n\n  return graph;\n}", "code_tokens": ["function", "erdosRenyiSparse", "(", "GraphClass", ",", "options", ")", "{", "if", "(", "!", "isGraphConstructor", "(", "GraphClass", ")", ")", "throw", "new", "Error", "(", "'graphology-generators/random/erdos-renyi: invalid Graph constructor.'", ")", ";", "var", "order", "=", "options", ".", "order", ",", "probability", "=", "options", ".", "probability", ",", "rng", "=", "options", ".", "rng", "||", "Math", ".", "random", ";", "var", "graph", "=", "new", "GraphClass", "(", ")", ";", "// If user gave a size, we need to compute probability", "if", "(", "typeof", "options", ".", "approximateSize", "===", "'number'", ")", "{", "var", "densityFunction", "=", "density", "[", "graph", ".", "type", "+", "'Density'", "]", ";", "probability", "=", "densityFunction", "(", "order", ",", "options", ".", "approximateSize", ")", ";", "}", "if", "(", "typeof", "order", "!==", "'number'", "||", "order", "<=", "0", ")", "throw", "new", "Error", "(", "'graphology-generators/random/erdos-renyi: invalid `order`. Should be a positive number.'", ")", ";", "if", "(", "typeof", "probability", "!==", "'number'", "||", "probability", "<", "0", "||", "probability", ">", "1", ")", "throw", "new", "Error", "(", "'graphology-generators/random/erdos-renyi: invalid `probability`. Should be a number between 0 and 1. Or maybe you gave an `approximateSize` exceeding the graph\\'s density.'", ")", ";", "if", "(", "typeof", "rng", "!==", "'function'", ")", "throw", "new", "Error", "(", "'graphology-generators/random/erdos-renyi: invalid `rng`. Should be a function.'", ")", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "order", ";", "i", "++", ")", "graph", ".", "addNode", "(", "i", ")", ";", "if", "(", "probability", "<=", "0", ")", "return", "graph", ";", "var", "w", "=", "-", "1", ",", "lp", "=", "Math", ".", "log", "(", "1", "-", "probability", ")", ",", "lr", ",", "v", ";", "if", "(", "graph", ".", "type", "!==", "'undirected'", ")", "{", "v", "=", "0", ";", "while", "(", "v", "<", "order", ")", "{", "lr", "=", "Math", ".", "log", "(", "1", "-", "rng", "(", ")", ")", ";", "w", "+=", "1", "+", "(", "(", "lr", "/", "lp", ")", "|", "0", ")", ";", "// Avoiding self loops", "if", "(", "v", "===", "w", ")", "{", "w", "++", ";", "}", "while", "(", "v", "<", "order", "&&", "order", "<=", "w", ")", "{", "w", "-=", "order", ";", "v", "++", ";", "// Avoiding self loops", "if", "(", "v", "===", "w", ")", "w", "++", ";", "}", "if", "(", "v", "<", "order", ")", "graph", ".", "addDirectedEdge", "(", "v", ",", "w", ")", ";", "}", "}", "w", "=", "-", "1", ";", "if", "(", "graph", ".", "type", "!==", "'directed'", ")", "{", "v", "=", "1", ";", "while", "(", "v", "<", "order", ")", "{", "lr", "=", "Math", ".", "log", "(", "1", "-", "rng", "(", ")", ")", ";", "w", "+=", "1", "+", "(", "(", "lr", "/", "lp", ")", "|", "0", ")", ";", "while", "(", "w", ">=", "v", "&&", "v", "<", "order", ")", "{", "w", "-=", "v", ";", "v", "++", ";", "}", "if", "(", "v", "<", "order", ")", "graph", ".", "addUndirectedEdge", "(", "v", ",", "w", ")", ";", "}", "}", "return", "graph", ";", "}"], "docstring": "Generates a binomial graph graph with n nodes using a faster algorithm\nfor sparse graphs.\n\n@param  {Class}    GraphClass    - The Graph Class to instantiate.\n@param  {object}   options       - Options:\n@param  {number}     order       - Number of nodes in the graph.\n@param  {number}     probability - Probability for edge creation.\n@param  {function}   rng         - Custom RNG function.\n@return {Graph}", "docstring_tokens": ["Generates", "a", "binomial", "graph", "graph", "with", "n", "nodes", "using", "a", "faster", "algorithm", "for", "sparse", "graphs", "."], "sha": "bd9c36df57550fbec68a0b56040ea0dab8f81bd8", "url": "https://github.com/graphology/graphology-generators/blob/bd9c36df57550fbec68a0b56040ea0dab8f81bd8/random/erdos-renyi.js#L91-L174", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "removeData", "original_string": "function removeData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return;\n  }\n\n  // Remove all stored data\n  delete elData[id];\n\n  // Remove the elIdAttr property from the DOM node\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}", "language": "javascript", "code": "function removeData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return;\n  }\n\n  // Remove all stored data\n  delete elData[id];\n\n  // Remove the elIdAttr property from the DOM node\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}", "code_tokens": ["function", "removeData", "(", "el", ")", "{", "var", "id", "=", "el", "[", "elIdAttr", "]", ";", "if", "(", "!", "id", ")", "{", "return", ";", "}", "// Remove all stored data", "delete", "elData", "[", "id", "]", ";", "// Remove the elIdAttr property from the DOM node", "try", "{", "delete", "el", "[", "elIdAttr", "]", ";", "}", "catch", "(", "e", ")", "{", "if", "(", "el", ".", "removeAttribute", ")", "{", "el", ".", "removeAttribute", "(", "elIdAttr", ")", ";", "}", "else", "{", "// IE doesn't appear to support removeAttribute on the document element", "el", "[", "elIdAttr", "]", "=", "null", ";", "}", "}", "}"], "docstring": "Delete data for the element from the cache and the guid attr from getElementById\n\n@param {Element} el\nRemove cached data for this element.", "docstring_tokens": ["Delete", "data", "for", "the", "element", "from", "the", "cache", "and", "the", "guid", "attr", "from", "getElementById"], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L1507-L1528", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "stopOrientation", "original_string": "function stopOrientation() {\n    window.removeEventListener('deviceorientation', orientationListener);\n    controls.orientation.classList.remove('pnlm-orientation-button-active');\n    orientation = false;\n}", "language": "javascript", "code": "function stopOrientation() {\n    window.removeEventListener('deviceorientation', orientationListener);\n    controls.orientation.classList.remove('pnlm-orientation-button-active');\n    orientation = false;\n}", "code_tokens": ["function", "stopOrientation", "(", ")", "{", "window", ".", "removeEventListener", "(", "'deviceorientation'", ",", "orientationListener", ")", ";", "controls", ".", "orientation", ".", "classList", ".", "remove", "(", "'pnlm-orientation-button-active'", ")", ";", "orientation", "=", "false", ";", "}"], "docstring": "Stop using device orientation.\n@private", "docstring_tokens": ["Stop", "using", "device", "orientation", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L2307-L2311", "partition": "test"}
{"repo": "johnspackman/chrome-remote-multiplex", "path": "src/multiplex.js", "func_name": "splitName", "original_string": "function splitName(method) {\n  var pos = method.indexOf('.');\n  if (pos < 0)\n    return [ null, method ];\n  var domainName = method.substring(0, pos);\n  var methodName = method.substring(pos + 1);\n  return [ domainName, methodName ];\n}", "language": "javascript", "code": "function splitName(method) {\n  var pos = method.indexOf('.');\n  if (pos < 0)\n    return [ null, method ];\n  var domainName = method.substring(0, pos);\n  var methodName = method.substring(pos + 1);\n  return [ domainName, methodName ];\n}", "code_tokens": ["function", "splitName", "(", "method", ")", "{", "var", "pos", "=", "method", ".", "indexOf", "(", "'.'", ")", ";", "if", "(", "pos", "<", "0", ")", "return", "[", "null", ",", "method", "]", ";", "var", "domainName", "=", "method", ".", "substring", "(", "0", ",", "pos", ")", ";", "var", "methodName", "=", "method", ".", "substring", "(", "pos", "+", "1", ")", ";", "return", "[", "domainName", ",", "methodName", "]", ";", "}"], "docstring": "Splits a string into domain and method", "docstring_tokens": ["Splits", "a", "string", "into", "domain", "and", "method"], "sha": "b4588e7411a6438a31c75ac7e01c55abdde3b95d", "url": "https://github.com/johnspackman/chrome-remote-multiplex/blob/b4588e7411a6438a31c75ac7e01c55abdde3b95d/src/multiplex.js#L900-L907", "partition": "test"}
{"repo": "cyraxx/pogobuf", "path": "pogobuf/pogobuf.utils.js", "func_name": "", "original_string": "function(enumObj, val) {\n        for (var key of Object.keys(enumObj)) {\n            if (enumObj[key] === val) {\n                return key.split('_')\n                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n                    .join(' ');\n            }\n        }\n        return null;\n    }", "language": "javascript", "code": "function(enumObj, val) {\n        for (var key of Object.keys(enumObj)) {\n            if (enumObj[key] === val) {\n                return key.split('_')\n                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n                    .join(' ');\n            }\n        }\n        return null;\n    }", "code_tokens": ["function", "(", "enumObj", ",", "val", ")", "{", "for", "(", "var", "key", "of", "Object", ".", "keys", "(", "enumObj", ")", ")", "{", "if", "(", "enumObj", "[", "key", "]", "===", "val", ")", "{", "return", "key", ".", "split", "(", "'_'", ")", ".", "map", "(", "word", "=>", "word", ".", "charAt", "(", "0", ")", ".", "toUpperCase", "(", ")", "+", "word", ".", "slice", "(", "1", ")", ".", "toLowerCase", "(", ")", ")", ".", "join", "(", "' '", ")", ";", "}", "}", "return", "null", ";", "}"], "docstring": "Utility method that finds the name of the key for a given enum value and makes it\nlook a little nicer.\n@param {object} enumObj\n@param {number} val\n@returns {string}\n@static", "docstring_tokens": ["Utility", "method", "that", "finds", "the", "name", "of", "the", "key", "for", "a", "given", "enum", "value", "and", "makes", "it", "look", "a", "little", "nicer", "."], "sha": "7e905906b77d77d69bfad1a974309bf35c02d9db", "url": "https://github.com/cyraxx/pogobuf/blob/7e905906b77d77d69bfad1a974309bf35c02d9db/pogobuf/pogobuf.utils.js#L224-L233", "partition": "test"}
{"repo": "IntrospectiveSystems/xGraph", "path": "lib/xgrl.js", "func_name": "getProtocolModule", "original_string": "function getProtocolModule(protocol) {\n\treturn new Promise(function (resolve, reject) {\n\t\tlet cacheFilepath = path.join(appdata, protocol);\n\t\tif (fs.existsSync(cacheFilepath)) {\n\t\t\treturn resolve(JSON.parse(fs.readFileSync(cacheFilepath).toString()));\n\t\t}\n\n\t\tlet options = {\n\t\t\thost: 'protocols.xgraphdev.com',\n\t\t\tport: 443,\n\t\t\tpath: '/' + protocol,\n\t\t\tmethod: 'GET',\n\t\t\trejectUnauthorized: false,\n\t\t};\n\n\t\tlet req = https.request(options, function (res) {\n\t\t\tres.setEncoding('utf8');\n\t\t\tlet response = '';\n\t\t\tres.on('data', function (chunk) {\n\t\t\t\tresponse += chunk;\n\t\t\t});\n\t\t\tres.on('end', _ => {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(JSON.parse(response));\n\t\t\t\t\ttry { fs.writeFileSync(cacheFilepath, response); } catch (e) {\n\t\t\t\t\t\treject({\n\t\t\t\t\t\t\tcode: 1,\n\t\t\t\t\t\t\ttext: `fail to save protocol at ${cacheFilepath}` +\n\t\t\t\t\t\t\t\t'\\n delete file and try again'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject({ code: 0, text: 'try and retrieve locally' });\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treq.on('error', function (e) {\n\t\t\tlog.e('problem with request: ' + e.message);\n\t\t\treject({ code: 1, text: 'problem with request: ' + e.message });\n\t\t});\n\n\t\t// write data to request body\n\t\treq.end();\n\t});\n}", "language": "javascript", "code": "function getProtocolModule(protocol) {\n\treturn new Promise(function (resolve, reject) {\n\t\tlet cacheFilepath = path.join(appdata, protocol);\n\t\tif (fs.existsSync(cacheFilepath)) {\n\t\t\treturn resolve(JSON.parse(fs.readFileSync(cacheFilepath).toString()));\n\t\t}\n\n\t\tlet options = {\n\t\t\thost: 'protocols.xgraphdev.com',\n\t\t\tport: 443,\n\t\t\tpath: '/' + protocol,\n\t\t\tmethod: 'GET',\n\t\t\trejectUnauthorized: false,\n\t\t};\n\n\t\tlet req = https.request(options, function (res) {\n\t\t\tres.setEncoding('utf8');\n\t\t\tlet response = '';\n\t\t\tres.on('data', function (chunk) {\n\t\t\t\tresponse += chunk;\n\t\t\t});\n\t\t\tres.on('end', _ => {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(JSON.parse(response));\n\t\t\t\t\ttry { fs.writeFileSync(cacheFilepath, response); } catch (e) {\n\t\t\t\t\t\treject({\n\t\t\t\t\t\t\tcode: 1,\n\t\t\t\t\t\t\ttext: `fail to save protocol at ${cacheFilepath}` +\n\t\t\t\t\t\t\t\t'\\n delete file and try again'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject({ code: 0, text: 'try and retrieve locally' });\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treq.on('error', function (e) {\n\t\t\tlog.e('problem with request: ' + e.message);\n\t\t\treject({ code: 1, text: 'problem with request: ' + e.message });\n\t\t});\n\n\t\t// write data to request body\n\t\treq.end();\n\t});\n}", "code_tokens": ["function", "getProtocolModule", "(", "protocol", ")", "{", "return", "new", "Promise", "(", "function", "(", "resolve", ",", "reject", ")", "{", "let", "cacheFilepath", "=", "path", ".", "join", "(", "appdata", ",", "protocol", ")", ";", "if", "(", "fs", ".", "existsSync", "(", "cacheFilepath", ")", ")", "{", "return", "resolve", "(", "JSON", ".", "parse", "(", "fs", ".", "readFileSync", "(", "cacheFilepath", ")", ".", "toString", "(", ")", ")", ")", ";", "}", "let", "options", "=", "{", "host", ":", "'protocols.xgraphdev.com'", ",", "port", ":", "443", ",", "path", ":", "'/'", "+", "protocol", ",", "method", ":", "'GET'", ",", "rejectUnauthorized", ":", "false", ",", "}", ";", "let", "req", "=", "https", ".", "request", "(", "options", ",", "function", "(", "res", ")", "{", "res", ".", "setEncoding", "(", "'utf8'", ")", ";", "let", "response", "=", "''", ";", "res", ".", "on", "(", "'data'", ",", "function", "(", "chunk", ")", "{", "response", "+=", "chunk", ";", "}", ")", ";", "res", ".", "on", "(", "'end'", ",", "_", "=>", "{", "try", "{", "resolve", "(", "JSON", ".", "parse", "(", "response", ")", ")", ";", "try", "{", "fs", ".", "writeFileSync", "(", "cacheFilepath", ",", "response", ")", ";", "}", "catch", "(", "e", ")", "{", "reject", "(", "{", "code", ":", "1", ",", "text", ":", "`", "${", "cacheFilepath", "}", "`", "+", "'\\n delete file and try again'", "}", ")", ";", "}", "}", "catch", "(", "e", ")", "{", "reject", "(", "{", "code", ":", "0", ",", "text", ":", "'try and retrieve locally'", "}", ")", ";", "}", "}", ")", ";", "}", ")", ";", "req", ".", "on", "(", "'error'", ",", "function", "(", "e", ")", "{", "log", ".", "e", "(", "'problem with request: '", "+", "e", ".", "message", ")", ";", "reject", "(", "{", "code", ":", "1", ",", "text", ":", "'problem with request: '", "+", "e", ".", "message", "}", ")", ";", "}", ")", ";", "// write data to request body", "req", ".", "end", "(", ")", ";", "}", ")", ";", "}"], "docstring": "load protocol to access modules", "docstring_tokens": ["load", "protocol", "to", "access", "modules"], "sha": "86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0", "url": "https://github.com/IntrospectiveSystems/xGraph/blob/86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0/lib/xgrl.js#L96-L141", "partition": "test"}
{"repo": "apache/cordova-plugin-media", "path": "src/windows/MediaProxy.js", "func_name": "parseUriToPathAndFilename", "original_string": "function parseUriToPathAndFilename(uri) {\n    // Removing scheme and location, using backslashes: ms-appdata:///local/path/to/file.m4a -> path\\\\to\\\\file.m4a\n    var normalizedSrc = uri.path.split('/').slice(2).join('\\\\');\n\n    var path = normalizedSrc.substr(0, normalizedSrc.lastIndexOf('\\\\'));\n    var fileName = normalizedSrc.replace(path + '\\\\', '');\n\n    var fsType;\n\n    if (uri.path.split('/')[1] === 'local') {\n        fsType = fsTypes.PERSISTENT;\n    } else if (uri.path.split('/')[1] === 'temp') {\n        fsType = fsTypes.TEMPORARY;\n    }\n\n    return {\n        path: path,\n        fileName: fileName,\n        fsType: fsType\n    };\n}", "language": "javascript", "code": "function parseUriToPathAndFilename(uri) {\n    // Removing scheme and location, using backslashes: ms-appdata:///local/path/to/file.m4a -> path\\\\to\\\\file.m4a\n    var normalizedSrc = uri.path.split('/').slice(2).join('\\\\');\n\n    var path = normalizedSrc.substr(0, normalizedSrc.lastIndexOf('\\\\'));\n    var fileName = normalizedSrc.replace(path + '\\\\', '');\n\n    var fsType;\n\n    if (uri.path.split('/')[1] === 'local') {\n        fsType = fsTypes.PERSISTENT;\n    } else if (uri.path.split('/')[1] === 'temp') {\n        fsType = fsTypes.TEMPORARY;\n    }\n\n    return {\n        path: path,\n        fileName: fileName,\n        fsType: fsType\n    };\n}", "code_tokens": ["function", "parseUriToPathAndFilename", "(", "uri", ")", "{", "// Removing scheme and location, using backslashes: ms-appdata:///local/path/to/file.m4a -> path\\\\to\\\\file.m4a", "var", "normalizedSrc", "=", "uri", ".", "path", ".", "split", "(", "'/'", ")", ".", "slice", "(", "2", ")", ".", "join", "(", "'\\\\'", ")", ";", "var", "path", "=", "normalizedSrc", ".", "substr", "(", "0", ",", "normalizedSrc", ".", "lastIndexOf", "(", "'\\\\'", ")", ")", ";", "var", "fileName", "=", "normalizedSrc", ".", "replace", "(", "path", "+", "'\\\\'", ",", "''", ")", ";", "var", "fsType", ";", "if", "(", "uri", ".", "path", ".", "split", "(", "'/'", ")", "[", "1", "]", "===", "'local'", ")", "{", "fsType", "=", "fsTypes", ".", "PERSISTENT", ";", "}", "else", "if", "(", "uri", ".", "path", ".", "split", "(", "'/'", ")", "[", "1", "]", "===", "'temp'", ")", "{", "fsType", "=", "fsTypes", ".", "TEMPORARY", ";", "}", "return", "{", "path", ":", "path", ",", "fileName", ":", "fileName", ",", "fsType", ":", "fsType", "}", ";", "}"], "docstring": "Extracts path, filename and filesystem type from Uri\n@param  {Object} uri Windows.Foundation.Uri\n@return {Object}     Object containing path, filename and filesystem type", "docstring_tokens": ["Extracts", "path", "filename", "and", "filesystem", "type", "from", "Uri"], "sha": "b1c135342619f773fee3e8693a46992a133efd56", "url": "https://github.com/apache/cordova-plugin-media/blob/b1c135342619f773fee3e8693a46992a133efd56/src/windows/MediaProxy.js#L388-L408", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/dataview/NestedList.js", "func_name": "", "original_string": "function () {\n        var me = this,\n            node = me.getLastNode(),\n            detailCard = me.getDetailCard(),\n            detailCardActive = detailCard && me.getActiveItem() == detailCard,\n            lastActiveList = me.getLastActiveList();\n\n        this.fireAction('back', [this, node, lastActiveList, detailCardActive], 'doBack');\n    }", "language": "javascript", "code": "function () {\n        var me = this,\n            node = me.getLastNode(),\n            detailCard = me.getDetailCard(),\n            detailCardActive = detailCard && me.getActiveItem() == detailCard,\n            lastActiveList = me.getLastActiveList();\n\n        this.fireAction('back', [this, node, lastActiveList, detailCardActive], 'doBack');\n    }", "code_tokens": ["function", "(", ")", "{", "var", "me", "=", "this", ",", "node", "=", "me", ".", "getLastNode", "(", ")", ",", "detailCard", "=", "me", ".", "getDetailCard", "(", ")", ",", "detailCardActive", "=", "detailCard", "&&", "me", ".", "getActiveItem", "(", ")", "==", "detailCard", ",", "lastActiveList", "=", "me", ".", "getLastActiveList", "(", ")", ";", "this", ".", "fireAction", "(", "'back'", ",", "[", "this", ",", "node", ",", "lastActiveList", ",", "detailCardActive", "]", ",", "'doBack'", ")", ";", "}"], "docstring": "Called when the backButton has been tapped.", "docstring_tokens": ["Called", "when", "the", "backButton", "has", "been", "tapped", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/dataview/NestedList.js#L536-L544", "partition": "test"}
{"repo": "10xLaCroixDrinker/grunt-node-version", "path": "tasks/node_version.js", "func_name": "", "original_string": "function(callback) {\n      var command = '. ' + nvmPath;\n\n      childProcess.exec(command, cmdOpts, function(err, stdout, stderr) {\n        if (stderr.indexOf('No such file or directory') !== -1) {\n          if (nvmPath === home + '/.nvm/nvm.sh') {\n            nvmPath = home + '/nvm/nvm.sh';\n            nvmInit = '. ' + nvmPath + ' && ';\n            checkNVM(callback);\n          } else {\n            grunt[options.errorLevel]('Expected node ' + expected + ', but found v' + actual + '\\nNVM does not appear to be installed.\\nPlease install (https://github.com/creationix/nvm#installation), or update the NVM path.');\n          }\n        } else {\n          callback();\n        }\n      });\n    }", "language": "javascript", "code": "function(callback) {\n      var command = '. ' + nvmPath;\n\n      childProcess.exec(command, cmdOpts, function(err, stdout, stderr) {\n        if (stderr.indexOf('No such file or directory') !== -1) {\n          if (nvmPath === home + '/.nvm/nvm.sh') {\n            nvmPath = home + '/nvm/nvm.sh';\n            nvmInit = '. ' + nvmPath + ' && ';\n            checkNVM(callback);\n          } else {\n            grunt[options.errorLevel]('Expected node ' + expected + ', but found v' + actual + '\\nNVM does not appear to be installed.\\nPlease install (https://github.com/creationix/nvm#installation), or update the NVM path.');\n          }\n        } else {\n          callback();\n        }\n      });\n    }", "code_tokens": ["function", "(", "callback", ")", "{", "var", "command", "=", "'. '", "+", "nvmPath", ";", "childProcess", ".", "exec", "(", "command", ",", "cmdOpts", ",", "function", "(", "err", ",", "stdout", ",", "stderr", ")", "{", "if", "(", "stderr", ".", "indexOf", "(", "'No such file or directory'", ")", "!==", "-", "1", ")", "{", "if", "(", "nvmPath", "===", "home", "+", "'/.nvm/nvm.sh'", ")", "{", "nvmPath", "=", "home", "+", "'/nvm/nvm.sh'", ";", "nvmInit", "=", "'. '", "+", "nvmPath", "+", "' && '", ";", "checkNVM", "(", "callback", ")", ";", "}", "else", "{", "grunt", "[", "options", ".", "errorLevel", "]", "(", "'Expected node '", "+", "expected", "+", "', but found v'", "+", "actual", "+", "'\\nNVM does not appear to be installed.\\nPlease install (https://github.com/creationix/nvm#installation), or update the NVM path.'", ")", ";", "}", "}", "else", "{", "callback", "(", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Check for NVM", "docstring_tokens": ["Check", "for", "NVM"], "sha": "d16beba04f6a6325d2fa8202750165d3fc69b35b", "url": "https://github.com/10xLaCroixDrinker/grunt-node-version/blob/d16beba04f6a6325d2fa8202750165d3fc69b35b/tasks/node_version.js#L80-L96", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "detectAllNodesFixed", "original_string": "function detectAllNodesFixed()\n   {\n      if (data)\n      {\n         var currentNodesFixed = data.allNodesFixed;\n         var allNodesFixed = true;\n         data.nodes.forEach(function(node) { if (!node.fixed) { allNodesFixed = false; } });\n         data.allNodesFixed = allNodesFixed;\n         if (currentNodesFixed !== allNodesFixed) { updateMenuUI(); } // Update freeze / unfreeze menu option.\n      }\n   }", "language": "javascript", "code": "function detectAllNodesFixed()\n   {\n      if (data)\n      {\n         var currentNodesFixed = data.allNodesFixed;\n         var allNodesFixed = true;\n         data.nodes.forEach(function(node) { if (!node.fixed) { allNodesFixed = false; } });\n         data.allNodesFixed = allNodesFixed;\n         if (currentNodesFixed !== allNodesFixed) { updateMenuUI(); } // Update freeze / unfreeze menu option.\n      }\n   }", "code_tokens": ["function", "detectAllNodesFixed", "(", ")", "{", "if", "(", "data", ")", "{", "var", "currentNodesFixed", "=", "data", ".", "allNodesFixed", ";", "var", "allNodesFixed", "=", "true", ";", "data", ".", "nodes", ".", "forEach", "(", "function", "(", "node", ")", "{", "if", "(", "!", "node", ".", "fixed", ")", "{", "allNodesFixed", "=", "false", ";", "}", "}", ")", ";", "data", ".", "allNodesFixed", "=", "allNodesFixed", ";", "if", "(", "currentNodesFixed", "!==", "allNodesFixed", ")", "{", "updateMenuUI", "(", ")", ";", "}", "// Update freeze / unfreeze menu option.", "}", "}"], "docstring": "Helper function to determin if all nodes are fixed. This is run after any node is dragged and set to fixed.", "docstring_tokens": ["Helper", "function", "to", "determin", "if", "all", "nodes", "are", "fixed", ".", "This", "is", "run", "after", "any", "node", "is", "dragged", "and", "set", "to", "fixed", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L219-L229", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "spec/helpers/various-utils.js", "func_name": "toDashedProperties", "original_string": "function toDashedProperties ( hash ) {\n    var transformed = {};\n\n    _.each( hash, function ( value, key ) {\n        transformed[toDashed( key )] = value;\n    } );\n\n    return transformed;\n}", "language": "javascript", "code": "function toDashedProperties ( hash ) {\n    var transformed = {};\n\n    _.each( hash, function ( value, key ) {\n        transformed[toDashed( key )] = value;\n    } );\n\n    return transformed;\n}", "code_tokens": ["function", "toDashedProperties", "(", "hash", ")", "{", "var", "transformed", "=", "{", "}", ";", "_", ".", "each", "(", "hash", ",", "function", "(", "value", ",", "key", ")", "{", "transformed", "[", "toDashed", "(", "key", ")", "]", "=", "value", ";", "}", ")", ";", "return", "transformed", ";", "}"], "docstring": "Returns a transformed hash in which all camelCased property names have been replaced by dashed property names. The\ninput hash remains untouched.\n\nProperty values are not modified.\n\nSimple implementation, but good enough for the attribute names we deal with here.\n\nExample: { fooBar: \"whatEver\" } => { \"foo-bar\": \"whatEver\" }\n\n@param   {Object} hash\n@returns {Object}", "docstring_tokens": ["Returns", "a", "transformed", "hash", "in", "which", "all", "camelCased", "property", "names", "have", "been", "replaced", "by", "dashed", "property", "names", ".", "The", "input", "hash", "remains", "untouched", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/spec/helpers/various-utils.js#L111-L119", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "getElementCoords", "original_string": "function getElementCoords(element)\n   {\n      var ctm = element.getCTM();\n\n      return { x: ctm.e + element.getAttribute('cx') * ctm.a, y: ctm.f + element.getAttribute('cy') * ctm.d };\n   }", "language": "javascript", "code": "function getElementCoords(element)\n   {\n      var ctm = element.getCTM();\n\n      return { x: ctm.e + element.getAttribute('cx') * ctm.a, y: ctm.f + element.getAttribute('cy') * ctm.d };\n   }", "code_tokens": ["function", "getElementCoords", "(", "element", ")", "{", "var", "ctm", "=", "element", ".", "getCTM", "(", ")", ";", "return", "{", "x", ":", "ctm", ".", "e", "+", "element", ".", "getAttribute", "(", "'cx'", ")", "*", "ctm", ".", "a", ",", "y", ":", "ctm", ".", "f", "+", "element", ".", "getAttribute", "(", "'cy'", ")", "*", "ctm", ".", "d", "}", ";", "}"], "docstring": "Pass in the element and the screen coordinates are returned.\n\n@param element\n\n@returns {{x: number, y: number}}", "docstring_tokens": ["Pass", "in", "the", "element", "and", "the", "screen", "coordinates", "are", "returned", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L327-L332", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/core/utils/Dom.js", "func_name": "", "original_string": "function(obj, name) {\n\t\tif (obj.currentStyle) {\n\t\t\treturn obj.currentStyle[name];\n\t\t} else if (window.getComputedStyle) {\n\t\t\treturn window.getComputedStyle(obj, null)[name];\n\t\t}\n\t}", "language": "javascript", "code": "function(obj, name) {\n\t\tif (obj.currentStyle) {\n\t\t\treturn obj.currentStyle[name];\n\t\t} else if (window.getComputedStyle) {\n\t\t\treturn window.getComputedStyle(obj, null)[name];\n\t\t}\n\t}", "code_tokens": ["function", "(", "obj", ",", "name", ")", "{", "if", "(", "obj", ".", "currentStyle", ")", "{", "return", "obj", ".", "currentStyle", "[", "name", "]", ";", "}", "else", "if", "(", "window", ".", "getComputedStyle", ")", "{", "return", "window", ".", "getComputedStyle", "(", "obj", ",", "null", ")", "[", "name", "]", ";", "}", "}"], "docstring": "Returns a given computed style of a DOM element.\n\n@method getStyle\n@static\n@param {Object} obj DOM element like object.\n@param {String} name Style you want to get from the DOM element", "docstring_tokens": ["Returns", "a", "given", "computed", "style", "of", "a", "DOM", "element", "."], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Dom.js#L89-L95", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function() {\n    this.router = this.router || this.constructor.map(Ember.K);\n\n    var router = this.router,\n        location = get(this, 'location'),\n        container = this.container,\n        self = this,\n        initialURL = get(this, 'initialURL');\n\n    \n      // Allow the Location class to cancel the router setup while it refreshes\n      // the page\n      if (get(location, 'cancelRouterSetup')) {\n        return;\n      }\n    \n\n    this._setupRouter(router, location);\n\n    container.register('view:default', DefaultView);\n    container.register('view:toplevel', Ember.View.extend());\n\n    location.onUpdateURL(function(url) {\n      self.handleURL(url);\n    });\n\n    if (typeof initialURL === \"undefined\") {\n      initialURL = location.getURL();\n    }\n\n    this.handleURL(initialURL);\n  }", "language": "javascript", "code": "function() {\n    this.router = this.router || this.constructor.map(Ember.K);\n\n    var router = this.router,\n        location = get(this, 'location'),\n        container = this.container,\n        self = this,\n        initialURL = get(this, 'initialURL');\n\n    \n      // Allow the Location class to cancel the router setup while it refreshes\n      // the page\n      if (get(location, 'cancelRouterSetup')) {\n        return;\n      }\n    \n\n    this._setupRouter(router, location);\n\n    container.register('view:default', DefaultView);\n    container.register('view:toplevel', Ember.View.extend());\n\n    location.onUpdateURL(function(url) {\n      self.handleURL(url);\n    });\n\n    if (typeof initialURL === \"undefined\") {\n      initialURL = location.getURL();\n    }\n\n    this.handleURL(initialURL);\n  }", "code_tokens": ["function", "(", ")", "{", "this", ".", "router", "=", "this", ".", "router", "||", "this", ".", "constructor", ".", "map", "(", "Ember", ".", "K", ")", ";", "var", "router", "=", "this", ".", "router", ",", "location", "=", "get", "(", "this", ",", "'location'", ")", ",", "container", "=", "this", ".", "container", ",", "self", "=", "this", ",", "initialURL", "=", "get", "(", "this", ",", "'initialURL'", ")", ";", "// Allow the Location class to cancel the router setup while it refreshes", "// the page", "if", "(", "get", "(", "location", ",", "'cancelRouterSetup'", ")", ")", "{", "return", ";", "}", "this", ".", "_setupRouter", "(", "router", ",", "location", ")", ";", "container", ".", "register", "(", "'view:default'", ",", "DefaultView", ")", ";", "container", ".", "register", "(", "'view:toplevel'", ",", "Ember", ".", "View", ".", "extend", "(", ")", ")", ";", "location", ".", "onUpdateURL", "(", "function", "(", "url", ")", "{", "self", ".", "handleURL", "(", "url", ")", ";", "}", ")", ";", "if", "(", "typeof", "initialURL", "===", "\"undefined\"", ")", "{", "initialURL", "=", "location", ".", "getURL", "(", ")", ";", "}", "this", ".", "handleURL", "(", "initialURL", ")", ";", "}"], "docstring": "Initializes the current router instance and sets up the change handling\nevent listeners used by the instances `location` implementation.\n\nA property named `initialURL` will be used to determine the initial URL.\nIf no value is found `/` will be used.\n\n@method startRouting\n@private", "docstring_tokens": ["Initializes", "the", "current", "router", "instance", "and", "sets", "up", "the", "change", "handling", "event", "listeners", "used", "by", "the", "instances", "location", "implementation", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L34998-L35029", "partition": "test"}
{"repo": "italia/bootstrap-italia", "path": "src/js/plugins/transfer-back.js", "func_name": "resetToMove", "original_string": "function resetToMove(contextControl) {\n    var left = contextControl.find('.source .transfer-group')\n    var right = contextControl.find('.target .transfer-group')\n    var textLeft = contextControl.find('.source .transfer-header span.num')\n    var textRight = contextControl.find('.target .transfer-header span.num')\n    var header = contextControl.find('.transfer-header input')\n\n    $(left).html(elemLeft)\n    $(right).html(elemRight)\n\n    $(textLeft).text(elemLeftNum)\n    $(textRight).text(elemRightNum)\n\n    $(header).prop('disabled', false)\n  }", "language": "javascript", "code": "function resetToMove(contextControl) {\n    var left = contextControl.find('.source .transfer-group')\n    var right = contextControl.find('.target .transfer-group')\n    var textLeft = contextControl.find('.source .transfer-header span.num')\n    var textRight = contextControl.find('.target .transfer-header span.num')\n    var header = contextControl.find('.transfer-header input')\n\n    $(left).html(elemLeft)\n    $(right).html(elemRight)\n\n    $(textLeft).text(elemLeftNum)\n    $(textRight).text(elemRightNum)\n\n    $(header).prop('disabled', false)\n  }", "code_tokens": ["function", "resetToMove", "(", "contextControl", ")", "{", "var", "left", "=", "contextControl", ".", "find", "(", "'.source .transfer-group'", ")", "var", "right", "=", "contextControl", ".", "find", "(", "'.target .transfer-group'", ")", "var", "textLeft", "=", "contextControl", ".", "find", "(", "'.source .transfer-header span.num'", ")", "var", "textRight", "=", "contextControl", ".", "find", "(", "'.target .transfer-header span.num'", ")", "var", "header", "=", "contextControl", ".", "find", "(", "'.transfer-header input'", ")", "$", "(", "left", ")", ".", "html", "(", "elemLeft", ")", "$", "(", "right", ")", ".", "html", "(", "elemRight", ")", "$", "(", "textLeft", ")", ".", "text", "(", "elemLeftNum", ")", "$", "(", "textRight", ")", ".", "text", "(", "elemRightNum", ")", "$", "(", "header", ")", ".", "prop", "(", "'disabled'", ",", "false", ")", "}"], "docstring": "ripristino stato iniziale", "docstring_tokens": ["ripristino", "stato", "iniziale"], "sha": "9d2177a1c0c731f83636d2164bd22702ef5767c2", "url": "https://github.com/italia/bootstrap-italia/blob/9d2177a1c0c731f83636d2164bd22702ef5767c2/src/js/plugins/transfer-back.js#L24-L38", "partition": "test"}
{"repo": "taataa/tapspace", "path": "lib/Touchable/Sensor.js", "func_name": "", "original_string": "function (ev) {\n    var nextPointers\n\n    if (!ev.defaultPrevented) {\n      if (_preventDefault) {\n        ev.preventDefault()\n      }\n\n      if (!_mouseDown) {\n        _mouseDown = true\n\n        nextPointers = utils.clone(_currPointers) // See [2]\n        nextPointers['mouse'] = [ev.pageX, ev.pageY]\n\n        if (!_started) {\n          _started = true\n          _handlers.start(nextPointers)\n        }\n\n        _currPointers = nextPointers\n      }\n    }\n  }", "language": "javascript", "code": "function (ev) {\n    var nextPointers\n\n    if (!ev.defaultPrevented) {\n      if (_preventDefault) {\n        ev.preventDefault()\n      }\n\n      if (!_mouseDown) {\n        _mouseDown = true\n\n        nextPointers = utils.clone(_currPointers) // See [2]\n        nextPointers['mouse'] = [ev.pageX, ev.pageY]\n\n        if (!_started) {\n          _started = true\n          _handlers.start(nextPointers)\n        }\n\n        _currPointers = nextPointers\n      }\n    }\n  }", "code_tokens": ["function", "(", "ev", ")", "{", "var", "nextPointers", "if", "(", "!", "ev", ".", "defaultPrevented", ")", "{", "if", "(", "_preventDefault", ")", "{", "ev", ".", "preventDefault", "(", ")", "}", "if", "(", "!", "_mouseDown", ")", "{", "_mouseDown", "=", "true", "nextPointers", "=", "utils", ".", "clone", "(", "_currPointers", ")", "// See [2]", "nextPointers", "[", "'mouse'", "]", "=", "[", "ev", ".", "pageX", ",", "ev", ".", "pageY", "]", "if", "(", "!", "_started", ")", "{", "_started", "=", "true", "_handlers", ".", "start", "(", "nextPointers", ")", "}", "_currPointers", "=", "nextPointers", "}", "}", "}"], "docstring": "Mouse support No hover support.", "docstring_tokens": ["Mouse", "support", "No", "hover", "support", "."], "sha": "7ad0ecf4e410d8b761c0a843f34aac97f08e6eb3", "url": "https://github.com/taataa/tapspace/blob/7ad0ecf4e410d8b761c0a843f34aac97f08e6eb3/lib/Touchable/Sensor.js#L143-L165", "partition": "test"}
{"repo": "ethjs/ethjs-format", "path": "src/index.js", "func_name": "format", "original_string": "function format(formatter, value, encode, lengthRequirement) {\n  var output = value; // eslint-disable-line\n\n  // if formatter is quantity or quantity or tag\n  if (formatter === 'Q') {\n    output = formatQuantity(value, encode);\n  } else if (formatter === 'QP') {\n    output = formatQuantity(value, encode, true);\n  } else if (formatter === 'Q|T') {\n    output = formatQuantityOrTag(value, encode);\n  } else if (formatter === 'D') {\n    output = formatData(value); // dont format data flagged objects like compiler output\n  } else if (formatter === 'D20') {\n    output = formatData(value, 20); // dont format data flagged objects like compiler output\n  } else if (formatter === 'D32') {\n    output = formatData(value, 32); // dont format data flagged objects like compiler output\n  } else {\n    // if value is an object or array\n    if (typeof value === 'object'\n      && value !== null\n      && Array.isArray(value) === false) {\n      output = formatObject(formatter, value, encode);\n    } else if (Array.isArray(value)) {\n      output = formatArray(formatter, value, encode, lengthRequirement);\n    }\n  }\n\n  return output;\n}", "language": "javascript", "code": "function format(formatter, value, encode, lengthRequirement) {\n  var output = value; // eslint-disable-line\n\n  // if formatter is quantity or quantity or tag\n  if (formatter === 'Q') {\n    output = formatQuantity(value, encode);\n  } else if (formatter === 'QP') {\n    output = formatQuantity(value, encode, true);\n  } else if (formatter === 'Q|T') {\n    output = formatQuantityOrTag(value, encode);\n  } else if (formatter === 'D') {\n    output = formatData(value); // dont format data flagged objects like compiler output\n  } else if (formatter === 'D20') {\n    output = formatData(value, 20); // dont format data flagged objects like compiler output\n  } else if (formatter === 'D32') {\n    output = formatData(value, 32); // dont format data flagged objects like compiler output\n  } else {\n    // if value is an object or array\n    if (typeof value === 'object'\n      && value !== null\n      && Array.isArray(value) === false) {\n      output = formatObject(formatter, value, encode);\n    } else if (Array.isArray(value)) {\n      output = formatArray(formatter, value, encode, lengthRequirement);\n    }\n  }\n\n  return output;\n}", "code_tokens": ["function", "format", "(", "formatter", ",", "value", ",", "encode", ",", "lengthRequirement", ")", "{", "var", "output", "=", "value", ";", "// eslint-disable-line", "// if formatter is quantity or quantity or tag", "if", "(", "formatter", "===", "'Q'", ")", "{", "output", "=", "formatQuantity", "(", "value", ",", "encode", ")", ";", "}", "else", "if", "(", "formatter", "===", "'QP'", ")", "{", "output", "=", "formatQuantity", "(", "value", ",", "encode", ",", "true", ")", ";", "}", "else", "if", "(", "formatter", "===", "'Q|T'", ")", "{", "output", "=", "formatQuantityOrTag", "(", "value", ",", "encode", ")", ";", "}", "else", "if", "(", "formatter", "===", "'D'", ")", "{", "output", "=", "formatData", "(", "value", ")", ";", "// dont format data flagged objects like compiler output", "}", "else", "if", "(", "formatter", "===", "'D20'", ")", "{", "output", "=", "formatData", "(", "value", ",", "20", ")", ";", "// dont format data flagged objects like compiler output", "}", "else", "if", "(", "formatter", "===", "'D32'", ")", "{", "output", "=", "formatData", "(", "value", ",", "32", ")", ";", "// dont format data flagged objects like compiler output", "}", "else", "{", "// if value is an object or array", "if", "(", "typeof", "value", "===", "'object'", "&&", "value", "!==", "null", "&&", "Array", ".", "isArray", "(", "value", ")", "===", "false", ")", "{", "output", "=", "formatObject", "(", "formatter", ",", "value", ",", "encode", ")", ";", "}", "else", "if", "(", "Array", ".", "isArray", "(", "value", ")", ")", "{", "output", "=", "formatArray", "(", "formatter", ",", "value", ",", "encode", ",", "lengthRequirement", ")", ";", "}", "}", "return", "output", ";", "}"], "docstring": "Format various kinds of data to RPC spec or into digestable JS objects\n\n@method format\n@param {String|Array} formatter the data formatter\n@param {String|Array|Object|Null|Number} value the data value input\n@param {Boolean} encode encode to hex or decode to BigNumbers, Strings, Booleans, Null\n@param {Number} lengthRequirement the minimum data length requirement\n@throws error if minimum length isnt met", "docstring_tokens": ["Format", "various", "kinds", "of", "data", "to", "RPC", "spec", "or", "into", "digestable", "JS", "objects"], "sha": "626fe31ed6c7026ab9cc6012b6ea8659bc5faaf0", "url": "https://github.com/ethjs/ethjs-format/blob/626fe31ed6c7026ab9cc6012b6ea8659bc5faaf0/src/index.js#L188-L216", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "iterateEvents", "original_string": "function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {\n      if (!entity || !bindings) { return; }\n  \n      // type-check bindings\n      if (!_.isObject(bindings)) {\n        throw new Marionette.Error({\n          message: 'Bindings must be an object or function.',\n          url: 'marionette.functions.html#marionettebindentityevents'\n        });\n      }\n  \n      // allow the bindings to be a function\n      bindings = Marionette._getValue(bindings, target);\n  \n      // iterate the bindings and bind them\n      _.each(bindings, function(methods, evt) {\n  \n        // allow for a function as the handler,\n        // or a list of event names as a string\n        if (_.isFunction(methods)) {\n          functionCallback(target, entity, evt, methods);\n        } else {\n          stringCallback(target, entity, evt, methods);\n        }\n  \n      });\n    }", "language": "javascript", "code": "function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {\n      if (!entity || !bindings) { return; }\n  \n      // type-check bindings\n      if (!_.isObject(bindings)) {\n        throw new Marionette.Error({\n          message: 'Bindings must be an object or function.',\n          url: 'marionette.functions.html#marionettebindentityevents'\n        });\n      }\n  \n      // allow the bindings to be a function\n      bindings = Marionette._getValue(bindings, target);\n  \n      // iterate the bindings and bind them\n      _.each(bindings, function(methods, evt) {\n  \n        // allow for a function as the handler,\n        // or a list of event names as a string\n        if (_.isFunction(methods)) {\n          functionCallback(target, entity, evt, methods);\n        } else {\n          stringCallback(target, entity, evt, methods);\n        }\n  \n      });\n    }", "code_tokens": ["function", "iterateEvents", "(", "target", ",", "entity", ",", "bindings", ",", "functionCallback", ",", "stringCallback", ")", "{", "if", "(", "!", "entity", "||", "!", "bindings", ")", "{", "return", ";", "}", "// type-check bindings", "if", "(", "!", "_", ".", "isObject", "(", "bindings", ")", ")", "{", "throw", "new", "Marionette", ".", "Error", "(", "{", "message", ":", "'Bindings must be an object or function.'", ",", "url", ":", "'marionette.functions.html#marionettebindentityevents'", "}", ")", ";", "}", "// allow the bindings to be a function", "bindings", "=", "Marionette", ".", "_getValue", "(", "bindings", ",", "target", ")", ";", "// iterate the bindings and bind them", "_", ".", "each", "(", "bindings", ",", "function", "(", "methods", ",", "evt", ")", "{", "// allow for a function as the handler,", "// or a list of event names as a string", "if", "(", "_", ".", "isFunction", "(", "methods", ")", ")", "{", "functionCallback", "(", "target", ",", "entity", ",", "evt", ",", "methods", ")", ";", "}", "else", "{", "stringCallback", "(", "target", ",", "entity", ",", "evt", ",", "methods", ")", ";", "}", "}", ")", ";", "}"], "docstring": "generic looping function", "docstring_tokens": ["generic", "looping", "function"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L16911-L16937", "partition": "test"}
{"repo": "evanmoran/oj", "path": "versions/0.2.2/oj.js", "func_name": "", "original_string": "function(){\n      _a(oj.isDOM(this.el), this.typeName, 'constructor did not set this.el')\n\n      // Set instance on @el\n      _setInstanceOnElement(this.el, this)\n\n      var u = oj.unionArguments(arguments),\n        options = u.options,\n        args = u.args\n\n      // Emit as a tag if it isn't quiet or used new keyword\n      if (this.__autonew__ && !options.__quiet__)\n        this.emit()\n\n      // Remove quiet flag as it has served its purpose\n      if (options.__quiet__ != null)\n        delete options.__quiet__\n\n      // Add class oj-typeName\n      this.$el.addClass(\"oj-\" + this.typeName)\n\n      // Views automatically set all options to their properties\n      // arguments directly to properties\n      this.set(options)\n\n      // Remove options that were set\n      options = _clone(options)\n      this.properties.forEach(function(v){return delete options[v]})\n\n      // Views pass through remaining options to be attributes on the root element\n      // This can include jquery events and interpreted arguments\n      this.addAttributes(options)\n\n      // Record if view is fully constructed\n      return this._isConstructed = true\n    }", "language": "javascript", "code": "function(){\n      _a(oj.isDOM(this.el), this.typeName, 'constructor did not set this.el')\n\n      // Set instance on @el\n      _setInstanceOnElement(this.el, this)\n\n      var u = oj.unionArguments(arguments),\n        options = u.options,\n        args = u.args\n\n      // Emit as a tag if it isn't quiet or used new keyword\n      if (this.__autonew__ && !options.__quiet__)\n        this.emit()\n\n      // Remove quiet flag as it has served its purpose\n      if (options.__quiet__ != null)\n        delete options.__quiet__\n\n      // Add class oj-typeName\n      this.$el.addClass(\"oj-\" + this.typeName)\n\n      // Views automatically set all options to their properties\n      // arguments directly to properties\n      this.set(options)\n\n      // Remove options that were set\n      options = _clone(options)\n      this.properties.forEach(function(v){return delete options[v]})\n\n      // Views pass through remaining options to be attributes on the root element\n      // This can include jquery events and interpreted arguments\n      this.addAttributes(options)\n\n      // Record if view is fully constructed\n      return this._isConstructed = true\n    }", "code_tokens": ["function", "(", ")", "{", "_a", "(", "oj", ".", "isDOM", "(", "this", ".", "el", ")", ",", "this", ".", "typeName", ",", "'constructor did not set this.el'", ")", "// Set instance on @el", "_setInstanceOnElement", "(", "this", ".", "el", ",", "this", ")", "var", "u", "=", "oj", ".", "unionArguments", "(", "arguments", ")", ",", "options", "=", "u", ".", "options", ",", "args", "=", "u", ".", "args", "// Emit as a tag if it isn't quiet or used new keyword", "if", "(", "this", ".", "__autonew__", "&&", "!", "options", ".", "__quiet__", ")", "this", ".", "emit", "(", ")", "// Remove quiet flag as it has served its purpose", "if", "(", "options", ".", "__quiet__", "!=", "null", ")", "delete", "options", ".", "__quiet__", "// Add class oj-typeName", "this", ".", "$el", ".", "addClass", "(", "\"oj-\"", "+", "this", ".", "typeName", ")", "// Views automatically set all options to their properties", "// arguments directly to properties", "this", ".", "set", "(", "options", ")", "// Remove options that were set", "options", "=", "_clone", "(", "options", ")", "this", ".", "properties", ".", "forEach", "(", "function", "(", "v", ")", "{", "return", "delete", "options", "[", "v", "]", "}", ")", "// Views pass through remaining options to be attributes on the root element", "// This can include jquery events and interpreted arguments", "this", ".", "addAttributes", "(", "options", ")", "// Record if view is fully constructed", "return", "this", ".", "_isConstructed", "=", "true", "}"], "docstring": "Views are special objects map properties together. This is a union of arguments With the remaining arguments becoming a list", "docstring_tokens": ["Views", "are", "special", "objects", "map", "properties", "together", ".", "This", "is", "a", "union", "of", "arguments", "With", "the", "remaining", "arguments", "becoming", "a", "list"], "sha": "7f05880e4a4572fd67ffb0f55223f66d8ea4e68d", "url": "https://github.com/evanmoran/oj/blob/7f05880e4a4572fd67ffb0f55223f66d8ea4e68d/versions/0.2.2/oj.js#L1379-L1414", "partition": "test"}
{"repo": "duaraghav8/Ethlint", "path": "lib/autofix/source-code-fixer.js", "func_name": "", "original_string": "function(sourceCode, errorMessages) {\n        let fixedSourceCode = \"\", fixes = [], fixesApplied = [], remainingMessages = [];\n        let cursor = Number.NEGATIVE_INFINITY;\n\n        function attemptFix(fix) {\n            let start = fix.range [0], end = fix.range [1];\n\n            // If this fix overlaps with the previous one or has negaive range, return.\n            // Note that when cursor === start, its NOT an overlap since when source code in range\n            // [i, j] is being edited, the code covered is actually from i to j-1.\n            if (cursor > start || start > end) {\n                return false;\n            }\n\n            fixedSourceCode += sourceCode.slice(Math.max(0, cursor), Math.max(0, start));\n            fixedSourceCode += fix.text;\n            cursor = end;\n            return true;\n        }\n\n        // Segregate errors that can be fixed from those that can't for sure.\n        errorMessages.forEach(function(msg) {\n            if (msg.fix) {\n                // If msg.fix is an Array of fix packets, merge them into a single fix packet.\n                try {\n                    msg.fix = mergeFixes(msg.fix, sourceCode);\n                } catch (e) {\n                    throw new Error(\"An error occured while applying fix of rule \\\"\"\n\t\t\t\t\t\t+ msg.ruleName + \"\\\" for error \\\"\" + msg.message + \"\\\": \" + e.message);\n                }\n\n                return fixes.push(msg);\n            }\n\n            remainingMessages.push(msg);\n        });\n\n        // Fixes will be applied in top-down approach. The fix that arrives first (line-wise, followed by column-wise)\n        // gets applied first. But if current fix is applied successfully & the next one overlaps the current one,\n        // then the next one is simply skipped. Hence, it is NOT guranteed that all fixes will be applied.\n        fixes.sort(compareMessagesByFixRange).forEach(function(msg) {\n            if (attemptFix(msg.fix)) {\n                return fixesApplied.push(msg);\n            }\n\n            remainingMessages.push(msg);\n        });\n\n        fixedSourceCode += sourceCode.slice(Math.max(0, cursor));\n        remainingMessages.sort(compareMessagesByLocation);\n\n        return {\n            fixesApplied: fixesApplied,\n            fixedSourceCode: fixedSourceCode,\n            remainingErrorMessages: remainingMessages\n        };\n    }", "language": "javascript", "code": "function(sourceCode, errorMessages) {\n        let fixedSourceCode = \"\", fixes = [], fixesApplied = [], remainingMessages = [];\n        let cursor = Number.NEGATIVE_INFINITY;\n\n        function attemptFix(fix) {\n            let start = fix.range [0], end = fix.range [1];\n\n            // If this fix overlaps with the previous one or has negaive range, return.\n            // Note that when cursor === start, its NOT an overlap since when source code in range\n            // [i, j] is being edited, the code covered is actually from i to j-1.\n            if (cursor > start || start > end) {\n                return false;\n            }\n\n            fixedSourceCode += sourceCode.slice(Math.max(0, cursor), Math.max(0, start));\n            fixedSourceCode += fix.text;\n            cursor = end;\n            return true;\n        }\n\n        // Segregate errors that can be fixed from those that can't for sure.\n        errorMessages.forEach(function(msg) {\n            if (msg.fix) {\n                // If msg.fix is an Array of fix packets, merge them into a single fix packet.\n                try {\n                    msg.fix = mergeFixes(msg.fix, sourceCode);\n                } catch (e) {\n                    throw new Error(\"An error occured while applying fix of rule \\\"\"\n\t\t\t\t\t\t+ msg.ruleName + \"\\\" for error \\\"\" + msg.message + \"\\\": \" + e.message);\n                }\n\n                return fixes.push(msg);\n            }\n\n            remainingMessages.push(msg);\n        });\n\n        // Fixes will be applied in top-down approach. The fix that arrives first (line-wise, followed by column-wise)\n        // gets applied first. But if current fix is applied successfully & the next one overlaps the current one,\n        // then the next one is simply skipped. Hence, it is NOT guranteed that all fixes will be applied.\n        fixes.sort(compareMessagesByFixRange).forEach(function(msg) {\n            if (attemptFix(msg.fix)) {\n                return fixesApplied.push(msg);\n            }\n\n            remainingMessages.push(msg);\n        });\n\n        fixedSourceCode += sourceCode.slice(Math.max(0, cursor));\n        remainingMessages.sort(compareMessagesByLocation);\n\n        return {\n            fixesApplied: fixesApplied,\n            fixedSourceCode: fixedSourceCode,\n            remainingErrorMessages: remainingMessages\n        };\n    }", "code_tokens": ["function", "(", "sourceCode", ",", "errorMessages", ")", "{", "let", "fixedSourceCode", "=", "\"\"", ",", "fixes", "=", "[", "]", ",", "fixesApplied", "=", "[", "]", ",", "remainingMessages", "=", "[", "]", ";", "let", "cursor", "=", "Number", ".", "NEGATIVE_INFINITY", ";", "function", "attemptFix", "(", "fix", ")", "{", "let", "start", "=", "fix", ".", "range", "[", "0", "]", ",", "end", "=", "fix", ".", "range", "[", "1", "]", ";", "// If this fix overlaps with the previous one or has negaive range, return.", "// Note that when cursor === start, its NOT an overlap since when source code in range", "// [i, j] is being edited, the code covered is actually from i to j-1.", "if", "(", "cursor", ">", "start", "||", "start", ">", "end", ")", "{", "return", "false", ";", "}", "fixedSourceCode", "+=", "sourceCode", ".", "slice", "(", "Math", ".", "max", "(", "0", ",", "cursor", ")", ",", "Math", ".", "max", "(", "0", ",", "start", ")", ")", ";", "fixedSourceCode", "+=", "fix", ".", "text", ";", "cursor", "=", "end", ";", "return", "true", ";", "}", "// Segregate errors that can be fixed from those that can't for sure.", "errorMessages", ".", "forEach", "(", "function", "(", "msg", ")", "{", "if", "(", "msg", ".", "fix", ")", "{", "// If msg.fix is an Array of fix packets, merge them into a single fix packet.", "try", "{", "msg", ".", "fix", "=", "mergeFixes", "(", "msg", ".", "fix", ",", "sourceCode", ")", ";", "}", "catch", "(", "e", ")", "{", "throw", "new", "Error", "(", "\"An error occured while applying fix of rule \\\"\"", "+", "msg", ".", "ruleName", "+", "\"\\\" for error \\\"\"", "+", "msg", ".", "message", "+", "\"\\\": \"", "+", "e", ".", "message", ")", ";", "}", "return", "fixes", ".", "push", "(", "msg", ")", ";", "}", "remainingMessages", ".", "push", "(", "msg", ")", ";", "}", ")", ";", "// Fixes will be applied in top-down approach. The fix that arrives first (line-wise, followed by column-wise)", "// gets applied first. But if current fix is applied successfully & the next one overlaps the current one,", "// then the next one is simply skipped. Hence, it is NOT guranteed that all fixes will be applied.", "fixes", ".", "sort", "(", "compareMessagesByFixRange", ")", ".", "forEach", "(", "function", "(", "msg", ")", "{", "if", "(", "attemptFix", "(", "msg", ".", "fix", ")", ")", "{", "return", "fixesApplied", ".", "push", "(", "msg", ")", ";", "}", "remainingMessages", ".", "push", "(", "msg", ")", ";", "}", ")", ";", "fixedSourceCode", "+=", "sourceCode", ".", "slice", "(", "Math", ".", "max", "(", "0", ",", "cursor", ")", ")", ";", "remainingMessages", ".", "sort", "(", "compareMessagesByLocation", ")", ";", "return", "{", "fixesApplied", ":", "fixesApplied", ",", "fixedSourceCode", ":", "fixedSourceCode", ",", "remainingErrorMessages", ":", "remainingMessages", "}", ";", "}"], "docstring": "Apply fixes to source code depending on whichever errors can be fixed.\n@param {String} sourceCode Code to fix\n@param {Array} errorMessages Error objects that describe the error and possibly how to fix it.\n@returns {Object} fixed Contains fixed code and information about fixes applied & remaining un-fixed errors.", "docstring_tokens": ["Apply", "fixes", "to", "source", "code", "depending", "on", "whichever", "errors", "can", "be", "fixed", "."], "sha": "7d264373709561148c7166601ac39370e78f74b1", "url": "https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/autofix/source-code-fixer.js#L29-L85", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/views/Feed/FeedSummary.js", "func_name": "FeedSummary", "original_string": "function FeedSummary(props) {\n  const { children, className, content, date, user } = props\n\n  const classes = cx('summary', className)\n  const rest = getUnhandledProps(FeedSummary, props)\n  const ElementType = getElementType(FeedSummary, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedUser, val => ({ content: val }), user, { autoGenerateKey: false })}\n      {content}\n      {createShorthand(FeedDate, val => ({ content: val }), date, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function FeedSummary(props) {\n  const { children, className, content, date, user } = props\n\n  const classes = cx('summary', className)\n  const rest = getUnhandledProps(FeedSummary, props)\n  const ElementType = getElementType(FeedSummary, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedUser, val => ({ content: val }), user, { autoGenerateKey: false })}\n      {content}\n      {createShorthand(FeedDate, val => ({ content: val }), date, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "FeedSummary", "(", "props", ")", "{", "const", "{", "children", ",", "className", ",", "content", ",", "date", ",", "user", "}", "=", "props", "const", "classes", "=", "cx", "(", "'summary'", ",", "className", ")", "const", "rest", "=", "getUnhandledProps", "(", "FeedSummary", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "FeedSummary", ",", "props", ")", "if", "(", "!", "childrenUtils", ".", "isNil", "(", "children", ")", ")", "{", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "children", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "createShorthand", "(", "FeedUser", ",", "val", "=>", "(", "{", "content", ":", "val", "}", ")", ",", "user", ",", "{", "autoGenerateKey", ":", "false", "}", ")", "}", "\n      ", "{", "content", "}", "\n      ", "{", "createShorthand", "(", "FeedDate", ",", "val", "=>", "(", "{", "content", ":", "val", "}", ")", ",", "date", ",", "{", "autoGenerateKey", ":", "false", "}", ")", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A feed can contain a summary.", "docstring_tokens": ["A", "feed", "can", "contain", "a", "summary", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/FeedSummary.js#L18-L40", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function() {\n    if (this._hasElement && this._element) {\n      // Firefox versions < 11 do not have support for element.outerHTML.\n      var thisElement = this.element(), outerHTML = thisElement.outerHTML;\n      if (typeof outerHTML === 'undefined') {\n        return Ember.$('<div/>').append(thisElement).html();\n      }\n      return outerHTML;\n    } else {\n      return this.innerString();\n    }\n  }", "language": "javascript", "code": "function() {\n    if (this._hasElement && this._element) {\n      // Firefox versions < 11 do not have support for element.outerHTML.\n      var thisElement = this.element(), outerHTML = thisElement.outerHTML;\n      if (typeof outerHTML === 'undefined') {\n        return Ember.$('<div/>').append(thisElement).html();\n      }\n      return outerHTML;\n    } else {\n      return this.innerString();\n    }\n  }", "code_tokens": ["function", "(", ")", "{", "if", "(", "this", ".", "_hasElement", "&&", "this", ".", "_element", ")", "{", "// Firefox versions < 11 do not have support for element.outerHTML.", "var", "thisElement", "=", "this", ".", "element", "(", ")", ",", "outerHTML", "=", "thisElement", ".", "outerHTML", ";", "if", "(", "typeof", "outerHTML", "===", "'undefined'", ")", "{", "return", "Ember", ".", "$", "(", "'<div/>'", ")", ".", "append", "(", "thisElement", ")", ".", "html", "(", ")", ";", "}", "return", "outerHTML", ";", "}", "else", "{", "return", "this", ".", "innerString", "(", ")", ";", "}", "}"], "docstring": "Generates the HTML content for this buffer.\n\n@method string\n@return {String} The generated HTML", "docstring_tokens": ["Generates", "the", "HTML", "content", "for", "this", "buffer", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L22071-L22082", "partition": "test"}
{"repo": "mattijs/proximo", "path": "lib/model.js", "func_name": "Model", "original_string": "function Model(attributes) {\n    // Set events hash now to prevent proxy trap\n    this._events = {};\n\n    // Call super constructor\n    EventEmitter.call(this);\n    attributes = attributes || {};\n\n    // Separator for change events\n    this._separator = ':';\n\n    // Internal Object for storing attributes\n    this.attributes = {};\n\n    // Attributes that have changed since the last `change` was called.\n    this._changed = {};\n    // Hash of attributes that have changed silently since the last `change`\n    // was called.\n    this._silent  = {};\n    // Hash of changed attributes that have changed since the last `change`\n    // call began.\n    this._pending = {};\n\n    // Set initial attributes silently\n    this.set(attributes, { silent: true });\n\n    // Reset changes\n    this._changes = {};\n    this._silent  = {};\n    this._pending = {};\n\n    // Keep track of previous values (before the previous change call)\n    this._previous = _.clone(this.attributes);\n\n    // Call initialize logic\n    this.initialize.apply(this, arguments);\n}", "language": "javascript", "code": "function Model(attributes) {\n    // Set events hash now to prevent proxy trap\n    this._events = {};\n\n    // Call super constructor\n    EventEmitter.call(this);\n    attributes = attributes || {};\n\n    // Separator for change events\n    this._separator = ':';\n\n    // Internal Object for storing attributes\n    this.attributes = {};\n\n    // Attributes that have changed since the last `change` was called.\n    this._changed = {};\n    // Hash of attributes that have changed silently since the last `change`\n    // was called.\n    this._silent  = {};\n    // Hash of changed attributes that have changed since the last `change`\n    // call began.\n    this._pending = {};\n\n    // Set initial attributes silently\n    this.set(attributes, { silent: true });\n\n    // Reset changes\n    this._changes = {};\n    this._silent  = {};\n    this._pending = {};\n\n    // Keep track of previous values (before the previous change call)\n    this._previous = _.clone(this.attributes);\n\n    // Call initialize logic\n    this.initialize.apply(this, arguments);\n}", "code_tokens": ["function", "Model", "(", "attributes", ")", "{", "// Set events hash now to prevent proxy trap", "this", ".", "_events", "=", "{", "}", ";", "// Call super constructor", "EventEmitter", ".", "call", "(", "this", ")", ";", "attributes", "=", "attributes", "||", "{", "}", ";", "// Separator for change events", "this", ".", "_separator", "=", "':'", ";", "// Internal Object for storing attributes", "this", ".", "attributes", "=", "{", "}", ";", "// Attributes that have changed since the last `change` was called.", "this", ".", "_changed", "=", "{", "}", ";", "// Hash of attributes that have changed silently since the last `change`", "// was called.", "this", ".", "_silent", "=", "{", "}", ";", "// Hash of changed attributes that have changed since the last `change`", "// call began.", "this", ".", "_pending", "=", "{", "}", ";", "// Set initial attributes silently", "this", ".", "set", "(", "attributes", ",", "{", "silent", ":", "true", "}", ")", ";", "// Reset changes", "this", ".", "_changes", "=", "{", "}", ";", "this", ".", "_silent", "=", "{", "}", ";", "this", ".", "_pending", "=", "{", "}", ";", "// Keep track of previous values (before the previous change call)", "this", ".", "_previous", "=", "_", ".", "clone", "(", "this", ".", "attributes", ")", ";", "// Call initialize logic", "this", ".", "initialize", ".", "apply", "(", "this", ",", "arguments", ")", ";", "}"], "docstring": "Model implementation based on Backbone.js' Model implementation.\n\nThe Model object uses an internal hash to store it's values and\nemits events on Model attribute changes.\n\n@param {Object} attributes   Initial attributes for the Model", "docstring_tokens": ["Model", "implementation", "based", "on", "Backbone", ".", "js", "Model", "implementation", "."], "sha": "c83213af184035651ba367aa923550bcb7afb046", "url": "https://github.com/mattijs/proximo/blob/c83213af184035651ba367aa923550bcb7afb046/lib/model.js#L31-L67", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "getTargetInstForInputEventPolyfill", "original_string": "function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}", "language": "javascript", "code": "function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}", "code_tokens": ["function", "getTargetInstForInputEventPolyfill", "(", "topLevelType", ",", "targetInst", ")", "{", "if", "(", "topLevelType", "===", "TOP_SELECTION_CHANGE", "||", "topLevelType", "===", "TOP_KEY_UP", "||", "topLevelType", "===", "TOP_KEY_DOWN", ")", "{", "// On the selectionchange event, the target is just document which isn't", "// helpful for us so just check activeElement instead.", "//", "// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire", "// propertychange on the first input event after setting `value` from a", "// script and fires only keydown, keypress, keyup. Catching keyup usually", "// gets it and catching keydown lets us fire an event for the first", "// keystroke if user does a key repeat (it'll be a little delayed: right", "// before the second keystroke). Other input methods (e.g., paste) seem to", "// fire selectionchange normally.", "return", "getInstIfValueChanged", "(", "activeElementInst", ")", ";", "}", "}"], "docstring": "For IE8 and IE9.", "docstring_tokens": ["For", "IE8", "and", "IE9", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L6021-L6035", "partition": "test"}
{"repo": "AlverLyu/sm.js", "path": "lib/sm2.js", "func_name": "SM2KeyPair", "original_string": "function SM2KeyPair(pub, pri) {\n  if (!(this instanceof SM2KeyPair)) {\n    return new SM2KeyPair(pub, pri);\n  }\n  this.curve = SM2; // curve parameter\n  this.pub = null; // public key, should be a point on the curve\n  this.pri = null; // private key, should be a integer\n\n  var validPub = false;\n  var validPri = false;\n\n  if (pub != null) {\n    if (typeof pub === 'string') {\n      this._pubFromString(pub);\n    } else if (Array.isArray(pub)) {\n      this._pubFromBytes(pub);\n    } else if ('x' in pub && pub.x instanceof BN &&\n               'y' in pub && pub.y instanceof BN) {\n      // pub is already the Point object\n      this.pub = pub;\n      validPub = true;\n    } else {\n      throw 'invalid public key';\n    }\n  }\n  if (pri != null) {\n    if (typeof pri === 'string') {\n      this.pri = new BN(pri, 16);\n    } else if (pri instanceof BN) {\n      this.pri = pri;\n      validPri = true;\n    } else {\n      throw 'invalid private key';\n    }\n\n    // calculate public key\n    if (this.pub == null) {\n      this.pub = SM2.g.mul(this.pri);\n    }\n  }\n\n  if (!(validPub && validPri) && !this.validate()) {\n    throw 'invalid key';\n  }\n}", "language": "javascript", "code": "function SM2KeyPair(pub, pri) {\n  if (!(this instanceof SM2KeyPair)) {\n    return new SM2KeyPair(pub, pri);\n  }\n  this.curve = SM2; // curve parameter\n  this.pub = null; // public key, should be a point on the curve\n  this.pri = null; // private key, should be a integer\n\n  var validPub = false;\n  var validPri = false;\n\n  if (pub != null) {\n    if (typeof pub === 'string') {\n      this._pubFromString(pub);\n    } else if (Array.isArray(pub)) {\n      this._pubFromBytes(pub);\n    } else if ('x' in pub && pub.x instanceof BN &&\n               'y' in pub && pub.y instanceof BN) {\n      // pub is already the Point object\n      this.pub = pub;\n      validPub = true;\n    } else {\n      throw 'invalid public key';\n    }\n  }\n  if (pri != null) {\n    if (typeof pri === 'string') {\n      this.pri = new BN(pri, 16);\n    } else if (pri instanceof BN) {\n      this.pri = pri;\n      validPri = true;\n    } else {\n      throw 'invalid private key';\n    }\n\n    // calculate public key\n    if (this.pub == null) {\n      this.pub = SM2.g.mul(this.pri);\n    }\n  }\n\n  if (!(validPub && validPri) && !this.validate()) {\n    throw 'invalid key';\n  }\n}", "code_tokens": ["function", "SM2KeyPair", "(", "pub", ",", "pri", ")", "{", "if", "(", "!", "(", "this", "instanceof", "SM2KeyPair", ")", ")", "{", "return", "new", "SM2KeyPair", "(", "pub", ",", "pri", ")", ";", "}", "this", ".", "curve", "=", "SM2", ";", "// curve parameter", "this", ".", "pub", "=", "null", ";", "// public key, should be a point on the curve", "this", ".", "pri", "=", "null", ";", "// private key, should be a integer", "var", "validPub", "=", "false", ";", "var", "validPri", "=", "false", ";", "if", "(", "pub", "!=", "null", ")", "{", "if", "(", "typeof", "pub", "===", "'string'", ")", "{", "this", ".", "_pubFromString", "(", "pub", ")", ";", "}", "else", "if", "(", "Array", ".", "isArray", "(", "pub", ")", ")", "{", "this", ".", "_pubFromBytes", "(", "pub", ")", ";", "}", "else", "if", "(", "'x'", "in", "pub", "&&", "pub", ".", "x", "instanceof", "BN", "&&", "'y'", "in", "pub", "&&", "pub", ".", "y", "instanceof", "BN", ")", "{", "// pub is already the Point object", "this", ".", "pub", "=", "pub", ";", "validPub", "=", "true", ";", "}", "else", "{", "throw", "'invalid public key'", ";", "}", "}", "if", "(", "pri", "!=", "null", ")", "{", "if", "(", "typeof", "pri", "===", "'string'", ")", "{", "this", ".", "pri", "=", "new", "BN", "(", "pri", ",", "16", ")", ";", "}", "else", "if", "(", "pri", "instanceof", "BN", ")", "{", "this", ".", "pri", "=", "pri", ";", "validPri", "=", "true", ";", "}", "else", "{", "throw", "'invalid private key'", ";", "}", "// calculate public key", "if", "(", "this", ".", "pub", "==", "null", ")", "{", "this", ".", "pub", "=", "SM2", ".", "g", ".", "mul", "(", "this", ".", "pri", ")", ";", "}", "}", "if", "(", "!", "(", "validPub", "&&", "validPri", ")", "&&", "!", "this", ".", "validate", "(", ")", ")", "{", "throw", "'invalid key'", ";", "}", "}"], "docstring": "SM2 public and private key pair\n\nEither `pub` and `pri` can be a hex string or byte array or null.\nIf `pub` is a string, it should be the same format as output of pubToString().", "docstring_tokens": ["SM2", "public", "and", "private", "key", "pair"], "sha": "6beab32a225f8e4465387c2c995aa2df77f8c67c", "url": "https://github.com/AlverLyu/sm.js/blob/6beab32a225f8e4465387c2c995aa2df77f8c67c/lib/sm2.js#L91-L135", "partition": "test"}
{"repo": "wavesoft/gulp-jbb-profile", "path": "lib/ProfileIndex.js", "func_name": "", "original_string": "function( po ) {\n\t\tthis.objects[po.name] = po;\n\t\tif (po.extends) {\n\t\t\tthis._objTree.push([ po.extends, po.name ]);\n\t\t} else if (po.depends) {\n\t\t\tthis._objTree.push([ po.depends, po.name ]);\n\t\t} else {\n\t\t\tthis._objList.push( po.name );\n\t\t}\n\t}", "language": "javascript", "code": "function( po ) {\n\t\tthis.objects[po.name] = po;\n\t\tif (po.extends) {\n\t\t\tthis._objTree.push([ po.extends, po.name ]);\n\t\t} else if (po.depends) {\n\t\t\tthis._objTree.push([ po.depends, po.name ]);\n\t\t} else {\n\t\t\tthis._objList.push( po.name );\n\t\t}\n\t}", "code_tokens": ["function", "(", "po", ")", "{", "this", ".", "objects", "[", "po", ".", "name", "]", "=", "po", ";", "if", "(", "po", ".", "extends", ")", "{", "this", ".", "_objTree", ".", "push", "(", "[", "po", ".", "extends", ",", "po", ".", "name", "]", ")", ";", "}", "else", "if", "(", "po", ".", "depends", ")", "{", "this", ".", "_objTree", ".", "push", "(", "[", "po", ".", "depends", ",", "po", ".", "name", "]", ")", ";", "}", "else", "{", "this", ".", "_objList", ".", "push", "(", "po", ".", "name", ")", ";", "}", "}"], "docstring": "Add a profile object on the index", "docstring_tokens": ["Add", "a", "profile", "object", "on", "the", "index"], "sha": "3e9bc0ca733ae0325a09a461f504fc847e256f7a", "url": "https://github.com/wavesoft/gulp-jbb-profile/blob/3e9bc0ca733ae0325a09a461f504fc847e256f7a/lib/ProfileIndex.js#L55-L64", "partition": "test"}
{"repo": "rootsdev/gedcomx-fs-js", "path": "src/User.js", "func_name": "", "original_string": "function(json){\n    \n    // Protect against forgetting the new keyword when calling the constructor\n    if(!(this instanceof User)){\n      return new User(json);\n    }\n    \n    // If the given object is already an instance then just return it. DON'T copy it.\n    if(User.isInstance(json)){\n      return json;\n    }\n    \n    this.init(json);\n  }", "language": "javascript", "code": "function(json){\n    \n    // Protect against forgetting the new keyword when calling the constructor\n    if(!(this instanceof User)){\n      return new User(json);\n    }\n    \n    // If the given object is already an instance then just return it. DON'T copy it.\n    if(User.isInstance(json)){\n      return json;\n    }\n    \n    this.init(json);\n  }", "code_tokens": ["function", "(", "json", ")", "{", "// Protect against forgetting the new keyword when calling the constructor", "if", "(", "!", "(", "this", "instanceof", "User", ")", ")", "{", "return", "new", "User", "(", "json", ")", ";", "}", "// If the given object is already an instance then just return it. DON'T copy it.", "if", "(", "User", ".", "isInstance", "(", "json", ")", ")", "{", "return", "json", ";", "}", "this", ".", "init", "(", "json", ")", ";", "}"], "docstring": "FamilySearch user.\n\n@class User\n@extends ExtensibleData\n@param {Object} [json]", "docstring_tokens": ["FamilySearch", "user", "."], "sha": "47b6c6c9a609e163d80673d08fc83073f730d9d8", "url": "https://github.com/rootsdev/gedcomx-fs-js/blob/47b6c6c9a609e163d80673d08fc83073f730d9d8/src/User.js#L10-L23", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/data/NodeInterface.js", "func_name": "", "original_string": "function(destroy, suppressEvents) {\n                    var parentNode = this.parentNode;\n\n                    if (parentNode) {\n                        parentNode.removeChild(this, destroy, suppressEvents, true);\n                    }\n                    return this;\n                }", "language": "javascript", "code": "function(destroy, suppressEvents) {\n                    var parentNode = this.parentNode;\n\n                    if (parentNode) {\n                        parentNode.removeChild(this, destroy, suppressEvents, true);\n                    }\n                    return this;\n                }", "code_tokens": ["function", "(", "destroy", ",", "suppressEvents", ")", "{", "var", "parentNode", "=", "this", ".", "parentNode", ";", "if", "(", "parentNode", ")", "{", "parentNode", ".", "removeChild", "(", "this", ",", "destroy", ",", "suppressEvents", ",", "true", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Removes this node from its parent.\n@param {Boolean} [destroy=false] `true` to destroy the node upon removal.\n@return {Ext.data.NodeInterface} this", "docstring_tokens": ["Removes", "this", "node", "from", "its", "parent", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeInterface.js#L705-L712", "partition": "test"}
{"repo": "coolony/kiwi", "path": "support/compile.js", "func_name": "compile", "original_string": "function compile() {\n  var buf = '';\n  buf += '(function() {\\n';\n  buf += '\\n// CommonJS require()\\n\\n';\n  buf += browser.require + '\\n\\n';\n  buf += 'require.modules = {};\\n\\n';\n  buf += 'require.resolve = ' + browser.resolve + ';\\n\\n';\n  buf += 'require.register = ' + browser.register + ';\\n\\n';\n  buf += 'require.relative = ' + browser.relative + ';\\n\\n';\n  args.forEach(function(file){\n    var js = files[file];\n    file = file.replace('lib/', '');\n    buf += '\\nrequire.register(\"' + file + '\", function(module, exports, require){\\n';\n    buf += js;\n    buf += '\\n}); // module: ' + file + '\\n';\n  });\n  buf += '\\nwindow.kiwi = require(\"kiwi\");\\n';\n  buf += '})();\\n';\n  fs.writeFile('kiwi.js', buf, function(err){\n    if (err) throw err;\n    console.log('  \\033[90m create : \\033[0m\\033[36m%s\\033[0m', 'kiwi.js');\n    console.log();\n  });\n}", "language": "javascript", "code": "function compile() {\n  var buf = '';\n  buf += '(function() {\\n';\n  buf += '\\n// CommonJS require()\\n\\n';\n  buf += browser.require + '\\n\\n';\n  buf += 'require.modules = {};\\n\\n';\n  buf += 'require.resolve = ' + browser.resolve + ';\\n\\n';\n  buf += 'require.register = ' + browser.register + ';\\n\\n';\n  buf += 'require.relative = ' + browser.relative + ';\\n\\n';\n  args.forEach(function(file){\n    var js = files[file];\n    file = file.replace('lib/', '');\n    buf += '\\nrequire.register(\"' + file + '\", function(module, exports, require){\\n';\n    buf += js;\n    buf += '\\n}); // module: ' + file + '\\n';\n  });\n  buf += '\\nwindow.kiwi = require(\"kiwi\");\\n';\n  buf += '})();\\n';\n  fs.writeFile('kiwi.js', buf, function(err){\n    if (err) throw err;\n    console.log('  \\033[90m create : \\033[0m\\033[36m%s\\033[0m', 'kiwi.js');\n    console.log();\n  });\n}", "code_tokens": ["function", "compile", "(", ")", "{", "var", "buf", "=", "''", ";", "buf", "+=", "'(function() {\\n'", ";", "buf", "+=", "'\\n// CommonJS require()\\n\\n'", ";", "buf", "+=", "browser", ".", "require", "+", "'\\n\\n'", ";", "buf", "+=", "'require.modules = {};\\n\\n'", ";", "buf", "+=", "'require.resolve = '", "+", "browser", ".", "resolve", "+", "';\\n\\n'", ";", "buf", "+=", "'require.register = '", "+", "browser", ".", "register", "+", "';\\n\\n'", ";", "buf", "+=", "'require.relative = '", "+", "browser", ".", "relative", "+", "';\\n\\n'", ";", "args", ".", "forEach", "(", "function", "(", "file", ")", "{", "var", "js", "=", "files", "[", "file", "]", ";", "file", "=", "file", ".", "replace", "(", "'lib/'", ",", "''", ")", ";", "buf", "+=", "'\\nrequire.register(\"'", "+", "file", "+", "'\", function(module, exports, require){\\n'", ";", "buf", "+=", "js", ";", "buf", "+=", "'\\n}); // module: '", "+", "file", "+", "'\\n'", ";", "}", ")", ";", "buf", "+=", "'\\nwindow.kiwi = require(\"kiwi\");\\n'", ";", "buf", "+=", "'})();\\n'", ";", "fs", ".", "writeFile", "(", "'kiwi.js'", ",", "buf", ",", "function", "(", "err", ")", "{", "if", "(", "err", ")", "throw", "err", ";", "console", ".", "log", "(", "'  \\033[90m create : \\033[0m\\033[36m%s\\033[0m'", ",", "'kiwi.js'", ")", ";", "console", ".", "log", "(", ")", ";", "}", ")", ";", "}"], "docstring": "Compile the files.", "docstring_tokens": ["Compile", "the", "files", "."], "sha": "dd421737e74282ef27e3bfb007a5ecba7d9c5864", "url": "https://github.com/coolony/kiwi/blob/dd421737e74282ef27e3bfb007a5ecba7d9c5864/support/compile.js#L98-L121", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "parseOptionValue", "original_string": "function parseOptionValue(value, parser) {\n  if (parser) {\n    value = parser(value);\n  }\n\n  if (value && value !== 'none') {\n    return value;\n  }\n}", "language": "javascript", "code": "function parseOptionValue(value, parser) {\n  if (parser) {\n    value = parser(value);\n  }\n\n  if (value && value !== 'none') {\n    return value;\n  }\n}", "code_tokens": ["function", "parseOptionValue", "(", "value", ",", "parser", ")", "{", "if", "(", "parser", ")", "{", "value", "=", "parser", "(", "value", ")", ";", "}", "if", "(", "value", "&&", "value", "!==", "'none'", ")", "{", "return", "value", ";", "}", "}"], "docstring": "Get the actual value of an option.\n\n@param  {string} value\nThe value to get\n\n@param  {Function} [parser]\nOptional function to adjust the value.\n\n@return {Mixed}\n- Will be `undefined` if no value exists\n- Will be `undefined` if the given value is \"none\".\n- Will be the actual value otherwise.\n\n@private", "docstring_tokens": ["Get", "the", "actual", "value", "of", "an", "option", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L15406-L15414", "partition": "test"}
{"repo": "aragon/aragon-ui", "path": "src/proptypes.js", "func_name": "requireProp", "original_string": "function requireProp(props, propName, componentName) {\n  return isEmpty(props[propName])\n    ? new Error(\n        `The prop \\`${propName}\\` is required for \\`${componentName}\\`.`\n      )\n    : null\n}", "language": "javascript", "code": "function requireProp(props, propName, componentName) {\n  return isEmpty(props[propName])\n    ? new Error(\n        `The prop \\`${propName}\\` is required for \\`${componentName}\\`.`\n      )\n    : null\n}", "code_tokens": ["function", "requireProp", "(", "props", ",", "propName", ",", "componentName", ")", "{", "return", "isEmpty", "(", "props", "[", "propName", "]", ")", "?", "new", "Error", "(", "`", "\\`", "${", "propName", "}", "\\`", "\\`", "${", "componentName", "}", "\\`", "`", ")", ":", "null", "}"], "docstring": "Require a prop to not be empty", "docstring_tokens": ["Require", "a", "prop", "to", "not", "be", "empty"], "sha": "1c55ea5b5fe4885eab907602fb9d45cccf8f55dc", "url": "https://github.com/aragon/aragon-ui/blob/1c55ea5b5fe4885eab907602fb9d45cccf8f55dc/src/proptypes.js#L9-L15", "partition": "test"}
{"repo": "integreat-io/integreat", "path": "lib/actions/delete.js", "func_name": "deleteFn", "original_string": "async function deleteFn (action, { getService } = {}) {\n  debug('Action: DELETE')\n  const { type, id, service: serviceId, endpoint } = action.payload\n\n  const service = (typeof getService === 'function') ? getService(type, serviceId) : null\n  if (!service) {\n    return createUnknownServiceError(type, serviceId, 'DELETE')\n  }\n\n  const data = prepareData(action.payload)\n  if (data.length === 0) {\n    return createError(`No items to delete from service '${service.id}'`, 'noaction')\n  }\n\n  const endpointDebug = (endpoint) ? `endpoint '${endpoint}'` : `endpoint matching ${type} and ${id}`\n  debug('DELETE: Delete from service \\'%s\\' at %s.', service.id, endpointDebug)\n\n  const { response } = await service.send(appendToAction(action, { data }))\n\n  return (response.status === 'ok') ? { status: 'ok' } : response\n}", "language": "javascript", "code": "async function deleteFn (action, { getService } = {}) {\n  debug('Action: DELETE')\n  const { type, id, service: serviceId, endpoint } = action.payload\n\n  const service = (typeof getService === 'function') ? getService(type, serviceId) : null\n  if (!service) {\n    return createUnknownServiceError(type, serviceId, 'DELETE')\n  }\n\n  const data = prepareData(action.payload)\n  if (data.length === 0) {\n    return createError(`No items to delete from service '${service.id}'`, 'noaction')\n  }\n\n  const endpointDebug = (endpoint) ? `endpoint '${endpoint}'` : `endpoint matching ${type} and ${id}`\n  debug('DELETE: Delete from service \\'%s\\' at %s.', service.id, endpointDebug)\n\n  const { response } = await service.send(appendToAction(action, { data }))\n\n  return (response.status === 'ok') ? { status: 'ok' } : response\n}", "code_tokens": ["async", "function", "deleteFn", "(", "action", ",", "{", "getService", "}", "=", "{", "}", ")", "{", "debug", "(", "'Action: DELETE'", ")", "const", "{", "type", ",", "id", ",", "service", ":", "serviceId", ",", "endpoint", "}", "=", "action", ".", "payload", "const", "service", "=", "(", "typeof", "getService", "===", "'function'", ")", "?", "getService", "(", "type", ",", "serviceId", ")", ":", "null", "if", "(", "!", "service", ")", "{", "return", "createUnknownServiceError", "(", "type", ",", "serviceId", ",", "'DELETE'", ")", "}", "const", "data", "=", "prepareData", "(", "action", ".", "payload", ")", "if", "(", "data", ".", "length", "===", "0", ")", "{", "return", "createError", "(", "`", "${", "service", ".", "id", "}", "`", ",", "'noaction'", ")", "}", "const", "endpointDebug", "=", "(", "endpoint", ")", "?", "`", "${", "endpoint", "}", "`", ":", "`", "${", "type", "}", "${", "id", "}", "`", "debug", "(", "'DELETE: Delete from service \\'%s\\' at %s.'", ",", "service", ".", "id", ",", "endpointDebug", ")", "const", "{", "response", "}", "=", "await", "service", ".", "send", "(", "appendToAction", "(", "action", ",", "{", "data", "}", ")", ")", "return", "(", "response", ".", "status", "===", "'ok'", ")", "?", "{", "status", ":", "'ok'", "}", ":", "response", "}"], "docstring": "Delete several items from a service, based on the given payload.\n@param {Object} payload - Payload from action object\n@param {Object} resources - Object with getService\n@returns {Object} Response object with any data returned from the service", "docstring_tokens": ["Delete", "several", "items", "from", "a", "service", "based", "on", "the", "given", "payload", "."], "sha": "b3092036bfd40d74a082297cace1f678502427c6", "url": "https://github.com/integreat-io/integreat/blob/b3092036bfd40d74a082297cace1f678502427c6/lib/actions/delete.js#L25-L45", "partition": "test"}
{"repo": "intelligo-systems/intelligo.js", "path": "dist/multilabel/BinarySegmentation.js", "func_name": "", "original_string": "function(opts) {\n\tif (!('binaryClassifierType' in opts)) {\n\t\tconsole.dir(opts);\n\t\tthrow new Error(\"opts must contain binaryClassifierType\");\n\t}\n\tif (!opts.binaryClassifierType) {\n\t\tconsole.dir(opts);\n\t\tthrow new Error(\"opts.binaryClassifierType is null\");\n\t}\n\n\tthis.binaryClassifierType = opts.binaryClassifierType;\n\tthis.classifier = new this.binaryClassifierType();\n\n\tswitch (opts.segmentSplitStrategy) {\n\tcase 'shortestSegment': this.segmentSplitStrategy = this.shortestSegmentSplitStrategy; break;\n\tcase 'longestSegment':  this.segmentSplitStrategy = this.longestSegmentSplitStrategy;  break;\n\tcase 'cheapestSegment':  this.segmentSplitStrategy = this.cheapestSegmentSplitStrategy;  break;\n\tdefault: this.segmentSplitStrategy = null;\n\t}\n\t\n\tthis.mapClassnameToClassifier = {};\n}", "language": "javascript", "code": "function(opts) {\n\tif (!('binaryClassifierType' in opts)) {\n\t\tconsole.dir(opts);\n\t\tthrow new Error(\"opts must contain binaryClassifierType\");\n\t}\n\tif (!opts.binaryClassifierType) {\n\t\tconsole.dir(opts);\n\t\tthrow new Error(\"opts.binaryClassifierType is null\");\n\t}\n\n\tthis.binaryClassifierType = opts.binaryClassifierType;\n\tthis.classifier = new this.binaryClassifierType();\n\n\tswitch (opts.segmentSplitStrategy) {\n\tcase 'shortestSegment': this.segmentSplitStrategy = this.shortestSegmentSplitStrategy; break;\n\tcase 'longestSegment':  this.segmentSplitStrategy = this.longestSegmentSplitStrategy;  break;\n\tcase 'cheapestSegment':  this.segmentSplitStrategy = this.cheapestSegmentSplitStrategy;  break;\n\tdefault: this.segmentSplitStrategy = null;\n\t}\n\t\n\tthis.mapClassnameToClassifier = {};\n}", "code_tokens": ["function", "(", "opts", ")", "{", "if", "(", "!", "(", "'binaryClassifierType'", "in", "opts", ")", ")", "{", "console", ".", "dir", "(", "opts", ")", ";", "throw", "new", "Error", "(", "\"opts must contain binaryClassifierType\"", ")", ";", "}", "if", "(", "!", "opts", ".", "binaryClassifierType", ")", "{", "console", ".", "dir", "(", "opts", ")", ";", "throw", "new", "Error", "(", "\"opts.binaryClassifierType is null\"", ")", ";", "}", "this", ".", "binaryClassifierType", "=", "opts", ".", "binaryClassifierType", ";", "this", ".", "classifier", "=", "new", "this", ".", "binaryClassifierType", "(", ")", ";", "switch", "(", "opts", ".", "segmentSplitStrategy", ")", "{", "case", "'shortestSegment'", ":", "this", ".", "segmentSplitStrategy", "=", "this", ".", "shortestSegmentSplitStrategy", ";", "break", ";", "case", "'longestSegment'", ":", "this", ".", "segmentSplitStrategy", "=", "this", ".", "longestSegmentSplitStrategy", ";", "break", ";", "case", "'cheapestSegment'", ":", "this", ".", "segmentSplitStrategy", "=", "this", ".", "cheapestSegmentSplitStrategy", ";", "break", ";", "default", ":", "this", ".", "segmentSplitStrategy", "=", "null", ";", "}", "this", ".", "mapClassnameToClassifier", "=", "{", "}", ";", "}"], "docstring": "BinarySegmentation - Multi-label text classifier, based on a segmentation scheme using base binary classifiers.\n\nInspired by:\n\nMorbini Fabrizio, Sagae Kenji. Joint Identification and Segmentation of Domain-Specific Dialogue Acts for Conversational Dialogue Systems. ACL-HLT 2011\nhttp://www.citeulike.org/user/erelsegal-halevi/article/10259046\n\n@author Erel Segal-haLevi\n\n@param opts\nbinaryClassifierType (mandatory) - the type of the base binary classifier.\nfeatureExtractor (optional) - a single feature-extractor (see the \"features\" folder), or an array of extractors, for extracting features from the text segments during classification.", "docstring_tokens": ["BinarySegmentation", "-", "Multi", "-", "label", "text", "classifier", "based", "on", "a", "segmentation", "scheme", "using", "base", "binary", "classifiers", "."], "sha": "9e75d48214fb41d346462f5d886bd92cc9956df6", "url": "https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/multilabel/BinarySegmentation.js#L20-L41", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "each", "original_string": "function each(object, fn) {\n  keys(object).forEach(function (key) {\n    return fn(object[key], key);\n  });\n}", "language": "javascript", "code": "function each(object, fn) {\n  keys(object).forEach(function (key) {\n    return fn(object[key], key);\n  });\n}", "code_tokens": ["function", "each", "(", "object", ",", "fn", ")", "{", "keys", "(", "object", ")", ".", "forEach", "(", "function", "(", "key", ")", "{", "return", "fn", "(", "object", "[", "key", "]", ",", "key", ")", ";", "}", ")", ";", "}"], "docstring": "Array-like iteration for objects.\n\n@param {Object} object\nThe object to iterate over\n\n@param {obj:EachCallback} fn\nThe callback function which is called for each key in the object.", "docstring_tokens": ["Array", "-", "like", "iteration", "for", "objects", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L271-L275", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getDiagnosticHeadMessageForDecoratorResolution", "original_string": "function getDiagnosticHeadMessageForDecoratorResolution(node) {\n            switch (node.parent.kind) {\n                case 214 /* ClassDeclaration */:\n                case 186 /* ClassExpression */:\n                    return ts.Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;\n                case 138 /* Parameter */:\n                    return ts.Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;\n                case 141 /* PropertyDeclaration */:\n                    return ts.Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;\n                case 143 /* MethodDeclaration */:\n                case 145 /* GetAccessor */:\n                case 146 /* SetAccessor */:\n                    return ts.Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;\n            }\n        }", "language": "javascript", "code": "function getDiagnosticHeadMessageForDecoratorResolution(node) {\n            switch (node.parent.kind) {\n                case 214 /* ClassDeclaration */:\n                case 186 /* ClassExpression */:\n                    return ts.Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;\n                case 138 /* Parameter */:\n                    return ts.Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;\n                case 141 /* PropertyDeclaration */:\n                    return ts.Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;\n                case 143 /* MethodDeclaration */:\n                case 145 /* GetAccessor */:\n                case 146 /* SetAccessor */:\n                    return ts.Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;\n            }\n        }", "code_tokens": ["function", "getDiagnosticHeadMessageForDecoratorResolution", "(", "node", ")", "{", "switch", "(", "node", ".", "parent", ".", "kind", ")", "{", "case", "214", "/* ClassDeclaration */", ":", "case", "186", "/* ClassExpression */", ":", "return", "ts", ".", "Diagnostics", ".", "Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression", ";", "case", "138", "/* Parameter */", ":", "return", "ts", ".", "Diagnostics", ".", "Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression", ";", "case", "141", "/* PropertyDeclaration */", ":", "return", "ts", ".", "Diagnostics", ".", "Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression", ";", "case", "143", "/* MethodDeclaration */", ":", "case", "145", "/* GetAccessor */", ":", "case", "146", "/* SetAccessor */", ":", "return", "ts", ".", "Diagnostics", ".", "Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression", ";", "}", "}"], "docstring": "Gets the localized diagnostic head message to use for errors when resolving a decorator as a call expression.", "docstring_tokens": ["Gets", "the", "localized", "diagnostic", "head", "message", "to", "use", "for", "errors", "when", "resolving", "a", "decorator", "as", "a", "call", "expression", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L21681-L21695", "partition": "test"}
{"repo": "ctr-lang/ctr", "path": "lib/ctr-nodes/helpers/helper-style-default.js", "func_name": "", "original_string": "function (obj) {\n    const keys = _.sortBy(_.keys(obj), function (key) {\n      return key;\n    });\n    return _.zipObject(keys, _.map(keys, function (key) {\n      return obj[key];\n    }));\n  }", "language": "javascript", "code": "function (obj) {\n    const keys = _.sortBy(_.keys(obj), function (key) {\n      return key;\n    });\n    return _.zipObject(keys, _.map(keys, function (key) {\n      return obj[key];\n    }));\n  }", "code_tokens": ["function", "(", "obj", ")", "{", "const", "keys", "=", "_", ".", "sortBy", "(", "_", ".", "keys", "(", "obj", ")", ",", "function", "(", "key", ")", "{", "return", "key", ";", "}", ")", ";", "return", "_", ".", "zipObject", "(", "keys", ",", "_", ".", "map", "(", "keys", ",", "function", "(", "key", ")", "{", "return", "obj", "[", "key", "]", ";", "}", ")", ")", ";", "}"], "docstring": "sorts keys for better readablity", "docstring_tokens": ["sorts", "keys", "for", "better", "readablity"], "sha": "f73465cb7420bcc4f18a892a37529b3b366fb08a", "url": "https://github.com/ctr-lang/ctr/blob/f73465cb7420bcc4f18a892a37529b3b366fb08a/lib/ctr-nodes/helpers/helper-style-default.js#L7-L14", "partition": "test"}
{"repo": "taskcluster/taskcluster-lib-stats", "path": "src/stats.js", "func_name": "", "original_string": "function(options) {\n  assert(options,                   \"options are required\");\n  assert(options.connectionString,  \"options.connectionString is missing\");\n  assert(url.parse(options.connectionString).protocol === 'https:' ||\n         options.allowHTTP, \"InfluxDB connectionString must use HTTPS!\");\n  options = _.defaults({}, options, {\n    maxDelay:             60 * 5,\n    maxPendingPoints:     250\n  });\n  this._options           = options;\n  this._pendingPoints     = {};\n  this._nbPendingPoints   = 0;\n  this._flushTimeout = setTimeout(\n    this.flush.bind(this, true),\n    options.maxDelay * 1000\n  );\n}", "language": "javascript", "code": "function(options) {\n  assert(options,                   \"options are required\");\n  assert(options.connectionString,  \"options.connectionString is missing\");\n  assert(url.parse(options.connectionString).protocol === 'https:' ||\n         options.allowHTTP, \"InfluxDB connectionString must use HTTPS!\");\n  options = _.defaults({}, options, {\n    maxDelay:             60 * 5,\n    maxPendingPoints:     250\n  });\n  this._options           = options;\n  this._pendingPoints     = {};\n  this._nbPendingPoints   = 0;\n  this._flushTimeout = setTimeout(\n    this.flush.bind(this, true),\n    options.maxDelay * 1000\n  );\n}", "code_tokens": ["function", "(", "options", ")", "{", "assert", "(", "options", ",", "\"options are required\"", ")", ";", "assert", "(", "options", ".", "connectionString", ",", "\"options.connectionString is missing\"", ")", ";", "assert", "(", "url", ".", "parse", "(", "options", ".", "connectionString", ")", ".", "protocol", "===", "'https:'", "||", "options", ".", "allowHTTP", ",", "\"InfluxDB connectionString must use HTTPS!\"", ")", ";", "options", "=", "_", ".", "defaults", "(", "{", "}", ",", "options", ",", "{", "maxDelay", ":", "60", "*", "5", ",", "maxPendingPoints", ":", "250", "}", ")", ";", "this", ".", "_options", "=", "options", ";", "this", ".", "_pendingPoints", "=", "{", "}", ";", "this", ".", "_nbPendingPoints", "=", "0", ";", "this", ".", "_flushTimeout", "=", "setTimeout", "(", "this", ".", "flush", ".", "bind", "(", "this", ",", "true", ")", ",", "options", ".", "maxDelay", "*", "1000", ")", ";", "}"], "docstring": "Create an Influx Database Connection\n\noptions:\n{\n// Connection string for\nconnectionString:  '<protocol>://<user>:<pwd>@<host>:<port>/db/<database>',\n\n// Max submission delay\nmaxDelay:          60 * 5, // 5 minutes\n\n// Maximum number of pending points before writing\nmaxPendingPoints:  250,\n\n// Allow the connection string to use HTTP instead of HTTPS, this option\n// is just to prevent accidental deployments with HTTP instead of HTTPS\n// (there is no reason not to use HTTPS).\nallowHTTP:         false\n}", "docstring_tokens": ["Create", "an", "Influx", "Database", "Connection"], "sha": "1760c7037a07f0a4a715c6aa93475209f8bcbfc6", "url": "https://github.com/taskcluster/taskcluster-lib-stats/blob/1760c7037a07f0a4a715c6aa93475209f8bcbfc6/src/stats.js#L39-L55", "partition": "test"}
{"repo": "integreat-io/integreat", "path": "lib/utils/getService.js", "func_name": "getService", "original_string": "function getService (schemas, services) {\n  return (type, service) => {\n    if (!service && schemas[type]) {\n      service = schemas[type].service\n    }\n    return services[service] || null\n  }\n}", "language": "javascript", "code": "function getService (schemas, services) {\n  return (type, service) => {\n    if (!service && schemas[type]) {\n      service = schemas[type].service\n    }\n    return services[service] || null\n  }\n}", "code_tokens": ["function", "getService", "(", "schemas", ",", "services", ")", "{", "return", "(", "type", ",", "service", ")", "=>", "{", "if", "(", "!", "service", "&&", "schemas", "[", "type", "]", ")", "{", "service", "=", "schemas", "[", "type", "]", ".", "service", "}", "return", "services", "[", "service", "]", "||", "null", "}", "}"], "docstring": "Get service from type or service id.\n@param {Object} schemas - The schemas\n@param {Object} services - The services\n@returns {function} Function to retrieve service from type and service id", "docstring_tokens": ["Get", "service", "from", "type", "or", "service", "id", "."], "sha": "b3092036bfd40d74a082297cace1f678502427c6", "url": "https://github.com/integreat-io/integreat/blob/b3092036bfd40d74a082297cace1f678502427c6/lib/utils/getService.js#L7-L14", "partition": "test"}
{"repo": "Rudellandy/console2file", "path": "lib/index.js", "func_name": "assignOptions", "original_string": "function assignOptions(defaults, userDefined) {\n        for (const optionKey in userDefined) {\n            if (defaults.hasOwnProperty(optionKey)) {\n                defaults[optionKey] = userDefined[optionKey];\n            }\n            else {\n                throw new Error(`Unknown {IOptions} parameter '${optionKey}'`);\n            }\n        }\n        return defaults;\n    }", "language": "javascript", "code": "function assignOptions(defaults, userDefined) {\n        for (const optionKey in userDefined) {\n            if (defaults.hasOwnProperty(optionKey)) {\n                defaults[optionKey] = userDefined[optionKey];\n            }\n            else {\n                throw new Error(`Unknown {IOptions} parameter '${optionKey}'`);\n            }\n        }\n        return defaults;\n    }", "code_tokens": ["function", "assignOptions", "(", "defaults", ",", "userDefined", ")", "{", "for", "(", "const", "optionKey", "in", "userDefined", ")", "{", "if", "(", "defaults", ".", "hasOwnProperty", "(", "optionKey", ")", ")", "{", "defaults", "[", "optionKey", "]", "=", "userDefined", "[", "optionKey", "]", ";", "}", "else", "{", "throw", "new", "Error", "(", "`", "${", "optionKey", "}", "`", ")", ";", "}", "}", "return", "defaults", ";", "}"], "docstring": "Assign user options to object\n@param {IOptions} defaults\n@param {IOptions} userDefined", "docstring_tokens": ["Assign", "user", "options", "to", "object"], "sha": "221ac5b86c72b620dd9804b39fb6433c79d83111", "url": "https://github.com/Rudellandy/console2file/blob/221ac5b86c72b620dd9804b39fb6433c79d83111/lib/index.js#L131-L141", "partition": "test"}
{"repo": "beyo/model", "path": "lib/collection.js", "func_name": "find", "original_string": "function find(filter) {\n  var item;\n  var i;\n  var ilen;\n  var keys;\n  var key;\n  var k;\n  var klen;\n  var found;\n\n  if (filter instanceof Function) {\n    for (i = 0, ilen = this.items.length; i < ilen; ++i) {\n      item = this.items[i];\n      if (filter(item, i)) {\n        return item;\n      }\n    }\n  } else if (filter !== null && filter !== undefined) {\n    if (typeof filter === 'object') {\n      keys = Object.keys(filter);\n      klen = keys.length;\n      for (i = 0, ilen = this.items.length; i < ilen; ++i) {\n        item = this.items[i];\n        found = true;\n        for (k = 0; k < klen && found; ++k) {\n          key = keys[k];\n          if (filter[key] !== item[key]) {\n            found = false;\n          }\n        }\n        if (found) {\n          return item;\n        }\n      }\n    } else if (this.modelType) {\n      keys = Object.keys(this.modelType.attributes);\n      klen = keys.length;\n      for (i = 0, ilen = this.items.length; i < ilen; ++i) {\n        item = this.items[i];\n        found = false;\n        for (k = 0; k < klen && !found; ++k) {\n          key = keys[k];\n          if (filter === item[key]) {\n            found = true;\n          }\n        }\n        if (found) {\n          return item;\n        }\n      }\n    } else {\n      for (i = 0, ilen = this.items.length; i < ilen; ++i) {\n        item = this.items[i];\n        found = false;\n        keys = Object.keys(item);\n        for (k = 0, klen = keys.length; k < klen && !found; ++k) {\n          key = keys[k];\n          if (filter === item[key]) {\n            found = true;\n          }\n        }\n        if (found) {\n          return item;\n        }\n      }\n    }\n  }\n\n  return undefined;\n}", "language": "javascript", "code": "function find(filter) {\n  var item;\n  var i;\n  var ilen;\n  var keys;\n  var key;\n  var k;\n  var klen;\n  var found;\n\n  if (filter instanceof Function) {\n    for (i = 0, ilen = this.items.length; i < ilen; ++i) {\n      item = this.items[i];\n      if (filter(item, i)) {\n        return item;\n      }\n    }\n  } else if (filter !== null && filter !== undefined) {\n    if (typeof filter === 'object') {\n      keys = Object.keys(filter);\n      klen = keys.length;\n      for (i = 0, ilen = this.items.length; i < ilen; ++i) {\n        item = this.items[i];\n        found = true;\n        for (k = 0; k < klen && found; ++k) {\n          key = keys[k];\n          if (filter[key] !== item[key]) {\n            found = false;\n          }\n        }\n        if (found) {\n          return item;\n        }\n      }\n    } else if (this.modelType) {\n      keys = Object.keys(this.modelType.attributes);\n      klen = keys.length;\n      for (i = 0, ilen = this.items.length; i < ilen; ++i) {\n        item = this.items[i];\n        found = false;\n        for (k = 0; k < klen && !found; ++k) {\n          key = keys[k];\n          if (filter === item[key]) {\n            found = true;\n          }\n        }\n        if (found) {\n          return item;\n        }\n      }\n    } else {\n      for (i = 0, ilen = this.items.length; i < ilen; ++i) {\n        item = this.items[i];\n        found = false;\n        keys = Object.keys(item);\n        for (k = 0, klen = keys.length; k < klen && !found; ++k) {\n          key = keys[k];\n          if (filter === item[key]) {\n            found = true;\n          }\n        }\n        if (found) {\n          return item;\n        }\n      }\n    }\n  }\n\n  return undefined;\n}", "code_tokens": ["function", "find", "(", "filter", ")", "{", "var", "item", ";", "var", "i", ";", "var", "ilen", ";", "var", "keys", ";", "var", "key", ";", "var", "k", ";", "var", "klen", ";", "var", "found", ";", "if", "(", "filter", "instanceof", "Function", ")", "{", "for", "(", "i", "=", "0", ",", "ilen", "=", "this", ".", "items", ".", "length", ";", "i", "<", "ilen", ";", "++", "i", ")", "{", "item", "=", "this", ".", "items", "[", "i", "]", ";", "if", "(", "filter", "(", "item", ",", "i", ")", ")", "{", "return", "item", ";", "}", "}", "}", "else", "if", "(", "filter", "!==", "null", "&&", "filter", "!==", "undefined", ")", "{", "if", "(", "typeof", "filter", "===", "'object'", ")", "{", "keys", "=", "Object", ".", "keys", "(", "filter", ")", ";", "klen", "=", "keys", ".", "length", ";", "for", "(", "i", "=", "0", ",", "ilen", "=", "this", ".", "items", ".", "length", ";", "i", "<", "ilen", ";", "++", "i", ")", "{", "item", "=", "this", ".", "items", "[", "i", "]", ";", "found", "=", "true", ";", "for", "(", "k", "=", "0", ";", "k", "<", "klen", "&&", "found", ";", "++", "k", ")", "{", "key", "=", "keys", "[", "k", "]", ";", "if", "(", "filter", "[", "key", "]", "!==", "item", "[", "key", "]", ")", "{", "found", "=", "false", ";", "}", "}", "if", "(", "found", ")", "{", "return", "item", ";", "}", "}", "}", "else", "if", "(", "this", ".", "modelType", ")", "{", "keys", "=", "Object", ".", "keys", "(", "this", ".", "modelType", ".", "attributes", ")", ";", "klen", "=", "keys", ".", "length", ";", "for", "(", "i", "=", "0", ",", "ilen", "=", "this", ".", "items", ".", "length", ";", "i", "<", "ilen", ";", "++", "i", ")", "{", "item", "=", "this", ".", "items", "[", "i", "]", ";", "found", "=", "false", ";", "for", "(", "k", "=", "0", ";", "k", "<", "klen", "&&", "!", "found", ";", "++", "k", ")", "{", "key", "=", "keys", "[", "k", "]", ";", "if", "(", "filter", "===", "item", "[", "key", "]", ")", "{", "found", "=", "true", ";", "}", "}", "if", "(", "found", ")", "{", "return", "item", ";", "}", "}", "}", "else", "{", "for", "(", "i", "=", "0", ",", "ilen", "=", "this", ".", "items", ".", "length", ";", "i", "<", "ilen", ";", "++", "i", ")", "{", "item", "=", "this", ".", "items", "[", "i", "]", ";", "found", "=", "false", ";", "keys", "=", "Object", ".", "keys", "(", "item", ")", ";", "for", "(", "k", "=", "0", ",", "klen", "=", "keys", ".", "length", ";", "k", "<", "klen", "&&", "!", "found", ";", "++", "k", ")", "{", "key", "=", "keys", "[", "k", "]", ";", "if", "(", "filter", "===", "item", "[", "key", "]", ")", "{", "found", "=", "true", ";", "}", "}", "if", "(", "found", ")", "{", "return", "item", ";", "}", "}", "}", "}", "return", "undefined", ";", "}"], "docstring": "Find the first item matching filter\n\n@param {string|Object} filter      the filter\n@return {Object}                   the model found", "docstring_tokens": ["Find", "the", "first", "item", "matching", "filter"], "sha": "625b386b6e1141e1869ede753640850c0c9f0971", "url": "https://github.com/beyo/model/blob/625b386b6e1141e1869ede753640850c0c9f0971/lib/collection.js#L54-L123", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/collections/Table/TableRow.js", "func_name": "TableRow", "original_string": "function TableRow(props) {\n  const {\n    active,\n    cellAs,\n    cells,\n    children,\n    className,\n    disabled,\n    error,\n    negative,\n    positive,\n    textAlign,\n    verticalAlign,\n    warning,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(active, 'active'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(warning, 'warning'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    className,\n  )\n  const rest = getUnhandledProps(TableRow, props)\n  const ElementType = getElementType(TableRow, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(cells, cell => TableCell.create(cell, { defaultProps: { as: cellAs } }))}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function TableRow(props) {\n  const {\n    active,\n    cellAs,\n    cells,\n    children,\n    className,\n    disabled,\n    error,\n    negative,\n    positive,\n    textAlign,\n    verticalAlign,\n    warning,\n  } = props\n\n  const classes = cx(\n    useKeyOnly(active, 'active'),\n    useKeyOnly(disabled, 'disabled'),\n    useKeyOnly(error, 'error'),\n    useKeyOnly(negative, 'negative'),\n    useKeyOnly(positive, 'positive'),\n    useKeyOnly(warning, 'warning'),\n    useTextAlignProp(textAlign),\n    useVerticalAlignProp(verticalAlign),\n    className,\n  )\n  const rest = getUnhandledProps(TableRow, props)\n  const ElementType = getElementType(TableRow, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {_.map(cells, cell => TableCell.create(cell, { defaultProps: { as: cellAs } }))}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "TableRow", "(", "props", ")", "{", "const", "{", "active", ",", "cellAs", ",", "cells", ",", "children", ",", "className", ",", "disabled", ",", "error", ",", "negative", ",", "positive", ",", "textAlign", ",", "verticalAlign", ",", "warning", ",", "}", "=", "props", "const", "classes", "=", "cx", "(", "useKeyOnly", "(", "active", ",", "'active'", ")", ",", "useKeyOnly", "(", "disabled", ",", "'disabled'", ")", ",", "useKeyOnly", "(", "error", ",", "'error'", ")", ",", "useKeyOnly", "(", "negative", ",", "'negative'", ")", ",", "useKeyOnly", "(", "positive", ",", "'positive'", ")", ",", "useKeyOnly", "(", "warning", ",", "'warning'", ")", ",", "useTextAlignProp", "(", "textAlign", ")", ",", "useVerticalAlignProp", "(", "verticalAlign", ")", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "TableRow", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "TableRow", ",", "props", ")", "if", "(", "!", "childrenUtils", ".", "isNil", "(", "children", ")", ")", "{", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "children", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "_", ".", "map", "(", "cells", ",", "cell", "=>", "TableCell", ".", "create", "(", "cell", ",", "{", "defaultProps", ":", "{", "as", ":", "cellAs", "}", "}", ")", ")", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A table can have rows.", "docstring_tokens": ["A", "table", "can", "have", "rows", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Table/TableRow.js#L22-L65", "partition": "test"}
{"repo": "jeka-kiselyov/mdict", "path": "mdict-parser.js", "func_name": "willScanKeyTable", "original_string": "function willScanKeyTable(slicedKeyBlock, num_entries, keyword_index, delay) {\n      slicedKeyBlock.delay(delay).then(function (input) {\n        var scanner = Scanner(input);\n        for (var i = 0, size = keyword_index.length; i < size; i++) {\n        // common.log('z',keyword_index[i]);\n          read_key_block(scanner, keyword_index[i]);\n        }\n      });\n    }", "language": "javascript", "code": "function willScanKeyTable(slicedKeyBlock, num_entries, keyword_index, delay) {\n      slicedKeyBlock.delay(delay).then(function (input) {\n        var scanner = Scanner(input);\n        for (var i = 0, size = keyword_index.length; i < size; i++) {\n        // common.log('z',keyword_index[i]);\n          read_key_block(scanner, keyword_index[i]);\n        }\n      });\n    }", "code_tokens": ["function", "willScanKeyTable", "(", "slicedKeyBlock", ",", "num_entries", ",", "keyword_index", ",", "delay", ")", "{", "slicedKeyBlock", ".", "delay", "(", "delay", ")", ".", "then", "(", "function", "(", "input", ")", "{", "var", "scanner", "=", "Scanner", "(", "input", ")", ";", "for", "(", "var", "i", "=", "0", ",", "size", "=", "keyword_index", ".", "length", ";", "i", "<", "size", ";", "i", "++", ")", "{", "// common.log('z',keyword_index[i]);", "read_key_block", "(", "scanner", ",", "keyword_index", "[", "i", "]", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Delay to scan key table, for debug onyl.\n@param slicedKeyBlock a promise object which will resolve to an ArrayBuffer containing keyword blocks\nsliced from mdx/mdd file.\n@param num_entries number of keyword entries\n@param keyword_index array of keyword index\n@param delay time to delay for scanning key table", "docstring_tokens": ["Delay", "to", "scan", "key", "table", "for", "debug", "onyl", "."], "sha": "540898e63991cb0c8985ed8fb29eb11a59f35089", "url": "https://github.com/jeka-kiselyov/mdict/blob/540898e63991cb0c8985ed8fb29eb11a59f35089/mdict-parser.js#L574-L582", "partition": "test"}
{"repo": "GamesDoneQuick/rieussec", "path": "index.js", "func_name": "", "original_string": "function(tickRate){\n    events.EventEmitter.call(this);\n\n    // Initialize private properties\n    this._milliseconds = 0;\n    this._setState('stopped');\n    this._timer = new NanoTimer();\n\n    tickRate = tickRate || 100;\n    Object.defineProperty(this, 'tickRate', {\n        enumerable: true,\n        configurable: false,\n        writable: false,\n        value: tickRate\n    });\n}", "language": "javascript", "code": "function(tickRate){\n    events.EventEmitter.call(this);\n\n    // Initialize private properties\n    this._milliseconds = 0;\n    this._setState('stopped');\n    this._timer = new NanoTimer();\n\n    tickRate = tickRate || 100;\n    Object.defineProperty(this, 'tickRate', {\n        enumerable: true,\n        configurable: false,\n        writable: false,\n        value: tickRate\n    });\n}", "code_tokens": ["function", "(", "tickRate", ")", "{", "events", ".", "EventEmitter", ".", "call", "(", "this", ")", ";", "// Initialize private properties", "this", ".", "_milliseconds", "=", "0", ";", "this", ".", "_setState", "(", "'stopped'", ")", ";", "this", ".", "_timer", "=", "new", "NanoTimer", "(", ")", ";", "tickRate", "=", "tickRate", "||", "100", ";", "Object", ".", "defineProperty", "(", "this", ",", "'tickRate'", ",", "{", "enumerable", ":", "true", ",", "configurable", ":", "false", ",", "writable", ":", "false", ",", "value", ":", "tickRate", "}", ")", ";", "}"], "docstring": "Construct a new Rieussec stopwatch\n\n@class Rieussec\n@classdesc A rieussec stopwatch object.\n\n@param {Number} [tickRate=100] - How often (in milliseconds) to emit \"tick\" events", "docstring_tokens": ["Construct", "a", "new", "Rieussec", "stopwatch"], "sha": "370c53f49da272eb63f30d09c16fdee9a5d1fe1f", "url": "https://github.com/GamesDoneQuick/rieussec/blob/370c53f49da272eb63f30d09c16fdee9a5d1fe1f/index.js#L15-L30", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "lib/reflect.js", "func_name": "toPropertyDescriptor", "original_string": "function toPropertyDescriptor(obj) {\n  if (Object(obj) !== obj) {\n    throw new TypeError(\"property descriptor should be an Object, given: \"+\n                        obj);\n  }\n  var desc = {};\n  if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n  if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n  if ('value' in obj) { desc.value = obj.value; }\n  if ('writable' in obj) { desc.writable = !!obj.writable; }\n  if ('get' in obj) {\n    var getter = obj.get;\n    if (getter !== undefined && typeof getter !== \"function\") {\n      throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                          \"callable or undefined, given: \"+getter);\n    }\n    desc.get = getter;\n  }\n  if ('set' in obj) {\n    var setter = obj.set;\n    if (setter !== undefined && typeof setter !== \"function\") {\n      throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                          \"callable or undefined, given: \"+setter);\n    }\n    desc.set = setter;\n  }\n  if ('get' in desc || 'set' in desc) {\n    if ('value' in desc || 'writable' in desc) {\n      throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                          \"accessor descriptor: \"+obj);\n    }\n  }\n  return desc;\n}", "language": "javascript", "code": "function toPropertyDescriptor(obj) {\n  if (Object(obj) !== obj) {\n    throw new TypeError(\"property descriptor should be an Object, given: \"+\n                        obj);\n  }\n  var desc = {};\n  if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n  if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n  if ('value' in obj) { desc.value = obj.value; }\n  if ('writable' in obj) { desc.writable = !!obj.writable; }\n  if ('get' in obj) {\n    var getter = obj.get;\n    if (getter !== undefined && typeof getter !== \"function\") {\n      throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                          \"callable or undefined, given: \"+getter);\n    }\n    desc.get = getter;\n  }\n  if ('set' in obj) {\n    var setter = obj.set;\n    if (setter !== undefined && typeof setter !== \"function\") {\n      throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                          \"callable or undefined, given: \"+setter);\n    }\n    desc.set = setter;\n  }\n  if ('get' in desc || 'set' in desc) {\n    if ('value' in desc || 'writable' in desc) {\n      throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                          \"accessor descriptor: \"+obj);\n    }\n  }\n  return desc;\n}", "code_tokens": ["function", "toPropertyDescriptor", "(", "obj", ")", "{", "if", "(", "Object", "(", "obj", ")", "!==", "obj", ")", "{", "throw", "new", "TypeError", "(", "\"property descriptor should be an Object, given: \"", "+", "obj", ")", ";", "}", "var", "desc", "=", "{", "}", ";", "if", "(", "'enumerable'", "in", "obj", ")", "{", "desc", ".", "enumerable", "=", "!", "!", "obj", ".", "enumerable", ";", "}", "if", "(", "'configurable'", "in", "obj", ")", "{", "desc", ".", "configurable", "=", "!", "!", "obj", ".", "configurable", ";", "}", "if", "(", "'value'", "in", "obj", ")", "{", "desc", ".", "value", "=", "obj", ".", "value", ";", "}", "if", "(", "'writable'", "in", "obj", ")", "{", "desc", ".", "writable", "=", "!", "!", "obj", ".", "writable", ";", "}", "if", "(", "'get'", "in", "obj", ")", "{", "var", "getter", "=", "obj", ".", "get", ";", "if", "(", "getter", "!==", "undefined", "&&", "typeof", "getter", "!==", "\"function\"", ")", "{", "throw", "new", "TypeError", "(", "\"property descriptor 'get' attribute must be \"", "+", "\"callable or undefined, given: \"", "+", "getter", ")", ";", "}", "desc", ".", "get", "=", "getter", ";", "}", "if", "(", "'set'", "in", "obj", ")", "{", "var", "setter", "=", "obj", ".", "set", ";", "if", "(", "setter", "!==", "undefined", "&&", "typeof", "setter", "!==", "\"function\"", ")", "{", "throw", "new", "TypeError", "(", "\"property descriptor 'set' attribute must be \"", "+", "\"callable or undefined, given: \"", "+", "setter", ")", ";", "}", "desc", ".", "set", "=", "setter", ";", "}", "if", "(", "'get'", "in", "desc", "||", "'set'", "in", "desc", ")", "{", "if", "(", "'value'", "in", "desc", "||", "'writable'", "in", "desc", ")", "{", "throw", "new", "TypeError", "(", "\"property descriptor cannot be both a data and an \"", "+", "\"accessor descriptor: \"", "+", "obj", ")", ";", "}", "}", "return", "desc", ";", "}"], "docstring": "Adapted from ES5 section 8.10.5", "docstring_tokens": ["Adapted", "from", "ES5", "section", "8", ".", "10", ".", "5"], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/lib/reflect.js#L193-L226", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "emitFiles", "original_string": "function emitFiles(resolver, host, targetSourceFile) {\n        // emit output for the __extends helper function\n        var extendsHelper = \"\\nvar __extends = (this && this.__extends) || function (d, b) {\\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\\n    function __() { this.constructor = d; }\\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n};\";\n        // emit output for the __decorate helper function\n        var decorateHelper = \"\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\n};\";\n        // emit output for the __metadata helper function\n        var metadataHelper = \"\\nvar __metadata = (this && this.__metadata) || function (k, v) {\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.metadata === \\\"function\\\") return Reflect.metadata(k, v);\\n};\";\n        // emit output for the __param helper function\n        var paramHelper = \"\\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\\n    return function (target, key) { decorator(target, key, paramIndex); }\\n};\";\n        var awaiterHelper = \"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\\n    return new Promise(function (resolve, reject) {\\n        generator = generator.call(thisArg, _arguments);\\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\\n        function onfulfill(value) { try { step(\\\"next\\\", value); } catch (e) { reject(e); } }\\n        function onreject(value) { try { step(\\\"throw\\\", value); } catch (e) { reject(e); } }\\n        function step(verb, value) {\\n            var result = generator[verb](value);\\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\\n        }\\n        step(\\\"next\\\", void 0);\\n    });\\n};\";\n        var compilerOptions = host.getCompilerOptions();\n        var languageVersion = compilerOptions.target || 0 /* ES3 */;\n        var modulekind = compilerOptions.module ? compilerOptions.module : languageVersion === 2 /* ES6 */ ? 5 /* ES6 */ : 0 /* None */;\n        var sourceMapDataList = compilerOptions.sourceMap || compilerOptions.inlineSourceMap ? [] : undefined;\n        var diagnostics = [];\n        var newLine = host.getNewLine();\n        var jsxDesugaring = host.getCompilerOptions().jsx !== 1 /* Preserve */;\n        var shouldEmitJsx = function (s) { return (s.languageVariant === 1 /* JSX */ && !jsxDesugaring); };\n        if (targetSourceFile === undefined) {\n            ts.forEach(host.getSourceFiles(), function (sourceFile) {\n                if (ts.shouldEmitToOwnFile(sourceFile, compilerOptions)) {\n                    var jsFilePath = ts.getOwnEmitOutputFilePath(sourceFile, host, shouldEmitJsx(sourceFile) ? \".jsx\" : \".js\");\n                    emitFile(jsFilePath, sourceFile);\n                }\n            });\n            if (compilerOptions.outFile || compilerOptions.out) {\n                emitFile(compilerOptions.outFile || compilerOptions.out);\n            }\n        }\n        else {\n            // targetSourceFile is specified (e.g calling emitter from language service or calling getSemanticDiagnostic from language service)\n            if (ts.shouldEmitToOwnFile(targetSourceFile, compilerOptions)) {\n                var jsFilePath = ts.getOwnEmitOutputFilePath(targetSourceFile, host, shouldEmitJsx(targetSourceFile) ? \".jsx\" : \".js\");\n                emitFile(jsFilePath, targetSourceFile);\n            }\n            else if (!ts.isDeclarationFile(targetSourceFile) && (compilerOptions.outFile || compilerOptions.out)) {\n                emitFile(compilerOptions.outFile || compilerOptions.out);\n            }\n        }\n        // Sort and make the unique list of diagnostics\n        diagnostics = ts.sortAndDeduplicateDiagnostics(diagnostics);\n        return {\n            emitSkipped: false,\n            diagnostics: diagnostics,\n            sourceMaps: sourceMapDataList\n        };\n        function isUniqueLocalName(name, container) {\n            for (var node = container; ts.isNodeDescendentOf(node, container); node = node.nextContainer) {\n                if (node.locals && ts.hasProperty(node.locals, name)) {\n                    // We conservatively include alias symbols to cover cases where they're emitted as locals\n                    if (node.locals[name].flags & (107455 /* Value */ | 1048576 /* ExportValue */ | 8388608 /* Alias */)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        function emitJavaScript(jsFilePath, root) {\n            var writer = ts.createTextWriter(newLine);\n            var write = writer.write, writeTextOfNode = writer.writeTextOfNode, writeLine = writer.writeLine, increaseIndent = writer.increaseIndent, decreaseIndent = writer.decreaseIndent;\n            var currentSourceFile;\n            // name of an exporter function if file is a System external module\n            // System.register([...], function (<exporter>) {...})\n            // exporting in System modules looks like:\n            // export var x; ... x = 1\n            // =>\n            // var x;... exporter(\"x\", x = 1)\n            var exportFunctionForFile;\n            var generatedNameSet = {};\n            var nodeToGeneratedName = [];\n            var computedPropertyNamesToGeneratedNames;\n            var extendsEmitted = false;\n            var decorateEmitted = false;\n            var paramEmitted = false;\n            var awaiterEmitted = false;\n            var tempFlags = 0;\n            var tempVariables;\n            var tempParameters;\n            var externalImports;\n            var exportSpecifiers;\n            var exportEquals;\n            var hasExportStars;\n            /** Write emitted output to disk */\n            var writeEmittedFiles = writeJavaScriptFile;\n            var detachedCommentsInfo;\n            var writeComment = ts.writeCommentRange;\n            /** Emit a node */\n            var emit = emitNodeWithCommentsAndWithoutSourcemap;\n            /** Called just before starting emit of a node */\n            var emitStart = function (node) { };\n            /** Called once the emit of the node is done */\n            var emitEnd = function (node) { };\n            /** Emit the text for the given token that comes after startPos\n             * This by default writes the text provided with the given tokenKind\n             * but if optional emitFn callback is provided the text is emitted using the callback instead of default text\n             * @param tokenKind the kind of the token to search and emit\n             * @param startPos the position in the source to start searching for the token\n             * @param emitFn if given will be invoked to emit the text instead of actual token emit */\n            var emitToken = emitTokenText;\n            /** Called to before starting the lexical scopes as in function/class in the emitted code because of node\n             * @param scopeDeclaration node that starts the lexical scope\n             * @param scopeName Optional name of this scope instead of deducing one from the declaration node */\n            var scopeEmitStart = function (scopeDeclaration, scopeName) { };\n            /** Called after coming out of the scope */\n            var scopeEmitEnd = function () { };\n            /** Sourcemap data that will get encoded */\n            var sourceMapData;\n            /** If removeComments is true, no leading-comments needed to be emitted **/\n            var emitLeadingCommentsOfPosition = compilerOptions.removeComments ? function (pos) { } : emitLeadingCommentsOfPositionWorker;\n            var moduleEmitDelegates = (_a = {},\n                    _a[5 /* ES6 */] = emitES6Module,\n                    _a[2 /* AMD */] = emitAMDModule,\n                    _a[4 /* System */] = emitSystemModule,\n                    _a[3 /* UMD */] = emitUMDModule,\n                    _a[1 /* CommonJS */] = emitCommonJSModule,\n                    _a\n            );\n            if (compilerOptions.sourceMap || compilerOptions.inlineSourceMap) {\n                initializeEmitterWithSourceMaps();\n            }\n            if (root) {\n                // Do not call emit directly. It does not set the currentSourceFile.\n                emitSourceFile(root);\n            }\n            else {\n                ts.forEach(host.getSourceFiles(), function (sourceFile) {\n                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {\n                        emitSourceFile(sourceFile);\n                    }\n                });\n            }\n            writeLine();\n            writeEmittedFiles(writer.getText(), /*writeByteOrderMark*/ compilerOptions.emitBOM);\n            return;\n            function emitSourceFile(sourceFile) {\n                currentSourceFile = sourceFile;\n                exportFunctionForFile = undefined;\n                emit(sourceFile);\n            }\n            function isUniqueName(name) {\n                return !resolver.hasGlobalName(name) &&\n                    !ts.hasProperty(currentSourceFile.identifiers, name) &&\n                    !ts.hasProperty(generatedNameSet, name);\n            }\n            // Return the next available name in the pattern _a ... _z, _0, _1, ...\n            // TempFlags._i or TempFlags._n may be used to express a preference for that dedicated name.\n            // Note that names generated by makeTempVariableName and makeUniqueName will never conflict.\n            function makeTempVariableName(flags) {\n                if (flags && !(tempFlags & flags)) {\n                    var name_19 = flags === 268435456 /* _i */ ? \"_i\" : \"_n\";\n                    if (isUniqueName(name_19)) {\n                        tempFlags |= flags;\n                        return name_19;\n                    }\n                }\n                while (true) {\n                    var count = tempFlags & 268435455 /* CountMask */;\n                    tempFlags++;\n                    // Skip over 'i' and 'n'\n                    if (count !== 8 && count !== 13) {\n                        var name_20 = count < 26 ? \"_\" + String.fromCharCode(97 /* a */ + count) : \"_\" + (count - 26);\n                        if (isUniqueName(name_20)) {\n                            return name_20;\n                        }\n                    }\n                }\n            }\n            // Generate a name that is unique within the current file and doesn't conflict with any names\n            // in global scope. The name is formed by adding an '_n' suffix to the specified base name,\n            // where n is a positive integer. Note that names generated by makeTempVariableName and\n            // makeUniqueName are guaranteed to never conflict.\n            function makeUniqueName(baseName) {\n                // Find the first unique 'name_n', where n is a positive number\n                if (baseName.charCodeAt(baseName.length - 1) !== 95 /* _ */) {\n                    baseName += \"_\";\n                }\n                var i = 1;\n                while (true) {\n                    var generatedName = baseName + i;\n                    if (isUniqueName(generatedName)) {\n                        return generatedNameSet[generatedName] = generatedName;\n                    }\n                    i++;\n                }\n            }\n            function generateNameForModuleOrEnum(node) {\n                var name = node.name.text;\n                // Use module/enum name itself if it is unique, otherwise make a unique variation\n                return isUniqueLocalName(name, node) ? name : makeUniqueName(name);\n            }\n            function generateNameForImportOrExportDeclaration(node) {\n                var expr = ts.getExternalModuleName(node);\n                var baseName = expr.kind === 9 /* StringLiteral */ ?\n                    ts.escapeIdentifier(ts.makeIdentifierFromModuleName(expr.text)) : \"module\";\n                return makeUniqueName(baseName);\n            }\n            function generateNameForExportDefault() {\n                return makeUniqueName(\"default\");\n            }\n            function generateNameForClassExpression() {\n                return makeUniqueName(\"class\");\n            }\n            function generateNameForNode(node) {\n                switch (node.kind) {\n                    case 69 /* Identifier */:\n                        return makeUniqueName(node.text);\n                    case 218 /* ModuleDeclaration */:\n                    case 217 /* EnumDeclaration */:\n                        return generateNameForModuleOrEnum(node);\n                    case 222 /* ImportDeclaration */:\n                    case 228 /* ExportDeclaration */:\n                        return generateNameForImportOrExportDeclaration(node);\n                    case 213 /* FunctionDeclaration */:\n                    case 214 /* ClassDeclaration */:\n                    case 227 /* ExportAssignment */:\n                        return generateNameForExportDefault();\n                    case 186 /* ClassExpression */:\n                        return generateNameForClassExpression();\n                }\n            }\n            function getGeneratedNameForNode(node) {\n                var id = ts.getNodeId(node);\n                return nodeToGeneratedName[id] || (nodeToGeneratedName[id] = ts.unescapeIdentifier(generateNameForNode(node)));\n            }\n            function initializeEmitterWithSourceMaps() {\n                var sourceMapDir; // The directory in which sourcemap will be\n                // Current source map file and its index in the sources list\n                var sourceMapSourceIndex = -1;\n                // Names and its index map\n                var sourceMapNameIndexMap = {};\n                var sourceMapNameIndices = [];\n                function getSourceMapNameIndex() {\n                    return sourceMapNameIndices.length ? ts.lastOrUndefined(sourceMapNameIndices) : -1;\n                }\n                // Last recorded and encoded spans\n                var lastRecordedSourceMapSpan;\n                var lastEncodedSourceMapSpan = {\n                    emittedLine: 1,\n                    emittedColumn: 1,\n                    sourceLine: 1,\n                    sourceColumn: 1,\n                    sourceIndex: 0\n                };\n                var lastEncodedNameIndex = 0;\n                // Encoding for sourcemap span\n                function encodeLastRecordedSourceMapSpan() {\n                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {\n                        return;\n                    }\n                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;\n                    // Line/Comma delimiters\n                    if (lastEncodedSourceMapSpan.emittedLine === lastRecordedSourceMapSpan.emittedLine) {\n                        // Emit comma to separate the entry\n                        if (sourceMapData.sourceMapMappings) {\n                            sourceMapData.sourceMapMappings += \",\";\n                        }\n                    }\n                    else {\n                        // Emit line delimiters\n                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {\n                            sourceMapData.sourceMapMappings += \";\";\n                        }\n                        prevEncodedEmittedColumn = 1;\n                    }\n                    // 1. Relative Column 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);\n                    // 2. Relative sourceIndex\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);\n                    // 3. Relative sourceLine 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);\n                    // 4. Relative sourceColumn 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);\n                    // 5. Relative namePosition 0 based\n                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {\n                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);\n                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;\n                    }\n                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;\n                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);\n                    function base64VLQFormatEncode(inValue) {\n                        function base64FormatEncode(inValue) {\n                            if (inValue < 64) {\n                                return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(inValue);\n                            }\n                            throw TypeError(inValue + \": not a 64 based value\");\n                        }\n                        // Add a new least significant bit that has the sign of the value.\n                        // if negative number the least significant bit that gets added to the number has value 1\n                        // else least significant bit value that gets added is 0\n                        // eg. -1 changes to binary : 01 [1] => 3\n                        //     +1 changes to binary : 01 [0] => 2\n                        if (inValue < 0) {\n                            inValue = ((-inValue) << 1) + 1;\n                        }\n                        else {\n                            inValue = inValue << 1;\n                        }\n                        // Encode 5 bits at a time starting from least significant bits\n                        var encodedStr = \"\";\n                        do {\n                            var currentDigit = inValue & 31; // 11111\n                            inValue = inValue >> 5;\n                            if (inValue > 0) {\n                                // There are still more digits to decode, set the msb (6th bit)\n                                currentDigit = currentDigit | 32;\n                            }\n                            encodedStr = encodedStr + base64FormatEncode(currentDigit);\n                        } while (inValue > 0);\n                        return encodedStr;\n                    }\n                }\n                function recordSourceMapSpan(pos) {\n                    var sourceLinePos = ts.getLineAndCharacterOfPosition(currentSourceFile, pos);\n                    // Convert the location to be one-based.\n                    sourceLinePos.line++;\n                    sourceLinePos.character++;\n                    var emittedLine = writer.getLine();\n                    var emittedColumn = writer.getColumn();\n                    // If this location wasn't recorded or the location in source is going backwards, record the span\n                    if (!lastRecordedSourceMapSpan ||\n                        lastRecordedSourceMapSpan.emittedLine !== emittedLine ||\n                        lastRecordedSourceMapSpan.emittedColumn !== emittedColumn ||\n                        (lastRecordedSourceMapSpan.sourceIndex === sourceMapSourceIndex &&\n                        (lastRecordedSourceMapSpan.sourceLine > sourceLinePos.line ||\n                        (lastRecordedSourceMapSpan.sourceLine === sourceLinePos.line && lastRecordedSourceMapSpan.sourceColumn > sourceLinePos.character)))) {\n                        // Encode the last recordedSpan before assigning new\n                        encodeLastRecordedSourceMapSpan();\n                        // New span\n                        lastRecordedSourceMapSpan = {\n                            emittedLine: emittedLine,\n                            emittedColumn: emittedColumn,\n                            sourceLine: sourceLinePos.line,\n                            sourceColumn: sourceLinePos.character,\n                            nameIndex: getSourceMapNameIndex(),\n                            sourceIndex: sourceMapSourceIndex\n                        };\n                    }\n                    else {\n                        // Take the new pos instead since there is no change in emittedLine and column since last location\n                        lastRecordedSourceMapSpan.sourceLine = sourceLinePos.line;\n                        lastRecordedSourceMapSpan.sourceColumn = sourceLinePos.character;\n                        lastRecordedSourceMapSpan.sourceIndex = sourceMapSourceIndex;\n                    }\n                }\n                function recordEmitNodeStartSpan(node) {\n                    // Get the token pos after skipping to the token (ignoring the leading trivia)\n                    recordSourceMapSpan(ts.skipTrivia(currentSourceFile.text, node.pos));\n                }\n                function recordEmitNodeEndSpan(node) {\n                    recordSourceMapSpan(node.end);\n                }\n                function writeTextWithSpanRecord(tokenKind, startPos, emitFn) {\n                    var tokenStartPos = ts.skipTrivia(currentSourceFile.text, startPos);\n                    recordSourceMapSpan(tokenStartPos);\n                    var tokenEndPos = emitTokenText(tokenKind, tokenStartPos, emitFn);\n                    recordSourceMapSpan(tokenEndPos);\n                    return tokenEndPos;\n                }\n                function recordNewSourceFileStart(node) {\n                    // Add the file to tsFilePaths\n                    // If sourceroot option: Use the relative path corresponding to the common directory path\n                    // otherwise source locations relative to map file location\n                    var sourcesDirectoryPath = compilerOptions.sourceRoot ? host.getCommonSourceDirectory() : sourceMapDir;\n                    sourceMapData.sourceMapSources.push(ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, node.fileName, host.getCurrentDirectory(), host.getCanonicalFileName,\n                        /*isAbsolutePathAnUrl*/ true));\n                    sourceMapSourceIndex = sourceMapData.sourceMapSources.length - 1;\n                    // The one that can be used from program to get the actual source file\n                    sourceMapData.inputSourceFileNames.push(node.fileName);\n                    if (compilerOptions.inlineSources) {\n                        if (!sourceMapData.sourceMapSourcesContent) {\n                            sourceMapData.sourceMapSourcesContent = [];\n                        }\n                        sourceMapData.sourceMapSourcesContent.push(node.text);\n                    }\n                }\n                function recordScopeNameOfNode(node, scopeName) {\n                    function recordScopeNameIndex(scopeNameIndex) {\n                        sourceMapNameIndices.push(scopeNameIndex);\n                    }\n                    function recordScopeNameStart(scopeName) {\n                        var scopeNameIndex = -1;\n                        if (scopeName) {\n                            var parentIndex = getSourceMapNameIndex();\n                            if (parentIndex !== -1) {\n                                // Child scopes are always shown with a dot (even if they have no name),\n                                // unless it is a computed property. Then it is shown with brackets,\n                                // but the brackets are included in the name.\n                                var name_21 = node.name;\n                                if (!name_21 || name_21.kind !== 136 /* ComputedPropertyName */) {\n                                    scopeName = \".\" + scopeName;\n                                }\n                                scopeName = sourceMapData.sourceMapNames[parentIndex] + scopeName;\n                            }\n                            scopeNameIndex = ts.getProperty(sourceMapNameIndexMap, scopeName);\n                            if (scopeNameIndex === undefined) {\n                                scopeNameIndex = sourceMapData.sourceMapNames.length;\n                                sourceMapData.sourceMapNames.push(scopeName);\n                                sourceMapNameIndexMap[scopeName] = scopeNameIndex;\n                            }\n                        }\n                        recordScopeNameIndex(scopeNameIndex);\n                    }\n                    if (scopeName) {\n                        // The scope was already given a name  use it\n                        recordScopeNameStart(scopeName);\n                    }\n                    else if (node.kind === 213 /* FunctionDeclaration */ ||\n                        node.kind === 173 /* FunctionExpression */ ||\n                        node.kind === 143 /* MethodDeclaration */ ||\n                        node.kind === 142 /* MethodSignature */ ||\n                        node.kind === 145 /* GetAccessor */ ||\n                        node.kind === 146 /* SetAccessor */ ||\n                        node.kind === 218 /* ModuleDeclaration */ ||\n                        node.kind === 214 /* ClassDeclaration */ ||\n                        node.kind === 217 /* EnumDeclaration */) {\n                        // Declaration and has associated name use it\n                        if (node.name) {\n                            var name_22 = node.name;\n                            // For computed property names, the text will include the brackets\n                            scopeName = name_22.kind === 136 /* ComputedPropertyName */\n                                ? ts.getTextOfNode(name_22)\n                                : node.name.text;\n                        }\n                        recordScopeNameStart(scopeName);\n                    }\n                    else {\n                        // Block just use the name from upper level scope\n                        recordScopeNameIndex(getSourceMapNameIndex());\n                    }\n                }\n                function recordScopeNameEnd() {\n                    sourceMapNameIndices.pop();\n                }\n                ;\n                function writeCommentRangeWithMap(curentSourceFile, writer, comment, newLine) {\n                    recordSourceMapSpan(comment.pos);\n                    ts.writeCommentRange(currentSourceFile, writer, comment, newLine);\n                    recordSourceMapSpan(comment.end);\n                }\n                function serializeSourceMapContents(version, file, sourceRoot, sources, names, mappings, sourcesContent) {\n                    if (typeof JSON !== \"undefined\") {\n                        var map_1 = {\n                            version: version,\n                            file: file,\n                            sourceRoot: sourceRoot,\n                            sources: sources,\n                            names: names,\n                            mappings: mappings\n                        };\n                        if (sourcesContent !== undefined) {\n                            map_1.sourcesContent = sourcesContent;\n                        }\n                        return JSON.stringify(map_1);\n                    }\n                    return \"{\\\"version\\\":\" + version + \",\\\"file\\\":\\\"\" + ts.escapeString(file) + \"\\\",\\\"sourceRoot\\\":\\\"\" + ts.escapeString(sourceRoot) + \"\\\",\\\"sources\\\":[\" + serializeStringArray(sources) + \"],\\\"names\\\":[\" + serializeStringArray(names) + \"],\\\"mappings\\\":\\\"\" + ts.escapeString(mappings) + \"\\\" \" + (sourcesContent !== undefined ? \",\\\"sourcesContent\\\":[\" + serializeStringArray(sourcesContent) + \"]\" : \"\") + \"}\";\n                    function serializeStringArray(list) {\n                        var output = \"\";\n                        for (var i = 0, n = list.length; i < n; i++) {\n                            if (i) {\n                                output += \",\";\n                            }\n                            output += \"\\\"\" + ts.escapeString(list[i]) + \"\\\"\";\n                        }\n                        return output;\n                    }\n                }\n                function writeJavaScriptAndSourceMapFile(emitOutput, writeByteOrderMark) {\n                    encodeLastRecordedSourceMapSpan();\n                    var sourceMapText = serializeSourceMapContents(3, sourceMapData.sourceMapFile, sourceMapData.sourceMapSourceRoot, sourceMapData.sourceMapSources, sourceMapData.sourceMapNames, sourceMapData.sourceMapMappings, sourceMapData.sourceMapSourcesContent);\n                    sourceMapDataList.push(sourceMapData);\n                    var sourceMapUrl;\n                    if (compilerOptions.inlineSourceMap) {\n                        // Encode the sourceMap into the sourceMap url\n                        var base64SourceMapText = ts.convertToBase64(sourceMapText);\n                        sourceMapUrl = \"//# sourceMappingURL=data:application/json;base64,\" + base64SourceMapText;\n                    }\n                    else {\n                        // Write source map file\n                        ts.writeFile(host, diagnostics, sourceMapData.sourceMapFilePath, sourceMapText, /*writeByteOrderMark*/ false);\n                        sourceMapUrl = \"//# sourceMappingURL=\" + sourceMapData.jsSourceMappingURL;\n                    }\n                    // Write sourcemap url to the js file and write the js file\n                    writeJavaScriptFile(emitOutput + sourceMapUrl, writeByteOrderMark);\n                }\n                // Initialize source map data\n                var sourceMapJsFile = ts.getBaseFileName(ts.normalizeSlashes(jsFilePath));\n                sourceMapData = {\n                    sourceMapFilePath: jsFilePath + \".map\",\n                    jsSourceMappingURL: sourceMapJsFile + \".map\",\n                    sourceMapFile: sourceMapJsFile,\n                    sourceMapSourceRoot: compilerOptions.sourceRoot || \"\",\n                    sourceMapSources: [],\n                    inputSourceFileNames: [],\n                    sourceMapNames: [],\n                    sourceMapMappings: \"\",\n                    sourceMapSourcesContent: undefined,\n                    sourceMapDecodedMappings: []\n                };\n                // Normalize source root and make sure it has trailing \"/\" so that it can be used to combine paths with the\n                // relative paths of the sources list in the sourcemap\n                sourceMapData.sourceMapSourceRoot = ts.normalizeSlashes(sourceMapData.sourceMapSourceRoot);\n                if (sourceMapData.sourceMapSourceRoot.length && sourceMapData.sourceMapSourceRoot.charCodeAt(sourceMapData.sourceMapSourceRoot.length - 1) !== 47 /* slash */) {\n                    sourceMapData.sourceMapSourceRoot += ts.directorySeparator;\n                }\n                if (compilerOptions.mapRoot) {\n                    sourceMapDir = ts.normalizeSlashes(compilerOptions.mapRoot);\n                    if (root) {\n                        // For modules or multiple emit files the mapRoot will have directory structure like the sources\n                        // So if src\\a.ts and src\\lib\\b.ts are compiled together user would be moving the maps into mapRoot\\a.js.map and mapRoot\\lib\\b.js.map\n                        sourceMapDir = ts.getDirectoryPath(ts.getSourceFilePathInNewDir(root, host, sourceMapDir));\n                    }\n                    if (!ts.isRootedDiskPath(sourceMapDir) && !ts.isUrl(sourceMapDir)) {\n                        // The relative paths are relative to the common directory\n                        sourceMapDir = ts.combinePaths(host.getCommonSourceDirectory(), sourceMapDir);\n                        sourceMapData.jsSourceMappingURL = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(jsFilePath)), // get the relative sourceMapDir path based on jsFilePath\n                            ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL), // this is where user expects to see sourceMap\n                            host.getCurrentDirectory(), host.getCanonicalFileName,\n                            /*isAbsolutePathAnUrl*/ true);\n                    }\n                    else {\n                        sourceMapData.jsSourceMappingURL = ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL);\n                    }\n                }\n                else {\n                    sourceMapDir = ts.getDirectoryPath(ts.normalizePath(jsFilePath));\n                }\n                function emitNodeWithSourceMap(node) {\n                    if (node) {\n                        if (ts.nodeIsSynthesized(node)) {\n                            return emitNodeWithoutSourceMap(node);\n                        }\n                        if (node.kind !== 248 /* SourceFile */) {\n                            recordEmitNodeStartSpan(node);\n                            emitNodeWithoutSourceMap(node);\n                            recordEmitNodeEndSpan(node);\n                        }\n                        else {\n                            recordNewSourceFileStart(node);\n                            emitNodeWithoutSourceMap(node);\n                        }\n                    }\n                }\n                function emitNodeWithCommentsAndWithSourcemap(node) {\n                    emitNodeConsideringCommentsOption(node, emitNodeWithSourceMap);\n                }\n                writeEmittedFiles = writeJavaScriptAndSourceMapFile;\n                emit = emitNodeWithCommentsAndWithSourcemap;\n                emitStart = recordEmitNodeStartSpan;\n                emitEnd = recordEmitNodeEndSpan;\n                emitToken = writeTextWithSpanRecord;\n                scopeEmitStart = recordScopeNameOfNode;\n                scopeEmitEnd = recordScopeNameEnd;\n                writeComment = writeCommentRangeWithMap;\n            }\n            function writeJavaScriptFile(emitOutput, writeByteOrderMark) {\n                ts.writeFile(host, diagnostics, jsFilePath, emitOutput, writeByteOrderMark);\n            }\n            // Create a temporary variable with a unique unused name.\n            function createTempVariable(flags) {\n                var result = ts.createSynthesizedNode(69 /* Identifier */);\n                result.text = makeTempVariableName(flags);\n                return result;\n            }\n            function recordTempDeclaration(name) {\n                if (!tempVariables) {\n                    tempVariables = [];\n                }\n                tempVariables.push(name);\n            }\n            function createAndRecordTempVariable(flags) {\n                var temp = createTempVariable(flags);\n                recordTempDeclaration(temp);\n                return temp;\n            }\n            function emitTempDeclarations(newLine) {\n                if (tempVariables) {\n                    if (newLine) {\n                        writeLine();\n                    }\n                    else {\n                        write(\" \");\n                    }\n                    write(\"var \");\n                    emitCommaList(tempVariables);\n                    write(\";\");\n                }\n            }\n            function emitTokenText(tokenKind, startPos, emitFn) {\n                var tokenString = ts.tokenToString(tokenKind);\n                if (emitFn) {\n                    emitFn();\n                }\n                else {\n                    write(tokenString);\n                }\n                return startPos + tokenString.length;\n            }\n            function emitOptional(prefix, node) {\n                if (node) {\n                    write(prefix);\n                    emit(node);\n                }\n            }\n            function emitParenthesizedIf(node, parenthesized) {\n                if (parenthesized) {\n                    write(\"(\");\n                }\n                emit(node);\n                if (parenthesized) {\n                    write(\")\");\n                }\n            }\n            function emitTrailingCommaIfPresent(nodeList) {\n                if (nodeList.hasTrailingComma) {\n                    write(\",\");\n                }\n            }\n            function emitLinePreservingList(parent, nodes, allowTrailingComma, spacesBetweenBraces) {\n                ts.Debug.assert(nodes.length > 0);\n                increaseIndent();\n                if (nodeStartPositionsAreOnSameLine(parent, nodes[0])) {\n                    if (spacesBetweenBraces) {\n                        write(\" \");\n                    }\n                }\n                else {\n                    writeLine();\n                }\n                for (var i = 0, n = nodes.length; i < n; i++) {\n                    if (i) {\n                        if (nodeEndIsOnSameLineAsNodeStart(nodes[i - 1], nodes[i])) {\n                            write(\", \");\n                        }\n                        else {\n                            write(\",\");\n                            writeLine();\n                        }\n                    }\n                    emit(nodes[i]);\n                }\n                if (nodes.hasTrailingComma && allowTrailingComma) {\n                    write(\",\");\n                }\n                decreaseIndent();\n                if (nodeEndPositionsAreOnSameLine(parent, ts.lastOrUndefined(nodes))) {\n                    if (spacesBetweenBraces) {\n                        write(\" \");\n                    }\n                }\n                else {\n                    writeLine();\n                }\n            }\n            function emitList(nodes, start, count, multiLine, trailingComma, leadingComma, noTrailingNewLine, emitNode) {\n                if (!emitNode) {\n                    emitNode = emit;\n                }\n                for (var i = 0; i < count; i++) {\n                    if (multiLine) {\n                        if (i || leadingComma) {\n                            write(\",\");\n                        }\n                        writeLine();\n                    }\n                    else {\n                        if (i || leadingComma) {\n                            write(\", \");\n                        }\n                    }\n                    var node = nodes[start + i];\n                    // This emitting is to make sure we emit following comment properly\n                    //   ...(x, /*comment1*/ y)...\n                    //         ^ => node.pos\n                    // \"comment1\" is not considered leading comment for \"y\" but rather\n                    // considered as trailing comment of the previous node.\n                    emitTrailingCommentsOfPosition(node.pos);\n                    emitNode(node);\n                    leadingComma = true;\n                }\n                if (trailingComma) {\n                    write(\",\");\n                }\n                if (multiLine && !noTrailingNewLine) {\n                    writeLine();\n                }\n                return count;\n            }\n            function emitCommaList(nodes) {\n                if (nodes) {\n                    emitList(nodes, 0, nodes.length, /*multiline*/ false, /*trailingComma*/ false);\n                }\n            }\n            function emitLines(nodes) {\n                emitLinesStartingAt(nodes, /*startIndex*/ 0);\n            }\n            function emitLinesStartingAt(nodes, startIndex) {\n                for (var i = startIndex; i < nodes.length; i++) {\n                    writeLine();\n                    emit(nodes[i]);\n                }\n            }\n            function isBinaryOrOctalIntegerLiteral(node, text) {\n                if (node.kind === 8 /* NumericLiteral */ && text.length > 1) {\n                    switch (text.charCodeAt(1)) {\n                        case 98 /* b */:\n                        case 66 /* B */:\n                        case 111 /* o */:\n                        case 79 /* O */:\n                            return true;\n                    }\n                }\n                return false;\n            }\n            function emitLiteral(node) {\n                var text = getLiteralText(node);\n                if ((compilerOptions.sourceMap || compilerOptions.inlineSourceMap) && (node.kind === 9 /* StringLiteral */ || ts.isTemplateLiteralKind(node.kind))) {\n                    writer.writeLiteral(text);\n                }\n                else if (languageVersion < 2 /* ES6 */ && isBinaryOrOctalIntegerLiteral(node, text)) {\n                    write(node.text);\n                }\n                else {\n                    write(text);\n                }\n            }\n            function getLiteralText(node) {\n                // Any template literal or string literal with an extended escape\n                // (e.g. \"\\u{0067}\") will need to be downleveled as a escaped string literal.\n                if (languageVersion < 2 /* ES6 */ && (ts.isTemplateLiteralKind(node.kind) || node.hasExtendedUnicodeEscape)) {\n                    return getQuotedEscapedLiteralText(\"\\\"\", node.text, \"\\\"\");\n                }\n                // If we don't need to downlevel and we can reach the original source text using\n                // the node's parent reference, then simply get the text as it was originally written.\n                if (node.parent) {\n                    return ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);\n                }\n                // If we can't reach the original source text, use the canonical form if it's a number,\n                // or an escaped quoted form of the original text if it's string-like.\n                switch (node.kind) {\n                    case 9 /* StringLiteral */:\n                        return getQuotedEscapedLiteralText(\"\\\"\", node.text, \"\\\"\");\n                    case 11 /* NoSubstitutionTemplateLiteral */:\n                        return getQuotedEscapedLiteralText(\"`\", node.text, \"`\");\n                    case 12 /* TemplateHead */:\n                        return getQuotedEscapedLiteralText(\"`\", node.text, \"${\");\n                    case 13 /* TemplateMiddle */:\n                        return getQuotedEscapedLiteralText(\"}\", node.text, \"${\");\n                    case 14 /* TemplateTail */:\n                        return getQuotedEscapedLiteralText(\"}\", node.text, \"`\");\n                    case 8 /* NumericLiteral */:\n                        return node.text;\n                }\n                ts.Debug.fail(\"Literal kind '\" + node.kind + \"' not accounted for.\");\n            }\n            function getQuotedEscapedLiteralText(leftQuote, text, rightQuote) {\n                return leftQuote + ts.escapeNonAsciiCharacters(ts.escapeString(text)) + rightQuote;\n            }\n            function emitDownlevelRawTemplateLiteral(node) {\n                // Find original source text, since we need to emit the raw strings of the tagged template.\n                // The raw strings contain the (escaped) strings of what the user wrote.\n                // Examples: `\\n` is converted to \"\\\\n\", a template string with a newline to \"\\n\".\n                var text = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);\n                // text contains the original source, it will also contain quotes (\"`\"), dolar signs and braces (\"${\" and \"}\"),\n                // thus we need to remove those characters.\n                // First template piece starts with \"`\", others with \"}\"\n                // Last template piece ends with \"`\", others with \"${\"\n                var isLast = node.kind === 11 /* NoSubstitutionTemplateLiteral */ || node.kind === 14 /* TemplateTail */;\n                text = text.substring(1, text.length - (isLast ? 1 : 2));\n                // Newline normalization:\n                // ES6 Spec 11.8.6.1 - Static Semantics of TV's and TRV's\n                // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for both TV and TRV.\n                text = text.replace(/\\r\\n?/g, \"\\n\");\n                text = ts.escapeString(text);\n                write(\"\\\"\" + text + \"\\\"\");\n            }\n            function emitDownlevelTaggedTemplateArray(node, literalEmitter) {\n                write(\"[\");\n                if (node.template.kind === 11 /* NoSubstitutionTemplateLiteral */) {\n                    literalEmitter(node.template);\n                }\n                else {\n                    literalEmitter(node.template.head);\n                    ts.forEach(node.template.templateSpans, function (child) {\n                        write(\", \");\n                        literalEmitter(child.literal);\n                    });\n                }\n                write(\"]\");\n            }\n            function emitDownlevelTaggedTemplate(node) {\n                var tempVariable = createAndRecordTempVariable(0 /* Auto */);\n                write(\"(\");\n                emit(tempVariable);\n                write(\" = \");\n                emitDownlevelTaggedTemplateArray(node, emit);\n                write(\", \");\n                emit(tempVariable);\n                write(\".raw = \");\n                emitDownlevelTaggedTemplateArray(node, emitDownlevelRawTemplateLiteral);\n                write(\", \");\n                emitParenthesizedIf(node.tag, needsParenthesisForPropertyAccessOrInvocation(node.tag));\n                write(\"(\");\n                emit(tempVariable);\n                // Now we emit the expressions\n                if (node.template.kind === 183 /* TemplateExpression */) {\n                    ts.forEach(node.template.templateSpans, function (templateSpan) {\n                        write(\", \");\n                        var needsParens = templateSpan.expression.kind === 181 /* BinaryExpression */\n                            && templateSpan.expression.operatorToken.kind === 24 /* CommaToken */;\n                        emitParenthesizedIf(templateSpan.expression, needsParens);\n                    });\n                }\n                write(\"))\");\n            }\n            function emitTemplateExpression(node) {\n                // In ES6 mode and above, we can simply emit each portion of a template in order, but in\n                // ES3 & ES5 we must convert the template expression into a series of string concatenations.\n                if (languageVersion >= 2 /* ES6 */) {\n                    ts.forEachChild(node, emit);\n                    return;\n                }\n                var emitOuterParens = ts.isExpression(node.parent)\n                    && templateNeedsParens(node, node.parent);\n                if (emitOuterParens) {\n                    write(\"(\");\n                }\n                var headEmitted = false;\n                if (shouldEmitTemplateHead()) {\n                    emitLiteral(node.head);\n                    headEmitted = true;\n                }\n                for (var i = 0, n = node.templateSpans.length; i < n; i++) {\n                    var templateSpan = node.templateSpans[i];\n                    // Check if the expression has operands and binds its operands less closely than binary '+'.\n                    // If it does, we need to wrap the expression in parentheses. Otherwise, something like\n                    //    `abc${ 1 << 2 }`\n                    // becomes\n                    //    \"abc\" + 1 << 2 + \"\"\n                    // which is really\n                    //    (\"abc\" + 1) << (2 + \"\")\n                    // rather than\n                    //    \"abc\" + (1 << 2) + \"\"\n                    var needsParens = templateSpan.expression.kind !== 172 /* ParenthesizedExpression */\n                        && comparePrecedenceToBinaryPlus(templateSpan.expression) !== 1 /* GreaterThan */;\n                    if (i > 0 || headEmitted) {\n                        // If this is the first span and the head was not emitted, then this templateSpan's\n                        // expression will be the first to be emitted. Don't emit the preceding ' + ' in that\n                        // case.\n                        write(\" + \");\n                    }\n                    emitParenthesizedIf(templateSpan.expression, needsParens);\n                    // Only emit if the literal is non-empty.\n                    // The binary '+' operator is left-associative, so the first string concatenation\n                    // with the head will force the result up to this point to be a string.\n                    // Emitting a '+ \"\"' has no semantic effect for middles and tails.\n                    if (templateSpan.literal.text.length !== 0) {\n                        write(\" + \");\n                        emitLiteral(templateSpan.literal);\n                    }\n                }\n                if (emitOuterParens) {\n                    write(\")\");\n                }\n                function shouldEmitTemplateHead() {\n                    // If this expression has an empty head literal and the first template span has a non-empty\n                    // literal, then emitting the empty head literal is not necessary.\n                    //     `${ foo } and ${ bar }`\n                    // can be emitted as\n                    //     foo + \" and \" + bar\n                    // This is because it is only required that one of the first two operands in the emit\n                    // output must be a string literal, so that the other operand and all following operands\n                    // are forced into strings.\n                    //\n                    // If the first template span has an empty literal, then the head must still be emitted.\n                    //     `${ foo }${ bar }`\n                    // must still be emitted as\n                    //     \"\" + foo + bar\n                    // There is always atleast one templateSpan in this code path, since\n                    // NoSubstitutionTemplateLiterals are directly emitted via emitLiteral()\n                    ts.Debug.assert(node.templateSpans.length !== 0);\n                    return node.head.text.length !== 0 || node.templateSpans[0].literal.text.length === 0;\n                }\n                function templateNeedsParens(template, parent) {\n                    switch (parent.kind) {\n                        case 168 /* CallExpression */:\n                        case 169 /* NewExpression */:\n                            return parent.expression === template;\n                        case 170 /* TaggedTemplateExpression */:\n                        case 172 /* ParenthesizedExpression */:\n                            return false;\n                        default:\n                            return comparePrecedenceToBinaryPlus(parent) !== -1 /* LessThan */;\n                    }\n                }\n                /**\n                 * Returns whether the expression has lesser, greater,\n                 * or equal precedence to the binary '+' operator\n                 */\n                function comparePrecedenceToBinaryPlus(expression) {\n                    // All binary expressions have lower precedence than '+' apart from '*', '/', and '%'\n                    // which have greater precedence and '-' which has equal precedence.\n                    // All unary operators have a higher precedence apart from yield.\n                    // Arrow functions and conditionals have a lower precedence,\n                    // although we convert the former into regular function expressions in ES5 mode,\n                    // and in ES6 mode this function won't get called anyway.\n                    //\n                    // TODO (drosen): Note that we need to account for the upcoming 'yield' and\n                    //                spread ('...') unary operators that are anticipated for ES6.\n                    switch (expression.kind) {\n                        case 181 /* BinaryExpression */:\n                            switch (expression.operatorToken.kind) {\n                                case 37 /* AsteriskToken */:\n                                case 39 /* SlashToken */:\n                                case 40 /* PercentToken */:\n                                    return 1 /* GreaterThan */;\n                                case 35 /* PlusToken */:\n                                case 36 /* MinusToken */:\n                                    return 0 /* EqualTo */;\n                                default:\n                                    return -1 /* LessThan */;\n                            }\n                        case 184 /* YieldExpression */:\n                        case 182 /* ConditionalExpression */:\n                            return -1 /* LessThan */;\n                        default:\n                            return 1 /* GreaterThan */;\n                    }\n                }\n            }\n            function emitTemplateSpan(span) {\n                emit(span.expression);\n                emit(span.literal);\n            }\n            function jsxEmitReact(node) {\n                /// Emit a tag name, which is either '\"div\"' for lower-cased names, or\n                /// 'Div' for upper-cased or dotted names\n                function emitTagName(name) {\n                    if (name.kind === 69 /* Identifier */ && ts.isIntrinsicJsxName(name.text)) {\n                        write(\"\\\"\");\n                        emit(name);\n                        write(\"\\\"\");\n                    }\n                    else {\n                        emit(name);\n                    }\n                }\n                /// Emit an attribute name, which is quoted if it needs to be quoted. Because\n                /// these emit into an object literal property name, we don't need to be worried\n                /// about keywords, just non-identifier characters\n                function emitAttributeName(name) {\n                    if (/[A-Za-z_]+[\\w*]/.test(name.text)) {\n                        write(\"\\\"\");\n                        emit(name);\n                        write(\"\\\"\");\n                    }\n                    else {\n                        emit(name);\n                    }\n                }\n                /// Emit an name/value pair for an attribute (e.g. \"x: 3\")\n                function emitJsxAttribute(node) {\n                    emitAttributeName(node.name);\n                    write(\": \");\n                    if (node.initializer) {\n                        emit(node.initializer);\n                    }\n                    else {\n                        write(\"true\");\n                    }\n                }\n                function emitJsxElement(openingNode, children) {\n                    var syntheticReactRef = ts.createSynthesizedNode(69 /* Identifier */);\n                    syntheticReactRef.text = \"React\";\n                    syntheticReactRef.parent = openingNode;\n                    // Call React.createElement(tag, ...\n                    emitLeadingComments(openingNode);\n                    emitExpressionIdentifier(syntheticReactRef);\n                    write(\".createElement(\");\n                    emitTagName(openingNode.tagName);\n                    write(\", \");\n                    // Attribute list\n                    if (openingNode.attributes.length === 0) {\n                        // When there are no attributes, React wants \"null\"\n                        write(\"null\");\n                    }\n                    else {\n                        // Either emit one big object literal (no spread attribs), or\n                        // a call to React.__spread\n                        var attrs = openingNode.attributes;\n                        if (ts.forEach(attrs, function (attr) { return attr.kind === 239 /* JsxSpreadAttribute */; })) {\n                            emitExpressionIdentifier(syntheticReactRef);\n                            write(\".__spread(\");\n                            var haveOpenedObjectLiteral = false;\n                            for (var i_1 = 0; i_1 < attrs.length; i_1++) {\n                                if (attrs[i_1].kind === 239 /* JsxSpreadAttribute */) {\n                                    // If this is the first argument, we need to emit a {} as the first argument\n                                    if (i_1 === 0) {\n                                        write(\"{}, \");\n                                    }\n                                    if (haveOpenedObjectLiteral) {\n                                        write(\"}\");\n                                        haveOpenedObjectLiteral = false;\n                                    }\n                                    if (i_1 > 0) {\n                                        write(\", \");\n                                    }\n                                    emit(attrs[i_1].expression);\n                                }\n                                else {\n                                    ts.Debug.assert(attrs[i_1].kind === 238 /* JsxAttribute */);\n                                    if (haveOpenedObjectLiteral) {\n                                        write(\", \");\n                                    }\n                                    else {\n                                        haveOpenedObjectLiteral = true;\n                                        if (i_1 > 0) {\n                                            write(\", \");\n                                        }\n                                        write(\"{\");\n                                    }\n                                    emitJsxAttribute(attrs[i_1]);\n                                }\n                            }\n                            if (haveOpenedObjectLiteral)\n                                write(\"}\");\n                            write(\")\"); // closing paren to React.__spread(\n                        }\n                        else {\n                            // One object literal with all the attributes in them\n                            write(\"{\");\n                            for (var i = 0; i < attrs.length; i++) {\n                                if (i > 0) {\n                                    write(\", \");\n                                }\n                                emitJsxAttribute(attrs[i]);\n                            }\n                            write(\"}\");\n                        }\n                    }\n                    // Children\n                    if (children) {\n                        for (var i = 0; i < children.length; i++) {\n                            // Don't emit empty expressions\n                            if (children[i].kind === 240 /* JsxExpression */ && !(children[i].expression)) {\n                                continue;\n                            }\n                            // Don't emit empty strings\n                            if (children[i].kind === 236 /* JsxText */) {\n                                var text = getTextToEmit(children[i]);\n                                if (text !== undefined) {\n                                    write(\", \\\"\");\n                                    write(text);\n                                    write(\"\\\"\");\n                                }\n                            }\n                            else {\n                                write(\", \");\n                                emit(children[i]);\n                            }\n                        }\n                    }\n                    // Closing paren\n                    write(\")\"); // closes \"React.createElement(\"\n                    emitTrailingComments(openingNode);\n                }\n                if (node.kind === 233 /* JsxElement */) {\n                    emitJsxElement(node.openingElement, node.children);\n                }\n                else {\n                    ts.Debug.assert(node.kind === 234 /* JsxSelfClosingElement */);\n                    emitJsxElement(node);\n                }\n            }\n            function jsxEmitPreserve(node) {\n                function emitJsxAttribute(node) {\n                    emit(node.name);\n                    if (node.initializer) {\n                        write(\"=\");\n                        emit(node.initializer);\n                    }\n                }\n                function emitJsxSpreadAttribute(node) {\n                    write(\"{...\");\n                    emit(node.expression);\n                    write(\"}\");\n                }\n                function emitAttributes(attribs) {\n                    for (var i = 0, n = attribs.length; i < n; i++) {\n                        if (i > 0) {\n                            write(\" \");\n                        }\n                        if (attribs[i].kind === 239 /* JsxSpreadAttribute */) {\n                            emitJsxSpreadAttribute(attribs[i]);\n                        }\n                        else {\n                            ts.Debug.assert(attribs[i].kind === 238 /* JsxAttribute */);\n                            emitJsxAttribute(attribs[i]);\n                        }\n                    }\n                }\n                function emitJsxOpeningOrSelfClosingElement(node) {\n                    write(\"<\");\n                    emit(node.tagName);\n                    if (node.attributes.length > 0 || (node.kind === 234 /* JsxSelfClosingElement */)) {\n                        write(\" \");\n                    }\n                    emitAttributes(node.attributes);\n                    if (node.kind === 234 /* JsxSelfClosingElement */) {\n                        write(\"/>\");\n                    }\n                    else {\n                        write(\">\");\n                    }\n                }\n                function emitJsxClosingElement(node) {\n                    write(\"</\");\n                    emit(node.tagName);\n                    write(\">\");\n                }\n                function emitJsxElement(node) {\n                    emitJsxOpeningOrSelfClosingElement(node.openingElement);\n                    for (var i = 0, n = node.children.length; i < n; i++) {\n                        emit(node.children[i]);\n                    }\n                    emitJsxClosingElement(node.closingElement);\n                }\n                if (node.kind === 233 /* JsxElement */) {\n                    emitJsxElement(node);\n                }\n                else {\n                    ts.Debug.assert(node.kind === 234 /* JsxSelfClosingElement */);\n                    emitJsxOpeningOrSelfClosingElement(node);\n                }\n            }\n            // This function specifically handles numeric/string literals for enum and accessor 'identifiers'.\n            // In a sense, it does not actually emit identifiers as much as it declares a name for a specific property.\n            // For example, this is utilized when feeding in a result to Object.defineProperty.\n            function emitExpressionForPropertyName(node) {\n                ts.Debug.assert(node.kind !== 163 /* BindingElement */);\n                if (node.kind === 9 /* StringLiteral */) {\n                    emitLiteral(node);\n                }\n                else if (node.kind === 136 /* ComputedPropertyName */) {\n                    // if this is a decorated computed property, we will need to capture the result\n                    // of the property expression so that we can apply decorators later. This is to ensure\n                    // we don't introduce unintended side effects:\n                    //\n                    //   class C {\n                    //     [_a = x]() { }\n                    //   }\n                    //\n                    // The emit for the decorated computed property decorator is:\n                    //\n                    //   __decorate([dec], C.prototype, _a, Object.getOwnPropertyDescriptor(C.prototype, _a));\n                    //\n                    if (ts.nodeIsDecorated(node.parent)) {\n                        if (!computedPropertyNamesToGeneratedNames) {\n                            computedPropertyNamesToGeneratedNames = [];\n                        }\n                        var generatedName = computedPropertyNamesToGeneratedNames[ts.getNodeId(node)];\n                        if (generatedName) {\n                            // we have already generated a variable for this node, write that value instead.\n                            write(generatedName);\n                            return;\n                        }\n                        generatedName = createAndRecordTempVariable(0 /* Auto */).text;\n                        computedPropertyNamesToGeneratedNames[ts.getNodeId(node)] = generatedName;\n                        write(generatedName);\n                        write(\" = \");\n                    }\n                    emit(node.expression);\n                }\n                else {\n                    write(\"\\\"\");\n                    if (node.kind === 8 /* NumericLiteral */) {\n                        write(node.text);\n                    }\n                    else {\n                        writeTextOfNode(currentSourceFile, node);\n                    }\n                    write(\"\\\"\");\n                }\n            }\n            function isExpressionIdentifier(node) {\n                var parent = node.parent;\n                switch (parent.kind) {\n                    case 164 /* ArrayLiteralExpression */:\n                    case 189 /* AsExpression */:\n                    case 181 /* BinaryExpression */:\n                    case 168 /* CallExpression */:\n                    case 241 /* CaseClause */:\n                    case 136 /* ComputedPropertyName */:\n                    case 182 /* ConditionalExpression */:\n                    case 139 /* Decorator */:\n                    case 175 /* DeleteExpression */:\n                    case 197 /* DoStatement */:\n                    case 167 /* ElementAccessExpression */:\n                    case 227 /* ExportAssignment */:\n                    case 195 /* ExpressionStatement */:\n                    case 188 /* ExpressionWithTypeArguments */:\n                    case 199 /* ForStatement */:\n                    case 200 /* ForInStatement */:\n                    case 201 /* ForOfStatement */:\n                    case 196 /* IfStatement */:\n                    case 234 /* JsxSelfClosingElement */:\n                    case 235 /* JsxOpeningElement */:\n                    case 239 /* JsxSpreadAttribute */:\n                    case 240 /* JsxExpression */:\n                    case 169 /* NewExpression */:\n                    case 172 /* ParenthesizedExpression */:\n                    case 180 /* PostfixUnaryExpression */:\n                    case 179 /* PrefixUnaryExpression */:\n                    case 204 /* ReturnStatement */:\n                    case 246 /* ShorthandPropertyAssignment */:\n                    case 185 /* SpreadElementExpression */:\n                    case 206 /* SwitchStatement */:\n                    case 170 /* TaggedTemplateExpression */:\n                    case 190 /* TemplateSpan */:\n                    case 208 /* ThrowStatement */:\n                    case 171 /* TypeAssertionExpression */:\n                    case 176 /* TypeOfExpression */:\n                    case 177 /* VoidExpression */:\n                    case 198 /* WhileStatement */:\n                    case 205 /* WithStatement */:\n                    case 184 /* YieldExpression */:\n                        return true;\n                    case 163 /* BindingElement */:\n                    case 247 /* EnumMember */:\n                    case 138 /* Parameter */:\n                    case 245 /* PropertyAssignment */:\n                    case 141 /* PropertyDeclaration */:\n                    case 211 /* VariableDeclaration */:\n                        return parent.initializer === node;\n                    case 166 /* PropertyAccessExpression */:\n                        return parent.expression === node;\n                    case 174 /* ArrowFunction */:\n                    case 173 /* FunctionExpression */:\n                        return parent.body === node;\n                    case 221 /* ImportEqualsDeclaration */:\n                        return parent.moduleReference === node;\n                    case 135 /* QualifiedName */:\n                        return parent.left === node;\n                }\n                return false;\n            }\n            function emitExpressionIdentifier(node) {\n                if (resolver.getNodeCheckFlags(node) & 2048 /* LexicalArguments */) {\n                    write(\"_arguments\");\n                    return;\n                }\n                var container = resolver.getReferencedExportContainer(node);\n                if (container) {\n                    if (container.kind === 248 /* SourceFile */) {\n                        // Identifier references module export\n                        if (modulekind !== 5 /* ES6 */ && modulekind !== 4 /* System */) {\n                            write(\"exports.\");\n                        }\n                    }\n                    else {\n                        // Identifier references namespace export\n                        write(getGeneratedNameForNode(container));\n                        write(\".\");\n                    }\n                }\n                else {\n                    if (modulekind !== 5 /* ES6 */) {\n                        var declaration = resolver.getReferencedImportDeclaration(node);\n                        if (declaration) {\n                            if (declaration.kind === 223 /* ImportClause */) {\n                                // Identifier references default import\n                                write(getGeneratedNameForNode(declaration.parent));\n                                write(languageVersion === 0 /* ES3 */ ? \"[\\\"default\\\"]\" : \".default\");\n                                return;\n                            }\n                            else if (declaration.kind === 226 /* ImportSpecifier */) {\n                                // Identifier references named import\n                                write(getGeneratedNameForNode(declaration.parent.parent.parent));\n                                var name_23 = declaration.propertyName || declaration.name;\n                                var identifier = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, name_23);\n                                if (languageVersion === 0 /* ES3 */ && identifier === \"default\") {\n                                    write(\"[\\\"default\\\"]\");\n                                }\n                                else {\n                                    write(\".\");\n                                    write(identifier);\n                                }\n                                return;\n                            }\n                        }\n                    }\n                    if (languageVersion !== 2 /* ES6 */) {\n                        var declaration = resolver.getReferencedNestedRedeclaration(node);\n                        if (declaration) {\n                            write(getGeneratedNameForNode(declaration.name));\n                            return;\n                        }\n                    }\n                }\n                if (ts.nodeIsSynthesized(node)) {\n                    write(node.text);\n                }\n                else {\n                    writeTextOfNode(currentSourceFile, node);\n                }\n            }\n            function isNameOfNestedRedeclaration(node) {\n                if (languageVersion < 2 /* ES6 */) {\n                    var parent_6 = node.parent;\n                    switch (parent_6.kind) {\n                        case 163 /* BindingElement */:\n                        case 214 /* ClassDeclaration */:\n                        case 217 /* EnumDeclaration */:\n                        case 211 /* VariableDeclaration */:\n                            return parent_6.name === node && resolver.isNestedRedeclaration(parent_6);\n                    }\n                }\n                return false;\n            }\n            function emitIdentifier(node) {\n                if (!node.parent) {\n                    write(node.text);\n                }\n                else if (isExpressionIdentifier(node)) {\n                    emitExpressionIdentifier(node);\n                }\n                else if (isNameOfNestedRedeclaration(node)) {\n                    write(getGeneratedNameForNode(node));\n                }\n                else if (ts.nodeIsSynthesized(node)) {\n                    write(node.text);\n                }\n                else {\n                    writeTextOfNode(currentSourceFile, node);\n                }\n            }\n            function emitThis(node) {\n                if (resolver.getNodeCheckFlags(node) & 2 /* LexicalThis */) {\n                    write(\"_this\");\n                }\n                else {\n                    write(\"this\");\n                }\n            }\n            function emitSuper(node) {\n                if (languageVersion >= 2 /* ES6 */) {\n                    write(\"super\");\n                }\n                else {\n                    var flags = resolver.getNodeCheckFlags(node);\n                    if (flags & 256 /* SuperInstance */) {\n                        write(\"_super.prototype\");\n                    }\n                    else {\n                        write(\"_super\");\n                    }\n                }\n            }\n            function emitObjectBindingPattern(node) {\n                write(\"{ \");\n                var elements = node.elements;\n                emitList(elements, 0, elements.length, /*multiLine*/ false, /*trailingComma*/ elements.hasTrailingComma);\n                write(\" }\");\n            }\n            function emitArrayBindingPattern(node) {\n                write(\"[\");\n                var elements = node.elements;\n                emitList(elements, 0, elements.length, /*multiLine*/ false, /*trailingComma*/ elements.hasTrailingComma);\n                write(\"]\");\n            }\n            function emitBindingElement(node) {\n                if (node.propertyName) {\n                    emit(node.propertyName);\n                    write(\": \");\n                }\n                if (node.dotDotDotToken) {\n                    write(\"...\");\n                }\n                if (ts.isBindingPattern(node.name)) {\n                    emit(node.name);\n                }\n                else {\n                    emitModuleMemberName(node);\n                }\n                emitOptional(\" = \", node.initializer);\n            }\n            function emitSpreadElementExpression(node) {\n                write(\"...\");\n                emit(node.expression);\n            }\n            function emitYieldExpression(node) {\n                write(ts.tokenToString(114 /* YieldKeyword */));\n                if (node.asteriskToken) {\n                    write(\"*\");\n                }\n                if (node.expression) {\n                    write(\" \");\n                    emit(node.expression);\n                }\n            }\n            function emitAwaitExpression(node) {\n                var needsParenthesis = needsParenthesisForAwaitExpressionAsYield(node);\n                if (needsParenthesis) {\n                    write(\"(\");\n                }\n                write(ts.tokenToString(114 /* YieldKeyword */));\n                write(\" \");\n                emit(node.expression);\n                if (needsParenthesis) {\n                    write(\")\");\n                }\n            }\n            function needsParenthesisForAwaitExpressionAsYield(node) {\n                if (node.parent.kind === 181 /* BinaryExpression */ && !ts.isAssignmentOperator(node.parent.operatorToken.kind)) {\n                    return true;\n                }\n                else if (node.parent.kind === 182 /* ConditionalExpression */ && node.parent.condition === node) {\n                    return true;\n                }\n                return false;\n            }\n            function needsParenthesisForPropertyAccessOrInvocation(node) {\n                switch (node.kind) {\n                    case 69 /* Identifier */:\n                    case 164 /* ArrayLiteralExpression */:\n                    case 166 /* PropertyAccessExpression */:\n                    case 167 /* ElementAccessExpression */:\n                    case 168 /* CallExpression */:\n                    case 172 /* ParenthesizedExpression */:\n                        // This list is not exhaustive and only includes those cases that are relevant\n                        // to the check in emitArrayLiteral. More cases can be added as needed.\n                        return false;\n                }\n                return true;\n            }\n            function emitListWithSpread(elements, needsUniqueCopy, multiLine, trailingComma, useConcat) {\n                var pos = 0;\n                var group = 0;\n                var length = elements.length;\n                while (pos < length) {\n                    // Emit using the pattern <group0>.concat(<group1>, <group2>, ...)\n                    if (group === 1 && useConcat) {\n                        write(\".concat(\");\n                    }\n                    else if (group > 0) {\n                        write(\", \");\n                    }\n                    var e = elements[pos];\n                    if (e.kind === 185 /* SpreadElementExpression */) {\n                        e = e.expression;\n                        emitParenthesizedIf(e, /*parenthesized*/ group === 0 && needsParenthesisForPropertyAccessOrInvocation(e));\n                        pos++;\n                        if (pos === length && group === 0 && needsUniqueCopy && e.kind !== 164 /* ArrayLiteralExpression */) {\n                            write(\".slice()\");\n                        }\n                    }\n                    else {\n                        var i = pos;\n                        while (i < length && elements[i].kind !== 185 /* SpreadElementExpression */) {\n                            i++;\n                        }\n                        write(\"[\");\n                        if (multiLine) {\n                            increaseIndent();\n                        }\n                        emitList(elements, pos, i - pos, multiLine, trailingComma && i === length);\n                        if (multiLine) {\n                            decreaseIndent();\n                        }\n                        write(\"]\");\n                        pos = i;\n                    }\n                    group++;\n                }\n                if (group > 1) {\n                    if (useConcat) {\n                        write(\")\");\n                    }\n                }\n            }\n            function isSpreadElementExpression(node) {\n                return node.kind === 185 /* SpreadElementExpression */;\n            }\n            function emitArrayLiteral(node) {\n                var elements = node.elements;\n                if (elements.length === 0) {\n                    write(\"[]\");\n                }\n                else if (languageVersion >= 2 /* ES6 */ || !ts.forEach(elements, isSpreadElementExpression)) {\n                    write(\"[\");\n                    emitLinePreservingList(node, node.elements, elements.hasTrailingComma, /*spacesBetweenBraces:*/ false);\n                    write(\"]\");\n                }\n                else {\n                    emitListWithSpread(elements, /*needsUniqueCopy*/ true, /*multiLine*/ (node.flags & 2048 /* MultiLine */) !== 0,\n                        /*trailingComma*/ elements.hasTrailingComma, /*useConcat*/ true);\n                }\n            }\n            function emitObjectLiteralBody(node, numElements) {\n                if (numElements === 0) {\n                    write(\"{}\");\n                    return;\n                }\n                write(\"{\");\n                if (numElements > 0) {\n                    var properties = node.properties;\n                    // If we are not doing a downlevel transformation for object literals,\n                    // then try to preserve the original shape of the object literal.\n                    // Otherwise just try to preserve the formatting.\n                    if (numElements === properties.length) {\n                        emitLinePreservingList(node, properties, /* allowTrailingComma */ languageVersion >= 1 /* ES5 */, /* spacesBetweenBraces */ true);\n                    }\n                    else {\n                        var multiLine = (node.flags & 2048 /* MultiLine */) !== 0;\n                        if (!multiLine) {\n                            write(\" \");\n                        }\n                        else {\n                            increaseIndent();\n                        }\n                        emitList(properties, 0, numElements, /*multiLine*/ multiLine, /*trailingComma*/ false);\n                        if (!multiLine) {\n                            write(\" \");\n                        }\n                        else {\n                            decreaseIndent();\n                        }\n                    }\n                }\n                write(\"}\");\n            }\n            function emitDownlevelObjectLiteralWithComputedProperties(node, firstComputedPropertyIndex) {\n                var multiLine = (node.flags & 2048 /* MultiLine */) !== 0;\n                var properties = node.properties;\n                write(\"(\");\n                if (multiLine) {\n                    increaseIndent();\n                }\n                // For computed properties, we need to create a unique handle to the object\n                // literal so we can modify it without risking internal assignments tainting the object.\n                var tempVar = createAndRecordTempVariable(0 /* Auto */);\n                // Write out the first non-computed properties\n                // (or all properties if none of them are computed),\n                // then emit the rest through indexing on the temp variable.\n                emit(tempVar);\n                write(\" = \");\n                emitObjectLiteralBody(node, firstComputedPropertyIndex);\n                for (var i = firstComputedPropertyIndex, n = properties.length; i < n; i++) {\n                    writeComma();\n                    var property = properties[i];\n                    emitStart(property);\n                    if (property.kind === 145 /* GetAccessor */ || property.kind === 146 /* SetAccessor */) {\n                        // TODO (drosen): Reconcile with 'emitMemberFunctions'.\n                        var accessors = ts.getAllAccessorDeclarations(node.properties, property);\n                        if (property !== accessors.firstAccessor) {\n                            continue;\n                        }\n                        write(\"Object.defineProperty(\");\n                        emit(tempVar);\n                        write(\", \");\n                        emitStart(node.name);\n                        emitExpressionForPropertyName(property.name);\n                        emitEnd(property.name);\n                        write(\", {\");\n                        increaseIndent();\n                        if (accessors.getAccessor) {\n                            writeLine();\n                            emitLeadingComments(accessors.getAccessor);\n                            write(\"get: \");\n                            emitStart(accessors.getAccessor);\n                            write(\"function \");\n                            emitSignatureAndBody(accessors.getAccessor);\n                            emitEnd(accessors.getAccessor);\n                            emitTrailingComments(accessors.getAccessor);\n                            write(\",\");\n                        }\n                        if (accessors.setAccessor) {\n                            writeLine();\n                            emitLeadingComments(accessors.setAccessor);\n                            write(\"set: \");\n                            emitStart(accessors.setAccessor);\n                            write(\"function \");\n                            emitSignatureAndBody(accessors.setAccessor);\n                            emitEnd(accessors.setAccessor);\n                            emitTrailingComments(accessors.setAccessor);\n                            write(\",\");\n                        }\n                        writeLine();\n                        write(\"enumerable: true,\");\n                        writeLine();\n                        write(\"configurable: true\");\n                        decreaseIndent();\n                        writeLine();\n                        write(\"})\");\n                        emitEnd(property);\n                    }\n                    else {\n                        emitLeadingComments(property);\n                        emitStart(property.name);\n                        emit(tempVar);\n                        emitMemberAccessForPropertyName(property.name);\n                        emitEnd(property.name);\n                        write(\" = \");\n                        if (property.kind === 245 /* PropertyAssignment */) {\n                            emit(property.initializer);\n                        }\n                        else if (property.kind === 246 /* ShorthandPropertyAssignment */) {\n                            emitExpressionIdentifier(property.name);\n                        }\n                        else if (property.kind === 143 /* MethodDeclaration */) {\n                            emitFunctionDeclaration(property);\n                        }\n                        else {\n                            ts.Debug.fail(\"ObjectLiteralElement type not accounted for: \" + property.kind);\n                        }\n                    }\n                    emitEnd(property);\n                }\n                writeComma();\n                emit(tempVar);\n                if (multiLine) {\n                    decreaseIndent();\n                    writeLine();\n                }\n                write(\")\");\n                function writeComma() {\n                    if (multiLine) {\n                        write(\",\");\n                        writeLine();\n                    }\n                    else {\n                        write(\", \");\n                    }\n                }\n            }\n            function emitObjectLiteral(node) {\n                var properties = node.properties;\n                if (languageVersion < 2 /* ES6 */) {\n                    var numProperties = properties.length;\n                    // Find the first computed property.\n                    // Everything until that point can be emitted as part of the initial object literal.\n                    var numInitialNonComputedProperties = numProperties;\n                    for (var i = 0, n = properties.length; i < n; i++) {\n                        if (properties[i].name.kind === 136 /* ComputedPropertyName */) {\n                            numInitialNonComputedProperties = i;\n                            break;\n                        }\n                    }\n                    var hasComputedProperty = numInitialNonComputedProperties !== properties.length;\n                    if (hasComputedProperty) {\n                        emitDownlevelObjectLiteralWithComputedProperties(node, numInitialNonComputedProperties);\n                        return;\n                    }\n                }\n                // Ordinary case: either the object has no computed properties\n                // or we're compiling with an ES6+ target.\n                emitObjectLiteralBody(node, properties.length);\n            }\n            function createBinaryExpression(left, operator, right, startsOnNewLine) {\n                var result = ts.createSynthesizedNode(181 /* BinaryExpression */, startsOnNewLine);\n                result.operatorToken = ts.createSynthesizedNode(operator);\n                result.left = left;\n                result.right = right;\n                return result;\n            }\n            function createPropertyAccessExpression(expression, name) {\n                var result = ts.createSynthesizedNode(166 /* PropertyAccessExpression */);\n                result.expression = parenthesizeForAccess(expression);\n                result.dotToken = ts.createSynthesizedNode(21 /* DotToken */);\n                result.name = name;\n                return result;\n            }\n            function createElementAccessExpression(expression, argumentExpression) {\n                var result = ts.createSynthesizedNode(167 /* ElementAccessExpression */);\n                result.expression = parenthesizeForAccess(expression);\n                result.argumentExpression = argumentExpression;\n                return result;\n            }\n            function parenthesizeForAccess(expr) {\n                // When diagnosing whether the expression needs parentheses, the decision should be based\n                // on the innermost expression in a chain of nested type assertions.\n                while (expr.kind === 171 /* TypeAssertionExpression */ || expr.kind === 189 /* AsExpression */) {\n                    expr = expr.expression;\n                }\n                // isLeftHandSideExpression is almost the correct criterion for when it is not necessary\n                // to parenthesize the expression before a dot. The known exceptions are:\n                //\n                //    NewExpression:\n                //       new C.x        -> not the same as (new C).x\n                //    NumberLiteral\n                //       1.x            -> not the same as (1).x\n                //\n                if (ts.isLeftHandSideExpression(expr) &&\n                    expr.kind !== 169 /* NewExpression */ &&\n                    expr.kind !== 8 /* NumericLiteral */) {\n                    return expr;\n                }\n                var node = ts.createSynthesizedNode(172 /* ParenthesizedExpression */);\n                node.expression = expr;\n                return node;\n            }\n            function emitComputedPropertyName(node) {\n                write(\"[\");\n                emitExpressionForPropertyName(node);\n                write(\"]\");\n            }\n            function emitMethod(node) {\n                if (languageVersion >= 2 /* ES6 */ && node.asteriskToken) {\n                    write(\"*\");\n                }\n                emit(node.name);\n                if (languageVersion < 2 /* ES6 */) {\n                    write(\": function \");\n                }\n                emitSignatureAndBody(node);\n            }\n            function emitPropertyAssignment(node) {\n                emit(node.name);\n                write(\": \");\n                // This is to ensure that we emit comment in the following case:\n                //      For example:\n                //          obj = {\n                //              id: /*comment1*/ ()=>void\n                //          }\n                // \"comment1\" is not considered to be leading comment for node.initializer\n                // but rather a trailing comment on the previous node.\n                emitTrailingCommentsOfPosition(node.initializer.pos);\n                emit(node.initializer);\n            }\n            // Return true if identifier resolves to an exported member of a namespace\n            function isNamespaceExportReference(node) {\n                var container = resolver.getReferencedExportContainer(node);\n                return container && container.kind !== 248 /* SourceFile */;\n            }\n            function emitShorthandPropertyAssignment(node) {\n                // The name property of a short-hand property assignment is considered an expression position, so here\n                // we manually emit the identifier to avoid rewriting.\n                writeTextOfNode(currentSourceFile, node.name);\n                // If emitting pre-ES6 code, or if the name requires rewriting when resolved as an expression identifier,\n                // we emit a normal property assignment. For example:\n                //   module m {\n                //       export let y;\n                //   }\n                //   module m {\n                //       let obj = { y };\n                //   }\n                // Here we need to emit obj = { y : m.y } regardless of the output target.\n                if (languageVersion < 2 /* ES6 */ || isNamespaceExportReference(node.name)) {\n                    // Emit identifier as an identifier\n                    write(\": \");\n                    emit(node.name);\n                }\n                if (languageVersion >= 2 /* ES6 */ && node.objectAssignmentInitializer) {\n                    write(\" = \");\n                    emit(node.objectAssignmentInitializer);\n                }\n            }\n            function tryEmitConstantValue(node) {\n                var constantValue = tryGetConstEnumValue(node);\n                if (constantValue !== undefined) {\n                    write(constantValue.toString());\n                    if (!compilerOptions.removeComments) {\n                        var propertyName = node.kind === 166 /* PropertyAccessExpression */ ? ts.declarationNameToString(node.name) : ts.getTextOfNode(node.argumentExpression);\n                        write(\" /* \" + propertyName + \" */\");\n                    }\n                    return true;\n                }\n                return false;\n            }\n            function tryGetConstEnumValue(node) {\n                if (compilerOptions.isolatedModules) {\n                    return undefined;\n                }\n                return node.kind === 166 /* PropertyAccessExpression */ || node.kind === 167 /* ElementAccessExpression */\n                    ? resolver.getConstantValue(node)\n                    : undefined;\n            }\n            // Returns 'true' if the code was actually indented, false otherwise.\n            // If the code is not indented, an optional valueToWriteWhenNotIndenting will be\n            // emitted instead.\n            function indentIfOnDifferentLines(parent, node1, node2, valueToWriteWhenNotIndenting) {\n                var realNodesAreOnDifferentLines = !ts.nodeIsSynthesized(parent) && !nodeEndIsOnSameLineAsNodeStart(node1, node2);\n                // Always use a newline for synthesized code if the synthesizer desires it.\n                var synthesizedNodeIsOnDifferentLine = synthesizedNodeStartsOnNewLine(node2);\n                if (realNodesAreOnDifferentLines || synthesizedNodeIsOnDifferentLine) {\n                    increaseIndent();\n                    writeLine();\n                    return true;\n                }\n                else {\n                    if (valueToWriteWhenNotIndenting) {\n                        write(valueToWriteWhenNotIndenting);\n                    }\n                    return false;\n                }\n            }\n            function emitPropertyAccess(node) {\n                if (tryEmitConstantValue(node)) {\n                    return;\n                }\n                emit(node.expression);\n                var indentedBeforeDot = indentIfOnDifferentLines(node, node.expression, node.dotToken);\n                // 1 .toString is a valid property access, emit a space after the literal\n                // Also emit a space if expression is a integer const enum value - it will appear in generated code as numeric literal\n                var shouldEmitSpace;\n                if (!indentedBeforeDot) {\n                    if (node.expression.kind === 8 /* NumericLiteral */) {\n                        // check if numeric literal was originally written with a dot\n                        var text = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node.expression);\n                        shouldEmitSpace = text.indexOf(ts.tokenToString(21 /* DotToken */)) < 0;\n                    }\n                    else {\n                        // check if constant enum value is integer\n                        var constantValue = tryGetConstEnumValue(node.expression);\n                        // isFinite handles cases when constantValue is undefined\n                        shouldEmitSpace = isFinite(constantValue) && Math.floor(constantValue) === constantValue;\n                    }\n                }\n                if (shouldEmitSpace) {\n                    write(\" .\");\n                }\n                else {\n                    write(\".\");\n                }\n                var indentedAfterDot = indentIfOnDifferentLines(node, node.dotToken, node.name);\n                emit(node.name);\n                decreaseIndentIf(indentedBeforeDot, indentedAfterDot);\n            }\n            function emitQualifiedName(node) {\n                emit(node.left);\n                write(\".\");\n                emit(node.right);\n            }\n            function emitQualifiedNameAsExpression(node, useFallback) {\n                if (node.left.kind === 69 /* Identifier */) {\n                    emitEntityNameAsExpression(node.left, useFallback);\n                }\n                else if (useFallback) {\n                    var temp = createAndRecordTempVariable(0 /* Auto */);\n                    write(\"(\");\n                    emitNodeWithoutSourceMap(temp);\n                    write(\" = \");\n                    emitEntityNameAsExpression(node.left, /*useFallback*/ true);\n                    write(\") && \");\n                    emitNodeWithoutSourceMap(temp);\n                }\n                else {\n                    emitEntityNameAsExpression(node.left, /*useFallback*/ false);\n                }\n                write(\".\");\n                emit(node.right);\n            }\n            function emitEntityNameAsExpression(node, useFallback) {\n                switch (node.kind) {\n                    case 69 /* Identifier */:\n                        if (useFallback) {\n                            write(\"typeof \");\n                            emitExpressionIdentifier(node);\n                            write(\" !== 'undefined' && \");\n                        }\n                        emitExpressionIdentifier(node);\n                        break;\n                    case 135 /* QualifiedName */:\n                        emitQualifiedNameAsExpression(node, useFallback);\n                        break;\n                }\n            }\n            function emitIndexedAccess(node) {\n                if (tryEmitConstantValue(node)) {\n                    return;\n                }\n                emit(node.expression);\n                write(\"[\");\n                emit(node.argumentExpression);\n                write(\"]\");\n            }\n            function hasSpreadElement(elements) {\n                return ts.forEach(elements, function (e) { return e.kind === 185 /* SpreadElementExpression */; });\n            }\n            function skipParentheses(node) {\n                while (node.kind === 172 /* ParenthesizedExpression */ || node.kind === 171 /* TypeAssertionExpression */ || node.kind === 189 /* AsExpression */) {\n                    node = node.expression;\n                }\n                return node;\n            }\n            function emitCallTarget(node) {\n                if (node.kind === 69 /* Identifier */ || node.kind === 97 /* ThisKeyword */ || node.kind === 95 /* SuperKeyword */) {\n                    emit(node);\n                    return node;\n                }\n                var temp = createAndRecordTempVariable(0 /* Auto */);\n                write(\"(\");\n                emit(temp);\n                write(\" = \");\n                emit(node);\n                write(\")\");\n                return temp;\n            }\n            function emitCallWithSpread(node) {\n                var target;\n                var expr = skipParentheses(node.expression);\n                if (expr.kind === 166 /* PropertyAccessExpression */) {\n                    // Target will be emitted as \"this\" argument\n                    target = emitCallTarget(expr.expression);\n                    write(\".\");\n                    emit(expr.name);\n                }\n                else if (expr.kind === 167 /* ElementAccessExpression */) {\n                    // Target will be emitted as \"this\" argument\n                    target = emitCallTarget(expr.expression);\n                    write(\"[\");\n                    emit(expr.argumentExpression);\n                    write(\"]\");\n                }\n                else if (expr.kind === 95 /* SuperKeyword */) {\n                    target = expr;\n                    write(\"_super\");\n                }\n                else {\n                    emit(node.expression);\n                }\n                write(\".apply(\");\n                if (target) {\n                    if (target.kind === 95 /* SuperKeyword */) {\n                        // Calls of form super(...) and super.foo(...)\n                        emitThis(target);\n                    }\n                    else {\n                        // Calls of form obj.foo(...)\n                        emit(target);\n                    }\n                }\n                else {\n                    // Calls of form foo(...)\n                    write(\"void 0\");\n                }\n                write(\", \");\n                emitListWithSpread(node.arguments, /*needsUniqueCopy*/ false, /*multiLine*/ false, /*trailingComma*/ false, /*useConcat*/ true);\n                write(\")\");\n            }\n            function emitCallExpression(node) {\n                if (languageVersion < 2 /* ES6 */ && hasSpreadElement(node.arguments)) {\n                    emitCallWithSpread(node);\n                    return;\n                }\n                var superCall = false;\n                if (node.expression.kind === 95 /* SuperKeyword */) {\n                    emitSuper(node.expression);\n                    superCall = true;\n                }\n                else {\n                    emit(node.expression);\n                    superCall = node.expression.kind === 166 /* PropertyAccessExpression */ && node.expression.expression.kind === 95 /* SuperKeyword */;\n                }\n                if (superCall && languageVersion < 2 /* ES6 */) {\n                    write(\".call(\");\n                    emitThis(node.expression);\n                    if (node.arguments.length) {\n                        write(\", \");\n                        emitCommaList(node.arguments);\n                    }\n                    write(\")\");\n                }\n                else {\n                    write(\"(\");\n                    emitCommaList(node.arguments);\n                    write(\")\");\n                }\n            }\n            function emitNewExpression(node) {\n                write(\"new \");\n                // Spread operator logic is supported in new expressions in ES5 using a combination\n                // of Function.prototype.bind() and Function.prototype.apply().\n                //\n                //     Example:\n                //\n                //         var args = [1, 2, 3, 4, 5];\n                //         new Array(...args);\n                //\n                //     is compiled into the following ES5:\n                //\n                //         var args = [1, 2, 3, 4, 5];\n                //         new (Array.bind.apply(Array, [void 0].concat(args)));\n                //\n                // The 'thisArg' to 'bind' is ignored when invoking the result of 'bind' with 'new',\n                // Thus, we set it to undefined ('void 0').\n                if (languageVersion === 1 /* ES5 */ &&\n                    node.arguments &&\n                    hasSpreadElement(node.arguments)) {\n                    write(\"(\");\n                    var target = emitCallTarget(node.expression);\n                    write(\".bind.apply(\");\n                    emit(target);\n                    write(\", [void 0].concat(\");\n                    emitListWithSpread(node.arguments, /*needsUniqueCopy*/ false, /*multiline*/ false, /*trailingComma*/ false, /*useConcat*/ false);\n                    write(\")))\");\n                    write(\"()\");\n                }\n                else {\n                    emit(node.expression);\n                    if (node.arguments) {\n                        write(\"(\");\n                        emitCommaList(node.arguments);\n                        write(\")\");\n                    }\n                }\n            }\n            function emitTaggedTemplateExpression(node) {\n                if (languageVersion >= 2 /* ES6 */) {\n                    emit(node.tag);\n                    write(\" \");\n                    emit(node.template);\n                }\n                else {\n                    emitDownlevelTaggedTemplate(node);\n                }\n            }\n            function emitParenExpression(node) {\n                // If the node is synthesized, it means the emitter put the parentheses there,\n                // not the user. If we didn't want them, the emitter would not have put them\n                // there.\n                if (!ts.nodeIsSynthesized(node) && node.parent.kind !== 174 /* ArrowFunction */) {\n                    if (node.expression.kind === 171 /* TypeAssertionExpression */ || node.expression.kind === 189 /* AsExpression */) {\n                        var operand = node.expression.expression;\n                        // Make sure we consider all nested cast expressions, e.g.:\n                        // (<any><number><any>-A).x;\n                        while (operand.kind === 171 /* TypeAssertionExpression */ || operand.kind === 189 /* AsExpression */) {\n                            operand = operand.expression;\n                        }\n                        // We have an expression of the form: (<Type>SubExpr)\n                        // Emitting this as (SubExpr) is really not desirable. We would like to emit the subexpr as is.\n                        // Omitting the parentheses, however, could cause change in the semantics of the generated\n                        // code if the casted expression has a lower precedence than the rest of the expression, e.g.:\n                        //      (<any>new A).foo should be emitted as (new A).foo and not new A.foo\n                        //      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()\n                        //      new (<any>A()) should be emitted as new (A()) and not new A()\n                        //      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()\n                        if (operand.kind !== 179 /* PrefixUnaryExpression */ &&\n                            operand.kind !== 177 /* VoidExpression */ &&\n                            operand.kind !== 176 /* TypeOfExpression */ &&\n                            operand.kind !== 175 /* DeleteExpression */ &&\n                            operand.kind !== 180 /* PostfixUnaryExpression */ &&\n                            operand.kind !== 169 /* NewExpression */ &&\n                            !(operand.kind === 168 /* CallExpression */ && node.parent.kind === 169 /* NewExpression */) &&\n                            !(operand.kind === 173 /* FunctionExpression */ && node.parent.kind === 168 /* CallExpression */) &&\n                            !(operand.kind === 8 /* NumericLiteral */ && node.parent.kind === 166 /* PropertyAccessExpression */)) {\n                            emit(operand);\n                            return;\n                        }\n                    }\n                }\n                write(\"(\");\n                emit(node.expression);\n                write(\")\");\n            }\n            function emitDeleteExpression(node) {\n                write(ts.tokenToString(78 /* DeleteKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function emitVoidExpression(node) {\n                write(ts.tokenToString(103 /* VoidKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function emitTypeOfExpression(node) {\n                write(ts.tokenToString(101 /* TypeOfKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node) {\n                if (!isCurrentFileSystemExternalModule() || node.kind !== 69 /* Identifier */ || ts.nodeIsSynthesized(node)) {\n                    return false;\n                }\n                var isVariableDeclarationOrBindingElement = node.parent && (node.parent.kind === 211 /* VariableDeclaration */ || node.parent.kind === 163 /* BindingElement */);\n                var targetDeclaration = isVariableDeclarationOrBindingElement\n                    ? node.parent\n                    : resolver.getReferencedValueDeclaration(node);\n                return isSourceFileLevelDeclarationInSystemJsModule(targetDeclaration, /*isExported*/ true);\n            }\n            function emitPrefixUnaryExpression(node) {\n                var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node.operand);\n                if (exportChanged) {\n                    // emit\n                    // ++x\n                    // as\n                    // exports('x', ++x)\n                    write(exportFunctionForFile + \"(\\\"\");\n                    emitNodeWithoutSourceMap(node.operand);\n                    write(\"\\\", \");\n                }\n                write(ts.tokenToString(node.operator));\n                // In some cases, we need to emit a space between the operator and the operand. One obvious case\n                // is when the operator is an identifier, like delete or typeof. We also need to do this for plus\n                // and minus expressions in certain cases. Specifically, consider the following two cases (parens\n                // are just for clarity of exposition, and not part of the source code):\n                //\n                //  (+(+1))\n                //  (+(++1))\n                //\n                // We need to emit a space in both cases. In the first case, the absence of a space will make\n                // the resulting expression a prefix increment operation. And in the second, it will make the resulting\n                // expression a prefix increment whose operand is a plus expression - (++(+x))\n                // The same is true of minus of course.\n                if (node.operand.kind === 179 /* PrefixUnaryExpression */) {\n                    var operand = node.operand;\n                    if (node.operator === 35 /* PlusToken */ && (operand.operator === 35 /* PlusToken */ || operand.operator === 41 /* PlusPlusToken */)) {\n                        write(\" \");\n                    }\n                    else if (node.operator === 36 /* MinusToken */ && (operand.operator === 36 /* MinusToken */ || operand.operator === 42 /* MinusMinusToken */)) {\n                        write(\" \");\n                    }\n                }\n                emit(node.operand);\n                if (exportChanged) {\n                    write(\")\");\n                }\n            }\n            function emitPostfixUnaryExpression(node) {\n                var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node.operand);\n                if (exportChanged) {\n                    // export function returns the value that was passes as the second argument\n                    // however for postfix unary expressions result value should be the value before modification.\n                    // emit 'x++' as '(export('x', ++x) - 1)' and 'x--' as '(export('x', --x) + 1)'\n                    write(\"(\" + exportFunctionForFile + \"(\\\"\");\n                    emitNodeWithoutSourceMap(node.operand);\n                    write(\"\\\", \");\n                    write(ts.tokenToString(node.operator));\n                    emit(node.operand);\n                    if (node.operator === 41 /* PlusPlusToken */) {\n                        write(\") - 1)\");\n                    }\n                    else {\n                        write(\") + 1)\");\n                    }\n                }\n                else {\n                    emit(node.operand);\n                    write(ts.tokenToString(node.operator));\n                }\n            }\n            function shouldHoistDeclarationInSystemJsModule(node) {\n                return isSourceFileLevelDeclarationInSystemJsModule(node, /*isExported*/ false);\n            }\n            /*\n             * Checks if given node is a source file level declaration (not nested in module/function).\n             * If 'isExported' is true - then declaration must also be exported.\n             * This function is used in two cases:\n             * - check if node is a exported source file level value to determine\n             *   if we should also export the value after its it changed\n             * - check if node is a source level declaration to emit it differently,\n             *   i.e non-exported variable statement 'var x = 1' is hoisted so\n             *   we we emit variable statement 'var' should be dropped.\n             */\n            function isSourceFileLevelDeclarationInSystemJsModule(node, isExported) {\n                if (!node || languageVersion >= 2 /* ES6 */ || !isCurrentFileSystemExternalModule()) {\n                    return false;\n                }\n                var current = node;\n                while (current) {\n                    if (current.kind === 248 /* SourceFile */) {\n                        return !isExported || ((ts.getCombinedNodeFlags(node) & 1 /* Export */) !== 0);\n                    }\n                    else if (ts.isFunctionLike(current) || current.kind === 219 /* ModuleBlock */) {\n                        return false;\n                    }\n                    else {\n                        current = current.parent;\n                    }\n                }\n            }\n            /**\n             * Emit ES7 exponentiation operator downlevel using Math.pow\n             * @param node a binary expression node containing exponentiationOperator (**, **=)\n             */\n            function emitExponentiationOperator(node) {\n                var leftHandSideExpression = node.left;\n                if (node.operatorToken.kind === 60 /* AsteriskAsteriskEqualsToken */) {\n                    var synthesizedLHS;\n                    var shouldEmitParentheses = false;\n                    if (ts.isElementAccessExpression(leftHandSideExpression)) {\n                        shouldEmitParentheses = true;\n                        write(\"(\");\n                        synthesizedLHS = ts.createSynthesizedNode(167 /* ElementAccessExpression */, /*startsOnNewLine*/ false);\n                        var identifier = emitTempVariableAssignment(leftHandSideExpression.expression, /*canDefinedTempVariablesInPlaces*/ false, /*shouldEmitCommaBeforeAssignment*/ false);\n                        synthesizedLHS.expression = identifier;\n                        if (leftHandSideExpression.argumentExpression.kind !== 8 /* NumericLiteral */ &&\n                            leftHandSideExpression.argumentExpression.kind !== 9 /* StringLiteral */) {\n                            var tempArgumentExpression = createAndRecordTempVariable(268435456 /* _i */);\n                            synthesizedLHS.argumentExpression = tempArgumentExpression;\n                            emitAssignment(tempArgumentExpression, leftHandSideExpression.argumentExpression, /*shouldEmitCommaBeforeAssignment*/ true);\n                        }\n                        else {\n                            synthesizedLHS.argumentExpression = leftHandSideExpression.argumentExpression;\n                        }\n                        write(\", \");\n                    }\n                    else if (ts.isPropertyAccessExpression(leftHandSideExpression)) {\n                        shouldEmitParentheses = true;\n                        write(\"(\");\n                        synthesizedLHS = ts.createSynthesizedNode(166 /* PropertyAccessExpression */, /*startsOnNewLine*/ false);\n                        var identifier = emitTempVariableAssignment(leftHandSideExpression.expression, /*canDefinedTempVariablesInPlaces*/ false, /*shouldemitCommaBeforeAssignment*/ false);\n                        synthesizedLHS.expression = identifier;\n                        synthesizedLHS.dotToken = leftHandSideExpression.dotToken;\n                        synthesizedLHS.name = leftHandSideExpression.name;\n                        write(\", \");\n                    }\n                    emit(synthesizedLHS || leftHandSideExpression);\n                    write(\" = \");\n                    write(\"Math.pow(\");\n                    emit(synthesizedLHS || leftHandSideExpression);\n                    write(\", \");\n                    emit(node.right);\n                    write(\")\");\n                    if (shouldEmitParentheses) {\n                        write(\")\");\n                    }\n                }\n                else {\n                    write(\"Math.pow(\");\n                    emit(leftHandSideExpression);\n                    write(\", \");\n                    emit(node.right);\n                    write(\")\");\n                }\n            }\n            function emitBinaryExpression(node) {\n                if (languageVersion < 2 /* ES6 */ && node.operatorToken.kind === 56 /* EqualsToken */ &&\n                    (node.left.kind === 165 /* ObjectLiteralExpression */ || node.left.kind === 164 /* ArrayLiteralExpression */)) {\n                    emitDestructuring(node, node.parent.kind === 195 /* ExpressionStatement */);\n                }\n                else {\n                    var exportChanged = node.operatorToken.kind >= 56 /* FirstAssignment */ &&\n                        node.operatorToken.kind <= 68 /* LastAssignment */ &&\n                        isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node.left);\n                    if (exportChanged) {\n                        // emit assignment 'x <op> y' as 'exports(\"x\", x <op> y)'\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitNodeWithoutSourceMap(node.left);\n                        write(\"\\\", \");\n                    }\n                    if (node.operatorToken.kind === 38 /* AsteriskAsteriskToken */ || node.operatorToken.kind === 60 /* AsteriskAsteriskEqualsToken */) {\n                        // Downleveled emit exponentiation operator using Math.pow\n                        emitExponentiationOperator(node);\n                    }\n                    else {\n                        emit(node.left);\n                        // Add indentation before emit the operator if the operator is on different line\n                        // For example:\n                        //      3\n                        //      + 2;\n                        //   emitted as\n                        //      3\n                        //          + 2;\n                        var indentedBeforeOperator = indentIfOnDifferentLines(node, node.left, node.operatorToken, node.operatorToken.kind !== 24 /* CommaToken */ ? \" \" : undefined);\n                        write(ts.tokenToString(node.operatorToken.kind));\n                        var indentedAfterOperator = indentIfOnDifferentLines(node, node.operatorToken, node.right, \" \");\n                        emit(node.right);\n                        decreaseIndentIf(indentedBeforeOperator, indentedAfterOperator);\n                    }\n                    if (exportChanged) {\n                        write(\")\");\n                    }\n                }\n            }\n            function synthesizedNodeStartsOnNewLine(node) {\n                return ts.nodeIsSynthesized(node) && node.startsOnNewLine;\n            }\n            function emitConditionalExpression(node) {\n                emit(node.condition);\n                var indentedBeforeQuestion = indentIfOnDifferentLines(node, node.condition, node.questionToken, \" \");\n                write(\"?\");\n                var indentedAfterQuestion = indentIfOnDifferentLines(node, node.questionToken, node.whenTrue, \" \");\n                emit(node.whenTrue);\n                decreaseIndentIf(indentedBeforeQuestion, indentedAfterQuestion);\n                var indentedBeforeColon = indentIfOnDifferentLines(node, node.whenTrue, node.colonToken, \" \");\n                write(\":\");\n                var indentedAfterColon = indentIfOnDifferentLines(node, node.colonToken, node.whenFalse, \" \");\n                emit(node.whenFalse);\n                decreaseIndentIf(indentedBeforeColon, indentedAfterColon);\n            }\n            // Helper function to decrease the indent if we previously indented.  Allows multiple\n            // previous indent values to be considered at a time.  This also allows caller to just\n            // call this once, passing in all their appropriate indent values, instead of needing\n            // to call this helper function multiple times.\n            function decreaseIndentIf(value1, value2) {\n                if (value1) {\n                    decreaseIndent();\n                }\n                if (value2) {\n                    decreaseIndent();\n                }\n            }\n            function isSingleLineEmptyBlock(node) {\n                if (node && node.kind === 192 /* Block */) {\n                    var block = node;\n                    return block.statements.length === 0 && nodeEndIsOnSameLineAsNodeStart(block, block);\n                }\n            }\n            function emitBlock(node) {\n                if (isSingleLineEmptyBlock(node)) {\n                    emitToken(15 /* OpenBraceToken */, node.pos);\n                    write(\" \");\n                    emitToken(16 /* CloseBraceToken */, node.statements.end);\n                    return;\n                }\n                emitToken(15 /* OpenBraceToken */, node.pos);\n                increaseIndent();\n                scopeEmitStart(node.parent);\n                if (node.kind === 219 /* ModuleBlock */) {\n                    ts.Debug.assert(node.parent.kind === 218 /* ModuleDeclaration */);\n                    emitCaptureThisForNodeIfNecessary(node.parent);\n                }\n                emitLines(node.statements);\n                if (node.kind === 219 /* ModuleBlock */) {\n                    emitTempDeclarations(/*newLine*/ true);\n                }\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.statements.end);\n                scopeEmitEnd();\n            }\n            function emitEmbeddedStatement(node) {\n                if (node.kind === 192 /* Block */) {\n                    write(\" \");\n                    emit(node);\n                }\n                else {\n                    increaseIndent();\n                    writeLine();\n                    emit(node);\n                    decreaseIndent();\n                }\n            }\n            function emitExpressionStatement(node) {\n                emitParenthesizedIf(node.expression, /*parenthesized*/ node.expression.kind === 174 /* ArrowFunction */);\n                write(\";\");\n            }\n            function emitIfStatement(node) {\n                var endPos = emitToken(88 /* IfKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(17 /* OpenParenToken */, endPos);\n                emit(node.expression);\n                emitToken(18 /* CloseParenToken */, node.expression.end);\n                emitEmbeddedStatement(node.thenStatement);\n                if (node.elseStatement) {\n                    writeLine();\n                    emitToken(80 /* ElseKeyword */, node.thenStatement.end);\n                    if (node.elseStatement.kind === 196 /* IfStatement */) {\n                        write(\" \");\n                        emit(node.elseStatement);\n                    }\n                    else {\n                        emitEmbeddedStatement(node.elseStatement);\n                    }\n                }\n            }\n            function emitDoStatement(node) {\n                write(\"do\");\n                emitEmbeddedStatement(node.statement);\n                if (node.statement.kind === 192 /* Block */) {\n                    write(\" \");\n                }\n                else {\n                    writeLine();\n                }\n                write(\"while (\");\n                emit(node.expression);\n                write(\");\");\n            }\n            function emitWhileStatement(node) {\n                write(\"while (\");\n                emit(node.expression);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            /**\n             * Returns true if start of variable declaration list was emitted.\n             * Returns false if nothing was written - this can happen for source file level variable declarations\n             *     in system modules where such variable declarations are hoisted.\n             */\n            function tryEmitStartOfVariableDeclarationList(decl, startPos) {\n                if (shouldHoistVariable(decl, /*checkIfSourceFileLevelDecl*/ true)) {\n                    // variables in variable declaration list were already hoisted\n                    return false;\n                }\n                var tokenKind = 102 /* VarKeyword */;\n                if (decl && languageVersion >= 2 /* ES6 */) {\n                    if (ts.isLet(decl)) {\n                        tokenKind = 108 /* LetKeyword */;\n                    }\n                    else if (ts.isConst(decl)) {\n                        tokenKind = 74 /* ConstKeyword */;\n                    }\n                }\n                if (startPos !== undefined) {\n                    emitToken(tokenKind, startPos);\n                    write(\" \");\n                }\n                else {\n                    switch (tokenKind) {\n                        case 102 /* VarKeyword */:\n                            write(\"var \");\n                            break;\n                        case 108 /* LetKeyword */:\n                            write(\"let \");\n                            break;\n                        case 74 /* ConstKeyword */:\n                            write(\"const \");\n                            break;\n                    }\n                }\n                return true;\n            }\n            function emitVariableDeclarationListSkippingUninitializedEntries(list) {\n                var started = false;\n                for (var _a = 0, _b = list.declarations; _a < _b.length; _a++) {\n                    var decl = _b[_a];\n                    if (!decl.initializer) {\n                        continue;\n                    }\n                    if (!started) {\n                        started = true;\n                    }\n                    else {\n                        write(\", \");\n                    }\n                    emit(decl);\n                }\n                return started;\n            }\n            function emitForStatement(node) {\n                var endPos = emitToken(86 /* ForKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(17 /* OpenParenToken */, endPos);\n                if (node.initializer && node.initializer.kind === 212 /* VariableDeclarationList */) {\n                    var variableDeclarationList = node.initializer;\n                    var startIsEmitted = tryEmitStartOfVariableDeclarationList(variableDeclarationList, endPos);\n                    if (startIsEmitted) {\n                        emitCommaList(variableDeclarationList.declarations);\n                    }\n                    else {\n                        emitVariableDeclarationListSkippingUninitializedEntries(variableDeclarationList);\n                    }\n                }\n                else if (node.initializer) {\n                    emit(node.initializer);\n                }\n                write(\";\");\n                emitOptional(\" \", node.condition);\n                write(\";\");\n                emitOptional(\" \", node.incrementor);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitForInOrForOfStatement(node) {\n                if (languageVersion < 2 /* ES6 */ && node.kind === 201 /* ForOfStatement */) {\n                    return emitDownLevelForOfStatement(node);\n                }\n                var endPos = emitToken(86 /* ForKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(17 /* OpenParenToken */, endPos);\n                if (node.initializer.kind === 212 /* VariableDeclarationList */) {\n                    var variableDeclarationList = node.initializer;\n                    if (variableDeclarationList.declarations.length >= 1) {\n                        tryEmitStartOfVariableDeclarationList(variableDeclarationList, endPos);\n                        emit(variableDeclarationList.declarations[0]);\n                    }\n                }\n                else {\n                    emit(node.initializer);\n                }\n                if (node.kind === 200 /* ForInStatement */) {\n                    write(\" in \");\n                }\n                else {\n                    write(\" of \");\n                }\n                emit(node.expression);\n                emitToken(18 /* CloseParenToken */, node.expression.end);\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitDownLevelForOfStatement(node) {\n                // The following ES6 code:\n                //\n                //    for (let v of expr) { }\n                //\n                // should be emitted as\n                //\n                //    for (let _i = 0, _a = expr; _i < _a.length; _i++) {\n                //        let v = _a[_i];\n                //    }\n                //\n                // where _a and _i are temps emitted to capture the RHS and the counter,\n                // respectively.\n                // When the left hand side is an expression instead of a let declaration,\n                // the \"let v\" is not emitted.\n                // When the left hand side is a let/const, the v is renamed if there is\n                // another v in scope.\n                // Note that all assignments to the LHS are emitted in the body, including\n                // all destructuring.\n                // Note also that because an extra statement is needed to assign to the LHS,\n                // for-of bodies are always emitted as blocks.\n                var endPos = emitToken(86 /* ForKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(17 /* OpenParenToken */, endPos);\n                // Do not emit the LHS let declaration yet, because it might contain destructuring.\n                // Do not call recordTempDeclaration because we are declaring the temps\n                // right here. Recording means they will be declared later.\n                // In the case where the user wrote an identifier as the RHS, like this:\n                //\n                //     for (let v of arr) { }\n                //\n                // we don't want to emit a temporary variable for the RHS, just use it directly.\n                var rhsIsIdentifier = node.expression.kind === 69 /* Identifier */;\n                var counter = createTempVariable(268435456 /* _i */);\n                var rhsReference = rhsIsIdentifier ? node.expression : createTempVariable(0 /* Auto */);\n                // This is the let keyword for the counter and rhsReference. The let keyword for\n                // the LHS will be emitted inside the body.\n                emitStart(node.expression);\n                write(\"var \");\n                // _i = 0\n                emitNodeWithoutSourceMap(counter);\n                write(\" = 0\");\n                emitEnd(node.expression);\n                if (!rhsIsIdentifier) {\n                    // , _a = expr\n                    write(\", \");\n                    emitStart(node.expression);\n                    emitNodeWithoutSourceMap(rhsReference);\n                    write(\" = \");\n                    emitNodeWithoutSourceMap(node.expression);\n                    emitEnd(node.expression);\n                }\n                write(\"; \");\n                // _i < _a.length;\n                emitStart(node.initializer);\n                emitNodeWithoutSourceMap(counter);\n                write(\" < \");\n                emitNodeWithCommentsAndWithoutSourcemap(rhsReference);\n                write(\".length\");\n                emitEnd(node.initializer);\n                write(\"; \");\n                // _i++)\n                emitStart(node.initializer);\n                emitNodeWithoutSourceMap(counter);\n                write(\"++\");\n                emitEnd(node.initializer);\n                emitToken(18 /* CloseParenToken */, node.expression.end);\n                // Body\n                write(\" {\");\n                writeLine();\n                increaseIndent();\n                // Initialize LHS\n                // let v = _a[_i];\n                var rhsIterationValue = createElementAccessExpression(rhsReference, counter);\n                emitStart(node.initializer);\n                if (node.initializer.kind === 212 /* VariableDeclarationList */) {\n                    write(\"var \");\n                    var variableDeclarationList = node.initializer;\n                    if (variableDeclarationList.declarations.length > 0) {\n                        var declaration = variableDeclarationList.declarations[0];\n                        if (ts.isBindingPattern(declaration.name)) {\n                            // This works whether the declaration is a var, let, or const.\n                            // It will use rhsIterationValue _a[_i] as the initializer.\n                            emitDestructuring(declaration, /*isAssignmentExpressionStatement*/ false, rhsIterationValue);\n                        }\n                        else {\n                            // The following call does not include the initializer, so we have\n                            // to emit it separately.\n                            emitNodeWithCommentsAndWithoutSourcemap(declaration);\n                            write(\" = \");\n                            emitNodeWithoutSourceMap(rhsIterationValue);\n                        }\n                    }\n                    else {\n                        // It's an empty declaration list. This can only happen in an error case, if the user wrote\n                        //     for (let of []) {}\n                        emitNodeWithoutSourceMap(createTempVariable(0 /* Auto */));\n                        write(\" = \");\n                        emitNodeWithoutSourceMap(rhsIterationValue);\n                    }\n                }\n                else {\n                    // Initializer is an expression. Emit the expression in the body, so that it's\n                    // evaluated on every iteration.\n                    var assignmentExpression = createBinaryExpression(node.initializer, 56 /* EqualsToken */, rhsIterationValue, /*startsOnNewLine*/ false);\n                    if (node.initializer.kind === 164 /* ArrayLiteralExpression */ || node.initializer.kind === 165 /* ObjectLiteralExpression */) {\n                        // This is a destructuring pattern, so call emitDestructuring instead of emit. Calling emit will not work, because it will cause\n                        // the BinaryExpression to be passed in instead of the expression statement, which will cause emitDestructuring to crash.\n                        emitDestructuring(assignmentExpression, /*isAssignmentExpressionStatement*/ true, /*value*/ undefined);\n                    }\n                    else {\n                        emitNodeWithCommentsAndWithoutSourcemap(assignmentExpression);\n                    }\n                }\n                emitEnd(node.initializer);\n                write(\";\");\n                if (node.statement.kind === 192 /* Block */) {\n                    emitLines(node.statement.statements);\n                }\n                else {\n                    writeLine();\n                    emit(node.statement);\n                }\n                writeLine();\n                decreaseIndent();\n                write(\"}\");\n            }\n            function emitBreakOrContinueStatement(node) {\n                emitToken(node.kind === 203 /* BreakStatement */ ? 70 /* BreakKeyword */ : 75 /* ContinueKeyword */, node.pos);\n                emitOptional(\" \", node.label);\n                write(\";\");\n            }\n            function emitReturnStatement(node) {\n                emitToken(94 /* ReturnKeyword */, node.pos);\n                emitOptional(\" \", node.expression);\n                write(\";\");\n            }\n            function emitWithStatement(node) {\n                write(\"with (\");\n                emit(node.expression);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitSwitchStatement(node) {\n                var endPos = emitToken(96 /* SwitchKeyword */, node.pos);\n                write(\" \");\n                emitToken(17 /* OpenParenToken */, endPos);\n                emit(node.expression);\n                endPos = emitToken(18 /* CloseParenToken */, node.expression.end);\n                write(\" \");\n                emitCaseBlock(node.caseBlock, endPos);\n            }\n            function emitCaseBlock(node, startPos) {\n                emitToken(15 /* OpenBraceToken */, startPos);\n                increaseIndent();\n                emitLines(node.clauses);\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.clauses.end);\n            }\n            function nodeStartPositionsAreOnSameLine(node1, node2) {\n                return ts.getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node1.pos)) ===\n                    ts.getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node2.pos));\n            }\n            function nodeEndPositionsAreOnSameLine(node1, node2) {\n                return ts.getLineOfLocalPosition(currentSourceFile, node1.end) ===\n                    ts.getLineOfLocalPosition(currentSourceFile, node2.end);\n            }\n            function nodeEndIsOnSameLineAsNodeStart(node1, node2) {\n                return ts.getLineOfLocalPosition(currentSourceFile, node1.end) ===\n                    ts.getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node2.pos));\n            }\n            function emitCaseOrDefaultClause(node) {\n                if (node.kind === 241 /* CaseClause */) {\n                    write(\"case \");\n                    emit(node.expression);\n                    write(\":\");\n                }\n                else {\n                    write(\"default:\");\n                }\n                if (node.statements.length === 1 && nodeStartPositionsAreOnSameLine(node, node.statements[0])) {\n                    write(\" \");\n                    emit(node.statements[0]);\n                }\n                else {\n                    increaseIndent();\n                    emitLines(node.statements);\n                    decreaseIndent();\n                }\n            }\n            function emitThrowStatement(node) {\n                write(\"throw \");\n                emit(node.expression);\n                write(\";\");\n            }\n            function emitTryStatement(node) {\n                write(\"try \");\n                emit(node.tryBlock);\n                emit(node.catchClause);\n                if (node.finallyBlock) {\n                    writeLine();\n                    write(\"finally \");\n                    emit(node.finallyBlock);\n                }\n            }\n            function emitCatchClause(node) {\n                writeLine();\n                var endPos = emitToken(72 /* CatchKeyword */, node.pos);\n                write(\" \");\n                emitToken(17 /* OpenParenToken */, endPos);\n                emit(node.variableDeclaration);\n                emitToken(18 /* CloseParenToken */, node.variableDeclaration ? node.variableDeclaration.end : endPos);\n                write(\" \");\n                emitBlock(node.block);\n            }\n            function emitDebuggerStatement(node) {\n                emitToken(76 /* DebuggerKeyword */, node.pos);\n                write(\";\");\n            }\n            function emitLabelledStatement(node) {\n                emit(node.label);\n                write(\": \");\n                emit(node.statement);\n            }\n            function getContainingModule(node) {\n                do {\n                    node = node.parent;\n                } while (node && node.kind !== 218 /* ModuleDeclaration */);\n                return node;\n            }\n            function emitContainingModuleName(node) {\n                var container = getContainingModule(node);\n                write(container ? getGeneratedNameForNode(container) : \"exports\");\n            }\n            function emitModuleMemberName(node) {\n                emitStart(node.name);\n                if (ts.getCombinedNodeFlags(node) & 1 /* Export */) {\n                    var container = getContainingModule(node);\n                    if (container) {\n                        write(getGeneratedNameForNode(container));\n                        write(\".\");\n                    }\n                    else if (modulekind !== 5 /* ES6 */ && modulekind !== 4 /* System */) {\n                        write(\"exports.\");\n                    }\n                }\n                emitNodeWithCommentsAndWithoutSourcemap(node.name);\n                emitEnd(node.name);\n            }\n            function createVoidZero() {\n                var zero = ts.createSynthesizedNode(8 /* NumericLiteral */);\n                zero.text = \"0\";\n                var result = ts.createSynthesizedNode(177 /* VoidExpression */);\n                result.expression = zero;\n                return result;\n            }\n            function emitEs6ExportDefaultCompat(node) {\n                if (node.parent.kind === 248 /* SourceFile */) {\n                    ts.Debug.assert(!!(node.flags & 1024 /* Default */) || node.kind === 227 /* ExportAssignment */);\n                    // only allow export default at a source file level\n                    if (modulekind === 1 /* CommonJS */ || modulekind === 2 /* AMD */ || modulekind === 3 /* UMD */) {\n                        if (!currentSourceFile.symbol.exports[\"___esModule\"]) {\n                            if (languageVersion === 1 /* ES5 */) {\n                                // default value of configurable, enumerable, writable are `false`.\n                                write(\"Object.defineProperty(exports, \\\"__esModule\\\", { value: true });\");\n                                writeLine();\n                            }\n                            else if (languageVersion === 0 /* ES3 */) {\n                                write(\"exports.__esModule = true;\");\n                                writeLine();\n                            }\n                        }\n                    }\n                }\n            }\n            function emitExportMemberAssignment(node) {\n                if (node.flags & 1 /* Export */) {\n                    writeLine();\n                    emitStart(node);\n                    // emit call to exporter only for top level nodes\n                    if (modulekind === 4 /* System */ && node.parent === currentSourceFile) {\n                        // emit export default <smth> as\n                        // export(\"default\", <smth>)\n                        write(exportFunctionForFile + \"(\\\"\");\n                        if (node.flags & 1024 /* Default */) {\n                            write(\"default\");\n                        }\n                        else {\n                            emitNodeWithCommentsAndWithoutSourcemap(node.name);\n                        }\n                        write(\"\\\", \");\n                        emitDeclarationName(node);\n                        write(\")\");\n                    }\n                    else {\n                        if (node.flags & 1024 /* Default */) {\n                            emitEs6ExportDefaultCompat(node);\n                            if (languageVersion === 0 /* ES3 */) {\n                                write(\"exports[\\\"default\\\"]\");\n                            }\n                            else {\n                                write(\"exports.default\");\n                            }\n                        }\n                        else {\n                            emitModuleMemberName(node);\n                        }\n                        write(\" = \");\n                        emitDeclarationName(node);\n                    }\n                    emitEnd(node);\n                    write(\";\");\n                }\n            }\n            function emitExportMemberAssignments(name) {\n                if (modulekind === 4 /* System */) {\n                    return;\n                }\n                if (!exportEquals && exportSpecifiers && ts.hasProperty(exportSpecifiers, name.text)) {\n                    for (var _a = 0, _b = exportSpecifiers[name.text]; _a < _b.length; _a++) {\n                        var specifier = _b[_a];\n                        writeLine();\n                        emitStart(specifier.name);\n                        emitContainingModuleName(specifier);\n                        write(\".\");\n                        emitNodeWithCommentsAndWithoutSourcemap(specifier.name);\n                        emitEnd(specifier.name);\n                        write(\" = \");\n                        emitExpressionIdentifier(name);\n                        write(\";\");\n                    }\n                }\n            }\n            function emitExportSpecifierInSystemModule(specifier) {\n                ts.Debug.assert(modulekind === 4 /* System */);\n                if (!resolver.getReferencedValueDeclaration(specifier.propertyName || specifier.name) && !resolver.isValueAliasDeclaration(specifier)) {\n                    return;\n                }\n                writeLine();\n                emitStart(specifier.name);\n                write(exportFunctionForFile + \"(\\\"\");\n                emitNodeWithCommentsAndWithoutSourcemap(specifier.name);\n                write(\"\\\", \");\n                emitExpressionIdentifier(specifier.propertyName || specifier.name);\n                write(\")\");\n                emitEnd(specifier.name);\n                write(\";\");\n            }\n            /**\n             * Emit an assignment to a given identifier, 'name', with a given expression, 'value'.\n             * @param name an identifier as a left-hand-side operand of the assignment\n             * @param value an expression as a right-hand-side operand of the assignment\n             * @param shouldEmitCommaBeforeAssignment a boolean indicating whether to prefix an assignment with comma\n             */\n            function emitAssignment(name, value, shouldEmitCommaBeforeAssignment) {\n                if (shouldEmitCommaBeforeAssignment) {\n                    write(\", \");\n                }\n                var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(name);\n                if (exportChanged) {\n                    write(exportFunctionForFile + \"(\\\"\");\n                    emitNodeWithCommentsAndWithoutSourcemap(name);\n                    write(\"\\\", \");\n                }\n                var isVariableDeclarationOrBindingElement = name.parent && (name.parent.kind === 211 /* VariableDeclaration */ || name.parent.kind === 163 /* BindingElement */);\n                if (isVariableDeclarationOrBindingElement) {\n                    emitModuleMemberName(name.parent);\n                }\n                else {\n                    emit(name);\n                }\n                write(\" = \");\n                emit(value);\n                if (exportChanged) {\n                    write(\")\");\n                }\n            }\n            /**\n             * Create temporary variable, emit an assignment of the variable the given expression\n             * @param expression an expression to assign to the newly created temporary variable\n             * @param canDefineTempVariablesInPlace a boolean indicating whether you can define the temporary variable at an assignment location\n             * @param shouldEmitCommaBeforeAssignment a boolean indicating whether an assignment should prefix with comma\n             */\n            function emitTempVariableAssignment(expression, canDefineTempVariablesInPlace, shouldEmitCommaBeforeAssignment) {\n                var identifier = createTempVariable(0 /* Auto */);\n                if (!canDefineTempVariablesInPlace) {\n                    recordTempDeclaration(identifier);\n                }\n                emitAssignment(identifier, expression, shouldEmitCommaBeforeAssignment);\n                return identifier;\n            }\n            function emitDestructuring(root, isAssignmentExpressionStatement, value) {\n                var emitCount = 0;\n                // An exported declaration is actually emitted as an assignment (to a property on the module object), so\n                // temporary variables in an exported declaration need to have real declarations elsewhere\n                // Also temporary variables should be explicitly allocated for source level declarations when module target is system\n                // because actual variable declarations are hoisted\n                var canDefineTempVariablesInPlace = false;\n                if (root.kind === 211 /* VariableDeclaration */) {\n                    var isExported = ts.getCombinedNodeFlags(root) & 1 /* Export */;\n                    var isSourceLevelForSystemModuleKind = shouldHoistDeclarationInSystemJsModule(root);\n                    canDefineTempVariablesInPlace = !isExported && !isSourceLevelForSystemModuleKind;\n                }\n                else if (root.kind === 138 /* Parameter */) {\n                    canDefineTempVariablesInPlace = true;\n                }\n                if (root.kind === 181 /* BinaryExpression */) {\n                    emitAssignmentExpression(root);\n                }\n                else {\n                    ts.Debug.assert(!isAssignmentExpressionStatement);\n                    emitBindingElement(root, value);\n                }\n                /**\n                 * Ensures that there exists a declared identifier whose value holds the given expression.\n                 * This function is useful to ensure that the expression's value can be read from in subsequent expressions.\n                 * Unless 'reuseIdentifierExpressions' is false, 'expr' will be returned if it is just an identifier.\n                 *\n                 * @param expr the expression whose value needs to be bound.\n                 * @param reuseIdentifierExpressions true if identifier expressions can simply be returned;\n                 *                                   false if it is necessary to always emit an identifier.\n                 */\n                function ensureIdentifier(expr, reuseIdentifierExpressions) {\n                    if (expr.kind === 69 /* Identifier */ && reuseIdentifierExpressions) {\n                        return expr;\n                    }\n                    var identifier = emitTempVariableAssignment(expr, canDefineTempVariablesInPlace, emitCount > 0);\n                    emitCount++;\n                    return identifier;\n                }\n                function createDefaultValueCheck(value, defaultValue) {\n                    // The value expression will be evaluated twice, so for anything but a simple identifier\n                    // we need to generate a temporary variable\n                    value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ true);\n                    // Return the expression 'value === void 0 ? defaultValue : value'\n                    var equals = ts.createSynthesizedNode(181 /* BinaryExpression */);\n                    equals.left = value;\n                    equals.operatorToken = ts.createSynthesizedNode(32 /* EqualsEqualsEqualsToken */);\n                    equals.right = createVoidZero();\n                    return createConditionalExpression(equals, defaultValue, value);\n                }\n                function createConditionalExpression(condition, whenTrue, whenFalse) {\n                    var cond = ts.createSynthesizedNode(182 /* ConditionalExpression */);\n                    cond.condition = condition;\n                    cond.questionToken = ts.createSynthesizedNode(53 /* QuestionToken */);\n                    cond.whenTrue = whenTrue;\n                    cond.colonToken = ts.createSynthesizedNode(54 /* ColonToken */);\n                    cond.whenFalse = whenFalse;\n                    return cond;\n                }\n                function createNumericLiteral(value) {\n                    var node = ts.createSynthesizedNode(8 /* NumericLiteral */);\n                    node.text = \"\" + value;\n                    return node;\n                }\n                function createPropertyAccessForDestructuringProperty(object, propName) {\n                    // We create a synthetic copy of the identifier in order to avoid the rewriting that might\n                    // otherwise occur when the identifier is emitted.\n                    var syntheticName = ts.createSynthesizedNode(propName.kind);\n                    syntheticName.text = propName.text;\n                    if (syntheticName.kind !== 69 /* Identifier */) {\n                        return createElementAccessExpression(object, syntheticName);\n                    }\n                    return createPropertyAccessExpression(object, syntheticName);\n                }\n                function createSliceCall(value, sliceIndex) {\n                    var call = ts.createSynthesizedNode(168 /* CallExpression */);\n                    var sliceIdentifier = ts.createSynthesizedNode(69 /* Identifier */);\n                    sliceIdentifier.text = \"slice\";\n                    call.expression = createPropertyAccessExpression(value, sliceIdentifier);\n                    call.arguments = ts.createSynthesizedNodeArray();\n                    call.arguments[0] = createNumericLiteral(sliceIndex);\n                    return call;\n                }\n                function emitObjectLiteralAssignment(target, value) {\n                    var properties = target.properties;\n                    if (properties.length !== 1) {\n                        // For anything but a single element destructuring we need to generate a temporary\n                        // to ensure value is evaluated exactly once.\n                        value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ true);\n                    }\n                    for (var _a = 0; _a < properties.length; _a++) {\n                        var p = properties[_a];\n                        if (p.kind === 245 /* PropertyAssignment */ || p.kind === 246 /* ShorthandPropertyAssignment */) {\n                            var propName = p.name;\n                            var target_1 = p.kind === 246 /* ShorthandPropertyAssignment */ ? p : p.initializer || propName;\n                            emitDestructuringAssignment(target_1, createPropertyAccessForDestructuringProperty(value, propName));\n                        }\n                    }\n                }\n                function emitArrayLiteralAssignment(target, value) {\n                    var elements = target.elements;\n                    if (elements.length !== 1) {\n                        // For anything but a single element destructuring we need to generate a temporary\n                        // to ensure value is evaluated exactly once.\n                        value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ true);\n                    }\n                    for (var i = 0; i < elements.length; i++) {\n                        var e = elements[i];\n                        if (e.kind !== 187 /* OmittedExpression */) {\n                            if (e.kind !== 185 /* SpreadElementExpression */) {\n                                emitDestructuringAssignment(e, createElementAccessExpression(value, createNumericLiteral(i)));\n                            }\n                            else if (i === elements.length - 1) {\n                                emitDestructuringAssignment(e.expression, createSliceCall(value, i));\n                            }\n                        }\n                    }\n                }\n                function emitDestructuringAssignment(target, value) {\n                    if (target.kind === 246 /* ShorthandPropertyAssignment */) {\n                        if (target.objectAssignmentInitializer) {\n                            value = createDefaultValueCheck(value, target.objectAssignmentInitializer);\n                        }\n                        target = target.name;\n                    }\n                    else if (target.kind === 181 /* BinaryExpression */ && target.operatorToken.kind === 56 /* EqualsToken */) {\n                        value = createDefaultValueCheck(value, target.right);\n                        target = target.left;\n                    }\n                    if (target.kind === 165 /* ObjectLiteralExpression */) {\n                        emitObjectLiteralAssignment(target, value);\n                    }\n                    else if (target.kind === 164 /* ArrayLiteralExpression */) {\n                        emitArrayLiteralAssignment(target, value);\n                    }\n                    else {\n                        emitAssignment(target, value, /*shouldEmitCommaBeforeAssignment*/ emitCount > 0);\n                        emitCount++;\n                    }\n                }\n                function emitAssignmentExpression(root) {\n                    var target = root.left;\n                    var value = root.right;\n                    if (ts.isEmptyObjectLiteralOrArrayLiteral(target)) {\n                        emit(value);\n                    }\n                    else if (isAssignmentExpressionStatement) {\n                        emitDestructuringAssignment(target, value);\n                    }\n                    else {\n                        if (root.parent.kind !== 172 /* ParenthesizedExpression */) {\n                            write(\"(\");\n                        }\n                        value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ true);\n                        emitDestructuringAssignment(target, value);\n                        write(\", \");\n                        emit(value);\n                        if (root.parent.kind !== 172 /* ParenthesizedExpression */) {\n                            write(\")\");\n                        }\n                    }\n                }\n                function emitBindingElement(target, value) {\n                    if (target.initializer) {\n                        // Combine value and initializer\n                        value = value ? createDefaultValueCheck(value, target.initializer) : target.initializer;\n                    }\n                    else if (!value) {\n                        // Use 'void 0' in absence of value and initializer\n                        value = createVoidZero();\n                    }\n                    if (ts.isBindingPattern(target.name)) {\n                        var pattern = target.name;\n                        var elements = pattern.elements;\n                        var numElements = elements.length;\n                        if (numElements !== 1) {\n                            // For anything other than a single-element destructuring we need to generate a temporary\n                            // to ensure value is evaluated exactly once. Additionally, if we have zero elements\n                            // we need to emit *something* to ensure that in case a 'var' keyword was already emitted,\n                            // so in that case, we'll intentionally create that temporary.\n                            value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ numElements !== 0);\n                        }\n                        for (var i = 0; i < numElements; i++) {\n                            var element = elements[i];\n                            if (pattern.kind === 161 /* ObjectBindingPattern */) {\n                                // Rewrite element to a declaration with an initializer that fetches property\n                                var propName = element.propertyName || element.name;\n                                emitBindingElement(element, createPropertyAccessForDestructuringProperty(value, propName));\n                            }\n                            else if (element.kind !== 187 /* OmittedExpression */) {\n                                if (!element.dotDotDotToken) {\n                                    // Rewrite element to a declaration that accesses array element at index i\n                                    emitBindingElement(element, createElementAccessExpression(value, createNumericLiteral(i)));\n                                }\n                                else if (i === numElements - 1) {\n                                    emitBindingElement(element, createSliceCall(value, i));\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        emitAssignment(target.name, value, /*shouldEmitCommaBeforeAssignment*/ emitCount > 0);\n                        emitCount++;\n                    }\n                }\n            }\n            function emitVariableDeclaration(node) {\n                if (ts.isBindingPattern(node.name)) {\n                    if (languageVersion < 2 /* ES6 */) {\n                        emitDestructuring(node, /*isAssignmentExpressionStatement*/ false);\n                    }\n                    else {\n                        emit(node.name);\n                        emitOptional(\" = \", node.initializer);\n                    }\n                }\n                else {\n                    var initializer = node.initializer;\n                    if (!initializer && languageVersion < 2 /* ES6 */) {\n                        // downlevel emit for non-initialized let bindings defined in loops\n                        // for (...) {  let x; }\n                        // should be\n                        // for (...) { var <some-uniqie-name> = void 0; }\n                        // this is necessary to preserve ES6 semantic in scenarios like\n                        // for (...) { let x; console.log(x); x = 1 } // assignment on one iteration should not affect other iterations\n                        var isUninitializedLet = (resolver.getNodeCheckFlags(node) & 16384 /* BlockScopedBindingInLoop */) &&\n                            (getCombinedFlagsForIdentifier(node.name) & 16384 /* Let */);\n                        // NOTE: default initialization should not be added to let bindings in for-in\\for-of statements\n                        if (isUninitializedLet &&\n                            node.parent.parent.kind !== 200 /* ForInStatement */ &&\n                            node.parent.parent.kind !== 201 /* ForOfStatement */) {\n                            initializer = createVoidZero();\n                        }\n                    }\n                    var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node.name);\n                    if (exportChanged) {\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitNodeWithCommentsAndWithoutSourcemap(node.name);\n                        write(\"\\\", \");\n                    }\n                    emitModuleMemberName(node);\n                    emitOptional(\" = \", initializer);\n                    if (exportChanged) {\n                        write(\")\");\n                    }\n                }\n            }\n            function emitExportVariableAssignments(node) {\n                if (node.kind === 187 /* OmittedExpression */) {\n                    return;\n                }\n                var name = node.name;\n                if (name.kind === 69 /* Identifier */) {\n                    emitExportMemberAssignments(name);\n                }\n                else if (ts.isBindingPattern(name)) {\n                    ts.forEach(name.elements, emitExportVariableAssignments);\n                }\n            }\n            function getCombinedFlagsForIdentifier(node) {\n                if (!node.parent || (node.parent.kind !== 211 /* VariableDeclaration */ && node.parent.kind !== 163 /* BindingElement */)) {\n                    return 0;\n                }\n                return ts.getCombinedNodeFlags(node.parent);\n            }\n            function isES6ExportedDeclaration(node) {\n                return !!(node.flags & 1 /* Export */) &&\n                    modulekind === 5 /* ES6 */ &&\n                    node.parent.kind === 248 /* SourceFile */;\n            }\n            function emitVariableStatement(node) {\n                var startIsEmitted = false;\n                if (node.flags & 1 /* Export */) {\n                    if (isES6ExportedDeclaration(node)) {\n                        // Exported ES6 module member\n                        write(\"export \");\n                        startIsEmitted = tryEmitStartOfVariableDeclarationList(node.declarationList);\n                    }\n                }\n                else {\n                    startIsEmitted = tryEmitStartOfVariableDeclarationList(node.declarationList);\n                }\n                if (startIsEmitted) {\n                    emitCommaList(node.declarationList.declarations);\n                    write(\";\");\n                }\n                else {\n                    var atLeastOneItem = emitVariableDeclarationListSkippingUninitializedEntries(node.declarationList);\n                    if (atLeastOneItem) {\n                        write(\";\");\n                    }\n                }\n                if (modulekind !== 5 /* ES6 */ && node.parent === currentSourceFile) {\n                    ts.forEach(node.declarationList.declarations, emitExportVariableAssignments);\n                }\n            }\n            function shouldEmitLeadingAndTrailingCommentsForVariableStatement(node) {\n                // If we're not exporting the variables, there's nothing special here.\n                // Always emit comments for these nodes.\n                if (!(node.flags & 1 /* Export */)) {\n                    return true;\n                }\n                // If we are exporting, but it's a top-level ES6 module exports,\n                // we'll emit the declaration list verbatim, so emit comments too.\n                if (isES6ExportedDeclaration(node)) {\n                    return true;\n                }\n                // Otherwise, only emit if we have at least one initializer present.\n                for (var _a = 0, _b = node.declarationList.declarations; _a < _b.length; _a++) {\n                    var declaration = _b[_a];\n                    if (declaration.initializer) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function emitParameter(node) {\n                if (languageVersion < 2 /* ES6 */) {\n                    if (ts.isBindingPattern(node.name)) {\n                        var name_24 = createTempVariable(0 /* Auto */);\n                        if (!tempParameters) {\n                            tempParameters = [];\n                        }\n                        tempParameters.push(name_24);\n                        emit(name_24);\n                    }\n                    else {\n                        emit(node.name);\n                    }\n                }\n                else {\n                    if (node.dotDotDotToken) {\n                        write(\"...\");\n                    }\n                    emit(node.name);\n                    emitOptional(\" = \", node.initializer);\n                }\n            }\n            function emitDefaultValueAssignments(node) {\n                if (languageVersion < 2 /* ES6 */) {\n                    var tempIndex = 0;\n                    ts.forEach(node.parameters, function (parameter) {\n                        // A rest parameter cannot have a binding pattern or an initializer,\n                        // so let's just ignore it.\n                        if (parameter.dotDotDotToken) {\n                            return;\n                        }\n                        var paramName = parameter.name, initializer = parameter.initializer;\n                        if (ts.isBindingPattern(paramName)) {\n                            // In cases where a binding pattern is simply '[]' or '{}',\n                            // we usually don't want to emit a var declaration; however, in the presence\n                            // of an initializer, we must emit that expression to preserve side effects.\n                            var hasBindingElements = paramName.elements.length > 0;\n                            if (hasBindingElements || initializer) {\n                                writeLine();\n                                write(\"var \");\n                                if (hasBindingElements) {\n                                    emitDestructuring(parameter, /*isAssignmentExpressionStatement*/ false, tempParameters[tempIndex]);\n                                }\n                                else {\n                                    emit(tempParameters[tempIndex]);\n                                    write(\" = \");\n                                    emit(initializer);\n                                }\n                                write(\";\");\n                                tempIndex++;\n                            }\n                        }\n                        else if (initializer) {\n                            writeLine();\n                            emitStart(parameter);\n                            write(\"if (\");\n                            emitNodeWithoutSourceMap(paramName);\n                            write(\" === void 0)\");\n                            emitEnd(parameter);\n                            write(\" { \");\n                            emitStart(parameter);\n                            emitNodeWithCommentsAndWithoutSourcemap(paramName);\n                            write(\" = \");\n                            emitNodeWithCommentsAndWithoutSourcemap(initializer);\n                            emitEnd(parameter);\n                            write(\"; }\");\n                        }\n                    });\n                }\n            }\n            function emitRestParameter(node) {\n                if (languageVersion < 2 /* ES6 */ && ts.hasRestParameter(node)) {\n                    var restIndex = node.parameters.length - 1;\n                    var restParam = node.parameters[restIndex];\n                    // A rest parameter cannot have a binding pattern, so let's just ignore it if it does.\n                    if (ts.isBindingPattern(restParam.name)) {\n                        return;\n                    }\n                    var tempName = createTempVariable(268435456 /* _i */).text;\n                    writeLine();\n                    emitLeadingComments(restParam);\n                    emitStart(restParam);\n                    write(\"var \");\n                    emitNodeWithCommentsAndWithoutSourcemap(restParam.name);\n                    write(\" = [];\");\n                    emitEnd(restParam);\n                    emitTrailingComments(restParam);\n                    writeLine();\n                    write(\"for (\");\n                    emitStart(restParam);\n                    write(\"var \" + tempName + \" = \" + restIndex + \";\");\n                    emitEnd(restParam);\n                    write(\" \");\n                    emitStart(restParam);\n                    write(tempName + \" < arguments.length;\");\n                    emitEnd(restParam);\n                    write(\" \");\n                    emitStart(restParam);\n                    write(tempName + \"++\");\n                    emitEnd(restParam);\n                    write(\") {\");\n                    increaseIndent();\n                    writeLine();\n                    emitStart(restParam);\n                    emitNodeWithCommentsAndWithoutSourcemap(restParam.name);\n                    write(\"[\" + tempName + \" - \" + restIndex + \"] = arguments[\" + tempName + \"];\");\n                    emitEnd(restParam);\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                }\n            }\n            function emitAccessor(node) {\n                write(node.kind === 145 /* GetAccessor */ ? \"get \" : \"set \");\n                emit(node.name);\n                emitSignatureAndBody(node);\n            }\n            function shouldEmitAsArrowFunction(node) {\n                return node.kind === 174 /* ArrowFunction */ && languageVersion >= 2 /* ES6 */;\n            }\n            function emitDeclarationName(node) {\n                if (node.name) {\n                    emitNodeWithCommentsAndWithoutSourcemap(node.name);\n                }\n                else {\n                    write(getGeneratedNameForNode(node));\n                }\n            }\n            function shouldEmitFunctionName(node) {\n                if (node.kind === 173 /* FunctionExpression */) {\n                    // Emit name if one is present\n                    return !!node.name;\n                }\n                if (node.kind === 213 /* FunctionDeclaration */) {\n                    // Emit name if one is present, or emit generated name in down-level case (for export default case)\n                    return !!node.name || languageVersion < 2 /* ES6 */;\n                }\n            }\n            function emitFunctionDeclaration(node) {\n                if (ts.nodeIsMissing(node.body)) {\n                    return emitCommentsOnNotEmittedNode(node);\n                }\n                // TODO (yuisu) : we should not have special cases to condition emitting comments\n                // but have one place to fix check for these conditions.\n                if (node.kind !== 143 /* MethodDeclaration */ && node.kind !== 142 /* MethodSignature */ &&\n                    node.parent && node.parent.kind !== 245 /* PropertyAssignment */ &&\n                    node.parent.kind !== 168 /* CallExpression */) {\n                    // 1. Methods will emit the comments as part of emitting method declaration\n                    // 2. If the function is a property of object literal, emitting leading-comments\n                    // is done by emitNodeWithoutSourceMap which then call this function.\n                    // In particular, we would like to avoid emit comments twice in following case:\n                    //      For example:\n                    //          var obj = {\n                    //              id:\n                    //                  /*comment*/ () => void\n                    //          }\n                    // 3. If the function is an argument in call expression, emitting of comments will be\n                    // taken care of in emit list of arguments inside of emitCallexpression\n                    emitLeadingComments(node);\n                }\n                emitStart(node);\n                // For targeting below es6, emit functions-like declaration including arrow function using function keyword.\n                // When targeting ES6, emit arrow function natively in ES6 by omitting function keyword and using fat arrow instead\n                if (!shouldEmitAsArrowFunction(node)) {\n                    if (isES6ExportedDeclaration(node)) {\n                        write(\"export \");\n                        if (node.flags & 1024 /* Default */) {\n                            write(\"default \");\n                        }\n                    }\n                    write(\"function\");\n                    if (languageVersion >= 2 /* ES6 */ && node.asteriskToken) {\n                        write(\"*\");\n                    }\n                    write(\" \");\n                }\n                if (shouldEmitFunctionName(node)) {\n                    emitDeclarationName(node);\n                }\n                emitSignatureAndBody(node);\n                if (modulekind !== 5 /* ES6 */ && node.kind === 213 /* FunctionDeclaration */ && node.parent === currentSourceFile && node.name) {\n                    emitExportMemberAssignments(node.name);\n                }\n                emitEnd(node);\n                if (node.kind !== 143 /* MethodDeclaration */ && node.kind !== 142 /* MethodSignature */) {\n                    emitTrailingComments(node);\n                }\n            }\n            function emitCaptureThisForNodeIfNecessary(node) {\n                if (resolver.getNodeCheckFlags(node) & 4 /* CaptureThis */) {\n                    writeLine();\n                    emitStart(node);\n                    write(\"var _this = this;\");\n                    emitEnd(node);\n                }\n            }\n            function emitSignatureParameters(node) {\n                increaseIndent();\n                write(\"(\");\n                if (node) {\n                    var parameters = node.parameters;\n                    var omitCount = languageVersion < 2 /* ES6 */ && ts.hasRestParameter(node) ? 1 : 0;\n                    emitList(parameters, 0, parameters.length - omitCount, /*multiLine*/ false, /*trailingComma*/ false);\n                }\n                write(\")\");\n                decreaseIndent();\n            }\n            function emitSignatureParametersForArrow(node) {\n                // Check whether the parameter list needs parentheses and preserve no-parenthesis\n                if (node.parameters.length === 1 && node.pos === node.parameters[0].pos) {\n                    emit(node.parameters[0]);\n                    return;\n                }\n                emitSignatureParameters(node);\n            }\n            function emitAsyncFunctionBodyForES6(node) {\n                var promiseConstructor = ts.getEntityNameFromTypeNode(node.type);\n                var isArrowFunction = node.kind === 174 /* ArrowFunction */;\n                var hasLexicalArguments = (resolver.getNodeCheckFlags(node) & 4096 /* CaptureArguments */) !== 0;\n                var args;\n                // An async function is emit as an outer function that calls an inner\n                // generator function. To preserve lexical bindings, we pass the current\n                // `this` and `arguments` objects to `__awaiter`. The generator function\n                // passed to `__awaiter` is executed inside of the callback to the\n                // promise constructor.\n                //\n                // The emit for an async arrow without a lexical `arguments` binding might be:\n                //\n                //  // input\n                //  let a = async (b) => { await b; }\n                //\n                //  // output\n                //  let a = (b) => __awaiter(this, void 0, void 0, function* () {\n                //      yield b;\n                //  });\n                //\n                // The emit for an async arrow with a lexical `arguments` binding might be:\n                //\n                //  // input\n                //  let a = async (b) => { await arguments[0]; }\n                //\n                //  // output\n                //  let a = (b) => __awaiter(this, arguments, void 0, function* (arguments) {\n                //      yield arguments[0];\n                //  });\n                //\n                // The emit for an async function expression without a lexical `arguments` binding\n                // might be:\n                //\n                //  // input\n                //  let a = async function (b) {\n                //      await b;\n                //  }\n                //\n                //  // output\n                //  let a = function (b) {\n                //      return __awaiter(this, void 0, void 0, function* () {\n                //          yield b;\n                //      });\n                //  }\n                //\n                // The emit for an async function expression with a lexical `arguments` binding\n                // might be:\n                //\n                //  // input\n                //  let a = async function (b) {\n                //      await arguments[0];\n                //  }\n                //\n                //  // output\n                //  let a = function (b) {\n                //      return __awaiter(this, arguments, void 0, function* (_arguments) {\n                //          yield _arguments[0];\n                //      });\n                //  }\n                //\n                // The emit for an async function expression with a lexical `arguments` binding\n                // and a return type annotation might be:\n                //\n                //  // input\n                //  let a = async function (b): MyPromise<any> {\n                //      await arguments[0];\n                //  }\n                //\n                //  // output\n                //  let a = function (b) {\n                //      return __awaiter(this, arguments, MyPromise, function* (_arguments) {\n                //          yield _arguments[0];\n                //      });\n                //  }\n                //\n                // If this is not an async arrow, emit the opening brace of the function body\n                // and the start of the return statement.\n                if (!isArrowFunction) {\n                    write(\" {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"return\");\n                }\n                write(\" __awaiter(this\");\n                if (hasLexicalArguments) {\n                    write(\", arguments\");\n                }\n                else {\n                    write(\", void 0\");\n                }\n                if (promiseConstructor) {\n                    write(\", \");\n                    emitNodeWithoutSourceMap(promiseConstructor);\n                }\n                else {\n                    write(\", Promise\");\n                }\n                // Emit the call to __awaiter.\n                if (hasLexicalArguments) {\n                    write(\", function* (_arguments)\");\n                }\n                else {\n                    write(\", function* ()\");\n                }\n                // Emit the signature and body for the inner generator function.\n                emitFunctionBody(node);\n                write(\")\");\n                // If this is not an async arrow, emit the closing brace of the outer function body.\n                if (!isArrowFunction) {\n                    write(\";\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                }\n            }\n            function emitFunctionBody(node) {\n                if (!node.body) {\n                    // There can be no body when there are parse errors.  Just emit an empty block\n                    // in that case.\n                    write(\" { }\");\n                }\n                else {\n                    if (node.body.kind === 192 /* Block */) {\n                        emitBlockFunctionBody(node, node.body);\n                    }\n                    else {\n                        emitExpressionFunctionBody(node, node.body);\n                    }\n                }\n            }\n            function emitSignatureAndBody(node) {\n                var saveTempFlags = tempFlags;\n                var saveTempVariables = tempVariables;\n                var saveTempParameters = tempParameters;\n                tempFlags = 0;\n                tempVariables = undefined;\n                tempParameters = undefined;\n                // When targeting ES6, emit arrow function natively in ES6\n                if (shouldEmitAsArrowFunction(node)) {\n                    emitSignatureParametersForArrow(node);\n                    write(\" =>\");\n                }\n                else {\n                    emitSignatureParameters(node);\n                }\n                var isAsync = ts.isAsyncFunctionLike(node);\n                if (isAsync && languageVersion === 2 /* ES6 */) {\n                    emitAsyncFunctionBodyForES6(node);\n                }\n                else {\n                    emitFunctionBody(node);\n                }\n                if (!isES6ExportedDeclaration(node)) {\n                    emitExportMemberAssignment(node);\n                }\n                tempFlags = saveTempFlags;\n                tempVariables = saveTempVariables;\n                tempParameters = saveTempParameters;\n            }\n            // Returns true if any preamble code was emitted.\n            function emitFunctionBodyPreamble(node) {\n                emitCaptureThisForNodeIfNecessary(node);\n                emitDefaultValueAssignments(node);\n                emitRestParameter(node);\n            }\n            function emitExpressionFunctionBody(node, body) {\n                if (languageVersion < 2 /* ES6 */ || node.flags & 512 /* Async */) {\n                    emitDownLevelExpressionFunctionBody(node, body);\n                    return;\n                }\n                // For es6 and higher we can emit the expression as is.  However, in the case\n                // where the expression might end up looking like a block when emitted, we'll\n                // also wrap it in parentheses first.  For example if you have: a => <foo>{}\n                // then we need to generate: a => ({})\n                write(\" \");\n                // Unwrap all type assertions.\n                var current = body;\n                while (current.kind === 171 /* TypeAssertionExpression */) {\n                    current = current.expression;\n                }\n                emitParenthesizedIf(body, current.kind === 165 /* ObjectLiteralExpression */);\n            }\n            function emitDownLevelExpressionFunctionBody(node, body) {\n                write(\" {\");\n                scopeEmitStart(node);\n                increaseIndent();\n                var outPos = writer.getTextPos();\n                emitDetachedComments(node.body);\n                emitFunctionBodyPreamble(node);\n                var preambleEmitted = writer.getTextPos() !== outPos;\n                decreaseIndent();\n                // If we didn't have to emit any preamble code, then attempt to keep the arrow\n                // function on one line.\n                if (!preambleEmitted && nodeStartPositionsAreOnSameLine(node, body)) {\n                    write(\" \");\n                    emitStart(body);\n                    write(\"return \");\n                    emit(body);\n                    emitEnd(body);\n                    write(\";\");\n                    emitTempDeclarations(/*newLine*/ false);\n                    write(\" \");\n                }\n                else {\n                    increaseIndent();\n                    writeLine();\n                    emitLeadingComments(node.body);\n                    write(\"return \");\n                    emit(body);\n                    write(\";\");\n                    emitTrailingComments(node.body);\n                    emitTempDeclarations(/*newLine*/ true);\n                    decreaseIndent();\n                    writeLine();\n                }\n                emitStart(node.body);\n                write(\"}\");\n                emitEnd(node.body);\n                scopeEmitEnd();\n            }\n            function emitBlockFunctionBody(node, body) {\n                write(\" {\");\n                scopeEmitStart(node);\n                var initialTextPos = writer.getTextPos();\n                increaseIndent();\n                emitDetachedComments(body.statements);\n                // Emit all the directive prologues (like \"use strict\").  These have to come before\n                // any other preamble code we write (like parameter initializers).\n                var startIndex = emitDirectivePrologues(body.statements, /*startWithNewLine*/ true);\n                emitFunctionBodyPreamble(node);\n                decreaseIndent();\n                var preambleEmitted = writer.getTextPos() !== initialTextPos;\n                if (!preambleEmitted && nodeEndIsOnSameLineAsNodeStart(body, body)) {\n                    for (var _a = 0, _b = body.statements; _a < _b.length; _a++) {\n                        var statement = _b[_a];\n                        write(\" \");\n                        emit(statement);\n                    }\n                    emitTempDeclarations(/*newLine*/ false);\n                    write(\" \");\n                    emitLeadingCommentsOfPosition(body.statements.end);\n                }\n                else {\n                    increaseIndent();\n                    emitLinesStartingAt(body.statements, startIndex);\n                    emitTempDeclarations(/*newLine*/ true);\n                    writeLine();\n                    emitLeadingCommentsOfPosition(body.statements.end);\n                    decreaseIndent();\n                }\n                emitToken(16 /* CloseBraceToken */, body.statements.end);\n                scopeEmitEnd();\n            }\n            function findInitialSuperCall(ctor) {\n                if (ctor.body) {\n                    var statement = ctor.body.statements[0];\n                    if (statement && statement.kind === 195 /* ExpressionStatement */) {\n                        var expr = statement.expression;\n                        if (expr && expr.kind === 168 /* CallExpression */) {\n                            var func = expr.expression;\n                            if (func && func.kind === 95 /* SuperKeyword */) {\n                                return statement;\n                            }\n                        }\n                    }\n                }\n            }\n            function emitParameterPropertyAssignments(node) {\n                ts.forEach(node.parameters, function (param) {\n                    if (param.flags & 112 /* AccessibilityModifier */) {\n                        writeLine();\n                        emitStart(param);\n                        emitStart(param.name);\n                        write(\"this.\");\n                        emitNodeWithoutSourceMap(param.name);\n                        emitEnd(param.name);\n                        write(\" = \");\n                        emit(param.name);\n                        write(\";\");\n                        emitEnd(param);\n                    }\n                });\n            }\n            function emitMemberAccessForPropertyName(memberName) {\n                // This does not emit source map because it is emitted by caller as caller\n                // is aware how the property name changes to the property access\n                // eg. public x = 10; becomes this.x and static x = 10 becomes className.x\n                if (memberName.kind === 9 /* StringLiteral */ || memberName.kind === 8 /* NumericLiteral */) {\n                    write(\"[\");\n                    emitNodeWithCommentsAndWithoutSourcemap(memberName);\n                    write(\"]\");\n                }\n                else if (memberName.kind === 136 /* ComputedPropertyName */) {\n                    emitComputedPropertyName(memberName);\n                }\n                else {\n                    write(\".\");\n                    emitNodeWithCommentsAndWithoutSourcemap(memberName);\n                }\n            }\n            function getInitializedProperties(node, isStatic) {\n                var properties = [];\n                for (var _a = 0, _b = node.members; _a < _b.length; _a++) {\n                    var member = _b[_a];\n                    if (member.kind === 141 /* PropertyDeclaration */ && isStatic === ((member.flags & 128 /* Static */) !== 0) && member.initializer) {\n                        properties.push(member);\n                    }\n                }\n                return properties;\n            }\n            function emitPropertyDeclarations(node, properties) {\n                for (var _a = 0; _a < properties.length; _a++) {\n                    var property = properties[_a];\n                    emitPropertyDeclaration(node, property);\n                }\n            }\n            function emitPropertyDeclaration(node, property, receiver, isExpression) {\n                writeLine();\n                emitLeadingComments(property);\n                emitStart(property);\n                emitStart(property.name);\n                if (receiver) {\n                    emit(receiver);\n                }\n                else {\n                    if (property.flags & 128 /* Static */) {\n                        emitDeclarationName(node);\n                    }\n                    else {\n                        write(\"this\");\n                    }\n                }\n                emitMemberAccessForPropertyName(property.name);\n                emitEnd(property.name);\n                write(\" = \");\n                emit(property.initializer);\n                if (!isExpression) {\n                    write(\";\");\n                }\n                emitEnd(property);\n                emitTrailingComments(property);\n            }\n            function emitMemberFunctionsForES5AndLower(node) {\n                ts.forEach(node.members, function (member) {\n                    if (member.kind === 191 /* SemicolonClassElement */) {\n                        writeLine();\n                        write(\";\");\n                    }\n                    else if (member.kind === 143 /* MethodDeclaration */ || node.kind === 142 /* MethodSignature */) {\n                        if (!member.body) {\n                            return emitCommentsOnNotEmittedNode(member);\n                        }\n                        writeLine();\n                        emitLeadingComments(member);\n                        emitStart(member);\n                        emitStart(member.name);\n                        emitClassMemberPrefix(node, member);\n                        emitMemberAccessForPropertyName(member.name);\n                        emitEnd(member.name);\n                        write(\" = \");\n                        emitFunctionDeclaration(member);\n                        emitEnd(member);\n                        write(\";\");\n                        emitTrailingComments(member);\n                    }\n                    else if (member.kind === 145 /* GetAccessor */ || member.kind === 146 /* SetAccessor */) {\n                        var accessors = ts.getAllAccessorDeclarations(node.members, member);\n                        if (member === accessors.firstAccessor) {\n                            writeLine();\n                            emitStart(member);\n                            write(\"Object.defineProperty(\");\n                            emitStart(member.name);\n                            emitClassMemberPrefix(node, member);\n                            write(\", \");\n                            emitExpressionForPropertyName(member.name);\n                            emitEnd(member.name);\n                            write(\", {\");\n                            increaseIndent();\n                            if (accessors.getAccessor) {\n                                writeLine();\n                                emitLeadingComments(accessors.getAccessor);\n                                write(\"get: \");\n                                emitStart(accessors.getAccessor);\n                                write(\"function \");\n                                emitSignatureAndBody(accessors.getAccessor);\n                                emitEnd(accessors.getAccessor);\n                                emitTrailingComments(accessors.getAccessor);\n                                write(\",\");\n                            }\n                            if (accessors.setAccessor) {\n                                writeLine();\n                                emitLeadingComments(accessors.setAccessor);\n                                write(\"set: \");\n                                emitStart(accessors.setAccessor);\n                                write(\"function \");\n                                emitSignatureAndBody(accessors.setAccessor);\n                                emitEnd(accessors.setAccessor);\n                                emitTrailingComments(accessors.setAccessor);\n                                write(\",\");\n                            }\n                            writeLine();\n                            write(\"enumerable: true,\");\n                            writeLine();\n                            write(\"configurable: true\");\n                            decreaseIndent();\n                            writeLine();\n                            write(\"});\");\n                            emitEnd(member);\n                        }\n                    }\n                });\n            }\n            function emitMemberFunctionsForES6AndHigher(node) {\n                for (var _a = 0, _b = node.members; _a < _b.length; _a++) {\n                    var member = _b[_a];\n                    if ((member.kind === 143 /* MethodDeclaration */ || node.kind === 142 /* MethodSignature */) && !member.body) {\n                        emitCommentsOnNotEmittedNode(member);\n                    }\n                    else if (member.kind === 143 /* MethodDeclaration */ ||\n                        member.kind === 145 /* GetAccessor */ ||\n                        member.kind === 146 /* SetAccessor */) {\n                        writeLine();\n                        emitLeadingComments(member);\n                        emitStart(member);\n                        if (member.flags & 128 /* Static */) {\n                            write(\"static \");\n                        }\n                        if (member.kind === 145 /* GetAccessor */) {\n                            write(\"get \");\n                        }\n                        else if (member.kind === 146 /* SetAccessor */) {\n                            write(\"set \");\n                        }\n                        if (member.asteriskToken) {\n                            write(\"*\");\n                        }\n                        emit(member.name);\n                        emitSignatureAndBody(member);\n                        emitEnd(member);\n                        emitTrailingComments(member);\n                    }\n                    else if (member.kind === 191 /* SemicolonClassElement */) {\n                        writeLine();\n                        write(\";\");\n                    }\n                }\n            }\n            function emitConstructor(node, baseTypeElement) {\n                var saveTempFlags = tempFlags;\n                var saveTempVariables = tempVariables;\n                var saveTempParameters = tempParameters;\n                tempFlags = 0;\n                tempVariables = undefined;\n                tempParameters = undefined;\n                emitConstructorWorker(node, baseTypeElement);\n                tempFlags = saveTempFlags;\n                tempVariables = saveTempVariables;\n                tempParameters = saveTempParameters;\n            }\n            function emitConstructorWorker(node, baseTypeElement) {\n                // Check if we have property assignment inside class declaration.\n                // If there is property assignment, we need to emit constructor whether users define it or not\n                // If there is no property assignment, we can omit constructor if users do not define it\n                var hasInstancePropertyWithInitializer = false;\n                // Emit the constructor overload pinned comments\n                ts.forEach(node.members, function (member) {\n                    if (member.kind === 144 /* Constructor */ && !member.body) {\n                        emitCommentsOnNotEmittedNode(member);\n                    }\n                    // Check if there is any non-static property assignment\n                    if (member.kind === 141 /* PropertyDeclaration */ && member.initializer && (member.flags & 128 /* Static */) === 0) {\n                        hasInstancePropertyWithInitializer = true;\n                    }\n                });\n                var ctor = ts.getFirstConstructorWithBody(node);\n                // For target ES6 and above, if there is no user-defined constructor and there is no property assignment\n                // do not emit constructor in class declaration.\n                if (languageVersion >= 2 /* ES6 */ && !ctor && !hasInstancePropertyWithInitializer) {\n                    return;\n                }\n                if (ctor) {\n                    emitLeadingComments(ctor);\n                }\n                emitStart(ctor || node);\n                if (languageVersion < 2 /* ES6 */) {\n                    write(\"function \");\n                    emitDeclarationName(node);\n                    emitSignatureParameters(ctor);\n                }\n                else {\n                    write(\"constructor\");\n                    if (ctor) {\n                        emitSignatureParameters(ctor);\n                    }\n                    else {\n                        // Based on EcmaScript6 section 14.5.14: Runtime Semantics: ClassDefinitionEvaluation.\n                        // If constructor is empty, then,\n                        //      If ClassHeritageopt is present, then\n                        //          Let constructor be the result of parsing the String \"constructor(... args){ super (...args);}\" using the syntactic grammar with the goal symbol MethodDefinition.\n                        //      Else,\n                        //          Let constructor be the result of parsing the String \"constructor( ){ }\" using the syntactic grammar with the goal symbol MethodDefinition\n                        if (baseTypeElement) {\n                            write(\"(...args)\");\n                        }\n                        else {\n                            write(\"()\");\n                        }\n                    }\n                }\n                var startIndex = 0;\n                write(\" {\");\n                scopeEmitStart(node, \"constructor\");\n                increaseIndent();\n                if (ctor) {\n                    // Emit all the directive prologues (like \"use strict\").  These have to come before\n                    // any other preamble code we write (like parameter initializers).\n                    startIndex = emitDirectivePrologues(ctor.body.statements, /*startWithNewLine*/ true);\n                    emitDetachedComments(ctor.body.statements);\n                }\n                emitCaptureThisForNodeIfNecessary(node);\n                var superCall;\n                if (ctor) {\n                    emitDefaultValueAssignments(ctor);\n                    emitRestParameter(ctor);\n                    if (baseTypeElement) {\n                        superCall = findInitialSuperCall(ctor);\n                        if (superCall) {\n                            writeLine();\n                            emit(superCall);\n                        }\n                    }\n                    emitParameterPropertyAssignments(ctor);\n                }\n                else {\n                    if (baseTypeElement) {\n                        writeLine();\n                        emitStart(baseTypeElement);\n                        if (languageVersion < 2 /* ES6 */) {\n                            write(\"_super.apply(this, arguments);\");\n                        }\n                        else {\n                            write(\"super(...args);\");\n                        }\n                        emitEnd(baseTypeElement);\n                    }\n                }\n                emitPropertyDeclarations(node, getInitializedProperties(node, /*static:*/ false));\n                if (ctor) {\n                    var statements = ctor.body.statements;\n                    if (superCall) {\n                        statements = statements.slice(1);\n                    }\n                    emitLinesStartingAt(statements, startIndex);\n                }\n                emitTempDeclarations(/*newLine*/ true);\n                writeLine();\n                if (ctor) {\n                    emitLeadingCommentsOfPosition(ctor.body.statements.end);\n                }\n                decreaseIndent();\n                emitToken(16 /* CloseBraceToken */, ctor ? ctor.body.statements.end : node.members.end);\n                scopeEmitEnd();\n                emitEnd(ctor || node);\n                if (ctor) {\n                    emitTrailingComments(ctor);\n                }\n            }\n            function emitClassExpression(node) {\n                return emitClassLikeDeclaration(node);\n            }\n            function emitClassDeclaration(node) {\n                return emitClassLikeDeclaration(node);\n            }\n            function emitClassLikeDeclaration(node) {\n                if (languageVersion < 2 /* ES6 */) {\n                    emitClassLikeDeclarationBelowES6(node);\n                }\n                else {\n                    emitClassLikeDeclarationForES6AndHigher(node);\n                }\n                if (modulekind !== 5 /* ES6 */ && node.parent === currentSourceFile && node.name) {\n                    emitExportMemberAssignments(node.name);\n                }\n            }\n            function emitClassLikeDeclarationForES6AndHigher(node) {\n                var thisNodeIsDecorated = ts.nodeIsDecorated(node);\n                if (node.kind === 214 /* ClassDeclaration */) {\n                    if (thisNodeIsDecorated) {\n                        // To preserve the correct runtime semantics when decorators are applied to the class,\n                        // the emit needs to follow one of the following rules:\n                        //\n                        // * For a local class declaration:\n                        //\n                        //     @dec class C {\n                        //     }\n                        //\n                        //   The emit should be:\n                        //\n                        //     let C = class {\n                        //     };\n                        //     C = __decorate([dec], C);\n                        //\n                        // * For an exported class declaration:\n                        //\n                        //     @dec export class C {\n                        //     }\n                        //\n                        //   The emit should be:\n                        //\n                        //     export let C = class {\n                        //     };\n                        //     C = __decorate([dec], C);\n                        //\n                        // * For a default export of a class declaration with a name:\n                        //\n                        //     @dec default export class C {\n                        //     }\n                        //\n                        //   The emit should be:\n                        //\n                        //     let C = class {\n                        //     }\n                        //     C = __decorate([dec], C);\n                        //     export default C;\n                        //\n                        // * For a default export of a class declaration without a name:\n                        //\n                        //     @dec default export class {\n                        //     }\n                        //\n                        //   The emit should be:\n                        //\n                        //     let _default = class {\n                        //     }\n                        //     _default = __decorate([dec], _default);\n                        //     export default _default;\n                        //\n                        if (isES6ExportedDeclaration(node) && !(node.flags & 1024 /* Default */)) {\n                            write(\"export \");\n                        }\n                        write(\"let \");\n                        emitDeclarationName(node);\n                        write(\" = \");\n                    }\n                    else if (isES6ExportedDeclaration(node)) {\n                        write(\"export \");\n                        if (node.flags & 1024 /* Default */) {\n                            write(\"default \");\n                        }\n                    }\n                }\n                // If the class has static properties, and it's a class expression, then we'll need\n                // to specialize the emit a bit.  for a class expression of the form:\n                //\n                //      class C { static a = 1; static b = 2; ... }\n                //\n                // We'll emit:\n                //\n                //      (_temp = class C { ... }, _temp.a = 1, _temp.b = 2, _temp)\n                //\n                // This keeps the expression as an expression, while ensuring that the static parts\n                // of it have been initialized by the time it is used.\n                var staticProperties = getInitializedProperties(node, /*static:*/ true);\n                var isClassExpressionWithStaticProperties = staticProperties.length > 0 && node.kind === 186 /* ClassExpression */;\n                var tempVariable;\n                if (isClassExpressionWithStaticProperties) {\n                    tempVariable = createAndRecordTempVariable(0 /* Auto */);\n                    write(\"(\");\n                    increaseIndent();\n                    emit(tempVariable);\n                    write(\" = \");\n                }\n                write(\"class\");\n                // emit name if\n                // - node has a name\n                // - this is default export with static initializers\n                if ((node.name || (node.flags & 1024 /* Default */ && staticProperties.length > 0)) && !thisNodeIsDecorated) {\n                    write(\" \");\n                    emitDeclarationName(node);\n                }\n                var baseTypeNode = ts.getClassExtendsHeritageClauseElement(node);\n                if (baseTypeNode) {\n                    write(\" extends \");\n                    emit(baseTypeNode.expression);\n                }\n                write(\" {\");\n                increaseIndent();\n                scopeEmitStart(node);\n                writeLine();\n                emitConstructor(node, baseTypeNode);\n                emitMemberFunctionsForES6AndHigher(node);\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.members.end);\n                scopeEmitEnd();\n                // TODO(rbuckton): Need to go back to `let _a = class C {}` approach, removing the defineProperty call for now.\n                // For a decorated class, we need to assign its name (if it has one). This is because we emit\n                // the class as a class expression to avoid the double-binding of the identifier:\n                //\n                //   let C = class {\n                //   }\n                //   Object.defineProperty(C, \"name\", { value: \"C\", configurable: true });\n                //\n                if (thisNodeIsDecorated) {\n                    write(\";\");\n                }\n                // Emit static property assignment. Because classDeclaration is lexically evaluated,\n                // it is safe to emit static property assignment after classDeclaration\n                // From ES6 specification:\n                //      HasLexicalDeclaration (N) : Determines if the argument identifier has a binding in this environment record that was created using\n                //                                  a lexical declaration such as a LexicalDeclaration or a ClassDeclaration.\n                if (isClassExpressionWithStaticProperties) {\n                    for (var _a = 0; _a < staticProperties.length; _a++) {\n                        var property = staticProperties[_a];\n                        write(\",\");\n                        writeLine();\n                        emitPropertyDeclaration(node, property, /*receiver:*/ tempVariable, /*isExpression:*/ true);\n                    }\n                    write(\",\");\n                    writeLine();\n                    emit(tempVariable);\n                    decreaseIndent();\n                    write(\")\");\n                }\n                else {\n                    writeLine();\n                    emitPropertyDeclarations(node, staticProperties);\n                    emitDecoratorsOfClass(node);\n                }\n                // If this is an exported class, but not on the top level (i.e. on an internal\n                // module), export it\n                if (!isES6ExportedDeclaration(node) && (node.flags & 1 /* Export */)) {\n                    writeLine();\n                    emitStart(node);\n                    emitModuleMemberName(node);\n                    write(\" = \");\n                    emitDeclarationName(node);\n                    emitEnd(node);\n                    write(\";\");\n                }\n                else if (isES6ExportedDeclaration(node) && (node.flags & 1024 /* Default */) && thisNodeIsDecorated) {\n                    // if this is a top level default export of decorated class, write the export after the declaration.\n                    writeLine();\n                    write(\"export default \");\n                    emitDeclarationName(node);\n                    write(\";\");\n                }\n            }\n            function emitClassLikeDeclarationBelowES6(node) {\n                if (node.kind === 214 /* ClassDeclaration */) {\n                    // source file level classes in system modules are hoisted so 'var's for them are already defined\n                    if (!shouldHoistDeclarationInSystemJsModule(node)) {\n                        write(\"var \");\n                    }\n                    emitDeclarationName(node);\n                    write(\" = \");\n                }\n                write(\"(function (\");\n                var baseTypeNode = ts.getClassExtendsHeritageClauseElement(node);\n                if (baseTypeNode) {\n                    write(\"_super\");\n                }\n                write(\") {\");\n                var saveTempFlags = tempFlags;\n                var saveTempVariables = tempVariables;\n                var saveTempParameters = tempParameters;\n                var saveComputedPropertyNamesToGeneratedNames = computedPropertyNamesToGeneratedNames;\n                tempFlags = 0;\n                tempVariables = undefined;\n                tempParameters = undefined;\n                computedPropertyNamesToGeneratedNames = undefined;\n                increaseIndent();\n                scopeEmitStart(node);\n                if (baseTypeNode) {\n                    writeLine();\n                    emitStart(baseTypeNode);\n                    write(\"__extends(\");\n                    emitDeclarationName(node);\n                    write(\", _super);\");\n                    emitEnd(baseTypeNode);\n                }\n                writeLine();\n                emitConstructor(node, baseTypeNode);\n                emitMemberFunctionsForES5AndLower(node);\n                emitPropertyDeclarations(node, getInitializedProperties(node, /*static:*/ true));\n                writeLine();\n                emitDecoratorsOfClass(node);\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.members.end, function () {\n                    write(\"return \");\n                    emitDeclarationName(node);\n                });\n                write(\";\");\n                emitTempDeclarations(/*newLine*/ true);\n                tempFlags = saveTempFlags;\n                tempVariables = saveTempVariables;\n                tempParameters = saveTempParameters;\n                computedPropertyNamesToGeneratedNames = saveComputedPropertyNamesToGeneratedNames;\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.members.end);\n                scopeEmitEnd();\n                emitStart(node);\n                write(\")(\");\n                if (baseTypeNode) {\n                    emit(baseTypeNode.expression);\n                }\n                write(\")\");\n                if (node.kind === 214 /* ClassDeclaration */) {\n                    write(\";\");\n                }\n                emitEnd(node);\n                if (node.kind === 214 /* ClassDeclaration */) {\n                    emitExportMemberAssignment(node);\n                }\n            }\n            function emitClassMemberPrefix(node, member) {\n                emitDeclarationName(node);\n                if (!(member.flags & 128 /* Static */)) {\n                    write(\".prototype\");\n                }\n            }\n            function emitDecoratorsOfClass(node) {\n                emitDecoratorsOfMembers(node, /*staticFlag*/ 0);\n                emitDecoratorsOfMembers(node, 128 /* Static */);\n                emitDecoratorsOfConstructor(node);\n            }\n            function emitDecoratorsOfConstructor(node) {\n                var decorators = node.decorators;\n                var constructor = ts.getFirstConstructorWithBody(node);\n                var hasDecoratedParameters = constructor && ts.forEach(constructor.parameters, ts.nodeIsDecorated);\n                // skip decoration of the constructor if neither it nor its parameters are decorated\n                if (!decorators && !hasDecoratedParameters) {\n                    return;\n                }\n                // Emit the call to __decorate. Given the class:\n                //\n                //   @dec\n                //   class C {\n                //   }\n                //\n                // The emit for the class is:\n                //\n                //   C = __decorate([dec], C);\n                //\n                writeLine();\n                emitStart(node);\n                emitDeclarationName(node);\n                write(\" = __decorate([\");\n                increaseIndent();\n                writeLine();\n                var decoratorCount = decorators ? decorators.length : 0;\n                var argumentsWritten = emitList(decorators, 0, decoratorCount, /*multiLine*/ true, /*trailingComma*/ false, /*leadingComma*/ false, /*noTrailingNewLine*/ true, function (decorator) {\n                    emitStart(decorator);\n                    emit(decorator.expression);\n                    emitEnd(decorator);\n                });\n                argumentsWritten += emitDecoratorsOfParameters(constructor, /*leadingComma*/ argumentsWritten > 0);\n                emitSerializedTypeMetadata(node, /*leadingComma*/ argumentsWritten >= 0);\n                decreaseIndent();\n                writeLine();\n                write(\"], \");\n                emitDeclarationName(node);\n                write(\");\");\n                emitEnd(node);\n                writeLine();\n            }\n            function emitDecoratorsOfMembers(node, staticFlag) {\n                for (var _a = 0, _b = node.members; _a < _b.length; _a++) {\n                    var member = _b[_a];\n                    // only emit members in the correct group\n                    if ((member.flags & 128 /* Static */) !== staticFlag) {\n                        continue;\n                    }\n                    // skip members that cannot be decorated (such as the constructor)\n                    if (!ts.nodeCanBeDecorated(member)) {\n                        continue;\n                    }\n                    // skip a member if it or any of its parameters are not decorated\n                    if (!ts.nodeOrChildIsDecorated(member)) {\n                        continue;\n                    }\n                    // skip an accessor declaration if it is not the first accessor\n                    var decorators = void 0;\n                    var functionLikeMember = void 0;\n                    if (ts.isAccessor(member)) {\n                        var accessors = ts.getAllAccessorDeclarations(node.members, member);\n                        if (member !== accessors.firstAccessor) {\n                            continue;\n                        }\n                        // get the decorators from the first accessor with decorators\n                        decorators = accessors.firstAccessor.decorators;\n                        if (!decorators && accessors.secondAccessor) {\n                            decorators = accessors.secondAccessor.decorators;\n                        }\n                        // we only decorate parameters of the set accessor\n                        functionLikeMember = accessors.setAccessor;\n                    }\n                    else {\n                        decorators = member.decorators;\n                        // we only decorate the parameters here if this is a method\n                        if (member.kind === 143 /* MethodDeclaration */) {\n                            functionLikeMember = member;\n                        }\n                    }\n                    // Emit the call to __decorate. Given the following:\n                    //\n                    //   class C {\n                    //     @dec method(@dec2 x) {}\n                    //     @dec get accessor() {}\n                    //     @dec prop;\n                    //   }\n                    //\n                    // The emit for a method is:\n                    //\n                    //   __decorate([\n                    //       dec,\n                    //       __param(0, dec2),\n                    //       __metadata(\"design:type\", Function),\n                    //       __metadata(\"design:paramtypes\", [Object]),\n                    //       __metadata(\"design:returntype\", void 0)\n                    //   ], C.prototype, \"method\", undefined);\n                    //\n                    // The emit for an accessor is:\n                    //\n                    //   __decorate([\n                    //       dec\n                    //   ], C.prototype, \"accessor\", undefined);\n                    //\n                    // The emit for a property is:\n                    //\n                    //   __decorate([\n                    //       dec\n                    //   ], C.prototype, \"prop\");\n                    //\n                    writeLine();\n                    emitStart(member);\n                    write(\"__decorate([\");\n                    increaseIndent();\n                    writeLine();\n                    var decoratorCount = decorators ? decorators.length : 0;\n                    var argumentsWritten = emitList(decorators, 0, decoratorCount, /*multiLine*/ true, /*trailingComma*/ false, /*leadingComma*/ false, /*noTrailingNewLine*/ true, function (decorator) {\n                        emitStart(decorator);\n                        emit(decorator.expression);\n                        emitEnd(decorator);\n                    });\n                    argumentsWritten += emitDecoratorsOfParameters(functionLikeMember, argumentsWritten > 0);\n                    emitSerializedTypeMetadata(member, argumentsWritten > 0);\n                    decreaseIndent();\n                    writeLine();\n                    write(\"], \");\n                    emitStart(member.name);\n                    emitClassMemberPrefix(node, member);\n                    write(\", \");\n                    emitExpressionForPropertyName(member.name);\n                    emitEnd(member.name);\n                    if (languageVersion > 0 /* ES3 */) {\n                        if (member.kind !== 141 /* PropertyDeclaration */) {\n                            // We emit `null` here to indicate to `__decorate` that it can invoke `Object.getOwnPropertyDescriptor` directly.\n                            // We have this extra argument here so that we can inject an explicit property descriptor at a later date.\n                            write(\", null\");\n                        }\n                        else {\n                            // We emit `void 0` here to indicate to `__decorate` that it can invoke `Object.defineProperty` directly, but that it\n                            // should not invoke `Object.getOwnPropertyDescriptor`.\n                            write(\", void 0\");\n                        }\n                    }\n                    write(\");\");\n                    emitEnd(member);\n                    writeLine();\n                }\n            }\n            function emitDecoratorsOfParameters(node, leadingComma) {\n                var argumentsWritten = 0;\n                if (node) {\n                    var parameterIndex = 0;\n                    for (var _a = 0, _b = node.parameters; _a < _b.length; _a++) {\n                        var parameter = _b[_a];\n                        if (ts.nodeIsDecorated(parameter)) {\n                            var decorators = parameter.decorators;\n                            argumentsWritten += emitList(decorators, 0, decorators.length, /*multiLine*/ true, /*trailingComma*/ false, /*leadingComma*/ leadingComma, /*noTrailingNewLine*/ true, function (decorator) {\n                                emitStart(decorator);\n                                write(\"__param(\" + parameterIndex + \", \");\n                                emit(decorator.expression);\n                                write(\")\");\n                                emitEnd(decorator);\n                            });\n                            leadingComma = true;\n                        }\n                        ++parameterIndex;\n                    }\n                }\n                return argumentsWritten;\n            }\n            function shouldEmitTypeMetadata(node) {\n                // This method determines whether to emit the \"design:type\" metadata based on the node's kind.\n                // The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata\n                // compiler option is set.\n                switch (node.kind) {\n                    case 143 /* MethodDeclaration */:\n                    case 145 /* GetAccessor */:\n                    case 146 /* SetAccessor */:\n                    case 141 /* PropertyDeclaration */:\n                        return true;\n                }\n                return false;\n            }\n            function shouldEmitReturnTypeMetadata(node) {\n                // This method determines whether to emit the \"design:returntype\" metadata based on the node's kind.\n                // The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata\n                // compiler option is set.\n                switch (node.kind) {\n                    case 143 /* MethodDeclaration */:\n                        return true;\n                }\n                return false;\n            }\n            function shouldEmitParamTypesMetadata(node) {\n                // This method determines whether to emit the \"design:paramtypes\" metadata based on the node's kind.\n                // The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata\n                // compiler option is set.\n                switch (node.kind) {\n                    case 214 /* ClassDeclaration */:\n                    case 143 /* MethodDeclaration */:\n                    case 146 /* SetAccessor */:\n                        return true;\n                }\n                return false;\n            }\n            /** Serializes the type of a declaration to an appropriate JS constructor value. Used by the __metadata decorator for a class member. */\n            function emitSerializedTypeOfNode(node) {\n                // serialization of the type of a declaration uses the following rules:\n                //\n                // * The serialized type of a ClassDeclaration is \"Function\"\n                // * The serialized type of a ParameterDeclaration is the serialized type of its type annotation.\n                // * The serialized type of a PropertyDeclaration is the serialized type of its type annotation.\n                // * The serialized type of an AccessorDeclaration is the serialized type of the return type annotation of its getter or parameter type annotation of its setter.\n                // * The serialized type of any other FunctionLikeDeclaration is \"Function\".\n                // * The serialized type of any other node is \"void 0\".\n                //\n                // For rules on serializing type annotations, see `serializeTypeNode`.\n                switch (node.kind) {\n                    case 214 /* ClassDeclaration */:\n                        write(\"Function\");\n                        return;\n                    case 141 /* PropertyDeclaration */:\n                        emitSerializedTypeNode(node.type);\n                        return;\n                    case 138 /* Parameter */:\n                        emitSerializedTypeNode(node.type);\n                        return;\n                    case 145 /* GetAccessor */:\n                        emitSerializedTypeNode(node.type);\n                        return;\n                    case 146 /* SetAccessor */:\n                        emitSerializedTypeNode(ts.getSetAccessorTypeAnnotationNode(node));\n                        return;\n                }\n                if (ts.isFunctionLike(node)) {\n                    write(\"Function\");\n                    return;\n                }\n                write(\"void 0\");\n            }\n            function emitSerializedTypeNode(node) {\n                if (node) {\n                    switch (node.kind) {\n                        case 103 /* VoidKeyword */:\n                            write(\"void 0\");\n                            return;\n                        case 160 /* ParenthesizedType */:\n                            emitSerializedTypeNode(node.type);\n                            return;\n                        case 152 /* FunctionType */:\n                        case 153 /* ConstructorType */:\n                            write(\"Function\");\n                            return;\n                        case 156 /* ArrayType */:\n                        case 157 /* TupleType */:\n                            write(\"Array\");\n                            return;\n                        case 150 /* TypePredicate */:\n                        case 120 /* BooleanKeyword */:\n                            write(\"Boolean\");\n                            return;\n                        case 130 /* StringKeyword */:\n                        case 9 /* StringLiteral */:\n                            write(\"String\");\n                            return;\n                        case 128 /* NumberKeyword */:\n                            write(\"Number\");\n                            return;\n                        case 131 /* SymbolKeyword */:\n                            write(\"Symbol\");\n                            return;\n                        case 151 /* TypeReference */:\n                            emitSerializedTypeReferenceNode(node);\n                            return;\n                        case 154 /* TypeQuery */:\n                        case 155 /* TypeLiteral */:\n                        case 158 /* UnionType */:\n                        case 159 /* IntersectionType */:\n                        case 117 /* AnyKeyword */:\n                            break;\n                        default:\n                            ts.Debug.fail(\"Cannot serialize unexpected type node.\");\n                            break;\n                    }\n                }\n                write(\"Object\");\n            }\n            /** Serializes a TypeReferenceNode to an appropriate JS constructor value. Used by the __metadata decorator. */\n            function emitSerializedTypeReferenceNode(node) {\n                var location = node.parent;\n                while (ts.isDeclaration(location) || ts.isTypeNode(location)) {\n                    location = location.parent;\n                }\n                // Clone the type name and parent it to a location outside of the current declaration.\n                var typeName = ts.cloneEntityName(node.typeName);\n                typeName.parent = location;\n                var result = resolver.getTypeReferenceSerializationKind(typeName);\n                switch (result) {\n                    case ts.TypeReferenceSerializationKind.Unknown:\n                        var temp = createAndRecordTempVariable(0 /* Auto */);\n                        write(\"(typeof (\");\n                        emitNodeWithoutSourceMap(temp);\n                        write(\" = \");\n                        emitEntityNameAsExpression(typeName, /*useFallback*/ true);\n                        write(\") === 'function' && \");\n                        emitNodeWithoutSourceMap(temp);\n                        write(\") || Object\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue:\n                        emitEntityNameAsExpression(typeName, /*useFallback*/ false);\n                        break;\n                    case ts.TypeReferenceSerializationKind.VoidType:\n                        write(\"void 0\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.BooleanType:\n                        write(\"Boolean\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.NumberLikeType:\n                        write(\"Number\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.StringLikeType:\n                        write(\"String\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.ArrayLikeType:\n                        write(\"Array\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.ESSymbolType:\n                        if (languageVersion < 2 /* ES6 */) {\n                            write(\"typeof Symbol === 'function' ? Symbol : Object\");\n                        }\n                        else {\n                            write(\"Symbol\");\n                        }\n                        break;\n                    case ts.TypeReferenceSerializationKind.TypeWithCallSignature:\n                        write(\"Function\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.ObjectType:\n                        write(\"Object\");\n                        break;\n                }\n            }\n            /** Serializes the parameter types of a function or the constructor of a class. Used by the __metadata decorator for a method or set accessor. */\n            function emitSerializedParameterTypesOfNode(node) {\n                // serialization of parameter types uses the following rules:\n                //\n                // * If the declaration is a class, the parameters of the first constructor with a body are used.\n                // * If the declaration is function-like and has a body, the parameters of the function are used.\n                //\n                // For the rules on serializing the type of each parameter declaration, see `serializeTypeOfDeclaration`.\n                if (node) {\n                    var valueDeclaration;\n                    if (node.kind === 214 /* ClassDeclaration */) {\n                        valueDeclaration = ts.getFirstConstructorWithBody(node);\n                    }\n                    else if (ts.isFunctionLike(node) && ts.nodeIsPresent(node.body)) {\n                        valueDeclaration = node;\n                    }\n                    if (valueDeclaration) {\n                        var parameters = valueDeclaration.parameters;\n                        var parameterCount = parameters.length;\n                        if (parameterCount > 0) {\n                            for (var i = 0; i < parameterCount; i++) {\n                                if (i > 0) {\n                                    write(\", \");\n                                }\n                                if (parameters[i].dotDotDotToken) {\n                                    var parameterType = parameters[i].type;\n                                    if (parameterType.kind === 156 /* ArrayType */) {\n                                        parameterType = parameterType.elementType;\n                                    }\n                                    else if (parameterType.kind === 151 /* TypeReference */ && parameterType.typeArguments && parameterType.typeArguments.length === 1) {\n                                        parameterType = parameterType.typeArguments[0];\n                                    }\n                                    else {\n                                        parameterType = undefined;\n                                    }\n                                    emitSerializedTypeNode(parameterType);\n                                }\n                                else {\n                                    emitSerializedTypeOfNode(parameters[i]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            /** Serializes the return type of function. Used by the __metadata decorator for a method. */\n            function emitSerializedReturnTypeOfNode(node) {\n                if (node && ts.isFunctionLike(node) && node.type) {\n                    emitSerializedTypeNode(node.type);\n                    return;\n                }\n                write(\"void 0\");\n            }\n            function emitSerializedTypeMetadata(node, writeComma) {\n                // This method emits the serialized type metadata for a decorator target.\n                // The caller should have already tested whether the node has decorators.\n                var argumentsWritten = 0;\n                if (compilerOptions.emitDecoratorMetadata) {\n                    if (shouldEmitTypeMetadata(node)) {\n                        if (writeComma) {\n                            write(\", \");\n                        }\n                        writeLine();\n                        write(\"__metadata('design:type', \");\n                        emitSerializedTypeOfNode(node);\n                        write(\")\");\n                        argumentsWritten++;\n                    }\n                    if (shouldEmitParamTypesMetadata(node)) {\n                        if (writeComma || argumentsWritten) {\n                            write(\", \");\n                        }\n                        writeLine();\n                        write(\"__metadata('design:paramtypes', [\");\n                        emitSerializedParameterTypesOfNode(node);\n                        write(\"])\");\n                        argumentsWritten++;\n                    }\n                    if (shouldEmitReturnTypeMetadata(node)) {\n                        if (writeComma || argumentsWritten) {\n                            write(\", \");\n                        }\n                        writeLine();\n                        write(\"__metadata('design:returntype', \");\n                        emitSerializedReturnTypeOfNode(node);\n                        write(\")\");\n                        argumentsWritten++;\n                    }\n                }\n                return argumentsWritten;\n            }\n            function emitInterfaceDeclaration(node) {\n                emitCommentsOnNotEmittedNode(node);\n            }\n            function shouldEmitEnumDeclaration(node) {\n                var isConstEnum = ts.isConst(node);\n                return !isConstEnum || compilerOptions.preserveConstEnums || compilerOptions.isolatedModules;\n            }\n            function emitEnumDeclaration(node) {\n                // const enums are completely erased during compilation.\n                if (!shouldEmitEnumDeclaration(node)) {\n                    return;\n                }\n                if (!shouldHoistDeclarationInSystemJsModule(node)) {\n                    // do not emit var if variable was already hoisted\n                    if (!(node.flags & 1 /* Export */) || isES6ExportedDeclaration(node)) {\n                        emitStart(node);\n                        if (isES6ExportedDeclaration(node)) {\n                            write(\"export \");\n                        }\n                        write(\"var \");\n                        emit(node.name);\n                        emitEnd(node);\n                        write(\";\");\n                    }\n                }\n                writeLine();\n                emitStart(node);\n                write(\"(function (\");\n                emitStart(node.name);\n                write(getGeneratedNameForNode(node));\n                emitEnd(node.name);\n                write(\") {\");\n                increaseIndent();\n                scopeEmitStart(node);\n                emitLines(node.members);\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.members.end);\n                scopeEmitEnd();\n                write(\")(\");\n                emitModuleMemberName(node);\n                write(\" || (\");\n                emitModuleMemberName(node);\n                write(\" = {}));\");\n                emitEnd(node);\n                if (!isES6ExportedDeclaration(node) && node.flags & 1 /* Export */ && !shouldHoistDeclarationInSystemJsModule(node)) {\n                    // do not emit var if variable was already hoisted\n                    writeLine();\n                    emitStart(node);\n                    write(\"var \");\n                    emit(node.name);\n                    write(\" = \");\n                    emitModuleMemberName(node);\n                    emitEnd(node);\n                    write(\";\");\n                }\n                if (modulekind !== 5 /* ES6 */ && node.parent === currentSourceFile) {\n                    if (modulekind === 4 /* System */ && (node.flags & 1 /* Export */)) {\n                        // write the call to exporter for enum\n                        writeLine();\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitDeclarationName(node);\n                        write(\"\\\", \");\n                        emitDeclarationName(node);\n                        write(\");\");\n                    }\n                    emitExportMemberAssignments(node.name);\n                }\n            }\n            function emitEnumMember(node) {\n                var enumParent = node.parent;\n                emitStart(node);\n                write(getGeneratedNameForNode(enumParent));\n                write(\"[\");\n                write(getGeneratedNameForNode(enumParent));\n                write(\"[\");\n                emitExpressionForPropertyName(node.name);\n                write(\"] = \");\n                writeEnumMemberDeclarationValue(node);\n                write(\"] = \");\n                emitExpressionForPropertyName(node.name);\n                emitEnd(node);\n                write(\";\");\n            }\n            function writeEnumMemberDeclarationValue(member) {\n                var value = resolver.getConstantValue(member);\n                if (value !== undefined) {\n                    write(value.toString());\n                    return;\n                }\n                else if (member.initializer) {\n                    emit(member.initializer);\n                }\n                else {\n                    write(\"undefined\");\n                }\n            }\n            function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {\n                if (moduleDeclaration.body.kind === 218 /* ModuleDeclaration */) {\n                    var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);\n                    return recursiveInnerModule || moduleDeclaration.body;\n                }\n            }\n            function shouldEmitModuleDeclaration(node) {\n                return ts.isInstantiatedModule(node, compilerOptions.preserveConstEnums || compilerOptions.isolatedModules);\n            }\n            function isModuleMergedWithES6Class(node) {\n                return languageVersion === 2 /* ES6 */ && !!(resolver.getNodeCheckFlags(node) & 32768 /* LexicalModuleMergesWithClass */);\n            }\n            function emitModuleDeclaration(node) {\n                // Emit only if this module is non-ambient.\n                var shouldEmit = shouldEmitModuleDeclaration(node);\n                if (!shouldEmit) {\n                    return emitCommentsOnNotEmittedNode(node);\n                }\n                var hoistedInDeclarationScope = shouldHoistDeclarationInSystemJsModule(node);\n                var emitVarForModule = !hoistedInDeclarationScope && !isModuleMergedWithES6Class(node);\n                if (emitVarForModule) {\n                    emitStart(node);\n                    if (isES6ExportedDeclaration(node)) {\n                        write(\"export \");\n                    }\n                    write(\"var \");\n                    emit(node.name);\n                    write(\";\");\n                    emitEnd(node);\n                    writeLine();\n                }\n                emitStart(node);\n                write(\"(function (\");\n                emitStart(node.name);\n                write(getGeneratedNameForNode(node));\n                emitEnd(node.name);\n                write(\") \");\n                if (node.body.kind === 219 /* ModuleBlock */) {\n                    var saveTempFlags = tempFlags;\n                    var saveTempVariables = tempVariables;\n                    tempFlags = 0;\n                    tempVariables = undefined;\n                    emit(node.body);\n                    tempFlags = saveTempFlags;\n                    tempVariables = saveTempVariables;\n                }\n                else {\n                    write(\"{\");\n                    increaseIndent();\n                    scopeEmitStart(node);\n                    emitCaptureThisForNodeIfNecessary(node);\n                    writeLine();\n                    emit(node.body);\n                    decreaseIndent();\n                    writeLine();\n                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;\n                    emitToken(16 /* CloseBraceToken */, moduleBlock.statements.end);\n                    scopeEmitEnd();\n                }\n                write(\")(\");\n                // write moduleDecl = containingModule.m only if it is not exported es6 module member\n                if ((node.flags & 1 /* Export */) && !isES6ExportedDeclaration(node)) {\n                    emit(node.name);\n                    write(\" = \");\n                }\n                emitModuleMemberName(node);\n                write(\" || (\");\n                emitModuleMemberName(node);\n                write(\" = {}));\");\n                emitEnd(node);\n                if (!isES6ExportedDeclaration(node) && node.name.kind === 69 /* Identifier */ && node.parent === currentSourceFile) {\n                    if (modulekind === 4 /* System */ && (node.flags & 1 /* Export */)) {\n                        writeLine();\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitDeclarationName(node);\n                        write(\"\\\", \");\n                        emitDeclarationName(node);\n                        write(\");\");\n                    }\n                    emitExportMemberAssignments(node.name);\n                }\n            }\n            /*\n             * Some bundlers (SystemJS builder) sometimes want to rename dependencies.\n             * Here we check if alternative name was provided for a given moduleName and return it if possible.\n             */\n            function tryRenameExternalModule(moduleName) {\n                if (currentSourceFile.renamedDependencies && ts.hasProperty(currentSourceFile.renamedDependencies, moduleName.text)) {\n                    return \"\\\"\" + currentSourceFile.renamedDependencies[moduleName.text] + \"\\\"\";\n                }\n                return undefined;\n            }\n            function emitRequire(moduleName) {\n                if (moduleName.kind === 9 /* StringLiteral */) {\n                    write(\"require(\");\n                    var text = tryRenameExternalModule(moduleName);\n                    if (text) {\n                        write(text);\n                    }\n                    else {\n                        emitStart(moduleName);\n                        emitLiteral(moduleName);\n                        emitEnd(moduleName);\n                    }\n                    emitToken(18 /* CloseParenToken */, moduleName.end);\n                }\n                else {\n                    write(\"require()\");\n                }\n            }\n            function getNamespaceDeclarationNode(node) {\n                if (node.kind === 221 /* ImportEqualsDeclaration */) {\n                    return node;\n                }\n                var importClause = node.importClause;\n                if (importClause && importClause.namedBindings && importClause.namedBindings.kind === 224 /* NamespaceImport */) {\n                    return importClause.namedBindings;\n                }\n            }\n            function isDefaultImport(node) {\n                return node.kind === 222 /* ImportDeclaration */ && node.importClause && !!node.importClause.name;\n            }\n            function emitExportImportAssignments(node) {\n                if (ts.isAliasSymbolDeclaration(node) && resolver.isValueAliasDeclaration(node)) {\n                    emitExportMemberAssignments(node.name);\n                }\n                ts.forEachChild(node, emitExportImportAssignments);\n            }\n            function emitImportDeclaration(node) {\n                if (modulekind !== 5 /* ES6 */) {\n                    return emitExternalImportDeclaration(node);\n                }\n                // ES6 import\n                if (node.importClause) {\n                    var shouldEmitDefaultBindings = resolver.isReferencedAliasDeclaration(node.importClause);\n                    var shouldEmitNamedBindings = node.importClause.namedBindings && resolver.isReferencedAliasDeclaration(node.importClause.namedBindings, /* checkChildren */ true);\n                    if (shouldEmitDefaultBindings || shouldEmitNamedBindings) {\n                        write(\"import \");\n                        emitStart(node.importClause);\n                        if (shouldEmitDefaultBindings) {\n                            emit(node.importClause.name);\n                            if (shouldEmitNamedBindings) {\n                                write(\", \");\n                            }\n                        }\n                        if (shouldEmitNamedBindings) {\n                            emitLeadingComments(node.importClause.namedBindings);\n                            emitStart(node.importClause.namedBindings);\n                            if (node.importClause.namedBindings.kind === 224 /* NamespaceImport */) {\n                                write(\"* as \");\n                                emit(node.importClause.namedBindings.name);\n                            }\n                            else {\n                                write(\"{ \");\n                                emitExportOrImportSpecifierList(node.importClause.namedBindings.elements, resolver.isReferencedAliasDeclaration);\n                                write(\" }\");\n                            }\n                            emitEnd(node.importClause.namedBindings);\n                            emitTrailingComments(node.importClause.namedBindings);\n                        }\n                        emitEnd(node.importClause);\n                        write(\" from \");\n                        emit(node.moduleSpecifier);\n                        write(\";\");\n                    }\n                }\n                else {\n                    write(\"import \");\n                    emit(node.moduleSpecifier);\n                    write(\";\");\n                }\n            }\n            function emitExternalImportDeclaration(node) {\n                if (ts.contains(externalImports, node)) {\n                    var isExportedImport = node.kind === 221 /* ImportEqualsDeclaration */ && (node.flags & 1 /* Export */) !== 0;\n                    var namespaceDeclaration = getNamespaceDeclarationNode(node);\n                    if (modulekind !== 2 /* AMD */) {\n                        emitLeadingComments(node);\n                        emitStart(node);\n                        if (namespaceDeclaration && !isDefaultImport(node)) {\n                            // import x = require(\"foo\")\n                            // import * as x from \"foo\"\n                            if (!isExportedImport)\n                                write(\"var \");\n                            emitModuleMemberName(namespaceDeclaration);\n                            write(\" = \");\n                        }\n                        else {\n                            // import \"foo\"\n                            // import x from \"foo\"\n                            // import { x, y } from \"foo\"\n                            // import d, * as x from \"foo\"\n                            // import d, { x, y } from \"foo\"\n                            var isNakedImport = 222 /* ImportDeclaration */ && !node.importClause;\n                            if (!isNakedImport) {\n                                write(\"var \");\n                                write(getGeneratedNameForNode(node));\n                                write(\" = \");\n                            }\n                        }\n                        emitRequire(ts.getExternalModuleName(node));\n                        if (namespaceDeclaration && isDefaultImport(node)) {\n                            // import d, * as x from \"foo\"\n                            write(\", \");\n                            emitModuleMemberName(namespaceDeclaration);\n                            write(\" = \");\n                            write(getGeneratedNameForNode(node));\n                        }\n                        write(\";\");\n                        emitEnd(node);\n                        emitExportImportAssignments(node);\n                        emitTrailingComments(node);\n                    }\n                    else {\n                        if (isExportedImport) {\n                            emitModuleMemberName(namespaceDeclaration);\n                            write(\" = \");\n                            emit(namespaceDeclaration.name);\n                            write(\";\");\n                        }\n                        else if (namespaceDeclaration && isDefaultImport(node)) {\n                            // import d, * as x from \"foo\"\n                            write(\"var \");\n                            emitModuleMemberName(namespaceDeclaration);\n                            write(\" = \");\n                            write(getGeneratedNameForNode(node));\n                            write(\";\");\n                        }\n                        emitExportImportAssignments(node);\n                    }\n                }\n            }\n            function emitImportEqualsDeclaration(node) {\n                if (ts.isExternalModuleImportEqualsDeclaration(node)) {\n                    emitExternalImportDeclaration(node);\n                    return;\n                }\n                // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when\n                // - current file is not external module\n                // - import declaration is top level and target is value imported by entity name\n                if (resolver.isReferencedAliasDeclaration(node) ||\n                    (!ts.isExternalModule(currentSourceFile) && resolver.isTopLevelValueImportEqualsWithEntityName(node))) {\n                    emitLeadingComments(node);\n                    emitStart(node);\n                    // variable declaration for import-equals declaration can be hoisted in system modules\n                    // in this case 'var' should be omitted and emit should contain only initialization\n                    var variableDeclarationIsHoisted = shouldHoistVariable(node, /*checkIfSourceFileLevelDecl*/ true);\n                    // is it top level export import v = a.b.c in system module?\n                    // if yes - it needs to be rewritten as exporter('v', v = a.b.c)\n                    var isExported = isSourceFileLevelDeclarationInSystemJsModule(node, /*isExported*/ true);\n                    if (!variableDeclarationIsHoisted) {\n                        ts.Debug.assert(!isExported);\n                        if (isES6ExportedDeclaration(node)) {\n                            write(\"export \");\n                            write(\"var \");\n                        }\n                        else if (!(node.flags & 1 /* Export */)) {\n                            write(\"var \");\n                        }\n                    }\n                    if (isExported) {\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitNodeWithoutSourceMap(node.name);\n                        write(\"\\\", \");\n                    }\n                    emitModuleMemberName(node);\n                    write(\" = \");\n                    emit(node.moduleReference);\n                    if (isExported) {\n                        write(\")\");\n                    }\n                    write(\";\");\n                    emitEnd(node);\n                    emitExportImportAssignments(node);\n                    emitTrailingComments(node);\n                }\n            }\n            function emitExportDeclaration(node) {\n                ts.Debug.assert(modulekind !== 4 /* System */);\n                if (modulekind !== 5 /* ES6 */) {\n                    if (node.moduleSpecifier && (!node.exportClause || resolver.isValueAliasDeclaration(node))) {\n                        emitStart(node);\n                        var generatedName = getGeneratedNameForNode(node);\n                        if (node.exportClause) {\n                            // export { x, y, ... } from \"foo\"\n                            if (modulekind !== 2 /* AMD */) {\n                                write(\"var \");\n                                write(generatedName);\n                                write(\" = \");\n                                emitRequire(ts.getExternalModuleName(node));\n                                write(\";\");\n                            }\n                            for (var _a = 0, _b = node.exportClause.elements; _a < _b.length; _a++) {\n                                var specifier = _b[_a];\n                                if (resolver.isValueAliasDeclaration(specifier)) {\n                                    writeLine();\n                                    emitStart(specifier);\n                                    emitContainingModuleName(specifier);\n                                    write(\".\");\n                                    emitNodeWithCommentsAndWithoutSourcemap(specifier.name);\n                                    write(\" = \");\n                                    write(generatedName);\n                                    write(\".\");\n                                    emitNodeWithCommentsAndWithoutSourcemap(specifier.propertyName || specifier.name);\n                                    write(\";\");\n                                    emitEnd(specifier);\n                                }\n                            }\n                        }\n                        else {\n                            // export * from \"foo\"\n                            writeLine();\n                            write(\"__export(\");\n                            if (modulekind !== 2 /* AMD */) {\n                                emitRequire(ts.getExternalModuleName(node));\n                            }\n                            else {\n                                write(generatedName);\n                            }\n                            write(\");\");\n                        }\n                        emitEnd(node);\n                    }\n                }\n                else {\n                    if (!node.exportClause || resolver.isValueAliasDeclaration(node)) {\n                        write(\"export \");\n                        if (node.exportClause) {\n                            // export { x, y, ... }\n                            write(\"{ \");\n                            emitExportOrImportSpecifierList(node.exportClause.elements, resolver.isValueAliasDeclaration);\n                            write(\" }\");\n                        }\n                        else {\n                            write(\"*\");\n                        }\n                        if (node.moduleSpecifier) {\n                            write(\" from \");\n                            emit(node.moduleSpecifier);\n                        }\n                        write(\";\");\n                    }\n                }\n            }\n            function emitExportOrImportSpecifierList(specifiers, shouldEmit) {\n                ts.Debug.assert(modulekind === 5 /* ES6 */);\n                var needsComma = false;\n                for (var _a = 0; _a < specifiers.length; _a++) {\n                    var specifier = specifiers[_a];\n                    if (shouldEmit(specifier)) {\n                        if (needsComma) {\n                            write(\", \");\n                        }\n                        if (specifier.propertyName) {\n                            emit(specifier.propertyName);\n                            write(\" as \");\n                        }\n                        emit(specifier.name);\n                        needsComma = true;\n                    }\n                }\n            }\n            function emitExportAssignment(node) {\n                if (!node.isExportEquals && resolver.isValueAliasDeclaration(node)) {\n                    if (modulekind === 5 /* ES6 */) {\n                        writeLine();\n                        emitStart(node);\n                        write(\"export default \");\n                        var expression = node.expression;\n                        emit(expression);\n                        if (expression.kind !== 213 /* FunctionDeclaration */ &&\n                            expression.kind !== 214 /* ClassDeclaration */) {\n                            write(\";\");\n                        }\n                        emitEnd(node);\n                    }\n                    else {\n                        writeLine();\n                        emitStart(node);\n                        if (modulekind === 4 /* System */) {\n                            write(exportFunctionForFile + \"(\\\"default\\\",\");\n                            emit(node.expression);\n                            write(\")\");\n                        }\n                        else {\n                            emitEs6ExportDefaultCompat(node);\n                            emitContainingModuleName(node);\n                            if (languageVersion === 0 /* ES3 */) {\n                                write(\"[\\\"default\\\"] = \");\n                            }\n                            else {\n                                write(\".default = \");\n                            }\n                            emit(node.expression);\n                        }\n                        write(\";\");\n                        emitEnd(node);\n                    }\n                }\n            }\n            function collectExternalModuleInfo(sourceFile) {\n                externalImports = [];\n                exportSpecifiers = {};\n                exportEquals = undefined;\n                hasExportStars = false;\n                for (var _a = 0, _b = sourceFile.statements; _a < _b.length; _a++) {\n                    var node = _b[_a];\n                    switch (node.kind) {\n                        case 222 /* ImportDeclaration */:\n                            if (!node.importClause ||\n                                resolver.isReferencedAliasDeclaration(node.importClause, /*checkChildren*/ true)) {\n                                // import \"mod\"\n                                // import x from \"mod\" where x is referenced\n                                // import * as x from \"mod\" where x is referenced\n                                // import { x, y } from \"mod\" where at least one import is referenced\n                                externalImports.push(node);\n                            }\n                            break;\n                        case 221 /* ImportEqualsDeclaration */:\n                            if (node.moduleReference.kind === 232 /* ExternalModuleReference */ && resolver.isReferencedAliasDeclaration(node)) {\n                                // import x = require(\"mod\") where x is referenced\n                                externalImports.push(node);\n                            }\n                            break;\n                        case 228 /* ExportDeclaration */:\n                            if (node.moduleSpecifier) {\n                                if (!node.exportClause) {\n                                    // export * from \"mod\"\n                                    externalImports.push(node);\n                                    hasExportStars = true;\n                                }\n                                else if (resolver.isValueAliasDeclaration(node)) {\n                                    // export { x, y } from \"mod\" where at least one export is a value symbol\n                                    externalImports.push(node);\n                                }\n                            }\n                            else {\n                                // export { x, y }\n                                for (var _c = 0, _d = node.exportClause.elements; _c < _d.length; _c++) {\n                                    var specifier = _d[_c];\n                                    var name_25 = (specifier.propertyName || specifier.name).text;\n                                    (exportSpecifiers[name_25] || (exportSpecifiers[name_25] = [])).push(specifier);\n                                }\n                            }\n                            break;\n                        case 227 /* ExportAssignment */:\n                            if (node.isExportEquals && !exportEquals) {\n                                // export = x\n                                exportEquals = node;\n                            }\n                            break;\n                    }\n                }\n            }\n            function emitExportStarHelper() {\n                if (hasExportStars) {\n                    writeLine();\n                    write(\"function __export(m) {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                }\n            }\n            function getLocalNameForExternalImport(node) {\n                var namespaceDeclaration = getNamespaceDeclarationNode(node);\n                if (namespaceDeclaration && !isDefaultImport(node)) {\n                    return ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, namespaceDeclaration.name);\n                }\n                if (node.kind === 222 /* ImportDeclaration */ && node.importClause) {\n                    return getGeneratedNameForNode(node);\n                }\n                if (node.kind === 228 /* ExportDeclaration */ && node.moduleSpecifier) {\n                    return getGeneratedNameForNode(node);\n                }\n            }\n            function getExternalModuleNameText(importNode) {\n                var moduleName = ts.getExternalModuleName(importNode);\n                if (moduleName.kind === 9 /* StringLiteral */) {\n                    return tryRenameExternalModule(moduleName) || getLiteralText(moduleName);\n                }\n                return undefined;\n            }\n            function emitVariableDeclarationsForImports() {\n                if (externalImports.length === 0) {\n                    return;\n                }\n                writeLine();\n                var started = false;\n                for (var _a = 0; _a < externalImports.length; _a++) {\n                    var importNode = externalImports[_a];\n                    // do not create variable declaration for exports and imports that lack import clause\n                    var skipNode = importNode.kind === 228 /* ExportDeclaration */ ||\n                        (importNode.kind === 222 /* ImportDeclaration */ && !importNode.importClause);\n                    if (skipNode) {\n                        continue;\n                    }\n                    if (!started) {\n                        write(\"var \");\n                        started = true;\n                    }\n                    else {\n                        write(\", \");\n                    }\n                    write(getLocalNameForExternalImport(importNode));\n                }\n                if (started) {\n                    write(\";\");\n                }\n            }\n            function emitLocalStorageForExportedNamesIfNecessary(exportedDeclarations) {\n                // when resolving exports local exported entries/indirect exported entries in the module\n                // should always win over entries with similar names that were added via star exports\n                // to support this we store names of local/indirect exported entries in a set.\n                // this set is used to filter names brought by star expors.\n                if (!hasExportStars) {\n                    // local names set is needed only in presence of star exports\n                    return undefined;\n                }\n                // local names set should only be added if we have anything exported\n                if (!exportedDeclarations && ts.isEmpty(exportSpecifiers)) {\n                    // no exported declarations (export var ...) or export specifiers (export {x})\n                    // check if we have any non star export declarations.\n                    var hasExportDeclarationWithExportClause = false;\n                    for (var _a = 0; _a < externalImports.length; _a++) {\n                        var externalImport = externalImports[_a];\n                        if (externalImport.kind === 228 /* ExportDeclaration */ && externalImport.exportClause) {\n                            hasExportDeclarationWithExportClause = true;\n                            break;\n                        }\n                    }\n                    if (!hasExportDeclarationWithExportClause) {\n                        // we still need to emit exportStar helper\n                        return emitExportStarFunction(/*localNames*/ undefined);\n                    }\n                }\n                var exportedNamesStorageRef = makeUniqueName(\"exportedNames\");\n                writeLine();\n                write(\"var \" + exportedNamesStorageRef + \" = {\");\n                increaseIndent();\n                var started = false;\n                if (exportedDeclarations) {\n                    for (var i = 0; i < exportedDeclarations.length; ++i) {\n                        // write name of exported declaration, i.e 'export var x...'\n                        writeExportedName(exportedDeclarations[i]);\n                    }\n                }\n                if (exportSpecifiers) {\n                    for (var n in exportSpecifiers) {\n                        for (var _b = 0, _c = exportSpecifiers[n]; _b < _c.length; _b++) {\n                            var specifier = _c[_b];\n                            // write name of export specified, i.e. 'export {x}'\n                            writeExportedName(specifier.name);\n                        }\n                    }\n                }\n                for (var _d = 0; _d < externalImports.length; _d++) {\n                    var externalImport = externalImports[_d];\n                    if (externalImport.kind !== 228 /* ExportDeclaration */) {\n                        continue;\n                    }\n                    var exportDecl = externalImport;\n                    if (!exportDecl.exportClause) {\n                        // export * from ...\n                        continue;\n                    }\n                    for (var _e = 0, _f = exportDecl.exportClause.elements; _e < _f.length; _e++) {\n                        var element = _f[_e];\n                        // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                        writeExportedName(element.name || element.propertyName);\n                    }\n                }\n                decreaseIndent();\n                writeLine();\n                write(\"};\");\n                return emitExportStarFunction(exportedNamesStorageRef);\n                function emitExportStarFunction(localNames) {\n                    var exportStarFunction = makeUniqueName(\"exportStar\");\n                    writeLine();\n                    // define an export star helper function\n                    write(\"function \" + exportStarFunction + \"(m) {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"var exports = {};\");\n                    writeLine();\n                    write(\"for(var n in m) {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"if (n !== \\\"default\\\"\");\n                    if (localNames) {\n                        write(\"&& !\" + localNames + \".hasOwnProperty(n)\");\n                    }\n                    write(\") exports[n] = m[n];\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                    writeLine();\n                    write(exportFunctionForFile + \"(exports);\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                    return exportStarFunction;\n                }\n                function writeExportedName(node) {\n                    // do not record default exports\n                    // they are local to module and never overwritten (explicitly skipped) by star export\n                    if (node.kind !== 69 /* Identifier */ && node.flags & 1024 /* Default */) {\n                        return;\n                    }\n                    if (started) {\n                        write(\",\");\n                    }\n                    else {\n                        started = true;\n                    }\n                    writeLine();\n                    write(\"'\");\n                    if (node.kind === 69 /* Identifier */) {\n                        emitNodeWithCommentsAndWithoutSourcemap(node);\n                    }\n                    else {\n                        emitDeclarationName(node);\n                    }\n                    write(\"': true\");\n                }\n            }\n            function processTopLevelVariableAndFunctionDeclarations(node) {\n                // per ES6 spec:\n                // 15.2.1.16.4 ModuleDeclarationInstantiation() Concrete Method\n                // - var declarations are initialized to undefined - 14.a.ii\n                // - function/generator declarations are instantiated - 16.a.iv\n                // this means that after module is instantiated but before its evaluation\n                // exported functions are already accessible at import sites\n                // in theory we should hoist only exported functions and its dependencies\n                // in practice to simplify things we'll hoist all source level functions and variable declaration\n                // including variables declarations for module and class declarations\n                var hoistedVars;\n                var hoistedFunctionDeclarations;\n                var exportedDeclarations;\n                visit(node);\n                if (hoistedVars) {\n                    writeLine();\n                    write(\"var \");\n                    var seen = {};\n                    for (var i = 0; i < hoistedVars.length; ++i) {\n                        var local = hoistedVars[i];\n                        var name_26 = local.kind === 69 /* Identifier */\n                            ? local\n                            : local.name;\n                        if (name_26) {\n                            // do not emit duplicate entries (in case of declaration merging) in the list of hoisted variables\n                            var text = ts.unescapeIdentifier(name_26.text);\n                            if (ts.hasProperty(seen, text)) {\n                                continue;\n                            }\n                            else {\n                                seen[text] = text;\n                            }\n                        }\n                        if (i !== 0) {\n                            write(\", \");\n                        }\n                        if (local.kind === 214 /* ClassDeclaration */ || local.kind === 218 /* ModuleDeclaration */ || local.kind === 217 /* EnumDeclaration */) {\n                            emitDeclarationName(local);\n                        }\n                        else {\n                            emit(local);\n                        }\n                        var flags = ts.getCombinedNodeFlags(local.kind === 69 /* Identifier */ ? local.parent : local);\n                        if (flags & 1 /* Export */) {\n                            if (!exportedDeclarations) {\n                                exportedDeclarations = [];\n                            }\n                            exportedDeclarations.push(local);\n                        }\n                    }\n                    write(\";\");\n                }\n                if (hoistedFunctionDeclarations) {\n                    for (var _a = 0; _a < hoistedFunctionDeclarations.length; _a++) {\n                        var f = hoistedFunctionDeclarations[_a];\n                        writeLine();\n                        emit(f);\n                        if (f.flags & 1 /* Export */) {\n                            if (!exportedDeclarations) {\n                                exportedDeclarations = [];\n                            }\n                            exportedDeclarations.push(f);\n                        }\n                    }\n                }\n                return exportedDeclarations;\n                function visit(node) {\n                    if (node.flags & 2 /* Ambient */) {\n                        return;\n                    }\n                    if (node.kind === 213 /* FunctionDeclaration */) {\n                        if (!hoistedFunctionDeclarations) {\n                            hoistedFunctionDeclarations = [];\n                        }\n                        hoistedFunctionDeclarations.push(node);\n                        return;\n                    }\n                    if (node.kind === 214 /* ClassDeclaration */) {\n                        if (!hoistedVars) {\n                            hoistedVars = [];\n                        }\n                        hoistedVars.push(node);\n                        return;\n                    }\n                    if (node.kind === 217 /* EnumDeclaration */) {\n                        if (shouldEmitEnumDeclaration(node)) {\n                            if (!hoistedVars) {\n                                hoistedVars = [];\n                            }\n                            hoistedVars.push(node);\n                        }\n                        return;\n                    }\n                    if (node.kind === 218 /* ModuleDeclaration */) {\n                        if (shouldEmitModuleDeclaration(node)) {\n                            if (!hoistedVars) {\n                                hoistedVars = [];\n                            }\n                            hoistedVars.push(node);\n                        }\n                        return;\n                    }\n                    if (node.kind === 211 /* VariableDeclaration */ || node.kind === 163 /* BindingElement */) {\n                        if (shouldHoistVariable(node, /*checkIfSourceFileLevelDecl*/ false)) {\n                            var name_27 = node.name;\n                            if (name_27.kind === 69 /* Identifier */) {\n                                if (!hoistedVars) {\n                                    hoistedVars = [];\n                                }\n                                hoistedVars.push(name_27);\n                            }\n                            else {\n                                ts.forEachChild(name_27, visit);\n                            }\n                        }\n                        return;\n                    }\n                    if (ts.isInternalModuleImportEqualsDeclaration(node) && resolver.isValueAliasDeclaration(node)) {\n                        if (!hoistedVars) {\n                            hoistedVars = [];\n                        }\n                        hoistedVars.push(node.name);\n                        return;\n                    }\n                    if (ts.isBindingPattern(node)) {\n                        ts.forEach(node.elements, visit);\n                        return;\n                    }\n                    if (!ts.isDeclaration(node)) {\n                        ts.forEachChild(node, visit);\n                    }\n                }\n            }\n            function shouldHoistVariable(node, checkIfSourceFileLevelDecl) {\n                if (checkIfSourceFileLevelDecl && !shouldHoistDeclarationInSystemJsModule(node)) {\n                    return false;\n                }\n                // hoist variable if\n                // - it is not block scoped\n                // - it is top level block scoped\n                // if block scoped variables are nested in some another block then\n                // no other functions can use them except ones that are defined at least in the same block\n                return (ts.getCombinedNodeFlags(node) & 49152 /* BlockScoped */) === 0 ||\n                    ts.getEnclosingBlockScopeContainer(node).kind === 248 /* SourceFile */;\n            }\n            function isCurrentFileSystemExternalModule() {\n                return modulekind === 4 /* System */ && ts.isExternalModule(currentSourceFile);\n            }\n            function emitSystemModuleBody(node, dependencyGroups, startIndex) {\n                // shape of the body in system modules:\n                // function (exports) {\n                //     <list of local aliases for imports>\n                //     <hoisted function declarations>\n                //     <hoisted variable declarations>\n                //     return {\n                //         setters: [\n                //             <list of setter function for imports>\n                //         ],\n                //         execute: function() {\n                //             <module statements>\n                //         }\n                //     }\n                //     <temp declarations>\n                // }\n                // I.e:\n                // import {x} from 'file1'\n                // var y = 1;\n                // export function foo() { return y + x(); }\n                // console.log(y);\n                // will be transformed to\n                // function(exports) {\n                //     var file1; // local alias\n                //     var y;\n                //     function foo() { return y + file1.x(); }\n                //     exports(\"foo\", foo);\n                //     return {\n                //         setters: [\n                //             function(v) { file1 = v }\n                //         ],\n                //         execute(): function() {\n                //             y = 1;\n                //             console.log(y);\n                //         }\n                //     };\n                // }\n                emitVariableDeclarationsForImports();\n                writeLine();\n                var exportedDeclarations = processTopLevelVariableAndFunctionDeclarations(node);\n                var exportStarFunction = emitLocalStorageForExportedNamesIfNecessary(exportedDeclarations);\n                writeLine();\n                write(\"return {\");\n                increaseIndent();\n                writeLine();\n                emitSetters(exportStarFunction, dependencyGroups);\n                writeLine();\n                emitExecute(node, startIndex);\n                decreaseIndent();\n                writeLine();\n                write(\"}\"); // return\n                emitTempDeclarations(/*newLine*/ true);\n            }\n            function emitSetters(exportStarFunction, dependencyGroups) {\n                write(\"setters:[\");\n                for (var i = 0; i < dependencyGroups.length; ++i) {\n                    if (i !== 0) {\n                        write(\",\");\n                    }\n                    writeLine();\n                    increaseIndent();\n                    var group = dependencyGroups[i];\n                    // derive a unique name for parameter from the first named entry in the group\n                    var parameterName = makeUniqueName(ts.forEach(group, getLocalNameForExternalImport) || \"\");\n                    write(\"function (\" + parameterName + \") {\");\n                    increaseIndent();\n                    for (var _a = 0; _a < group.length; _a++) {\n                        var entry = group[_a];\n                        var importVariableName = getLocalNameForExternalImport(entry) || \"\";\n                        switch (entry.kind) {\n                            case 222 /* ImportDeclaration */:\n                                if (!entry.importClause) {\n                                    // 'import \"...\"' case\n                                    // module is imported only for side-effects, no emit required\n                                    break;\n                                }\n                            // fall-through\n                            case 221 /* ImportEqualsDeclaration */:\n                                ts.Debug.assert(importVariableName !== \"\");\n                                writeLine();\n                                // save import into the local\n                                write(importVariableName + \" = \" + parameterName + \";\");\n                                writeLine();\n                                break;\n                            case 228 /* ExportDeclaration */:\n                                ts.Debug.assert(importVariableName !== \"\");\n                                if (entry.exportClause) {\n                                    // export {a, b as c} from 'foo'\n                                    // emit as:\n                                    // exports_({\n                                    //    \"a\": _[\"a\"],\n                                    //    \"c\": _[\"b\"]\n                                    // });\n                                    writeLine();\n                                    write(exportFunctionForFile + \"({\");\n                                    writeLine();\n                                    increaseIndent();\n                                    for (var i_2 = 0, len = entry.exportClause.elements.length; i_2 < len; ++i_2) {\n                                        if (i_2 !== 0) {\n                                            write(\",\");\n                                            writeLine();\n                                        }\n                                        var e = entry.exportClause.elements[i_2];\n                                        write(\"\\\"\");\n                                        emitNodeWithCommentsAndWithoutSourcemap(e.name);\n                                        write(\"\\\": \" + parameterName + \"[\\\"\");\n                                        emitNodeWithCommentsAndWithoutSourcemap(e.propertyName || e.name);\n                                        write(\"\\\"]\");\n                                    }\n                                    decreaseIndent();\n                                    writeLine();\n                                    write(\"});\");\n                                }\n                                else {\n                                    writeLine();\n                                    // export * from 'foo'\n                                    // emit as:\n                                    // exportStar(_foo);\n                                    write(exportStarFunction + \"(\" + parameterName + \");\");\n                                }\n                                writeLine();\n                                break;\n                        }\n                    }\n                    decreaseIndent();\n                    write(\"}\");\n                    decreaseIndent();\n                }\n                write(\"],\");\n            }\n            function emitExecute(node, startIndex) {\n                write(\"execute: function() {\");\n                increaseIndent();\n                writeLine();\n                for (var i = startIndex; i < node.statements.length; ++i) {\n                    var statement = node.statements[i];\n                    switch (statement.kind) {\n                        // - function declarations are not emitted because they were already hoisted\n                        // - import declarations are not emitted since they are already handled in setters\n                        // - export declarations with module specifiers are not emitted since they were already written in setters\n                        // - export declarations without module specifiers are emitted preserving the order\n                        case 213 /* FunctionDeclaration */:\n                        case 222 /* ImportDeclaration */:\n                            continue;\n                        case 228 /* ExportDeclaration */:\n                            if (!statement.moduleSpecifier) {\n                                for (var _a = 0, _b = statement.exportClause.elements; _a < _b.length; _a++) {\n                                    var element = _b[_a];\n                                    // write call to exporter function for every export specifier in exports list\n                                    emitExportSpecifierInSystemModule(element);\n                                }\n                            }\n                            continue;\n                        case 221 /* ImportEqualsDeclaration */:\n                            if (!ts.isInternalModuleImportEqualsDeclaration(statement)) {\n                                // - import equals declarations that import external modules are not emitted\n                                continue;\n                            }\n                        // fall-though for import declarations that import internal modules\n                        default:\n                            writeLine();\n                            emit(statement);\n                    }\n                }\n                decreaseIndent();\n                writeLine();\n                write(\"}\"); // execute\n            }\n            function emitSystemModule(node) {\n                collectExternalModuleInfo(node);\n                // System modules has the following shape\n                // System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n                // 'exports' here is a function 'exports<T>(name: string, value: T): T' that is used to publish exported values.\n                // 'exports' returns its 'value' argument so in most cases expressions\n                // that mutate exported values can be rewritten as:\n                // expr -> exports('name', expr).\n                // The only exception in this rule is postfix unary operators,\n                // see comment to 'emitPostfixUnaryExpression' for more details\n                ts.Debug.assert(!exportFunctionForFile);\n                // make sure that  name of 'exports' function does not conflict with existing identifiers\n                exportFunctionForFile = makeUniqueName(\"exports\");\n                writeLine();\n                write(\"System.register(\");\n                if (node.moduleName) {\n                    write(\"\\\"\" + node.moduleName + \"\\\", \");\n                }\n                write(\"[\");\n                var groupIndices = {};\n                var dependencyGroups = [];\n                for (var i = 0; i < externalImports.length; ++i) {\n                    var text = getExternalModuleNameText(externalImports[i]);\n                    if (ts.hasProperty(groupIndices, text)) {\n                        // deduplicate/group entries in dependency list by the dependency name\n                        var groupIndex = groupIndices[text];\n                        dependencyGroups[groupIndex].push(externalImports[i]);\n                        continue;\n                    }\n                    else {\n                        groupIndices[text] = dependencyGroups.length;\n                        dependencyGroups.push([externalImports[i]]);\n                    }\n                    if (i !== 0) {\n                        write(\", \");\n                    }\n                    write(text);\n                }\n                write(\"], function(\" + exportFunctionForFile + \") {\");\n                writeLine();\n                increaseIndent();\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ true);\n                emitEmitHelpers(node);\n                emitCaptureThisForNodeIfNecessary(node);\n                emitSystemModuleBody(node, dependencyGroups, startIndex);\n                decreaseIndent();\n                writeLine();\n                write(\"});\");\n            }\n            function getAMDDependencyNames(node, includeNonAmdDependencies) {\n                // names of modules with corresponding parameter in the factory function\n                var aliasedModuleNames = [];\n                // names of modules with no corresponding parameters in factory function\n                var unaliasedModuleNames = [];\n                var importAliasNames = []; // names of the parameters in the factory function; these\n                // parameters need to match the indexes of the corresponding\n                // module names in aliasedModuleNames.\n                // Fill in amd-dependency tags\n                for (var _a = 0, _b = node.amdDependencies; _a < _b.length; _a++) {\n                    var amdDependency = _b[_a];\n                    if (amdDependency.name) {\n                        aliasedModuleNames.push(\"\\\"\" + amdDependency.path + \"\\\"\");\n                        importAliasNames.push(amdDependency.name);\n                    }\n                    else {\n                        unaliasedModuleNames.push(\"\\\"\" + amdDependency.path + \"\\\"\");\n                    }\n                }\n                for (var _c = 0; _c < externalImports.length; _c++) {\n                    var importNode = externalImports[_c];\n                    // Find the name of the external module\n                    var externalModuleName = getExternalModuleNameText(importNode);\n                    // Find the name of the module alias, if there is one\n                    var importAliasName = getLocalNameForExternalImport(importNode);\n                    if (includeNonAmdDependencies && importAliasName) {\n                        aliasedModuleNames.push(externalModuleName);\n                        importAliasNames.push(importAliasName);\n                    }\n                    else {\n                        unaliasedModuleNames.push(externalModuleName);\n                    }\n                }\n                return { aliasedModuleNames: aliasedModuleNames, unaliasedModuleNames: unaliasedModuleNames, importAliasNames: importAliasNames };\n            }\n            function emitAMDDependencies(node, includeNonAmdDependencies) {\n                // An AMD define function has the following shape:\n                //     define(id?, dependencies?, factory);\n                //\n                // This has the shape of\n                //     define(name, [\"module1\", \"module2\"], function (module1Alias) {\n                // The location of the alias in the parameter list in the factory function needs to\n                // match the position of the module name in the dependency list.\n                //\n                // To ensure this is true in cases of modules with no aliases, e.g.:\n                // `import \"module\"` or `<amd-dependency path= \"a.css\" />`\n                // we need to add modules without alias names to the end of the dependencies list\n                var dependencyNames = getAMDDependencyNames(node, includeNonAmdDependencies);\n                emitAMDDependencyList(dependencyNames);\n                write(\", \");\n                emitAMDFactoryHeader(dependencyNames);\n            }\n            function emitAMDDependencyList(_a) {\n                var aliasedModuleNames = _a.aliasedModuleNames, unaliasedModuleNames = _a.unaliasedModuleNames;\n                write(\"[\\\"require\\\", \\\"exports\\\"\");\n                if (aliasedModuleNames.length) {\n                    write(\", \");\n                    write(aliasedModuleNames.join(\", \"));\n                }\n                if (unaliasedModuleNames.length) {\n                    write(\", \");\n                    write(unaliasedModuleNames.join(\", \"));\n                }\n                write(\"]\");\n            }\n            function emitAMDFactoryHeader(_a) {\n                var importAliasNames = _a.importAliasNames;\n                write(\"function (require, exports\");\n                if (importAliasNames.length) {\n                    write(\", \");\n                    write(importAliasNames.join(\", \"));\n                }\n                write(\") {\");\n            }\n            function emitAMDModule(node) {\n                emitEmitHelpers(node);\n                collectExternalModuleInfo(node);\n                writeLine();\n                write(\"define(\");\n                if (node.moduleName) {\n                    write(\"\\\"\" + node.moduleName + \"\\\", \");\n                }\n                emitAMDDependencies(node, /*includeNonAmdDependencies*/ true);\n                increaseIndent();\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ true);\n                emitExportStarHelper();\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                emitTempDeclarations(/*newLine*/ true);\n                emitExportEquals(/*emitAsReturn*/ true);\n                decreaseIndent();\n                writeLine();\n                write(\"});\");\n            }\n            function emitCommonJSModule(node) {\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ false);\n                emitEmitHelpers(node);\n                collectExternalModuleInfo(node);\n                emitExportStarHelper();\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                emitTempDeclarations(/*newLine*/ true);\n                emitExportEquals(/*emitAsReturn*/ false);\n            }\n            function emitUMDModule(node) {\n                emitEmitHelpers(node);\n                collectExternalModuleInfo(node);\n                var dependencyNames = getAMDDependencyNames(node, /*includeNonAmdDependencies*/ false);\n                // Module is detected first to support Browserify users that load into a browser with an AMD loader\n                writeLines(\"(function (factory) {\\n    if (typeof module === 'object' && typeof module.exports === 'object') {\\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\\n    }\\n    else if (typeof define === 'function' && define.amd) {\\n        define(\");\n                emitAMDDependencyList(dependencyNames);\n                write(\", factory);\");\n                writeLines(\"    }\\n})(\");\n                emitAMDFactoryHeader(dependencyNames);\n                increaseIndent();\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ true);\n                emitExportStarHelper();\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                emitTempDeclarations(/*newLine*/ true);\n                emitExportEquals(/*emitAsReturn*/ true);\n                decreaseIndent();\n                writeLine();\n                write(\"});\");\n            }\n            function emitES6Module(node) {\n                externalImports = undefined;\n                exportSpecifiers = undefined;\n                exportEquals = undefined;\n                hasExportStars = false;\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ false);\n                emitEmitHelpers(node);\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                emitTempDeclarations(/*newLine*/ true);\n                // Emit exportDefault if it exists will happen as part\n                // or normal statement emit.\n            }\n            function emitExportEquals(emitAsReturn) {\n                if (exportEquals && resolver.isValueAliasDeclaration(exportEquals)) {\n                    writeLine();\n                    emitStart(exportEquals);\n                    write(emitAsReturn ? \"return \" : \"module.exports = \");\n                    emit(exportEquals.expression);\n                    write(\";\");\n                    emitEnd(exportEquals);\n                }\n            }\n            function emitJsxElement(node) {\n                switch (compilerOptions.jsx) {\n                    case 2 /* React */:\n                        jsxEmitReact(node);\n                        break;\n                    case 1 /* Preserve */:\n                    // Fall back to preserve if None was specified (we'll error earlier)\n                    default:\n                        jsxEmitPreserve(node);\n                        break;\n                }\n            }\n            function trimReactWhitespaceAndApplyEntities(node) {\n                var result = undefined;\n                var text = ts.getTextOfNode(node, /*includeTrivia*/ true);\n                var firstNonWhitespace = 0;\n                var lastNonWhitespace = -1;\n                // JSX trims whitespace at the end and beginning of lines, except that the\n                // start/end of a tag is considered a start/end of a line only if that line is\n                // on the same line as the closing tag. See examples in tests/cases/conformance/jsx/tsxReactEmitWhitespace.tsx\n                for (var i = 0; i < text.length; i++) {\n                    var c = text.charCodeAt(i);\n                    if (ts.isLineBreak(c)) {\n                        if (firstNonWhitespace !== -1 && (lastNonWhitespace - firstNonWhitespace + 1 > 0)) {\n                            var part = text.substr(firstNonWhitespace, lastNonWhitespace - firstNonWhitespace + 1);\n                            result = (result ? result + \"\\\" + ' ' + \\\"\" : \"\") + ts.escapeString(part);\n                        }\n                        firstNonWhitespace = -1;\n                    }\n                    else if (!ts.isWhiteSpace(c)) {\n                        lastNonWhitespace = i;\n                        if (firstNonWhitespace === -1) {\n                            firstNonWhitespace = i;\n                        }\n                    }\n                }\n                if (firstNonWhitespace !== -1) {\n                    var part = text.substr(firstNonWhitespace);\n                    result = (result ? result + \"\\\" + ' ' + \\\"\" : \"\") + ts.escapeString(part);\n                }\n                if (result) {\n                    // Replace entities like &nbsp;\n                    result = result.replace(/&(\\w+);/g, function (s, m) {\n                        if (entities[m] !== undefined) {\n                            return String.fromCharCode(entities[m]);\n                        }\n                        else {\n                            return s;\n                        }\n                    });\n                }\n                return result;\n            }\n            function getTextToEmit(node) {\n                switch (compilerOptions.jsx) {\n                    case 2 /* React */:\n                        var text = trimReactWhitespaceAndApplyEntities(node);\n                        if (text === undefined || text.length === 0) {\n                            return undefined;\n                        }\n                        else {\n                            return text;\n                        }\n                    case 1 /* Preserve */:\n                    default:\n                        return ts.getTextOfNode(node, /*includeTrivia*/ true);\n                }\n            }\n            function emitJsxText(node) {\n                switch (compilerOptions.jsx) {\n                    case 2 /* React */:\n                        write(\"\\\"\");\n                        write(trimReactWhitespaceAndApplyEntities(node));\n                        write(\"\\\"\");\n                        break;\n                    case 1 /* Preserve */:\n                    default:\n                        writer.writeLiteral(ts.getTextOfNode(node, /*includeTrivia*/ true));\n                        break;\n                }\n            }\n            function emitJsxExpression(node) {\n                if (node.expression) {\n                    switch (compilerOptions.jsx) {\n                        case 1 /* Preserve */:\n                        default:\n                            write(\"{\");\n                            emit(node.expression);\n                            write(\"}\");\n                            break;\n                        case 2 /* React */:\n                            emit(node.expression);\n                            break;\n                    }\n                }\n            }\n            function emitDirectivePrologues(statements, startWithNewLine) {\n                for (var i = 0; i < statements.length; ++i) {\n                    if (ts.isPrologueDirective(statements[i])) {\n                        if (startWithNewLine || i > 0) {\n                            writeLine();\n                        }\n                        emit(statements[i]);\n                    }\n                    else {\n                        // return index of the first non prologue directive\n                        return i;\n                    }\n                }\n                return statements.length;\n            }\n            function writeLines(text) {\n                var lines = text.split(/\\r\\n|\\r|\\n/g);\n                for (var i = 0; i < lines.length; ++i) {\n                    var line = lines[i];\n                    if (line.length) {\n                        writeLine();\n                        write(line);\n                    }\n                }\n            }\n            function emitEmitHelpers(node) {\n                // Only emit helpers if the user did not say otherwise.\n                if (!compilerOptions.noEmitHelpers) {\n                    // Only Emit __extends function when target ES5.\n                    // For target ES6 and above, we can emit classDeclaration as is.\n                    if ((languageVersion < 2 /* ES6 */) && (!extendsEmitted && resolver.getNodeCheckFlags(node) & 8 /* EmitExtends */)) {\n                        writeLines(extendsHelper);\n                        extendsEmitted = true;\n                    }\n                    if (!decorateEmitted && resolver.getNodeCheckFlags(node) & 16 /* EmitDecorate */) {\n                        writeLines(decorateHelper);\n                        if (compilerOptions.emitDecoratorMetadata) {\n                            writeLines(metadataHelper);\n                        }\n                        decorateEmitted = true;\n                    }\n                    if (!paramEmitted && resolver.getNodeCheckFlags(node) & 32 /* EmitParam */) {\n                        writeLines(paramHelper);\n                        paramEmitted = true;\n                    }\n                    if (!awaiterEmitted && resolver.getNodeCheckFlags(node) & 64 /* EmitAwaiter */) {\n                        writeLines(awaiterHelper);\n                        awaiterEmitted = true;\n                    }\n                }\n            }\n            function emitSourceFileNode(node) {\n                // Start new file on new line\n                writeLine();\n                emitShebang();\n                emitDetachedComments(node);\n                if (ts.isExternalModule(node) || compilerOptions.isolatedModules) {\n                    var emitModule = moduleEmitDelegates[modulekind] || moduleEmitDelegates[1 /* CommonJS */];\n                    emitModule(node);\n                }\n                else {\n                    // emit prologue directives prior to __extends\n                    var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ false);\n                    externalImports = undefined;\n                    exportSpecifiers = undefined;\n                    exportEquals = undefined;\n                    hasExportStars = false;\n                    emitEmitHelpers(node);\n                    emitCaptureThisForNodeIfNecessary(node);\n                    emitLinesStartingAt(node.statements, startIndex);\n                    emitTempDeclarations(/*newLine*/ true);\n                }\n                emitLeadingComments(node.endOfFileToken);\n            }\n            function emitNodeWithCommentsAndWithoutSourcemap(node) {\n                emitNodeConsideringCommentsOption(node, emitNodeWithoutSourceMap);\n            }\n            function emitNodeConsideringCommentsOption(node, emitNodeConsideringSourcemap) {\n                if (node) {\n                    if (node.flags & 2 /* Ambient */) {\n                        return emitCommentsOnNotEmittedNode(node);\n                    }\n                    if (isSpecializedCommentHandling(node)) {\n                        // This is the node that will handle its own comments and sourcemap\n                        return emitNodeWithoutSourceMap(node);\n                    }\n                    var emitComments_1 = shouldEmitLeadingAndTrailingComments(node);\n                    if (emitComments_1) {\n                        emitLeadingComments(node);\n                    }\n                    emitNodeConsideringSourcemap(node);\n                    if (emitComments_1) {\n                        emitTrailingComments(node);\n                    }\n                }\n            }\n            function emitNodeWithoutSourceMap(node) {\n                if (node) {\n                    emitJavaScriptWorker(node);\n                }\n            }\n            function isSpecializedCommentHandling(node) {\n                switch (node.kind) {\n                    // All of these entities are emitted in a specialized fashion.  As such, we allow\n                    // the specialized methods for each to handle the comments on the nodes.\n                    case 215 /* InterfaceDeclaration */:\n                    case 213 /* FunctionDeclaration */:\n                    case 222 /* ImportDeclaration */:\n                    case 221 /* ImportEqualsDeclaration */:\n                    case 216 /* TypeAliasDeclaration */:\n                    case 227 /* ExportAssignment */:\n                        return true;\n                }\n            }\n            function shouldEmitLeadingAndTrailingComments(node) {\n                switch (node.kind) {\n                    case 193 /* VariableStatement */:\n                        return shouldEmitLeadingAndTrailingCommentsForVariableStatement(node);\n                    case 218 /* ModuleDeclaration */:\n                        // Only emit the leading/trailing comments for a module if we're actually\n                        // emitting the module as well.\n                        return shouldEmitModuleDeclaration(node);\n                    case 217 /* EnumDeclaration */:\n                        // Only emit the leading/trailing comments for an enum if we're actually\n                        // emitting the module as well.\n                        return shouldEmitEnumDeclaration(node);\n                }\n                // If the node is emitted in specialized fashion, dont emit comments as this node will handle\n                // emitting comments when emitting itself\n                ts.Debug.assert(!isSpecializedCommentHandling(node));\n                // If this is the expression body of an arrow function that we're down-leveling,\n                // then we don't want to emit comments when we emit the body.  It will have already\n                // been taken care of when we emitted the 'return' statement for the function\n                // expression body.\n                if (node.kind !== 192 /* Block */ &&\n                    node.parent &&\n                    node.parent.kind === 174 /* ArrowFunction */ &&\n                    node.parent.body === node &&\n                    compilerOptions.target <= 1 /* ES5 */) {\n                    return false;\n                }\n                // Emit comments for everything else.\n                return true;\n            }\n            function emitJavaScriptWorker(node) {\n                // Check if the node can be emitted regardless of the ScriptTarget\n                switch (node.kind) {\n                    case 69 /* Identifier */:\n                        return emitIdentifier(node);\n                    case 138 /* Parameter */:\n                        return emitParameter(node);\n                    case 143 /* MethodDeclaration */:\n                    case 142 /* MethodSignature */:\n                        return emitMethod(node);\n                    case 145 /* GetAccessor */:\n                    case 146 /* SetAccessor */:\n                        return emitAccessor(node);\n                    case 97 /* ThisKeyword */:\n                        return emitThis(node);\n                    case 95 /* SuperKeyword */:\n                        return emitSuper(node);\n                    case 93 /* NullKeyword */:\n                        return write(\"null\");\n                    case 99 /* TrueKeyword */:\n                        return write(\"true\");\n                    case 84 /* FalseKeyword */:\n                        return write(\"false\");\n                    case 8 /* NumericLiteral */:\n                    case 9 /* StringLiteral */:\n                    case 10 /* RegularExpressionLiteral */:\n                    case 11 /* NoSubstitutionTemplateLiteral */:\n                    case 12 /* TemplateHead */:\n                    case 13 /* TemplateMiddle */:\n                    case 14 /* TemplateTail */:\n                        return emitLiteral(node);\n                    case 183 /* TemplateExpression */:\n                        return emitTemplateExpression(node);\n                    case 190 /* TemplateSpan */:\n                        return emitTemplateSpan(node);\n                    case 233 /* JsxElement */:\n                    case 234 /* JsxSelfClosingElement */:\n                        return emitJsxElement(node);\n                    case 236 /* JsxText */:\n                        return emitJsxText(node);\n                    case 240 /* JsxExpression */:\n                        return emitJsxExpression(node);\n                    case 135 /* QualifiedName */:\n                        return emitQualifiedName(node);\n                    case 161 /* ObjectBindingPattern */:\n                        return emitObjectBindingPattern(node);\n                    case 162 /* ArrayBindingPattern */:\n                        return emitArrayBindingPattern(node);\n                    case 163 /* BindingElement */:\n                        return emitBindingElement(node);\n                    case 164 /* ArrayLiteralExpression */:\n                        return emitArrayLiteral(node);\n                    case 165 /* ObjectLiteralExpression */:\n                        return emitObjectLiteral(node);\n                    case 245 /* PropertyAssignment */:\n                        return emitPropertyAssignment(node);\n                    case 246 /* ShorthandPropertyAssignment */:\n                        return emitShorthandPropertyAssignment(node);\n                    case 136 /* ComputedPropertyName */:\n                        return emitComputedPropertyName(node);\n                    case 166 /* PropertyAccessExpression */:\n                        return emitPropertyAccess(node);\n                    case 167 /* ElementAccessExpression */:\n                        return emitIndexedAccess(node);\n                    case 168 /* CallExpression */:\n                        return emitCallExpression(node);\n                    case 169 /* NewExpression */:\n                        return emitNewExpression(node);\n                    case 170 /* TaggedTemplateExpression */:\n                        return emitTaggedTemplateExpression(node);\n                    case 171 /* TypeAssertionExpression */:\n                        return emit(node.expression);\n                    case 189 /* AsExpression */:\n                        return emit(node.expression);\n                    case 172 /* ParenthesizedExpression */:\n                        return emitParenExpression(node);\n                    case 213 /* FunctionDeclaration */:\n                    case 173 /* FunctionExpression */:\n                    case 174 /* ArrowFunction */:\n                        return emitFunctionDeclaration(node);\n                    case 175 /* DeleteExpression */:\n                        return emitDeleteExpression(node);\n                    case 176 /* TypeOfExpression */:\n                        return emitTypeOfExpression(node);\n                    case 177 /* VoidExpression */:\n                        return emitVoidExpression(node);\n                    case 178 /* AwaitExpression */:\n                        return emitAwaitExpression(node);\n                    case 179 /* PrefixUnaryExpression */:\n                        return emitPrefixUnaryExpression(node);\n                    case 180 /* PostfixUnaryExpression */:\n                        return emitPostfixUnaryExpression(node);\n                    case 181 /* BinaryExpression */:\n                        return emitBinaryExpression(node);\n                    case 182 /* ConditionalExpression */:\n                        return emitConditionalExpression(node);\n                    case 185 /* SpreadElementExpression */:\n                        return emitSpreadElementExpression(node);\n                    case 184 /* YieldExpression */:\n                        return emitYieldExpression(node);\n                    case 187 /* OmittedExpression */:\n                        return;\n                    case 192 /* Block */:\n                    case 219 /* ModuleBlock */:\n                        return emitBlock(node);\n                    case 193 /* VariableStatement */:\n                        return emitVariableStatement(node);\n                    case 194 /* EmptyStatement */:\n                        return write(\";\");\n                    case 195 /* ExpressionStatement */:\n                        return emitExpressionStatement(node);\n                    case 196 /* IfStatement */:\n                        return emitIfStatement(node);\n                    case 197 /* DoStatement */:\n                        return emitDoStatement(node);\n                    case 198 /* WhileStatement */:\n                        return emitWhileStatement(node);\n                    case 199 /* ForStatement */:\n                        return emitForStatement(node);\n                    case 201 /* ForOfStatement */:\n                    case 200 /* ForInStatement */:\n                        return emitForInOrForOfStatement(node);\n                    case 202 /* ContinueStatement */:\n                    case 203 /* BreakStatement */:\n                        return emitBreakOrContinueStatement(node);\n                    case 204 /* ReturnStatement */:\n                        return emitReturnStatement(node);\n                    case 205 /* WithStatement */:\n                        return emitWithStatement(node);\n                    case 206 /* SwitchStatement */:\n                        return emitSwitchStatement(node);\n                    case 241 /* CaseClause */:\n                    case 242 /* DefaultClause */:\n                        return emitCaseOrDefaultClause(node);\n                    case 207 /* LabeledStatement */:\n                        return emitLabelledStatement(node);\n                    case 208 /* ThrowStatement */:\n                        return emitThrowStatement(node);\n                    case 209 /* TryStatement */:\n                        return emitTryStatement(node);\n                    case 244 /* CatchClause */:\n                        return emitCatchClause(node);\n                    case 210 /* DebuggerStatement */:\n                        return emitDebuggerStatement(node);\n                    case 211 /* VariableDeclaration */:\n                        return emitVariableDeclaration(node);\n                    case 186 /* ClassExpression */:\n                        return emitClassExpression(node);\n                    case 214 /* ClassDeclaration */:\n                        return emitClassDeclaration(node);\n                    case 215 /* InterfaceDeclaration */:\n                        return emitInterfaceDeclaration(node);\n                    case 217 /* EnumDeclaration */:\n                        return emitEnumDeclaration(node);\n                    case 247 /* EnumMember */:\n                        return emitEnumMember(node);\n                    case 218 /* ModuleDeclaration */:\n                        return emitModuleDeclaration(node);\n                    case 222 /* ImportDeclaration */:\n                        return emitImportDeclaration(node);\n                    case 221 /* ImportEqualsDeclaration */:\n                        return emitImportEqualsDeclaration(node);\n                    case 228 /* ExportDeclaration */:\n                        return emitExportDeclaration(node);\n                    case 227 /* ExportAssignment */:\n                        return emitExportAssignment(node);\n                    case 248 /* SourceFile */:\n                        return emitSourceFileNode(node);\n                }\n            }\n            function hasDetachedComments(pos) {\n                return detachedCommentsInfo !== undefined && ts.lastOrUndefined(detachedCommentsInfo).nodePos === pos;\n            }\n            function getLeadingCommentsWithoutDetachedComments() {\n                // get the leading comments from detachedPos\n                var leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, ts.lastOrUndefined(detachedCommentsInfo).detachedCommentEndPos);\n                if (detachedCommentsInfo.length - 1) {\n                    detachedCommentsInfo.pop();\n                }\n                else {\n                    detachedCommentsInfo = undefined;\n                }\n                return leadingComments;\n            }\n            function isPinnedComments(comment) {\n                return currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */ &&\n                    currentSourceFile.text.charCodeAt(comment.pos + 2) === 33 /* exclamation */;\n            }\n            /**\n             * Determine if the given comment is a triple-slash\n             *\n             * @return true if the comment is a triple-slash comment else false\n             **/\n            function isTripleSlashComment(comment) {\n                // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text\n                // so that we don't end up computing comment string and doing match for all // comments\n                if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 47 /* slash */ &&\n                    comment.pos + 2 < comment.end &&\n                    currentSourceFile.text.charCodeAt(comment.pos + 2) === 47 /* slash */) {\n                    var textSubStr = currentSourceFile.text.substring(comment.pos, comment.end);\n                    return textSubStr.match(ts.fullTripleSlashReferencePathRegEx) ||\n                    textSubStr.match(ts.fullTripleSlashAMDReferencePathRegEx) ?\n                        true : false;\n                }\n                return false;\n            }\n            function getLeadingCommentsToEmit(node) {\n                // Emit the leading comments only if the parent's pos doesn't match because parent should take care of emitting these comments\n                if (node.parent) {\n                    if (node.parent.kind === 248 /* SourceFile */ || node.pos !== node.parent.pos) {\n                        if (hasDetachedComments(node.pos)) {\n                            // get comments without detached comments\n                            return getLeadingCommentsWithoutDetachedComments();\n                        }\n                        else {\n                            // get the leading comments from the node\n                            return ts.getLeadingCommentRangesOfNode(node, currentSourceFile);\n                        }\n                    }\n                }\n            }\n            function getTrailingCommentsToEmit(node) {\n                // Emit the trailing comments only if the parent's pos doesn't match because parent should take care of emitting these comments\n                if (node.parent) {\n                    if (node.parent.kind === 248 /* SourceFile */ || node.end !== node.parent.end) {\n                        return ts.getTrailingCommentRanges(currentSourceFile.text, node.end);\n                    }\n                }\n            }\n            /**\n             * Emit comments associated with node that will not be emitted into JS file\n             */\n            function emitCommentsOnNotEmittedNode(node) {\n                emitLeadingCommentsWorker(node, /*isEmittedNode:*/ false);\n            }\n            function emitLeadingComments(node) {\n                return emitLeadingCommentsWorker(node, /*isEmittedNode:*/ true);\n            }\n            function emitLeadingCommentsWorker(node, isEmittedNode) {\n                if (compilerOptions.removeComments) {\n                    return;\n                }\n                var leadingComments;\n                if (isEmittedNode) {\n                    leadingComments = getLeadingCommentsToEmit(node);\n                }\n                else {\n                    // If the node will not be emitted in JS, remove all the comments(normal, pinned and ///) associated with the node,\n                    // unless it is a triple slash comment at the top of the file.\n                    // For Example:\n                    //      /// <reference-path ...>\n                    //      declare var x;\n                    //      /// <reference-path ...>\n                    //      interface F {}\n                    //  The first /// will NOT be removed while the second one will be removed eventhough both node will not be emitted\n                    if (node.pos === 0) {\n                        leadingComments = ts.filter(getLeadingCommentsToEmit(node), isTripleSlashComment);\n                    }\n                }\n                ts.emitNewLineBeforeLeadingComments(currentSourceFile, writer, node, leadingComments);\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\n                ts.emitComments(currentSourceFile, writer, leadingComments, /*trailingSeparator:*/ true, newLine, writeComment);\n            }\n            function emitTrailingComments(node) {\n                if (compilerOptions.removeComments) {\n                    return;\n                }\n                // Emit the trailing comments only if the parent's end doesn't match\n                var trailingComments = getTrailingCommentsToEmit(node);\n                // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/\n                ts.emitComments(currentSourceFile, writer, trailingComments, /*trailingSeparator*/ false, newLine, writeComment);\n            }\n            /**\n             * Emit trailing comments at the position. The term trailing comment is used here to describe following comment:\n             *      x, /comment1/ y\n             *        ^ => pos; the function will emit \"comment1\" in the emitJS\n             */\n            function emitTrailingCommentsOfPosition(pos) {\n                if (compilerOptions.removeComments) {\n                    return;\n                }\n                var trailingComments = ts.getTrailingCommentRanges(currentSourceFile.text, pos);\n                // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/\n                ts.emitComments(currentSourceFile, writer, trailingComments, /*trailingSeparator*/ true, newLine, writeComment);\n            }\n            function emitLeadingCommentsOfPositionWorker(pos) {\n                if (compilerOptions.removeComments) {\n                    return;\n                }\n                var leadingComments;\n                if (hasDetachedComments(pos)) {\n                    // get comments without detached comments\n                    leadingComments = getLeadingCommentsWithoutDetachedComments();\n                }\n                else {\n                    // get the leading comments from the node\n                    leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, pos);\n                }\n                ts.emitNewLineBeforeLeadingComments(currentSourceFile, writer, { pos: pos, end: pos }, leadingComments);\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\n                ts.emitComments(currentSourceFile, writer, leadingComments, /*trailingSeparator*/ true, newLine, writeComment);\n            }\n            function emitDetachedComments(node) {\n                var leadingComments;\n                if (compilerOptions.removeComments) {\n                    // removeComments is true, only reserve pinned comment at the top of file\n                    // For example:\n                    //      /*! Pinned Comment */\n                    //\n                    //      var x = 10;\n                    if (node.pos === 0) {\n                        leadingComments = ts.filter(ts.getLeadingCommentRanges(currentSourceFile.text, node.pos), isPinnedComments);\n                    }\n                }\n                else {\n                    // removeComments is false, just get detached as normal and bypass the process to filter comment\n                    leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, node.pos);\n                }\n                if (leadingComments) {\n                    var detachedComments = [];\n                    var lastComment;\n                    ts.forEach(leadingComments, function (comment) {\n                        if (lastComment) {\n                            var lastCommentLine = ts.getLineOfLocalPosition(currentSourceFile, lastComment.end);\n                            var commentLine = ts.getLineOfLocalPosition(currentSourceFile, comment.pos);\n                            if (commentLine >= lastCommentLine + 2) {\n                                // There was a blank line between the last comment and this comment.  This\n                                // comment is not part of the copyright comments.  Return what we have so\n                                // far.\n                                return detachedComments;\n                            }\n                        }\n                        detachedComments.push(comment);\n                        lastComment = comment;\n                    });\n                    if (detachedComments.length) {\n                        // All comments look like they could have been part of the copyright header.  Make\n                        // sure there is at least one blank line between it and the node.  If not, it's not\n                        // a copyright header.\n                        var lastCommentLine = ts.getLineOfLocalPosition(currentSourceFile, ts.lastOrUndefined(detachedComments).end);\n                        var nodeLine = ts.getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node.pos));\n                        if (nodeLine >= lastCommentLine + 2) {\n                            // Valid detachedComments\n                            ts.emitNewLineBeforeLeadingComments(currentSourceFile, writer, node, leadingComments);\n                            ts.emitComments(currentSourceFile, writer, detachedComments, /*trailingSeparator*/ true, newLine, writeComment);\n                            var currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: ts.lastOrUndefined(detachedComments).end };\n                            if (detachedCommentsInfo) {\n                                detachedCommentsInfo.push(currentDetachedCommentInfo);\n                            }\n                            else {\n                                detachedCommentsInfo = [currentDetachedCommentInfo];\n                            }\n                        }\n                    }\n                }\n            }\n            function emitShebang() {\n                var shebang = ts.getShebang(currentSourceFile.text);\n                if (shebang) {\n                    write(shebang);\n                }\n            }\n            var _a;\n        }\n        function emitFile(jsFilePath, sourceFile) {\n            emitJavaScript(jsFilePath, sourceFile);\n            if (compilerOptions.declaration) {\n                ts.writeDeclarationFile(jsFilePath, sourceFile, host, resolver, diagnostics);\n            }\n        }\n    }", "language": "javascript", "code": "function emitFiles(resolver, host, targetSourceFile) {\n        // emit output for the __extends helper function\n        var extendsHelper = \"\\nvar __extends = (this && this.__extends) || function (d, b) {\\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\\n    function __() { this.constructor = d; }\\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n};\";\n        // emit output for the __decorate helper function\n        var decorateHelper = \"\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\n};\";\n        // emit output for the __metadata helper function\n        var metadataHelper = \"\\nvar __metadata = (this && this.__metadata) || function (k, v) {\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.metadata === \\\"function\\\") return Reflect.metadata(k, v);\\n};\";\n        // emit output for the __param helper function\n        var paramHelper = \"\\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\\n    return function (target, key) { decorator(target, key, paramIndex); }\\n};\";\n        var awaiterHelper = \"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\\n    return new Promise(function (resolve, reject) {\\n        generator = generator.call(thisArg, _arguments);\\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\\n        function onfulfill(value) { try { step(\\\"next\\\", value); } catch (e) { reject(e); } }\\n        function onreject(value) { try { step(\\\"throw\\\", value); } catch (e) { reject(e); } }\\n        function step(verb, value) {\\n            var result = generator[verb](value);\\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\\n        }\\n        step(\\\"next\\\", void 0);\\n    });\\n};\";\n        var compilerOptions = host.getCompilerOptions();\n        var languageVersion = compilerOptions.target || 0 /* ES3 */;\n        var modulekind = compilerOptions.module ? compilerOptions.module : languageVersion === 2 /* ES6 */ ? 5 /* ES6 */ : 0 /* None */;\n        var sourceMapDataList = compilerOptions.sourceMap || compilerOptions.inlineSourceMap ? [] : undefined;\n        var diagnostics = [];\n        var newLine = host.getNewLine();\n        var jsxDesugaring = host.getCompilerOptions().jsx !== 1 /* Preserve */;\n        var shouldEmitJsx = function (s) { return (s.languageVariant === 1 /* JSX */ && !jsxDesugaring); };\n        if (targetSourceFile === undefined) {\n            ts.forEach(host.getSourceFiles(), function (sourceFile) {\n                if (ts.shouldEmitToOwnFile(sourceFile, compilerOptions)) {\n                    var jsFilePath = ts.getOwnEmitOutputFilePath(sourceFile, host, shouldEmitJsx(sourceFile) ? \".jsx\" : \".js\");\n                    emitFile(jsFilePath, sourceFile);\n                }\n            });\n            if (compilerOptions.outFile || compilerOptions.out) {\n                emitFile(compilerOptions.outFile || compilerOptions.out);\n            }\n        }\n        else {\n            // targetSourceFile is specified (e.g calling emitter from language service or calling getSemanticDiagnostic from language service)\n            if (ts.shouldEmitToOwnFile(targetSourceFile, compilerOptions)) {\n                var jsFilePath = ts.getOwnEmitOutputFilePath(targetSourceFile, host, shouldEmitJsx(targetSourceFile) ? \".jsx\" : \".js\");\n                emitFile(jsFilePath, targetSourceFile);\n            }\n            else if (!ts.isDeclarationFile(targetSourceFile) && (compilerOptions.outFile || compilerOptions.out)) {\n                emitFile(compilerOptions.outFile || compilerOptions.out);\n            }\n        }\n        // Sort and make the unique list of diagnostics\n        diagnostics = ts.sortAndDeduplicateDiagnostics(diagnostics);\n        return {\n            emitSkipped: false,\n            diagnostics: diagnostics,\n            sourceMaps: sourceMapDataList\n        };\n        function isUniqueLocalName(name, container) {\n            for (var node = container; ts.isNodeDescendentOf(node, container); node = node.nextContainer) {\n                if (node.locals && ts.hasProperty(node.locals, name)) {\n                    // We conservatively include alias symbols to cover cases where they're emitted as locals\n                    if (node.locals[name].flags & (107455 /* Value */ | 1048576 /* ExportValue */ | 8388608 /* Alias */)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        function emitJavaScript(jsFilePath, root) {\n            var writer = ts.createTextWriter(newLine);\n            var write = writer.write, writeTextOfNode = writer.writeTextOfNode, writeLine = writer.writeLine, increaseIndent = writer.increaseIndent, decreaseIndent = writer.decreaseIndent;\n            var currentSourceFile;\n            // name of an exporter function if file is a System external module\n            // System.register([...], function (<exporter>) {...})\n            // exporting in System modules looks like:\n            // export var x; ... x = 1\n            // =>\n            // var x;... exporter(\"x\", x = 1)\n            var exportFunctionForFile;\n            var generatedNameSet = {};\n            var nodeToGeneratedName = [];\n            var computedPropertyNamesToGeneratedNames;\n            var extendsEmitted = false;\n            var decorateEmitted = false;\n            var paramEmitted = false;\n            var awaiterEmitted = false;\n            var tempFlags = 0;\n            var tempVariables;\n            var tempParameters;\n            var externalImports;\n            var exportSpecifiers;\n            var exportEquals;\n            var hasExportStars;\n            /** Write emitted output to disk */\n            var writeEmittedFiles = writeJavaScriptFile;\n            var detachedCommentsInfo;\n            var writeComment = ts.writeCommentRange;\n            /** Emit a node */\n            var emit = emitNodeWithCommentsAndWithoutSourcemap;\n            /** Called just before starting emit of a node */\n            var emitStart = function (node) { };\n            /** Called once the emit of the node is done */\n            var emitEnd = function (node) { };\n            /** Emit the text for the given token that comes after startPos\n             * This by default writes the text provided with the given tokenKind\n             * but if optional emitFn callback is provided the text is emitted using the callback instead of default text\n             * @param tokenKind the kind of the token to search and emit\n             * @param startPos the position in the source to start searching for the token\n             * @param emitFn if given will be invoked to emit the text instead of actual token emit */\n            var emitToken = emitTokenText;\n            /** Called to before starting the lexical scopes as in function/class in the emitted code because of node\n             * @param scopeDeclaration node that starts the lexical scope\n             * @param scopeName Optional name of this scope instead of deducing one from the declaration node */\n            var scopeEmitStart = function (scopeDeclaration, scopeName) { };\n            /** Called after coming out of the scope */\n            var scopeEmitEnd = function () { };\n            /** Sourcemap data that will get encoded */\n            var sourceMapData;\n            /** If removeComments is true, no leading-comments needed to be emitted **/\n            var emitLeadingCommentsOfPosition = compilerOptions.removeComments ? function (pos) { } : emitLeadingCommentsOfPositionWorker;\n            var moduleEmitDelegates = (_a = {},\n                    _a[5 /* ES6 */] = emitES6Module,\n                    _a[2 /* AMD */] = emitAMDModule,\n                    _a[4 /* System */] = emitSystemModule,\n                    _a[3 /* UMD */] = emitUMDModule,\n                    _a[1 /* CommonJS */] = emitCommonJSModule,\n                    _a\n            );\n            if (compilerOptions.sourceMap || compilerOptions.inlineSourceMap) {\n                initializeEmitterWithSourceMaps();\n            }\n            if (root) {\n                // Do not call emit directly. It does not set the currentSourceFile.\n                emitSourceFile(root);\n            }\n            else {\n                ts.forEach(host.getSourceFiles(), function (sourceFile) {\n                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {\n                        emitSourceFile(sourceFile);\n                    }\n                });\n            }\n            writeLine();\n            writeEmittedFiles(writer.getText(), /*writeByteOrderMark*/ compilerOptions.emitBOM);\n            return;\n            function emitSourceFile(sourceFile) {\n                currentSourceFile = sourceFile;\n                exportFunctionForFile = undefined;\n                emit(sourceFile);\n            }\n            function isUniqueName(name) {\n                return !resolver.hasGlobalName(name) &&\n                    !ts.hasProperty(currentSourceFile.identifiers, name) &&\n                    !ts.hasProperty(generatedNameSet, name);\n            }\n            // Return the next available name in the pattern _a ... _z, _0, _1, ...\n            // TempFlags._i or TempFlags._n may be used to express a preference for that dedicated name.\n            // Note that names generated by makeTempVariableName and makeUniqueName will never conflict.\n            function makeTempVariableName(flags) {\n                if (flags && !(tempFlags & flags)) {\n                    var name_19 = flags === 268435456 /* _i */ ? \"_i\" : \"_n\";\n                    if (isUniqueName(name_19)) {\n                        tempFlags |= flags;\n                        return name_19;\n                    }\n                }\n                while (true) {\n                    var count = tempFlags & 268435455 /* CountMask */;\n                    tempFlags++;\n                    // Skip over 'i' and 'n'\n                    if (count !== 8 && count !== 13) {\n                        var name_20 = count < 26 ? \"_\" + String.fromCharCode(97 /* a */ + count) : \"_\" + (count - 26);\n                        if (isUniqueName(name_20)) {\n                            return name_20;\n                        }\n                    }\n                }\n            }\n            // Generate a name that is unique within the current file and doesn't conflict with any names\n            // in global scope. The name is formed by adding an '_n' suffix to the specified base name,\n            // where n is a positive integer. Note that names generated by makeTempVariableName and\n            // makeUniqueName are guaranteed to never conflict.\n            function makeUniqueName(baseName) {\n                // Find the first unique 'name_n', where n is a positive number\n                if (baseName.charCodeAt(baseName.length - 1) !== 95 /* _ */) {\n                    baseName += \"_\";\n                }\n                var i = 1;\n                while (true) {\n                    var generatedName = baseName + i;\n                    if (isUniqueName(generatedName)) {\n                        return generatedNameSet[generatedName] = generatedName;\n                    }\n                    i++;\n                }\n            }\n            function generateNameForModuleOrEnum(node) {\n                var name = node.name.text;\n                // Use module/enum name itself if it is unique, otherwise make a unique variation\n                return isUniqueLocalName(name, node) ? name : makeUniqueName(name);\n            }\n            function generateNameForImportOrExportDeclaration(node) {\n                var expr = ts.getExternalModuleName(node);\n                var baseName = expr.kind === 9 /* StringLiteral */ ?\n                    ts.escapeIdentifier(ts.makeIdentifierFromModuleName(expr.text)) : \"module\";\n                return makeUniqueName(baseName);\n            }\n            function generateNameForExportDefault() {\n                return makeUniqueName(\"default\");\n            }\n            function generateNameForClassExpression() {\n                return makeUniqueName(\"class\");\n            }\n            function generateNameForNode(node) {\n                switch (node.kind) {\n                    case 69 /* Identifier */:\n                        return makeUniqueName(node.text);\n                    case 218 /* ModuleDeclaration */:\n                    case 217 /* EnumDeclaration */:\n                        return generateNameForModuleOrEnum(node);\n                    case 222 /* ImportDeclaration */:\n                    case 228 /* ExportDeclaration */:\n                        return generateNameForImportOrExportDeclaration(node);\n                    case 213 /* FunctionDeclaration */:\n                    case 214 /* ClassDeclaration */:\n                    case 227 /* ExportAssignment */:\n                        return generateNameForExportDefault();\n                    case 186 /* ClassExpression */:\n                        return generateNameForClassExpression();\n                }\n            }\n            function getGeneratedNameForNode(node) {\n                var id = ts.getNodeId(node);\n                return nodeToGeneratedName[id] || (nodeToGeneratedName[id] = ts.unescapeIdentifier(generateNameForNode(node)));\n            }\n            function initializeEmitterWithSourceMaps() {\n                var sourceMapDir; // The directory in which sourcemap will be\n                // Current source map file and its index in the sources list\n                var sourceMapSourceIndex = -1;\n                // Names and its index map\n                var sourceMapNameIndexMap = {};\n                var sourceMapNameIndices = [];\n                function getSourceMapNameIndex() {\n                    return sourceMapNameIndices.length ? ts.lastOrUndefined(sourceMapNameIndices) : -1;\n                }\n                // Last recorded and encoded spans\n                var lastRecordedSourceMapSpan;\n                var lastEncodedSourceMapSpan = {\n                    emittedLine: 1,\n                    emittedColumn: 1,\n                    sourceLine: 1,\n                    sourceColumn: 1,\n                    sourceIndex: 0\n                };\n                var lastEncodedNameIndex = 0;\n                // Encoding for sourcemap span\n                function encodeLastRecordedSourceMapSpan() {\n                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {\n                        return;\n                    }\n                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;\n                    // Line/Comma delimiters\n                    if (lastEncodedSourceMapSpan.emittedLine === lastRecordedSourceMapSpan.emittedLine) {\n                        // Emit comma to separate the entry\n                        if (sourceMapData.sourceMapMappings) {\n                            sourceMapData.sourceMapMappings += \",\";\n                        }\n                    }\n                    else {\n                        // Emit line delimiters\n                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {\n                            sourceMapData.sourceMapMappings += \";\";\n                        }\n                        prevEncodedEmittedColumn = 1;\n                    }\n                    // 1. Relative Column 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);\n                    // 2. Relative sourceIndex\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);\n                    // 3. Relative sourceLine 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);\n                    // 4. Relative sourceColumn 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);\n                    // 5. Relative namePosition 0 based\n                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {\n                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);\n                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;\n                    }\n                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;\n                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);\n                    function base64VLQFormatEncode(inValue) {\n                        function base64FormatEncode(inValue) {\n                            if (inValue < 64) {\n                                return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(inValue);\n                            }\n                            throw TypeError(inValue + \": not a 64 based value\");\n                        }\n                        // Add a new least significant bit that has the sign of the value.\n                        // if negative number the least significant bit that gets added to the number has value 1\n                        // else least significant bit value that gets added is 0\n                        // eg. -1 changes to binary : 01 [1] => 3\n                        //     +1 changes to binary : 01 [0] => 2\n                        if (inValue < 0) {\n                            inValue = ((-inValue) << 1) + 1;\n                        }\n                        else {\n                            inValue = inValue << 1;\n                        }\n                        // Encode 5 bits at a time starting from least significant bits\n                        var encodedStr = \"\";\n                        do {\n                            var currentDigit = inValue & 31; // 11111\n                            inValue = inValue >> 5;\n                            if (inValue > 0) {\n                                // There are still more digits to decode, set the msb (6th bit)\n                                currentDigit = currentDigit | 32;\n                            }\n                            encodedStr = encodedStr + base64FormatEncode(currentDigit);\n                        } while (inValue > 0);\n                        return encodedStr;\n                    }\n                }\n                function recordSourceMapSpan(pos) {\n                    var sourceLinePos = ts.getLineAndCharacterOfPosition(currentSourceFile, pos);\n                    // Convert the location to be one-based.\n                    sourceLinePos.line++;\n                    sourceLinePos.character++;\n                    var emittedLine = writer.getLine();\n                    var emittedColumn = writer.getColumn();\n                    // If this location wasn't recorded or the location in source is going backwards, record the span\n                    if (!lastRecordedSourceMapSpan ||\n                        lastRecordedSourceMapSpan.emittedLine !== emittedLine ||\n                        lastRecordedSourceMapSpan.emittedColumn !== emittedColumn ||\n                        (lastRecordedSourceMapSpan.sourceIndex === sourceMapSourceIndex &&\n                        (lastRecordedSourceMapSpan.sourceLine > sourceLinePos.line ||\n                        (lastRecordedSourceMapSpan.sourceLine === sourceLinePos.line && lastRecordedSourceMapSpan.sourceColumn > sourceLinePos.character)))) {\n                        // Encode the last recordedSpan before assigning new\n                        encodeLastRecordedSourceMapSpan();\n                        // New span\n                        lastRecordedSourceMapSpan = {\n                            emittedLine: emittedLine,\n                            emittedColumn: emittedColumn,\n                            sourceLine: sourceLinePos.line,\n                            sourceColumn: sourceLinePos.character,\n                            nameIndex: getSourceMapNameIndex(),\n                            sourceIndex: sourceMapSourceIndex\n                        };\n                    }\n                    else {\n                        // Take the new pos instead since there is no change in emittedLine and column since last location\n                        lastRecordedSourceMapSpan.sourceLine = sourceLinePos.line;\n                        lastRecordedSourceMapSpan.sourceColumn = sourceLinePos.character;\n                        lastRecordedSourceMapSpan.sourceIndex = sourceMapSourceIndex;\n                    }\n                }\n                function recordEmitNodeStartSpan(node) {\n                    // Get the token pos after skipping to the token (ignoring the leading trivia)\n                    recordSourceMapSpan(ts.skipTrivia(currentSourceFile.text, node.pos));\n                }\n                function recordEmitNodeEndSpan(node) {\n                    recordSourceMapSpan(node.end);\n                }\n                function writeTextWithSpanRecord(tokenKind, startPos, emitFn) {\n                    var tokenStartPos = ts.skipTrivia(currentSourceFile.text, startPos);\n                    recordSourceMapSpan(tokenStartPos);\n                    var tokenEndPos = emitTokenText(tokenKind, tokenStartPos, emitFn);\n                    recordSourceMapSpan(tokenEndPos);\n                    return tokenEndPos;\n                }\n                function recordNewSourceFileStart(node) {\n                    // Add the file to tsFilePaths\n                    // If sourceroot option: Use the relative path corresponding to the common directory path\n                    // otherwise source locations relative to map file location\n                    var sourcesDirectoryPath = compilerOptions.sourceRoot ? host.getCommonSourceDirectory() : sourceMapDir;\n                    sourceMapData.sourceMapSources.push(ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, node.fileName, host.getCurrentDirectory(), host.getCanonicalFileName,\n                        /*isAbsolutePathAnUrl*/ true));\n                    sourceMapSourceIndex = sourceMapData.sourceMapSources.length - 1;\n                    // The one that can be used from program to get the actual source file\n                    sourceMapData.inputSourceFileNames.push(node.fileName);\n                    if (compilerOptions.inlineSources) {\n                        if (!sourceMapData.sourceMapSourcesContent) {\n                            sourceMapData.sourceMapSourcesContent = [];\n                        }\n                        sourceMapData.sourceMapSourcesContent.push(node.text);\n                    }\n                }\n                function recordScopeNameOfNode(node, scopeName) {\n                    function recordScopeNameIndex(scopeNameIndex) {\n                        sourceMapNameIndices.push(scopeNameIndex);\n                    }\n                    function recordScopeNameStart(scopeName) {\n                        var scopeNameIndex = -1;\n                        if (scopeName) {\n                            var parentIndex = getSourceMapNameIndex();\n                            if (parentIndex !== -1) {\n                                // Child scopes are always shown with a dot (even if they have no name),\n                                // unless it is a computed property. Then it is shown with brackets,\n                                // but the brackets are included in the name.\n                                var name_21 = node.name;\n                                if (!name_21 || name_21.kind !== 136 /* ComputedPropertyName */) {\n                                    scopeName = \".\" + scopeName;\n                                }\n                                scopeName = sourceMapData.sourceMapNames[parentIndex] + scopeName;\n                            }\n                            scopeNameIndex = ts.getProperty(sourceMapNameIndexMap, scopeName);\n                            if (scopeNameIndex === undefined) {\n                                scopeNameIndex = sourceMapData.sourceMapNames.length;\n                                sourceMapData.sourceMapNames.push(scopeName);\n                                sourceMapNameIndexMap[scopeName] = scopeNameIndex;\n                            }\n                        }\n                        recordScopeNameIndex(scopeNameIndex);\n                    }\n                    if (scopeName) {\n                        // The scope was already given a name  use it\n                        recordScopeNameStart(scopeName);\n                    }\n                    else if (node.kind === 213 /* FunctionDeclaration */ ||\n                        node.kind === 173 /* FunctionExpression */ ||\n                        node.kind === 143 /* MethodDeclaration */ ||\n                        node.kind === 142 /* MethodSignature */ ||\n                        node.kind === 145 /* GetAccessor */ ||\n                        node.kind === 146 /* SetAccessor */ ||\n                        node.kind === 218 /* ModuleDeclaration */ ||\n                        node.kind === 214 /* ClassDeclaration */ ||\n                        node.kind === 217 /* EnumDeclaration */) {\n                        // Declaration and has associated name use it\n                        if (node.name) {\n                            var name_22 = node.name;\n                            // For computed property names, the text will include the brackets\n                            scopeName = name_22.kind === 136 /* ComputedPropertyName */\n                                ? ts.getTextOfNode(name_22)\n                                : node.name.text;\n                        }\n                        recordScopeNameStart(scopeName);\n                    }\n                    else {\n                        // Block just use the name from upper level scope\n                        recordScopeNameIndex(getSourceMapNameIndex());\n                    }\n                }\n                function recordScopeNameEnd() {\n                    sourceMapNameIndices.pop();\n                }\n                ;\n                function writeCommentRangeWithMap(curentSourceFile, writer, comment, newLine) {\n                    recordSourceMapSpan(comment.pos);\n                    ts.writeCommentRange(currentSourceFile, writer, comment, newLine);\n                    recordSourceMapSpan(comment.end);\n                }\n                function serializeSourceMapContents(version, file, sourceRoot, sources, names, mappings, sourcesContent) {\n                    if (typeof JSON !== \"undefined\") {\n                        var map_1 = {\n                            version: version,\n                            file: file,\n                            sourceRoot: sourceRoot,\n                            sources: sources,\n                            names: names,\n                            mappings: mappings\n                        };\n                        if (sourcesContent !== undefined) {\n                            map_1.sourcesContent = sourcesContent;\n                        }\n                        return JSON.stringify(map_1);\n                    }\n                    return \"{\\\"version\\\":\" + version + \",\\\"file\\\":\\\"\" + ts.escapeString(file) + \"\\\",\\\"sourceRoot\\\":\\\"\" + ts.escapeString(sourceRoot) + \"\\\",\\\"sources\\\":[\" + serializeStringArray(sources) + \"],\\\"names\\\":[\" + serializeStringArray(names) + \"],\\\"mappings\\\":\\\"\" + ts.escapeString(mappings) + \"\\\" \" + (sourcesContent !== undefined ? \",\\\"sourcesContent\\\":[\" + serializeStringArray(sourcesContent) + \"]\" : \"\") + \"}\";\n                    function serializeStringArray(list) {\n                        var output = \"\";\n                        for (var i = 0, n = list.length; i < n; i++) {\n                            if (i) {\n                                output += \",\";\n                            }\n                            output += \"\\\"\" + ts.escapeString(list[i]) + \"\\\"\";\n                        }\n                        return output;\n                    }\n                }\n                function writeJavaScriptAndSourceMapFile(emitOutput, writeByteOrderMark) {\n                    encodeLastRecordedSourceMapSpan();\n                    var sourceMapText = serializeSourceMapContents(3, sourceMapData.sourceMapFile, sourceMapData.sourceMapSourceRoot, sourceMapData.sourceMapSources, sourceMapData.sourceMapNames, sourceMapData.sourceMapMappings, sourceMapData.sourceMapSourcesContent);\n                    sourceMapDataList.push(sourceMapData);\n                    var sourceMapUrl;\n                    if (compilerOptions.inlineSourceMap) {\n                        // Encode the sourceMap into the sourceMap url\n                        var base64SourceMapText = ts.convertToBase64(sourceMapText);\n                        sourceMapUrl = \"//# sourceMappingURL=data:application/json;base64,\" + base64SourceMapText;\n                    }\n                    else {\n                        // Write source map file\n                        ts.writeFile(host, diagnostics, sourceMapData.sourceMapFilePath, sourceMapText, /*writeByteOrderMark*/ false);\n                        sourceMapUrl = \"//# sourceMappingURL=\" + sourceMapData.jsSourceMappingURL;\n                    }\n                    // Write sourcemap url to the js file and write the js file\n                    writeJavaScriptFile(emitOutput + sourceMapUrl, writeByteOrderMark);\n                }\n                // Initialize source map data\n                var sourceMapJsFile = ts.getBaseFileName(ts.normalizeSlashes(jsFilePath));\n                sourceMapData = {\n                    sourceMapFilePath: jsFilePath + \".map\",\n                    jsSourceMappingURL: sourceMapJsFile + \".map\",\n                    sourceMapFile: sourceMapJsFile,\n                    sourceMapSourceRoot: compilerOptions.sourceRoot || \"\",\n                    sourceMapSources: [],\n                    inputSourceFileNames: [],\n                    sourceMapNames: [],\n                    sourceMapMappings: \"\",\n                    sourceMapSourcesContent: undefined,\n                    sourceMapDecodedMappings: []\n                };\n                // Normalize source root and make sure it has trailing \"/\" so that it can be used to combine paths with the\n                // relative paths of the sources list in the sourcemap\n                sourceMapData.sourceMapSourceRoot = ts.normalizeSlashes(sourceMapData.sourceMapSourceRoot);\n                if (sourceMapData.sourceMapSourceRoot.length && sourceMapData.sourceMapSourceRoot.charCodeAt(sourceMapData.sourceMapSourceRoot.length - 1) !== 47 /* slash */) {\n                    sourceMapData.sourceMapSourceRoot += ts.directorySeparator;\n                }\n                if (compilerOptions.mapRoot) {\n                    sourceMapDir = ts.normalizeSlashes(compilerOptions.mapRoot);\n                    if (root) {\n                        // For modules or multiple emit files the mapRoot will have directory structure like the sources\n                        // So if src\\a.ts and src\\lib\\b.ts are compiled together user would be moving the maps into mapRoot\\a.js.map and mapRoot\\lib\\b.js.map\n                        sourceMapDir = ts.getDirectoryPath(ts.getSourceFilePathInNewDir(root, host, sourceMapDir));\n                    }\n                    if (!ts.isRootedDiskPath(sourceMapDir) && !ts.isUrl(sourceMapDir)) {\n                        // The relative paths are relative to the common directory\n                        sourceMapDir = ts.combinePaths(host.getCommonSourceDirectory(), sourceMapDir);\n                        sourceMapData.jsSourceMappingURL = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(jsFilePath)), // get the relative sourceMapDir path based on jsFilePath\n                            ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL), // this is where user expects to see sourceMap\n                            host.getCurrentDirectory(), host.getCanonicalFileName,\n                            /*isAbsolutePathAnUrl*/ true);\n                    }\n                    else {\n                        sourceMapData.jsSourceMappingURL = ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL);\n                    }\n                }\n                else {\n                    sourceMapDir = ts.getDirectoryPath(ts.normalizePath(jsFilePath));\n                }\n                function emitNodeWithSourceMap(node) {\n                    if (node) {\n                        if (ts.nodeIsSynthesized(node)) {\n                            return emitNodeWithoutSourceMap(node);\n                        }\n                        if (node.kind !== 248 /* SourceFile */) {\n                            recordEmitNodeStartSpan(node);\n                            emitNodeWithoutSourceMap(node);\n                            recordEmitNodeEndSpan(node);\n                        }\n                        else {\n                            recordNewSourceFileStart(node);\n                            emitNodeWithoutSourceMap(node);\n                        }\n                    }\n                }\n                function emitNodeWithCommentsAndWithSourcemap(node) {\n                    emitNodeConsideringCommentsOption(node, emitNodeWithSourceMap);\n                }\n                writeEmittedFiles = writeJavaScriptAndSourceMapFile;\n                emit = emitNodeWithCommentsAndWithSourcemap;\n                emitStart = recordEmitNodeStartSpan;\n                emitEnd = recordEmitNodeEndSpan;\n                emitToken = writeTextWithSpanRecord;\n                scopeEmitStart = recordScopeNameOfNode;\n                scopeEmitEnd = recordScopeNameEnd;\n                writeComment = writeCommentRangeWithMap;\n            }\n            function writeJavaScriptFile(emitOutput, writeByteOrderMark) {\n                ts.writeFile(host, diagnostics, jsFilePath, emitOutput, writeByteOrderMark);\n            }\n            // Create a temporary variable with a unique unused name.\n            function createTempVariable(flags) {\n                var result = ts.createSynthesizedNode(69 /* Identifier */);\n                result.text = makeTempVariableName(flags);\n                return result;\n            }\n            function recordTempDeclaration(name) {\n                if (!tempVariables) {\n                    tempVariables = [];\n                }\n                tempVariables.push(name);\n            }\n            function createAndRecordTempVariable(flags) {\n                var temp = createTempVariable(flags);\n                recordTempDeclaration(temp);\n                return temp;\n            }\n            function emitTempDeclarations(newLine) {\n                if (tempVariables) {\n                    if (newLine) {\n                        writeLine();\n                    }\n                    else {\n                        write(\" \");\n                    }\n                    write(\"var \");\n                    emitCommaList(tempVariables);\n                    write(\";\");\n                }\n            }\n            function emitTokenText(tokenKind, startPos, emitFn) {\n                var tokenString = ts.tokenToString(tokenKind);\n                if (emitFn) {\n                    emitFn();\n                }\n                else {\n                    write(tokenString);\n                }\n                return startPos + tokenString.length;\n            }\n            function emitOptional(prefix, node) {\n                if (node) {\n                    write(prefix);\n                    emit(node);\n                }\n            }\n            function emitParenthesizedIf(node, parenthesized) {\n                if (parenthesized) {\n                    write(\"(\");\n                }\n                emit(node);\n                if (parenthesized) {\n                    write(\")\");\n                }\n            }\n            function emitTrailingCommaIfPresent(nodeList) {\n                if (nodeList.hasTrailingComma) {\n                    write(\",\");\n                }\n            }\n            function emitLinePreservingList(parent, nodes, allowTrailingComma, spacesBetweenBraces) {\n                ts.Debug.assert(nodes.length > 0);\n                increaseIndent();\n                if (nodeStartPositionsAreOnSameLine(parent, nodes[0])) {\n                    if (spacesBetweenBraces) {\n                        write(\" \");\n                    }\n                }\n                else {\n                    writeLine();\n                }\n                for (var i = 0, n = nodes.length; i < n; i++) {\n                    if (i) {\n                        if (nodeEndIsOnSameLineAsNodeStart(nodes[i - 1], nodes[i])) {\n                            write(\", \");\n                        }\n                        else {\n                            write(\",\");\n                            writeLine();\n                        }\n                    }\n                    emit(nodes[i]);\n                }\n                if (nodes.hasTrailingComma && allowTrailingComma) {\n                    write(\",\");\n                }\n                decreaseIndent();\n                if (nodeEndPositionsAreOnSameLine(parent, ts.lastOrUndefined(nodes))) {\n                    if (spacesBetweenBraces) {\n                        write(\" \");\n                    }\n                }\n                else {\n                    writeLine();\n                }\n            }\n            function emitList(nodes, start, count, multiLine, trailingComma, leadingComma, noTrailingNewLine, emitNode) {\n                if (!emitNode) {\n                    emitNode = emit;\n                }\n                for (var i = 0; i < count; i++) {\n                    if (multiLine) {\n                        if (i || leadingComma) {\n                            write(\",\");\n                        }\n                        writeLine();\n                    }\n                    else {\n                        if (i || leadingComma) {\n                            write(\", \");\n                        }\n                    }\n                    var node = nodes[start + i];\n                    // This emitting is to make sure we emit following comment properly\n                    //   ...(x, /*comment1*/ y)...\n                    //         ^ => node.pos\n                    // \"comment1\" is not considered leading comment for \"y\" but rather\n                    // considered as trailing comment of the previous node.\n                    emitTrailingCommentsOfPosition(node.pos);\n                    emitNode(node);\n                    leadingComma = true;\n                }\n                if (trailingComma) {\n                    write(\",\");\n                }\n                if (multiLine && !noTrailingNewLine) {\n                    writeLine();\n                }\n                return count;\n            }\n            function emitCommaList(nodes) {\n                if (nodes) {\n                    emitList(nodes, 0, nodes.length, /*multiline*/ false, /*trailingComma*/ false);\n                }\n            }\n            function emitLines(nodes) {\n                emitLinesStartingAt(nodes, /*startIndex*/ 0);\n            }\n            function emitLinesStartingAt(nodes, startIndex) {\n                for (var i = startIndex; i < nodes.length; i++) {\n                    writeLine();\n                    emit(nodes[i]);\n                }\n            }\n            function isBinaryOrOctalIntegerLiteral(node, text) {\n                if (node.kind === 8 /* NumericLiteral */ && text.length > 1) {\n                    switch (text.charCodeAt(1)) {\n                        case 98 /* b */:\n                        case 66 /* B */:\n                        case 111 /* o */:\n                        case 79 /* O */:\n                            return true;\n                    }\n                }\n                return false;\n            }\n            function emitLiteral(node) {\n                var text = getLiteralText(node);\n                if ((compilerOptions.sourceMap || compilerOptions.inlineSourceMap) && (node.kind === 9 /* StringLiteral */ || ts.isTemplateLiteralKind(node.kind))) {\n                    writer.writeLiteral(text);\n                }\n                else if (languageVersion < 2 /* ES6 */ && isBinaryOrOctalIntegerLiteral(node, text)) {\n                    write(node.text);\n                }\n                else {\n                    write(text);\n                }\n            }\n            function getLiteralText(node) {\n                // Any template literal or string literal with an extended escape\n                // (e.g. \"\\u{0067}\") will need to be downleveled as a escaped string literal.\n                if (languageVersion < 2 /* ES6 */ && (ts.isTemplateLiteralKind(node.kind) || node.hasExtendedUnicodeEscape)) {\n                    return getQuotedEscapedLiteralText(\"\\\"\", node.text, \"\\\"\");\n                }\n                // If we don't need to downlevel and we can reach the original source text using\n                // the node's parent reference, then simply get the text as it was originally written.\n                if (node.parent) {\n                    return ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);\n                }\n                // If we can't reach the original source text, use the canonical form if it's a number,\n                // or an escaped quoted form of the original text if it's string-like.\n                switch (node.kind) {\n                    case 9 /* StringLiteral */:\n                        return getQuotedEscapedLiteralText(\"\\\"\", node.text, \"\\\"\");\n                    case 11 /* NoSubstitutionTemplateLiteral */:\n                        return getQuotedEscapedLiteralText(\"`\", node.text, \"`\");\n                    case 12 /* TemplateHead */:\n                        return getQuotedEscapedLiteralText(\"`\", node.text, \"${\");\n                    case 13 /* TemplateMiddle */:\n                        return getQuotedEscapedLiteralText(\"}\", node.text, \"${\");\n                    case 14 /* TemplateTail */:\n                        return getQuotedEscapedLiteralText(\"}\", node.text, \"`\");\n                    case 8 /* NumericLiteral */:\n                        return node.text;\n                }\n                ts.Debug.fail(\"Literal kind '\" + node.kind + \"' not accounted for.\");\n            }\n            function getQuotedEscapedLiteralText(leftQuote, text, rightQuote) {\n                return leftQuote + ts.escapeNonAsciiCharacters(ts.escapeString(text)) + rightQuote;\n            }\n            function emitDownlevelRawTemplateLiteral(node) {\n                // Find original source text, since we need to emit the raw strings of the tagged template.\n                // The raw strings contain the (escaped) strings of what the user wrote.\n                // Examples: `\\n` is converted to \"\\\\n\", a template string with a newline to \"\\n\".\n                var text = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);\n                // text contains the original source, it will also contain quotes (\"`\"), dolar signs and braces (\"${\" and \"}\"),\n                // thus we need to remove those characters.\n                // First template piece starts with \"`\", others with \"}\"\n                // Last template piece ends with \"`\", others with \"${\"\n                var isLast = node.kind === 11 /* NoSubstitutionTemplateLiteral */ || node.kind === 14 /* TemplateTail */;\n                text = text.substring(1, text.length - (isLast ? 1 : 2));\n                // Newline normalization:\n                // ES6 Spec 11.8.6.1 - Static Semantics of TV's and TRV's\n                // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for both TV and TRV.\n                text = text.replace(/\\r\\n?/g, \"\\n\");\n                text = ts.escapeString(text);\n                write(\"\\\"\" + text + \"\\\"\");\n            }\n            function emitDownlevelTaggedTemplateArray(node, literalEmitter) {\n                write(\"[\");\n                if (node.template.kind === 11 /* NoSubstitutionTemplateLiteral */) {\n                    literalEmitter(node.template);\n                }\n                else {\n                    literalEmitter(node.template.head);\n                    ts.forEach(node.template.templateSpans, function (child) {\n                        write(\", \");\n                        literalEmitter(child.literal);\n                    });\n                }\n                write(\"]\");\n            }\n            function emitDownlevelTaggedTemplate(node) {\n                var tempVariable = createAndRecordTempVariable(0 /* Auto */);\n                write(\"(\");\n                emit(tempVariable);\n                write(\" = \");\n                emitDownlevelTaggedTemplateArray(node, emit);\n                write(\", \");\n                emit(tempVariable);\n                write(\".raw = \");\n                emitDownlevelTaggedTemplateArray(node, emitDownlevelRawTemplateLiteral);\n                write(\", \");\n                emitParenthesizedIf(node.tag, needsParenthesisForPropertyAccessOrInvocation(node.tag));\n                write(\"(\");\n                emit(tempVariable);\n                // Now we emit the expressions\n                if (node.template.kind === 183 /* TemplateExpression */) {\n                    ts.forEach(node.template.templateSpans, function (templateSpan) {\n                        write(\", \");\n                        var needsParens = templateSpan.expression.kind === 181 /* BinaryExpression */\n                            && templateSpan.expression.operatorToken.kind === 24 /* CommaToken */;\n                        emitParenthesizedIf(templateSpan.expression, needsParens);\n                    });\n                }\n                write(\"))\");\n            }\n            function emitTemplateExpression(node) {\n                // In ES6 mode and above, we can simply emit each portion of a template in order, but in\n                // ES3 & ES5 we must convert the template expression into a series of string concatenations.\n                if (languageVersion >= 2 /* ES6 */) {\n                    ts.forEachChild(node, emit);\n                    return;\n                }\n                var emitOuterParens = ts.isExpression(node.parent)\n                    && templateNeedsParens(node, node.parent);\n                if (emitOuterParens) {\n                    write(\"(\");\n                }\n                var headEmitted = false;\n                if (shouldEmitTemplateHead()) {\n                    emitLiteral(node.head);\n                    headEmitted = true;\n                }\n                for (var i = 0, n = node.templateSpans.length; i < n; i++) {\n                    var templateSpan = node.templateSpans[i];\n                    // Check if the expression has operands and binds its operands less closely than binary '+'.\n                    // If it does, we need to wrap the expression in parentheses. Otherwise, something like\n                    //    `abc${ 1 << 2 }`\n                    // becomes\n                    //    \"abc\" + 1 << 2 + \"\"\n                    // which is really\n                    //    (\"abc\" + 1) << (2 + \"\")\n                    // rather than\n                    //    \"abc\" + (1 << 2) + \"\"\n                    var needsParens = templateSpan.expression.kind !== 172 /* ParenthesizedExpression */\n                        && comparePrecedenceToBinaryPlus(templateSpan.expression) !== 1 /* GreaterThan */;\n                    if (i > 0 || headEmitted) {\n                        // If this is the first span and the head was not emitted, then this templateSpan's\n                        // expression will be the first to be emitted. Don't emit the preceding ' + ' in that\n                        // case.\n                        write(\" + \");\n                    }\n                    emitParenthesizedIf(templateSpan.expression, needsParens);\n                    // Only emit if the literal is non-empty.\n                    // The binary '+' operator is left-associative, so the first string concatenation\n                    // with the head will force the result up to this point to be a string.\n                    // Emitting a '+ \"\"' has no semantic effect for middles and tails.\n                    if (templateSpan.literal.text.length !== 0) {\n                        write(\" + \");\n                        emitLiteral(templateSpan.literal);\n                    }\n                }\n                if (emitOuterParens) {\n                    write(\")\");\n                }\n                function shouldEmitTemplateHead() {\n                    // If this expression has an empty head literal and the first template span has a non-empty\n                    // literal, then emitting the empty head literal is not necessary.\n                    //     `${ foo } and ${ bar }`\n                    // can be emitted as\n                    //     foo + \" and \" + bar\n                    // This is because it is only required that one of the first two operands in the emit\n                    // output must be a string literal, so that the other operand and all following operands\n                    // are forced into strings.\n                    //\n                    // If the first template span has an empty literal, then the head must still be emitted.\n                    //     `${ foo }${ bar }`\n                    // must still be emitted as\n                    //     \"\" + foo + bar\n                    // There is always atleast one templateSpan in this code path, since\n                    // NoSubstitutionTemplateLiterals are directly emitted via emitLiteral()\n                    ts.Debug.assert(node.templateSpans.length !== 0);\n                    return node.head.text.length !== 0 || node.templateSpans[0].literal.text.length === 0;\n                }\n                function templateNeedsParens(template, parent) {\n                    switch (parent.kind) {\n                        case 168 /* CallExpression */:\n                        case 169 /* NewExpression */:\n                            return parent.expression === template;\n                        case 170 /* TaggedTemplateExpression */:\n                        case 172 /* ParenthesizedExpression */:\n                            return false;\n                        default:\n                            return comparePrecedenceToBinaryPlus(parent) !== -1 /* LessThan */;\n                    }\n                }\n                /**\n                 * Returns whether the expression has lesser, greater,\n                 * or equal precedence to the binary '+' operator\n                 */\n                function comparePrecedenceToBinaryPlus(expression) {\n                    // All binary expressions have lower precedence than '+' apart from '*', '/', and '%'\n                    // which have greater precedence and '-' which has equal precedence.\n                    // All unary operators have a higher precedence apart from yield.\n                    // Arrow functions and conditionals have a lower precedence,\n                    // although we convert the former into regular function expressions in ES5 mode,\n                    // and in ES6 mode this function won't get called anyway.\n                    //\n                    // TODO (drosen): Note that we need to account for the upcoming 'yield' and\n                    //                spread ('...') unary operators that are anticipated for ES6.\n                    switch (expression.kind) {\n                        case 181 /* BinaryExpression */:\n                            switch (expression.operatorToken.kind) {\n                                case 37 /* AsteriskToken */:\n                                case 39 /* SlashToken */:\n                                case 40 /* PercentToken */:\n                                    return 1 /* GreaterThan */;\n                                case 35 /* PlusToken */:\n                                case 36 /* MinusToken */:\n                                    return 0 /* EqualTo */;\n                                default:\n                                    return -1 /* LessThan */;\n                            }\n                        case 184 /* YieldExpression */:\n                        case 182 /* ConditionalExpression */:\n                            return -1 /* LessThan */;\n                        default:\n                            return 1 /* GreaterThan */;\n                    }\n                }\n            }\n            function emitTemplateSpan(span) {\n                emit(span.expression);\n                emit(span.literal);\n            }\n            function jsxEmitReact(node) {\n                /// Emit a tag name, which is either '\"div\"' for lower-cased names, or\n                /// 'Div' for upper-cased or dotted names\n                function emitTagName(name) {\n                    if (name.kind === 69 /* Identifier */ && ts.isIntrinsicJsxName(name.text)) {\n                        write(\"\\\"\");\n                        emit(name);\n                        write(\"\\\"\");\n                    }\n                    else {\n                        emit(name);\n                    }\n                }\n                /// Emit an attribute name, which is quoted if it needs to be quoted. Because\n                /// these emit into an object literal property name, we don't need to be worried\n                /// about keywords, just non-identifier characters\n                function emitAttributeName(name) {\n                    if (/[A-Za-z_]+[\\w*]/.test(name.text)) {\n                        write(\"\\\"\");\n                        emit(name);\n                        write(\"\\\"\");\n                    }\n                    else {\n                        emit(name);\n                    }\n                }\n                /// Emit an name/value pair for an attribute (e.g. \"x: 3\")\n                function emitJsxAttribute(node) {\n                    emitAttributeName(node.name);\n                    write(\": \");\n                    if (node.initializer) {\n                        emit(node.initializer);\n                    }\n                    else {\n                        write(\"true\");\n                    }\n                }\n                function emitJsxElement(openingNode, children) {\n                    var syntheticReactRef = ts.createSynthesizedNode(69 /* Identifier */);\n                    syntheticReactRef.text = \"React\";\n                    syntheticReactRef.parent = openingNode;\n                    // Call React.createElement(tag, ...\n                    emitLeadingComments(openingNode);\n                    emitExpressionIdentifier(syntheticReactRef);\n                    write(\".createElement(\");\n                    emitTagName(openingNode.tagName);\n                    write(\", \");\n                    // Attribute list\n                    if (openingNode.attributes.length === 0) {\n                        // When there are no attributes, React wants \"null\"\n                        write(\"null\");\n                    }\n                    else {\n                        // Either emit one big object literal (no spread attribs), or\n                        // a call to React.__spread\n                        var attrs = openingNode.attributes;\n                        if (ts.forEach(attrs, function (attr) { return attr.kind === 239 /* JsxSpreadAttribute */; })) {\n                            emitExpressionIdentifier(syntheticReactRef);\n                            write(\".__spread(\");\n                            var haveOpenedObjectLiteral = false;\n                            for (var i_1 = 0; i_1 < attrs.length; i_1++) {\n                                if (attrs[i_1].kind === 239 /* JsxSpreadAttribute */) {\n                                    // If this is the first argument, we need to emit a {} as the first argument\n                                    if (i_1 === 0) {\n                                        write(\"{}, \");\n                                    }\n                                    if (haveOpenedObjectLiteral) {\n                                        write(\"}\");\n                                        haveOpenedObjectLiteral = false;\n                                    }\n                                    if (i_1 > 0) {\n                                        write(\", \");\n                                    }\n                                    emit(attrs[i_1].expression);\n                                }\n                                else {\n                                    ts.Debug.assert(attrs[i_1].kind === 238 /* JsxAttribute */);\n                                    if (haveOpenedObjectLiteral) {\n                                        write(\", \");\n                                    }\n                                    else {\n                                        haveOpenedObjectLiteral = true;\n                                        if (i_1 > 0) {\n                                            write(\", \");\n                                        }\n                                        write(\"{\");\n                                    }\n                                    emitJsxAttribute(attrs[i_1]);\n                                }\n                            }\n                            if (haveOpenedObjectLiteral)\n                                write(\"}\");\n                            write(\")\"); // closing paren to React.__spread(\n                        }\n                        else {\n                            // One object literal with all the attributes in them\n                            write(\"{\");\n                            for (var i = 0; i < attrs.length; i++) {\n                                if (i > 0) {\n                                    write(\", \");\n                                }\n                                emitJsxAttribute(attrs[i]);\n                            }\n                            write(\"}\");\n                        }\n                    }\n                    // Children\n                    if (children) {\n                        for (var i = 0; i < children.length; i++) {\n                            // Don't emit empty expressions\n                            if (children[i].kind === 240 /* JsxExpression */ && !(children[i].expression)) {\n                                continue;\n                            }\n                            // Don't emit empty strings\n                            if (children[i].kind === 236 /* JsxText */) {\n                                var text = getTextToEmit(children[i]);\n                                if (text !== undefined) {\n                                    write(\", \\\"\");\n                                    write(text);\n                                    write(\"\\\"\");\n                                }\n                            }\n                            else {\n                                write(\", \");\n                                emit(children[i]);\n                            }\n                        }\n                    }\n                    // Closing paren\n                    write(\")\"); // closes \"React.createElement(\"\n                    emitTrailingComments(openingNode);\n                }\n                if (node.kind === 233 /* JsxElement */) {\n                    emitJsxElement(node.openingElement, node.children);\n                }\n                else {\n                    ts.Debug.assert(node.kind === 234 /* JsxSelfClosingElement */);\n                    emitJsxElement(node);\n                }\n            }\n            function jsxEmitPreserve(node) {\n                function emitJsxAttribute(node) {\n                    emit(node.name);\n                    if (node.initializer) {\n                        write(\"=\");\n                        emit(node.initializer);\n                    }\n                }\n                function emitJsxSpreadAttribute(node) {\n                    write(\"{...\");\n                    emit(node.expression);\n                    write(\"}\");\n                }\n                function emitAttributes(attribs) {\n                    for (var i = 0, n = attribs.length; i < n; i++) {\n                        if (i > 0) {\n                            write(\" \");\n                        }\n                        if (attribs[i].kind === 239 /* JsxSpreadAttribute */) {\n                            emitJsxSpreadAttribute(attribs[i]);\n                        }\n                        else {\n                            ts.Debug.assert(attribs[i].kind === 238 /* JsxAttribute */);\n                            emitJsxAttribute(attribs[i]);\n                        }\n                    }\n                }\n                function emitJsxOpeningOrSelfClosingElement(node) {\n                    write(\"<\");\n                    emit(node.tagName);\n                    if (node.attributes.length > 0 || (node.kind === 234 /* JsxSelfClosingElement */)) {\n                        write(\" \");\n                    }\n                    emitAttributes(node.attributes);\n                    if (node.kind === 234 /* JsxSelfClosingElement */) {\n                        write(\"/>\");\n                    }\n                    else {\n                        write(\">\");\n                    }\n                }\n                function emitJsxClosingElement(node) {\n                    write(\"</\");\n                    emit(node.tagName);\n                    write(\">\");\n                }\n                function emitJsxElement(node) {\n                    emitJsxOpeningOrSelfClosingElement(node.openingElement);\n                    for (var i = 0, n = node.children.length; i < n; i++) {\n                        emit(node.children[i]);\n                    }\n                    emitJsxClosingElement(node.closingElement);\n                }\n                if (node.kind === 233 /* JsxElement */) {\n                    emitJsxElement(node);\n                }\n                else {\n                    ts.Debug.assert(node.kind === 234 /* JsxSelfClosingElement */);\n                    emitJsxOpeningOrSelfClosingElement(node);\n                }\n            }\n            // This function specifically handles numeric/string literals for enum and accessor 'identifiers'.\n            // In a sense, it does not actually emit identifiers as much as it declares a name for a specific property.\n            // For example, this is utilized when feeding in a result to Object.defineProperty.\n            function emitExpressionForPropertyName(node) {\n                ts.Debug.assert(node.kind !== 163 /* BindingElement */);\n                if (node.kind === 9 /* StringLiteral */) {\n                    emitLiteral(node);\n                }\n                else if (node.kind === 136 /* ComputedPropertyName */) {\n                    // if this is a decorated computed property, we will need to capture the result\n                    // of the property expression so that we can apply decorators later. This is to ensure\n                    // we don't introduce unintended side effects:\n                    //\n                    //   class C {\n                    //     [_a = x]() { }\n                    //   }\n                    //\n                    // The emit for the decorated computed property decorator is:\n                    //\n                    //   __decorate([dec], C.prototype, _a, Object.getOwnPropertyDescriptor(C.prototype, _a));\n                    //\n                    if (ts.nodeIsDecorated(node.parent)) {\n                        if (!computedPropertyNamesToGeneratedNames) {\n                            computedPropertyNamesToGeneratedNames = [];\n                        }\n                        var generatedName = computedPropertyNamesToGeneratedNames[ts.getNodeId(node)];\n                        if (generatedName) {\n                            // we have already generated a variable for this node, write that value instead.\n                            write(generatedName);\n                            return;\n                        }\n                        generatedName = createAndRecordTempVariable(0 /* Auto */).text;\n                        computedPropertyNamesToGeneratedNames[ts.getNodeId(node)] = generatedName;\n                        write(generatedName);\n                        write(\" = \");\n                    }\n                    emit(node.expression);\n                }\n                else {\n                    write(\"\\\"\");\n                    if (node.kind === 8 /* NumericLiteral */) {\n                        write(node.text);\n                    }\n                    else {\n                        writeTextOfNode(currentSourceFile, node);\n                    }\n                    write(\"\\\"\");\n                }\n            }\n            function isExpressionIdentifier(node) {\n                var parent = node.parent;\n                switch (parent.kind) {\n                    case 164 /* ArrayLiteralExpression */:\n                    case 189 /* AsExpression */:\n                    case 181 /* BinaryExpression */:\n                    case 168 /* CallExpression */:\n                    case 241 /* CaseClause */:\n                    case 136 /* ComputedPropertyName */:\n                    case 182 /* ConditionalExpression */:\n                    case 139 /* Decorator */:\n                    case 175 /* DeleteExpression */:\n                    case 197 /* DoStatement */:\n                    case 167 /* ElementAccessExpression */:\n                    case 227 /* ExportAssignment */:\n                    case 195 /* ExpressionStatement */:\n                    case 188 /* ExpressionWithTypeArguments */:\n                    case 199 /* ForStatement */:\n                    case 200 /* ForInStatement */:\n                    case 201 /* ForOfStatement */:\n                    case 196 /* IfStatement */:\n                    case 234 /* JsxSelfClosingElement */:\n                    case 235 /* JsxOpeningElement */:\n                    case 239 /* JsxSpreadAttribute */:\n                    case 240 /* JsxExpression */:\n                    case 169 /* NewExpression */:\n                    case 172 /* ParenthesizedExpression */:\n                    case 180 /* PostfixUnaryExpression */:\n                    case 179 /* PrefixUnaryExpression */:\n                    case 204 /* ReturnStatement */:\n                    case 246 /* ShorthandPropertyAssignment */:\n                    case 185 /* SpreadElementExpression */:\n                    case 206 /* SwitchStatement */:\n                    case 170 /* TaggedTemplateExpression */:\n                    case 190 /* TemplateSpan */:\n                    case 208 /* ThrowStatement */:\n                    case 171 /* TypeAssertionExpression */:\n                    case 176 /* TypeOfExpression */:\n                    case 177 /* VoidExpression */:\n                    case 198 /* WhileStatement */:\n                    case 205 /* WithStatement */:\n                    case 184 /* YieldExpression */:\n                        return true;\n                    case 163 /* BindingElement */:\n                    case 247 /* EnumMember */:\n                    case 138 /* Parameter */:\n                    case 245 /* PropertyAssignment */:\n                    case 141 /* PropertyDeclaration */:\n                    case 211 /* VariableDeclaration */:\n                        return parent.initializer === node;\n                    case 166 /* PropertyAccessExpression */:\n                        return parent.expression === node;\n                    case 174 /* ArrowFunction */:\n                    case 173 /* FunctionExpression */:\n                        return parent.body === node;\n                    case 221 /* ImportEqualsDeclaration */:\n                        return parent.moduleReference === node;\n                    case 135 /* QualifiedName */:\n                        return parent.left === node;\n                }\n                return false;\n            }\n            function emitExpressionIdentifier(node) {\n                if (resolver.getNodeCheckFlags(node) & 2048 /* LexicalArguments */) {\n                    write(\"_arguments\");\n                    return;\n                }\n                var container = resolver.getReferencedExportContainer(node);\n                if (container) {\n                    if (container.kind === 248 /* SourceFile */) {\n                        // Identifier references module export\n                        if (modulekind !== 5 /* ES6 */ && modulekind !== 4 /* System */) {\n                            write(\"exports.\");\n                        }\n                    }\n                    else {\n                        // Identifier references namespace export\n                        write(getGeneratedNameForNode(container));\n                        write(\".\");\n                    }\n                }\n                else {\n                    if (modulekind !== 5 /* ES6 */) {\n                        var declaration = resolver.getReferencedImportDeclaration(node);\n                        if (declaration) {\n                            if (declaration.kind === 223 /* ImportClause */) {\n                                // Identifier references default import\n                                write(getGeneratedNameForNode(declaration.parent));\n                                write(languageVersion === 0 /* ES3 */ ? \"[\\\"default\\\"]\" : \".default\");\n                                return;\n                            }\n                            else if (declaration.kind === 226 /* ImportSpecifier */) {\n                                // Identifier references named import\n                                write(getGeneratedNameForNode(declaration.parent.parent.parent));\n                                var name_23 = declaration.propertyName || declaration.name;\n                                var identifier = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, name_23);\n                                if (languageVersion === 0 /* ES3 */ && identifier === \"default\") {\n                                    write(\"[\\\"default\\\"]\");\n                                }\n                                else {\n                                    write(\".\");\n                                    write(identifier);\n                                }\n                                return;\n                            }\n                        }\n                    }\n                    if (languageVersion !== 2 /* ES6 */) {\n                        var declaration = resolver.getReferencedNestedRedeclaration(node);\n                        if (declaration) {\n                            write(getGeneratedNameForNode(declaration.name));\n                            return;\n                        }\n                    }\n                }\n                if (ts.nodeIsSynthesized(node)) {\n                    write(node.text);\n                }\n                else {\n                    writeTextOfNode(currentSourceFile, node);\n                }\n            }\n            function isNameOfNestedRedeclaration(node) {\n                if (languageVersion < 2 /* ES6 */) {\n                    var parent_6 = node.parent;\n                    switch (parent_6.kind) {\n                        case 163 /* BindingElement */:\n                        case 214 /* ClassDeclaration */:\n                        case 217 /* EnumDeclaration */:\n                        case 211 /* VariableDeclaration */:\n                            return parent_6.name === node && resolver.isNestedRedeclaration(parent_6);\n                    }\n                }\n                return false;\n            }\n            function emitIdentifier(node) {\n                if (!node.parent) {\n                    write(node.text);\n                }\n                else if (isExpressionIdentifier(node)) {\n                    emitExpressionIdentifier(node);\n                }\n                else if (isNameOfNestedRedeclaration(node)) {\n                    write(getGeneratedNameForNode(node));\n                }\n                else if (ts.nodeIsSynthesized(node)) {\n                    write(node.text);\n                }\n                else {\n                    writeTextOfNode(currentSourceFile, node);\n                }\n            }\n            function emitThis(node) {\n                if (resolver.getNodeCheckFlags(node) & 2 /* LexicalThis */) {\n                    write(\"_this\");\n                }\n                else {\n                    write(\"this\");\n                }\n            }\n            function emitSuper(node) {\n                if (languageVersion >= 2 /* ES6 */) {\n                    write(\"super\");\n                }\n                else {\n                    var flags = resolver.getNodeCheckFlags(node);\n                    if (flags & 256 /* SuperInstance */) {\n                        write(\"_super.prototype\");\n                    }\n                    else {\n                        write(\"_super\");\n                    }\n                }\n            }\n            function emitObjectBindingPattern(node) {\n                write(\"{ \");\n                var elements = node.elements;\n                emitList(elements, 0, elements.length, /*multiLine*/ false, /*trailingComma*/ elements.hasTrailingComma);\n                write(\" }\");\n            }\n            function emitArrayBindingPattern(node) {\n                write(\"[\");\n                var elements = node.elements;\n                emitList(elements, 0, elements.length, /*multiLine*/ false, /*trailingComma*/ elements.hasTrailingComma);\n                write(\"]\");\n            }\n            function emitBindingElement(node) {\n                if (node.propertyName) {\n                    emit(node.propertyName);\n                    write(\": \");\n                }\n                if (node.dotDotDotToken) {\n                    write(\"...\");\n                }\n                if (ts.isBindingPattern(node.name)) {\n                    emit(node.name);\n                }\n                else {\n                    emitModuleMemberName(node);\n                }\n                emitOptional(\" = \", node.initializer);\n            }\n            function emitSpreadElementExpression(node) {\n                write(\"...\");\n                emit(node.expression);\n            }\n            function emitYieldExpression(node) {\n                write(ts.tokenToString(114 /* YieldKeyword */));\n                if (node.asteriskToken) {\n                    write(\"*\");\n                }\n                if (node.expression) {\n                    write(\" \");\n                    emit(node.expression);\n                }\n            }\n            function emitAwaitExpression(node) {\n                var needsParenthesis = needsParenthesisForAwaitExpressionAsYield(node);\n                if (needsParenthesis) {\n                    write(\"(\");\n                }\n                write(ts.tokenToString(114 /* YieldKeyword */));\n                write(\" \");\n                emit(node.expression);\n                if (needsParenthesis) {\n                    write(\")\");\n                }\n            }\n            function needsParenthesisForAwaitExpressionAsYield(node) {\n                if (node.parent.kind === 181 /* BinaryExpression */ && !ts.isAssignmentOperator(node.parent.operatorToken.kind)) {\n                    return true;\n                }\n                else if (node.parent.kind === 182 /* ConditionalExpression */ && node.parent.condition === node) {\n                    return true;\n                }\n                return false;\n            }\n            function needsParenthesisForPropertyAccessOrInvocation(node) {\n                switch (node.kind) {\n                    case 69 /* Identifier */:\n                    case 164 /* ArrayLiteralExpression */:\n                    case 166 /* PropertyAccessExpression */:\n                    case 167 /* ElementAccessExpression */:\n                    case 168 /* CallExpression */:\n                    case 172 /* ParenthesizedExpression */:\n                        // This list is not exhaustive and only includes those cases that are relevant\n                        // to the check in emitArrayLiteral. More cases can be added as needed.\n                        return false;\n                }\n                return true;\n            }\n            function emitListWithSpread(elements, needsUniqueCopy, multiLine, trailingComma, useConcat) {\n                var pos = 0;\n                var group = 0;\n                var length = elements.length;\n                while (pos < length) {\n                    // Emit using the pattern <group0>.concat(<group1>, <group2>, ...)\n                    if (group === 1 && useConcat) {\n                        write(\".concat(\");\n                    }\n                    else if (group > 0) {\n                        write(\", \");\n                    }\n                    var e = elements[pos];\n                    if (e.kind === 185 /* SpreadElementExpression */) {\n                        e = e.expression;\n                        emitParenthesizedIf(e, /*parenthesized*/ group === 0 && needsParenthesisForPropertyAccessOrInvocation(e));\n                        pos++;\n                        if (pos === length && group === 0 && needsUniqueCopy && e.kind !== 164 /* ArrayLiteralExpression */) {\n                            write(\".slice()\");\n                        }\n                    }\n                    else {\n                        var i = pos;\n                        while (i < length && elements[i].kind !== 185 /* SpreadElementExpression */) {\n                            i++;\n                        }\n                        write(\"[\");\n                        if (multiLine) {\n                            increaseIndent();\n                        }\n                        emitList(elements, pos, i - pos, multiLine, trailingComma && i === length);\n                        if (multiLine) {\n                            decreaseIndent();\n                        }\n                        write(\"]\");\n                        pos = i;\n                    }\n                    group++;\n                }\n                if (group > 1) {\n                    if (useConcat) {\n                        write(\")\");\n                    }\n                }\n            }\n            function isSpreadElementExpression(node) {\n                return node.kind === 185 /* SpreadElementExpression */;\n            }\n            function emitArrayLiteral(node) {\n                var elements = node.elements;\n                if (elements.length === 0) {\n                    write(\"[]\");\n                }\n                else if (languageVersion >= 2 /* ES6 */ || !ts.forEach(elements, isSpreadElementExpression)) {\n                    write(\"[\");\n                    emitLinePreservingList(node, node.elements, elements.hasTrailingComma, /*spacesBetweenBraces:*/ false);\n                    write(\"]\");\n                }\n                else {\n                    emitListWithSpread(elements, /*needsUniqueCopy*/ true, /*multiLine*/ (node.flags & 2048 /* MultiLine */) !== 0,\n                        /*trailingComma*/ elements.hasTrailingComma, /*useConcat*/ true);\n                }\n            }\n            function emitObjectLiteralBody(node, numElements) {\n                if (numElements === 0) {\n                    write(\"{}\");\n                    return;\n                }\n                write(\"{\");\n                if (numElements > 0) {\n                    var properties = node.properties;\n                    // If we are not doing a downlevel transformation for object literals,\n                    // then try to preserve the original shape of the object literal.\n                    // Otherwise just try to preserve the formatting.\n                    if (numElements === properties.length) {\n                        emitLinePreservingList(node, properties, /* allowTrailingComma */ languageVersion >= 1 /* ES5 */, /* spacesBetweenBraces */ true);\n                    }\n                    else {\n                        var multiLine = (node.flags & 2048 /* MultiLine */) !== 0;\n                        if (!multiLine) {\n                            write(\" \");\n                        }\n                        else {\n                            increaseIndent();\n                        }\n                        emitList(properties, 0, numElements, /*multiLine*/ multiLine, /*trailingComma*/ false);\n                        if (!multiLine) {\n                            write(\" \");\n                        }\n                        else {\n                            decreaseIndent();\n                        }\n                    }\n                }\n                write(\"}\");\n            }\n            function emitDownlevelObjectLiteralWithComputedProperties(node, firstComputedPropertyIndex) {\n                var multiLine = (node.flags & 2048 /* MultiLine */) !== 0;\n                var properties = node.properties;\n                write(\"(\");\n                if (multiLine) {\n                    increaseIndent();\n                }\n                // For computed properties, we need to create a unique handle to the object\n                // literal so we can modify it without risking internal assignments tainting the object.\n                var tempVar = createAndRecordTempVariable(0 /* Auto */);\n                // Write out the first non-computed properties\n                // (or all properties if none of them are computed),\n                // then emit the rest through indexing on the temp variable.\n                emit(tempVar);\n                write(\" = \");\n                emitObjectLiteralBody(node, firstComputedPropertyIndex);\n                for (var i = firstComputedPropertyIndex, n = properties.length; i < n; i++) {\n                    writeComma();\n                    var property = properties[i];\n                    emitStart(property);\n                    if (property.kind === 145 /* GetAccessor */ || property.kind === 146 /* SetAccessor */) {\n                        // TODO (drosen): Reconcile with 'emitMemberFunctions'.\n                        var accessors = ts.getAllAccessorDeclarations(node.properties, property);\n                        if (property !== accessors.firstAccessor) {\n                            continue;\n                        }\n                        write(\"Object.defineProperty(\");\n                        emit(tempVar);\n                        write(\", \");\n                        emitStart(node.name);\n                        emitExpressionForPropertyName(property.name);\n                        emitEnd(property.name);\n                        write(\", {\");\n                        increaseIndent();\n                        if (accessors.getAccessor) {\n                            writeLine();\n                            emitLeadingComments(accessors.getAccessor);\n                            write(\"get: \");\n                            emitStart(accessors.getAccessor);\n                            write(\"function \");\n                            emitSignatureAndBody(accessors.getAccessor);\n                            emitEnd(accessors.getAccessor);\n                            emitTrailingComments(accessors.getAccessor);\n                            write(\",\");\n                        }\n                        if (accessors.setAccessor) {\n                            writeLine();\n                            emitLeadingComments(accessors.setAccessor);\n                            write(\"set: \");\n                            emitStart(accessors.setAccessor);\n                            write(\"function \");\n                            emitSignatureAndBody(accessors.setAccessor);\n                            emitEnd(accessors.setAccessor);\n                            emitTrailingComments(accessors.setAccessor);\n                            write(\",\");\n                        }\n                        writeLine();\n                        write(\"enumerable: true,\");\n                        writeLine();\n                        write(\"configurable: true\");\n                        decreaseIndent();\n                        writeLine();\n                        write(\"})\");\n                        emitEnd(property);\n                    }\n                    else {\n                        emitLeadingComments(property);\n                        emitStart(property.name);\n                        emit(tempVar);\n                        emitMemberAccessForPropertyName(property.name);\n                        emitEnd(property.name);\n                        write(\" = \");\n                        if (property.kind === 245 /* PropertyAssignment */) {\n                            emit(property.initializer);\n                        }\n                        else if (property.kind === 246 /* ShorthandPropertyAssignment */) {\n                            emitExpressionIdentifier(property.name);\n                        }\n                        else if (property.kind === 143 /* MethodDeclaration */) {\n                            emitFunctionDeclaration(property);\n                        }\n                        else {\n                            ts.Debug.fail(\"ObjectLiteralElement type not accounted for: \" + property.kind);\n                        }\n                    }\n                    emitEnd(property);\n                }\n                writeComma();\n                emit(tempVar);\n                if (multiLine) {\n                    decreaseIndent();\n                    writeLine();\n                }\n                write(\")\");\n                function writeComma() {\n                    if (multiLine) {\n                        write(\",\");\n                        writeLine();\n                    }\n                    else {\n                        write(\", \");\n                    }\n                }\n            }\n            function emitObjectLiteral(node) {\n                var properties = node.properties;\n                if (languageVersion < 2 /* ES6 */) {\n                    var numProperties = properties.length;\n                    // Find the first computed property.\n                    // Everything until that point can be emitted as part of the initial object literal.\n                    var numInitialNonComputedProperties = numProperties;\n                    for (var i = 0, n = properties.length; i < n; i++) {\n                        if (properties[i].name.kind === 136 /* ComputedPropertyName */) {\n                            numInitialNonComputedProperties = i;\n                            break;\n                        }\n                    }\n                    var hasComputedProperty = numInitialNonComputedProperties !== properties.length;\n                    if (hasComputedProperty) {\n                        emitDownlevelObjectLiteralWithComputedProperties(node, numInitialNonComputedProperties);\n                        return;\n                    }\n                }\n                // Ordinary case: either the object has no computed properties\n                // or we're compiling with an ES6+ target.\n                emitObjectLiteralBody(node, properties.length);\n            }\n            function createBinaryExpression(left, operator, right, startsOnNewLine) {\n                var result = ts.createSynthesizedNode(181 /* BinaryExpression */, startsOnNewLine);\n                result.operatorToken = ts.createSynthesizedNode(operator);\n                result.left = left;\n                result.right = right;\n                return result;\n            }\n            function createPropertyAccessExpression(expression, name) {\n                var result = ts.createSynthesizedNode(166 /* PropertyAccessExpression */);\n                result.expression = parenthesizeForAccess(expression);\n                result.dotToken = ts.createSynthesizedNode(21 /* DotToken */);\n                result.name = name;\n                return result;\n            }\n            function createElementAccessExpression(expression, argumentExpression) {\n                var result = ts.createSynthesizedNode(167 /* ElementAccessExpression */);\n                result.expression = parenthesizeForAccess(expression);\n                result.argumentExpression = argumentExpression;\n                return result;\n            }\n            function parenthesizeForAccess(expr) {\n                // When diagnosing whether the expression needs parentheses, the decision should be based\n                // on the innermost expression in a chain of nested type assertions.\n                while (expr.kind === 171 /* TypeAssertionExpression */ || expr.kind === 189 /* AsExpression */) {\n                    expr = expr.expression;\n                }\n                // isLeftHandSideExpression is almost the correct criterion for when it is not necessary\n                // to parenthesize the expression before a dot. The known exceptions are:\n                //\n                //    NewExpression:\n                //       new C.x        -> not the same as (new C).x\n                //    NumberLiteral\n                //       1.x            -> not the same as (1).x\n                //\n                if (ts.isLeftHandSideExpression(expr) &&\n                    expr.kind !== 169 /* NewExpression */ &&\n                    expr.kind !== 8 /* NumericLiteral */) {\n                    return expr;\n                }\n                var node = ts.createSynthesizedNode(172 /* ParenthesizedExpression */);\n                node.expression = expr;\n                return node;\n            }\n            function emitComputedPropertyName(node) {\n                write(\"[\");\n                emitExpressionForPropertyName(node);\n                write(\"]\");\n            }\n            function emitMethod(node) {\n                if (languageVersion >= 2 /* ES6 */ && node.asteriskToken) {\n                    write(\"*\");\n                }\n                emit(node.name);\n                if (languageVersion < 2 /* ES6 */) {\n                    write(\": function \");\n                }\n                emitSignatureAndBody(node);\n            }\n            function emitPropertyAssignment(node) {\n                emit(node.name);\n                write(\": \");\n                // This is to ensure that we emit comment in the following case:\n                //      For example:\n                //          obj = {\n                //              id: /*comment1*/ ()=>void\n                //          }\n                // \"comment1\" is not considered to be leading comment for node.initializer\n                // but rather a trailing comment on the previous node.\n                emitTrailingCommentsOfPosition(node.initializer.pos);\n                emit(node.initializer);\n            }\n            // Return true if identifier resolves to an exported member of a namespace\n            function isNamespaceExportReference(node) {\n                var container = resolver.getReferencedExportContainer(node);\n                return container && container.kind !== 248 /* SourceFile */;\n            }\n            function emitShorthandPropertyAssignment(node) {\n                // The name property of a short-hand property assignment is considered an expression position, so here\n                // we manually emit the identifier to avoid rewriting.\n                writeTextOfNode(currentSourceFile, node.name);\n                // If emitting pre-ES6 code, or if the name requires rewriting when resolved as an expression identifier,\n                // we emit a normal property assignment. For example:\n                //   module m {\n                //       export let y;\n                //   }\n                //   module m {\n                //       let obj = { y };\n                //   }\n                // Here we need to emit obj = { y : m.y } regardless of the output target.\n                if (languageVersion < 2 /* ES6 */ || isNamespaceExportReference(node.name)) {\n                    // Emit identifier as an identifier\n                    write(\": \");\n                    emit(node.name);\n                }\n                if (languageVersion >= 2 /* ES6 */ && node.objectAssignmentInitializer) {\n                    write(\" = \");\n                    emit(node.objectAssignmentInitializer);\n                }\n            }\n            function tryEmitConstantValue(node) {\n                var constantValue = tryGetConstEnumValue(node);\n                if (constantValue !== undefined) {\n                    write(constantValue.toString());\n                    if (!compilerOptions.removeComments) {\n                        var propertyName = node.kind === 166 /* PropertyAccessExpression */ ? ts.declarationNameToString(node.name) : ts.getTextOfNode(node.argumentExpression);\n                        write(\" /* \" + propertyName + \" */\");\n                    }\n                    return true;\n                }\n                return false;\n            }\n            function tryGetConstEnumValue(node) {\n                if (compilerOptions.isolatedModules) {\n                    return undefined;\n                }\n                return node.kind === 166 /* PropertyAccessExpression */ || node.kind === 167 /* ElementAccessExpression */\n                    ? resolver.getConstantValue(node)\n                    : undefined;\n            }\n            // Returns 'true' if the code was actually indented, false otherwise.\n            // If the code is not indented, an optional valueToWriteWhenNotIndenting will be\n            // emitted instead.\n            function indentIfOnDifferentLines(parent, node1, node2, valueToWriteWhenNotIndenting) {\n                var realNodesAreOnDifferentLines = !ts.nodeIsSynthesized(parent) && !nodeEndIsOnSameLineAsNodeStart(node1, node2);\n                // Always use a newline for synthesized code if the synthesizer desires it.\n                var synthesizedNodeIsOnDifferentLine = synthesizedNodeStartsOnNewLine(node2);\n                if (realNodesAreOnDifferentLines || synthesizedNodeIsOnDifferentLine) {\n                    increaseIndent();\n                    writeLine();\n                    return true;\n                }\n                else {\n                    if (valueToWriteWhenNotIndenting) {\n                        write(valueToWriteWhenNotIndenting);\n                    }\n                    return false;\n                }\n            }\n            function emitPropertyAccess(node) {\n                if (tryEmitConstantValue(node)) {\n                    return;\n                }\n                emit(node.expression);\n                var indentedBeforeDot = indentIfOnDifferentLines(node, node.expression, node.dotToken);\n                // 1 .toString is a valid property access, emit a space after the literal\n                // Also emit a space if expression is a integer const enum value - it will appear in generated code as numeric literal\n                var shouldEmitSpace;\n                if (!indentedBeforeDot) {\n                    if (node.expression.kind === 8 /* NumericLiteral */) {\n                        // check if numeric literal was originally written with a dot\n                        var text = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node.expression);\n                        shouldEmitSpace = text.indexOf(ts.tokenToString(21 /* DotToken */)) < 0;\n                    }\n                    else {\n                        // check if constant enum value is integer\n                        var constantValue = tryGetConstEnumValue(node.expression);\n                        // isFinite handles cases when constantValue is undefined\n                        shouldEmitSpace = isFinite(constantValue) && Math.floor(constantValue) === constantValue;\n                    }\n                }\n                if (shouldEmitSpace) {\n                    write(\" .\");\n                }\n                else {\n                    write(\".\");\n                }\n                var indentedAfterDot = indentIfOnDifferentLines(node, node.dotToken, node.name);\n                emit(node.name);\n                decreaseIndentIf(indentedBeforeDot, indentedAfterDot);\n            }\n            function emitQualifiedName(node) {\n                emit(node.left);\n                write(\".\");\n                emit(node.right);\n            }\n            function emitQualifiedNameAsExpression(node, useFallback) {\n                if (node.left.kind === 69 /* Identifier */) {\n                    emitEntityNameAsExpression(node.left, useFallback);\n                }\n                else if (useFallback) {\n                    var temp = createAndRecordTempVariable(0 /* Auto */);\n                    write(\"(\");\n                    emitNodeWithoutSourceMap(temp);\n                    write(\" = \");\n                    emitEntityNameAsExpression(node.left, /*useFallback*/ true);\n                    write(\") && \");\n                    emitNodeWithoutSourceMap(temp);\n                }\n                else {\n                    emitEntityNameAsExpression(node.left, /*useFallback*/ false);\n                }\n                write(\".\");\n                emit(node.right);\n            }\n            function emitEntityNameAsExpression(node, useFallback) {\n                switch (node.kind) {\n                    case 69 /* Identifier */:\n                        if (useFallback) {\n                            write(\"typeof \");\n                            emitExpressionIdentifier(node);\n                            write(\" !== 'undefined' && \");\n                        }\n                        emitExpressionIdentifier(node);\n                        break;\n                    case 135 /* QualifiedName */:\n                        emitQualifiedNameAsExpression(node, useFallback);\n                        break;\n                }\n            }\n            function emitIndexedAccess(node) {\n                if (tryEmitConstantValue(node)) {\n                    return;\n                }\n                emit(node.expression);\n                write(\"[\");\n                emit(node.argumentExpression);\n                write(\"]\");\n            }\n            function hasSpreadElement(elements) {\n                return ts.forEach(elements, function (e) { return e.kind === 185 /* SpreadElementExpression */; });\n            }\n            function skipParentheses(node) {\n                while (node.kind === 172 /* ParenthesizedExpression */ || node.kind === 171 /* TypeAssertionExpression */ || node.kind === 189 /* AsExpression */) {\n                    node = node.expression;\n                }\n                return node;\n            }\n            function emitCallTarget(node) {\n                if (node.kind === 69 /* Identifier */ || node.kind === 97 /* ThisKeyword */ || node.kind === 95 /* SuperKeyword */) {\n                    emit(node);\n                    return node;\n                }\n                var temp = createAndRecordTempVariable(0 /* Auto */);\n                write(\"(\");\n                emit(temp);\n                write(\" = \");\n                emit(node);\n                write(\")\");\n                return temp;\n            }\n            function emitCallWithSpread(node) {\n                var target;\n                var expr = skipParentheses(node.expression);\n                if (expr.kind === 166 /* PropertyAccessExpression */) {\n                    // Target will be emitted as \"this\" argument\n                    target = emitCallTarget(expr.expression);\n                    write(\".\");\n                    emit(expr.name);\n                }\n                else if (expr.kind === 167 /* ElementAccessExpression */) {\n                    // Target will be emitted as \"this\" argument\n                    target = emitCallTarget(expr.expression);\n                    write(\"[\");\n                    emit(expr.argumentExpression);\n                    write(\"]\");\n                }\n                else if (expr.kind === 95 /* SuperKeyword */) {\n                    target = expr;\n                    write(\"_super\");\n                }\n                else {\n                    emit(node.expression);\n                }\n                write(\".apply(\");\n                if (target) {\n                    if (target.kind === 95 /* SuperKeyword */) {\n                        // Calls of form super(...) and super.foo(...)\n                        emitThis(target);\n                    }\n                    else {\n                        // Calls of form obj.foo(...)\n                        emit(target);\n                    }\n                }\n                else {\n                    // Calls of form foo(...)\n                    write(\"void 0\");\n                }\n                write(\", \");\n                emitListWithSpread(node.arguments, /*needsUniqueCopy*/ false, /*multiLine*/ false, /*trailingComma*/ false, /*useConcat*/ true);\n                write(\")\");\n            }\n            function emitCallExpression(node) {\n                if (languageVersion < 2 /* ES6 */ && hasSpreadElement(node.arguments)) {\n                    emitCallWithSpread(node);\n                    return;\n                }\n                var superCall = false;\n                if (node.expression.kind === 95 /* SuperKeyword */) {\n                    emitSuper(node.expression);\n                    superCall = true;\n                }\n                else {\n                    emit(node.expression);\n                    superCall = node.expression.kind === 166 /* PropertyAccessExpression */ && node.expression.expression.kind === 95 /* SuperKeyword */;\n                }\n                if (superCall && languageVersion < 2 /* ES6 */) {\n                    write(\".call(\");\n                    emitThis(node.expression);\n                    if (node.arguments.length) {\n                        write(\", \");\n                        emitCommaList(node.arguments);\n                    }\n                    write(\")\");\n                }\n                else {\n                    write(\"(\");\n                    emitCommaList(node.arguments);\n                    write(\")\");\n                }\n            }\n            function emitNewExpression(node) {\n                write(\"new \");\n                // Spread operator logic is supported in new expressions in ES5 using a combination\n                // of Function.prototype.bind() and Function.prototype.apply().\n                //\n                //     Example:\n                //\n                //         var args = [1, 2, 3, 4, 5];\n                //         new Array(...args);\n                //\n                //     is compiled into the following ES5:\n                //\n                //         var args = [1, 2, 3, 4, 5];\n                //         new (Array.bind.apply(Array, [void 0].concat(args)));\n                //\n                // The 'thisArg' to 'bind' is ignored when invoking the result of 'bind' with 'new',\n                // Thus, we set it to undefined ('void 0').\n                if (languageVersion === 1 /* ES5 */ &&\n                    node.arguments &&\n                    hasSpreadElement(node.arguments)) {\n                    write(\"(\");\n                    var target = emitCallTarget(node.expression);\n                    write(\".bind.apply(\");\n                    emit(target);\n                    write(\", [void 0].concat(\");\n                    emitListWithSpread(node.arguments, /*needsUniqueCopy*/ false, /*multiline*/ false, /*trailingComma*/ false, /*useConcat*/ false);\n                    write(\")))\");\n                    write(\"()\");\n                }\n                else {\n                    emit(node.expression);\n                    if (node.arguments) {\n                        write(\"(\");\n                        emitCommaList(node.arguments);\n                        write(\")\");\n                    }\n                }\n            }\n            function emitTaggedTemplateExpression(node) {\n                if (languageVersion >= 2 /* ES6 */) {\n                    emit(node.tag);\n                    write(\" \");\n                    emit(node.template);\n                }\n                else {\n                    emitDownlevelTaggedTemplate(node);\n                }\n            }\n            function emitParenExpression(node) {\n                // If the node is synthesized, it means the emitter put the parentheses there,\n                // not the user. If we didn't want them, the emitter would not have put them\n                // there.\n                if (!ts.nodeIsSynthesized(node) && node.parent.kind !== 174 /* ArrowFunction */) {\n                    if (node.expression.kind === 171 /* TypeAssertionExpression */ || node.expression.kind === 189 /* AsExpression */) {\n                        var operand = node.expression.expression;\n                        // Make sure we consider all nested cast expressions, e.g.:\n                        // (<any><number><any>-A).x;\n                        while (operand.kind === 171 /* TypeAssertionExpression */ || operand.kind === 189 /* AsExpression */) {\n                            operand = operand.expression;\n                        }\n                        // We have an expression of the form: (<Type>SubExpr)\n                        // Emitting this as (SubExpr) is really not desirable. We would like to emit the subexpr as is.\n                        // Omitting the parentheses, however, could cause change in the semantics of the generated\n                        // code if the casted expression has a lower precedence than the rest of the expression, e.g.:\n                        //      (<any>new A).foo should be emitted as (new A).foo and not new A.foo\n                        //      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()\n                        //      new (<any>A()) should be emitted as new (A()) and not new A()\n                        //      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()\n                        if (operand.kind !== 179 /* PrefixUnaryExpression */ &&\n                            operand.kind !== 177 /* VoidExpression */ &&\n                            operand.kind !== 176 /* TypeOfExpression */ &&\n                            operand.kind !== 175 /* DeleteExpression */ &&\n                            operand.kind !== 180 /* PostfixUnaryExpression */ &&\n                            operand.kind !== 169 /* NewExpression */ &&\n                            !(operand.kind === 168 /* CallExpression */ && node.parent.kind === 169 /* NewExpression */) &&\n                            !(operand.kind === 173 /* FunctionExpression */ && node.parent.kind === 168 /* CallExpression */) &&\n                            !(operand.kind === 8 /* NumericLiteral */ && node.parent.kind === 166 /* PropertyAccessExpression */)) {\n                            emit(operand);\n                            return;\n                        }\n                    }\n                }\n                write(\"(\");\n                emit(node.expression);\n                write(\")\");\n            }\n            function emitDeleteExpression(node) {\n                write(ts.tokenToString(78 /* DeleteKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function emitVoidExpression(node) {\n                write(ts.tokenToString(103 /* VoidKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function emitTypeOfExpression(node) {\n                write(ts.tokenToString(101 /* TypeOfKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node) {\n                if (!isCurrentFileSystemExternalModule() || node.kind !== 69 /* Identifier */ || ts.nodeIsSynthesized(node)) {\n                    return false;\n                }\n                var isVariableDeclarationOrBindingElement = node.parent && (node.parent.kind === 211 /* VariableDeclaration */ || node.parent.kind === 163 /* BindingElement */);\n                var targetDeclaration = isVariableDeclarationOrBindingElement\n                    ? node.parent\n                    : resolver.getReferencedValueDeclaration(node);\n                return isSourceFileLevelDeclarationInSystemJsModule(targetDeclaration, /*isExported*/ true);\n            }\n            function emitPrefixUnaryExpression(node) {\n                var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node.operand);\n                if (exportChanged) {\n                    // emit\n                    // ++x\n                    // as\n                    // exports('x', ++x)\n                    write(exportFunctionForFile + \"(\\\"\");\n                    emitNodeWithoutSourceMap(node.operand);\n                    write(\"\\\", \");\n                }\n                write(ts.tokenToString(node.operator));\n                // In some cases, we need to emit a space between the operator and the operand. One obvious case\n                // is when the operator is an identifier, like delete or typeof. We also need to do this for plus\n                // and minus expressions in certain cases. Specifically, consider the following two cases (parens\n                // are just for clarity of exposition, and not part of the source code):\n                //\n                //  (+(+1))\n                //  (+(++1))\n                //\n                // We need to emit a space in both cases. In the first case, the absence of a space will make\n                // the resulting expression a prefix increment operation. And in the second, it will make the resulting\n                // expression a prefix increment whose operand is a plus expression - (++(+x))\n                // The same is true of minus of course.\n                if (node.operand.kind === 179 /* PrefixUnaryExpression */) {\n                    var operand = node.operand;\n                    if (node.operator === 35 /* PlusToken */ && (operand.operator === 35 /* PlusToken */ || operand.operator === 41 /* PlusPlusToken */)) {\n                        write(\" \");\n                    }\n                    else if (node.operator === 36 /* MinusToken */ && (operand.operator === 36 /* MinusToken */ || operand.operator === 42 /* MinusMinusToken */)) {\n                        write(\" \");\n                    }\n                }\n                emit(node.operand);\n                if (exportChanged) {\n                    write(\")\");\n                }\n            }\n            function emitPostfixUnaryExpression(node) {\n                var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node.operand);\n                if (exportChanged) {\n                    // export function returns the value that was passes as the second argument\n                    // however for postfix unary expressions result value should be the value before modification.\n                    // emit 'x++' as '(export('x', ++x) - 1)' and 'x--' as '(export('x', --x) + 1)'\n                    write(\"(\" + exportFunctionForFile + \"(\\\"\");\n                    emitNodeWithoutSourceMap(node.operand);\n                    write(\"\\\", \");\n                    write(ts.tokenToString(node.operator));\n                    emit(node.operand);\n                    if (node.operator === 41 /* PlusPlusToken */) {\n                        write(\") - 1)\");\n                    }\n                    else {\n                        write(\") + 1)\");\n                    }\n                }\n                else {\n                    emit(node.operand);\n                    write(ts.tokenToString(node.operator));\n                }\n            }\n            function shouldHoistDeclarationInSystemJsModule(node) {\n                return isSourceFileLevelDeclarationInSystemJsModule(node, /*isExported*/ false);\n            }\n            /*\n             * Checks if given node is a source file level declaration (not nested in module/function).\n             * If 'isExported' is true - then declaration must also be exported.\n             * This function is used in two cases:\n             * - check if node is a exported source file level value to determine\n             *   if we should also export the value after its it changed\n             * - check if node is a source level declaration to emit it differently,\n             *   i.e non-exported variable statement 'var x = 1' is hoisted so\n             *   we we emit variable statement 'var' should be dropped.\n             */\n            function isSourceFileLevelDeclarationInSystemJsModule(node, isExported) {\n                if (!node || languageVersion >= 2 /* ES6 */ || !isCurrentFileSystemExternalModule()) {\n                    return false;\n                }\n                var current = node;\n                while (current) {\n                    if (current.kind === 248 /* SourceFile */) {\n                        return !isExported || ((ts.getCombinedNodeFlags(node) & 1 /* Export */) !== 0);\n                    }\n                    else if (ts.isFunctionLike(current) || current.kind === 219 /* ModuleBlock */) {\n                        return false;\n                    }\n                    else {\n                        current = current.parent;\n                    }\n                }\n            }\n            /**\n             * Emit ES7 exponentiation operator downlevel using Math.pow\n             * @param node a binary expression node containing exponentiationOperator (**, **=)\n             */\n            function emitExponentiationOperator(node) {\n                var leftHandSideExpression = node.left;\n                if (node.operatorToken.kind === 60 /* AsteriskAsteriskEqualsToken */) {\n                    var synthesizedLHS;\n                    var shouldEmitParentheses = false;\n                    if (ts.isElementAccessExpression(leftHandSideExpression)) {\n                        shouldEmitParentheses = true;\n                        write(\"(\");\n                        synthesizedLHS = ts.createSynthesizedNode(167 /* ElementAccessExpression */, /*startsOnNewLine*/ false);\n                        var identifier = emitTempVariableAssignment(leftHandSideExpression.expression, /*canDefinedTempVariablesInPlaces*/ false, /*shouldEmitCommaBeforeAssignment*/ false);\n                        synthesizedLHS.expression = identifier;\n                        if (leftHandSideExpression.argumentExpression.kind !== 8 /* NumericLiteral */ &&\n                            leftHandSideExpression.argumentExpression.kind !== 9 /* StringLiteral */) {\n                            var tempArgumentExpression = createAndRecordTempVariable(268435456 /* _i */);\n                            synthesizedLHS.argumentExpression = tempArgumentExpression;\n                            emitAssignment(tempArgumentExpression, leftHandSideExpression.argumentExpression, /*shouldEmitCommaBeforeAssignment*/ true);\n                        }\n                        else {\n                            synthesizedLHS.argumentExpression = leftHandSideExpression.argumentExpression;\n                        }\n                        write(\", \");\n                    }\n                    else if (ts.isPropertyAccessExpression(leftHandSideExpression)) {\n                        shouldEmitParentheses = true;\n                        write(\"(\");\n                        synthesizedLHS = ts.createSynthesizedNode(166 /* PropertyAccessExpression */, /*startsOnNewLine*/ false);\n                        var identifier = emitTempVariableAssignment(leftHandSideExpression.expression, /*canDefinedTempVariablesInPlaces*/ false, /*shouldemitCommaBeforeAssignment*/ false);\n                        synthesizedLHS.expression = identifier;\n                        synthesizedLHS.dotToken = leftHandSideExpression.dotToken;\n                        synthesizedLHS.name = leftHandSideExpression.name;\n                        write(\", \");\n                    }\n                    emit(synthesizedLHS || leftHandSideExpression);\n                    write(\" = \");\n                    write(\"Math.pow(\");\n                    emit(synthesizedLHS || leftHandSideExpression);\n                    write(\", \");\n                    emit(node.right);\n                    write(\")\");\n                    if (shouldEmitParentheses) {\n                        write(\")\");\n                    }\n                }\n                else {\n                    write(\"Math.pow(\");\n                    emit(leftHandSideExpression);\n                    write(\", \");\n                    emit(node.right);\n                    write(\")\");\n                }\n            }\n            function emitBinaryExpression(node) {\n                if (languageVersion < 2 /* ES6 */ && node.operatorToken.kind === 56 /* EqualsToken */ &&\n                    (node.left.kind === 165 /* ObjectLiteralExpression */ || node.left.kind === 164 /* ArrayLiteralExpression */)) {\n                    emitDestructuring(node, node.parent.kind === 195 /* ExpressionStatement */);\n                }\n                else {\n                    var exportChanged = node.operatorToken.kind >= 56 /* FirstAssignment */ &&\n                        node.operatorToken.kind <= 68 /* LastAssignment */ &&\n                        isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node.left);\n                    if (exportChanged) {\n                        // emit assignment 'x <op> y' as 'exports(\"x\", x <op> y)'\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitNodeWithoutSourceMap(node.left);\n                        write(\"\\\", \");\n                    }\n                    if (node.operatorToken.kind === 38 /* AsteriskAsteriskToken */ || node.operatorToken.kind === 60 /* AsteriskAsteriskEqualsToken */) {\n                        // Downleveled emit exponentiation operator using Math.pow\n                        emitExponentiationOperator(node);\n                    }\n                    else {\n                        emit(node.left);\n                        // Add indentation before emit the operator if the operator is on different line\n                        // For example:\n                        //      3\n                        //      + 2;\n                        //   emitted as\n                        //      3\n                        //          + 2;\n                        var indentedBeforeOperator = indentIfOnDifferentLines(node, node.left, node.operatorToken, node.operatorToken.kind !== 24 /* CommaToken */ ? \" \" : undefined);\n                        write(ts.tokenToString(node.operatorToken.kind));\n                        var indentedAfterOperator = indentIfOnDifferentLines(node, node.operatorToken, node.right, \" \");\n                        emit(node.right);\n                        decreaseIndentIf(indentedBeforeOperator, indentedAfterOperator);\n                    }\n                    if (exportChanged) {\n                        write(\")\");\n                    }\n                }\n            }\n            function synthesizedNodeStartsOnNewLine(node) {\n                return ts.nodeIsSynthesized(node) && node.startsOnNewLine;\n            }\n            function emitConditionalExpression(node) {\n                emit(node.condition);\n                var indentedBeforeQuestion = indentIfOnDifferentLines(node, node.condition, node.questionToken, \" \");\n                write(\"?\");\n                var indentedAfterQuestion = indentIfOnDifferentLines(node, node.questionToken, node.whenTrue, \" \");\n                emit(node.whenTrue);\n                decreaseIndentIf(indentedBeforeQuestion, indentedAfterQuestion);\n                var indentedBeforeColon = indentIfOnDifferentLines(node, node.whenTrue, node.colonToken, \" \");\n                write(\":\");\n                var indentedAfterColon = indentIfOnDifferentLines(node, node.colonToken, node.whenFalse, \" \");\n                emit(node.whenFalse);\n                decreaseIndentIf(indentedBeforeColon, indentedAfterColon);\n            }\n            // Helper function to decrease the indent if we previously indented.  Allows multiple\n            // previous indent values to be considered at a time.  This also allows caller to just\n            // call this once, passing in all their appropriate indent values, instead of needing\n            // to call this helper function multiple times.\n            function decreaseIndentIf(value1, value2) {\n                if (value1) {\n                    decreaseIndent();\n                }\n                if (value2) {\n                    decreaseIndent();\n                }\n            }\n            function isSingleLineEmptyBlock(node) {\n                if (node && node.kind === 192 /* Block */) {\n                    var block = node;\n                    return block.statements.length === 0 && nodeEndIsOnSameLineAsNodeStart(block, block);\n                }\n            }\n            function emitBlock(node) {\n                if (isSingleLineEmptyBlock(node)) {\n                    emitToken(15 /* OpenBraceToken */, node.pos);\n                    write(\" \");\n                    emitToken(16 /* CloseBraceToken */, node.statements.end);\n                    return;\n                }\n                emitToken(15 /* OpenBraceToken */, node.pos);\n                increaseIndent();\n                scopeEmitStart(node.parent);\n                if (node.kind === 219 /* ModuleBlock */) {\n                    ts.Debug.assert(node.parent.kind === 218 /* ModuleDeclaration */);\n                    emitCaptureThisForNodeIfNecessary(node.parent);\n                }\n                emitLines(node.statements);\n                if (node.kind === 219 /* ModuleBlock */) {\n                    emitTempDeclarations(/*newLine*/ true);\n                }\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.statements.end);\n                scopeEmitEnd();\n            }\n            function emitEmbeddedStatement(node) {\n                if (node.kind === 192 /* Block */) {\n                    write(\" \");\n                    emit(node);\n                }\n                else {\n                    increaseIndent();\n                    writeLine();\n                    emit(node);\n                    decreaseIndent();\n                }\n            }\n            function emitExpressionStatement(node) {\n                emitParenthesizedIf(node.expression, /*parenthesized*/ node.expression.kind === 174 /* ArrowFunction */);\n                write(\";\");\n            }\n            function emitIfStatement(node) {\n                var endPos = emitToken(88 /* IfKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(17 /* OpenParenToken */, endPos);\n                emit(node.expression);\n                emitToken(18 /* CloseParenToken */, node.expression.end);\n                emitEmbeddedStatement(node.thenStatement);\n                if (node.elseStatement) {\n                    writeLine();\n                    emitToken(80 /* ElseKeyword */, node.thenStatement.end);\n                    if (node.elseStatement.kind === 196 /* IfStatement */) {\n                        write(\" \");\n                        emit(node.elseStatement);\n                    }\n                    else {\n                        emitEmbeddedStatement(node.elseStatement);\n                    }\n                }\n            }\n            function emitDoStatement(node) {\n                write(\"do\");\n                emitEmbeddedStatement(node.statement);\n                if (node.statement.kind === 192 /* Block */) {\n                    write(\" \");\n                }\n                else {\n                    writeLine();\n                }\n                write(\"while (\");\n                emit(node.expression);\n                write(\");\");\n            }\n            function emitWhileStatement(node) {\n                write(\"while (\");\n                emit(node.expression);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            /**\n             * Returns true if start of variable declaration list was emitted.\n             * Returns false if nothing was written - this can happen for source file level variable declarations\n             *     in system modules where such variable declarations are hoisted.\n             */\n            function tryEmitStartOfVariableDeclarationList(decl, startPos) {\n                if (shouldHoistVariable(decl, /*checkIfSourceFileLevelDecl*/ true)) {\n                    // variables in variable declaration list were already hoisted\n                    return false;\n                }\n                var tokenKind = 102 /* VarKeyword */;\n                if (decl && languageVersion >= 2 /* ES6 */) {\n                    if (ts.isLet(decl)) {\n                        tokenKind = 108 /* LetKeyword */;\n                    }\n                    else if (ts.isConst(decl)) {\n                        tokenKind = 74 /* ConstKeyword */;\n                    }\n                }\n                if (startPos !== undefined) {\n                    emitToken(tokenKind, startPos);\n                    write(\" \");\n                }\n                else {\n                    switch (tokenKind) {\n                        case 102 /* VarKeyword */:\n                            write(\"var \");\n                            break;\n                        case 108 /* LetKeyword */:\n                            write(\"let \");\n                            break;\n                        case 74 /* ConstKeyword */:\n                            write(\"const \");\n                            break;\n                    }\n                }\n                return true;\n            }\n            function emitVariableDeclarationListSkippingUninitializedEntries(list) {\n                var started = false;\n                for (var _a = 0, _b = list.declarations; _a < _b.length; _a++) {\n                    var decl = _b[_a];\n                    if (!decl.initializer) {\n                        continue;\n                    }\n                    if (!started) {\n                        started = true;\n                    }\n                    else {\n                        write(\", \");\n                    }\n                    emit(decl);\n                }\n                return started;\n            }\n            function emitForStatement(node) {\n                var endPos = emitToken(86 /* ForKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(17 /* OpenParenToken */, endPos);\n                if (node.initializer && node.initializer.kind === 212 /* VariableDeclarationList */) {\n                    var variableDeclarationList = node.initializer;\n                    var startIsEmitted = tryEmitStartOfVariableDeclarationList(variableDeclarationList, endPos);\n                    if (startIsEmitted) {\n                        emitCommaList(variableDeclarationList.declarations);\n                    }\n                    else {\n                        emitVariableDeclarationListSkippingUninitializedEntries(variableDeclarationList);\n                    }\n                }\n                else if (node.initializer) {\n                    emit(node.initializer);\n                }\n                write(\";\");\n                emitOptional(\" \", node.condition);\n                write(\";\");\n                emitOptional(\" \", node.incrementor);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitForInOrForOfStatement(node) {\n                if (languageVersion < 2 /* ES6 */ && node.kind === 201 /* ForOfStatement */) {\n                    return emitDownLevelForOfStatement(node);\n                }\n                var endPos = emitToken(86 /* ForKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(17 /* OpenParenToken */, endPos);\n                if (node.initializer.kind === 212 /* VariableDeclarationList */) {\n                    var variableDeclarationList = node.initializer;\n                    if (variableDeclarationList.declarations.length >= 1) {\n                        tryEmitStartOfVariableDeclarationList(variableDeclarationList, endPos);\n                        emit(variableDeclarationList.declarations[0]);\n                    }\n                }\n                else {\n                    emit(node.initializer);\n                }\n                if (node.kind === 200 /* ForInStatement */) {\n                    write(\" in \");\n                }\n                else {\n                    write(\" of \");\n                }\n                emit(node.expression);\n                emitToken(18 /* CloseParenToken */, node.expression.end);\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitDownLevelForOfStatement(node) {\n                // The following ES6 code:\n                //\n                //    for (let v of expr) { }\n                //\n                // should be emitted as\n                //\n                //    for (let _i = 0, _a = expr; _i < _a.length; _i++) {\n                //        let v = _a[_i];\n                //    }\n                //\n                // where _a and _i are temps emitted to capture the RHS and the counter,\n                // respectively.\n                // When the left hand side is an expression instead of a let declaration,\n                // the \"let v\" is not emitted.\n                // When the left hand side is a let/const, the v is renamed if there is\n                // another v in scope.\n                // Note that all assignments to the LHS are emitted in the body, including\n                // all destructuring.\n                // Note also that because an extra statement is needed to assign to the LHS,\n                // for-of bodies are always emitted as blocks.\n                var endPos = emitToken(86 /* ForKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(17 /* OpenParenToken */, endPos);\n                // Do not emit the LHS let declaration yet, because it might contain destructuring.\n                // Do not call recordTempDeclaration because we are declaring the temps\n                // right here. Recording means they will be declared later.\n                // In the case where the user wrote an identifier as the RHS, like this:\n                //\n                //     for (let v of arr) { }\n                //\n                // we don't want to emit a temporary variable for the RHS, just use it directly.\n                var rhsIsIdentifier = node.expression.kind === 69 /* Identifier */;\n                var counter = createTempVariable(268435456 /* _i */);\n                var rhsReference = rhsIsIdentifier ? node.expression : createTempVariable(0 /* Auto */);\n                // This is the let keyword for the counter and rhsReference. The let keyword for\n                // the LHS will be emitted inside the body.\n                emitStart(node.expression);\n                write(\"var \");\n                // _i = 0\n                emitNodeWithoutSourceMap(counter);\n                write(\" = 0\");\n                emitEnd(node.expression);\n                if (!rhsIsIdentifier) {\n                    // , _a = expr\n                    write(\", \");\n                    emitStart(node.expression);\n                    emitNodeWithoutSourceMap(rhsReference);\n                    write(\" = \");\n                    emitNodeWithoutSourceMap(node.expression);\n                    emitEnd(node.expression);\n                }\n                write(\"; \");\n                // _i < _a.length;\n                emitStart(node.initializer);\n                emitNodeWithoutSourceMap(counter);\n                write(\" < \");\n                emitNodeWithCommentsAndWithoutSourcemap(rhsReference);\n                write(\".length\");\n                emitEnd(node.initializer);\n                write(\"; \");\n                // _i++)\n                emitStart(node.initializer);\n                emitNodeWithoutSourceMap(counter);\n                write(\"++\");\n                emitEnd(node.initializer);\n                emitToken(18 /* CloseParenToken */, node.expression.end);\n                // Body\n                write(\" {\");\n                writeLine();\n                increaseIndent();\n                // Initialize LHS\n                // let v = _a[_i];\n                var rhsIterationValue = createElementAccessExpression(rhsReference, counter);\n                emitStart(node.initializer);\n                if (node.initializer.kind === 212 /* VariableDeclarationList */) {\n                    write(\"var \");\n                    var variableDeclarationList = node.initializer;\n                    if (variableDeclarationList.declarations.length > 0) {\n                        var declaration = variableDeclarationList.declarations[0];\n                        if (ts.isBindingPattern(declaration.name)) {\n                            // This works whether the declaration is a var, let, or const.\n                            // It will use rhsIterationValue _a[_i] as the initializer.\n                            emitDestructuring(declaration, /*isAssignmentExpressionStatement*/ false, rhsIterationValue);\n                        }\n                        else {\n                            // The following call does not include the initializer, so we have\n                            // to emit it separately.\n                            emitNodeWithCommentsAndWithoutSourcemap(declaration);\n                            write(\" = \");\n                            emitNodeWithoutSourceMap(rhsIterationValue);\n                        }\n                    }\n                    else {\n                        // It's an empty declaration list. This can only happen in an error case, if the user wrote\n                        //     for (let of []) {}\n                        emitNodeWithoutSourceMap(createTempVariable(0 /* Auto */));\n                        write(\" = \");\n                        emitNodeWithoutSourceMap(rhsIterationValue);\n                    }\n                }\n                else {\n                    // Initializer is an expression. Emit the expression in the body, so that it's\n                    // evaluated on every iteration.\n                    var assignmentExpression = createBinaryExpression(node.initializer, 56 /* EqualsToken */, rhsIterationValue, /*startsOnNewLine*/ false);\n                    if (node.initializer.kind === 164 /* ArrayLiteralExpression */ || node.initializer.kind === 165 /* ObjectLiteralExpression */) {\n                        // This is a destructuring pattern, so call emitDestructuring instead of emit. Calling emit will not work, because it will cause\n                        // the BinaryExpression to be passed in instead of the expression statement, which will cause emitDestructuring to crash.\n                        emitDestructuring(assignmentExpression, /*isAssignmentExpressionStatement*/ true, /*value*/ undefined);\n                    }\n                    else {\n                        emitNodeWithCommentsAndWithoutSourcemap(assignmentExpression);\n                    }\n                }\n                emitEnd(node.initializer);\n                write(\";\");\n                if (node.statement.kind === 192 /* Block */) {\n                    emitLines(node.statement.statements);\n                }\n                else {\n                    writeLine();\n                    emit(node.statement);\n                }\n                writeLine();\n                decreaseIndent();\n                write(\"}\");\n            }\n            function emitBreakOrContinueStatement(node) {\n                emitToken(node.kind === 203 /* BreakStatement */ ? 70 /* BreakKeyword */ : 75 /* ContinueKeyword */, node.pos);\n                emitOptional(\" \", node.label);\n                write(\";\");\n            }\n            function emitReturnStatement(node) {\n                emitToken(94 /* ReturnKeyword */, node.pos);\n                emitOptional(\" \", node.expression);\n                write(\";\");\n            }\n            function emitWithStatement(node) {\n                write(\"with (\");\n                emit(node.expression);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitSwitchStatement(node) {\n                var endPos = emitToken(96 /* SwitchKeyword */, node.pos);\n                write(\" \");\n                emitToken(17 /* OpenParenToken */, endPos);\n                emit(node.expression);\n                endPos = emitToken(18 /* CloseParenToken */, node.expression.end);\n                write(\" \");\n                emitCaseBlock(node.caseBlock, endPos);\n            }\n            function emitCaseBlock(node, startPos) {\n                emitToken(15 /* OpenBraceToken */, startPos);\n                increaseIndent();\n                emitLines(node.clauses);\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.clauses.end);\n            }\n            function nodeStartPositionsAreOnSameLine(node1, node2) {\n                return ts.getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node1.pos)) ===\n                    ts.getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node2.pos));\n            }\n            function nodeEndPositionsAreOnSameLine(node1, node2) {\n                return ts.getLineOfLocalPosition(currentSourceFile, node1.end) ===\n                    ts.getLineOfLocalPosition(currentSourceFile, node2.end);\n            }\n            function nodeEndIsOnSameLineAsNodeStart(node1, node2) {\n                return ts.getLineOfLocalPosition(currentSourceFile, node1.end) ===\n                    ts.getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node2.pos));\n            }\n            function emitCaseOrDefaultClause(node) {\n                if (node.kind === 241 /* CaseClause */) {\n                    write(\"case \");\n                    emit(node.expression);\n                    write(\":\");\n                }\n                else {\n                    write(\"default:\");\n                }\n                if (node.statements.length === 1 && nodeStartPositionsAreOnSameLine(node, node.statements[0])) {\n                    write(\" \");\n                    emit(node.statements[0]);\n                }\n                else {\n                    increaseIndent();\n                    emitLines(node.statements);\n                    decreaseIndent();\n                }\n            }\n            function emitThrowStatement(node) {\n                write(\"throw \");\n                emit(node.expression);\n                write(\";\");\n            }\n            function emitTryStatement(node) {\n                write(\"try \");\n                emit(node.tryBlock);\n                emit(node.catchClause);\n                if (node.finallyBlock) {\n                    writeLine();\n                    write(\"finally \");\n                    emit(node.finallyBlock);\n                }\n            }\n            function emitCatchClause(node) {\n                writeLine();\n                var endPos = emitToken(72 /* CatchKeyword */, node.pos);\n                write(\" \");\n                emitToken(17 /* OpenParenToken */, endPos);\n                emit(node.variableDeclaration);\n                emitToken(18 /* CloseParenToken */, node.variableDeclaration ? node.variableDeclaration.end : endPos);\n                write(\" \");\n                emitBlock(node.block);\n            }\n            function emitDebuggerStatement(node) {\n                emitToken(76 /* DebuggerKeyword */, node.pos);\n                write(\";\");\n            }\n            function emitLabelledStatement(node) {\n                emit(node.label);\n                write(\": \");\n                emit(node.statement);\n            }\n            function getContainingModule(node) {\n                do {\n                    node = node.parent;\n                } while (node && node.kind !== 218 /* ModuleDeclaration */);\n                return node;\n            }\n            function emitContainingModuleName(node) {\n                var container = getContainingModule(node);\n                write(container ? getGeneratedNameForNode(container) : \"exports\");\n            }\n            function emitModuleMemberName(node) {\n                emitStart(node.name);\n                if (ts.getCombinedNodeFlags(node) & 1 /* Export */) {\n                    var container = getContainingModule(node);\n                    if (container) {\n                        write(getGeneratedNameForNode(container));\n                        write(\".\");\n                    }\n                    else if (modulekind !== 5 /* ES6 */ && modulekind !== 4 /* System */) {\n                        write(\"exports.\");\n                    }\n                }\n                emitNodeWithCommentsAndWithoutSourcemap(node.name);\n                emitEnd(node.name);\n            }\n            function createVoidZero() {\n                var zero = ts.createSynthesizedNode(8 /* NumericLiteral */);\n                zero.text = \"0\";\n                var result = ts.createSynthesizedNode(177 /* VoidExpression */);\n                result.expression = zero;\n                return result;\n            }\n            function emitEs6ExportDefaultCompat(node) {\n                if (node.parent.kind === 248 /* SourceFile */) {\n                    ts.Debug.assert(!!(node.flags & 1024 /* Default */) || node.kind === 227 /* ExportAssignment */);\n                    // only allow export default at a source file level\n                    if (modulekind === 1 /* CommonJS */ || modulekind === 2 /* AMD */ || modulekind === 3 /* UMD */) {\n                        if (!currentSourceFile.symbol.exports[\"___esModule\"]) {\n                            if (languageVersion === 1 /* ES5 */) {\n                                // default value of configurable, enumerable, writable are `false`.\n                                write(\"Object.defineProperty(exports, \\\"__esModule\\\", { value: true });\");\n                                writeLine();\n                            }\n                            else if (languageVersion === 0 /* ES3 */) {\n                                write(\"exports.__esModule = true;\");\n                                writeLine();\n                            }\n                        }\n                    }\n                }\n            }\n            function emitExportMemberAssignment(node) {\n                if (node.flags & 1 /* Export */) {\n                    writeLine();\n                    emitStart(node);\n                    // emit call to exporter only for top level nodes\n                    if (modulekind === 4 /* System */ && node.parent === currentSourceFile) {\n                        // emit export default <smth> as\n                        // export(\"default\", <smth>)\n                        write(exportFunctionForFile + \"(\\\"\");\n                        if (node.flags & 1024 /* Default */) {\n                            write(\"default\");\n                        }\n                        else {\n                            emitNodeWithCommentsAndWithoutSourcemap(node.name);\n                        }\n                        write(\"\\\", \");\n                        emitDeclarationName(node);\n                        write(\")\");\n                    }\n                    else {\n                        if (node.flags & 1024 /* Default */) {\n                            emitEs6ExportDefaultCompat(node);\n                            if (languageVersion === 0 /* ES3 */) {\n                                write(\"exports[\\\"default\\\"]\");\n                            }\n                            else {\n                                write(\"exports.default\");\n                            }\n                        }\n                        else {\n                            emitModuleMemberName(node);\n                        }\n                        write(\" = \");\n                        emitDeclarationName(node);\n                    }\n                    emitEnd(node);\n                    write(\";\");\n                }\n            }\n            function emitExportMemberAssignments(name) {\n                if (modulekind === 4 /* System */) {\n                    return;\n                }\n                if (!exportEquals && exportSpecifiers && ts.hasProperty(exportSpecifiers, name.text)) {\n                    for (var _a = 0, _b = exportSpecifiers[name.text]; _a < _b.length; _a++) {\n                        var specifier = _b[_a];\n                        writeLine();\n                        emitStart(specifier.name);\n                        emitContainingModuleName(specifier);\n                        write(\".\");\n                        emitNodeWithCommentsAndWithoutSourcemap(specifier.name);\n                        emitEnd(specifier.name);\n                        write(\" = \");\n                        emitExpressionIdentifier(name);\n                        write(\";\");\n                    }\n                }\n            }\n            function emitExportSpecifierInSystemModule(specifier) {\n                ts.Debug.assert(modulekind === 4 /* System */);\n                if (!resolver.getReferencedValueDeclaration(specifier.propertyName || specifier.name) && !resolver.isValueAliasDeclaration(specifier)) {\n                    return;\n                }\n                writeLine();\n                emitStart(specifier.name);\n                write(exportFunctionForFile + \"(\\\"\");\n                emitNodeWithCommentsAndWithoutSourcemap(specifier.name);\n                write(\"\\\", \");\n                emitExpressionIdentifier(specifier.propertyName || specifier.name);\n                write(\")\");\n                emitEnd(specifier.name);\n                write(\";\");\n            }\n            /**\n             * Emit an assignment to a given identifier, 'name', with a given expression, 'value'.\n             * @param name an identifier as a left-hand-side operand of the assignment\n             * @param value an expression as a right-hand-side operand of the assignment\n             * @param shouldEmitCommaBeforeAssignment a boolean indicating whether to prefix an assignment with comma\n             */\n            function emitAssignment(name, value, shouldEmitCommaBeforeAssignment) {\n                if (shouldEmitCommaBeforeAssignment) {\n                    write(\", \");\n                }\n                var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(name);\n                if (exportChanged) {\n                    write(exportFunctionForFile + \"(\\\"\");\n                    emitNodeWithCommentsAndWithoutSourcemap(name);\n                    write(\"\\\", \");\n                }\n                var isVariableDeclarationOrBindingElement = name.parent && (name.parent.kind === 211 /* VariableDeclaration */ || name.parent.kind === 163 /* BindingElement */);\n                if (isVariableDeclarationOrBindingElement) {\n                    emitModuleMemberName(name.parent);\n                }\n                else {\n                    emit(name);\n                }\n                write(\" = \");\n                emit(value);\n                if (exportChanged) {\n                    write(\")\");\n                }\n            }\n            /**\n             * Create temporary variable, emit an assignment of the variable the given expression\n             * @param expression an expression to assign to the newly created temporary variable\n             * @param canDefineTempVariablesInPlace a boolean indicating whether you can define the temporary variable at an assignment location\n             * @param shouldEmitCommaBeforeAssignment a boolean indicating whether an assignment should prefix with comma\n             */\n            function emitTempVariableAssignment(expression, canDefineTempVariablesInPlace, shouldEmitCommaBeforeAssignment) {\n                var identifier = createTempVariable(0 /* Auto */);\n                if (!canDefineTempVariablesInPlace) {\n                    recordTempDeclaration(identifier);\n                }\n                emitAssignment(identifier, expression, shouldEmitCommaBeforeAssignment);\n                return identifier;\n            }\n            function emitDestructuring(root, isAssignmentExpressionStatement, value) {\n                var emitCount = 0;\n                // An exported declaration is actually emitted as an assignment (to a property on the module object), so\n                // temporary variables in an exported declaration need to have real declarations elsewhere\n                // Also temporary variables should be explicitly allocated for source level declarations when module target is system\n                // because actual variable declarations are hoisted\n                var canDefineTempVariablesInPlace = false;\n                if (root.kind === 211 /* VariableDeclaration */) {\n                    var isExported = ts.getCombinedNodeFlags(root) & 1 /* Export */;\n                    var isSourceLevelForSystemModuleKind = shouldHoistDeclarationInSystemJsModule(root);\n                    canDefineTempVariablesInPlace = !isExported && !isSourceLevelForSystemModuleKind;\n                }\n                else if (root.kind === 138 /* Parameter */) {\n                    canDefineTempVariablesInPlace = true;\n                }\n                if (root.kind === 181 /* BinaryExpression */) {\n                    emitAssignmentExpression(root);\n                }\n                else {\n                    ts.Debug.assert(!isAssignmentExpressionStatement);\n                    emitBindingElement(root, value);\n                }\n                /**\n                 * Ensures that there exists a declared identifier whose value holds the given expression.\n                 * This function is useful to ensure that the expression's value can be read from in subsequent expressions.\n                 * Unless 'reuseIdentifierExpressions' is false, 'expr' will be returned if it is just an identifier.\n                 *\n                 * @param expr the expression whose value needs to be bound.\n                 * @param reuseIdentifierExpressions true if identifier expressions can simply be returned;\n                 *                                   false if it is necessary to always emit an identifier.\n                 */\n                function ensureIdentifier(expr, reuseIdentifierExpressions) {\n                    if (expr.kind === 69 /* Identifier */ && reuseIdentifierExpressions) {\n                        return expr;\n                    }\n                    var identifier = emitTempVariableAssignment(expr, canDefineTempVariablesInPlace, emitCount > 0);\n                    emitCount++;\n                    return identifier;\n                }\n                function createDefaultValueCheck(value, defaultValue) {\n                    // The value expression will be evaluated twice, so for anything but a simple identifier\n                    // we need to generate a temporary variable\n                    value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ true);\n                    // Return the expression 'value === void 0 ? defaultValue : value'\n                    var equals = ts.createSynthesizedNode(181 /* BinaryExpression */);\n                    equals.left = value;\n                    equals.operatorToken = ts.createSynthesizedNode(32 /* EqualsEqualsEqualsToken */);\n                    equals.right = createVoidZero();\n                    return createConditionalExpression(equals, defaultValue, value);\n                }\n                function createConditionalExpression(condition, whenTrue, whenFalse) {\n                    var cond = ts.createSynthesizedNode(182 /* ConditionalExpression */);\n                    cond.condition = condition;\n                    cond.questionToken = ts.createSynthesizedNode(53 /* QuestionToken */);\n                    cond.whenTrue = whenTrue;\n                    cond.colonToken = ts.createSynthesizedNode(54 /* ColonToken */);\n                    cond.whenFalse = whenFalse;\n                    return cond;\n                }\n                function createNumericLiteral(value) {\n                    var node = ts.createSynthesizedNode(8 /* NumericLiteral */);\n                    node.text = \"\" + value;\n                    return node;\n                }\n                function createPropertyAccessForDestructuringProperty(object, propName) {\n                    // We create a synthetic copy of the identifier in order to avoid the rewriting that might\n                    // otherwise occur when the identifier is emitted.\n                    var syntheticName = ts.createSynthesizedNode(propName.kind);\n                    syntheticName.text = propName.text;\n                    if (syntheticName.kind !== 69 /* Identifier */) {\n                        return createElementAccessExpression(object, syntheticName);\n                    }\n                    return createPropertyAccessExpression(object, syntheticName);\n                }\n                function createSliceCall(value, sliceIndex) {\n                    var call = ts.createSynthesizedNode(168 /* CallExpression */);\n                    var sliceIdentifier = ts.createSynthesizedNode(69 /* Identifier */);\n                    sliceIdentifier.text = \"slice\";\n                    call.expression = createPropertyAccessExpression(value, sliceIdentifier);\n                    call.arguments = ts.createSynthesizedNodeArray();\n                    call.arguments[0] = createNumericLiteral(sliceIndex);\n                    return call;\n                }\n                function emitObjectLiteralAssignment(target, value) {\n                    var properties = target.properties;\n                    if (properties.length !== 1) {\n                        // For anything but a single element destructuring we need to generate a temporary\n                        // to ensure value is evaluated exactly once.\n                        value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ true);\n                    }\n                    for (var _a = 0; _a < properties.length; _a++) {\n                        var p = properties[_a];\n                        if (p.kind === 245 /* PropertyAssignment */ || p.kind === 246 /* ShorthandPropertyAssignment */) {\n                            var propName = p.name;\n                            var target_1 = p.kind === 246 /* ShorthandPropertyAssignment */ ? p : p.initializer || propName;\n                            emitDestructuringAssignment(target_1, createPropertyAccessForDestructuringProperty(value, propName));\n                        }\n                    }\n                }\n                function emitArrayLiteralAssignment(target, value) {\n                    var elements = target.elements;\n                    if (elements.length !== 1) {\n                        // For anything but a single element destructuring we need to generate a temporary\n                        // to ensure value is evaluated exactly once.\n                        value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ true);\n                    }\n                    for (var i = 0; i < elements.length; i++) {\n                        var e = elements[i];\n                        if (e.kind !== 187 /* OmittedExpression */) {\n                            if (e.kind !== 185 /* SpreadElementExpression */) {\n                                emitDestructuringAssignment(e, createElementAccessExpression(value, createNumericLiteral(i)));\n                            }\n                            else if (i === elements.length - 1) {\n                                emitDestructuringAssignment(e.expression, createSliceCall(value, i));\n                            }\n                        }\n                    }\n                }\n                function emitDestructuringAssignment(target, value) {\n                    if (target.kind === 246 /* ShorthandPropertyAssignment */) {\n                        if (target.objectAssignmentInitializer) {\n                            value = createDefaultValueCheck(value, target.objectAssignmentInitializer);\n                        }\n                        target = target.name;\n                    }\n                    else if (target.kind === 181 /* BinaryExpression */ && target.operatorToken.kind === 56 /* EqualsToken */) {\n                        value = createDefaultValueCheck(value, target.right);\n                        target = target.left;\n                    }\n                    if (target.kind === 165 /* ObjectLiteralExpression */) {\n                        emitObjectLiteralAssignment(target, value);\n                    }\n                    else if (target.kind === 164 /* ArrayLiteralExpression */) {\n                        emitArrayLiteralAssignment(target, value);\n                    }\n                    else {\n                        emitAssignment(target, value, /*shouldEmitCommaBeforeAssignment*/ emitCount > 0);\n                        emitCount++;\n                    }\n                }\n                function emitAssignmentExpression(root) {\n                    var target = root.left;\n                    var value = root.right;\n                    if (ts.isEmptyObjectLiteralOrArrayLiteral(target)) {\n                        emit(value);\n                    }\n                    else if (isAssignmentExpressionStatement) {\n                        emitDestructuringAssignment(target, value);\n                    }\n                    else {\n                        if (root.parent.kind !== 172 /* ParenthesizedExpression */) {\n                            write(\"(\");\n                        }\n                        value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ true);\n                        emitDestructuringAssignment(target, value);\n                        write(\", \");\n                        emit(value);\n                        if (root.parent.kind !== 172 /* ParenthesizedExpression */) {\n                            write(\")\");\n                        }\n                    }\n                }\n                function emitBindingElement(target, value) {\n                    if (target.initializer) {\n                        // Combine value and initializer\n                        value = value ? createDefaultValueCheck(value, target.initializer) : target.initializer;\n                    }\n                    else if (!value) {\n                        // Use 'void 0' in absence of value and initializer\n                        value = createVoidZero();\n                    }\n                    if (ts.isBindingPattern(target.name)) {\n                        var pattern = target.name;\n                        var elements = pattern.elements;\n                        var numElements = elements.length;\n                        if (numElements !== 1) {\n                            // For anything other than a single-element destructuring we need to generate a temporary\n                            // to ensure value is evaluated exactly once. Additionally, if we have zero elements\n                            // we need to emit *something* to ensure that in case a 'var' keyword was already emitted,\n                            // so in that case, we'll intentionally create that temporary.\n                            value = ensureIdentifier(value, /*reuseIdentifierExpressions*/ numElements !== 0);\n                        }\n                        for (var i = 0; i < numElements; i++) {\n                            var element = elements[i];\n                            if (pattern.kind === 161 /* ObjectBindingPattern */) {\n                                // Rewrite element to a declaration with an initializer that fetches property\n                                var propName = element.propertyName || element.name;\n                                emitBindingElement(element, createPropertyAccessForDestructuringProperty(value, propName));\n                            }\n                            else if (element.kind !== 187 /* OmittedExpression */) {\n                                if (!element.dotDotDotToken) {\n                                    // Rewrite element to a declaration that accesses array element at index i\n                                    emitBindingElement(element, createElementAccessExpression(value, createNumericLiteral(i)));\n                                }\n                                else if (i === numElements - 1) {\n                                    emitBindingElement(element, createSliceCall(value, i));\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        emitAssignment(target.name, value, /*shouldEmitCommaBeforeAssignment*/ emitCount > 0);\n                        emitCount++;\n                    }\n                }\n            }\n            function emitVariableDeclaration(node) {\n                if (ts.isBindingPattern(node.name)) {\n                    if (languageVersion < 2 /* ES6 */) {\n                        emitDestructuring(node, /*isAssignmentExpressionStatement*/ false);\n                    }\n                    else {\n                        emit(node.name);\n                        emitOptional(\" = \", node.initializer);\n                    }\n                }\n                else {\n                    var initializer = node.initializer;\n                    if (!initializer && languageVersion < 2 /* ES6 */) {\n                        // downlevel emit for non-initialized let bindings defined in loops\n                        // for (...) {  let x; }\n                        // should be\n                        // for (...) { var <some-uniqie-name> = void 0; }\n                        // this is necessary to preserve ES6 semantic in scenarios like\n                        // for (...) { let x; console.log(x); x = 1 } // assignment on one iteration should not affect other iterations\n                        var isUninitializedLet = (resolver.getNodeCheckFlags(node) & 16384 /* BlockScopedBindingInLoop */) &&\n                            (getCombinedFlagsForIdentifier(node.name) & 16384 /* Let */);\n                        // NOTE: default initialization should not be added to let bindings in for-in\\for-of statements\n                        if (isUninitializedLet &&\n                            node.parent.parent.kind !== 200 /* ForInStatement */ &&\n                            node.parent.parent.kind !== 201 /* ForOfStatement */) {\n                            initializer = createVoidZero();\n                        }\n                    }\n                    var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(node.name);\n                    if (exportChanged) {\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitNodeWithCommentsAndWithoutSourcemap(node.name);\n                        write(\"\\\", \");\n                    }\n                    emitModuleMemberName(node);\n                    emitOptional(\" = \", initializer);\n                    if (exportChanged) {\n                        write(\")\");\n                    }\n                }\n            }\n            function emitExportVariableAssignments(node) {\n                if (node.kind === 187 /* OmittedExpression */) {\n                    return;\n                }\n                var name = node.name;\n                if (name.kind === 69 /* Identifier */) {\n                    emitExportMemberAssignments(name);\n                }\n                else if (ts.isBindingPattern(name)) {\n                    ts.forEach(name.elements, emitExportVariableAssignments);\n                }\n            }\n            function getCombinedFlagsForIdentifier(node) {\n                if (!node.parent || (node.parent.kind !== 211 /* VariableDeclaration */ && node.parent.kind !== 163 /* BindingElement */)) {\n                    return 0;\n                }\n                return ts.getCombinedNodeFlags(node.parent);\n            }\n            function isES6ExportedDeclaration(node) {\n                return !!(node.flags & 1 /* Export */) &&\n                    modulekind === 5 /* ES6 */ &&\n                    node.parent.kind === 248 /* SourceFile */;\n            }\n            function emitVariableStatement(node) {\n                var startIsEmitted = false;\n                if (node.flags & 1 /* Export */) {\n                    if (isES6ExportedDeclaration(node)) {\n                        // Exported ES6 module member\n                        write(\"export \");\n                        startIsEmitted = tryEmitStartOfVariableDeclarationList(node.declarationList);\n                    }\n                }\n                else {\n                    startIsEmitted = tryEmitStartOfVariableDeclarationList(node.declarationList);\n                }\n                if (startIsEmitted) {\n                    emitCommaList(node.declarationList.declarations);\n                    write(\";\");\n                }\n                else {\n                    var atLeastOneItem = emitVariableDeclarationListSkippingUninitializedEntries(node.declarationList);\n                    if (atLeastOneItem) {\n                        write(\";\");\n                    }\n                }\n                if (modulekind !== 5 /* ES6 */ && node.parent === currentSourceFile) {\n                    ts.forEach(node.declarationList.declarations, emitExportVariableAssignments);\n                }\n            }\n            function shouldEmitLeadingAndTrailingCommentsForVariableStatement(node) {\n                // If we're not exporting the variables, there's nothing special here.\n                // Always emit comments for these nodes.\n                if (!(node.flags & 1 /* Export */)) {\n                    return true;\n                }\n                // If we are exporting, but it's a top-level ES6 module exports,\n                // we'll emit the declaration list verbatim, so emit comments too.\n                if (isES6ExportedDeclaration(node)) {\n                    return true;\n                }\n                // Otherwise, only emit if we have at least one initializer present.\n                for (var _a = 0, _b = node.declarationList.declarations; _a < _b.length; _a++) {\n                    var declaration = _b[_a];\n                    if (declaration.initializer) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function emitParameter(node) {\n                if (languageVersion < 2 /* ES6 */) {\n                    if (ts.isBindingPattern(node.name)) {\n                        var name_24 = createTempVariable(0 /* Auto */);\n                        if (!tempParameters) {\n                            tempParameters = [];\n                        }\n                        tempParameters.push(name_24);\n                        emit(name_24);\n                    }\n                    else {\n                        emit(node.name);\n                    }\n                }\n                else {\n                    if (node.dotDotDotToken) {\n                        write(\"...\");\n                    }\n                    emit(node.name);\n                    emitOptional(\" = \", node.initializer);\n                }\n            }\n            function emitDefaultValueAssignments(node) {\n                if (languageVersion < 2 /* ES6 */) {\n                    var tempIndex = 0;\n                    ts.forEach(node.parameters, function (parameter) {\n                        // A rest parameter cannot have a binding pattern or an initializer,\n                        // so let's just ignore it.\n                        if (parameter.dotDotDotToken) {\n                            return;\n                        }\n                        var paramName = parameter.name, initializer = parameter.initializer;\n                        if (ts.isBindingPattern(paramName)) {\n                            // In cases where a binding pattern is simply '[]' or '{}',\n                            // we usually don't want to emit a var declaration; however, in the presence\n                            // of an initializer, we must emit that expression to preserve side effects.\n                            var hasBindingElements = paramName.elements.length > 0;\n                            if (hasBindingElements || initializer) {\n                                writeLine();\n                                write(\"var \");\n                                if (hasBindingElements) {\n                                    emitDestructuring(parameter, /*isAssignmentExpressionStatement*/ false, tempParameters[tempIndex]);\n                                }\n                                else {\n                                    emit(tempParameters[tempIndex]);\n                                    write(\" = \");\n                                    emit(initializer);\n                                }\n                                write(\";\");\n                                tempIndex++;\n                            }\n                        }\n                        else if (initializer) {\n                            writeLine();\n                            emitStart(parameter);\n                            write(\"if (\");\n                            emitNodeWithoutSourceMap(paramName);\n                            write(\" === void 0)\");\n                            emitEnd(parameter);\n                            write(\" { \");\n                            emitStart(parameter);\n                            emitNodeWithCommentsAndWithoutSourcemap(paramName);\n                            write(\" = \");\n                            emitNodeWithCommentsAndWithoutSourcemap(initializer);\n                            emitEnd(parameter);\n                            write(\"; }\");\n                        }\n                    });\n                }\n            }\n            function emitRestParameter(node) {\n                if (languageVersion < 2 /* ES6 */ && ts.hasRestParameter(node)) {\n                    var restIndex = node.parameters.length - 1;\n                    var restParam = node.parameters[restIndex];\n                    // A rest parameter cannot have a binding pattern, so let's just ignore it if it does.\n                    if (ts.isBindingPattern(restParam.name)) {\n                        return;\n                    }\n                    var tempName = createTempVariable(268435456 /* _i */).text;\n                    writeLine();\n                    emitLeadingComments(restParam);\n                    emitStart(restParam);\n                    write(\"var \");\n                    emitNodeWithCommentsAndWithoutSourcemap(restParam.name);\n                    write(\" = [];\");\n                    emitEnd(restParam);\n                    emitTrailingComments(restParam);\n                    writeLine();\n                    write(\"for (\");\n                    emitStart(restParam);\n                    write(\"var \" + tempName + \" = \" + restIndex + \";\");\n                    emitEnd(restParam);\n                    write(\" \");\n                    emitStart(restParam);\n                    write(tempName + \" < arguments.length;\");\n                    emitEnd(restParam);\n                    write(\" \");\n                    emitStart(restParam);\n                    write(tempName + \"++\");\n                    emitEnd(restParam);\n                    write(\") {\");\n                    increaseIndent();\n                    writeLine();\n                    emitStart(restParam);\n                    emitNodeWithCommentsAndWithoutSourcemap(restParam.name);\n                    write(\"[\" + tempName + \" - \" + restIndex + \"] = arguments[\" + tempName + \"];\");\n                    emitEnd(restParam);\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                }\n            }\n            function emitAccessor(node) {\n                write(node.kind === 145 /* GetAccessor */ ? \"get \" : \"set \");\n                emit(node.name);\n                emitSignatureAndBody(node);\n            }\n            function shouldEmitAsArrowFunction(node) {\n                return node.kind === 174 /* ArrowFunction */ && languageVersion >= 2 /* ES6 */;\n            }\n            function emitDeclarationName(node) {\n                if (node.name) {\n                    emitNodeWithCommentsAndWithoutSourcemap(node.name);\n                }\n                else {\n                    write(getGeneratedNameForNode(node));\n                }\n            }\n            function shouldEmitFunctionName(node) {\n                if (node.kind === 173 /* FunctionExpression */) {\n                    // Emit name if one is present\n                    return !!node.name;\n                }\n                if (node.kind === 213 /* FunctionDeclaration */) {\n                    // Emit name if one is present, or emit generated name in down-level case (for export default case)\n                    return !!node.name || languageVersion < 2 /* ES6 */;\n                }\n            }\n            function emitFunctionDeclaration(node) {\n                if (ts.nodeIsMissing(node.body)) {\n                    return emitCommentsOnNotEmittedNode(node);\n                }\n                // TODO (yuisu) : we should not have special cases to condition emitting comments\n                // but have one place to fix check for these conditions.\n                if (node.kind !== 143 /* MethodDeclaration */ && node.kind !== 142 /* MethodSignature */ &&\n                    node.parent && node.parent.kind !== 245 /* PropertyAssignment */ &&\n                    node.parent.kind !== 168 /* CallExpression */) {\n                    // 1. Methods will emit the comments as part of emitting method declaration\n                    // 2. If the function is a property of object literal, emitting leading-comments\n                    // is done by emitNodeWithoutSourceMap which then call this function.\n                    // In particular, we would like to avoid emit comments twice in following case:\n                    //      For example:\n                    //          var obj = {\n                    //              id:\n                    //                  /*comment*/ () => void\n                    //          }\n                    // 3. If the function is an argument in call expression, emitting of comments will be\n                    // taken care of in emit list of arguments inside of emitCallexpression\n                    emitLeadingComments(node);\n                }\n                emitStart(node);\n                // For targeting below es6, emit functions-like declaration including arrow function using function keyword.\n                // When targeting ES6, emit arrow function natively in ES6 by omitting function keyword and using fat arrow instead\n                if (!shouldEmitAsArrowFunction(node)) {\n                    if (isES6ExportedDeclaration(node)) {\n                        write(\"export \");\n                        if (node.flags & 1024 /* Default */) {\n                            write(\"default \");\n                        }\n                    }\n                    write(\"function\");\n                    if (languageVersion >= 2 /* ES6 */ && node.asteriskToken) {\n                        write(\"*\");\n                    }\n                    write(\" \");\n                }\n                if (shouldEmitFunctionName(node)) {\n                    emitDeclarationName(node);\n                }\n                emitSignatureAndBody(node);\n                if (modulekind !== 5 /* ES6 */ && node.kind === 213 /* FunctionDeclaration */ && node.parent === currentSourceFile && node.name) {\n                    emitExportMemberAssignments(node.name);\n                }\n                emitEnd(node);\n                if (node.kind !== 143 /* MethodDeclaration */ && node.kind !== 142 /* MethodSignature */) {\n                    emitTrailingComments(node);\n                }\n            }\n            function emitCaptureThisForNodeIfNecessary(node) {\n                if (resolver.getNodeCheckFlags(node) & 4 /* CaptureThis */) {\n                    writeLine();\n                    emitStart(node);\n                    write(\"var _this = this;\");\n                    emitEnd(node);\n                }\n            }\n            function emitSignatureParameters(node) {\n                increaseIndent();\n                write(\"(\");\n                if (node) {\n                    var parameters = node.parameters;\n                    var omitCount = languageVersion < 2 /* ES6 */ && ts.hasRestParameter(node) ? 1 : 0;\n                    emitList(parameters, 0, parameters.length - omitCount, /*multiLine*/ false, /*trailingComma*/ false);\n                }\n                write(\")\");\n                decreaseIndent();\n            }\n            function emitSignatureParametersForArrow(node) {\n                // Check whether the parameter list needs parentheses and preserve no-parenthesis\n                if (node.parameters.length === 1 && node.pos === node.parameters[0].pos) {\n                    emit(node.parameters[0]);\n                    return;\n                }\n                emitSignatureParameters(node);\n            }\n            function emitAsyncFunctionBodyForES6(node) {\n                var promiseConstructor = ts.getEntityNameFromTypeNode(node.type);\n                var isArrowFunction = node.kind === 174 /* ArrowFunction */;\n                var hasLexicalArguments = (resolver.getNodeCheckFlags(node) & 4096 /* CaptureArguments */) !== 0;\n                var args;\n                // An async function is emit as an outer function that calls an inner\n                // generator function. To preserve lexical bindings, we pass the current\n                // `this` and `arguments` objects to `__awaiter`. The generator function\n                // passed to `__awaiter` is executed inside of the callback to the\n                // promise constructor.\n                //\n                // The emit for an async arrow without a lexical `arguments` binding might be:\n                //\n                //  // input\n                //  let a = async (b) => { await b; }\n                //\n                //  // output\n                //  let a = (b) => __awaiter(this, void 0, void 0, function* () {\n                //      yield b;\n                //  });\n                //\n                // The emit for an async arrow with a lexical `arguments` binding might be:\n                //\n                //  // input\n                //  let a = async (b) => { await arguments[0]; }\n                //\n                //  // output\n                //  let a = (b) => __awaiter(this, arguments, void 0, function* (arguments) {\n                //      yield arguments[0];\n                //  });\n                //\n                // The emit for an async function expression without a lexical `arguments` binding\n                // might be:\n                //\n                //  // input\n                //  let a = async function (b) {\n                //      await b;\n                //  }\n                //\n                //  // output\n                //  let a = function (b) {\n                //      return __awaiter(this, void 0, void 0, function* () {\n                //          yield b;\n                //      });\n                //  }\n                //\n                // The emit for an async function expression with a lexical `arguments` binding\n                // might be:\n                //\n                //  // input\n                //  let a = async function (b) {\n                //      await arguments[0];\n                //  }\n                //\n                //  // output\n                //  let a = function (b) {\n                //      return __awaiter(this, arguments, void 0, function* (_arguments) {\n                //          yield _arguments[0];\n                //      });\n                //  }\n                //\n                // The emit for an async function expression with a lexical `arguments` binding\n                // and a return type annotation might be:\n                //\n                //  // input\n                //  let a = async function (b): MyPromise<any> {\n                //      await arguments[0];\n                //  }\n                //\n                //  // output\n                //  let a = function (b) {\n                //      return __awaiter(this, arguments, MyPromise, function* (_arguments) {\n                //          yield _arguments[0];\n                //      });\n                //  }\n                //\n                // If this is not an async arrow, emit the opening brace of the function body\n                // and the start of the return statement.\n                if (!isArrowFunction) {\n                    write(\" {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"return\");\n                }\n                write(\" __awaiter(this\");\n                if (hasLexicalArguments) {\n                    write(\", arguments\");\n                }\n                else {\n                    write(\", void 0\");\n                }\n                if (promiseConstructor) {\n                    write(\", \");\n                    emitNodeWithoutSourceMap(promiseConstructor);\n                }\n                else {\n                    write(\", Promise\");\n                }\n                // Emit the call to __awaiter.\n                if (hasLexicalArguments) {\n                    write(\", function* (_arguments)\");\n                }\n                else {\n                    write(\", function* ()\");\n                }\n                // Emit the signature and body for the inner generator function.\n                emitFunctionBody(node);\n                write(\")\");\n                // If this is not an async arrow, emit the closing brace of the outer function body.\n                if (!isArrowFunction) {\n                    write(\";\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                }\n            }\n            function emitFunctionBody(node) {\n                if (!node.body) {\n                    // There can be no body when there are parse errors.  Just emit an empty block\n                    // in that case.\n                    write(\" { }\");\n                }\n                else {\n                    if (node.body.kind === 192 /* Block */) {\n                        emitBlockFunctionBody(node, node.body);\n                    }\n                    else {\n                        emitExpressionFunctionBody(node, node.body);\n                    }\n                }\n            }\n            function emitSignatureAndBody(node) {\n                var saveTempFlags = tempFlags;\n                var saveTempVariables = tempVariables;\n                var saveTempParameters = tempParameters;\n                tempFlags = 0;\n                tempVariables = undefined;\n                tempParameters = undefined;\n                // When targeting ES6, emit arrow function natively in ES6\n                if (shouldEmitAsArrowFunction(node)) {\n                    emitSignatureParametersForArrow(node);\n                    write(\" =>\");\n                }\n                else {\n                    emitSignatureParameters(node);\n                }\n                var isAsync = ts.isAsyncFunctionLike(node);\n                if (isAsync && languageVersion === 2 /* ES6 */) {\n                    emitAsyncFunctionBodyForES6(node);\n                }\n                else {\n                    emitFunctionBody(node);\n                }\n                if (!isES6ExportedDeclaration(node)) {\n                    emitExportMemberAssignment(node);\n                }\n                tempFlags = saveTempFlags;\n                tempVariables = saveTempVariables;\n                tempParameters = saveTempParameters;\n            }\n            // Returns true if any preamble code was emitted.\n            function emitFunctionBodyPreamble(node) {\n                emitCaptureThisForNodeIfNecessary(node);\n                emitDefaultValueAssignments(node);\n                emitRestParameter(node);\n            }\n            function emitExpressionFunctionBody(node, body) {\n                if (languageVersion < 2 /* ES6 */ || node.flags & 512 /* Async */) {\n                    emitDownLevelExpressionFunctionBody(node, body);\n                    return;\n                }\n                // For es6 and higher we can emit the expression as is.  However, in the case\n                // where the expression might end up looking like a block when emitted, we'll\n                // also wrap it in parentheses first.  For example if you have: a => <foo>{}\n                // then we need to generate: a => ({})\n                write(\" \");\n                // Unwrap all type assertions.\n                var current = body;\n                while (current.kind === 171 /* TypeAssertionExpression */) {\n                    current = current.expression;\n                }\n                emitParenthesizedIf(body, current.kind === 165 /* ObjectLiteralExpression */);\n            }\n            function emitDownLevelExpressionFunctionBody(node, body) {\n                write(\" {\");\n                scopeEmitStart(node);\n                increaseIndent();\n                var outPos = writer.getTextPos();\n                emitDetachedComments(node.body);\n                emitFunctionBodyPreamble(node);\n                var preambleEmitted = writer.getTextPos() !== outPos;\n                decreaseIndent();\n                // If we didn't have to emit any preamble code, then attempt to keep the arrow\n                // function on one line.\n                if (!preambleEmitted && nodeStartPositionsAreOnSameLine(node, body)) {\n                    write(\" \");\n                    emitStart(body);\n                    write(\"return \");\n                    emit(body);\n                    emitEnd(body);\n                    write(\";\");\n                    emitTempDeclarations(/*newLine*/ false);\n                    write(\" \");\n                }\n                else {\n                    increaseIndent();\n                    writeLine();\n                    emitLeadingComments(node.body);\n                    write(\"return \");\n                    emit(body);\n                    write(\";\");\n                    emitTrailingComments(node.body);\n                    emitTempDeclarations(/*newLine*/ true);\n                    decreaseIndent();\n                    writeLine();\n                }\n                emitStart(node.body);\n                write(\"}\");\n                emitEnd(node.body);\n                scopeEmitEnd();\n            }\n            function emitBlockFunctionBody(node, body) {\n                write(\" {\");\n                scopeEmitStart(node);\n                var initialTextPos = writer.getTextPos();\n                increaseIndent();\n                emitDetachedComments(body.statements);\n                // Emit all the directive prologues (like \"use strict\").  These have to come before\n                // any other preamble code we write (like parameter initializers).\n                var startIndex = emitDirectivePrologues(body.statements, /*startWithNewLine*/ true);\n                emitFunctionBodyPreamble(node);\n                decreaseIndent();\n                var preambleEmitted = writer.getTextPos() !== initialTextPos;\n                if (!preambleEmitted && nodeEndIsOnSameLineAsNodeStart(body, body)) {\n                    for (var _a = 0, _b = body.statements; _a < _b.length; _a++) {\n                        var statement = _b[_a];\n                        write(\" \");\n                        emit(statement);\n                    }\n                    emitTempDeclarations(/*newLine*/ false);\n                    write(\" \");\n                    emitLeadingCommentsOfPosition(body.statements.end);\n                }\n                else {\n                    increaseIndent();\n                    emitLinesStartingAt(body.statements, startIndex);\n                    emitTempDeclarations(/*newLine*/ true);\n                    writeLine();\n                    emitLeadingCommentsOfPosition(body.statements.end);\n                    decreaseIndent();\n                }\n                emitToken(16 /* CloseBraceToken */, body.statements.end);\n                scopeEmitEnd();\n            }\n            function findInitialSuperCall(ctor) {\n                if (ctor.body) {\n                    var statement = ctor.body.statements[0];\n                    if (statement && statement.kind === 195 /* ExpressionStatement */) {\n                        var expr = statement.expression;\n                        if (expr && expr.kind === 168 /* CallExpression */) {\n                            var func = expr.expression;\n                            if (func && func.kind === 95 /* SuperKeyword */) {\n                                return statement;\n                            }\n                        }\n                    }\n                }\n            }\n            function emitParameterPropertyAssignments(node) {\n                ts.forEach(node.parameters, function (param) {\n                    if (param.flags & 112 /* AccessibilityModifier */) {\n                        writeLine();\n                        emitStart(param);\n                        emitStart(param.name);\n                        write(\"this.\");\n                        emitNodeWithoutSourceMap(param.name);\n                        emitEnd(param.name);\n                        write(\" = \");\n                        emit(param.name);\n                        write(\";\");\n                        emitEnd(param);\n                    }\n                });\n            }\n            function emitMemberAccessForPropertyName(memberName) {\n                // This does not emit source map because it is emitted by caller as caller\n                // is aware how the property name changes to the property access\n                // eg. public x = 10; becomes this.x and static x = 10 becomes className.x\n                if (memberName.kind === 9 /* StringLiteral */ || memberName.kind === 8 /* NumericLiteral */) {\n                    write(\"[\");\n                    emitNodeWithCommentsAndWithoutSourcemap(memberName);\n                    write(\"]\");\n                }\n                else if (memberName.kind === 136 /* ComputedPropertyName */) {\n                    emitComputedPropertyName(memberName);\n                }\n                else {\n                    write(\".\");\n                    emitNodeWithCommentsAndWithoutSourcemap(memberName);\n                }\n            }\n            function getInitializedProperties(node, isStatic) {\n                var properties = [];\n                for (var _a = 0, _b = node.members; _a < _b.length; _a++) {\n                    var member = _b[_a];\n                    if (member.kind === 141 /* PropertyDeclaration */ && isStatic === ((member.flags & 128 /* Static */) !== 0) && member.initializer) {\n                        properties.push(member);\n                    }\n                }\n                return properties;\n            }\n            function emitPropertyDeclarations(node, properties) {\n                for (var _a = 0; _a < properties.length; _a++) {\n                    var property = properties[_a];\n                    emitPropertyDeclaration(node, property);\n                }\n            }\n            function emitPropertyDeclaration(node, property, receiver, isExpression) {\n                writeLine();\n                emitLeadingComments(property);\n                emitStart(property);\n                emitStart(property.name);\n                if (receiver) {\n                    emit(receiver);\n                }\n                else {\n                    if (property.flags & 128 /* Static */) {\n                        emitDeclarationName(node);\n                    }\n                    else {\n                        write(\"this\");\n                    }\n                }\n                emitMemberAccessForPropertyName(property.name);\n                emitEnd(property.name);\n                write(\" = \");\n                emit(property.initializer);\n                if (!isExpression) {\n                    write(\";\");\n                }\n                emitEnd(property);\n                emitTrailingComments(property);\n            }\n            function emitMemberFunctionsForES5AndLower(node) {\n                ts.forEach(node.members, function (member) {\n                    if (member.kind === 191 /* SemicolonClassElement */) {\n                        writeLine();\n                        write(\";\");\n                    }\n                    else if (member.kind === 143 /* MethodDeclaration */ || node.kind === 142 /* MethodSignature */) {\n                        if (!member.body) {\n                            return emitCommentsOnNotEmittedNode(member);\n                        }\n                        writeLine();\n                        emitLeadingComments(member);\n                        emitStart(member);\n                        emitStart(member.name);\n                        emitClassMemberPrefix(node, member);\n                        emitMemberAccessForPropertyName(member.name);\n                        emitEnd(member.name);\n                        write(\" = \");\n                        emitFunctionDeclaration(member);\n                        emitEnd(member);\n                        write(\";\");\n                        emitTrailingComments(member);\n                    }\n                    else if (member.kind === 145 /* GetAccessor */ || member.kind === 146 /* SetAccessor */) {\n                        var accessors = ts.getAllAccessorDeclarations(node.members, member);\n                        if (member === accessors.firstAccessor) {\n                            writeLine();\n                            emitStart(member);\n                            write(\"Object.defineProperty(\");\n                            emitStart(member.name);\n                            emitClassMemberPrefix(node, member);\n                            write(\", \");\n                            emitExpressionForPropertyName(member.name);\n                            emitEnd(member.name);\n                            write(\", {\");\n                            increaseIndent();\n                            if (accessors.getAccessor) {\n                                writeLine();\n                                emitLeadingComments(accessors.getAccessor);\n                                write(\"get: \");\n                                emitStart(accessors.getAccessor);\n                                write(\"function \");\n                                emitSignatureAndBody(accessors.getAccessor);\n                                emitEnd(accessors.getAccessor);\n                                emitTrailingComments(accessors.getAccessor);\n                                write(\",\");\n                            }\n                            if (accessors.setAccessor) {\n                                writeLine();\n                                emitLeadingComments(accessors.setAccessor);\n                                write(\"set: \");\n                                emitStart(accessors.setAccessor);\n                                write(\"function \");\n                                emitSignatureAndBody(accessors.setAccessor);\n                                emitEnd(accessors.setAccessor);\n                                emitTrailingComments(accessors.setAccessor);\n                                write(\",\");\n                            }\n                            writeLine();\n                            write(\"enumerable: true,\");\n                            writeLine();\n                            write(\"configurable: true\");\n                            decreaseIndent();\n                            writeLine();\n                            write(\"});\");\n                            emitEnd(member);\n                        }\n                    }\n                });\n            }\n            function emitMemberFunctionsForES6AndHigher(node) {\n                for (var _a = 0, _b = node.members; _a < _b.length; _a++) {\n                    var member = _b[_a];\n                    if ((member.kind === 143 /* MethodDeclaration */ || node.kind === 142 /* MethodSignature */) && !member.body) {\n                        emitCommentsOnNotEmittedNode(member);\n                    }\n                    else if (member.kind === 143 /* MethodDeclaration */ ||\n                        member.kind === 145 /* GetAccessor */ ||\n                        member.kind === 146 /* SetAccessor */) {\n                        writeLine();\n                        emitLeadingComments(member);\n                        emitStart(member);\n                        if (member.flags & 128 /* Static */) {\n                            write(\"static \");\n                        }\n                        if (member.kind === 145 /* GetAccessor */) {\n                            write(\"get \");\n                        }\n                        else if (member.kind === 146 /* SetAccessor */) {\n                            write(\"set \");\n                        }\n                        if (member.asteriskToken) {\n                            write(\"*\");\n                        }\n                        emit(member.name);\n                        emitSignatureAndBody(member);\n                        emitEnd(member);\n                        emitTrailingComments(member);\n                    }\n                    else if (member.kind === 191 /* SemicolonClassElement */) {\n                        writeLine();\n                        write(\";\");\n                    }\n                }\n            }\n            function emitConstructor(node, baseTypeElement) {\n                var saveTempFlags = tempFlags;\n                var saveTempVariables = tempVariables;\n                var saveTempParameters = tempParameters;\n                tempFlags = 0;\n                tempVariables = undefined;\n                tempParameters = undefined;\n                emitConstructorWorker(node, baseTypeElement);\n                tempFlags = saveTempFlags;\n                tempVariables = saveTempVariables;\n                tempParameters = saveTempParameters;\n            }\n            function emitConstructorWorker(node, baseTypeElement) {\n                // Check if we have property assignment inside class declaration.\n                // If there is property assignment, we need to emit constructor whether users define it or not\n                // If there is no property assignment, we can omit constructor if users do not define it\n                var hasInstancePropertyWithInitializer = false;\n                // Emit the constructor overload pinned comments\n                ts.forEach(node.members, function (member) {\n                    if (member.kind === 144 /* Constructor */ && !member.body) {\n                        emitCommentsOnNotEmittedNode(member);\n                    }\n                    // Check if there is any non-static property assignment\n                    if (member.kind === 141 /* PropertyDeclaration */ && member.initializer && (member.flags & 128 /* Static */) === 0) {\n                        hasInstancePropertyWithInitializer = true;\n                    }\n                });\n                var ctor = ts.getFirstConstructorWithBody(node);\n                // For target ES6 and above, if there is no user-defined constructor and there is no property assignment\n                // do not emit constructor in class declaration.\n                if (languageVersion >= 2 /* ES6 */ && !ctor && !hasInstancePropertyWithInitializer) {\n                    return;\n                }\n                if (ctor) {\n                    emitLeadingComments(ctor);\n                }\n                emitStart(ctor || node);\n                if (languageVersion < 2 /* ES6 */) {\n                    write(\"function \");\n                    emitDeclarationName(node);\n                    emitSignatureParameters(ctor);\n                }\n                else {\n                    write(\"constructor\");\n                    if (ctor) {\n                        emitSignatureParameters(ctor);\n                    }\n                    else {\n                        // Based on EcmaScript6 section 14.5.14: Runtime Semantics: ClassDefinitionEvaluation.\n                        // If constructor is empty, then,\n                        //      If ClassHeritageopt is present, then\n                        //          Let constructor be the result of parsing the String \"constructor(... args){ super (...args);}\" using the syntactic grammar with the goal symbol MethodDefinition.\n                        //      Else,\n                        //          Let constructor be the result of parsing the String \"constructor( ){ }\" using the syntactic grammar with the goal symbol MethodDefinition\n                        if (baseTypeElement) {\n                            write(\"(...args)\");\n                        }\n                        else {\n                            write(\"()\");\n                        }\n                    }\n                }\n                var startIndex = 0;\n                write(\" {\");\n                scopeEmitStart(node, \"constructor\");\n                increaseIndent();\n                if (ctor) {\n                    // Emit all the directive prologues (like \"use strict\").  These have to come before\n                    // any other preamble code we write (like parameter initializers).\n                    startIndex = emitDirectivePrologues(ctor.body.statements, /*startWithNewLine*/ true);\n                    emitDetachedComments(ctor.body.statements);\n                }\n                emitCaptureThisForNodeIfNecessary(node);\n                var superCall;\n                if (ctor) {\n                    emitDefaultValueAssignments(ctor);\n                    emitRestParameter(ctor);\n                    if (baseTypeElement) {\n                        superCall = findInitialSuperCall(ctor);\n                        if (superCall) {\n                            writeLine();\n                            emit(superCall);\n                        }\n                    }\n                    emitParameterPropertyAssignments(ctor);\n                }\n                else {\n                    if (baseTypeElement) {\n                        writeLine();\n                        emitStart(baseTypeElement);\n                        if (languageVersion < 2 /* ES6 */) {\n                            write(\"_super.apply(this, arguments);\");\n                        }\n                        else {\n                            write(\"super(...args);\");\n                        }\n                        emitEnd(baseTypeElement);\n                    }\n                }\n                emitPropertyDeclarations(node, getInitializedProperties(node, /*static:*/ false));\n                if (ctor) {\n                    var statements = ctor.body.statements;\n                    if (superCall) {\n                        statements = statements.slice(1);\n                    }\n                    emitLinesStartingAt(statements, startIndex);\n                }\n                emitTempDeclarations(/*newLine*/ true);\n                writeLine();\n                if (ctor) {\n                    emitLeadingCommentsOfPosition(ctor.body.statements.end);\n                }\n                decreaseIndent();\n                emitToken(16 /* CloseBraceToken */, ctor ? ctor.body.statements.end : node.members.end);\n                scopeEmitEnd();\n                emitEnd(ctor || node);\n                if (ctor) {\n                    emitTrailingComments(ctor);\n                }\n            }\n            function emitClassExpression(node) {\n                return emitClassLikeDeclaration(node);\n            }\n            function emitClassDeclaration(node) {\n                return emitClassLikeDeclaration(node);\n            }\n            function emitClassLikeDeclaration(node) {\n                if (languageVersion < 2 /* ES6 */) {\n                    emitClassLikeDeclarationBelowES6(node);\n                }\n                else {\n                    emitClassLikeDeclarationForES6AndHigher(node);\n                }\n                if (modulekind !== 5 /* ES6 */ && node.parent === currentSourceFile && node.name) {\n                    emitExportMemberAssignments(node.name);\n                }\n            }\n            function emitClassLikeDeclarationForES6AndHigher(node) {\n                var thisNodeIsDecorated = ts.nodeIsDecorated(node);\n                if (node.kind === 214 /* ClassDeclaration */) {\n                    if (thisNodeIsDecorated) {\n                        // To preserve the correct runtime semantics when decorators are applied to the class,\n                        // the emit needs to follow one of the following rules:\n                        //\n                        // * For a local class declaration:\n                        //\n                        //     @dec class C {\n                        //     }\n                        //\n                        //   The emit should be:\n                        //\n                        //     let C = class {\n                        //     };\n                        //     C = __decorate([dec], C);\n                        //\n                        // * For an exported class declaration:\n                        //\n                        //     @dec export class C {\n                        //     }\n                        //\n                        //   The emit should be:\n                        //\n                        //     export let C = class {\n                        //     };\n                        //     C = __decorate([dec], C);\n                        //\n                        // * For a default export of a class declaration with a name:\n                        //\n                        //     @dec default export class C {\n                        //     }\n                        //\n                        //   The emit should be:\n                        //\n                        //     let C = class {\n                        //     }\n                        //     C = __decorate([dec], C);\n                        //     export default C;\n                        //\n                        // * For a default export of a class declaration without a name:\n                        //\n                        //     @dec default export class {\n                        //     }\n                        //\n                        //   The emit should be:\n                        //\n                        //     let _default = class {\n                        //     }\n                        //     _default = __decorate([dec], _default);\n                        //     export default _default;\n                        //\n                        if (isES6ExportedDeclaration(node) && !(node.flags & 1024 /* Default */)) {\n                            write(\"export \");\n                        }\n                        write(\"let \");\n                        emitDeclarationName(node);\n                        write(\" = \");\n                    }\n                    else if (isES6ExportedDeclaration(node)) {\n                        write(\"export \");\n                        if (node.flags & 1024 /* Default */) {\n                            write(\"default \");\n                        }\n                    }\n                }\n                // If the class has static properties, and it's a class expression, then we'll need\n                // to specialize the emit a bit.  for a class expression of the form:\n                //\n                //      class C { static a = 1; static b = 2; ... }\n                //\n                // We'll emit:\n                //\n                //      (_temp = class C { ... }, _temp.a = 1, _temp.b = 2, _temp)\n                //\n                // This keeps the expression as an expression, while ensuring that the static parts\n                // of it have been initialized by the time it is used.\n                var staticProperties = getInitializedProperties(node, /*static:*/ true);\n                var isClassExpressionWithStaticProperties = staticProperties.length > 0 && node.kind === 186 /* ClassExpression */;\n                var tempVariable;\n                if (isClassExpressionWithStaticProperties) {\n                    tempVariable = createAndRecordTempVariable(0 /* Auto */);\n                    write(\"(\");\n                    increaseIndent();\n                    emit(tempVariable);\n                    write(\" = \");\n                }\n                write(\"class\");\n                // emit name if\n                // - node has a name\n                // - this is default export with static initializers\n                if ((node.name || (node.flags & 1024 /* Default */ && staticProperties.length > 0)) && !thisNodeIsDecorated) {\n                    write(\" \");\n                    emitDeclarationName(node);\n                }\n                var baseTypeNode = ts.getClassExtendsHeritageClauseElement(node);\n                if (baseTypeNode) {\n                    write(\" extends \");\n                    emit(baseTypeNode.expression);\n                }\n                write(\" {\");\n                increaseIndent();\n                scopeEmitStart(node);\n                writeLine();\n                emitConstructor(node, baseTypeNode);\n                emitMemberFunctionsForES6AndHigher(node);\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.members.end);\n                scopeEmitEnd();\n                // TODO(rbuckton): Need to go back to `let _a = class C {}` approach, removing the defineProperty call for now.\n                // For a decorated class, we need to assign its name (if it has one). This is because we emit\n                // the class as a class expression to avoid the double-binding of the identifier:\n                //\n                //   let C = class {\n                //   }\n                //   Object.defineProperty(C, \"name\", { value: \"C\", configurable: true });\n                //\n                if (thisNodeIsDecorated) {\n                    write(\";\");\n                }\n                // Emit static property assignment. Because classDeclaration is lexically evaluated,\n                // it is safe to emit static property assignment after classDeclaration\n                // From ES6 specification:\n                //      HasLexicalDeclaration (N) : Determines if the argument identifier has a binding in this environment record that was created using\n                //                                  a lexical declaration such as a LexicalDeclaration or a ClassDeclaration.\n                if (isClassExpressionWithStaticProperties) {\n                    for (var _a = 0; _a < staticProperties.length; _a++) {\n                        var property = staticProperties[_a];\n                        write(\",\");\n                        writeLine();\n                        emitPropertyDeclaration(node, property, /*receiver:*/ tempVariable, /*isExpression:*/ true);\n                    }\n                    write(\",\");\n                    writeLine();\n                    emit(tempVariable);\n                    decreaseIndent();\n                    write(\")\");\n                }\n                else {\n                    writeLine();\n                    emitPropertyDeclarations(node, staticProperties);\n                    emitDecoratorsOfClass(node);\n                }\n                // If this is an exported class, but not on the top level (i.e. on an internal\n                // module), export it\n                if (!isES6ExportedDeclaration(node) && (node.flags & 1 /* Export */)) {\n                    writeLine();\n                    emitStart(node);\n                    emitModuleMemberName(node);\n                    write(\" = \");\n                    emitDeclarationName(node);\n                    emitEnd(node);\n                    write(\";\");\n                }\n                else if (isES6ExportedDeclaration(node) && (node.flags & 1024 /* Default */) && thisNodeIsDecorated) {\n                    // if this is a top level default export of decorated class, write the export after the declaration.\n                    writeLine();\n                    write(\"export default \");\n                    emitDeclarationName(node);\n                    write(\";\");\n                }\n            }\n            function emitClassLikeDeclarationBelowES6(node) {\n                if (node.kind === 214 /* ClassDeclaration */) {\n                    // source file level classes in system modules are hoisted so 'var's for them are already defined\n                    if (!shouldHoistDeclarationInSystemJsModule(node)) {\n                        write(\"var \");\n                    }\n                    emitDeclarationName(node);\n                    write(\" = \");\n                }\n                write(\"(function (\");\n                var baseTypeNode = ts.getClassExtendsHeritageClauseElement(node);\n                if (baseTypeNode) {\n                    write(\"_super\");\n                }\n                write(\") {\");\n                var saveTempFlags = tempFlags;\n                var saveTempVariables = tempVariables;\n                var saveTempParameters = tempParameters;\n                var saveComputedPropertyNamesToGeneratedNames = computedPropertyNamesToGeneratedNames;\n                tempFlags = 0;\n                tempVariables = undefined;\n                tempParameters = undefined;\n                computedPropertyNamesToGeneratedNames = undefined;\n                increaseIndent();\n                scopeEmitStart(node);\n                if (baseTypeNode) {\n                    writeLine();\n                    emitStart(baseTypeNode);\n                    write(\"__extends(\");\n                    emitDeclarationName(node);\n                    write(\", _super);\");\n                    emitEnd(baseTypeNode);\n                }\n                writeLine();\n                emitConstructor(node, baseTypeNode);\n                emitMemberFunctionsForES5AndLower(node);\n                emitPropertyDeclarations(node, getInitializedProperties(node, /*static:*/ true));\n                writeLine();\n                emitDecoratorsOfClass(node);\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.members.end, function () {\n                    write(\"return \");\n                    emitDeclarationName(node);\n                });\n                write(\";\");\n                emitTempDeclarations(/*newLine*/ true);\n                tempFlags = saveTempFlags;\n                tempVariables = saveTempVariables;\n                tempParameters = saveTempParameters;\n                computedPropertyNamesToGeneratedNames = saveComputedPropertyNamesToGeneratedNames;\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.members.end);\n                scopeEmitEnd();\n                emitStart(node);\n                write(\")(\");\n                if (baseTypeNode) {\n                    emit(baseTypeNode.expression);\n                }\n                write(\")\");\n                if (node.kind === 214 /* ClassDeclaration */) {\n                    write(\";\");\n                }\n                emitEnd(node);\n                if (node.kind === 214 /* ClassDeclaration */) {\n                    emitExportMemberAssignment(node);\n                }\n            }\n            function emitClassMemberPrefix(node, member) {\n                emitDeclarationName(node);\n                if (!(member.flags & 128 /* Static */)) {\n                    write(\".prototype\");\n                }\n            }\n            function emitDecoratorsOfClass(node) {\n                emitDecoratorsOfMembers(node, /*staticFlag*/ 0);\n                emitDecoratorsOfMembers(node, 128 /* Static */);\n                emitDecoratorsOfConstructor(node);\n            }\n            function emitDecoratorsOfConstructor(node) {\n                var decorators = node.decorators;\n                var constructor = ts.getFirstConstructorWithBody(node);\n                var hasDecoratedParameters = constructor && ts.forEach(constructor.parameters, ts.nodeIsDecorated);\n                // skip decoration of the constructor if neither it nor its parameters are decorated\n                if (!decorators && !hasDecoratedParameters) {\n                    return;\n                }\n                // Emit the call to __decorate. Given the class:\n                //\n                //   @dec\n                //   class C {\n                //   }\n                //\n                // The emit for the class is:\n                //\n                //   C = __decorate([dec], C);\n                //\n                writeLine();\n                emitStart(node);\n                emitDeclarationName(node);\n                write(\" = __decorate([\");\n                increaseIndent();\n                writeLine();\n                var decoratorCount = decorators ? decorators.length : 0;\n                var argumentsWritten = emitList(decorators, 0, decoratorCount, /*multiLine*/ true, /*trailingComma*/ false, /*leadingComma*/ false, /*noTrailingNewLine*/ true, function (decorator) {\n                    emitStart(decorator);\n                    emit(decorator.expression);\n                    emitEnd(decorator);\n                });\n                argumentsWritten += emitDecoratorsOfParameters(constructor, /*leadingComma*/ argumentsWritten > 0);\n                emitSerializedTypeMetadata(node, /*leadingComma*/ argumentsWritten >= 0);\n                decreaseIndent();\n                writeLine();\n                write(\"], \");\n                emitDeclarationName(node);\n                write(\");\");\n                emitEnd(node);\n                writeLine();\n            }\n            function emitDecoratorsOfMembers(node, staticFlag) {\n                for (var _a = 0, _b = node.members; _a < _b.length; _a++) {\n                    var member = _b[_a];\n                    // only emit members in the correct group\n                    if ((member.flags & 128 /* Static */) !== staticFlag) {\n                        continue;\n                    }\n                    // skip members that cannot be decorated (such as the constructor)\n                    if (!ts.nodeCanBeDecorated(member)) {\n                        continue;\n                    }\n                    // skip a member if it or any of its parameters are not decorated\n                    if (!ts.nodeOrChildIsDecorated(member)) {\n                        continue;\n                    }\n                    // skip an accessor declaration if it is not the first accessor\n                    var decorators = void 0;\n                    var functionLikeMember = void 0;\n                    if (ts.isAccessor(member)) {\n                        var accessors = ts.getAllAccessorDeclarations(node.members, member);\n                        if (member !== accessors.firstAccessor) {\n                            continue;\n                        }\n                        // get the decorators from the first accessor with decorators\n                        decorators = accessors.firstAccessor.decorators;\n                        if (!decorators && accessors.secondAccessor) {\n                            decorators = accessors.secondAccessor.decorators;\n                        }\n                        // we only decorate parameters of the set accessor\n                        functionLikeMember = accessors.setAccessor;\n                    }\n                    else {\n                        decorators = member.decorators;\n                        // we only decorate the parameters here if this is a method\n                        if (member.kind === 143 /* MethodDeclaration */) {\n                            functionLikeMember = member;\n                        }\n                    }\n                    // Emit the call to __decorate. Given the following:\n                    //\n                    //   class C {\n                    //     @dec method(@dec2 x) {}\n                    //     @dec get accessor() {}\n                    //     @dec prop;\n                    //   }\n                    //\n                    // The emit for a method is:\n                    //\n                    //   __decorate([\n                    //       dec,\n                    //       __param(0, dec2),\n                    //       __metadata(\"design:type\", Function),\n                    //       __metadata(\"design:paramtypes\", [Object]),\n                    //       __metadata(\"design:returntype\", void 0)\n                    //   ], C.prototype, \"method\", undefined);\n                    //\n                    // The emit for an accessor is:\n                    //\n                    //   __decorate([\n                    //       dec\n                    //   ], C.prototype, \"accessor\", undefined);\n                    //\n                    // The emit for a property is:\n                    //\n                    //   __decorate([\n                    //       dec\n                    //   ], C.prototype, \"prop\");\n                    //\n                    writeLine();\n                    emitStart(member);\n                    write(\"__decorate([\");\n                    increaseIndent();\n                    writeLine();\n                    var decoratorCount = decorators ? decorators.length : 0;\n                    var argumentsWritten = emitList(decorators, 0, decoratorCount, /*multiLine*/ true, /*trailingComma*/ false, /*leadingComma*/ false, /*noTrailingNewLine*/ true, function (decorator) {\n                        emitStart(decorator);\n                        emit(decorator.expression);\n                        emitEnd(decorator);\n                    });\n                    argumentsWritten += emitDecoratorsOfParameters(functionLikeMember, argumentsWritten > 0);\n                    emitSerializedTypeMetadata(member, argumentsWritten > 0);\n                    decreaseIndent();\n                    writeLine();\n                    write(\"], \");\n                    emitStart(member.name);\n                    emitClassMemberPrefix(node, member);\n                    write(\", \");\n                    emitExpressionForPropertyName(member.name);\n                    emitEnd(member.name);\n                    if (languageVersion > 0 /* ES3 */) {\n                        if (member.kind !== 141 /* PropertyDeclaration */) {\n                            // We emit `null` here to indicate to `__decorate` that it can invoke `Object.getOwnPropertyDescriptor` directly.\n                            // We have this extra argument here so that we can inject an explicit property descriptor at a later date.\n                            write(\", null\");\n                        }\n                        else {\n                            // We emit `void 0` here to indicate to `__decorate` that it can invoke `Object.defineProperty` directly, but that it\n                            // should not invoke `Object.getOwnPropertyDescriptor`.\n                            write(\", void 0\");\n                        }\n                    }\n                    write(\");\");\n                    emitEnd(member);\n                    writeLine();\n                }\n            }\n            function emitDecoratorsOfParameters(node, leadingComma) {\n                var argumentsWritten = 0;\n                if (node) {\n                    var parameterIndex = 0;\n                    for (var _a = 0, _b = node.parameters; _a < _b.length; _a++) {\n                        var parameter = _b[_a];\n                        if (ts.nodeIsDecorated(parameter)) {\n                            var decorators = parameter.decorators;\n                            argumentsWritten += emitList(decorators, 0, decorators.length, /*multiLine*/ true, /*trailingComma*/ false, /*leadingComma*/ leadingComma, /*noTrailingNewLine*/ true, function (decorator) {\n                                emitStart(decorator);\n                                write(\"__param(\" + parameterIndex + \", \");\n                                emit(decorator.expression);\n                                write(\")\");\n                                emitEnd(decorator);\n                            });\n                            leadingComma = true;\n                        }\n                        ++parameterIndex;\n                    }\n                }\n                return argumentsWritten;\n            }\n            function shouldEmitTypeMetadata(node) {\n                // This method determines whether to emit the \"design:type\" metadata based on the node's kind.\n                // The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata\n                // compiler option is set.\n                switch (node.kind) {\n                    case 143 /* MethodDeclaration */:\n                    case 145 /* GetAccessor */:\n                    case 146 /* SetAccessor */:\n                    case 141 /* PropertyDeclaration */:\n                        return true;\n                }\n                return false;\n            }\n            function shouldEmitReturnTypeMetadata(node) {\n                // This method determines whether to emit the \"design:returntype\" metadata based on the node's kind.\n                // The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata\n                // compiler option is set.\n                switch (node.kind) {\n                    case 143 /* MethodDeclaration */:\n                        return true;\n                }\n                return false;\n            }\n            function shouldEmitParamTypesMetadata(node) {\n                // This method determines whether to emit the \"design:paramtypes\" metadata based on the node's kind.\n                // The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata\n                // compiler option is set.\n                switch (node.kind) {\n                    case 214 /* ClassDeclaration */:\n                    case 143 /* MethodDeclaration */:\n                    case 146 /* SetAccessor */:\n                        return true;\n                }\n                return false;\n            }\n            /** Serializes the type of a declaration to an appropriate JS constructor value. Used by the __metadata decorator for a class member. */\n            function emitSerializedTypeOfNode(node) {\n                // serialization of the type of a declaration uses the following rules:\n                //\n                // * The serialized type of a ClassDeclaration is \"Function\"\n                // * The serialized type of a ParameterDeclaration is the serialized type of its type annotation.\n                // * The serialized type of a PropertyDeclaration is the serialized type of its type annotation.\n                // * The serialized type of an AccessorDeclaration is the serialized type of the return type annotation of its getter or parameter type annotation of its setter.\n                // * The serialized type of any other FunctionLikeDeclaration is \"Function\".\n                // * The serialized type of any other node is \"void 0\".\n                //\n                // For rules on serializing type annotations, see `serializeTypeNode`.\n                switch (node.kind) {\n                    case 214 /* ClassDeclaration */:\n                        write(\"Function\");\n                        return;\n                    case 141 /* PropertyDeclaration */:\n                        emitSerializedTypeNode(node.type);\n                        return;\n                    case 138 /* Parameter */:\n                        emitSerializedTypeNode(node.type);\n                        return;\n                    case 145 /* GetAccessor */:\n                        emitSerializedTypeNode(node.type);\n                        return;\n                    case 146 /* SetAccessor */:\n                        emitSerializedTypeNode(ts.getSetAccessorTypeAnnotationNode(node));\n                        return;\n                }\n                if (ts.isFunctionLike(node)) {\n                    write(\"Function\");\n                    return;\n                }\n                write(\"void 0\");\n            }\n            function emitSerializedTypeNode(node) {\n                if (node) {\n                    switch (node.kind) {\n                        case 103 /* VoidKeyword */:\n                            write(\"void 0\");\n                            return;\n                        case 160 /* ParenthesizedType */:\n                            emitSerializedTypeNode(node.type);\n                            return;\n                        case 152 /* FunctionType */:\n                        case 153 /* ConstructorType */:\n                            write(\"Function\");\n                            return;\n                        case 156 /* ArrayType */:\n                        case 157 /* TupleType */:\n                            write(\"Array\");\n                            return;\n                        case 150 /* TypePredicate */:\n                        case 120 /* BooleanKeyword */:\n                            write(\"Boolean\");\n                            return;\n                        case 130 /* StringKeyword */:\n                        case 9 /* StringLiteral */:\n                            write(\"String\");\n                            return;\n                        case 128 /* NumberKeyword */:\n                            write(\"Number\");\n                            return;\n                        case 131 /* SymbolKeyword */:\n                            write(\"Symbol\");\n                            return;\n                        case 151 /* TypeReference */:\n                            emitSerializedTypeReferenceNode(node);\n                            return;\n                        case 154 /* TypeQuery */:\n                        case 155 /* TypeLiteral */:\n                        case 158 /* UnionType */:\n                        case 159 /* IntersectionType */:\n                        case 117 /* AnyKeyword */:\n                            break;\n                        default:\n                            ts.Debug.fail(\"Cannot serialize unexpected type node.\");\n                            break;\n                    }\n                }\n                write(\"Object\");\n            }\n            /** Serializes a TypeReferenceNode to an appropriate JS constructor value. Used by the __metadata decorator. */\n            function emitSerializedTypeReferenceNode(node) {\n                var location = node.parent;\n                while (ts.isDeclaration(location) || ts.isTypeNode(location)) {\n                    location = location.parent;\n                }\n                // Clone the type name and parent it to a location outside of the current declaration.\n                var typeName = ts.cloneEntityName(node.typeName);\n                typeName.parent = location;\n                var result = resolver.getTypeReferenceSerializationKind(typeName);\n                switch (result) {\n                    case ts.TypeReferenceSerializationKind.Unknown:\n                        var temp = createAndRecordTempVariable(0 /* Auto */);\n                        write(\"(typeof (\");\n                        emitNodeWithoutSourceMap(temp);\n                        write(\" = \");\n                        emitEntityNameAsExpression(typeName, /*useFallback*/ true);\n                        write(\") === 'function' && \");\n                        emitNodeWithoutSourceMap(temp);\n                        write(\") || Object\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue:\n                        emitEntityNameAsExpression(typeName, /*useFallback*/ false);\n                        break;\n                    case ts.TypeReferenceSerializationKind.VoidType:\n                        write(\"void 0\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.BooleanType:\n                        write(\"Boolean\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.NumberLikeType:\n                        write(\"Number\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.StringLikeType:\n                        write(\"String\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.ArrayLikeType:\n                        write(\"Array\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.ESSymbolType:\n                        if (languageVersion < 2 /* ES6 */) {\n                            write(\"typeof Symbol === 'function' ? Symbol : Object\");\n                        }\n                        else {\n                            write(\"Symbol\");\n                        }\n                        break;\n                    case ts.TypeReferenceSerializationKind.TypeWithCallSignature:\n                        write(\"Function\");\n                        break;\n                    case ts.TypeReferenceSerializationKind.ObjectType:\n                        write(\"Object\");\n                        break;\n                }\n            }\n            /** Serializes the parameter types of a function or the constructor of a class. Used by the __metadata decorator for a method or set accessor. */\n            function emitSerializedParameterTypesOfNode(node) {\n                // serialization of parameter types uses the following rules:\n                //\n                // * If the declaration is a class, the parameters of the first constructor with a body are used.\n                // * If the declaration is function-like and has a body, the parameters of the function are used.\n                //\n                // For the rules on serializing the type of each parameter declaration, see `serializeTypeOfDeclaration`.\n                if (node) {\n                    var valueDeclaration;\n                    if (node.kind === 214 /* ClassDeclaration */) {\n                        valueDeclaration = ts.getFirstConstructorWithBody(node);\n                    }\n                    else if (ts.isFunctionLike(node) && ts.nodeIsPresent(node.body)) {\n                        valueDeclaration = node;\n                    }\n                    if (valueDeclaration) {\n                        var parameters = valueDeclaration.parameters;\n                        var parameterCount = parameters.length;\n                        if (parameterCount > 0) {\n                            for (var i = 0; i < parameterCount; i++) {\n                                if (i > 0) {\n                                    write(\", \");\n                                }\n                                if (parameters[i].dotDotDotToken) {\n                                    var parameterType = parameters[i].type;\n                                    if (parameterType.kind === 156 /* ArrayType */) {\n                                        parameterType = parameterType.elementType;\n                                    }\n                                    else if (parameterType.kind === 151 /* TypeReference */ && parameterType.typeArguments && parameterType.typeArguments.length === 1) {\n                                        parameterType = parameterType.typeArguments[0];\n                                    }\n                                    else {\n                                        parameterType = undefined;\n                                    }\n                                    emitSerializedTypeNode(parameterType);\n                                }\n                                else {\n                                    emitSerializedTypeOfNode(parameters[i]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            /** Serializes the return type of function. Used by the __metadata decorator for a method. */\n            function emitSerializedReturnTypeOfNode(node) {\n                if (node && ts.isFunctionLike(node) && node.type) {\n                    emitSerializedTypeNode(node.type);\n                    return;\n                }\n                write(\"void 0\");\n            }\n            function emitSerializedTypeMetadata(node, writeComma) {\n                // This method emits the serialized type metadata for a decorator target.\n                // The caller should have already tested whether the node has decorators.\n                var argumentsWritten = 0;\n                if (compilerOptions.emitDecoratorMetadata) {\n                    if (shouldEmitTypeMetadata(node)) {\n                        if (writeComma) {\n                            write(\", \");\n                        }\n                        writeLine();\n                        write(\"__metadata('design:type', \");\n                        emitSerializedTypeOfNode(node);\n                        write(\")\");\n                        argumentsWritten++;\n                    }\n                    if (shouldEmitParamTypesMetadata(node)) {\n                        if (writeComma || argumentsWritten) {\n                            write(\", \");\n                        }\n                        writeLine();\n                        write(\"__metadata('design:paramtypes', [\");\n                        emitSerializedParameterTypesOfNode(node);\n                        write(\"])\");\n                        argumentsWritten++;\n                    }\n                    if (shouldEmitReturnTypeMetadata(node)) {\n                        if (writeComma || argumentsWritten) {\n                            write(\", \");\n                        }\n                        writeLine();\n                        write(\"__metadata('design:returntype', \");\n                        emitSerializedReturnTypeOfNode(node);\n                        write(\")\");\n                        argumentsWritten++;\n                    }\n                }\n                return argumentsWritten;\n            }\n            function emitInterfaceDeclaration(node) {\n                emitCommentsOnNotEmittedNode(node);\n            }\n            function shouldEmitEnumDeclaration(node) {\n                var isConstEnum = ts.isConst(node);\n                return !isConstEnum || compilerOptions.preserveConstEnums || compilerOptions.isolatedModules;\n            }\n            function emitEnumDeclaration(node) {\n                // const enums are completely erased during compilation.\n                if (!shouldEmitEnumDeclaration(node)) {\n                    return;\n                }\n                if (!shouldHoistDeclarationInSystemJsModule(node)) {\n                    // do not emit var if variable was already hoisted\n                    if (!(node.flags & 1 /* Export */) || isES6ExportedDeclaration(node)) {\n                        emitStart(node);\n                        if (isES6ExportedDeclaration(node)) {\n                            write(\"export \");\n                        }\n                        write(\"var \");\n                        emit(node.name);\n                        emitEnd(node);\n                        write(\";\");\n                    }\n                }\n                writeLine();\n                emitStart(node);\n                write(\"(function (\");\n                emitStart(node.name);\n                write(getGeneratedNameForNode(node));\n                emitEnd(node.name);\n                write(\") {\");\n                increaseIndent();\n                scopeEmitStart(node);\n                emitLines(node.members);\n                decreaseIndent();\n                writeLine();\n                emitToken(16 /* CloseBraceToken */, node.members.end);\n                scopeEmitEnd();\n                write(\")(\");\n                emitModuleMemberName(node);\n                write(\" || (\");\n                emitModuleMemberName(node);\n                write(\" = {}));\");\n                emitEnd(node);\n                if (!isES6ExportedDeclaration(node) && node.flags & 1 /* Export */ && !shouldHoistDeclarationInSystemJsModule(node)) {\n                    // do not emit var if variable was already hoisted\n                    writeLine();\n                    emitStart(node);\n                    write(\"var \");\n                    emit(node.name);\n                    write(\" = \");\n                    emitModuleMemberName(node);\n                    emitEnd(node);\n                    write(\";\");\n                }\n                if (modulekind !== 5 /* ES6 */ && node.parent === currentSourceFile) {\n                    if (modulekind === 4 /* System */ && (node.flags & 1 /* Export */)) {\n                        // write the call to exporter for enum\n                        writeLine();\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitDeclarationName(node);\n                        write(\"\\\", \");\n                        emitDeclarationName(node);\n                        write(\");\");\n                    }\n                    emitExportMemberAssignments(node.name);\n                }\n            }\n            function emitEnumMember(node) {\n                var enumParent = node.parent;\n                emitStart(node);\n                write(getGeneratedNameForNode(enumParent));\n                write(\"[\");\n                write(getGeneratedNameForNode(enumParent));\n                write(\"[\");\n                emitExpressionForPropertyName(node.name);\n                write(\"] = \");\n                writeEnumMemberDeclarationValue(node);\n                write(\"] = \");\n                emitExpressionForPropertyName(node.name);\n                emitEnd(node);\n                write(\";\");\n            }\n            function writeEnumMemberDeclarationValue(member) {\n                var value = resolver.getConstantValue(member);\n                if (value !== undefined) {\n                    write(value.toString());\n                    return;\n                }\n                else if (member.initializer) {\n                    emit(member.initializer);\n                }\n                else {\n                    write(\"undefined\");\n                }\n            }\n            function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {\n                if (moduleDeclaration.body.kind === 218 /* ModuleDeclaration */) {\n                    var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);\n                    return recursiveInnerModule || moduleDeclaration.body;\n                }\n            }\n            function shouldEmitModuleDeclaration(node) {\n                return ts.isInstantiatedModule(node, compilerOptions.preserveConstEnums || compilerOptions.isolatedModules);\n            }\n            function isModuleMergedWithES6Class(node) {\n                return languageVersion === 2 /* ES6 */ && !!(resolver.getNodeCheckFlags(node) & 32768 /* LexicalModuleMergesWithClass */);\n            }\n            function emitModuleDeclaration(node) {\n                // Emit only if this module is non-ambient.\n                var shouldEmit = shouldEmitModuleDeclaration(node);\n                if (!shouldEmit) {\n                    return emitCommentsOnNotEmittedNode(node);\n                }\n                var hoistedInDeclarationScope = shouldHoistDeclarationInSystemJsModule(node);\n                var emitVarForModule = !hoistedInDeclarationScope && !isModuleMergedWithES6Class(node);\n                if (emitVarForModule) {\n                    emitStart(node);\n                    if (isES6ExportedDeclaration(node)) {\n                        write(\"export \");\n                    }\n                    write(\"var \");\n                    emit(node.name);\n                    write(\";\");\n                    emitEnd(node);\n                    writeLine();\n                }\n                emitStart(node);\n                write(\"(function (\");\n                emitStart(node.name);\n                write(getGeneratedNameForNode(node));\n                emitEnd(node.name);\n                write(\") \");\n                if (node.body.kind === 219 /* ModuleBlock */) {\n                    var saveTempFlags = tempFlags;\n                    var saveTempVariables = tempVariables;\n                    tempFlags = 0;\n                    tempVariables = undefined;\n                    emit(node.body);\n                    tempFlags = saveTempFlags;\n                    tempVariables = saveTempVariables;\n                }\n                else {\n                    write(\"{\");\n                    increaseIndent();\n                    scopeEmitStart(node);\n                    emitCaptureThisForNodeIfNecessary(node);\n                    writeLine();\n                    emit(node.body);\n                    decreaseIndent();\n                    writeLine();\n                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;\n                    emitToken(16 /* CloseBraceToken */, moduleBlock.statements.end);\n                    scopeEmitEnd();\n                }\n                write(\")(\");\n                // write moduleDecl = containingModule.m only if it is not exported es6 module member\n                if ((node.flags & 1 /* Export */) && !isES6ExportedDeclaration(node)) {\n                    emit(node.name);\n                    write(\" = \");\n                }\n                emitModuleMemberName(node);\n                write(\" || (\");\n                emitModuleMemberName(node);\n                write(\" = {}));\");\n                emitEnd(node);\n                if (!isES6ExportedDeclaration(node) && node.name.kind === 69 /* Identifier */ && node.parent === currentSourceFile) {\n                    if (modulekind === 4 /* System */ && (node.flags & 1 /* Export */)) {\n                        writeLine();\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitDeclarationName(node);\n                        write(\"\\\", \");\n                        emitDeclarationName(node);\n                        write(\");\");\n                    }\n                    emitExportMemberAssignments(node.name);\n                }\n            }\n            /*\n             * Some bundlers (SystemJS builder) sometimes want to rename dependencies.\n             * Here we check if alternative name was provided for a given moduleName and return it if possible.\n             */\n            function tryRenameExternalModule(moduleName) {\n                if (currentSourceFile.renamedDependencies && ts.hasProperty(currentSourceFile.renamedDependencies, moduleName.text)) {\n                    return \"\\\"\" + currentSourceFile.renamedDependencies[moduleName.text] + \"\\\"\";\n                }\n                return undefined;\n            }\n            function emitRequire(moduleName) {\n                if (moduleName.kind === 9 /* StringLiteral */) {\n                    write(\"require(\");\n                    var text = tryRenameExternalModule(moduleName);\n                    if (text) {\n                        write(text);\n                    }\n                    else {\n                        emitStart(moduleName);\n                        emitLiteral(moduleName);\n                        emitEnd(moduleName);\n                    }\n                    emitToken(18 /* CloseParenToken */, moduleName.end);\n                }\n                else {\n                    write(\"require()\");\n                }\n            }\n            function getNamespaceDeclarationNode(node) {\n                if (node.kind === 221 /* ImportEqualsDeclaration */) {\n                    return node;\n                }\n                var importClause = node.importClause;\n                if (importClause && importClause.namedBindings && importClause.namedBindings.kind === 224 /* NamespaceImport */) {\n                    return importClause.namedBindings;\n                }\n            }\n            function isDefaultImport(node) {\n                return node.kind === 222 /* ImportDeclaration */ && node.importClause && !!node.importClause.name;\n            }\n            function emitExportImportAssignments(node) {\n                if (ts.isAliasSymbolDeclaration(node) && resolver.isValueAliasDeclaration(node)) {\n                    emitExportMemberAssignments(node.name);\n                }\n                ts.forEachChild(node, emitExportImportAssignments);\n            }\n            function emitImportDeclaration(node) {\n                if (modulekind !== 5 /* ES6 */) {\n                    return emitExternalImportDeclaration(node);\n                }\n                // ES6 import\n                if (node.importClause) {\n                    var shouldEmitDefaultBindings = resolver.isReferencedAliasDeclaration(node.importClause);\n                    var shouldEmitNamedBindings = node.importClause.namedBindings && resolver.isReferencedAliasDeclaration(node.importClause.namedBindings, /* checkChildren */ true);\n                    if (shouldEmitDefaultBindings || shouldEmitNamedBindings) {\n                        write(\"import \");\n                        emitStart(node.importClause);\n                        if (shouldEmitDefaultBindings) {\n                            emit(node.importClause.name);\n                            if (shouldEmitNamedBindings) {\n                                write(\", \");\n                            }\n                        }\n                        if (shouldEmitNamedBindings) {\n                            emitLeadingComments(node.importClause.namedBindings);\n                            emitStart(node.importClause.namedBindings);\n                            if (node.importClause.namedBindings.kind === 224 /* NamespaceImport */) {\n                                write(\"* as \");\n                                emit(node.importClause.namedBindings.name);\n                            }\n                            else {\n                                write(\"{ \");\n                                emitExportOrImportSpecifierList(node.importClause.namedBindings.elements, resolver.isReferencedAliasDeclaration);\n                                write(\" }\");\n                            }\n                            emitEnd(node.importClause.namedBindings);\n                            emitTrailingComments(node.importClause.namedBindings);\n                        }\n                        emitEnd(node.importClause);\n                        write(\" from \");\n                        emit(node.moduleSpecifier);\n                        write(\";\");\n                    }\n                }\n                else {\n                    write(\"import \");\n                    emit(node.moduleSpecifier);\n                    write(\";\");\n                }\n            }\n            function emitExternalImportDeclaration(node) {\n                if (ts.contains(externalImports, node)) {\n                    var isExportedImport = node.kind === 221 /* ImportEqualsDeclaration */ && (node.flags & 1 /* Export */) !== 0;\n                    var namespaceDeclaration = getNamespaceDeclarationNode(node);\n                    if (modulekind !== 2 /* AMD */) {\n                        emitLeadingComments(node);\n                        emitStart(node);\n                        if (namespaceDeclaration && !isDefaultImport(node)) {\n                            // import x = require(\"foo\")\n                            // import * as x from \"foo\"\n                            if (!isExportedImport)\n                                write(\"var \");\n                            emitModuleMemberName(namespaceDeclaration);\n                            write(\" = \");\n                        }\n                        else {\n                            // import \"foo\"\n                            // import x from \"foo\"\n                            // import { x, y } from \"foo\"\n                            // import d, * as x from \"foo\"\n                            // import d, { x, y } from \"foo\"\n                            var isNakedImport = 222 /* ImportDeclaration */ && !node.importClause;\n                            if (!isNakedImport) {\n                                write(\"var \");\n                                write(getGeneratedNameForNode(node));\n                                write(\" = \");\n                            }\n                        }\n                        emitRequire(ts.getExternalModuleName(node));\n                        if (namespaceDeclaration && isDefaultImport(node)) {\n                            // import d, * as x from \"foo\"\n                            write(\", \");\n                            emitModuleMemberName(namespaceDeclaration);\n                            write(\" = \");\n                            write(getGeneratedNameForNode(node));\n                        }\n                        write(\";\");\n                        emitEnd(node);\n                        emitExportImportAssignments(node);\n                        emitTrailingComments(node);\n                    }\n                    else {\n                        if (isExportedImport) {\n                            emitModuleMemberName(namespaceDeclaration);\n                            write(\" = \");\n                            emit(namespaceDeclaration.name);\n                            write(\";\");\n                        }\n                        else if (namespaceDeclaration && isDefaultImport(node)) {\n                            // import d, * as x from \"foo\"\n                            write(\"var \");\n                            emitModuleMemberName(namespaceDeclaration);\n                            write(\" = \");\n                            write(getGeneratedNameForNode(node));\n                            write(\";\");\n                        }\n                        emitExportImportAssignments(node);\n                    }\n                }\n            }\n            function emitImportEqualsDeclaration(node) {\n                if (ts.isExternalModuleImportEqualsDeclaration(node)) {\n                    emitExternalImportDeclaration(node);\n                    return;\n                }\n                // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when\n                // - current file is not external module\n                // - import declaration is top level and target is value imported by entity name\n                if (resolver.isReferencedAliasDeclaration(node) ||\n                    (!ts.isExternalModule(currentSourceFile) && resolver.isTopLevelValueImportEqualsWithEntityName(node))) {\n                    emitLeadingComments(node);\n                    emitStart(node);\n                    // variable declaration for import-equals declaration can be hoisted in system modules\n                    // in this case 'var' should be omitted and emit should contain only initialization\n                    var variableDeclarationIsHoisted = shouldHoistVariable(node, /*checkIfSourceFileLevelDecl*/ true);\n                    // is it top level export import v = a.b.c in system module?\n                    // if yes - it needs to be rewritten as exporter('v', v = a.b.c)\n                    var isExported = isSourceFileLevelDeclarationInSystemJsModule(node, /*isExported*/ true);\n                    if (!variableDeclarationIsHoisted) {\n                        ts.Debug.assert(!isExported);\n                        if (isES6ExportedDeclaration(node)) {\n                            write(\"export \");\n                            write(\"var \");\n                        }\n                        else if (!(node.flags & 1 /* Export */)) {\n                            write(\"var \");\n                        }\n                    }\n                    if (isExported) {\n                        write(exportFunctionForFile + \"(\\\"\");\n                        emitNodeWithoutSourceMap(node.name);\n                        write(\"\\\", \");\n                    }\n                    emitModuleMemberName(node);\n                    write(\" = \");\n                    emit(node.moduleReference);\n                    if (isExported) {\n                        write(\")\");\n                    }\n                    write(\";\");\n                    emitEnd(node);\n                    emitExportImportAssignments(node);\n                    emitTrailingComments(node);\n                }\n            }\n            function emitExportDeclaration(node) {\n                ts.Debug.assert(modulekind !== 4 /* System */);\n                if (modulekind !== 5 /* ES6 */) {\n                    if (node.moduleSpecifier && (!node.exportClause || resolver.isValueAliasDeclaration(node))) {\n                        emitStart(node);\n                        var generatedName = getGeneratedNameForNode(node);\n                        if (node.exportClause) {\n                            // export { x, y, ... } from \"foo\"\n                            if (modulekind !== 2 /* AMD */) {\n                                write(\"var \");\n                                write(generatedName);\n                                write(\" = \");\n                                emitRequire(ts.getExternalModuleName(node));\n                                write(\";\");\n                            }\n                            for (var _a = 0, _b = node.exportClause.elements; _a < _b.length; _a++) {\n                                var specifier = _b[_a];\n                                if (resolver.isValueAliasDeclaration(specifier)) {\n                                    writeLine();\n                                    emitStart(specifier);\n                                    emitContainingModuleName(specifier);\n                                    write(\".\");\n                                    emitNodeWithCommentsAndWithoutSourcemap(specifier.name);\n                                    write(\" = \");\n                                    write(generatedName);\n                                    write(\".\");\n                                    emitNodeWithCommentsAndWithoutSourcemap(specifier.propertyName || specifier.name);\n                                    write(\";\");\n                                    emitEnd(specifier);\n                                }\n                            }\n                        }\n                        else {\n                            // export * from \"foo\"\n                            writeLine();\n                            write(\"__export(\");\n                            if (modulekind !== 2 /* AMD */) {\n                                emitRequire(ts.getExternalModuleName(node));\n                            }\n                            else {\n                                write(generatedName);\n                            }\n                            write(\");\");\n                        }\n                        emitEnd(node);\n                    }\n                }\n                else {\n                    if (!node.exportClause || resolver.isValueAliasDeclaration(node)) {\n                        write(\"export \");\n                        if (node.exportClause) {\n                            // export { x, y, ... }\n                            write(\"{ \");\n                            emitExportOrImportSpecifierList(node.exportClause.elements, resolver.isValueAliasDeclaration);\n                            write(\" }\");\n                        }\n                        else {\n                            write(\"*\");\n                        }\n                        if (node.moduleSpecifier) {\n                            write(\" from \");\n                            emit(node.moduleSpecifier);\n                        }\n                        write(\";\");\n                    }\n                }\n            }\n            function emitExportOrImportSpecifierList(specifiers, shouldEmit) {\n                ts.Debug.assert(modulekind === 5 /* ES6 */);\n                var needsComma = false;\n                for (var _a = 0; _a < specifiers.length; _a++) {\n                    var specifier = specifiers[_a];\n                    if (shouldEmit(specifier)) {\n                        if (needsComma) {\n                            write(\", \");\n                        }\n                        if (specifier.propertyName) {\n                            emit(specifier.propertyName);\n                            write(\" as \");\n                        }\n                        emit(specifier.name);\n                        needsComma = true;\n                    }\n                }\n            }\n            function emitExportAssignment(node) {\n                if (!node.isExportEquals && resolver.isValueAliasDeclaration(node)) {\n                    if (modulekind === 5 /* ES6 */) {\n                        writeLine();\n                        emitStart(node);\n                        write(\"export default \");\n                        var expression = node.expression;\n                        emit(expression);\n                        if (expression.kind !== 213 /* FunctionDeclaration */ &&\n                            expression.kind !== 214 /* ClassDeclaration */) {\n                            write(\";\");\n                        }\n                        emitEnd(node);\n                    }\n                    else {\n                        writeLine();\n                        emitStart(node);\n                        if (modulekind === 4 /* System */) {\n                            write(exportFunctionForFile + \"(\\\"default\\\",\");\n                            emit(node.expression);\n                            write(\")\");\n                        }\n                        else {\n                            emitEs6ExportDefaultCompat(node);\n                            emitContainingModuleName(node);\n                            if (languageVersion === 0 /* ES3 */) {\n                                write(\"[\\\"default\\\"] = \");\n                            }\n                            else {\n                                write(\".default = \");\n                            }\n                            emit(node.expression);\n                        }\n                        write(\";\");\n                        emitEnd(node);\n                    }\n                }\n            }\n            function collectExternalModuleInfo(sourceFile) {\n                externalImports = [];\n                exportSpecifiers = {};\n                exportEquals = undefined;\n                hasExportStars = false;\n                for (var _a = 0, _b = sourceFile.statements; _a < _b.length; _a++) {\n                    var node = _b[_a];\n                    switch (node.kind) {\n                        case 222 /* ImportDeclaration */:\n                            if (!node.importClause ||\n                                resolver.isReferencedAliasDeclaration(node.importClause, /*checkChildren*/ true)) {\n                                // import \"mod\"\n                                // import x from \"mod\" where x is referenced\n                                // import * as x from \"mod\" where x is referenced\n                                // import { x, y } from \"mod\" where at least one import is referenced\n                                externalImports.push(node);\n                            }\n                            break;\n                        case 221 /* ImportEqualsDeclaration */:\n                            if (node.moduleReference.kind === 232 /* ExternalModuleReference */ && resolver.isReferencedAliasDeclaration(node)) {\n                                // import x = require(\"mod\") where x is referenced\n                                externalImports.push(node);\n                            }\n                            break;\n                        case 228 /* ExportDeclaration */:\n                            if (node.moduleSpecifier) {\n                                if (!node.exportClause) {\n                                    // export * from \"mod\"\n                                    externalImports.push(node);\n                                    hasExportStars = true;\n                                }\n                                else if (resolver.isValueAliasDeclaration(node)) {\n                                    // export { x, y } from \"mod\" where at least one export is a value symbol\n                                    externalImports.push(node);\n                                }\n                            }\n                            else {\n                                // export { x, y }\n                                for (var _c = 0, _d = node.exportClause.elements; _c < _d.length; _c++) {\n                                    var specifier = _d[_c];\n                                    var name_25 = (specifier.propertyName || specifier.name).text;\n                                    (exportSpecifiers[name_25] || (exportSpecifiers[name_25] = [])).push(specifier);\n                                }\n                            }\n                            break;\n                        case 227 /* ExportAssignment */:\n                            if (node.isExportEquals && !exportEquals) {\n                                // export = x\n                                exportEquals = node;\n                            }\n                            break;\n                    }\n                }\n            }\n            function emitExportStarHelper() {\n                if (hasExportStars) {\n                    writeLine();\n                    write(\"function __export(m) {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                }\n            }\n            function getLocalNameForExternalImport(node) {\n                var namespaceDeclaration = getNamespaceDeclarationNode(node);\n                if (namespaceDeclaration && !isDefaultImport(node)) {\n                    return ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, namespaceDeclaration.name);\n                }\n                if (node.kind === 222 /* ImportDeclaration */ && node.importClause) {\n                    return getGeneratedNameForNode(node);\n                }\n                if (node.kind === 228 /* ExportDeclaration */ && node.moduleSpecifier) {\n                    return getGeneratedNameForNode(node);\n                }\n            }\n            function getExternalModuleNameText(importNode) {\n                var moduleName = ts.getExternalModuleName(importNode);\n                if (moduleName.kind === 9 /* StringLiteral */) {\n                    return tryRenameExternalModule(moduleName) || getLiteralText(moduleName);\n                }\n                return undefined;\n            }\n            function emitVariableDeclarationsForImports() {\n                if (externalImports.length === 0) {\n                    return;\n                }\n                writeLine();\n                var started = false;\n                for (var _a = 0; _a < externalImports.length; _a++) {\n                    var importNode = externalImports[_a];\n                    // do not create variable declaration for exports and imports that lack import clause\n                    var skipNode = importNode.kind === 228 /* ExportDeclaration */ ||\n                        (importNode.kind === 222 /* ImportDeclaration */ && !importNode.importClause);\n                    if (skipNode) {\n                        continue;\n                    }\n                    if (!started) {\n                        write(\"var \");\n                        started = true;\n                    }\n                    else {\n                        write(\", \");\n                    }\n                    write(getLocalNameForExternalImport(importNode));\n                }\n                if (started) {\n                    write(\";\");\n                }\n            }\n            function emitLocalStorageForExportedNamesIfNecessary(exportedDeclarations) {\n                // when resolving exports local exported entries/indirect exported entries in the module\n                // should always win over entries with similar names that were added via star exports\n                // to support this we store names of local/indirect exported entries in a set.\n                // this set is used to filter names brought by star expors.\n                if (!hasExportStars) {\n                    // local names set is needed only in presence of star exports\n                    return undefined;\n                }\n                // local names set should only be added if we have anything exported\n                if (!exportedDeclarations && ts.isEmpty(exportSpecifiers)) {\n                    // no exported declarations (export var ...) or export specifiers (export {x})\n                    // check if we have any non star export declarations.\n                    var hasExportDeclarationWithExportClause = false;\n                    for (var _a = 0; _a < externalImports.length; _a++) {\n                        var externalImport = externalImports[_a];\n                        if (externalImport.kind === 228 /* ExportDeclaration */ && externalImport.exportClause) {\n                            hasExportDeclarationWithExportClause = true;\n                            break;\n                        }\n                    }\n                    if (!hasExportDeclarationWithExportClause) {\n                        // we still need to emit exportStar helper\n                        return emitExportStarFunction(/*localNames*/ undefined);\n                    }\n                }\n                var exportedNamesStorageRef = makeUniqueName(\"exportedNames\");\n                writeLine();\n                write(\"var \" + exportedNamesStorageRef + \" = {\");\n                increaseIndent();\n                var started = false;\n                if (exportedDeclarations) {\n                    for (var i = 0; i < exportedDeclarations.length; ++i) {\n                        // write name of exported declaration, i.e 'export var x...'\n                        writeExportedName(exportedDeclarations[i]);\n                    }\n                }\n                if (exportSpecifiers) {\n                    for (var n in exportSpecifiers) {\n                        for (var _b = 0, _c = exportSpecifiers[n]; _b < _c.length; _b++) {\n                            var specifier = _c[_b];\n                            // write name of export specified, i.e. 'export {x}'\n                            writeExportedName(specifier.name);\n                        }\n                    }\n                }\n                for (var _d = 0; _d < externalImports.length; _d++) {\n                    var externalImport = externalImports[_d];\n                    if (externalImport.kind !== 228 /* ExportDeclaration */) {\n                        continue;\n                    }\n                    var exportDecl = externalImport;\n                    if (!exportDecl.exportClause) {\n                        // export * from ...\n                        continue;\n                    }\n                    for (var _e = 0, _f = exportDecl.exportClause.elements; _e < _f.length; _e++) {\n                        var element = _f[_e];\n                        // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                        writeExportedName(element.name || element.propertyName);\n                    }\n                }\n                decreaseIndent();\n                writeLine();\n                write(\"};\");\n                return emitExportStarFunction(exportedNamesStorageRef);\n                function emitExportStarFunction(localNames) {\n                    var exportStarFunction = makeUniqueName(\"exportStar\");\n                    writeLine();\n                    // define an export star helper function\n                    write(\"function \" + exportStarFunction + \"(m) {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"var exports = {};\");\n                    writeLine();\n                    write(\"for(var n in m) {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"if (n !== \\\"default\\\"\");\n                    if (localNames) {\n                        write(\"&& !\" + localNames + \".hasOwnProperty(n)\");\n                    }\n                    write(\") exports[n] = m[n];\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                    writeLine();\n                    write(exportFunctionForFile + \"(exports);\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                    return exportStarFunction;\n                }\n                function writeExportedName(node) {\n                    // do not record default exports\n                    // they are local to module and never overwritten (explicitly skipped) by star export\n                    if (node.kind !== 69 /* Identifier */ && node.flags & 1024 /* Default */) {\n                        return;\n                    }\n                    if (started) {\n                        write(\",\");\n                    }\n                    else {\n                        started = true;\n                    }\n                    writeLine();\n                    write(\"'\");\n                    if (node.kind === 69 /* Identifier */) {\n                        emitNodeWithCommentsAndWithoutSourcemap(node);\n                    }\n                    else {\n                        emitDeclarationName(node);\n                    }\n                    write(\"': true\");\n                }\n            }\n            function processTopLevelVariableAndFunctionDeclarations(node) {\n                // per ES6 spec:\n                // 15.2.1.16.4 ModuleDeclarationInstantiation() Concrete Method\n                // - var declarations are initialized to undefined - 14.a.ii\n                // - function/generator declarations are instantiated - 16.a.iv\n                // this means that after module is instantiated but before its evaluation\n                // exported functions are already accessible at import sites\n                // in theory we should hoist only exported functions and its dependencies\n                // in practice to simplify things we'll hoist all source level functions and variable declaration\n                // including variables declarations for module and class declarations\n                var hoistedVars;\n                var hoistedFunctionDeclarations;\n                var exportedDeclarations;\n                visit(node);\n                if (hoistedVars) {\n                    writeLine();\n                    write(\"var \");\n                    var seen = {};\n                    for (var i = 0; i < hoistedVars.length; ++i) {\n                        var local = hoistedVars[i];\n                        var name_26 = local.kind === 69 /* Identifier */\n                            ? local\n                            : local.name;\n                        if (name_26) {\n                            // do not emit duplicate entries (in case of declaration merging) in the list of hoisted variables\n                            var text = ts.unescapeIdentifier(name_26.text);\n                            if (ts.hasProperty(seen, text)) {\n                                continue;\n                            }\n                            else {\n                                seen[text] = text;\n                            }\n                        }\n                        if (i !== 0) {\n                            write(\", \");\n                        }\n                        if (local.kind === 214 /* ClassDeclaration */ || local.kind === 218 /* ModuleDeclaration */ || local.kind === 217 /* EnumDeclaration */) {\n                            emitDeclarationName(local);\n                        }\n                        else {\n                            emit(local);\n                        }\n                        var flags = ts.getCombinedNodeFlags(local.kind === 69 /* Identifier */ ? local.parent : local);\n                        if (flags & 1 /* Export */) {\n                            if (!exportedDeclarations) {\n                                exportedDeclarations = [];\n                            }\n                            exportedDeclarations.push(local);\n                        }\n                    }\n                    write(\";\");\n                }\n                if (hoistedFunctionDeclarations) {\n                    for (var _a = 0; _a < hoistedFunctionDeclarations.length; _a++) {\n                        var f = hoistedFunctionDeclarations[_a];\n                        writeLine();\n                        emit(f);\n                        if (f.flags & 1 /* Export */) {\n                            if (!exportedDeclarations) {\n                                exportedDeclarations = [];\n                            }\n                            exportedDeclarations.push(f);\n                        }\n                    }\n                }\n                return exportedDeclarations;\n                function visit(node) {\n                    if (node.flags & 2 /* Ambient */) {\n                        return;\n                    }\n                    if (node.kind === 213 /* FunctionDeclaration */) {\n                        if (!hoistedFunctionDeclarations) {\n                            hoistedFunctionDeclarations = [];\n                        }\n                        hoistedFunctionDeclarations.push(node);\n                        return;\n                    }\n                    if (node.kind === 214 /* ClassDeclaration */) {\n                        if (!hoistedVars) {\n                            hoistedVars = [];\n                        }\n                        hoistedVars.push(node);\n                        return;\n                    }\n                    if (node.kind === 217 /* EnumDeclaration */) {\n                        if (shouldEmitEnumDeclaration(node)) {\n                            if (!hoistedVars) {\n                                hoistedVars = [];\n                            }\n                            hoistedVars.push(node);\n                        }\n                        return;\n                    }\n                    if (node.kind === 218 /* ModuleDeclaration */) {\n                        if (shouldEmitModuleDeclaration(node)) {\n                            if (!hoistedVars) {\n                                hoistedVars = [];\n                            }\n                            hoistedVars.push(node);\n                        }\n                        return;\n                    }\n                    if (node.kind === 211 /* VariableDeclaration */ || node.kind === 163 /* BindingElement */) {\n                        if (shouldHoistVariable(node, /*checkIfSourceFileLevelDecl*/ false)) {\n                            var name_27 = node.name;\n                            if (name_27.kind === 69 /* Identifier */) {\n                                if (!hoistedVars) {\n                                    hoistedVars = [];\n                                }\n                                hoistedVars.push(name_27);\n                            }\n                            else {\n                                ts.forEachChild(name_27, visit);\n                            }\n                        }\n                        return;\n                    }\n                    if (ts.isInternalModuleImportEqualsDeclaration(node) && resolver.isValueAliasDeclaration(node)) {\n                        if (!hoistedVars) {\n                            hoistedVars = [];\n                        }\n                        hoistedVars.push(node.name);\n                        return;\n                    }\n                    if (ts.isBindingPattern(node)) {\n                        ts.forEach(node.elements, visit);\n                        return;\n                    }\n                    if (!ts.isDeclaration(node)) {\n                        ts.forEachChild(node, visit);\n                    }\n                }\n            }\n            function shouldHoistVariable(node, checkIfSourceFileLevelDecl) {\n                if (checkIfSourceFileLevelDecl && !shouldHoistDeclarationInSystemJsModule(node)) {\n                    return false;\n                }\n                // hoist variable if\n                // - it is not block scoped\n                // - it is top level block scoped\n                // if block scoped variables are nested in some another block then\n                // no other functions can use them except ones that are defined at least in the same block\n                return (ts.getCombinedNodeFlags(node) & 49152 /* BlockScoped */) === 0 ||\n                    ts.getEnclosingBlockScopeContainer(node).kind === 248 /* SourceFile */;\n            }\n            function isCurrentFileSystemExternalModule() {\n                return modulekind === 4 /* System */ && ts.isExternalModule(currentSourceFile);\n            }\n            function emitSystemModuleBody(node, dependencyGroups, startIndex) {\n                // shape of the body in system modules:\n                // function (exports) {\n                //     <list of local aliases for imports>\n                //     <hoisted function declarations>\n                //     <hoisted variable declarations>\n                //     return {\n                //         setters: [\n                //             <list of setter function for imports>\n                //         ],\n                //         execute: function() {\n                //             <module statements>\n                //         }\n                //     }\n                //     <temp declarations>\n                // }\n                // I.e:\n                // import {x} from 'file1'\n                // var y = 1;\n                // export function foo() { return y + x(); }\n                // console.log(y);\n                // will be transformed to\n                // function(exports) {\n                //     var file1; // local alias\n                //     var y;\n                //     function foo() { return y + file1.x(); }\n                //     exports(\"foo\", foo);\n                //     return {\n                //         setters: [\n                //             function(v) { file1 = v }\n                //         ],\n                //         execute(): function() {\n                //             y = 1;\n                //             console.log(y);\n                //         }\n                //     };\n                // }\n                emitVariableDeclarationsForImports();\n                writeLine();\n                var exportedDeclarations = processTopLevelVariableAndFunctionDeclarations(node);\n                var exportStarFunction = emitLocalStorageForExportedNamesIfNecessary(exportedDeclarations);\n                writeLine();\n                write(\"return {\");\n                increaseIndent();\n                writeLine();\n                emitSetters(exportStarFunction, dependencyGroups);\n                writeLine();\n                emitExecute(node, startIndex);\n                decreaseIndent();\n                writeLine();\n                write(\"}\"); // return\n                emitTempDeclarations(/*newLine*/ true);\n            }\n            function emitSetters(exportStarFunction, dependencyGroups) {\n                write(\"setters:[\");\n                for (var i = 0; i < dependencyGroups.length; ++i) {\n                    if (i !== 0) {\n                        write(\",\");\n                    }\n                    writeLine();\n                    increaseIndent();\n                    var group = dependencyGroups[i];\n                    // derive a unique name for parameter from the first named entry in the group\n                    var parameterName = makeUniqueName(ts.forEach(group, getLocalNameForExternalImport) || \"\");\n                    write(\"function (\" + parameterName + \") {\");\n                    increaseIndent();\n                    for (var _a = 0; _a < group.length; _a++) {\n                        var entry = group[_a];\n                        var importVariableName = getLocalNameForExternalImport(entry) || \"\";\n                        switch (entry.kind) {\n                            case 222 /* ImportDeclaration */:\n                                if (!entry.importClause) {\n                                    // 'import \"...\"' case\n                                    // module is imported only for side-effects, no emit required\n                                    break;\n                                }\n                            // fall-through\n                            case 221 /* ImportEqualsDeclaration */:\n                                ts.Debug.assert(importVariableName !== \"\");\n                                writeLine();\n                                // save import into the local\n                                write(importVariableName + \" = \" + parameterName + \";\");\n                                writeLine();\n                                break;\n                            case 228 /* ExportDeclaration */:\n                                ts.Debug.assert(importVariableName !== \"\");\n                                if (entry.exportClause) {\n                                    // export {a, b as c} from 'foo'\n                                    // emit as:\n                                    // exports_({\n                                    //    \"a\": _[\"a\"],\n                                    //    \"c\": _[\"b\"]\n                                    // });\n                                    writeLine();\n                                    write(exportFunctionForFile + \"({\");\n                                    writeLine();\n                                    increaseIndent();\n                                    for (var i_2 = 0, len = entry.exportClause.elements.length; i_2 < len; ++i_2) {\n                                        if (i_2 !== 0) {\n                                            write(\",\");\n                                            writeLine();\n                                        }\n                                        var e = entry.exportClause.elements[i_2];\n                                        write(\"\\\"\");\n                                        emitNodeWithCommentsAndWithoutSourcemap(e.name);\n                                        write(\"\\\": \" + parameterName + \"[\\\"\");\n                                        emitNodeWithCommentsAndWithoutSourcemap(e.propertyName || e.name);\n                                        write(\"\\\"]\");\n                                    }\n                                    decreaseIndent();\n                                    writeLine();\n                                    write(\"});\");\n                                }\n                                else {\n                                    writeLine();\n                                    // export * from 'foo'\n                                    // emit as:\n                                    // exportStar(_foo);\n                                    write(exportStarFunction + \"(\" + parameterName + \");\");\n                                }\n                                writeLine();\n                                break;\n                        }\n                    }\n                    decreaseIndent();\n                    write(\"}\");\n                    decreaseIndent();\n                }\n                write(\"],\");\n            }\n            function emitExecute(node, startIndex) {\n                write(\"execute: function() {\");\n                increaseIndent();\n                writeLine();\n                for (var i = startIndex; i < node.statements.length; ++i) {\n                    var statement = node.statements[i];\n                    switch (statement.kind) {\n                        // - function declarations are not emitted because they were already hoisted\n                        // - import declarations are not emitted since they are already handled in setters\n                        // - export declarations with module specifiers are not emitted since they were already written in setters\n                        // - export declarations without module specifiers are emitted preserving the order\n                        case 213 /* FunctionDeclaration */:\n                        case 222 /* ImportDeclaration */:\n                            continue;\n                        case 228 /* ExportDeclaration */:\n                            if (!statement.moduleSpecifier) {\n                                for (var _a = 0, _b = statement.exportClause.elements; _a < _b.length; _a++) {\n                                    var element = _b[_a];\n                                    // write call to exporter function for every export specifier in exports list\n                                    emitExportSpecifierInSystemModule(element);\n                                }\n                            }\n                            continue;\n                        case 221 /* ImportEqualsDeclaration */:\n                            if (!ts.isInternalModuleImportEqualsDeclaration(statement)) {\n                                // - import equals declarations that import external modules are not emitted\n                                continue;\n                            }\n                        // fall-though for import declarations that import internal modules\n                        default:\n                            writeLine();\n                            emit(statement);\n                    }\n                }\n                decreaseIndent();\n                writeLine();\n                write(\"}\"); // execute\n            }\n            function emitSystemModule(node) {\n                collectExternalModuleInfo(node);\n                // System modules has the following shape\n                // System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n                // 'exports' here is a function 'exports<T>(name: string, value: T): T' that is used to publish exported values.\n                // 'exports' returns its 'value' argument so in most cases expressions\n                // that mutate exported values can be rewritten as:\n                // expr -> exports('name', expr).\n                // The only exception in this rule is postfix unary operators,\n                // see comment to 'emitPostfixUnaryExpression' for more details\n                ts.Debug.assert(!exportFunctionForFile);\n                // make sure that  name of 'exports' function does not conflict with existing identifiers\n                exportFunctionForFile = makeUniqueName(\"exports\");\n                writeLine();\n                write(\"System.register(\");\n                if (node.moduleName) {\n                    write(\"\\\"\" + node.moduleName + \"\\\", \");\n                }\n                write(\"[\");\n                var groupIndices = {};\n                var dependencyGroups = [];\n                for (var i = 0; i < externalImports.length; ++i) {\n                    var text = getExternalModuleNameText(externalImports[i]);\n                    if (ts.hasProperty(groupIndices, text)) {\n                        // deduplicate/group entries in dependency list by the dependency name\n                        var groupIndex = groupIndices[text];\n                        dependencyGroups[groupIndex].push(externalImports[i]);\n                        continue;\n                    }\n                    else {\n                        groupIndices[text] = dependencyGroups.length;\n                        dependencyGroups.push([externalImports[i]]);\n                    }\n                    if (i !== 0) {\n                        write(\", \");\n                    }\n                    write(text);\n                }\n                write(\"], function(\" + exportFunctionForFile + \") {\");\n                writeLine();\n                increaseIndent();\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ true);\n                emitEmitHelpers(node);\n                emitCaptureThisForNodeIfNecessary(node);\n                emitSystemModuleBody(node, dependencyGroups, startIndex);\n                decreaseIndent();\n                writeLine();\n                write(\"});\");\n            }\n            function getAMDDependencyNames(node, includeNonAmdDependencies) {\n                // names of modules with corresponding parameter in the factory function\n                var aliasedModuleNames = [];\n                // names of modules with no corresponding parameters in factory function\n                var unaliasedModuleNames = [];\n                var importAliasNames = []; // names of the parameters in the factory function; these\n                // parameters need to match the indexes of the corresponding\n                // module names in aliasedModuleNames.\n                // Fill in amd-dependency tags\n                for (var _a = 0, _b = node.amdDependencies; _a < _b.length; _a++) {\n                    var amdDependency = _b[_a];\n                    if (amdDependency.name) {\n                        aliasedModuleNames.push(\"\\\"\" + amdDependency.path + \"\\\"\");\n                        importAliasNames.push(amdDependency.name);\n                    }\n                    else {\n                        unaliasedModuleNames.push(\"\\\"\" + amdDependency.path + \"\\\"\");\n                    }\n                }\n                for (var _c = 0; _c < externalImports.length; _c++) {\n                    var importNode = externalImports[_c];\n                    // Find the name of the external module\n                    var externalModuleName = getExternalModuleNameText(importNode);\n                    // Find the name of the module alias, if there is one\n                    var importAliasName = getLocalNameForExternalImport(importNode);\n                    if (includeNonAmdDependencies && importAliasName) {\n                        aliasedModuleNames.push(externalModuleName);\n                        importAliasNames.push(importAliasName);\n                    }\n                    else {\n                        unaliasedModuleNames.push(externalModuleName);\n                    }\n                }\n                return { aliasedModuleNames: aliasedModuleNames, unaliasedModuleNames: unaliasedModuleNames, importAliasNames: importAliasNames };\n            }\n            function emitAMDDependencies(node, includeNonAmdDependencies) {\n                // An AMD define function has the following shape:\n                //     define(id?, dependencies?, factory);\n                //\n                // This has the shape of\n                //     define(name, [\"module1\", \"module2\"], function (module1Alias) {\n                // The location of the alias in the parameter list in the factory function needs to\n                // match the position of the module name in the dependency list.\n                //\n                // To ensure this is true in cases of modules with no aliases, e.g.:\n                // `import \"module\"` or `<amd-dependency path= \"a.css\" />`\n                // we need to add modules without alias names to the end of the dependencies list\n                var dependencyNames = getAMDDependencyNames(node, includeNonAmdDependencies);\n                emitAMDDependencyList(dependencyNames);\n                write(\", \");\n                emitAMDFactoryHeader(dependencyNames);\n            }\n            function emitAMDDependencyList(_a) {\n                var aliasedModuleNames = _a.aliasedModuleNames, unaliasedModuleNames = _a.unaliasedModuleNames;\n                write(\"[\\\"require\\\", \\\"exports\\\"\");\n                if (aliasedModuleNames.length) {\n                    write(\", \");\n                    write(aliasedModuleNames.join(\", \"));\n                }\n                if (unaliasedModuleNames.length) {\n                    write(\", \");\n                    write(unaliasedModuleNames.join(\", \"));\n                }\n                write(\"]\");\n            }\n            function emitAMDFactoryHeader(_a) {\n                var importAliasNames = _a.importAliasNames;\n                write(\"function (require, exports\");\n                if (importAliasNames.length) {\n                    write(\", \");\n                    write(importAliasNames.join(\", \"));\n                }\n                write(\") {\");\n            }\n            function emitAMDModule(node) {\n                emitEmitHelpers(node);\n                collectExternalModuleInfo(node);\n                writeLine();\n                write(\"define(\");\n                if (node.moduleName) {\n                    write(\"\\\"\" + node.moduleName + \"\\\", \");\n                }\n                emitAMDDependencies(node, /*includeNonAmdDependencies*/ true);\n                increaseIndent();\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ true);\n                emitExportStarHelper();\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                emitTempDeclarations(/*newLine*/ true);\n                emitExportEquals(/*emitAsReturn*/ true);\n                decreaseIndent();\n                writeLine();\n                write(\"});\");\n            }\n            function emitCommonJSModule(node) {\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ false);\n                emitEmitHelpers(node);\n                collectExternalModuleInfo(node);\n                emitExportStarHelper();\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                emitTempDeclarations(/*newLine*/ true);\n                emitExportEquals(/*emitAsReturn*/ false);\n            }\n            function emitUMDModule(node) {\n                emitEmitHelpers(node);\n                collectExternalModuleInfo(node);\n                var dependencyNames = getAMDDependencyNames(node, /*includeNonAmdDependencies*/ false);\n                // Module is detected first to support Browserify users that load into a browser with an AMD loader\n                writeLines(\"(function (factory) {\\n    if (typeof module === 'object' && typeof module.exports === 'object') {\\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\\n    }\\n    else if (typeof define === 'function' && define.amd) {\\n        define(\");\n                emitAMDDependencyList(dependencyNames);\n                write(\", factory);\");\n                writeLines(\"    }\\n})(\");\n                emitAMDFactoryHeader(dependencyNames);\n                increaseIndent();\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ true);\n                emitExportStarHelper();\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                emitTempDeclarations(/*newLine*/ true);\n                emitExportEquals(/*emitAsReturn*/ true);\n                decreaseIndent();\n                writeLine();\n                write(\"});\");\n            }\n            function emitES6Module(node) {\n                externalImports = undefined;\n                exportSpecifiers = undefined;\n                exportEquals = undefined;\n                hasExportStars = false;\n                var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ false);\n                emitEmitHelpers(node);\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                emitTempDeclarations(/*newLine*/ true);\n                // Emit exportDefault if it exists will happen as part\n                // or normal statement emit.\n            }\n            function emitExportEquals(emitAsReturn) {\n                if (exportEquals && resolver.isValueAliasDeclaration(exportEquals)) {\n                    writeLine();\n                    emitStart(exportEquals);\n                    write(emitAsReturn ? \"return \" : \"module.exports = \");\n                    emit(exportEquals.expression);\n                    write(\";\");\n                    emitEnd(exportEquals);\n                }\n            }\n            function emitJsxElement(node) {\n                switch (compilerOptions.jsx) {\n                    case 2 /* React */:\n                        jsxEmitReact(node);\n                        break;\n                    case 1 /* Preserve */:\n                    // Fall back to preserve if None was specified (we'll error earlier)\n                    default:\n                        jsxEmitPreserve(node);\n                        break;\n                }\n            }\n            function trimReactWhitespaceAndApplyEntities(node) {\n                var result = undefined;\n                var text = ts.getTextOfNode(node, /*includeTrivia*/ true);\n                var firstNonWhitespace = 0;\n                var lastNonWhitespace = -1;\n                // JSX trims whitespace at the end and beginning of lines, except that the\n                // start/end of a tag is considered a start/end of a line only if that line is\n                // on the same line as the closing tag. See examples in tests/cases/conformance/jsx/tsxReactEmitWhitespace.tsx\n                for (var i = 0; i < text.length; i++) {\n                    var c = text.charCodeAt(i);\n                    if (ts.isLineBreak(c)) {\n                        if (firstNonWhitespace !== -1 && (lastNonWhitespace - firstNonWhitespace + 1 > 0)) {\n                            var part = text.substr(firstNonWhitespace, lastNonWhitespace - firstNonWhitespace + 1);\n                            result = (result ? result + \"\\\" + ' ' + \\\"\" : \"\") + ts.escapeString(part);\n                        }\n                        firstNonWhitespace = -1;\n                    }\n                    else if (!ts.isWhiteSpace(c)) {\n                        lastNonWhitespace = i;\n                        if (firstNonWhitespace === -1) {\n                            firstNonWhitespace = i;\n                        }\n                    }\n                }\n                if (firstNonWhitespace !== -1) {\n                    var part = text.substr(firstNonWhitespace);\n                    result = (result ? result + \"\\\" + ' ' + \\\"\" : \"\") + ts.escapeString(part);\n                }\n                if (result) {\n                    // Replace entities like &nbsp;\n                    result = result.replace(/&(\\w+);/g, function (s, m) {\n                        if (entities[m] !== undefined) {\n                            return String.fromCharCode(entities[m]);\n                        }\n                        else {\n                            return s;\n                        }\n                    });\n                }\n                return result;\n            }\n            function getTextToEmit(node) {\n                switch (compilerOptions.jsx) {\n                    case 2 /* React */:\n                        var text = trimReactWhitespaceAndApplyEntities(node);\n                        if (text === undefined || text.length === 0) {\n                            return undefined;\n                        }\n                        else {\n                            return text;\n                        }\n                    case 1 /* Preserve */:\n                    default:\n                        return ts.getTextOfNode(node, /*includeTrivia*/ true);\n                }\n            }\n            function emitJsxText(node) {\n                switch (compilerOptions.jsx) {\n                    case 2 /* React */:\n                        write(\"\\\"\");\n                        write(trimReactWhitespaceAndApplyEntities(node));\n                        write(\"\\\"\");\n                        break;\n                    case 1 /* Preserve */:\n                    default:\n                        writer.writeLiteral(ts.getTextOfNode(node, /*includeTrivia*/ true));\n                        break;\n                }\n            }\n            function emitJsxExpression(node) {\n                if (node.expression) {\n                    switch (compilerOptions.jsx) {\n                        case 1 /* Preserve */:\n                        default:\n                            write(\"{\");\n                            emit(node.expression);\n                            write(\"}\");\n                            break;\n                        case 2 /* React */:\n                            emit(node.expression);\n                            break;\n                    }\n                }\n            }\n            function emitDirectivePrologues(statements, startWithNewLine) {\n                for (var i = 0; i < statements.length; ++i) {\n                    if (ts.isPrologueDirective(statements[i])) {\n                        if (startWithNewLine || i > 0) {\n                            writeLine();\n                        }\n                        emit(statements[i]);\n                    }\n                    else {\n                        // return index of the first non prologue directive\n                        return i;\n                    }\n                }\n                return statements.length;\n            }\n            function writeLines(text) {\n                var lines = text.split(/\\r\\n|\\r|\\n/g);\n                for (var i = 0; i < lines.length; ++i) {\n                    var line = lines[i];\n                    if (line.length) {\n                        writeLine();\n                        write(line);\n                    }\n                }\n            }\n            function emitEmitHelpers(node) {\n                // Only emit helpers if the user did not say otherwise.\n                if (!compilerOptions.noEmitHelpers) {\n                    // Only Emit __extends function when target ES5.\n                    // For target ES6 and above, we can emit classDeclaration as is.\n                    if ((languageVersion < 2 /* ES6 */) && (!extendsEmitted && resolver.getNodeCheckFlags(node) & 8 /* EmitExtends */)) {\n                        writeLines(extendsHelper);\n                        extendsEmitted = true;\n                    }\n                    if (!decorateEmitted && resolver.getNodeCheckFlags(node) & 16 /* EmitDecorate */) {\n                        writeLines(decorateHelper);\n                        if (compilerOptions.emitDecoratorMetadata) {\n                            writeLines(metadataHelper);\n                        }\n                        decorateEmitted = true;\n                    }\n                    if (!paramEmitted && resolver.getNodeCheckFlags(node) & 32 /* EmitParam */) {\n                        writeLines(paramHelper);\n                        paramEmitted = true;\n                    }\n                    if (!awaiterEmitted && resolver.getNodeCheckFlags(node) & 64 /* EmitAwaiter */) {\n                        writeLines(awaiterHelper);\n                        awaiterEmitted = true;\n                    }\n                }\n            }\n            function emitSourceFileNode(node) {\n                // Start new file on new line\n                writeLine();\n                emitShebang();\n                emitDetachedComments(node);\n                if (ts.isExternalModule(node) || compilerOptions.isolatedModules) {\n                    var emitModule = moduleEmitDelegates[modulekind] || moduleEmitDelegates[1 /* CommonJS */];\n                    emitModule(node);\n                }\n                else {\n                    // emit prologue directives prior to __extends\n                    var startIndex = emitDirectivePrologues(node.statements, /*startWithNewLine*/ false);\n                    externalImports = undefined;\n                    exportSpecifiers = undefined;\n                    exportEquals = undefined;\n                    hasExportStars = false;\n                    emitEmitHelpers(node);\n                    emitCaptureThisForNodeIfNecessary(node);\n                    emitLinesStartingAt(node.statements, startIndex);\n                    emitTempDeclarations(/*newLine*/ true);\n                }\n                emitLeadingComments(node.endOfFileToken);\n            }\n            function emitNodeWithCommentsAndWithoutSourcemap(node) {\n                emitNodeConsideringCommentsOption(node, emitNodeWithoutSourceMap);\n            }\n            function emitNodeConsideringCommentsOption(node, emitNodeConsideringSourcemap) {\n                if (node) {\n                    if (node.flags & 2 /* Ambient */) {\n                        return emitCommentsOnNotEmittedNode(node);\n                    }\n                    if (isSpecializedCommentHandling(node)) {\n                        // This is the node that will handle its own comments and sourcemap\n                        return emitNodeWithoutSourceMap(node);\n                    }\n                    var emitComments_1 = shouldEmitLeadingAndTrailingComments(node);\n                    if (emitComments_1) {\n                        emitLeadingComments(node);\n                    }\n                    emitNodeConsideringSourcemap(node);\n                    if (emitComments_1) {\n                        emitTrailingComments(node);\n                    }\n                }\n            }\n            function emitNodeWithoutSourceMap(node) {\n                if (node) {\n                    emitJavaScriptWorker(node);\n                }\n            }\n            function isSpecializedCommentHandling(node) {\n                switch (node.kind) {\n                    // All of these entities are emitted in a specialized fashion.  As such, we allow\n                    // the specialized methods for each to handle the comments on the nodes.\n                    case 215 /* InterfaceDeclaration */:\n                    case 213 /* FunctionDeclaration */:\n                    case 222 /* ImportDeclaration */:\n                    case 221 /* ImportEqualsDeclaration */:\n                    case 216 /* TypeAliasDeclaration */:\n                    case 227 /* ExportAssignment */:\n                        return true;\n                }\n            }\n            function shouldEmitLeadingAndTrailingComments(node) {\n                switch (node.kind) {\n                    case 193 /* VariableStatement */:\n                        return shouldEmitLeadingAndTrailingCommentsForVariableStatement(node);\n                    case 218 /* ModuleDeclaration */:\n                        // Only emit the leading/trailing comments for a module if we're actually\n                        // emitting the module as well.\n                        return shouldEmitModuleDeclaration(node);\n                    case 217 /* EnumDeclaration */:\n                        // Only emit the leading/trailing comments for an enum if we're actually\n                        // emitting the module as well.\n                        return shouldEmitEnumDeclaration(node);\n                }\n                // If the node is emitted in specialized fashion, dont emit comments as this node will handle\n                // emitting comments when emitting itself\n                ts.Debug.assert(!isSpecializedCommentHandling(node));\n                // If this is the expression body of an arrow function that we're down-leveling,\n                // then we don't want to emit comments when we emit the body.  It will have already\n                // been taken care of when we emitted the 'return' statement for the function\n                // expression body.\n                if (node.kind !== 192 /* Block */ &&\n                    node.parent &&\n                    node.parent.kind === 174 /* ArrowFunction */ &&\n                    node.parent.body === node &&\n                    compilerOptions.target <= 1 /* ES5 */) {\n                    return false;\n                }\n                // Emit comments for everything else.\n                return true;\n            }\n            function emitJavaScriptWorker(node) {\n                // Check if the node can be emitted regardless of the ScriptTarget\n                switch (node.kind) {\n                    case 69 /* Identifier */:\n                        return emitIdentifier(node);\n                    case 138 /* Parameter */:\n                        return emitParameter(node);\n                    case 143 /* MethodDeclaration */:\n                    case 142 /* MethodSignature */:\n                        return emitMethod(node);\n                    case 145 /* GetAccessor */:\n                    case 146 /* SetAccessor */:\n                        return emitAccessor(node);\n                    case 97 /* ThisKeyword */:\n                        return emitThis(node);\n                    case 95 /* SuperKeyword */:\n                        return emitSuper(node);\n                    case 93 /* NullKeyword */:\n                        return write(\"null\");\n                    case 99 /* TrueKeyword */:\n                        return write(\"true\");\n                    case 84 /* FalseKeyword */:\n                        return write(\"false\");\n                    case 8 /* NumericLiteral */:\n                    case 9 /* StringLiteral */:\n                    case 10 /* RegularExpressionLiteral */:\n                    case 11 /* NoSubstitutionTemplateLiteral */:\n                    case 12 /* TemplateHead */:\n                    case 13 /* TemplateMiddle */:\n                    case 14 /* TemplateTail */:\n                        return emitLiteral(node);\n                    case 183 /* TemplateExpression */:\n                        return emitTemplateExpression(node);\n                    case 190 /* TemplateSpan */:\n                        return emitTemplateSpan(node);\n                    case 233 /* JsxElement */:\n                    case 234 /* JsxSelfClosingElement */:\n                        return emitJsxElement(node);\n                    case 236 /* JsxText */:\n                        return emitJsxText(node);\n                    case 240 /* JsxExpression */:\n                        return emitJsxExpression(node);\n                    case 135 /* QualifiedName */:\n                        return emitQualifiedName(node);\n                    case 161 /* ObjectBindingPattern */:\n                        return emitObjectBindingPattern(node);\n                    case 162 /* ArrayBindingPattern */:\n                        return emitArrayBindingPattern(node);\n                    case 163 /* BindingElement */:\n                        return emitBindingElement(node);\n                    case 164 /* ArrayLiteralExpression */:\n                        return emitArrayLiteral(node);\n                    case 165 /* ObjectLiteralExpression */:\n                        return emitObjectLiteral(node);\n                    case 245 /* PropertyAssignment */:\n                        return emitPropertyAssignment(node);\n                    case 246 /* ShorthandPropertyAssignment */:\n                        return emitShorthandPropertyAssignment(node);\n                    case 136 /* ComputedPropertyName */:\n                        return emitComputedPropertyName(node);\n                    case 166 /* PropertyAccessExpression */:\n                        return emitPropertyAccess(node);\n                    case 167 /* ElementAccessExpression */:\n                        return emitIndexedAccess(node);\n                    case 168 /* CallExpression */:\n                        return emitCallExpression(node);\n                    case 169 /* NewExpression */:\n                        return emitNewExpression(node);\n                    case 170 /* TaggedTemplateExpression */:\n                        return emitTaggedTemplateExpression(node);\n                    case 171 /* TypeAssertionExpression */:\n                        return emit(node.expression);\n                    case 189 /* AsExpression */:\n                        return emit(node.expression);\n                    case 172 /* ParenthesizedExpression */:\n                        return emitParenExpression(node);\n                    case 213 /* FunctionDeclaration */:\n                    case 173 /* FunctionExpression */:\n                    case 174 /* ArrowFunction */:\n                        return emitFunctionDeclaration(node);\n                    case 175 /* DeleteExpression */:\n                        return emitDeleteExpression(node);\n                    case 176 /* TypeOfExpression */:\n                        return emitTypeOfExpression(node);\n                    case 177 /* VoidExpression */:\n                        return emitVoidExpression(node);\n                    case 178 /* AwaitExpression */:\n                        return emitAwaitExpression(node);\n                    case 179 /* PrefixUnaryExpression */:\n                        return emitPrefixUnaryExpression(node);\n                    case 180 /* PostfixUnaryExpression */:\n                        return emitPostfixUnaryExpression(node);\n                    case 181 /* BinaryExpression */:\n                        return emitBinaryExpression(node);\n                    case 182 /* ConditionalExpression */:\n                        return emitConditionalExpression(node);\n                    case 185 /* SpreadElementExpression */:\n                        return emitSpreadElementExpression(node);\n                    case 184 /* YieldExpression */:\n                        return emitYieldExpression(node);\n                    case 187 /* OmittedExpression */:\n                        return;\n                    case 192 /* Block */:\n                    case 219 /* ModuleBlock */:\n                        return emitBlock(node);\n                    case 193 /* VariableStatement */:\n                        return emitVariableStatement(node);\n                    case 194 /* EmptyStatement */:\n                        return write(\";\");\n                    case 195 /* ExpressionStatement */:\n                        return emitExpressionStatement(node);\n                    case 196 /* IfStatement */:\n                        return emitIfStatement(node);\n                    case 197 /* DoStatement */:\n                        return emitDoStatement(node);\n                    case 198 /* WhileStatement */:\n                        return emitWhileStatement(node);\n                    case 199 /* ForStatement */:\n                        return emitForStatement(node);\n                    case 201 /* ForOfStatement */:\n                    case 200 /* ForInStatement */:\n                        return emitForInOrForOfStatement(node);\n                    case 202 /* ContinueStatement */:\n                    case 203 /* BreakStatement */:\n                        return emitBreakOrContinueStatement(node);\n                    case 204 /* ReturnStatement */:\n                        return emitReturnStatement(node);\n                    case 205 /* WithStatement */:\n                        return emitWithStatement(node);\n                    case 206 /* SwitchStatement */:\n                        return emitSwitchStatement(node);\n                    case 241 /* CaseClause */:\n                    case 242 /* DefaultClause */:\n                        return emitCaseOrDefaultClause(node);\n                    case 207 /* LabeledStatement */:\n                        return emitLabelledStatement(node);\n                    case 208 /* ThrowStatement */:\n                        return emitThrowStatement(node);\n                    case 209 /* TryStatement */:\n                        return emitTryStatement(node);\n                    case 244 /* CatchClause */:\n                        return emitCatchClause(node);\n                    case 210 /* DebuggerStatement */:\n                        return emitDebuggerStatement(node);\n                    case 211 /* VariableDeclaration */:\n                        return emitVariableDeclaration(node);\n                    case 186 /* ClassExpression */:\n                        return emitClassExpression(node);\n                    case 214 /* ClassDeclaration */:\n                        return emitClassDeclaration(node);\n                    case 215 /* InterfaceDeclaration */:\n                        return emitInterfaceDeclaration(node);\n                    case 217 /* EnumDeclaration */:\n                        return emitEnumDeclaration(node);\n                    case 247 /* EnumMember */:\n                        return emitEnumMember(node);\n                    case 218 /* ModuleDeclaration */:\n                        return emitModuleDeclaration(node);\n                    case 222 /* ImportDeclaration */:\n                        return emitImportDeclaration(node);\n                    case 221 /* ImportEqualsDeclaration */:\n                        return emitImportEqualsDeclaration(node);\n                    case 228 /* ExportDeclaration */:\n                        return emitExportDeclaration(node);\n                    case 227 /* ExportAssignment */:\n                        return emitExportAssignment(node);\n                    case 248 /* SourceFile */:\n                        return emitSourceFileNode(node);\n                }\n            }\n            function hasDetachedComments(pos) {\n                return detachedCommentsInfo !== undefined && ts.lastOrUndefined(detachedCommentsInfo).nodePos === pos;\n            }\n            function getLeadingCommentsWithoutDetachedComments() {\n                // get the leading comments from detachedPos\n                var leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, ts.lastOrUndefined(detachedCommentsInfo).detachedCommentEndPos);\n                if (detachedCommentsInfo.length - 1) {\n                    detachedCommentsInfo.pop();\n                }\n                else {\n                    detachedCommentsInfo = undefined;\n                }\n                return leadingComments;\n            }\n            function isPinnedComments(comment) {\n                return currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */ &&\n                    currentSourceFile.text.charCodeAt(comment.pos + 2) === 33 /* exclamation */;\n            }\n            /**\n             * Determine if the given comment is a triple-slash\n             *\n             * @return true if the comment is a triple-slash comment else false\n             **/\n            function isTripleSlashComment(comment) {\n                // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text\n                // so that we don't end up computing comment string and doing match for all // comments\n                if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 47 /* slash */ &&\n                    comment.pos + 2 < comment.end &&\n                    currentSourceFile.text.charCodeAt(comment.pos + 2) === 47 /* slash */) {\n                    var textSubStr = currentSourceFile.text.substring(comment.pos, comment.end);\n                    return textSubStr.match(ts.fullTripleSlashReferencePathRegEx) ||\n                    textSubStr.match(ts.fullTripleSlashAMDReferencePathRegEx) ?\n                        true : false;\n                }\n                return false;\n            }\n            function getLeadingCommentsToEmit(node) {\n                // Emit the leading comments only if the parent's pos doesn't match because parent should take care of emitting these comments\n                if (node.parent) {\n                    if (node.parent.kind === 248 /* SourceFile */ || node.pos !== node.parent.pos) {\n                        if (hasDetachedComments(node.pos)) {\n                            // get comments without detached comments\n                            return getLeadingCommentsWithoutDetachedComments();\n                        }\n                        else {\n                            // get the leading comments from the node\n                            return ts.getLeadingCommentRangesOfNode(node, currentSourceFile);\n                        }\n                    }\n                }\n            }\n            function getTrailingCommentsToEmit(node) {\n                // Emit the trailing comments only if the parent's pos doesn't match because parent should take care of emitting these comments\n                if (node.parent) {\n                    if (node.parent.kind === 248 /* SourceFile */ || node.end !== node.parent.end) {\n                        return ts.getTrailingCommentRanges(currentSourceFile.text, node.end);\n                    }\n                }\n            }\n            /**\n             * Emit comments associated with node that will not be emitted into JS file\n             */\n            function emitCommentsOnNotEmittedNode(node) {\n                emitLeadingCommentsWorker(node, /*isEmittedNode:*/ false);\n            }\n            function emitLeadingComments(node) {\n                return emitLeadingCommentsWorker(node, /*isEmittedNode:*/ true);\n            }\n            function emitLeadingCommentsWorker(node, isEmittedNode) {\n                if (compilerOptions.removeComments) {\n                    return;\n                }\n                var leadingComments;\n                if (isEmittedNode) {\n                    leadingComments = getLeadingCommentsToEmit(node);\n                }\n                else {\n                    // If the node will not be emitted in JS, remove all the comments(normal, pinned and ///) associated with the node,\n                    // unless it is a triple slash comment at the top of the file.\n                    // For Example:\n                    //      /// <reference-path ...>\n                    //      declare var x;\n                    //      /// <reference-path ...>\n                    //      interface F {}\n                    //  The first /// will NOT be removed while the second one will be removed eventhough both node will not be emitted\n                    if (node.pos === 0) {\n                        leadingComments = ts.filter(getLeadingCommentsToEmit(node), isTripleSlashComment);\n                    }\n                }\n                ts.emitNewLineBeforeLeadingComments(currentSourceFile, writer, node, leadingComments);\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\n                ts.emitComments(currentSourceFile, writer, leadingComments, /*trailingSeparator:*/ true, newLine, writeComment);\n            }\n            function emitTrailingComments(node) {\n                if (compilerOptions.removeComments) {\n                    return;\n                }\n                // Emit the trailing comments only if the parent's end doesn't match\n                var trailingComments = getTrailingCommentsToEmit(node);\n                // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/\n                ts.emitComments(currentSourceFile, writer, trailingComments, /*trailingSeparator*/ false, newLine, writeComment);\n            }\n            /**\n             * Emit trailing comments at the position. The term trailing comment is used here to describe following comment:\n             *      x, /comment1/ y\n             *        ^ => pos; the function will emit \"comment1\" in the emitJS\n             */\n            function emitTrailingCommentsOfPosition(pos) {\n                if (compilerOptions.removeComments) {\n                    return;\n                }\n                var trailingComments = ts.getTrailingCommentRanges(currentSourceFile.text, pos);\n                // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/\n                ts.emitComments(currentSourceFile, writer, trailingComments, /*trailingSeparator*/ true, newLine, writeComment);\n            }\n            function emitLeadingCommentsOfPositionWorker(pos) {\n                if (compilerOptions.removeComments) {\n                    return;\n                }\n                var leadingComments;\n                if (hasDetachedComments(pos)) {\n                    // get comments without detached comments\n                    leadingComments = getLeadingCommentsWithoutDetachedComments();\n                }\n                else {\n                    // get the leading comments from the node\n                    leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, pos);\n                }\n                ts.emitNewLineBeforeLeadingComments(currentSourceFile, writer, { pos: pos, end: pos }, leadingComments);\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\n                ts.emitComments(currentSourceFile, writer, leadingComments, /*trailingSeparator*/ true, newLine, writeComment);\n            }\n            function emitDetachedComments(node) {\n                var leadingComments;\n                if (compilerOptions.removeComments) {\n                    // removeComments is true, only reserve pinned comment at the top of file\n                    // For example:\n                    //      /*! Pinned Comment */\n                    //\n                    //      var x = 10;\n                    if (node.pos === 0) {\n                        leadingComments = ts.filter(ts.getLeadingCommentRanges(currentSourceFile.text, node.pos), isPinnedComments);\n                    }\n                }\n                else {\n                    // removeComments is false, just get detached as normal and bypass the process to filter comment\n                    leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, node.pos);\n                }\n                if (leadingComments) {\n                    var detachedComments = [];\n                    var lastComment;\n                    ts.forEach(leadingComments, function (comment) {\n                        if (lastComment) {\n                            var lastCommentLine = ts.getLineOfLocalPosition(currentSourceFile, lastComment.end);\n                            var commentLine = ts.getLineOfLocalPosition(currentSourceFile, comment.pos);\n                            if (commentLine >= lastCommentLine + 2) {\n                                // There was a blank line between the last comment and this comment.  This\n                                // comment is not part of the copyright comments.  Return what we have so\n                                // far.\n                                return detachedComments;\n                            }\n                        }\n                        detachedComments.push(comment);\n                        lastComment = comment;\n                    });\n                    if (detachedComments.length) {\n                        // All comments look like they could have been part of the copyright header.  Make\n                        // sure there is at least one blank line between it and the node.  If not, it's not\n                        // a copyright header.\n                        var lastCommentLine = ts.getLineOfLocalPosition(currentSourceFile, ts.lastOrUndefined(detachedComments).end);\n                        var nodeLine = ts.getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node.pos));\n                        if (nodeLine >= lastCommentLine + 2) {\n                            // Valid detachedComments\n                            ts.emitNewLineBeforeLeadingComments(currentSourceFile, writer, node, leadingComments);\n                            ts.emitComments(currentSourceFile, writer, detachedComments, /*trailingSeparator*/ true, newLine, writeComment);\n                            var currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: ts.lastOrUndefined(detachedComments).end };\n                            if (detachedCommentsInfo) {\n                                detachedCommentsInfo.push(currentDetachedCommentInfo);\n                            }\n                            else {\n                                detachedCommentsInfo = [currentDetachedCommentInfo];\n                            }\n                        }\n                    }\n                }\n            }\n            function emitShebang() {\n                var shebang = ts.getShebang(currentSourceFile.text);\n                if (shebang) {\n                    write(shebang);\n                }\n            }\n            var _a;\n        }\n        function emitFile(jsFilePath, sourceFile) {\n            emitJavaScript(jsFilePath, sourceFile);\n            if (compilerOptions.declaration) {\n                ts.writeDeclarationFile(jsFilePath, sourceFile, host, resolver, diagnostics);\n            }\n        }\n    }", "code_tokens": ["function", "emitFiles", "(", "resolver", ",", "host", ",", "targetSourceFile", ")", "{", "// emit output for the __extends helper function", "var", "extendsHelper", "=", "\"\\nvar __extends = (this && this.__extends) || function (d, b) {\\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\\n    function __() { this.constructor = d; }\\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n};\"", ";", "// emit output for the __decorate helper function", "var", "decorateHelper", "=", "\"\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\n};\"", ";", "// emit output for the __metadata helper function", "var", "metadataHelper", "=", "\"\\nvar __metadata = (this && this.__metadata) || function (k, v) {\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.metadata === \\\"function\\\") return Reflect.metadata(k, v);\\n};\"", ";", "// emit output for the __param helper function", "var", "paramHelper", "=", "\"\\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\\n    return function (target, key) { decorator(target, key, paramIndex); }\\n};\"", ";", "var", "awaiterHelper", "=", "\"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\\n    return new Promise(function (resolve, reject) {\\n        generator = generator.call(thisArg, _arguments);\\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\\n        function onfulfill(value) { try { step(\\\"next\\\", value); } catch (e) { reject(e); } }\\n        function onreject(value) { try { step(\\\"throw\\\", value); } catch (e) { reject(e); } }\\n        function step(verb, value) {\\n            var result = generator[verb](value);\\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\\n        }\\n        step(\\\"next\\\", void 0);\\n    });\\n};\"", ";", "var", "compilerOptions", "=", "host", ".", "getCompilerOptions", "(", ")", ";", "var", "languageVersion", "=", "compilerOptions", ".", "target", "||", "0", "/* ES3 */", ";", "var", "modulekind", "=", "compilerOptions", ".", "module", "?", "compilerOptions", ".", "module", ":", "languageVersion", "===", "2", "/* ES6 */", "?", "5", "/* ES6 */", ":", "0", "/* None */", ";", "var", "sourceMapDataList", "=", "compilerOptions", ".", "sourceMap", "||", "compilerOptions", ".", "inlineSourceMap", "?", "[", "]", ":", "undefined", ";", "var", "diagnostics", "=", "[", "]", ";", "var", "newLine", "=", "host", ".", "getNewLine", "(", ")", ";", "var", "jsxDesugaring", "=", "host", ".", "getCompilerOptions", "(", ")", ".", "jsx", "!==", "1", "/* Preserve */", ";", "var", "shouldEmitJsx", "=", "function", "(", "s", ")", "{", "return", "(", "s", ".", "languageVariant", "===", "1", "/* JSX */", "&&", "!", "jsxDesugaring", ")", ";", "}", ";", "if", "(", "targetSourceFile", "===", "undefined", ")", "{", "ts", ".", "forEach", "(", "host", ".", "getSourceFiles", "(", ")", ",", "function", "(", "sourceFile", ")", "{", "if", "(", "ts", ".", "shouldEmitToOwnFile", "(", "sourceFile", ",", "compilerOptions", ")", ")", "{", "var", "jsFilePath", "=", "ts", ".", "getOwnEmitOutputFilePath", "(", "sourceFile", ",", "host", ",", "shouldEmitJsx", "(", "sourceFile", ")", "?", "\".jsx\"", ":", "\".js\"", ")", ";", "emitFile", "(", "jsFilePath", ",", "sourceFile", ")", ";", "}", "}", ")", ";", "if", "(", "compilerOptions", ".", "outFile", "||", "compilerOptions", ".", "out", ")", "{", "emitFile", "(", "compilerOptions", ".", "outFile", "||", "compilerOptions", ".", "out", ")", ";", "}", "}", "else", "{", "// targetSourceFile is specified (e.g calling emitter from language service or calling getSemanticDiagnostic from language service)", "if", "(", "ts", ".", "shouldEmitToOwnFile", "(", "targetSourceFile", ",", "compilerOptions", ")", ")", "{", "var", "jsFilePath", "=", "ts", ".", "getOwnEmitOutputFilePath", "(", "targetSourceFile", ",", "host", ",", "shouldEmitJsx", "(", "targetSourceFile", ")", "?", "\".jsx\"", ":", "\".js\"", ")", ";", "emitFile", "(", "jsFilePath", ",", "targetSourceFile", ")", ";", "}", "else", "if", "(", "!", "ts", ".", "isDeclarationFile", "(", "targetSourceFile", ")", "&&", "(", "compilerOptions", ".", "outFile", "||", "compilerOptions", ".", "out", ")", ")", "{", "emitFile", "(", "compilerOptions", ".", "outFile", "||", "compilerOptions", ".", "out", ")", ";", "}", "}", "// Sort and make the unique list of diagnostics", "diagnostics", "=", "ts", ".", "sortAndDeduplicateDiagnostics", "(", "diagnostics", ")", ";", "return", "{", "emitSkipped", ":", "false", ",", "diagnostics", ":", "diagnostics", ",", "sourceMaps", ":", "sourceMapDataList", "}", ";", "function", "isUniqueLocalName", "(", "name", ",", "container", ")", "{", "for", "(", "var", "node", "=", "container", ";", "ts", ".", "isNodeDescendentOf", "(", "node", ",", "container", ")", ";", "node", "=", "node", ".", "nextContainer", ")", "{", "if", "(", "node", ".", "locals", "&&", "ts", ".", "hasProperty", "(", "node", ".", "locals", ",", "name", ")", ")", "{", "// We conservatively include alias symbols to cover cases where they're emitted as locals", "if", "(", "node", ".", "locals", "[", "name", "]", ".", "flags", "&", "(", "107455", "/* Value */", "|", "1048576", "/* ExportValue */", "|", "8388608", "/* Alias */", ")", ")", "{", "return", "false", ";", "}", "}", "}", "return", "true", ";", "}", "function", "emitJavaScript", "(", "jsFilePath", ",", "root", ")", "{", "var", "writer", "=", "ts", ".", "createTextWriter", "(", "newLine", ")", ";", "var", "write", "=", "writer", ".", "write", ",", "writeTextOfNode", "=", "writer", ".", "writeTextOfNode", ",", "writeLine", "=", "writer", ".", "writeLine", ",", "increaseIndent", "=", "writer", ".", "increaseIndent", ",", "decreaseIndent", "=", "writer", ".", "decreaseIndent", ";", "var", "currentSourceFile", ";", "// name of an exporter function if file is a System external module", "// System.register([...], function (<exporter>) {...})", "// exporting in System modules looks like:", "// export var x; ... x = 1", "// =>", "// var x;... exporter(\"x\", x = 1)", "var", "exportFunctionForFile", ";", "var", "generatedNameSet", "=", "{", "}", ";", "var", "nodeToGeneratedName", "=", "[", "]", ";", "var", "computedPropertyNamesToGeneratedNames", ";", "var", "extendsEmitted", "=", "false", ";", "var", "decorateEmitted", "=", "false", ";", "var", "paramEmitted", "=", "false", ";", "var", "awaiterEmitted", "=", "false", ";", "var", "tempFlags", "=", "0", ";", "var", "tempVariables", ";", "var", "tempParameters", ";", "var", "externalImports", ";", "var", "exportSpecifiers", ";", "var", "exportEquals", ";", "var", "hasExportStars", ";", "/** Write emitted output to disk */", "var", "writeEmittedFiles", "=", "writeJavaScriptFile", ";", "var", "detachedCommentsInfo", ";", "var", "writeComment", "=", "ts", ".", "writeCommentRange", ";", "/** Emit a node */", "var", "emit", "=", "emitNodeWithCommentsAndWithoutSourcemap", ";", "/** Called just before starting emit of a node */", "var", "emitStart", "=", "function", "(", "node", ")", "{", "}", ";", "/** Called once the emit of the node is done */", "var", "emitEnd", "=", "function", "(", "node", ")", "{", "}", ";", "/** Emit the text for the given token that comes after startPos\n             * This by default writes the text provided with the given tokenKind\n             * but if optional emitFn callback is provided the text is emitted using the callback instead of default text\n             * @param tokenKind the kind of the token to search and emit\n             * @param startPos the position in the source to start searching for the token\n             * @param emitFn if given will be invoked to emit the text instead of actual token emit */", "var", "emitToken", "=", "emitTokenText", ";", "/** Called to before starting the lexical scopes as in function/class in the emitted code because of node\n             * @param scopeDeclaration node that starts the lexical scope\n             * @param scopeName Optional name of this scope instead of deducing one from the declaration node */", "var", "scopeEmitStart", "=", "function", "(", "scopeDeclaration", ",", "scopeName", ")", "{", "}", ";", "/** Called after coming out of the scope */", "var", "scopeEmitEnd", "=", "function", "(", ")", "{", "}", ";", "/** Sourcemap data that will get encoded */", "var", "sourceMapData", ";", "/** If removeComments is true, no leading-comments needed to be emitted **/", "var", "emitLeadingCommentsOfPosition", "=", "compilerOptions", ".", "removeComments", "?", "function", "(", "pos", ")", "{", "}", ":", "emitLeadingCommentsOfPositionWorker", ";", "var", "moduleEmitDelegates", "=", "(", "_a", "=", "{", "}", ",", "_a", "[", "5", "/* ES6 */", "]", "=", "emitES6Module", ",", "_a", "[", "2", "/* AMD */", "]", "=", "emitAMDModule", ",", "_a", "[", "4", "/* System */", "]", "=", "emitSystemModule", ",", "_a", "[", "3", "/* UMD */", "]", "=", "emitUMDModule", ",", "_a", "[", "1", "/* CommonJS */", "]", "=", "emitCommonJSModule", ",", "_a", ")", ";", "if", "(", "compilerOptions", ".", "sourceMap", "||", "compilerOptions", ".", "inlineSourceMap", ")", "{", "initializeEmitterWithSourceMaps", "(", ")", ";", "}", "if", "(", "root", ")", "{", "// Do not call emit directly. It does not set the currentSourceFile.", "emitSourceFile", "(", "root", ")", ";", "}", "else", "{", "ts", ".", "forEach", "(", "host", ".", "getSourceFiles", "(", ")", ",", "function", "(", "sourceFile", ")", "{", "if", "(", "!", "isExternalModuleOrDeclarationFile", "(", "sourceFile", ")", ")", "{", "emitSourceFile", "(", "sourceFile", ")", ";", "}", "}", ")", ";", "}", "writeLine", "(", ")", ";", "writeEmittedFiles", "(", "writer", ".", "getText", "(", ")", ",", "/*writeByteOrderMark*/", "compilerOptions", ".", "emitBOM", ")", ";", "return", ";", "function", "emitSourceFile", "(", "sourceFile", ")", "{", "currentSourceFile", "=", "sourceFile", ";", "exportFunctionForFile", "=", "undefined", ";", "emit", "(", "sourceFile", ")", ";", "}", "function", "isUniqueName", "(", "name", ")", "{", "return", "!", "resolver", ".", "hasGlobalName", "(", "name", ")", "&&", "!", "ts", ".", "hasProperty", "(", "currentSourceFile", ".", "identifiers", ",", "name", ")", "&&", "!", "ts", ".", "hasProperty", "(", "generatedNameSet", ",", "name", ")", ";", "}", "// Return the next available name in the pattern _a ... _z, _0, _1, ...", "// TempFlags._i or TempFlags._n may be used to express a preference for that dedicated name.", "// Note that names generated by makeTempVariableName and makeUniqueName will never conflict.", "function", "makeTempVariableName", "(", "flags", ")", "{", "if", "(", "flags", "&&", "!", "(", "tempFlags", "&", "flags", ")", ")", "{", "var", "name_19", "=", "flags", "===", "268435456", "/* _i */", "?", "\"_i\"", ":", "\"_n\"", ";", "if", "(", "isUniqueName", "(", "name_19", ")", ")", "{", "tempFlags", "|=", "flags", ";", "return", "name_19", ";", "}", "}", "while", "(", "true", ")", "{", "var", "count", "=", "tempFlags", "&", "268435455", "/* CountMask */", ";", "tempFlags", "++", ";", "// Skip over 'i' and 'n'", "if", "(", "count", "!==", "8", "&&", "count", "!==", "13", ")", "{", "var", "name_20", "=", "count", "<", "26", "?", "\"_\"", "+", "String", ".", "fromCharCode", "(", "97", "/* a */", "+", "count", ")", ":", "\"_\"", "+", "(", "count", "-", "26", ")", ";", "if", "(", "isUniqueName", "(", "name_20", ")", ")", "{", "return", "name_20", ";", "}", "}", "}", "}", "// Generate a name that is unique within the current file and doesn't conflict with any names", "// in global scope. The name is formed by adding an '_n' suffix to the specified base name,", "// where n is a positive integer. Note that names generated by makeTempVariableName and", "// makeUniqueName are guaranteed to never conflict.", "function", "makeUniqueName", "(", "baseName", ")", "{", "// Find the first unique 'name_n', where n is a positive number", "if", "(", "baseName", ".", "charCodeAt", "(", "baseName", ".", "length", "-", "1", ")", "!==", "95", "/* _ */", ")", "{", "baseName", "+=", "\"_\"", ";", "}", "var", "i", "=", "1", ";", "while", "(", "true", ")", "{", "var", "generatedName", "=", "baseName", "+", "i", ";", "if", "(", "isUniqueName", "(", "generatedName", ")", ")", "{", "return", "generatedNameSet", "[", "generatedName", "]", "=", "generatedName", ";", "}", "i", "++", ";", "}", "}", "function", "generateNameForModuleOrEnum", "(", "node", ")", "{", "var", "name", "=", "node", ".", "name", ".", "text", ";", "// Use module/enum name itself if it is unique, otherwise make a unique variation", "return", "isUniqueLocalName", "(", "name", ",", "node", ")", "?", "name", ":", "makeUniqueName", "(", "name", ")", ";", "}", "function", "generateNameForImportOrExportDeclaration", "(", "node", ")", "{", "var", "expr", "=", "ts", ".", "getExternalModuleName", "(", "node", ")", ";", "var", "baseName", "=", "expr", ".", "kind", "===", "9", "/* StringLiteral */", "?", "ts", ".", "escapeIdentifier", "(", "ts", ".", "makeIdentifierFromModuleName", "(", "expr", ".", "text", ")", ")", ":", "\"module\"", ";", "return", "makeUniqueName", "(", "baseName", ")", ";", "}", "function", "generateNameForExportDefault", "(", ")", "{", "return", "makeUniqueName", "(", "\"default\"", ")", ";", "}", "function", "generateNameForClassExpression", "(", ")", "{", "return", "makeUniqueName", "(", "\"class\"", ")", ";", "}", "function", "generateNameForNode", "(", "node", ")", "{", "switch", "(", "node", ".", "kind", ")", "{", "case", "69", "/* Identifier */", ":", "return", "makeUniqueName", "(", "node", ".", "text", ")", ";", "case", "218", "/* ModuleDeclaration */", ":", "case", "217", "/* EnumDeclaration */", ":", "return", "generateNameForModuleOrEnum", "(", "node", ")", ";", "case", "222", "/* ImportDeclaration */", ":", "case", "228", "/* ExportDeclaration */", ":", "return", "generateNameForImportOrExportDeclaration", "(", "node", ")", ";", "case", "213", "/* FunctionDeclaration */", ":", "case", "214", "/* ClassDeclaration */", ":", "case", "227", "/* ExportAssignment */", ":", "return", "generateNameForExportDefault", "(", ")", ";", "case", "186", "/* ClassExpression */", ":", "return", "generateNameForClassExpression", "(", ")", ";", "}", "}", "function", "getGeneratedNameForNode", "(", "node", ")", "{", "var", "id", "=", "ts", ".", "getNodeId", "(", "node", ")", ";", "return", "nodeToGeneratedName", "[", "id", "]", "||", "(", "nodeToGeneratedName", "[", "id", "]", "=", "ts", ".", "unescapeIdentifier", "(", "generateNameForNode", "(", "node", ")", ")", ")", ";", "}", "function", "initializeEmitterWithSourceMaps", "(", ")", "{", "var", "sourceMapDir", ";", "// The directory in which sourcemap will be", "// Current source map file and its index in the sources list", "var", "sourceMapSourceIndex", "=", "-", "1", ";", "// Names and its index map", "var", "sourceMapNameIndexMap", "=", "{", "}", ";", "var", "sourceMapNameIndices", "=", "[", "]", ";", "function", "getSourceMapNameIndex", "(", ")", "{", "return", "sourceMapNameIndices", ".", "length", "?", "ts", ".", "lastOrUndefined", "(", "sourceMapNameIndices", ")", ":", "-", "1", ";", "}", "// Last recorded and encoded spans", "var", "lastRecordedSourceMapSpan", ";", "var", "lastEncodedSourceMapSpan", "=", "{", "emittedLine", ":", "1", ",", "emittedColumn", ":", "1", ",", "sourceLine", ":", "1", ",", "sourceColumn", ":", "1", ",", "sourceIndex", ":", "0", "}", ";", "var", "lastEncodedNameIndex", "=", "0", ";", "// Encoding for sourcemap span", "function", "encodeLastRecordedSourceMapSpan", "(", ")", "{", "if", "(", "!", "lastRecordedSourceMapSpan", "||", "lastRecordedSourceMapSpan", "===", "lastEncodedSourceMapSpan", ")", "{", "return", ";", "}", "var", "prevEncodedEmittedColumn", "=", "lastEncodedSourceMapSpan", ".", "emittedColumn", ";", "// Line/Comma delimiters", "if", "(", "lastEncodedSourceMapSpan", ".", "emittedLine", "===", "lastRecordedSourceMapSpan", ".", "emittedLine", ")", "{", "// Emit comma to separate the entry", "if", "(", "sourceMapData", ".", "sourceMapMappings", ")", "{", "sourceMapData", ".", "sourceMapMappings", "+=", "\",\"", ";", "}", "}", "else", "{", "// Emit line delimiters", "for", "(", "var", "encodedLine", "=", "lastEncodedSourceMapSpan", ".", "emittedLine", ";", "encodedLine", "<", "lastRecordedSourceMapSpan", ".", "emittedLine", ";", "encodedLine", "++", ")", "{", "sourceMapData", ".", "sourceMapMappings", "+=", "\";\"", ";", "}", "prevEncodedEmittedColumn", "=", "1", ";", "}", "// 1. Relative Column 0 based", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "emittedColumn", "-", "prevEncodedEmittedColumn", ")", ";", "// 2. Relative sourceIndex", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "sourceIndex", "-", "lastEncodedSourceMapSpan", ".", "sourceIndex", ")", ";", "// 3. Relative sourceLine 0 based", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "sourceLine", "-", "lastEncodedSourceMapSpan", ".", "sourceLine", ")", ";", "// 4. Relative sourceColumn 0 based", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "sourceColumn", "-", "lastEncodedSourceMapSpan", ".", "sourceColumn", ")", ";", "// 5. Relative namePosition 0 based", "if", "(", "lastRecordedSourceMapSpan", ".", "nameIndex", ">=", "0", ")", "{", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "nameIndex", "-", "lastEncodedNameIndex", ")", ";", "lastEncodedNameIndex", "=", "lastRecordedSourceMapSpan", ".", "nameIndex", ";", "}", "lastEncodedSourceMapSpan", "=", "lastRecordedSourceMapSpan", ";", "sourceMapData", ".", "sourceMapDecodedMappings", ".", "push", "(", "lastEncodedSourceMapSpan", ")", ";", "function", "base64VLQFormatEncode", "(", "inValue", ")", "{", "function", "base64FormatEncode", "(", "inValue", ")", "{", "if", "(", "inValue", "<", "64", ")", "{", "return", "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"", ".", "charAt", "(", "inValue", ")", ";", "}", "throw", "TypeError", "(", "inValue", "+", "\": not a 64 based value\"", ")", ";", "}", "// Add a new least significant bit that has the sign of the value.", "// if negative number the least significant bit that gets added to the number has value 1", "// else least significant bit value that gets added is 0", "// eg. -1 changes to binary : 01 [1] => 3", "//     +1 changes to binary : 01 [0] => 2", "if", "(", "inValue", "<", "0", ")", "{", "inValue", "=", "(", "(", "-", "inValue", ")", "<<", "1", ")", "+", "1", ";", "}", "else", "{", "inValue", "=", "inValue", "<<", "1", ";", "}", "// Encode 5 bits at a time starting from least significant bits", "var", "encodedStr", "=", "\"\"", ";", "do", "{", "var", "currentDigit", "=", "inValue", "&", "31", ";", "// 11111", "inValue", "=", "inValue", ">>", "5", ";", "if", "(", "inValue", ">", "0", ")", "{", "// There are still more digits to decode, set the msb (6th bit)", "currentDigit", "=", "currentDigit", "|", "32", ";", "}", "encodedStr", "=", "encodedStr", "+", "base64FormatEncode", "(", "currentDigit", ")", ";", "}", "while", "(", "inValue", ">", "0", ")", ";", "return", "encodedStr", ";", "}", "}", "function", "recordSourceMapSpan", "(", "pos", ")", "{", "var", "sourceLinePos", "=", "ts", ".", "getLineAndCharacterOfPosition", "(", "currentSourceFile", ",", "pos", ")", ";", "// Convert the location to be one-based.", "sourceLinePos", ".", "line", "++", ";", "sourceLinePos", ".", "character", "++", ";", "var", "emittedLine", "=", "writer", ".", "getLine", "(", ")", ";", "var", "emittedColumn", "=", "writer", ".", "getColumn", "(", ")", ";", "// If this location wasn't recorded or the location in source is going backwards, record the span", "if", "(", "!", "lastRecordedSourceMapSpan", "||", "lastRecordedSourceMapSpan", ".", "emittedLine", "!==", "emittedLine", "||", "lastRecordedSourceMapSpan", ".", "emittedColumn", "!==", "emittedColumn", "||", "(", "lastRecordedSourceMapSpan", ".", "sourceIndex", "===", "sourceMapSourceIndex", "&&", "(", "lastRecordedSourceMapSpan", ".", "sourceLine", ">", "sourceLinePos", ".", "line", "||", "(", "lastRecordedSourceMapSpan", ".", "sourceLine", "===", "sourceLinePos", ".", "line", "&&", "lastRecordedSourceMapSpan", ".", "sourceColumn", ">", "sourceLinePos", ".", "character", ")", ")", ")", ")", "{", "// Encode the last recordedSpan before assigning new", "encodeLastRecordedSourceMapSpan", "(", ")", ";", "// New span", "lastRecordedSourceMapSpan", "=", "{", "emittedLine", ":", "emittedLine", ",", "emittedColumn", ":", "emittedColumn", ",", "sourceLine", ":", "sourceLinePos", ".", "line", ",", "sourceColumn", ":", "sourceLinePos", ".", "character", ",", "nameIndex", ":", "getSourceMapNameIndex", "(", ")", ",", "sourceIndex", ":", "sourceMapSourceIndex", "}", ";", "}", "else", "{", "// Take the new pos instead since there is no change in emittedLine and column since last location", "lastRecordedSourceMapSpan", ".", "sourceLine", "=", "sourceLinePos", ".", "line", ";", "lastRecordedSourceMapSpan", ".", "sourceColumn", "=", "sourceLinePos", ".", "character", ";", "lastRecordedSourceMapSpan", ".", "sourceIndex", "=", "sourceMapSourceIndex", ";", "}", "}", "function", "recordEmitNodeStartSpan", "(", "node", ")", "{", "// Get the token pos after skipping to the token (ignoring the leading trivia)", "recordSourceMapSpan", "(", "ts", ".", "skipTrivia", "(", "currentSourceFile", ".", "text", ",", "node", ".", "pos", ")", ")", ";", "}", "function", "recordEmitNodeEndSpan", "(", "node", ")", "{", "recordSourceMapSpan", "(", "node", ".", "end", ")", ";", "}", "function", "writeTextWithSpanRecord", "(", "tokenKind", ",", "startPos", ",", "emitFn", ")", "{", "var", "tokenStartPos", "=", "ts", ".", "skipTrivia", "(", "currentSourceFile", ".", "text", ",", "startPos", ")", ";", "recordSourceMapSpan", "(", "tokenStartPos", ")", ";", "var", "tokenEndPos", "=", "emitTokenText", "(", "tokenKind", ",", "tokenStartPos", ",", "emitFn", ")", ";", "recordSourceMapSpan", "(", "tokenEndPos", ")", ";", "return", "tokenEndPos", ";", "}", "function", "recordNewSourceFileStart", "(", "node", ")", "{", "// Add the file to tsFilePaths", "// If sourceroot option: Use the relative path corresponding to the common directory path", "// otherwise source locations relative to map file location", "var", "sourcesDirectoryPath", "=", "compilerOptions", ".", "sourceRoot", "?", "host", ".", "getCommonSourceDirectory", "(", ")", ":", "sourceMapDir", ";", "sourceMapData", ".", "sourceMapSources", ".", "push", "(", "ts", ".", "getRelativePathToDirectoryOrUrl", "(", "sourcesDirectoryPath", ",", "node", ".", "fileName", ",", "host", ".", "getCurrentDirectory", "(", ")", ",", "host", ".", "getCanonicalFileName", ",", "/*isAbsolutePathAnUrl*/", "true", ")", ")", ";", "sourceMapSourceIndex", "=", "sourceMapData", ".", "sourceMapSources", ".", "length", "-", "1", ";", "// The one that can be used from program to get the actual source file", "sourceMapData", ".", "inputSourceFileNames", ".", "push", "(", "node", ".", "fileName", ")", ";", "if", "(", "compilerOptions", ".", "inlineSources", ")", "{", "if", "(", "!", "sourceMapData", ".", "sourceMapSourcesContent", ")", "{", "sourceMapData", ".", "sourceMapSourcesContent", "=", "[", "]", ";", "}", "sourceMapData", ".", "sourceMapSourcesContent", ".", "push", "(", "node", ".", "text", ")", ";", "}", "}", "function", "recordScopeNameOfNode", "(", "node", ",", "scopeName", ")", "{", "function", "recordScopeNameIndex", "(", "scopeNameIndex", ")", "{", "sourceMapNameIndices", ".", "push", "(", "scopeNameIndex", ")", ";", "}", "function", "recordScopeNameStart", "(", "scopeName", ")", "{", "var", "scopeNameIndex", "=", "-", "1", ";", "if", "(", "scopeName", ")", "{", "var", "parentIndex", "=", "getSourceMapNameIndex", "(", ")", ";", "if", "(", "parentIndex", "!==", "-", "1", ")", "{", "// Child scopes are always shown with a dot (even if they have no name),", "// unless it is a computed property. Then it is shown with brackets,", "// but the brackets are included in the name.", "var", "name_21", "=", "node", ".", "name", ";", "if", "(", "!", "name_21", "||", "name_21", ".", "kind", "!==", "136", "/* ComputedPropertyName */", ")", "{", "scopeName", "=", "\".\"", "+", "scopeName", ";", "}", "scopeName", "=", "sourceMapData", ".", "sourceMapNames", "[", "parentIndex", "]", "+", "scopeName", ";", "}", "scopeNameIndex", "=", "ts", ".", "getProperty", "(", "sourceMapNameIndexMap", ",", "scopeName", ")", ";", "if", "(", "scopeNameIndex", "===", "undefined", ")", "{", "scopeNameIndex", "=", "sourceMapData", ".", "sourceMapNames", ".", "length", ";", "sourceMapData", ".", "sourceMapNames", ".", "push", "(", "scopeName", ")", ";", "sourceMapNameIndexMap", "[", "scopeName", "]", "=", "scopeNameIndex", ";", "}", "}", "recordScopeNameIndex", "(", "scopeNameIndex", ")", ";", "}", "if", "(", "scopeName", ")", "{", "// The scope was already given a name  use it", "recordScopeNameStart", "(", "scopeName", ")", ";", "}", "else", "if", "(", "node", ".", "kind", "===", "213", "/* FunctionDeclaration */", "||", "node", ".", "kind", "===", "173", "/* FunctionExpression */", "||", "node", ".", "kind", "===", "143", "/* MethodDeclaration */", "||", "node", ".", "kind", "===", "142", "/* MethodSignature */", "||", "node", ".", "kind", "===", "145", "/* GetAccessor */", "||", "node", ".", "kind", "===", "146", "/* SetAccessor */", "||", "node", ".", "kind", "===", "218", "/* ModuleDeclaration */", "||", "node", ".", "kind", "===", "214", "/* ClassDeclaration */", "||", "node", ".", "kind", "===", "217", "/* EnumDeclaration */", ")", "{", "// Declaration and has associated name use it", "if", "(", "node", ".", "name", ")", "{", "var", "name_22", "=", "node", ".", "name", ";", "// For computed property names, the text will include the brackets", "scopeName", "=", "name_22", ".", "kind", "===", "136", "/* ComputedPropertyName */", "?", "ts", ".", "getTextOfNode", "(", "name_22", ")", ":", "node", ".", "name", ".", "text", ";", "}", "recordScopeNameStart", "(", "scopeName", ")", ";", "}", "else", "{", "// Block just use the name from upper level scope", "recordScopeNameIndex", "(", "getSourceMapNameIndex", "(", ")", ")", ";", "}", "}", "function", "recordScopeNameEnd", "(", ")", "{", "sourceMapNameIndices", ".", "pop", "(", ")", ";", "}", ";", "function", "writeCommentRangeWithMap", "(", "curentSourceFile", ",", "writer", ",", "comment", ",", "newLine", ")", "{", "recordSourceMapSpan", "(", "comment", ".", "pos", ")", ";", "ts", ".", "writeCommentRange", "(", "currentSourceFile", ",", "writer", ",", "comment", ",", "newLine", ")", ";", "recordSourceMapSpan", "(", "comment", ".", "end", ")", ";", "}", "function", "serializeSourceMapContents", "(", "version", ",", "file", ",", "sourceRoot", ",", "sources", ",", "names", ",", "mappings", ",", "sourcesContent", ")", "{", "if", "(", "typeof", "JSON", "!==", "\"undefined\"", ")", "{", "var", "map_1", "=", "{", "version", ":", "version", ",", "file", ":", "file", ",", "sourceRoot", ":", "sourceRoot", ",", "sources", ":", "sources", ",", "names", ":", "names", ",", "mappings", ":", "mappings", "}", ";", "if", "(", "sourcesContent", "!==", "undefined", ")", "{", "map_1", ".", "sourcesContent", "=", "sourcesContent", ";", "}", "return", "JSON", ".", "stringify", "(", "map_1", ")", ";", "}", "return", "\"{\\\"version\\\":\"", "+", "version", "+", "\",\\\"file\\\":\\\"\"", "+", "ts", ".", "escapeString", "(", "file", ")", "+", "\"\\\",\\\"sourceRoot\\\":\\\"\"", "+", "ts", ".", "escapeString", "(", "sourceRoot", ")", "+", "\"\\\",\\\"sources\\\":[\"", "+", "serializeStringArray", "(", "sources", ")", "+", "\"],\\\"names\\\":[\"", "+", "serializeStringArray", "(", "names", ")", "+", "\"],\\\"mappings\\\":\\\"\"", "+", "ts", ".", "escapeString", "(", "mappings", ")", "+", "\"\\\" \"", "+", "(", "sourcesContent", "!==", "undefined", "?", "\",\\\"sourcesContent\\\":[\"", "+", "serializeStringArray", "(", "sourcesContent", ")", "+", "\"]\"", ":", "\"\"", ")", "+", "\"}\"", ";", "function", "serializeStringArray", "(", "list", ")", "{", "var", "output", "=", "\"\"", ";", "for", "(", "var", "i", "=", "0", ",", "n", "=", "list", ".", "length", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "i", ")", "{", "output", "+=", "\",\"", ";", "}", "output", "+=", "\"\\\"\"", "+", "ts", ".", "escapeString", "(", "list", "[", "i", "]", ")", "+", "\"\\\"\"", ";", "}", "return", "output", ";", "}", "}", "function", "writeJavaScriptAndSourceMapFile", "(", "emitOutput", ",", "writeByteOrderMark", ")", "{", "encodeLastRecordedSourceMapSpan", "(", ")", ";", "var", "sourceMapText", "=", "serializeSourceMapContents", "(", "3", ",", "sourceMapData", ".", "sourceMapFile", ",", "sourceMapData", ".", "sourceMapSourceRoot", ",", "sourceMapData", ".", "sourceMapSources", ",", "sourceMapData", ".", "sourceMapNames", ",", "sourceMapData", ".", "sourceMapMappings", ",", "sourceMapData", ".", "sourceMapSourcesContent", ")", ";", "sourceMapDataList", ".", "push", "(", "sourceMapData", ")", ";", "var", "sourceMapUrl", ";", "if", "(", "compilerOptions", ".", "inlineSourceMap", ")", "{", "// Encode the sourceMap into the sourceMap url", "var", "base64SourceMapText", "=", "ts", ".", "convertToBase64", "(", "sourceMapText", ")", ";", "sourceMapUrl", "=", "\"//# sourceMappingURL=data:application/json;base64,\"", "+", "base64SourceMapText", ";", "}", "else", "{", "// Write source map file", "ts", ".", "writeFile", "(", "host", ",", "diagnostics", ",", "sourceMapData", ".", "sourceMapFilePath", ",", "sourceMapText", ",", "/*writeByteOrderMark*/", "false", ")", ";", "sourceMapUrl", "=", "\"//# sourceMappingURL=\"", "+", "sourceMapData", ".", "jsSourceMappingURL", ";", "}", "// Write sourcemap url to the js file and write the js file", "writeJavaScriptFile", "(", "emitOutput", "+", "sourceMapUrl", ",", "writeByteOrderMark", ")", ";", "}", "// Initialize source map data", "var", "sourceMapJsFile", "=", "ts", ".", "getBaseFileName", "(", "ts", ".", "normalizeSlashes", "(", "jsFilePath", ")", ")", ";", "sourceMapData", "=", "{", "sourceMapFilePath", ":", "jsFilePath", "+", "\".map\"", ",", "jsSourceMappingURL", ":", "sourceMapJsFile", "+", "\".map\"", ",", "sourceMapFile", ":", "sourceMapJsFile", ",", "sourceMapSourceRoot", ":", "compilerOptions", ".", "sourceRoot", "||", "\"\"", ",", "sourceMapSources", ":", "[", "]", ",", "inputSourceFileNames", ":", "[", "]", ",", "sourceMapNames", ":", "[", "]", ",", "sourceMapMappings", ":", "\"\"", ",", "sourceMapSourcesContent", ":", "undefined", ",", "sourceMapDecodedMappings", ":", "[", "]", "}", ";", "// Normalize source root and make sure it has trailing \"/\" so that it can be used to combine paths with the", "// relative paths of the sources list in the sourcemap", "sourceMapData", ".", "sourceMapSourceRoot", "=", "ts", ".", "normalizeSlashes", "(", "sourceMapData", ".", "sourceMapSourceRoot", ")", ";", "if", "(", "sourceMapData", ".", "sourceMapSourceRoot", ".", "length", "&&", "sourceMapData", ".", "sourceMapSourceRoot", ".", "charCodeAt", "(", "sourceMapData", ".", "sourceMapSourceRoot", ".", "length", "-", "1", ")", "!==", "47", "/* slash */", ")", "{", "sourceMapData", ".", "sourceMapSourceRoot", "+=", "ts", ".", "directorySeparator", ";", "}", "if", "(", "compilerOptions", ".", "mapRoot", ")", "{", "sourceMapDir", "=", "ts", ".", "normalizeSlashes", "(", "compilerOptions", ".", "mapRoot", ")", ";", "if", "(", "root", ")", "{", "// For modules or multiple emit files the mapRoot will have directory structure like the sources", "// So if src\\a.ts and src\\lib\\b.ts are compiled together user would be moving the maps into mapRoot\\a.js.map and mapRoot\\lib\\b.js.map", "sourceMapDir", "=", "ts", ".", "getDirectoryPath", "(", "ts", ".", "getSourceFilePathInNewDir", "(", "root", ",", "host", ",", "sourceMapDir", ")", ")", ";", "}", "if", "(", "!", "ts", ".", "isRootedDiskPath", "(", "sourceMapDir", ")", "&&", "!", "ts", ".", "isUrl", "(", "sourceMapDir", ")", ")", "{", "// The relative paths are relative to the common directory", "sourceMapDir", "=", "ts", ".", "combinePaths", "(", "host", ".", "getCommonSourceDirectory", "(", ")", ",", "sourceMapDir", ")", ";", "sourceMapData", ".", "jsSourceMappingURL", "=", "ts", ".", "getRelativePathToDirectoryOrUrl", "(", "ts", ".", "getDirectoryPath", "(", "ts", ".", "normalizePath", "(", "jsFilePath", ")", ")", ",", "// get the relative sourceMapDir path based on jsFilePath", "ts", ".", "combinePaths", "(", "sourceMapDir", ",", "sourceMapData", ".", "jsSourceMappingURL", ")", ",", "// this is where user expects to see sourceMap", "host", ".", "getCurrentDirectory", "(", ")", ",", "host", ".", "getCanonicalFileName", ",", "/*isAbsolutePathAnUrl*/", "true", ")", ";", "}", "else", "{", "sourceMapData", ".", "jsSourceMappingURL", "=", "ts", ".", "combinePaths", "(", "sourceMapDir", ",", "sourceMapData", ".", "jsSourceMappingURL", ")", ";", "}", "}", "else", "{", "sourceMapDir", "=", "ts", ".", "getDirectoryPath", "(", "ts", ".", "normalizePath", "(", "jsFilePath", ")", ")", ";", "}", "function", "emitNodeWithSourceMap", "(", "node", ")", "{", "if", "(", "node", ")", "{", "if", "(", "ts", ".", "nodeIsSynthesized", "(", "node", ")", ")", "{", "return", "emitNodeWithoutSourceMap", "(", "node", ")", ";", "}", "if", "(", "node", ".", "kind", "!==", "248", "/* SourceFile */", ")", "{", "recordEmitNodeStartSpan", "(", "node", ")", ";", "emitNodeWithoutSourceMap", "(", "node", ")", ";", "recordEmitNodeEndSpan", "(", "node", ")", ";", "}", "else", "{", "recordNewSourceFileStart", "(", "node", ")", ";", "emitNodeWithoutSourceMap", "(", "node", ")", ";", "}", "}", "}", "function", "emitNodeWithCommentsAndWithSourcemap", "(", "node", ")", "{", "emitNodeConsideringCommentsOption", "(", "node", ",", "emitNodeWithSourceMap", ")", ";", "}", "writeEmittedFiles", "=", "writeJavaScriptAndSourceMapFile", ";", "emit", "=", "emitNodeWithCommentsAndWithSourcemap", ";", "emitStart", "=", "recordEmitNodeStartSpan", ";", "emitEnd", "=", "recordEmitNodeEndSpan", ";", "emitToken", "=", "writeTextWithSpanRecord", ";", "scopeEmitStart", "=", "recordScopeNameOfNode", ";", "scopeEmitEnd", "=", "recordScopeNameEnd", ";", "writeComment", "=", "writeCommentRangeWithMap", ";", "}", "function", "writeJavaScriptFile", "(", "emitOutput", ",", "writeByteOrderMark", ")", "{", "ts", ".", "writeFile", "(", "host", ",", "diagnostics", ",", "jsFilePath", ",", "emitOutput", ",", "writeByteOrderMark", ")", ";", "}", "// Create a temporary variable with a unique unused name.", "function", "createTempVariable", "(", "flags", ")", "{", "var", "result", "=", "ts", ".", "createSynthesizedNode", "(", "69", "/* Identifier */", ")", ";", "result", ".", "text", "=", "makeTempVariableName", "(", "flags", ")", ";", "return", "result", ";", "}", "function", "recordTempDeclaration", "(", "name", ")", "{", "if", "(", "!", "tempVariables", ")", "{", "tempVariables", "=", "[", "]", ";", "}", "tempVariables", ".", "push", "(", "name", ")", ";", "}", "function", "createAndRecordTempVariable", "(", "flags", ")", "{", "var", "temp", "=", "createTempVariable", "(", "flags", ")", ";", "recordTempDeclaration", "(", "temp", ")", ";", "return", "temp", ";", "}", "function", "emitTempDeclarations", "(", "newLine", ")", "{", "if", "(", "tempVariables", ")", "{", "if", "(", "newLine", ")", "{", "writeLine", "(", ")", ";", "}", "else", "{", "write", "(", "\" \"", ")", ";", "}", "write", "(", "\"var \"", ")", ";", "emitCommaList", "(", "tempVariables", ")", ";", "write", "(", "\";\"", ")", ";", "}", "}", "function", "emitTokenText", "(", "tokenKind", ",", "startPos", ",", "emitFn", ")", "{", "var", "tokenString", "=", "ts", ".", "tokenToString", "(", "tokenKind", ")", ";", "if", "(", "emitFn", ")", "{", "emitFn", "(", ")", ";", "}", "else", "{", "write", "(", "tokenString", ")", ";", "}", "return", "startPos", "+", "tokenString", ".", "length", ";", "}", "function", "emitOptional", "(", "prefix", ",", "node", ")", "{", "if", "(", "node", ")", "{", "write", "(", "prefix", ")", ";", "emit", "(", "node", ")", ";", "}", "}", "function", "emitParenthesizedIf", "(", "node", ",", "parenthesized", ")", "{", "if", "(", "parenthesized", ")", "{", "write", "(", "\"(\"", ")", ";", "}", "emit", "(", "node", ")", ";", "if", "(", "parenthesized", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "function", "emitTrailingCommaIfPresent", "(", "nodeList", ")", "{", "if", "(", "nodeList", ".", "hasTrailingComma", ")", "{", "write", "(", "\",\"", ")", ";", "}", "}", "function", "emitLinePreservingList", "(", "parent", ",", "nodes", ",", "allowTrailingComma", ",", "spacesBetweenBraces", ")", "{", "ts", ".", "Debug", ".", "assert", "(", "nodes", ".", "length", ">", "0", ")", ";", "increaseIndent", "(", ")", ";", "if", "(", "nodeStartPositionsAreOnSameLine", "(", "parent", ",", "nodes", "[", "0", "]", ")", ")", "{", "if", "(", "spacesBetweenBraces", ")", "{", "write", "(", "\" \"", ")", ";", "}", "}", "else", "{", "writeLine", "(", ")", ";", "}", "for", "(", "var", "i", "=", "0", ",", "n", "=", "nodes", ".", "length", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "i", ")", "{", "if", "(", "nodeEndIsOnSameLineAsNodeStart", "(", "nodes", "[", "i", "-", "1", "]", ",", "nodes", "[", "i", "]", ")", ")", "{", "write", "(", "\", \"", ")", ";", "}", "else", "{", "write", "(", "\",\"", ")", ";", "writeLine", "(", ")", ";", "}", "}", "emit", "(", "nodes", "[", "i", "]", ")", ";", "}", "if", "(", "nodes", ".", "hasTrailingComma", "&&", "allowTrailingComma", ")", "{", "write", "(", "\",\"", ")", ";", "}", "decreaseIndent", "(", ")", ";", "if", "(", "nodeEndPositionsAreOnSameLine", "(", "parent", ",", "ts", ".", "lastOrUndefined", "(", "nodes", ")", ")", ")", "{", "if", "(", "spacesBetweenBraces", ")", "{", "write", "(", "\" \"", ")", ";", "}", "}", "else", "{", "writeLine", "(", ")", ";", "}", "}", "function", "emitList", "(", "nodes", ",", "start", ",", "count", ",", "multiLine", ",", "trailingComma", ",", "leadingComma", ",", "noTrailingNewLine", ",", "emitNode", ")", "{", "if", "(", "!", "emitNode", ")", "{", "emitNode", "=", "emit", ";", "}", "for", "(", "var", "i", "=", "0", ";", "i", "<", "count", ";", "i", "++", ")", "{", "if", "(", "multiLine", ")", "{", "if", "(", "i", "||", "leadingComma", ")", "{", "write", "(", "\",\"", ")", ";", "}", "writeLine", "(", ")", ";", "}", "else", "{", "if", "(", "i", "||", "leadingComma", ")", "{", "write", "(", "\", \"", ")", ";", "}", "}", "var", "node", "=", "nodes", "[", "start", "+", "i", "]", ";", "// This emitting is to make sure we emit following comment properly", "//   ...(x, /*comment1*/ y)...", "//         ^ => node.pos", "// \"comment1\" is not considered leading comment for \"y\" but rather", "// considered as trailing comment of the previous node.", "emitTrailingCommentsOfPosition", "(", "node", ".", "pos", ")", ";", "emitNode", "(", "node", ")", ";", "leadingComma", "=", "true", ";", "}", "if", "(", "trailingComma", ")", "{", "write", "(", "\",\"", ")", ";", "}", "if", "(", "multiLine", "&&", "!", "noTrailingNewLine", ")", "{", "writeLine", "(", ")", ";", "}", "return", "count", ";", "}", "function", "emitCommaList", "(", "nodes", ")", "{", "if", "(", "nodes", ")", "{", "emitList", "(", "nodes", ",", "0", ",", "nodes", ".", "length", ",", "/*multiline*/", "false", ",", "/*trailingComma*/", "false", ")", ";", "}", "}", "function", "emitLines", "(", "nodes", ")", "{", "emitLinesStartingAt", "(", "nodes", ",", "/*startIndex*/", "0", ")", ";", "}", "function", "emitLinesStartingAt", "(", "nodes", ",", "startIndex", ")", "{", "for", "(", "var", "i", "=", "startIndex", ";", "i", "<", "nodes", ".", "length", ";", "i", "++", ")", "{", "writeLine", "(", ")", ";", "emit", "(", "nodes", "[", "i", "]", ")", ";", "}", "}", "function", "isBinaryOrOctalIntegerLiteral", "(", "node", ",", "text", ")", "{", "if", "(", "node", ".", "kind", "===", "8", "/* NumericLiteral */", "&&", "text", ".", "length", ">", "1", ")", "{", "switch", "(", "text", ".", "charCodeAt", "(", "1", ")", ")", "{", "case", "98", "/* b */", ":", "case", "66", "/* B */", ":", "case", "111", "/* o */", ":", "case", "79", "/* O */", ":", "return", "true", ";", "}", "}", "return", "false", ";", "}", "function", "emitLiteral", "(", "node", ")", "{", "var", "text", "=", "getLiteralText", "(", "node", ")", ";", "if", "(", "(", "compilerOptions", ".", "sourceMap", "||", "compilerOptions", ".", "inlineSourceMap", ")", "&&", "(", "node", ".", "kind", "===", "9", "/* StringLiteral */", "||", "ts", ".", "isTemplateLiteralKind", "(", "node", ".", "kind", ")", ")", ")", "{", "writer", ".", "writeLiteral", "(", "text", ")", ";", "}", "else", "if", "(", "languageVersion", "<", "2", "/* ES6 */", "&&", "isBinaryOrOctalIntegerLiteral", "(", "node", ",", "text", ")", ")", "{", "write", "(", "node", ".", "text", ")", ";", "}", "else", "{", "write", "(", "text", ")", ";", "}", "}", "function", "getLiteralText", "(", "node", ")", "{", "// Any template literal or string literal with an extended escape", "// (e.g. \"\\u{0067}\") will need to be downleveled as a escaped string literal.", "if", "(", "languageVersion", "<", "2", "/* ES6 */", "&&", "(", "ts", ".", "isTemplateLiteralKind", "(", "node", ".", "kind", ")", "||", "node", ".", "hasExtendedUnicodeEscape", ")", ")", "{", "return", "getQuotedEscapedLiteralText", "(", "\"\\\"\"", ",", "node", ".", "text", ",", "\"\\\"\"", ")", ";", "}", "// If we don't need to downlevel and we can reach the original source text using", "// the node's parent reference, then simply get the text as it was originally written.", "if", "(", "node", ".", "parent", ")", "{", "return", "ts", ".", "getSourceTextOfNodeFromSourceFile", "(", "currentSourceFile", ",", "node", ")", ";", "}", "// If we can't reach the original source text, use the canonical form if it's a number,", "// or an escaped quoted form of the original text if it's string-like.", "switch", "(", "node", ".", "kind", ")", "{", "case", "9", "/* StringLiteral */", ":", "return", "getQuotedEscapedLiteralText", "(", "\"\\\"\"", ",", "node", ".", "text", ",", "\"\\\"\"", ")", ";", "case", "11", "/* NoSubstitutionTemplateLiteral */", ":", "return", "getQuotedEscapedLiteralText", "(", "\"`\"", ",", "node", ".", "text", ",", "\"`\"", ")", ";", "case", "12", "/* TemplateHead */", ":", "return", "getQuotedEscapedLiteralText", "(", "\"`\"", ",", "node", ".", "text", ",", "\"${\"", ")", ";", "case", "13", "/* TemplateMiddle */", ":", "return", "getQuotedEscapedLiteralText", "(", "\"}\"", ",", "node", ".", "text", ",", "\"${\"", ")", ";", "case", "14", "/* TemplateTail */", ":", "return", "getQuotedEscapedLiteralText", "(", "\"}\"", ",", "node", ".", "text", ",", "\"`\"", ")", ";", "case", "8", "/* NumericLiteral */", ":", "return", "node", ".", "text", ";", "}", "ts", ".", "Debug", ".", "fail", "(", "\"Literal kind '\"", "+", "node", ".", "kind", "+", "\"' not accounted for.\"", ")", ";", "}", "function", "getQuotedEscapedLiteralText", "(", "leftQuote", ",", "text", ",", "rightQuote", ")", "{", "return", "leftQuote", "+", "ts", ".", "escapeNonAsciiCharacters", "(", "ts", ".", "escapeString", "(", "text", ")", ")", "+", "rightQuote", ";", "}", "function", "emitDownlevelRawTemplateLiteral", "(", "node", ")", "{", "// Find original source text, since we need to emit the raw strings of the tagged template.", "// The raw strings contain the (escaped) strings of what the user wrote.", "// Examples: `\\n` is converted to \"\\\\n\", a template string with a newline to \"\\n\".", "var", "text", "=", "ts", ".", "getSourceTextOfNodeFromSourceFile", "(", "currentSourceFile", ",", "node", ")", ";", "// text contains the original source, it will also contain quotes (\"`\"), dolar signs and braces (\"${\" and \"}\"),", "// thus we need to remove those characters.", "// First template piece starts with \"`\", others with \"}\"", "// Last template piece ends with \"`\", others with \"${\"", "var", "isLast", "=", "node", ".", "kind", "===", "11", "/* NoSubstitutionTemplateLiteral */", "||", "node", ".", "kind", "===", "14", "/* TemplateTail */", ";", "text", "=", "text", ".", "substring", "(", "1", ",", "text", ".", "length", "-", "(", "isLast", "?", "1", ":", "2", ")", ")", ";", "// Newline normalization:", "// ES6 Spec 11.8.6.1 - Static Semantics of TV's and TRV's", "// <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for both TV and TRV.", "text", "=", "text", ".", "replace", "(", "/", "\\r\\n?", "/", "g", ",", "\"\\n\"", ")", ";", "text", "=", "ts", ".", "escapeString", "(", "text", ")", ";", "write", "(", "\"\\\"\"", "+", "text", "+", "\"\\\"\"", ")", ";", "}", "function", "emitDownlevelTaggedTemplateArray", "(", "node", ",", "literalEmitter", ")", "{", "write", "(", "\"[\"", ")", ";", "if", "(", "node", ".", "template", ".", "kind", "===", "11", "/* NoSubstitutionTemplateLiteral */", ")", "{", "literalEmitter", "(", "node", ".", "template", ")", ";", "}", "else", "{", "literalEmitter", "(", "node", ".", "template", ".", "head", ")", ";", "ts", ".", "forEach", "(", "node", ".", "template", ".", "templateSpans", ",", "function", "(", "child", ")", "{", "write", "(", "\", \"", ")", ";", "literalEmitter", "(", "child", ".", "literal", ")", ";", "}", ")", ";", "}", "write", "(", "\"]\"", ")", ";", "}", "function", "emitDownlevelTaggedTemplate", "(", "node", ")", "{", "var", "tempVariable", "=", "createAndRecordTempVariable", "(", "0", "/* Auto */", ")", ";", "write", "(", "\"(\"", ")", ";", "emit", "(", "tempVariable", ")", ";", "write", "(", "\" = \"", ")", ";", "emitDownlevelTaggedTemplateArray", "(", "node", ",", "emit", ")", ";", "write", "(", "\", \"", ")", ";", "emit", "(", "tempVariable", ")", ";", "write", "(", "\".raw = \"", ")", ";", "emitDownlevelTaggedTemplateArray", "(", "node", ",", "emitDownlevelRawTemplateLiteral", ")", ";", "write", "(", "\", \"", ")", ";", "emitParenthesizedIf", "(", "node", ".", "tag", ",", "needsParenthesisForPropertyAccessOrInvocation", "(", "node", ".", "tag", ")", ")", ";", "write", "(", "\"(\"", ")", ";", "emit", "(", "tempVariable", ")", ";", "// Now we emit the expressions", "if", "(", "node", ".", "template", ".", "kind", "===", "183", "/* TemplateExpression */", ")", "{", "ts", ".", "forEach", "(", "node", ".", "template", ".", "templateSpans", ",", "function", "(", "templateSpan", ")", "{", "write", "(", "\", \"", ")", ";", "var", "needsParens", "=", "templateSpan", ".", "expression", ".", "kind", "===", "181", "/* BinaryExpression */", "&&", "templateSpan", ".", "expression", ".", "operatorToken", ".", "kind", "===", "24", "/* CommaToken */", ";", "emitParenthesizedIf", "(", "templateSpan", ".", "expression", ",", "needsParens", ")", ";", "}", ")", ";", "}", "write", "(", "\"))\"", ")", ";", "}", "function", "emitTemplateExpression", "(", "node", ")", "{", "// In ES6 mode and above, we can simply emit each portion of a template in order, but in", "// ES3 & ES5 we must convert the template expression into a series of string concatenations.", "if", "(", "languageVersion", ">=", "2", "/* ES6 */", ")", "{", "ts", ".", "forEachChild", "(", "node", ",", "emit", ")", ";", "return", ";", "}", "var", "emitOuterParens", "=", "ts", ".", "isExpression", "(", "node", ".", "parent", ")", "&&", "templateNeedsParens", "(", "node", ",", "node", ".", "parent", ")", ";", "if", "(", "emitOuterParens", ")", "{", "write", "(", "\"(\"", ")", ";", "}", "var", "headEmitted", "=", "false", ";", "if", "(", "shouldEmitTemplateHead", "(", ")", ")", "{", "emitLiteral", "(", "node", ".", "head", ")", ";", "headEmitted", "=", "true", ";", "}", "for", "(", "var", "i", "=", "0", ",", "n", "=", "node", ".", "templateSpans", ".", "length", ";", "i", "<", "n", ";", "i", "++", ")", "{", "var", "templateSpan", "=", "node", ".", "templateSpans", "[", "i", "]", ";", "// Check if the expression has operands and binds its operands less closely than binary '+'.", "// If it does, we need to wrap the expression in parentheses. Otherwise, something like", "//    `abc${ 1 << 2 }`", "// becomes", "//    \"abc\" + 1 << 2 + \"\"", "// which is really", "//    (\"abc\" + 1) << (2 + \"\")", "// rather than", "//    \"abc\" + (1 << 2) + \"\"", "var", "needsParens", "=", "templateSpan", ".", "expression", ".", "kind", "!==", "172", "/* ParenthesizedExpression */", "&&", "comparePrecedenceToBinaryPlus", "(", "templateSpan", ".", "expression", ")", "!==", "1", "/* GreaterThan */", ";", "if", "(", "i", ">", "0", "||", "headEmitted", ")", "{", "// If this is the first span and the head was not emitted, then this templateSpan's", "// expression will be the first to be emitted. Don't emit the preceding ' + ' in that", "// case.", "write", "(", "\" + \"", ")", ";", "}", "emitParenthesizedIf", "(", "templateSpan", ".", "expression", ",", "needsParens", ")", ";", "// Only emit if the literal is non-empty.", "// The binary '+' operator is left-associative, so the first string concatenation", "// with the head will force the result up to this point to be a string.", "// Emitting a '+ \"\"' has no semantic effect for middles and tails.", "if", "(", "templateSpan", ".", "literal", ".", "text", ".", "length", "!==", "0", ")", "{", "write", "(", "\" + \"", ")", ";", "emitLiteral", "(", "templateSpan", ".", "literal", ")", ";", "}", "}", "if", "(", "emitOuterParens", ")", "{", "write", "(", "\")\"", ")", ";", "}", "function", "shouldEmitTemplateHead", "(", ")", "{", "// If this expression has an empty head literal and the first template span has a non-empty", "// literal, then emitting the empty head literal is not necessary.", "//     `${ foo } and ${ bar }`", "// can be emitted as", "//     foo + \" and \" + bar", "// This is because it is only required that one of the first two operands in the emit", "// output must be a string literal, so that the other operand and all following operands", "// are forced into strings.", "//", "// If the first template span has an empty literal, then the head must still be emitted.", "//     `${ foo }${ bar }`", "// must still be emitted as", "//     \"\" + foo + bar", "// There is always atleast one templateSpan in this code path, since", "// NoSubstitutionTemplateLiterals are directly emitted via emitLiteral()", "ts", ".", "Debug", ".", "assert", "(", "node", ".", "templateSpans", ".", "length", "!==", "0", ")", ";", "return", "node", ".", "head", ".", "text", ".", "length", "!==", "0", "||", "node", ".", "templateSpans", "[", "0", "]", ".", "literal", ".", "text", ".", "length", "===", "0", ";", "}", "function", "templateNeedsParens", "(", "template", ",", "parent", ")", "{", "switch", "(", "parent", ".", "kind", ")", "{", "case", "168", "/* CallExpression */", ":", "case", "169", "/* NewExpression */", ":", "return", "parent", ".", "expression", "===", "template", ";", "case", "170", "/* TaggedTemplateExpression */", ":", "case", "172", "/* ParenthesizedExpression */", ":", "return", "false", ";", "default", ":", "return", "comparePrecedenceToBinaryPlus", "(", "parent", ")", "!==", "-", "1", "/* LessThan */", ";", "}", "}", "/**\n                 * Returns whether the expression has lesser, greater,\n                 * or equal precedence to the binary '+' operator\n                 */", "function", "comparePrecedenceToBinaryPlus", "(", "expression", ")", "{", "// All binary expressions have lower precedence than '+' apart from '*', '/', and '%'", "// which have greater precedence and '-' which has equal precedence.", "// All unary operators have a higher precedence apart from yield.", "// Arrow functions and conditionals have a lower precedence,", "// although we convert the former into regular function expressions in ES5 mode,", "// and in ES6 mode this function won't get called anyway.", "//", "// TODO (drosen): Note that we need to account for the upcoming 'yield' and", "//                spread ('...') unary operators that are anticipated for ES6.", "switch", "(", "expression", ".", "kind", ")", "{", "case", "181", "/* BinaryExpression */", ":", "switch", "(", "expression", ".", "operatorToken", ".", "kind", ")", "{", "case", "37", "/* AsteriskToken */", ":", "case", "39", "/* SlashToken */", ":", "case", "40", "/* PercentToken */", ":", "return", "1", "/* GreaterThan */", ";", "case", "35", "/* PlusToken */", ":", "case", "36", "/* MinusToken */", ":", "return", "0", "/* EqualTo */", ";", "default", ":", "return", "-", "1", "/* LessThan */", ";", "}", "case", "184", "/* YieldExpression */", ":", "case", "182", "/* ConditionalExpression */", ":", "return", "-", "1", "/* LessThan */", ";", "default", ":", "return", "1", "/* GreaterThan */", ";", "}", "}", "}", "function", "emitTemplateSpan", "(", "span", ")", "{", "emit", "(", "span", ".", "expression", ")", ";", "emit", "(", "span", ".", "literal", ")", ";", "}", "function", "jsxEmitReact", "(", "node", ")", "{", "/// Emit a tag name, which is either '\"div\"' for lower-cased names, or", "/// 'Div' for upper-cased or dotted names", "function", "emitTagName", "(", "name", ")", "{", "if", "(", "name", ".", "kind", "===", "69", "/* Identifier */", "&&", "ts", ".", "isIntrinsicJsxName", "(", "name", ".", "text", ")", ")", "{", "write", "(", "\"\\\"\"", ")", ";", "emit", "(", "name", ")", ";", "write", "(", "\"\\\"\"", ")", ";", "}", "else", "{", "emit", "(", "name", ")", ";", "}", "}", "/// Emit an attribute name, which is quoted if it needs to be quoted. Because", "/// these emit into an object literal property name, we don't need to be worried", "/// about keywords, just non-identifier characters", "function", "emitAttributeName", "(", "name", ")", "{", "if", "(", "/", "[A-Za-z_]+[\\w*]", "/", ".", "test", "(", "name", ".", "text", ")", ")", "{", "write", "(", "\"\\\"\"", ")", ";", "emit", "(", "name", ")", ";", "write", "(", "\"\\\"\"", ")", ";", "}", "else", "{", "emit", "(", "name", ")", ";", "}", "}", "/// Emit an name/value pair for an attribute (e.g. \"x: 3\")", "function", "emitJsxAttribute", "(", "node", ")", "{", "emitAttributeName", "(", "node", ".", "name", ")", ";", "write", "(", "\": \"", ")", ";", "if", "(", "node", ".", "initializer", ")", "{", "emit", "(", "node", ".", "initializer", ")", ";", "}", "else", "{", "write", "(", "\"true\"", ")", ";", "}", "}", "function", "emitJsxElement", "(", "openingNode", ",", "children", ")", "{", "var", "syntheticReactRef", "=", "ts", ".", "createSynthesizedNode", "(", "69", "/* Identifier */", ")", ";", "syntheticReactRef", ".", "text", "=", "\"React\"", ";", "syntheticReactRef", ".", "parent", "=", "openingNode", ";", "// Call React.createElement(tag, ...", "emitLeadingComments", "(", "openingNode", ")", ";", "emitExpressionIdentifier", "(", "syntheticReactRef", ")", ";", "write", "(", "\".createElement(\"", ")", ";", "emitTagName", "(", "openingNode", ".", "tagName", ")", ";", "write", "(", "\", \"", ")", ";", "// Attribute list", "if", "(", "openingNode", ".", "attributes", ".", "length", "===", "0", ")", "{", "// When there are no attributes, React wants \"null\"", "write", "(", "\"null\"", ")", ";", "}", "else", "{", "// Either emit one big object literal (no spread attribs), or", "// a call to React.__spread", "var", "attrs", "=", "openingNode", ".", "attributes", ";", "if", "(", "ts", ".", "forEach", "(", "attrs", ",", "function", "(", "attr", ")", "{", "return", "attr", ".", "kind", "===", "239", "/* JsxSpreadAttribute */", ";", "}", ")", ")", "{", "emitExpressionIdentifier", "(", "syntheticReactRef", ")", ";", "write", "(", "\".__spread(\"", ")", ";", "var", "haveOpenedObjectLiteral", "=", "false", ";", "for", "(", "var", "i_1", "=", "0", ";", "i_1", "<", "attrs", ".", "length", ";", "i_1", "++", ")", "{", "if", "(", "attrs", "[", "i_1", "]", ".", "kind", "===", "239", "/* JsxSpreadAttribute */", ")", "{", "// If this is the first argument, we need to emit a {} as the first argument", "if", "(", "i_1", "===", "0", ")", "{", "write", "(", "\"{}, \"", ")", ";", "}", "if", "(", "haveOpenedObjectLiteral", ")", "{", "write", "(", "\"}\"", ")", ";", "haveOpenedObjectLiteral", "=", "false", ";", "}", "if", "(", "i_1", ">", "0", ")", "{", "write", "(", "\", \"", ")", ";", "}", "emit", "(", "attrs", "[", "i_1", "]", ".", "expression", ")", ";", "}", "else", "{", "ts", ".", "Debug", ".", "assert", "(", "attrs", "[", "i_1", "]", ".", "kind", "===", "238", "/* JsxAttribute */", ")", ";", "if", "(", "haveOpenedObjectLiteral", ")", "{", "write", "(", "\", \"", ")", ";", "}", "else", "{", "haveOpenedObjectLiteral", "=", "true", ";", "if", "(", "i_1", ">", "0", ")", "{", "write", "(", "\", \"", ")", ";", "}", "write", "(", "\"{\"", ")", ";", "}", "emitJsxAttribute", "(", "attrs", "[", "i_1", "]", ")", ";", "}", "}", "if", "(", "haveOpenedObjectLiteral", ")", "write", "(", "\"}\"", ")", ";", "write", "(", "\")\"", ")", ";", "// closing paren to React.__spread(", "}", "else", "{", "// One object literal with all the attributes in them", "write", "(", "\"{\"", ")", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "attrs", ".", "length", ";", "i", "++", ")", "{", "if", "(", "i", ">", "0", ")", "{", "write", "(", "\", \"", ")", ";", "}", "emitJsxAttribute", "(", "attrs", "[", "i", "]", ")", ";", "}", "write", "(", "\"}\"", ")", ";", "}", "}", "// Children", "if", "(", "children", ")", "{", "for", "(", "var", "i", "=", "0", ";", "i", "<", "children", ".", "length", ";", "i", "++", ")", "{", "// Don't emit empty expressions", "if", "(", "children", "[", "i", "]", ".", "kind", "===", "240", "/* JsxExpression */", "&&", "!", "(", "children", "[", "i", "]", ".", "expression", ")", ")", "{", "continue", ";", "}", "// Don't emit empty strings", "if", "(", "children", "[", "i", "]", ".", "kind", "===", "236", "/* JsxText */", ")", "{", "var", "text", "=", "getTextToEmit", "(", "children", "[", "i", "]", ")", ";", "if", "(", "text", "!==", "undefined", ")", "{", "write", "(", "\", \\\"\"", ")", ";", "write", "(", "text", ")", ";", "write", "(", "\"\\\"\"", ")", ";", "}", "}", "else", "{", "write", "(", "\", \"", ")", ";", "emit", "(", "children", "[", "i", "]", ")", ";", "}", "}", "}", "// Closing paren", "write", "(", "\")\"", ")", ";", "// closes \"React.createElement(\"", "emitTrailingComments", "(", "openingNode", ")", ";", "}", "if", "(", "node", ".", "kind", "===", "233", "/* JsxElement */", ")", "{", "emitJsxElement", "(", "node", ".", "openingElement", ",", "node", ".", "children", ")", ";", "}", "else", "{", "ts", ".", "Debug", ".", "assert", "(", "node", ".", "kind", "===", "234", "/* JsxSelfClosingElement */", ")", ";", "emitJsxElement", "(", "node", ")", ";", "}", "}", "function", "jsxEmitPreserve", "(", "node", ")", "{", "function", "emitJsxAttribute", "(", "node", ")", "{", "emit", "(", "node", ".", "name", ")", ";", "if", "(", "node", ".", "initializer", ")", "{", "write", "(", "\"=\"", ")", ";", "emit", "(", "node", ".", "initializer", ")", ";", "}", "}", "function", "emitJsxSpreadAttribute", "(", "node", ")", "{", "write", "(", "\"{...\"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\"}\"", ")", ";", "}", "function", "emitAttributes", "(", "attribs", ")", "{", "for", "(", "var", "i", "=", "0", ",", "n", "=", "attribs", ".", "length", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "i", ">", "0", ")", "{", "write", "(", "\" \"", ")", ";", "}", "if", "(", "attribs", "[", "i", "]", ".", "kind", "===", "239", "/* JsxSpreadAttribute */", ")", "{", "emitJsxSpreadAttribute", "(", "attribs", "[", "i", "]", ")", ";", "}", "else", "{", "ts", ".", "Debug", ".", "assert", "(", "attribs", "[", "i", "]", ".", "kind", "===", "238", "/* JsxAttribute */", ")", ";", "emitJsxAttribute", "(", "attribs", "[", "i", "]", ")", ";", "}", "}", "}", "function", "emitJsxOpeningOrSelfClosingElement", "(", "node", ")", "{", "write", "(", "\"<\"", ")", ";", "emit", "(", "node", ".", "tagName", ")", ";", "if", "(", "node", ".", "attributes", ".", "length", ">", "0", "||", "(", "node", ".", "kind", "===", "234", "/* JsxSelfClosingElement */", ")", ")", "{", "write", "(", "\" \"", ")", ";", "}", "emitAttributes", "(", "node", ".", "attributes", ")", ";", "if", "(", "node", ".", "kind", "===", "234", "/* JsxSelfClosingElement */", ")", "{", "write", "(", "\"/>\"", ")", ";", "}", "else", "{", "write", "(", "\">\"", ")", ";", "}", "}", "function", "emitJsxClosingElement", "(", "node", ")", "{", "write", "(", "\"</\"", ")", ";", "emit", "(", "node", ".", "tagName", ")", ";", "write", "(", "\">\"", ")", ";", "}", "function", "emitJsxElement", "(", "node", ")", "{", "emitJsxOpeningOrSelfClosingElement", "(", "node", ".", "openingElement", ")", ";", "for", "(", "var", "i", "=", "0", ",", "n", "=", "node", ".", "children", ".", "length", ";", "i", "<", "n", ";", "i", "++", ")", "{", "emit", "(", "node", ".", "children", "[", "i", "]", ")", ";", "}", "emitJsxClosingElement", "(", "node", ".", "closingElement", ")", ";", "}", "if", "(", "node", ".", "kind", "===", "233", "/* JsxElement */", ")", "{", "emitJsxElement", "(", "node", ")", ";", "}", "else", "{", "ts", ".", "Debug", ".", "assert", "(", "node", ".", "kind", "===", "234", "/* JsxSelfClosingElement */", ")", ";", "emitJsxOpeningOrSelfClosingElement", "(", "node", ")", ";", "}", "}", "// This function specifically handles numeric/string literals for enum and accessor 'identifiers'.", "// In a sense, it does not actually emit identifiers as much as it declares a name for a specific property.", "// For example, this is utilized when feeding in a result to Object.defineProperty.", "function", "emitExpressionForPropertyName", "(", "node", ")", "{", "ts", ".", "Debug", ".", "assert", "(", "node", ".", "kind", "!==", "163", "/* BindingElement */", ")", ";", "if", "(", "node", ".", "kind", "===", "9", "/* StringLiteral */", ")", "{", "emitLiteral", "(", "node", ")", ";", "}", "else", "if", "(", "node", ".", "kind", "===", "136", "/* ComputedPropertyName */", ")", "{", "// if this is a decorated computed property, we will need to capture the result", "// of the property expression so that we can apply decorators later. This is to ensure", "// we don't introduce unintended side effects:", "//", "//   class C {", "//     [_a = x]() { }", "//   }", "//", "// The emit for the decorated computed property decorator is:", "//", "//   __decorate([dec], C.prototype, _a, Object.getOwnPropertyDescriptor(C.prototype, _a));", "//", "if", "(", "ts", ".", "nodeIsDecorated", "(", "node", ".", "parent", ")", ")", "{", "if", "(", "!", "computedPropertyNamesToGeneratedNames", ")", "{", "computedPropertyNamesToGeneratedNames", "=", "[", "]", ";", "}", "var", "generatedName", "=", "computedPropertyNamesToGeneratedNames", "[", "ts", ".", "getNodeId", "(", "node", ")", "]", ";", "if", "(", "generatedName", ")", "{", "// we have already generated a variable for this node, write that value instead.", "write", "(", "generatedName", ")", ";", "return", ";", "}", "generatedName", "=", "createAndRecordTempVariable", "(", "0", "/* Auto */", ")", ".", "text", ";", "computedPropertyNamesToGeneratedNames", "[", "ts", ".", "getNodeId", "(", "node", ")", "]", "=", "generatedName", ";", "write", "(", "generatedName", ")", ";", "write", "(", "\" = \"", ")", ";", "}", "emit", "(", "node", ".", "expression", ")", ";", "}", "else", "{", "write", "(", "\"\\\"\"", ")", ";", "if", "(", "node", ".", "kind", "===", "8", "/* NumericLiteral */", ")", "{", "write", "(", "node", ".", "text", ")", ";", "}", "else", "{", "writeTextOfNode", "(", "currentSourceFile", ",", "node", ")", ";", "}", "write", "(", "\"\\\"\"", ")", ";", "}", "}", "function", "isExpressionIdentifier", "(", "node", ")", "{", "var", "parent", "=", "node", ".", "parent", ";", "switch", "(", "parent", ".", "kind", ")", "{", "case", "164", "/* ArrayLiteralExpression */", ":", "case", "189", "/* AsExpression */", ":", "case", "181", "/* BinaryExpression */", ":", "case", "168", "/* CallExpression */", ":", "case", "241", "/* CaseClause */", ":", "case", "136", "/* ComputedPropertyName */", ":", "case", "182", "/* ConditionalExpression */", ":", "case", "139", "/* Decorator */", ":", "case", "175", "/* DeleteExpression */", ":", "case", "197", "/* DoStatement */", ":", "case", "167", "/* ElementAccessExpression */", ":", "case", "227", "/* ExportAssignment */", ":", "case", "195", "/* ExpressionStatement */", ":", "case", "188", "/* ExpressionWithTypeArguments */", ":", "case", "199", "/* ForStatement */", ":", "case", "200", "/* ForInStatement */", ":", "case", "201", "/* ForOfStatement */", ":", "case", "196", "/* IfStatement */", ":", "case", "234", "/* JsxSelfClosingElement */", ":", "case", "235", "/* JsxOpeningElement */", ":", "case", "239", "/* JsxSpreadAttribute */", ":", "case", "240", "/* JsxExpression */", ":", "case", "169", "/* NewExpression */", ":", "case", "172", "/* ParenthesizedExpression */", ":", "case", "180", "/* PostfixUnaryExpression */", ":", "case", "179", "/* PrefixUnaryExpression */", ":", "case", "204", "/* ReturnStatement */", ":", "case", "246", "/* ShorthandPropertyAssignment */", ":", "case", "185", "/* SpreadElementExpression */", ":", "case", "206", "/* SwitchStatement */", ":", "case", "170", "/* TaggedTemplateExpression */", ":", "case", "190", "/* TemplateSpan */", ":", "case", "208", "/* ThrowStatement */", ":", "case", "171", "/* TypeAssertionExpression */", ":", "case", "176", "/* TypeOfExpression */", ":", "case", "177", "/* VoidExpression */", ":", "case", "198", "/* WhileStatement */", ":", "case", "205", "/* WithStatement */", ":", "case", "184", "/* YieldExpression */", ":", "return", "true", ";", "case", "163", "/* BindingElement */", ":", "case", "247", "/* EnumMember */", ":", "case", "138", "/* Parameter */", ":", "case", "245", "/* PropertyAssignment */", ":", "case", "141", "/* PropertyDeclaration */", ":", "case", "211", "/* VariableDeclaration */", ":", "return", "parent", ".", "initializer", "===", "node", ";", "case", "166", "/* PropertyAccessExpression */", ":", "return", "parent", ".", "expression", "===", "node", ";", "case", "174", "/* ArrowFunction */", ":", "case", "173", "/* FunctionExpression */", ":", "return", "parent", ".", "body", "===", "node", ";", "case", "221", "/* ImportEqualsDeclaration */", ":", "return", "parent", ".", "moduleReference", "===", "node", ";", "case", "135", "/* QualifiedName */", ":", "return", "parent", ".", "left", "===", "node", ";", "}", "return", "false", ";", "}", "function", "emitExpressionIdentifier", "(", "node", ")", "{", "if", "(", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "2048", "/* LexicalArguments */", ")", "{", "write", "(", "\"_arguments\"", ")", ";", "return", ";", "}", "var", "container", "=", "resolver", ".", "getReferencedExportContainer", "(", "node", ")", ";", "if", "(", "container", ")", "{", "if", "(", "container", ".", "kind", "===", "248", "/* SourceFile */", ")", "{", "// Identifier references module export", "if", "(", "modulekind", "!==", "5", "/* ES6 */", "&&", "modulekind", "!==", "4", "/* System */", ")", "{", "write", "(", "\"exports.\"", ")", ";", "}", "}", "else", "{", "// Identifier references namespace export", "write", "(", "getGeneratedNameForNode", "(", "container", ")", ")", ";", "write", "(", "\".\"", ")", ";", "}", "}", "else", "{", "if", "(", "modulekind", "!==", "5", "/* ES6 */", ")", "{", "var", "declaration", "=", "resolver", ".", "getReferencedImportDeclaration", "(", "node", ")", ";", "if", "(", "declaration", ")", "{", "if", "(", "declaration", ".", "kind", "===", "223", "/* ImportClause */", ")", "{", "// Identifier references default import", "write", "(", "getGeneratedNameForNode", "(", "declaration", ".", "parent", ")", ")", ";", "write", "(", "languageVersion", "===", "0", "/* ES3 */", "?", "\"[\\\"default\\\"]\"", ":", "\".default\"", ")", ";", "return", ";", "}", "else", "if", "(", "declaration", ".", "kind", "===", "226", "/* ImportSpecifier */", ")", "{", "// Identifier references named import", "write", "(", "getGeneratedNameForNode", "(", "declaration", ".", "parent", ".", "parent", ".", "parent", ")", ")", ";", "var", "name_23", "=", "declaration", ".", "propertyName", "||", "declaration", ".", "name", ";", "var", "identifier", "=", "ts", ".", "getSourceTextOfNodeFromSourceFile", "(", "currentSourceFile", ",", "name_23", ")", ";", "if", "(", "languageVersion", "===", "0", "/* ES3 */", "&&", "identifier", "===", "\"default\"", ")", "{", "write", "(", "\"[\\\"default\\\"]\"", ")", ";", "}", "else", "{", "write", "(", "\".\"", ")", ";", "write", "(", "identifier", ")", ";", "}", "return", ";", "}", "}", "}", "if", "(", "languageVersion", "!==", "2", "/* ES6 */", ")", "{", "var", "declaration", "=", "resolver", ".", "getReferencedNestedRedeclaration", "(", "node", ")", ";", "if", "(", "declaration", ")", "{", "write", "(", "getGeneratedNameForNode", "(", "declaration", ".", "name", ")", ")", ";", "return", ";", "}", "}", "}", "if", "(", "ts", ".", "nodeIsSynthesized", "(", "node", ")", ")", "{", "write", "(", "node", ".", "text", ")", ";", "}", "else", "{", "writeTextOfNode", "(", "currentSourceFile", ",", "node", ")", ";", "}", "}", "function", "isNameOfNestedRedeclaration", "(", "node", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "var", "parent_6", "=", "node", ".", "parent", ";", "switch", "(", "parent_6", ".", "kind", ")", "{", "case", "163", "/* BindingElement */", ":", "case", "214", "/* ClassDeclaration */", ":", "case", "217", "/* EnumDeclaration */", ":", "case", "211", "/* VariableDeclaration */", ":", "return", "parent_6", ".", "name", "===", "node", "&&", "resolver", ".", "isNestedRedeclaration", "(", "parent_6", ")", ";", "}", "}", "return", "false", ";", "}", "function", "emitIdentifier", "(", "node", ")", "{", "if", "(", "!", "node", ".", "parent", ")", "{", "write", "(", "node", ".", "text", ")", ";", "}", "else", "if", "(", "isExpressionIdentifier", "(", "node", ")", ")", "{", "emitExpressionIdentifier", "(", "node", ")", ";", "}", "else", "if", "(", "isNameOfNestedRedeclaration", "(", "node", ")", ")", "{", "write", "(", "getGeneratedNameForNode", "(", "node", ")", ")", ";", "}", "else", "if", "(", "ts", ".", "nodeIsSynthesized", "(", "node", ")", ")", "{", "write", "(", "node", ".", "text", ")", ";", "}", "else", "{", "writeTextOfNode", "(", "currentSourceFile", ",", "node", ")", ";", "}", "}", "function", "emitThis", "(", "node", ")", "{", "if", "(", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "2", "/* LexicalThis */", ")", "{", "write", "(", "\"_this\"", ")", ";", "}", "else", "{", "write", "(", "\"this\"", ")", ";", "}", "}", "function", "emitSuper", "(", "node", ")", "{", "if", "(", "languageVersion", ">=", "2", "/* ES6 */", ")", "{", "write", "(", "\"super\"", ")", ";", "}", "else", "{", "var", "flags", "=", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", ";", "if", "(", "flags", "&", "256", "/* SuperInstance */", ")", "{", "write", "(", "\"_super.prototype\"", ")", ";", "}", "else", "{", "write", "(", "\"_super\"", ")", ";", "}", "}", "}", "function", "emitObjectBindingPattern", "(", "node", ")", "{", "write", "(", "\"{ \"", ")", ";", "var", "elements", "=", "node", ".", "elements", ";", "emitList", "(", "elements", ",", "0", ",", "elements", ".", "length", ",", "/*multiLine*/", "false", ",", "/*trailingComma*/", "elements", ".", "hasTrailingComma", ")", ";", "write", "(", "\" }\"", ")", ";", "}", "function", "emitArrayBindingPattern", "(", "node", ")", "{", "write", "(", "\"[\"", ")", ";", "var", "elements", "=", "node", ".", "elements", ";", "emitList", "(", "elements", ",", "0", ",", "elements", ".", "length", ",", "/*multiLine*/", "false", ",", "/*trailingComma*/", "elements", ".", "hasTrailingComma", ")", ";", "write", "(", "\"]\"", ")", ";", "}", "function", "emitBindingElement", "(", "node", ")", "{", "if", "(", "node", ".", "propertyName", ")", "{", "emit", "(", "node", ".", "propertyName", ")", ";", "write", "(", "\": \"", ")", ";", "}", "if", "(", "node", ".", "dotDotDotToken", ")", "{", "write", "(", "\"...\"", ")", ";", "}", "if", "(", "ts", ".", "isBindingPattern", "(", "node", ".", "name", ")", ")", "{", "emit", "(", "node", ".", "name", ")", ";", "}", "else", "{", "emitModuleMemberName", "(", "node", ")", ";", "}", "emitOptional", "(", "\" = \"", ",", "node", ".", "initializer", ")", ";", "}", "function", "emitSpreadElementExpression", "(", "node", ")", "{", "write", "(", "\"...\"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "}", "function", "emitYieldExpression", "(", "node", ")", "{", "write", "(", "ts", ".", "tokenToString", "(", "114", "/* YieldKeyword */", ")", ")", ";", "if", "(", "node", ".", "asteriskToken", ")", "{", "write", "(", "\"*\"", ")", ";", "}", "if", "(", "node", ".", "expression", ")", "{", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "}", "}", "function", "emitAwaitExpression", "(", "node", ")", "{", "var", "needsParenthesis", "=", "needsParenthesisForAwaitExpressionAsYield", "(", "node", ")", ";", "if", "(", "needsParenthesis", ")", "{", "write", "(", "\"(\"", ")", ";", "}", "write", "(", "ts", ".", "tokenToString", "(", "114", "/* YieldKeyword */", ")", ")", ";", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "if", "(", "needsParenthesis", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "function", "needsParenthesisForAwaitExpressionAsYield", "(", "node", ")", "{", "if", "(", "node", ".", "parent", ".", "kind", "===", "181", "/* BinaryExpression */", "&&", "!", "ts", ".", "isAssignmentOperator", "(", "node", ".", "parent", ".", "operatorToken", ".", "kind", ")", ")", "{", "return", "true", ";", "}", "else", "if", "(", "node", ".", "parent", ".", "kind", "===", "182", "/* ConditionalExpression */", "&&", "node", ".", "parent", ".", "condition", "===", "node", ")", "{", "return", "true", ";", "}", "return", "false", ";", "}", "function", "needsParenthesisForPropertyAccessOrInvocation", "(", "node", ")", "{", "switch", "(", "node", ".", "kind", ")", "{", "case", "69", "/* Identifier */", ":", "case", "164", "/* ArrayLiteralExpression */", ":", "case", "166", "/* PropertyAccessExpression */", ":", "case", "167", "/* ElementAccessExpression */", ":", "case", "168", "/* CallExpression */", ":", "case", "172", "/* ParenthesizedExpression */", ":", "// This list is not exhaustive and only includes those cases that are relevant", "// to the check in emitArrayLiteral. More cases can be added as needed.", "return", "false", ";", "}", "return", "true", ";", "}", "function", "emitListWithSpread", "(", "elements", ",", "needsUniqueCopy", ",", "multiLine", ",", "trailingComma", ",", "useConcat", ")", "{", "var", "pos", "=", "0", ";", "var", "group", "=", "0", ";", "var", "length", "=", "elements", ".", "length", ";", "while", "(", "pos", "<", "length", ")", "{", "// Emit using the pattern <group0>.concat(<group1>, <group2>, ...)", "if", "(", "group", "===", "1", "&&", "useConcat", ")", "{", "write", "(", "\".concat(\"", ")", ";", "}", "else", "if", "(", "group", ">", "0", ")", "{", "write", "(", "\", \"", ")", ";", "}", "var", "e", "=", "elements", "[", "pos", "]", ";", "if", "(", "e", ".", "kind", "===", "185", "/* SpreadElementExpression */", ")", "{", "e", "=", "e", ".", "expression", ";", "emitParenthesizedIf", "(", "e", ",", "/*parenthesized*/", "group", "===", "0", "&&", "needsParenthesisForPropertyAccessOrInvocation", "(", "e", ")", ")", ";", "pos", "++", ";", "if", "(", "pos", "===", "length", "&&", "group", "===", "0", "&&", "needsUniqueCopy", "&&", "e", ".", "kind", "!==", "164", "/* ArrayLiteralExpression */", ")", "{", "write", "(", "\".slice()\"", ")", ";", "}", "}", "else", "{", "var", "i", "=", "pos", ";", "while", "(", "i", "<", "length", "&&", "elements", "[", "i", "]", ".", "kind", "!==", "185", "/* SpreadElementExpression */", ")", "{", "i", "++", ";", "}", "write", "(", "\"[\"", ")", ";", "if", "(", "multiLine", ")", "{", "increaseIndent", "(", ")", ";", "}", "emitList", "(", "elements", ",", "pos", ",", "i", "-", "pos", ",", "multiLine", ",", "trailingComma", "&&", "i", "===", "length", ")", ";", "if", "(", "multiLine", ")", "{", "decreaseIndent", "(", ")", ";", "}", "write", "(", "\"]\"", ")", ";", "pos", "=", "i", ";", "}", "group", "++", ";", "}", "if", "(", "group", ">", "1", ")", "{", "if", "(", "useConcat", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "}", "function", "isSpreadElementExpression", "(", "node", ")", "{", "return", "node", ".", "kind", "===", "185", "/* SpreadElementExpression */", ";", "}", "function", "emitArrayLiteral", "(", "node", ")", "{", "var", "elements", "=", "node", ".", "elements", ";", "if", "(", "elements", ".", "length", "===", "0", ")", "{", "write", "(", "\"[]\"", ")", ";", "}", "else", "if", "(", "languageVersion", ">=", "2", "/* ES6 */", "||", "!", "ts", ".", "forEach", "(", "elements", ",", "isSpreadElementExpression", ")", ")", "{", "write", "(", "\"[\"", ")", ";", "emitLinePreservingList", "(", "node", ",", "node", ".", "elements", ",", "elements", ".", "hasTrailingComma", ",", "/*spacesBetweenBraces:*/", "false", ")", ";", "write", "(", "\"]\"", ")", ";", "}", "else", "{", "emitListWithSpread", "(", "elements", ",", "/*needsUniqueCopy*/", "true", ",", "/*multiLine*/", "(", "node", ".", "flags", "&", "2048", "/* MultiLine */", ")", "!==", "0", ",", "/*trailingComma*/", "elements", ".", "hasTrailingComma", ",", "/*useConcat*/", "true", ")", ";", "}", "}", "function", "emitObjectLiteralBody", "(", "node", ",", "numElements", ")", "{", "if", "(", "numElements", "===", "0", ")", "{", "write", "(", "\"{}\"", ")", ";", "return", ";", "}", "write", "(", "\"{\"", ")", ";", "if", "(", "numElements", ">", "0", ")", "{", "var", "properties", "=", "node", ".", "properties", ";", "// If we are not doing a downlevel transformation for object literals,", "// then try to preserve the original shape of the object literal.", "// Otherwise just try to preserve the formatting.", "if", "(", "numElements", "===", "properties", ".", "length", ")", "{", "emitLinePreservingList", "(", "node", ",", "properties", ",", "/* allowTrailingComma */", "languageVersion", ">=", "1", "/* ES5 */", ",", "/* spacesBetweenBraces */", "true", ")", ";", "}", "else", "{", "var", "multiLine", "=", "(", "node", ".", "flags", "&", "2048", "/* MultiLine */", ")", "!==", "0", ";", "if", "(", "!", "multiLine", ")", "{", "write", "(", "\" \"", ")", ";", "}", "else", "{", "increaseIndent", "(", ")", ";", "}", "emitList", "(", "properties", ",", "0", ",", "numElements", ",", "/*multiLine*/", "multiLine", ",", "/*trailingComma*/", "false", ")", ";", "if", "(", "!", "multiLine", ")", "{", "write", "(", "\" \"", ")", ";", "}", "else", "{", "decreaseIndent", "(", ")", ";", "}", "}", "}", "write", "(", "\"}\"", ")", ";", "}", "function", "emitDownlevelObjectLiteralWithComputedProperties", "(", "node", ",", "firstComputedPropertyIndex", ")", "{", "var", "multiLine", "=", "(", "node", ".", "flags", "&", "2048", "/* MultiLine */", ")", "!==", "0", ";", "var", "properties", "=", "node", ".", "properties", ";", "write", "(", "\"(\"", ")", ";", "if", "(", "multiLine", ")", "{", "increaseIndent", "(", ")", ";", "}", "// For computed properties, we need to create a unique handle to the object", "// literal so we can modify it without risking internal assignments tainting the object.", "var", "tempVar", "=", "createAndRecordTempVariable", "(", "0", "/* Auto */", ")", ";", "// Write out the first non-computed properties", "// (or all properties if none of them are computed),", "// then emit the rest through indexing on the temp variable.", "emit", "(", "tempVar", ")", ";", "write", "(", "\" = \"", ")", ";", "emitObjectLiteralBody", "(", "node", ",", "firstComputedPropertyIndex", ")", ";", "for", "(", "var", "i", "=", "firstComputedPropertyIndex", ",", "n", "=", "properties", ".", "length", ";", "i", "<", "n", ";", "i", "++", ")", "{", "writeComma", "(", ")", ";", "var", "property", "=", "properties", "[", "i", "]", ";", "emitStart", "(", "property", ")", ";", "if", "(", "property", ".", "kind", "===", "145", "/* GetAccessor */", "||", "property", ".", "kind", "===", "146", "/* SetAccessor */", ")", "{", "// TODO (drosen): Reconcile with 'emitMemberFunctions'.", "var", "accessors", "=", "ts", ".", "getAllAccessorDeclarations", "(", "node", ".", "properties", ",", "property", ")", ";", "if", "(", "property", "!==", "accessors", ".", "firstAccessor", ")", "{", "continue", ";", "}", "write", "(", "\"Object.defineProperty(\"", ")", ";", "emit", "(", "tempVar", ")", ";", "write", "(", "\", \"", ")", ";", "emitStart", "(", "node", ".", "name", ")", ";", "emitExpressionForPropertyName", "(", "property", ".", "name", ")", ";", "emitEnd", "(", "property", ".", "name", ")", ";", "write", "(", "\", {\"", ")", ";", "increaseIndent", "(", ")", ";", "if", "(", "accessors", ".", "getAccessor", ")", "{", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "accessors", ".", "getAccessor", ")", ";", "write", "(", "\"get: \"", ")", ";", "emitStart", "(", "accessors", ".", "getAccessor", ")", ";", "write", "(", "\"function \"", ")", ";", "emitSignatureAndBody", "(", "accessors", ".", "getAccessor", ")", ";", "emitEnd", "(", "accessors", ".", "getAccessor", ")", ";", "emitTrailingComments", "(", "accessors", ".", "getAccessor", ")", ";", "write", "(", "\",\"", ")", ";", "}", "if", "(", "accessors", ".", "setAccessor", ")", "{", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "accessors", ".", "setAccessor", ")", ";", "write", "(", "\"set: \"", ")", ";", "emitStart", "(", "accessors", ".", "setAccessor", ")", ";", "write", "(", "\"function \"", ")", ";", "emitSignatureAndBody", "(", "accessors", ".", "setAccessor", ")", ";", "emitEnd", "(", "accessors", ".", "setAccessor", ")", ";", "emitTrailingComments", "(", "accessors", ".", "setAccessor", ")", ";", "write", "(", "\",\"", ")", ";", "}", "writeLine", "(", ")", ";", "write", "(", "\"enumerable: true,\"", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"configurable: true\"", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"})\"", ")", ";", "emitEnd", "(", "property", ")", ";", "}", "else", "{", "emitLeadingComments", "(", "property", ")", ";", "emitStart", "(", "property", ".", "name", ")", ";", "emit", "(", "tempVar", ")", ";", "emitMemberAccessForPropertyName", "(", "property", ".", "name", ")", ";", "emitEnd", "(", "property", ".", "name", ")", ";", "write", "(", "\" = \"", ")", ";", "if", "(", "property", ".", "kind", "===", "245", "/* PropertyAssignment */", ")", "{", "emit", "(", "property", ".", "initializer", ")", ";", "}", "else", "if", "(", "property", ".", "kind", "===", "246", "/* ShorthandPropertyAssignment */", ")", "{", "emitExpressionIdentifier", "(", "property", ".", "name", ")", ";", "}", "else", "if", "(", "property", ".", "kind", "===", "143", "/* MethodDeclaration */", ")", "{", "emitFunctionDeclaration", "(", "property", ")", ";", "}", "else", "{", "ts", ".", "Debug", ".", "fail", "(", "\"ObjectLiteralElement type not accounted for: \"", "+", "property", ".", "kind", ")", ";", "}", "}", "emitEnd", "(", "property", ")", ";", "}", "writeComma", "(", ")", ";", "emit", "(", "tempVar", ")", ";", "if", "(", "multiLine", ")", "{", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "}", "write", "(", "\")\"", ")", ";", "function", "writeComma", "(", ")", "{", "if", "(", "multiLine", ")", "{", "write", "(", "\",\"", ")", ";", "writeLine", "(", ")", ";", "}", "else", "{", "write", "(", "\", \"", ")", ";", "}", "}", "}", "function", "emitObjectLiteral", "(", "node", ")", "{", "var", "properties", "=", "node", ".", "properties", ";", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "var", "numProperties", "=", "properties", ".", "length", ";", "// Find the first computed property.", "// Everything until that point can be emitted as part of the initial object literal.", "var", "numInitialNonComputedProperties", "=", "numProperties", ";", "for", "(", "var", "i", "=", "0", ",", "n", "=", "properties", ".", "length", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "properties", "[", "i", "]", ".", "name", ".", "kind", "===", "136", "/* ComputedPropertyName */", ")", "{", "numInitialNonComputedProperties", "=", "i", ";", "break", ";", "}", "}", "var", "hasComputedProperty", "=", "numInitialNonComputedProperties", "!==", "properties", ".", "length", ";", "if", "(", "hasComputedProperty", ")", "{", "emitDownlevelObjectLiteralWithComputedProperties", "(", "node", ",", "numInitialNonComputedProperties", ")", ";", "return", ";", "}", "}", "// Ordinary case: either the object has no computed properties", "// or we're compiling with an ES6+ target.", "emitObjectLiteralBody", "(", "node", ",", "properties", ".", "length", ")", ";", "}", "function", "createBinaryExpression", "(", "left", ",", "operator", ",", "right", ",", "startsOnNewLine", ")", "{", "var", "result", "=", "ts", ".", "createSynthesizedNode", "(", "181", "/* BinaryExpression */", ",", "startsOnNewLine", ")", ";", "result", ".", "operatorToken", "=", "ts", ".", "createSynthesizedNode", "(", "operator", ")", ";", "result", ".", "left", "=", "left", ";", "result", ".", "right", "=", "right", ";", "return", "result", ";", "}", "function", "createPropertyAccessExpression", "(", "expression", ",", "name", ")", "{", "var", "result", "=", "ts", ".", "createSynthesizedNode", "(", "166", "/* PropertyAccessExpression */", ")", ";", "result", ".", "expression", "=", "parenthesizeForAccess", "(", "expression", ")", ";", "result", ".", "dotToken", "=", "ts", ".", "createSynthesizedNode", "(", "21", "/* DotToken */", ")", ";", "result", ".", "name", "=", "name", ";", "return", "result", ";", "}", "function", "createElementAccessExpression", "(", "expression", ",", "argumentExpression", ")", "{", "var", "result", "=", "ts", ".", "createSynthesizedNode", "(", "167", "/* ElementAccessExpression */", ")", ";", "result", ".", "expression", "=", "parenthesizeForAccess", "(", "expression", ")", ";", "result", ".", "argumentExpression", "=", "argumentExpression", ";", "return", "result", ";", "}", "function", "parenthesizeForAccess", "(", "expr", ")", "{", "// When diagnosing whether the expression needs parentheses, the decision should be based", "// on the innermost expression in a chain of nested type assertions.", "while", "(", "expr", ".", "kind", "===", "171", "/* TypeAssertionExpression */", "||", "expr", ".", "kind", "===", "189", "/* AsExpression */", ")", "{", "expr", "=", "expr", ".", "expression", ";", "}", "// isLeftHandSideExpression is almost the correct criterion for when it is not necessary", "// to parenthesize the expression before a dot. The known exceptions are:", "//", "//    NewExpression:", "//       new C.x        -> not the same as (new C).x", "//    NumberLiteral", "//       1.x            -> not the same as (1).x", "//", "if", "(", "ts", ".", "isLeftHandSideExpression", "(", "expr", ")", "&&", "expr", ".", "kind", "!==", "169", "/* NewExpression */", "&&", "expr", ".", "kind", "!==", "8", "/* NumericLiteral */", ")", "{", "return", "expr", ";", "}", "var", "node", "=", "ts", ".", "createSynthesizedNode", "(", "172", "/* ParenthesizedExpression */", ")", ";", "node", ".", "expression", "=", "expr", ";", "return", "node", ";", "}", "function", "emitComputedPropertyName", "(", "node", ")", "{", "write", "(", "\"[\"", ")", ";", "emitExpressionForPropertyName", "(", "node", ")", ";", "write", "(", "\"]\"", ")", ";", "}", "function", "emitMethod", "(", "node", ")", "{", "if", "(", "languageVersion", ">=", "2", "/* ES6 */", "&&", "node", ".", "asteriskToken", ")", "{", "write", "(", "\"*\"", ")", ";", "}", "emit", "(", "node", ".", "name", ")", ";", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "write", "(", "\": function \"", ")", ";", "}", "emitSignatureAndBody", "(", "node", ")", ";", "}", "function", "emitPropertyAssignment", "(", "node", ")", "{", "emit", "(", "node", ".", "name", ")", ";", "write", "(", "\": \"", ")", ";", "// This is to ensure that we emit comment in the following case:", "//      For example:", "//          obj = {", "//              id: /*comment1*/ ()=>void", "//          }", "// \"comment1\" is not considered to be leading comment for node.initializer", "// but rather a trailing comment on the previous node.", "emitTrailingCommentsOfPosition", "(", "node", ".", "initializer", ".", "pos", ")", ";", "emit", "(", "node", ".", "initializer", ")", ";", "}", "// Return true if identifier resolves to an exported member of a namespace", "function", "isNamespaceExportReference", "(", "node", ")", "{", "var", "container", "=", "resolver", ".", "getReferencedExportContainer", "(", "node", ")", ";", "return", "container", "&&", "container", ".", "kind", "!==", "248", "/* SourceFile */", ";", "}", "function", "emitShorthandPropertyAssignment", "(", "node", ")", "{", "// The name property of a short-hand property assignment is considered an expression position, so here", "// we manually emit the identifier to avoid rewriting.", "writeTextOfNode", "(", "currentSourceFile", ",", "node", ".", "name", ")", ";", "// If emitting pre-ES6 code, or if the name requires rewriting when resolved as an expression identifier,", "// we emit a normal property assignment. For example:", "//   module m {", "//       export let y;", "//   }", "//   module m {", "//       let obj = { y };", "//   }", "// Here we need to emit obj = { y : m.y } regardless of the output target.", "if", "(", "languageVersion", "<", "2", "/* ES6 */", "||", "isNamespaceExportReference", "(", "node", ".", "name", ")", ")", "{", "// Emit identifier as an identifier", "write", "(", "\": \"", ")", ";", "emit", "(", "node", ".", "name", ")", ";", "}", "if", "(", "languageVersion", ">=", "2", "/* ES6 */", "&&", "node", ".", "objectAssignmentInitializer", ")", "{", "write", "(", "\" = \"", ")", ";", "emit", "(", "node", ".", "objectAssignmentInitializer", ")", ";", "}", "}", "function", "tryEmitConstantValue", "(", "node", ")", "{", "var", "constantValue", "=", "tryGetConstEnumValue", "(", "node", ")", ";", "if", "(", "constantValue", "!==", "undefined", ")", "{", "write", "(", "constantValue", ".", "toString", "(", ")", ")", ";", "if", "(", "!", "compilerOptions", ".", "removeComments", ")", "{", "var", "propertyName", "=", "node", ".", "kind", "===", "166", "/* PropertyAccessExpression */", "?", "ts", ".", "declarationNameToString", "(", "node", ".", "name", ")", ":", "ts", ".", "getTextOfNode", "(", "node", ".", "argumentExpression", ")", ";", "write", "(", "\" /* \"", "+", "propertyName", "+", "\" */\"", ")", ";", "}", "return", "true", ";", "}", "return", "false", ";", "}", "function", "tryGetConstEnumValue", "(", "node", ")", "{", "if", "(", "compilerOptions", ".", "isolatedModules", ")", "{", "return", "undefined", ";", "}", "return", "node", ".", "kind", "===", "166", "/* PropertyAccessExpression */", "||", "node", ".", "kind", "===", "167", "/* ElementAccessExpression */", "?", "resolver", ".", "getConstantValue", "(", "node", ")", ":", "undefined", ";", "}", "// Returns 'true' if the code was actually indented, false otherwise.", "// If the code is not indented, an optional valueToWriteWhenNotIndenting will be", "// emitted instead.", "function", "indentIfOnDifferentLines", "(", "parent", ",", "node1", ",", "node2", ",", "valueToWriteWhenNotIndenting", ")", "{", "var", "realNodesAreOnDifferentLines", "=", "!", "ts", ".", "nodeIsSynthesized", "(", "parent", ")", "&&", "!", "nodeEndIsOnSameLineAsNodeStart", "(", "node1", ",", "node2", ")", ";", "// Always use a newline for synthesized code if the synthesizer desires it.", "var", "synthesizedNodeIsOnDifferentLine", "=", "synthesizedNodeStartsOnNewLine", "(", "node2", ")", ";", "if", "(", "realNodesAreOnDifferentLines", "||", "synthesizedNodeIsOnDifferentLine", ")", "{", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "return", "true", ";", "}", "else", "{", "if", "(", "valueToWriteWhenNotIndenting", ")", "{", "write", "(", "valueToWriteWhenNotIndenting", ")", ";", "}", "return", "false", ";", "}", "}", "function", "emitPropertyAccess", "(", "node", ")", "{", "if", "(", "tryEmitConstantValue", "(", "node", ")", ")", "{", "return", ";", "}", "emit", "(", "node", ".", "expression", ")", ";", "var", "indentedBeforeDot", "=", "indentIfOnDifferentLines", "(", "node", ",", "node", ".", "expression", ",", "node", ".", "dotToken", ")", ";", "// 1 .toString is a valid property access, emit a space after the literal", "// Also emit a space if expression is a integer const enum value - it will appear in generated code as numeric literal", "var", "shouldEmitSpace", ";", "if", "(", "!", "indentedBeforeDot", ")", "{", "if", "(", "node", ".", "expression", ".", "kind", "===", "8", "/* NumericLiteral */", ")", "{", "// check if numeric literal was originally written with a dot", "var", "text", "=", "ts", ".", "getSourceTextOfNodeFromSourceFile", "(", "currentSourceFile", ",", "node", ".", "expression", ")", ";", "shouldEmitSpace", "=", "text", ".", "indexOf", "(", "ts", ".", "tokenToString", "(", "21", "/* DotToken */", ")", ")", "<", "0", ";", "}", "else", "{", "// check if constant enum value is integer", "var", "constantValue", "=", "tryGetConstEnumValue", "(", "node", ".", "expression", ")", ";", "// isFinite handles cases when constantValue is undefined", "shouldEmitSpace", "=", "isFinite", "(", "constantValue", ")", "&&", "Math", ".", "floor", "(", "constantValue", ")", "===", "constantValue", ";", "}", "}", "if", "(", "shouldEmitSpace", ")", "{", "write", "(", "\" .\"", ")", ";", "}", "else", "{", "write", "(", "\".\"", ")", ";", "}", "var", "indentedAfterDot", "=", "indentIfOnDifferentLines", "(", "node", ",", "node", ".", "dotToken", ",", "node", ".", "name", ")", ";", "emit", "(", "node", ".", "name", ")", ";", "decreaseIndentIf", "(", "indentedBeforeDot", ",", "indentedAfterDot", ")", ";", "}", "function", "emitQualifiedName", "(", "node", ")", "{", "emit", "(", "node", ".", "left", ")", ";", "write", "(", "\".\"", ")", ";", "emit", "(", "node", ".", "right", ")", ";", "}", "function", "emitQualifiedNameAsExpression", "(", "node", ",", "useFallback", ")", "{", "if", "(", "node", ".", "left", ".", "kind", "===", "69", "/* Identifier */", ")", "{", "emitEntityNameAsExpression", "(", "node", ".", "left", ",", "useFallback", ")", ";", "}", "else", "if", "(", "useFallback", ")", "{", "var", "temp", "=", "createAndRecordTempVariable", "(", "0", "/* Auto */", ")", ";", "write", "(", "\"(\"", ")", ";", "emitNodeWithoutSourceMap", "(", "temp", ")", ";", "write", "(", "\" = \"", ")", ";", "emitEntityNameAsExpression", "(", "node", ".", "left", ",", "/*useFallback*/", "true", ")", ";", "write", "(", "\") && \"", ")", ";", "emitNodeWithoutSourceMap", "(", "temp", ")", ";", "}", "else", "{", "emitEntityNameAsExpression", "(", "node", ".", "left", ",", "/*useFallback*/", "false", ")", ";", "}", "write", "(", "\".\"", ")", ";", "emit", "(", "node", ".", "right", ")", ";", "}", "function", "emitEntityNameAsExpression", "(", "node", ",", "useFallback", ")", "{", "switch", "(", "node", ".", "kind", ")", "{", "case", "69", "/* Identifier */", ":", "if", "(", "useFallback", ")", "{", "write", "(", "\"typeof \"", ")", ";", "emitExpressionIdentifier", "(", "node", ")", ";", "write", "(", "\" !== 'undefined' && \"", ")", ";", "}", "emitExpressionIdentifier", "(", "node", ")", ";", "break", ";", "case", "135", "/* QualifiedName */", ":", "emitQualifiedNameAsExpression", "(", "node", ",", "useFallback", ")", ";", "break", ";", "}", "}", "function", "emitIndexedAccess", "(", "node", ")", "{", "if", "(", "tryEmitConstantValue", "(", "node", ")", ")", "{", "return", ";", "}", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\"[\"", ")", ";", "emit", "(", "node", ".", "argumentExpression", ")", ";", "write", "(", "\"]\"", ")", ";", "}", "function", "hasSpreadElement", "(", "elements", ")", "{", "return", "ts", ".", "forEach", "(", "elements", ",", "function", "(", "e", ")", "{", "return", "e", ".", "kind", "===", "185", "/* SpreadElementExpression */", ";", "}", ")", ";", "}", "function", "skipParentheses", "(", "node", ")", "{", "while", "(", "node", ".", "kind", "===", "172", "/* ParenthesizedExpression */", "||", "node", ".", "kind", "===", "171", "/* TypeAssertionExpression */", "||", "node", ".", "kind", "===", "189", "/* AsExpression */", ")", "{", "node", "=", "node", ".", "expression", ";", "}", "return", "node", ";", "}", "function", "emitCallTarget", "(", "node", ")", "{", "if", "(", "node", ".", "kind", "===", "69", "/* Identifier */", "||", "node", ".", "kind", "===", "97", "/* ThisKeyword */", "||", "node", ".", "kind", "===", "95", "/* SuperKeyword */", ")", "{", "emit", "(", "node", ")", ";", "return", "node", ";", "}", "var", "temp", "=", "createAndRecordTempVariable", "(", "0", "/* Auto */", ")", ";", "write", "(", "\"(\"", ")", ";", "emit", "(", "temp", ")", ";", "write", "(", "\" = \"", ")", ";", "emit", "(", "node", ")", ";", "write", "(", "\")\"", ")", ";", "return", "temp", ";", "}", "function", "emitCallWithSpread", "(", "node", ")", "{", "var", "target", ";", "var", "expr", "=", "skipParentheses", "(", "node", ".", "expression", ")", ";", "if", "(", "expr", ".", "kind", "===", "166", "/* PropertyAccessExpression */", ")", "{", "// Target will be emitted as \"this\" argument", "target", "=", "emitCallTarget", "(", "expr", ".", "expression", ")", ";", "write", "(", "\".\"", ")", ";", "emit", "(", "expr", ".", "name", ")", ";", "}", "else", "if", "(", "expr", ".", "kind", "===", "167", "/* ElementAccessExpression */", ")", "{", "// Target will be emitted as \"this\" argument", "target", "=", "emitCallTarget", "(", "expr", ".", "expression", ")", ";", "write", "(", "\"[\"", ")", ";", "emit", "(", "expr", ".", "argumentExpression", ")", ";", "write", "(", "\"]\"", ")", ";", "}", "else", "if", "(", "expr", ".", "kind", "===", "95", "/* SuperKeyword */", ")", "{", "target", "=", "expr", ";", "write", "(", "\"_super\"", ")", ";", "}", "else", "{", "emit", "(", "node", ".", "expression", ")", ";", "}", "write", "(", "\".apply(\"", ")", ";", "if", "(", "target", ")", "{", "if", "(", "target", ".", "kind", "===", "95", "/* SuperKeyword */", ")", "{", "// Calls of form super(...) and super.foo(...)", "emitThis", "(", "target", ")", ";", "}", "else", "{", "// Calls of form obj.foo(...)", "emit", "(", "target", ")", ";", "}", "}", "else", "{", "// Calls of form foo(...)", "write", "(", "\"void 0\"", ")", ";", "}", "write", "(", "\", \"", ")", ";", "emitListWithSpread", "(", "node", ".", "arguments", ",", "/*needsUniqueCopy*/", "false", ",", "/*multiLine*/", "false", ",", "/*trailingComma*/", "false", ",", "/*useConcat*/", "true", ")", ";", "write", "(", "\")\"", ")", ";", "}", "function", "emitCallExpression", "(", "node", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", "&&", "hasSpreadElement", "(", "node", ".", "arguments", ")", ")", "{", "emitCallWithSpread", "(", "node", ")", ";", "return", ";", "}", "var", "superCall", "=", "false", ";", "if", "(", "node", ".", "expression", ".", "kind", "===", "95", "/* SuperKeyword */", ")", "{", "emitSuper", "(", "node", ".", "expression", ")", ";", "superCall", "=", "true", ";", "}", "else", "{", "emit", "(", "node", ".", "expression", ")", ";", "superCall", "=", "node", ".", "expression", ".", "kind", "===", "166", "/* PropertyAccessExpression */", "&&", "node", ".", "expression", ".", "expression", ".", "kind", "===", "95", "/* SuperKeyword */", ";", "}", "if", "(", "superCall", "&&", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "write", "(", "\".call(\"", ")", ";", "emitThis", "(", "node", ".", "expression", ")", ";", "if", "(", "node", ".", "arguments", ".", "length", ")", "{", "write", "(", "\", \"", ")", ";", "emitCommaList", "(", "node", ".", "arguments", ")", ";", "}", "write", "(", "\")\"", ")", ";", "}", "else", "{", "write", "(", "\"(\"", ")", ";", "emitCommaList", "(", "node", ".", "arguments", ")", ";", "write", "(", "\")\"", ")", ";", "}", "}", "function", "emitNewExpression", "(", "node", ")", "{", "write", "(", "\"new \"", ")", ";", "// Spread operator logic is supported in new expressions in ES5 using a combination", "// of Function.prototype.bind() and Function.prototype.apply().", "//", "//     Example:", "//", "//         var args = [1, 2, 3, 4, 5];", "//         new Array(...args);", "//", "//     is compiled into the following ES5:", "//", "//         var args = [1, 2, 3, 4, 5];", "//         new (Array.bind.apply(Array, [void 0].concat(args)));", "//", "// The 'thisArg' to 'bind' is ignored when invoking the result of 'bind' with 'new',", "// Thus, we set it to undefined ('void 0').", "if", "(", "languageVersion", "===", "1", "/* ES5 */", "&&", "node", ".", "arguments", "&&", "hasSpreadElement", "(", "node", ".", "arguments", ")", ")", "{", "write", "(", "\"(\"", ")", ";", "var", "target", "=", "emitCallTarget", "(", "node", ".", "expression", ")", ";", "write", "(", "\".bind.apply(\"", ")", ";", "emit", "(", "target", ")", ";", "write", "(", "\", [void 0].concat(\"", ")", ";", "emitListWithSpread", "(", "node", ".", "arguments", ",", "/*needsUniqueCopy*/", "false", ",", "/*multiline*/", "false", ",", "/*trailingComma*/", "false", ",", "/*useConcat*/", "false", ")", ";", "write", "(", "\")))\"", ")", ";", "write", "(", "\"()\"", ")", ";", "}", "else", "{", "emit", "(", "node", ".", "expression", ")", ";", "if", "(", "node", ".", "arguments", ")", "{", "write", "(", "\"(\"", ")", ";", "emitCommaList", "(", "node", ".", "arguments", ")", ";", "write", "(", "\")\"", ")", ";", "}", "}", "}", "function", "emitTaggedTemplateExpression", "(", "node", ")", "{", "if", "(", "languageVersion", ">=", "2", "/* ES6 */", ")", "{", "emit", "(", "node", ".", "tag", ")", ";", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ".", "template", ")", ";", "}", "else", "{", "emitDownlevelTaggedTemplate", "(", "node", ")", ";", "}", "}", "function", "emitParenExpression", "(", "node", ")", "{", "// If the node is synthesized, it means the emitter put the parentheses there,", "// not the user. If we didn't want them, the emitter would not have put them", "// there.", "if", "(", "!", "ts", ".", "nodeIsSynthesized", "(", "node", ")", "&&", "node", ".", "parent", ".", "kind", "!==", "174", "/* ArrowFunction */", ")", "{", "if", "(", "node", ".", "expression", ".", "kind", "===", "171", "/* TypeAssertionExpression */", "||", "node", ".", "expression", ".", "kind", "===", "189", "/* AsExpression */", ")", "{", "var", "operand", "=", "node", ".", "expression", ".", "expression", ";", "// Make sure we consider all nested cast expressions, e.g.:", "// (<any><number><any>-A).x;", "while", "(", "operand", ".", "kind", "===", "171", "/* TypeAssertionExpression */", "||", "operand", ".", "kind", "===", "189", "/* AsExpression */", ")", "{", "operand", "=", "operand", ".", "expression", ";", "}", "// We have an expression of the form: (<Type>SubExpr)", "// Emitting this as (SubExpr) is really not desirable. We would like to emit the subexpr as is.", "// Omitting the parentheses, however, could cause change in the semantics of the generated", "// code if the casted expression has a lower precedence than the rest of the expression, e.g.:", "//      (<any>new A).foo should be emitted as (new A).foo and not new A.foo", "//      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()", "//      new (<any>A()) should be emitted as new (A()) and not new A()", "//      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()", "if", "(", "operand", ".", "kind", "!==", "179", "/* PrefixUnaryExpression */", "&&", "operand", ".", "kind", "!==", "177", "/* VoidExpression */", "&&", "operand", ".", "kind", "!==", "176", "/* TypeOfExpression */", "&&", "operand", ".", "kind", "!==", "175", "/* DeleteExpression */", "&&", "operand", ".", "kind", "!==", "180", "/* PostfixUnaryExpression */", "&&", "operand", ".", "kind", "!==", "169", "/* NewExpression */", "&&", "!", "(", "operand", ".", "kind", "===", "168", "/* CallExpression */", "&&", "node", ".", "parent", ".", "kind", "===", "169", "/* NewExpression */", ")", "&&", "!", "(", "operand", ".", "kind", "===", "173", "/* FunctionExpression */", "&&", "node", ".", "parent", ".", "kind", "===", "168", "/* CallExpression */", ")", "&&", "!", "(", "operand", ".", "kind", "===", "8", "/* NumericLiteral */", "&&", "node", ".", "parent", ".", "kind", "===", "166", "/* PropertyAccessExpression */", ")", ")", "{", "emit", "(", "operand", ")", ";", "return", ";", "}", "}", "}", "write", "(", "\"(\"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\")\"", ")", ";", "}", "function", "emitDeleteExpression", "(", "node", ")", "{", "write", "(", "ts", ".", "tokenToString", "(", "78", "/* DeleteKeyword */", ")", ")", ";", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "}", "function", "emitVoidExpression", "(", "node", ")", "{", "write", "(", "ts", ".", "tokenToString", "(", "103", "/* VoidKeyword */", ")", ")", ";", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "}", "function", "emitTypeOfExpression", "(", "node", ")", "{", "write", "(", "ts", ".", "tokenToString", "(", "101", "/* TypeOfKeyword */", ")", ")", ";", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "}", "function", "isNameOfExportedSourceLevelDeclarationInSystemExternalModule", "(", "node", ")", "{", "if", "(", "!", "isCurrentFileSystemExternalModule", "(", ")", "||", "node", ".", "kind", "!==", "69", "/* Identifier */", "||", "ts", ".", "nodeIsSynthesized", "(", "node", ")", ")", "{", "return", "false", ";", "}", "var", "isVariableDeclarationOrBindingElement", "=", "node", ".", "parent", "&&", "(", "node", ".", "parent", ".", "kind", "===", "211", "/* VariableDeclaration */", "||", "node", ".", "parent", ".", "kind", "===", "163", "/* BindingElement */", ")", ";", "var", "targetDeclaration", "=", "isVariableDeclarationOrBindingElement", "?", "node", ".", "parent", ":", "resolver", ".", "getReferencedValueDeclaration", "(", "node", ")", ";", "return", "isSourceFileLevelDeclarationInSystemJsModule", "(", "targetDeclaration", ",", "/*isExported*/", "true", ")", ";", "}", "function", "emitPrefixUnaryExpression", "(", "node", ")", "{", "var", "exportChanged", "=", "isNameOfExportedSourceLevelDeclarationInSystemExternalModule", "(", "node", ".", "operand", ")", ";", "if", "(", "exportChanged", ")", "{", "// emit", "// ++x", "// as", "// exports('x', ++x)", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitNodeWithoutSourceMap", "(", "node", ".", "operand", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "}", "write", "(", "ts", ".", "tokenToString", "(", "node", ".", "operator", ")", ")", ";", "// In some cases, we need to emit a space between the operator and the operand. One obvious case", "// is when the operator is an identifier, like delete or typeof. We also need to do this for plus", "// and minus expressions in certain cases. Specifically, consider the following two cases (parens", "// are just for clarity of exposition, and not part of the source code):", "//", "//  (+(+1))", "//  (+(++1))", "//", "// We need to emit a space in both cases. In the first case, the absence of a space will make", "// the resulting expression a prefix increment operation. And in the second, it will make the resulting", "// expression a prefix increment whose operand is a plus expression - (++(+x))", "// The same is true of minus of course.", "if", "(", "node", ".", "operand", ".", "kind", "===", "179", "/* PrefixUnaryExpression */", ")", "{", "var", "operand", "=", "node", ".", "operand", ";", "if", "(", "node", ".", "operator", "===", "35", "/* PlusToken */", "&&", "(", "operand", ".", "operator", "===", "35", "/* PlusToken */", "||", "operand", ".", "operator", "===", "41", "/* PlusPlusToken */", ")", ")", "{", "write", "(", "\" \"", ")", ";", "}", "else", "if", "(", "node", ".", "operator", "===", "36", "/* MinusToken */", "&&", "(", "operand", ".", "operator", "===", "36", "/* MinusToken */", "||", "operand", ".", "operator", "===", "42", "/* MinusMinusToken */", ")", ")", "{", "write", "(", "\" \"", ")", ";", "}", "}", "emit", "(", "node", ".", "operand", ")", ";", "if", "(", "exportChanged", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "function", "emitPostfixUnaryExpression", "(", "node", ")", "{", "var", "exportChanged", "=", "isNameOfExportedSourceLevelDeclarationInSystemExternalModule", "(", "node", ".", "operand", ")", ";", "if", "(", "exportChanged", ")", "{", "// export function returns the value that was passes as the second argument", "// however for postfix unary expressions result value should be the value before modification.", "// emit 'x++' as '(export('x', ++x) - 1)' and 'x--' as '(export('x', --x) + 1)'", "write", "(", "\"(\"", "+", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitNodeWithoutSourceMap", "(", "node", ".", "operand", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "write", "(", "ts", ".", "tokenToString", "(", "node", ".", "operator", ")", ")", ";", "emit", "(", "node", ".", "operand", ")", ";", "if", "(", "node", ".", "operator", "===", "41", "/* PlusPlusToken */", ")", "{", "write", "(", "\") - 1)\"", ")", ";", "}", "else", "{", "write", "(", "\") + 1)\"", ")", ";", "}", "}", "else", "{", "emit", "(", "node", ".", "operand", ")", ";", "write", "(", "ts", ".", "tokenToString", "(", "node", ".", "operator", ")", ")", ";", "}", "}", "function", "shouldHoistDeclarationInSystemJsModule", "(", "node", ")", "{", "return", "isSourceFileLevelDeclarationInSystemJsModule", "(", "node", ",", "/*isExported*/", "false", ")", ";", "}", "/*\n             * Checks if given node is a source file level declaration (not nested in module/function).\n             * If 'isExported' is true - then declaration must also be exported.\n             * This function is used in two cases:\n             * - check if node is a exported source file level value to determine\n             *   if we should also export the value after its it changed\n             * - check if node is a source level declaration to emit it differently,\n             *   i.e non-exported variable statement 'var x = 1' is hoisted so\n             *   we we emit variable statement 'var' should be dropped.\n             */", "function", "isSourceFileLevelDeclarationInSystemJsModule", "(", "node", ",", "isExported", ")", "{", "if", "(", "!", "node", "||", "languageVersion", ">=", "2", "/* ES6 */", "||", "!", "isCurrentFileSystemExternalModule", "(", ")", ")", "{", "return", "false", ";", "}", "var", "current", "=", "node", ";", "while", "(", "current", ")", "{", "if", "(", "current", ".", "kind", "===", "248", "/* SourceFile */", ")", "{", "return", "!", "isExported", "||", "(", "(", "ts", ".", "getCombinedNodeFlags", "(", "node", ")", "&", "1", "/* Export */", ")", "!==", "0", ")", ";", "}", "else", "if", "(", "ts", ".", "isFunctionLike", "(", "current", ")", "||", "current", ".", "kind", "===", "219", "/* ModuleBlock */", ")", "{", "return", "false", ";", "}", "else", "{", "current", "=", "current", ".", "parent", ";", "}", "}", "}", "/**\n             * Emit ES7 exponentiation operator downlevel using Math.pow\n             * @param node a binary expression node containing exponentiationOperator (**, **=)\n             */", "function", "emitExponentiationOperator", "(", "node", ")", "{", "var", "leftHandSideExpression", "=", "node", ".", "left", ";", "if", "(", "node", ".", "operatorToken", ".", "kind", "===", "60", "/* AsteriskAsteriskEqualsToken */", ")", "{", "var", "synthesizedLHS", ";", "var", "shouldEmitParentheses", "=", "false", ";", "if", "(", "ts", ".", "isElementAccessExpression", "(", "leftHandSideExpression", ")", ")", "{", "shouldEmitParentheses", "=", "true", ";", "write", "(", "\"(\"", ")", ";", "synthesizedLHS", "=", "ts", ".", "createSynthesizedNode", "(", "167", "/* ElementAccessExpression */", ",", "/*startsOnNewLine*/", "false", ")", ";", "var", "identifier", "=", "emitTempVariableAssignment", "(", "leftHandSideExpression", ".", "expression", ",", "/*canDefinedTempVariablesInPlaces*/", "false", ",", "/*shouldEmitCommaBeforeAssignment*/", "false", ")", ";", "synthesizedLHS", ".", "expression", "=", "identifier", ";", "if", "(", "leftHandSideExpression", ".", "argumentExpression", ".", "kind", "!==", "8", "/* NumericLiteral */", "&&", "leftHandSideExpression", ".", "argumentExpression", ".", "kind", "!==", "9", "/* StringLiteral */", ")", "{", "var", "tempArgumentExpression", "=", "createAndRecordTempVariable", "(", "268435456", "/* _i */", ")", ";", "synthesizedLHS", ".", "argumentExpression", "=", "tempArgumentExpression", ";", "emitAssignment", "(", "tempArgumentExpression", ",", "leftHandSideExpression", ".", "argumentExpression", ",", "/*shouldEmitCommaBeforeAssignment*/", "true", ")", ";", "}", "else", "{", "synthesizedLHS", ".", "argumentExpression", "=", "leftHandSideExpression", ".", "argumentExpression", ";", "}", "write", "(", "\", \"", ")", ";", "}", "else", "if", "(", "ts", ".", "isPropertyAccessExpression", "(", "leftHandSideExpression", ")", ")", "{", "shouldEmitParentheses", "=", "true", ";", "write", "(", "\"(\"", ")", ";", "synthesizedLHS", "=", "ts", ".", "createSynthesizedNode", "(", "166", "/* PropertyAccessExpression */", ",", "/*startsOnNewLine*/", "false", ")", ";", "var", "identifier", "=", "emitTempVariableAssignment", "(", "leftHandSideExpression", ".", "expression", ",", "/*canDefinedTempVariablesInPlaces*/", "false", ",", "/*shouldemitCommaBeforeAssignment*/", "false", ")", ";", "synthesizedLHS", ".", "expression", "=", "identifier", ";", "synthesizedLHS", ".", "dotToken", "=", "leftHandSideExpression", ".", "dotToken", ";", "synthesizedLHS", ".", "name", "=", "leftHandSideExpression", ".", "name", ";", "write", "(", "\", \"", ")", ";", "}", "emit", "(", "synthesizedLHS", "||", "leftHandSideExpression", ")", ";", "write", "(", "\" = \"", ")", ";", "write", "(", "\"Math.pow(\"", ")", ";", "emit", "(", "synthesizedLHS", "||", "leftHandSideExpression", ")", ";", "write", "(", "\", \"", ")", ";", "emit", "(", "node", ".", "right", ")", ";", "write", "(", "\")\"", ")", ";", "if", "(", "shouldEmitParentheses", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "else", "{", "write", "(", "\"Math.pow(\"", ")", ";", "emit", "(", "leftHandSideExpression", ")", ";", "write", "(", "\", \"", ")", ";", "emit", "(", "node", ".", "right", ")", ";", "write", "(", "\")\"", ")", ";", "}", "}", "function", "emitBinaryExpression", "(", "node", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", "&&", "node", ".", "operatorToken", ".", "kind", "===", "56", "/* EqualsToken */", "&&", "(", "node", ".", "left", ".", "kind", "===", "165", "/* ObjectLiteralExpression */", "||", "node", ".", "left", ".", "kind", "===", "164", "/* ArrayLiteralExpression */", ")", ")", "{", "emitDestructuring", "(", "node", ",", "node", ".", "parent", ".", "kind", "===", "195", "/* ExpressionStatement */", ")", ";", "}", "else", "{", "var", "exportChanged", "=", "node", ".", "operatorToken", ".", "kind", ">=", "56", "/* FirstAssignment */", "&&", "node", ".", "operatorToken", ".", "kind", "<=", "68", "/* LastAssignment */", "&&", "isNameOfExportedSourceLevelDeclarationInSystemExternalModule", "(", "node", ".", "left", ")", ";", "if", "(", "exportChanged", ")", "{", "// emit assignment 'x <op> y' as 'exports(\"x\", x <op> y)'", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitNodeWithoutSourceMap", "(", "node", ".", "left", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "}", "if", "(", "node", ".", "operatorToken", ".", "kind", "===", "38", "/* AsteriskAsteriskToken */", "||", "node", ".", "operatorToken", ".", "kind", "===", "60", "/* AsteriskAsteriskEqualsToken */", ")", "{", "// Downleveled emit exponentiation operator using Math.pow", "emitExponentiationOperator", "(", "node", ")", ";", "}", "else", "{", "emit", "(", "node", ".", "left", ")", ";", "// Add indentation before emit the operator if the operator is on different line", "// For example:", "//      3", "//      + 2;", "//   emitted as", "//      3", "//          + 2;", "var", "indentedBeforeOperator", "=", "indentIfOnDifferentLines", "(", "node", ",", "node", ".", "left", ",", "node", ".", "operatorToken", ",", "node", ".", "operatorToken", ".", "kind", "!==", "24", "/* CommaToken */", "?", "\" \"", ":", "undefined", ")", ";", "write", "(", "ts", ".", "tokenToString", "(", "node", ".", "operatorToken", ".", "kind", ")", ")", ";", "var", "indentedAfterOperator", "=", "indentIfOnDifferentLines", "(", "node", ",", "node", ".", "operatorToken", ",", "node", ".", "right", ",", "\" \"", ")", ";", "emit", "(", "node", ".", "right", ")", ";", "decreaseIndentIf", "(", "indentedBeforeOperator", ",", "indentedAfterOperator", ")", ";", "}", "if", "(", "exportChanged", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "}", "function", "synthesizedNodeStartsOnNewLine", "(", "node", ")", "{", "return", "ts", ".", "nodeIsSynthesized", "(", "node", ")", "&&", "node", ".", "startsOnNewLine", ";", "}", "function", "emitConditionalExpression", "(", "node", ")", "{", "emit", "(", "node", ".", "condition", ")", ";", "var", "indentedBeforeQuestion", "=", "indentIfOnDifferentLines", "(", "node", ",", "node", ".", "condition", ",", "node", ".", "questionToken", ",", "\" \"", ")", ";", "write", "(", "\"?\"", ")", ";", "var", "indentedAfterQuestion", "=", "indentIfOnDifferentLines", "(", "node", ",", "node", ".", "questionToken", ",", "node", ".", "whenTrue", ",", "\" \"", ")", ";", "emit", "(", "node", ".", "whenTrue", ")", ";", "decreaseIndentIf", "(", "indentedBeforeQuestion", ",", "indentedAfterQuestion", ")", ";", "var", "indentedBeforeColon", "=", "indentIfOnDifferentLines", "(", "node", ",", "node", ".", "whenTrue", ",", "node", ".", "colonToken", ",", "\" \"", ")", ";", "write", "(", "\":\"", ")", ";", "var", "indentedAfterColon", "=", "indentIfOnDifferentLines", "(", "node", ",", "node", ".", "colonToken", ",", "node", ".", "whenFalse", ",", "\" \"", ")", ";", "emit", "(", "node", ".", "whenFalse", ")", ";", "decreaseIndentIf", "(", "indentedBeforeColon", ",", "indentedAfterColon", ")", ";", "}", "// Helper function to decrease the indent if we previously indented.  Allows multiple", "// previous indent values to be considered at a time.  This also allows caller to just", "// call this once, passing in all their appropriate indent values, instead of needing", "// to call this helper function multiple times.", "function", "decreaseIndentIf", "(", "value1", ",", "value2", ")", "{", "if", "(", "value1", ")", "{", "decreaseIndent", "(", ")", ";", "}", "if", "(", "value2", ")", "{", "decreaseIndent", "(", ")", ";", "}", "}", "function", "isSingleLineEmptyBlock", "(", "node", ")", "{", "if", "(", "node", "&&", "node", ".", "kind", "===", "192", "/* Block */", ")", "{", "var", "block", "=", "node", ";", "return", "block", ".", "statements", ".", "length", "===", "0", "&&", "nodeEndIsOnSameLineAsNodeStart", "(", "block", ",", "block", ")", ";", "}", "}", "function", "emitBlock", "(", "node", ")", "{", "if", "(", "isSingleLineEmptyBlock", "(", "node", ")", ")", "{", "emitToken", "(", "15", "/* OpenBraceToken */", ",", "node", ".", "pos", ")", ";", "write", "(", "\" \"", ")", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "node", ".", "statements", ".", "end", ")", ";", "return", ";", "}", "emitToken", "(", "15", "/* OpenBraceToken */", ",", "node", ".", "pos", ")", ";", "increaseIndent", "(", ")", ";", "scopeEmitStart", "(", "node", ".", "parent", ")", ";", "if", "(", "node", ".", "kind", "===", "219", "/* ModuleBlock */", ")", "{", "ts", ".", "Debug", ".", "assert", "(", "node", ".", "parent", ".", "kind", "===", "218", "/* ModuleDeclaration */", ")", ";", "emitCaptureThisForNodeIfNecessary", "(", "node", ".", "parent", ")", ";", "}", "emitLines", "(", "node", ".", "statements", ")", ";", "if", "(", "node", ".", "kind", "===", "219", "/* ModuleBlock */", ")", "{", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "}", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "node", ".", "statements", ".", "end", ")", ";", "scopeEmitEnd", "(", ")", ";", "}", "function", "emitEmbeddedStatement", "(", "node", ")", "{", "if", "(", "node", ".", "kind", "===", "192", "/* Block */", ")", "{", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ")", ";", "}", "else", "{", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emit", "(", "node", ")", ";", "decreaseIndent", "(", ")", ";", "}", "}", "function", "emitExpressionStatement", "(", "node", ")", "{", "emitParenthesizedIf", "(", "node", ".", "expression", ",", "/*parenthesized*/", "node", ".", "expression", ".", "kind", "===", "174", "/* ArrowFunction */", ")", ";", "write", "(", "\";\"", ")", ";", "}", "function", "emitIfStatement", "(", "node", ")", "{", "var", "endPos", "=", "emitToken", "(", "88", "/* IfKeyword */", ",", "node", ".", "pos", ")", ";", "write", "(", "\" \"", ")", ";", "endPos", "=", "emitToken", "(", "17", "/* OpenParenToken */", ",", "endPos", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "emitToken", "(", "18", "/* CloseParenToken */", ",", "node", ".", "expression", ".", "end", ")", ";", "emitEmbeddedStatement", "(", "node", ".", "thenStatement", ")", ";", "if", "(", "node", ".", "elseStatement", ")", "{", "writeLine", "(", ")", ";", "emitToken", "(", "80", "/* ElseKeyword */", ",", "node", ".", "thenStatement", ".", "end", ")", ";", "if", "(", "node", ".", "elseStatement", ".", "kind", "===", "196", "/* IfStatement */", ")", "{", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ".", "elseStatement", ")", ";", "}", "else", "{", "emitEmbeddedStatement", "(", "node", ".", "elseStatement", ")", ";", "}", "}", "}", "function", "emitDoStatement", "(", "node", ")", "{", "write", "(", "\"do\"", ")", ";", "emitEmbeddedStatement", "(", "node", ".", "statement", ")", ";", "if", "(", "node", ".", "statement", ".", "kind", "===", "192", "/* Block */", ")", "{", "write", "(", "\" \"", ")", ";", "}", "else", "{", "writeLine", "(", ")", ";", "}", "write", "(", "\"while (\"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\");\"", ")", ";", "}", "function", "emitWhileStatement", "(", "node", ")", "{", "write", "(", "\"while (\"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\")\"", ")", ";", "emitEmbeddedStatement", "(", "node", ".", "statement", ")", ";", "}", "/**\n             * Returns true if start of variable declaration list was emitted.\n             * Returns false if nothing was written - this can happen for source file level variable declarations\n             *     in system modules where such variable declarations are hoisted.\n             */", "function", "tryEmitStartOfVariableDeclarationList", "(", "decl", ",", "startPos", ")", "{", "if", "(", "shouldHoistVariable", "(", "decl", ",", "/*checkIfSourceFileLevelDecl*/", "true", ")", ")", "{", "// variables in variable declaration list were already hoisted", "return", "false", ";", "}", "var", "tokenKind", "=", "102", "/* VarKeyword */", ";", "if", "(", "decl", "&&", "languageVersion", ">=", "2", "/* ES6 */", ")", "{", "if", "(", "ts", ".", "isLet", "(", "decl", ")", ")", "{", "tokenKind", "=", "108", "/* LetKeyword */", ";", "}", "else", "if", "(", "ts", ".", "isConst", "(", "decl", ")", ")", "{", "tokenKind", "=", "74", "/* ConstKeyword */", ";", "}", "}", "if", "(", "startPos", "!==", "undefined", ")", "{", "emitToken", "(", "tokenKind", ",", "startPos", ")", ";", "write", "(", "\" \"", ")", ";", "}", "else", "{", "switch", "(", "tokenKind", ")", "{", "case", "102", "/* VarKeyword */", ":", "write", "(", "\"var \"", ")", ";", "break", ";", "case", "108", "/* LetKeyword */", ":", "write", "(", "\"let \"", ")", ";", "break", ";", "case", "74", "/* ConstKeyword */", ":", "write", "(", "\"const \"", ")", ";", "break", ";", "}", "}", "return", "true", ";", "}", "function", "emitVariableDeclarationListSkippingUninitializedEntries", "(", "list", ")", "{", "var", "started", "=", "false", ";", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "list", ".", "declarations", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "decl", "=", "_b", "[", "_a", "]", ";", "if", "(", "!", "decl", ".", "initializer", ")", "{", "continue", ";", "}", "if", "(", "!", "started", ")", "{", "started", "=", "true", ";", "}", "else", "{", "write", "(", "\", \"", ")", ";", "}", "emit", "(", "decl", ")", ";", "}", "return", "started", ";", "}", "function", "emitForStatement", "(", "node", ")", "{", "var", "endPos", "=", "emitToken", "(", "86", "/* ForKeyword */", ",", "node", ".", "pos", ")", ";", "write", "(", "\" \"", ")", ";", "endPos", "=", "emitToken", "(", "17", "/* OpenParenToken */", ",", "endPos", ")", ";", "if", "(", "node", ".", "initializer", "&&", "node", ".", "initializer", ".", "kind", "===", "212", "/* VariableDeclarationList */", ")", "{", "var", "variableDeclarationList", "=", "node", ".", "initializer", ";", "var", "startIsEmitted", "=", "tryEmitStartOfVariableDeclarationList", "(", "variableDeclarationList", ",", "endPos", ")", ";", "if", "(", "startIsEmitted", ")", "{", "emitCommaList", "(", "variableDeclarationList", ".", "declarations", ")", ";", "}", "else", "{", "emitVariableDeclarationListSkippingUninitializedEntries", "(", "variableDeclarationList", ")", ";", "}", "}", "else", "if", "(", "node", ".", "initializer", ")", "{", "emit", "(", "node", ".", "initializer", ")", ";", "}", "write", "(", "\";\"", ")", ";", "emitOptional", "(", "\" \"", ",", "node", ".", "condition", ")", ";", "write", "(", "\";\"", ")", ";", "emitOptional", "(", "\" \"", ",", "node", ".", "incrementor", ")", ";", "write", "(", "\")\"", ")", ";", "emitEmbeddedStatement", "(", "node", ".", "statement", ")", ";", "}", "function", "emitForInOrForOfStatement", "(", "node", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", "&&", "node", ".", "kind", "===", "201", "/* ForOfStatement */", ")", "{", "return", "emitDownLevelForOfStatement", "(", "node", ")", ";", "}", "var", "endPos", "=", "emitToken", "(", "86", "/* ForKeyword */", ",", "node", ".", "pos", ")", ";", "write", "(", "\" \"", ")", ";", "endPos", "=", "emitToken", "(", "17", "/* OpenParenToken */", ",", "endPos", ")", ";", "if", "(", "node", ".", "initializer", ".", "kind", "===", "212", "/* VariableDeclarationList */", ")", "{", "var", "variableDeclarationList", "=", "node", ".", "initializer", ";", "if", "(", "variableDeclarationList", ".", "declarations", ".", "length", ">=", "1", ")", "{", "tryEmitStartOfVariableDeclarationList", "(", "variableDeclarationList", ",", "endPos", ")", ";", "emit", "(", "variableDeclarationList", ".", "declarations", "[", "0", "]", ")", ";", "}", "}", "else", "{", "emit", "(", "node", ".", "initializer", ")", ";", "}", "if", "(", "node", ".", "kind", "===", "200", "/* ForInStatement */", ")", "{", "write", "(", "\" in \"", ")", ";", "}", "else", "{", "write", "(", "\" of \"", ")", ";", "}", "emit", "(", "node", ".", "expression", ")", ";", "emitToken", "(", "18", "/* CloseParenToken */", ",", "node", ".", "expression", ".", "end", ")", ";", "emitEmbeddedStatement", "(", "node", ".", "statement", ")", ";", "}", "function", "emitDownLevelForOfStatement", "(", "node", ")", "{", "// The following ES6 code:", "//", "//    for (let v of expr) { }", "//", "// should be emitted as", "//", "//    for (let _i = 0, _a = expr; _i < _a.length; _i++) {", "//        let v = _a[_i];", "//    }", "//", "// where _a and _i are temps emitted to capture the RHS and the counter,", "// respectively.", "// When the left hand side is an expression instead of a let declaration,", "// the \"let v\" is not emitted.", "// When the left hand side is a let/const, the v is renamed if there is", "// another v in scope.", "// Note that all assignments to the LHS are emitted in the body, including", "// all destructuring.", "// Note also that because an extra statement is needed to assign to the LHS,", "// for-of bodies are always emitted as blocks.", "var", "endPos", "=", "emitToken", "(", "86", "/* ForKeyword */", ",", "node", ".", "pos", ")", ";", "write", "(", "\" \"", ")", ";", "endPos", "=", "emitToken", "(", "17", "/* OpenParenToken */", ",", "endPos", ")", ";", "// Do not emit the LHS let declaration yet, because it might contain destructuring.", "// Do not call recordTempDeclaration because we are declaring the temps", "// right here. Recording means they will be declared later.", "// In the case where the user wrote an identifier as the RHS, like this:", "//", "//     for (let v of arr) { }", "//", "// we don't want to emit a temporary variable for the RHS, just use it directly.", "var", "rhsIsIdentifier", "=", "node", ".", "expression", ".", "kind", "===", "69", "/* Identifier */", ";", "var", "counter", "=", "createTempVariable", "(", "268435456", "/* _i */", ")", ";", "var", "rhsReference", "=", "rhsIsIdentifier", "?", "node", ".", "expression", ":", "createTempVariable", "(", "0", "/* Auto */", ")", ";", "// This is the let keyword for the counter and rhsReference. The let keyword for", "// the LHS will be emitted inside the body.", "emitStart", "(", "node", ".", "expression", ")", ";", "write", "(", "\"var \"", ")", ";", "// _i = 0", "emitNodeWithoutSourceMap", "(", "counter", ")", ";", "write", "(", "\" = 0\"", ")", ";", "emitEnd", "(", "node", ".", "expression", ")", ";", "if", "(", "!", "rhsIsIdentifier", ")", "{", "// , _a = expr", "write", "(", "\", \"", ")", ";", "emitStart", "(", "node", ".", "expression", ")", ";", "emitNodeWithoutSourceMap", "(", "rhsReference", ")", ";", "write", "(", "\" = \"", ")", ";", "emitNodeWithoutSourceMap", "(", "node", ".", "expression", ")", ";", "emitEnd", "(", "node", ".", "expression", ")", ";", "}", "write", "(", "\"; \"", ")", ";", "// _i < _a.length;", "emitStart", "(", "node", ".", "initializer", ")", ";", "emitNodeWithoutSourceMap", "(", "counter", ")", ";", "write", "(", "\" < \"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "rhsReference", ")", ";", "write", "(", "\".length\"", ")", ";", "emitEnd", "(", "node", ".", "initializer", ")", ";", "write", "(", "\"; \"", ")", ";", "// _i++)", "emitStart", "(", "node", ".", "initializer", ")", ";", "emitNodeWithoutSourceMap", "(", "counter", ")", ";", "write", "(", "\"++\"", ")", ";", "emitEnd", "(", "node", ".", "initializer", ")", ";", "emitToken", "(", "18", "/* CloseParenToken */", ",", "node", ".", "expression", ".", "end", ")", ";", "// Body", "write", "(", "\" {\"", ")", ";", "writeLine", "(", ")", ";", "increaseIndent", "(", ")", ";", "// Initialize LHS", "// let v = _a[_i];", "var", "rhsIterationValue", "=", "createElementAccessExpression", "(", "rhsReference", ",", "counter", ")", ";", "emitStart", "(", "node", ".", "initializer", ")", ";", "if", "(", "node", ".", "initializer", ".", "kind", "===", "212", "/* VariableDeclarationList */", ")", "{", "write", "(", "\"var \"", ")", ";", "var", "variableDeclarationList", "=", "node", ".", "initializer", ";", "if", "(", "variableDeclarationList", ".", "declarations", ".", "length", ">", "0", ")", "{", "var", "declaration", "=", "variableDeclarationList", ".", "declarations", "[", "0", "]", ";", "if", "(", "ts", ".", "isBindingPattern", "(", "declaration", ".", "name", ")", ")", "{", "// This works whether the declaration is a var, let, or const.", "// It will use rhsIterationValue _a[_i] as the initializer.", "emitDestructuring", "(", "declaration", ",", "/*isAssignmentExpressionStatement*/", "false", ",", "rhsIterationValue", ")", ";", "}", "else", "{", "// The following call does not include the initializer, so we have", "// to emit it separately.", "emitNodeWithCommentsAndWithoutSourcemap", "(", "declaration", ")", ";", "write", "(", "\" = \"", ")", ";", "emitNodeWithoutSourceMap", "(", "rhsIterationValue", ")", ";", "}", "}", "else", "{", "// It's an empty declaration list. This can only happen in an error case, if the user wrote", "//     for (let of []) {}", "emitNodeWithoutSourceMap", "(", "createTempVariable", "(", "0", "/* Auto */", ")", ")", ";", "write", "(", "\" = \"", ")", ";", "emitNodeWithoutSourceMap", "(", "rhsIterationValue", ")", ";", "}", "}", "else", "{", "// Initializer is an expression. Emit the expression in the body, so that it's", "// evaluated on every iteration.", "var", "assignmentExpression", "=", "createBinaryExpression", "(", "node", ".", "initializer", ",", "56", "/* EqualsToken */", ",", "rhsIterationValue", ",", "/*startsOnNewLine*/", "false", ")", ";", "if", "(", "node", ".", "initializer", ".", "kind", "===", "164", "/* ArrayLiteralExpression */", "||", "node", ".", "initializer", ".", "kind", "===", "165", "/* ObjectLiteralExpression */", ")", "{", "// This is a destructuring pattern, so call emitDestructuring instead of emit. Calling emit will not work, because it will cause", "// the BinaryExpression to be passed in instead of the expression statement, which will cause emitDestructuring to crash.", "emitDestructuring", "(", "assignmentExpression", ",", "/*isAssignmentExpressionStatement*/", "true", ",", "/*value*/", "undefined", ")", ";", "}", "else", "{", "emitNodeWithCommentsAndWithoutSourcemap", "(", "assignmentExpression", ")", ";", "}", "}", "emitEnd", "(", "node", ".", "initializer", ")", ";", "write", "(", "\";\"", ")", ";", "if", "(", "node", ".", "statement", ".", "kind", "===", "192", "/* Block */", ")", "{", "emitLines", "(", "node", ".", "statement", ".", "statements", ")", ";", "}", "else", "{", "writeLine", "(", ")", ";", "emit", "(", "node", ".", "statement", ")", ";", "}", "writeLine", "(", ")", ";", "decreaseIndent", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "}", "function", "emitBreakOrContinueStatement", "(", "node", ")", "{", "emitToken", "(", "node", ".", "kind", "===", "203", "/* BreakStatement */", "?", "70", "/* BreakKeyword */", ":", "75", "/* ContinueKeyword */", ",", "node", ".", "pos", ")", ";", "emitOptional", "(", "\" \"", ",", "node", ".", "label", ")", ";", "write", "(", "\";\"", ")", ";", "}", "function", "emitReturnStatement", "(", "node", ")", "{", "emitToken", "(", "94", "/* ReturnKeyword */", ",", "node", ".", "pos", ")", ";", "emitOptional", "(", "\" \"", ",", "node", ".", "expression", ")", ";", "write", "(", "\";\"", ")", ";", "}", "function", "emitWithStatement", "(", "node", ")", "{", "write", "(", "\"with (\"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\")\"", ")", ";", "emitEmbeddedStatement", "(", "node", ".", "statement", ")", ";", "}", "function", "emitSwitchStatement", "(", "node", ")", "{", "var", "endPos", "=", "emitToken", "(", "96", "/* SwitchKeyword */", ",", "node", ".", "pos", ")", ";", "write", "(", "\" \"", ")", ";", "emitToken", "(", "17", "/* OpenParenToken */", ",", "endPos", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "endPos", "=", "emitToken", "(", "18", "/* CloseParenToken */", ",", "node", ".", "expression", ".", "end", ")", ";", "write", "(", "\" \"", ")", ";", "emitCaseBlock", "(", "node", ".", "caseBlock", ",", "endPos", ")", ";", "}", "function", "emitCaseBlock", "(", "node", ",", "startPos", ")", "{", "emitToken", "(", "15", "/* OpenBraceToken */", ",", "startPos", ")", ";", "increaseIndent", "(", ")", ";", "emitLines", "(", "node", ".", "clauses", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "node", ".", "clauses", ".", "end", ")", ";", "}", "function", "nodeStartPositionsAreOnSameLine", "(", "node1", ",", "node2", ")", "{", "return", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "ts", ".", "skipTrivia", "(", "currentSourceFile", ".", "text", ",", "node1", ".", "pos", ")", ")", "===", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "ts", ".", "skipTrivia", "(", "currentSourceFile", ".", "text", ",", "node2", ".", "pos", ")", ")", ";", "}", "function", "nodeEndPositionsAreOnSameLine", "(", "node1", ",", "node2", ")", "{", "return", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "node1", ".", "end", ")", "===", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "node2", ".", "end", ")", ";", "}", "function", "nodeEndIsOnSameLineAsNodeStart", "(", "node1", ",", "node2", ")", "{", "return", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "node1", ".", "end", ")", "===", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "ts", ".", "skipTrivia", "(", "currentSourceFile", ".", "text", ",", "node2", ".", "pos", ")", ")", ";", "}", "function", "emitCaseOrDefaultClause", "(", "node", ")", "{", "if", "(", "node", ".", "kind", "===", "241", "/* CaseClause */", ")", "{", "write", "(", "\"case \"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\":\"", ")", ";", "}", "else", "{", "write", "(", "\"default:\"", ")", ";", "}", "if", "(", "node", ".", "statements", ".", "length", "===", "1", "&&", "nodeStartPositionsAreOnSameLine", "(", "node", ",", "node", ".", "statements", "[", "0", "]", ")", ")", "{", "write", "(", "\" \"", ")", ";", "emit", "(", "node", ".", "statements", "[", "0", "]", ")", ";", "}", "else", "{", "increaseIndent", "(", ")", ";", "emitLines", "(", "node", ".", "statements", ")", ";", "decreaseIndent", "(", ")", ";", "}", "}", "function", "emitThrowStatement", "(", "node", ")", "{", "write", "(", "\"throw \"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\";\"", ")", ";", "}", "function", "emitTryStatement", "(", "node", ")", "{", "write", "(", "\"try \"", ")", ";", "emit", "(", "node", ".", "tryBlock", ")", ";", "emit", "(", "node", ".", "catchClause", ")", ";", "if", "(", "node", ".", "finallyBlock", ")", "{", "writeLine", "(", ")", ";", "write", "(", "\"finally \"", ")", ";", "emit", "(", "node", ".", "finallyBlock", ")", ";", "}", "}", "function", "emitCatchClause", "(", "node", ")", "{", "writeLine", "(", ")", ";", "var", "endPos", "=", "emitToken", "(", "72", "/* CatchKeyword */", ",", "node", ".", "pos", ")", ";", "write", "(", "\" \"", ")", ";", "emitToken", "(", "17", "/* OpenParenToken */", ",", "endPos", ")", ";", "emit", "(", "node", ".", "variableDeclaration", ")", ";", "emitToken", "(", "18", "/* CloseParenToken */", ",", "node", ".", "variableDeclaration", "?", "node", ".", "variableDeclaration", ".", "end", ":", "endPos", ")", ";", "write", "(", "\" \"", ")", ";", "emitBlock", "(", "node", ".", "block", ")", ";", "}", "function", "emitDebuggerStatement", "(", "node", ")", "{", "emitToken", "(", "76", "/* DebuggerKeyword */", ",", "node", ".", "pos", ")", ";", "write", "(", "\";\"", ")", ";", "}", "function", "emitLabelledStatement", "(", "node", ")", "{", "emit", "(", "node", ".", "label", ")", ";", "write", "(", "\": \"", ")", ";", "emit", "(", "node", ".", "statement", ")", ";", "}", "function", "getContainingModule", "(", "node", ")", "{", "do", "{", "node", "=", "node", ".", "parent", ";", "}", "while", "(", "node", "&&", "node", ".", "kind", "!==", "218", "/* ModuleDeclaration */", ")", ";", "return", "node", ";", "}", "function", "emitContainingModuleName", "(", "node", ")", "{", "var", "container", "=", "getContainingModule", "(", "node", ")", ";", "write", "(", "container", "?", "getGeneratedNameForNode", "(", "container", ")", ":", "\"exports\"", ")", ";", "}", "function", "emitModuleMemberName", "(", "node", ")", "{", "emitStart", "(", "node", ".", "name", ")", ";", "if", "(", "ts", ".", "getCombinedNodeFlags", "(", "node", ")", "&", "1", "/* Export */", ")", "{", "var", "container", "=", "getContainingModule", "(", "node", ")", ";", "if", "(", "container", ")", "{", "write", "(", "getGeneratedNameForNode", "(", "container", ")", ")", ";", "write", "(", "\".\"", ")", ";", "}", "else", "if", "(", "modulekind", "!==", "5", "/* ES6 */", "&&", "modulekind", "!==", "4", "/* System */", ")", "{", "write", "(", "\"exports.\"", ")", ";", "}", "}", "emitNodeWithCommentsAndWithoutSourcemap", "(", "node", ".", "name", ")", ";", "emitEnd", "(", "node", ".", "name", ")", ";", "}", "function", "createVoidZero", "(", ")", "{", "var", "zero", "=", "ts", ".", "createSynthesizedNode", "(", "8", "/* NumericLiteral */", ")", ";", "zero", ".", "text", "=", "\"0\"", ";", "var", "result", "=", "ts", ".", "createSynthesizedNode", "(", "177", "/* VoidExpression */", ")", ";", "result", ".", "expression", "=", "zero", ";", "return", "result", ";", "}", "function", "emitEs6ExportDefaultCompat", "(", "node", ")", "{", "if", "(", "node", ".", "parent", ".", "kind", "===", "248", "/* SourceFile */", ")", "{", "ts", ".", "Debug", ".", "assert", "(", "!", "!", "(", "node", ".", "flags", "&", "1024", "/* Default */", ")", "||", "node", ".", "kind", "===", "227", "/* ExportAssignment */", ")", ";", "// only allow export default at a source file level", "if", "(", "modulekind", "===", "1", "/* CommonJS */", "||", "modulekind", "===", "2", "/* AMD */", "||", "modulekind", "===", "3", "/* UMD */", ")", "{", "if", "(", "!", "currentSourceFile", ".", "symbol", ".", "exports", "[", "\"___esModule\"", "]", ")", "{", "if", "(", "languageVersion", "===", "1", "/* ES5 */", ")", "{", "// default value of configurable, enumerable, writable are `false`.", "write", "(", "\"Object.defineProperty(exports, \\\"__esModule\\\", { value: true });\"", ")", ";", "writeLine", "(", ")", ";", "}", "else", "if", "(", "languageVersion", "===", "0", "/* ES3 */", ")", "{", "write", "(", "\"exports.__esModule = true;\"", ")", ";", "writeLine", "(", ")", ";", "}", "}", "}", "}", "}", "function", "emitExportMemberAssignment", "(", "node", ")", "{", "if", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "node", ")", ";", "// emit call to exporter only for top level nodes", "if", "(", "modulekind", "===", "4", "/* System */", "&&", "node", ".", "parent", "===", "currentSourceFile", ")", "{", "// emit export default <smth> as", "// export(\"default\", <smth>)", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "if", "(", "node", ".", "flags", "&", "1024", "/* Default */", ")", "{", "write", "(", "\"default\"", ")", ";", "}", "else", "{", "emitNodeWithCommentsAndWithoutSourcemap", "(", "node", ".", "name", ")", ";", "}", "write", "(", "\"\\\", \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\")\"", ")", ";", "}", "else", "{", "if", "(", "node", ".", "flags", "&", "1024", "/* Default */", ")", "{", "emitEs6ExportDefaultCompat", "(", "node", ")", ";", "if", "(", "languageVersion", "===", "0", "/* ES3 */", ")", "{", "write", "(", "\"exports[\\\"default\\\"]\"", ")", ";", "}", "else", "{", "write", "(", "\"exports.default\"", ")", ";", "}", "}", "else", "{", "emitModuleMemberName", "(", "node", ")", ";", "}", "write", "(", "\" = \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "}", "emitEnd", "(", "node", ")", ";", "write", "(", "\";\"", ")", ";", "}", "}", "function", "emitExportMemberAssignments", "(", "name", ")", "{", "if", "(", "modulekind", "===", "4", "/* System */", ")", "{", "return", ";", "}", "if", "(", "!", "exportEquals", "&&", "exportSpecifiers", "&&", "ts", ".", "hasProperty", "(", "exportSpecifiers", ",", "name", ".", "text", ")", ")", "{", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "exportSpecifiers", "[", "name", ".", "text", "]", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "specifier", "=", "_b", "[", "_a", "]", ";", "writeLine", "(", ")", ";", "emitStart", "(", "specifier", ".", "name", ")", ";", "emitContainingModuleName", "(", "specifier", ")", ";", "write", "(", "\".\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "specifier", ".", "name", ")", ";", "emitEnd", "(", "specifier", ".", "name", ")", ";", "write", "(", "\" = \"", ")", ";", "emitExpressionIdentifier", "(", "name", ")", ";", "write", "(", "\";\"", ")", ";", "}", "}", "}", "function", "emitExportSpecifierInSystemModule", "(", "specifier", ")", "{", "ts", ".", "Debug", ".", "assert", "(", "modulekind", "===", "4", "/* System */", ")", ";", "if", "(", "!", "resolver", ".", "getReferencedValueDeclaration", "(", "specifier", ".", "propertyName", "||", "specifier", ".", "name", ")", "&&", "!", "resolver", ".", "isValueAliasDeclaration", "(", "specifier", ")", ")", "{", "return", ";", "}", "writeLine", "(", ")", ";", "emitStart", "(", "specifier", ".", "name", ")", ";", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "specifier", ".", "name", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "emitExpressionIdentifier", "(", "specifier", ".", "propertyName", "||", "specifier", ".", "name", ")", ";", "write", "(", "\")\"", ")", ";", "emitEnd", "(", "specifier", ".", "name", ")", ";", "write", "(", "\";\"", ")", ";", "}", "/**\n             * Emit an assignment to a given identifier, 'name', with a given expression, 'value'.\n             * @param name an identifier as a left-hand-side operand of the assignment\n             * @param value an expression as a right-hand-side operand of the assignment\n             * @param shouldEmitCommaBeforeAssignment a boolean indicating whether to prefix an assignment with comma\n             */", "function", "emitAssignment", "(", "name", ",", "value", ",", "shouldEmitCommaBeforeAssignment", ")", "{", "if", "(", "shouldEmitCommaBeforeAssignment", ")", "{", "write", "(", "\", \"", ")", ";", "}", "var", "exportChanged", "=", "isNameOfExportedSourceLevelDeclarationInSystemExternalModule", "(", "name", ")", ";", "if", "(", "exportChanged", ")", "{", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "name", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "}", "var", "isVariableDeclarationOrBindingElement", "=", "name", ".", "parent", "&&", "(", "name", ".", "parent", ".", "kind", "===", "211", "/* VariableDeclaration */", "||", "name", ".", "parent", ".", "kind", "===", "163", "/* BindingElement */", ")", ";", "if", "(", "isVariableDeclarationOrBindingElement", ")", "{", "emitModuleMemberName", "(", "name", ".", "parent", ")", ";", "}", "else", "{", "emit", "(", "name", ")", ";", "}", "write", "(", "\" = \"", ")", ";", "emit", "(", "value", ")", ";", "if", "(", "exportChanged", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "/**\n             * Create temporary variable, emit an assignment of the variable the given expression\n             * @param expression an expression to assign to the newly created temporary variable\n             * @param canDefineTempVariablesInPlace a boolean indicating whether you can define the temporary variable at an assignment location\n             * @param shouldEmitCommaBeforeAssignment a boolean indicating whether an assignment should prefix with comma\n             */", "function", "emitTempVariableAssignment", "(", "expression", ",", "canDefineTempVariablesInPlace", ",", "shouldEmitCommaBeforeAssignment", ")", "{", "var", "identifier", "=", "createTempVariable", "(", "0", "/* Auto */", ")", ";", "if", "(", "!", "canDefineTempVariablesInPlace", ")", "{", "recordTempDeclaration", "(", "identifier", ")", ";", "}", "emitAssignment", "(", "identifier", ",", "expression", ",", "shouldEmitCommaBeforeAssignment", ")", ";", "return", "identifier", ";", "}", "function", "emitDestructuring", "(", "root", ",", "isAssignmentExpressionStatement", ",", "value", ")", "{", "var", "emitCount", "=", "0", ";", "// An exported declaration is actually emitted as an assignment (to a property on the module object), so", "// temporary variables in an exported declaration need to have real declarations elsewhere", "// Also temporary variables should be explicitly allocated for source level declarations when module target is system", "// because actual variable declarations are hoisted", "var", "canDefineTempVariablesInPlace", "=", "false", ";", "if", "(", "root", ".", "kind", "===", "211", "/* VariableDeclaration */", ")", "{", "var", "isExported", "=", "ts", ".", "getCombinedNodeFlags", "(", "root", ")", "&", "1", "/* Export */", ";", "var", "isSourceLevelForSystemModuleKind", "=", "shouldHoistDeclarationInSystemJsModule", "(", "root", ")", ";", "canDefineTempVariablesInPlace", "=", "!", "isExported", "&&", "!", "isSourceLevelForSystemModuleKind", ";", "}", "else", "if", "(", "root", ".", "kind", "===", "138", "/* Parameter */", ")", "{", "canDefineTempVariablesInPlace", "=", "true", ";", "}", "if", "(", "root", ".", "kind", "===", "181", "/* BinaryExpression */", ")", "{", "emitAssignmentExpression", "(", "root", ")", ";", "}", "else", "{", "ts", ".", "Debug", ".", "assert", "(", "!", "isAssignmentExpressionStatement", ")", ";", "emitBindingElement", "(", "root", ",", "value", ")", ";", "}", "/**\n                 * Ensures that there exists a declared identifier whose value holds the given expression.\n                 * This function is useful to ensure that the expression's value can be read from in subsequent expressions.\n                 * Unless 'reuseIdentifierExpressions' is false, 'expr' will be returned if it is just an identifier.\n                 *\n                 * @param expr the expression whose value needs to be bound.\n                 * @param reuseIdentifierExpressions true if identifier expressions can simply be returned;\n                 *                                   false if it is necessary to always emit an identifier.\n                 */", "function", "ensureIdentifier", "(", "expr", ",", "reuseIdentifierExpressions", ")", "{", "if", "(", "expr", ".", "kind", "===", "69", "/* Identifier */", "&&", "reuseIdentifierExpressions", ")", "{", "return", "expr", ";", "}", "var", "identifier", "=", "emitTempVariableAssignment", "(", "expr", ",", "canDefineTempVariablesInPlace", ",", "emitCount", ">", "0", ")", ";", "emitCount", "++", ";", "return", "identifier", ";", "}", "function", "createDefaultValueCheck", "(", "value", ",", "defaultValue", ")", "{", "// The value expression will be evaluated twice, so for anything but a simple identifier", "// we need to generate a temporary variable", "value", "=", "ensureIdentifier", "(", "value", ",", "/*reuseIdentifierExpressions*/", "true", ")", ";", "// Return the expression 'value === void 0 ? defaultValue : value'", "var", "equals", "=", "ts", ".", "createSynthesizedNode", "(", "181", "/* BinaryExpression */", ")", ";", "equals", ".", "left", "=", "value", ";", "equals", ".", "operatorToken", "=", "ts", ".", "createSynthesizedNode", "(", "32", "/* EqualsEqualsEqualsToken */", ")", ";", "equals", ".", "right", "=", "createVoidZero", "(", ")", ";", "return", "createConditionalExpression", "(", "equals", ",", "defaultValue", ",", "value", ")", ";", "}", "function", "createConditionalExpression", "(", "condition", ",", "whenTrue", ",", "whenFalse", ")", "{", "var", "cond", "=", "ts", ".", "createSynthesizedNode", "(", "182", "/* ConditionalExpression */", ")", ";", "cond", ".", "condition", "=", "condition", ";", "cond", ".", "questionToken", "=", "ts", ".", "createSynthesizedNode", "(", "53", "/* QuestionToken */", ")", ";", "cond", ".", "whenTrue", "=", "whenTrue", ";", "cond", ".", "colonToken", "=", "ts", ".", "createSynthesizedNode", "(", "54", "/* ColonToken */", ")", ";", "cond", ".", "whenFalse", "=", "whenFalse", ";", "return", "cond", ";", "}", "function", "createNumericLiteral", "(", "value", ")", "{", "var", "node", "=", "ts", ".", "createSynthesizedNode", "(", "8", "/* NumericLiteral */", ")", ";", "node", ".", "text", "=", "\"\"", "+", "value", ";", "return", "node", ";", "}", "function", "createPropertyAccessForDestructuringProperty", "(", "object", ",", "propName", ")", "{", "// We create a synthetic copy of the identifier in order to avoid the rewriting that might", "// otherwise occur when the identifier is emitted.", "var", "syntheticName", "=", "ts", ".", "createSynthesizedNode", "(", "propName", ".", "kind", ")", ";", "syntheticName", ".", "text", "=", "propName", ".", "text", ";", "if", "(", "syntheticName", ".", "kind", "!==", "69", "/* Identifier */", ")", "{", "return", "createElementAccessExpression", "(", "object", ",", "syntheticName", ")", ";", "}", "return", "createPropertyAccessExpression", "(", "object", ",", "syntheticName", ")", ";", "}", "function", "createSliceCall", "(", "value", ",", "sliceIndex", ")", "{", "var", "call", "=", "ts", ".", "createSynthesizedNode", "(", "168", "/* CallExpression */", ")", ";", "var", "sliceIdentifier", "=", "ts", ".", "createSynthesizedNode", "(", "69", "/* Identifier */", ")", ";", "sliceIdentifier", ".", "text", "=", "\"slice\"", ";", "call", ".", "expression", "=", "createPropertyAccessExpression", "(", "value", ",", "sliceIdentifier", ")", ";", "call", ".", "arguments", "=", "ts", ".", "createSynthesizedNodeArray", "(", ")", ";", "call", ".", "arguments", "[", "0", "]", "=", "createNumericLiteral", "(", "sliceIndex", ")", ";", "return", "call", ";", "}", "function", "emitObjectLiteralAssignment", "(", "target", ",", "value", ")", "{", "var", "properties", "=", "target", ".", "properties", ";", "if", "(", "properties", ".", "length", "!==", "1", ")", "{", "// For anything but a single element destructuring we need to generate a temporary", "// to ensure value is evaluated exactly once.", "value", "=", "ensureIdentifier", "(", "value", ",", "/*reuseIdentifierExpressions*/", "true", ")", ";", "}", "for", "(", "var", "_a", "=", "0", ";", "_a", "<", "properties", ".", "length", ";", "_a", "++", ")", "{", "var", "p", "=", "properties", "[", "_a", "]", ";", "if", "(", "p", ".", "kind", "===", "245", "/* PropertyAssignment */", "||", "p", ".", "kind", "===", "246", "/* ShorthandPropertyAssignment */", ")", "{", "var", "propName", "=", "p", ".", "name", ";", "var", "target_1", "=", "p", ".", "kind", "===", "246", "/* ShorthandPropertyAssignment */", "?", "p", ":", "p", ".", "initializer", "||", "propName", ";", "emitDestructuringAssignment", "(", "target_1", ",", "createPropertyAccessForDestructuringProperty", "(", "value", ",", "propName", ")", ")", ";", "}", "}", "}", "function", "emitArrayLiteralAssignment", "(", "target", ",", "value", ")", "{", "var", "elements", "=", "target", ".", "elements", ";", "if", "(", "elements", ".", "length", "!==", "1", ")", "{", "// For anything but a single element destructuring we need to generate a temporary", "// to ensure value is evaluated exactly once.", "value", "=", "ensureIdentifier", "(", "value", ",", "/*reuseIdentifierExpressions*/", "true", ")", ";", "}", "for", "(", "var", "i", "=", "0", ";", "i", "<", "elements", ".", "length", ";", "i", "++", ")", "{", "var", "e", "=", "elements", "[", "i", "]", ";", "if", "(", "e", ".", "kind", "!==", "187", "/* OmittedExpression */", ")", "{", "if", "(", "e", ".", "kind", "!==", "185", "/* SpreadElementExpression */", ")", "{", "emitDestructuringAssignment", "(", "e", ",", "createElementAccessExpression", "(", "value", ",", "createNumericLiteral", "(", "i", ")", ")", ")", ";", "}", "else", "if", "(", "i", "===", "elements", ".", "length", "-", "1", ")", "{", "emitDestructuringAssignment", "(", "e", ".", "expression", ",", "createSliceCall", "(", "value", ",", "i", ")", ")", ";", "}", "}", "}", "}", "function", "emitDestructuringAssignment", "(", "target", ",", "value", ")", "{", "if", "(", "target", ".", "kind", "===", "246", "/* ShorthandPropertyAssignment */", ")", "{", "if", "(", "target", ".", "objectAssignmentInitializer", ")", "{", "value", "=", "createDefaultValueCheck", "(", "value", ",", "target", ".", "objectAssignmentInitializer", ")", ";", "}", "target", "=", "target", ".", "name", ";", "}", "else", "if", "(", "target", ".", "kind", "===", "181", "/* BinaryExpression */", "&&", "target", ".", "operatorToken", ".", "kind", "===", "56", "/* EqualsToken */", ")", "{", "value", "=", "createDefaultValueCheck", "(", "value", ",", "target", ".", "right", ")", ";", "target", "=", "target", ".", "left", ";", "}", "if", "(", "target", ".", "kind", "===", "165", "/* ObjectLiteralExpression */", ")", "{", "emitObjectLiteralAssignment", "(", "target", ",", "value", ")", ";", "}", "else", "if", "(", "target", ".", "kind", "===", "164", "/* ArrayLiteralExpression */", ")", "{", "emitArrayLiteralAssignment", "(", "target", ",", "value", ")", ";", "}", "else", "{", "emitAssignment", "(", "target", ",", "value", ",", "/*shouldEmitCommaBeforeAssignment*/", "emitCount", ">", "0", ")", ";", "emitCount", "++", ";", "}", "}", "function", "emitAssignmentExpression", "(", "root", ")", "{", "var", "target", "=", "root", ".", "left", ";", "var", "value", "=", "root", ".", "right", ";", "if", "(", "ts", ".", "isEmptyObjectLiteralOrArrayLiteral", "(", "target", ")", ")", "{", "emit", "(", "value", ")", ";", "}", "else", "if", "(", "isAssignmentExpressionStatement", ")", "{", "emitDestructuringAssignment", "(", "target", ",", "value", ")", ";", "}", "else", "{", "if", "(", "root", ".", "parent", ".", "kind", "!==", "172", "/* ParenthesizedExpression */", ")", "{", "write", "(", "\"(\"", ")", ";", "}", "value", "=", "ensureIdentifier", "(", "value", ",", "/*reuseIdentifierExpressions*/", "true", ")", ";", "emitDestructuringAssignment", "(", "target", ",", "value", ")", ";", "write", "(", "\", \"", ")", ";", "emit", "(", "value", ")", ";", "if", "(", "root", ".", "parent", ".", "kind", "!==", "172", "/* ParenthesizedExpression */", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "}", "function", "emitBindingElement", "(", "target", ",", "value", ")", "{", "if", "(", "target", ".", "initializer", ")", "{", "// Combine value and initializer", "value", "=", "value", "?", "createDefaultValueCheck", "(", "value", ",", "target", ".", "initializer", ")", ":", "target", ".", "initializer", ";", "}", "else", "if", "(", "!", "value", ")", "{", "// Use 'void 0' in absence of value and initializer", "value", "=", "createVoidZero", "(", ")", ";", "}", "if", "(", "ts", ".", "isBindingPattern", "(", "target", ".", "name", ")", ")", "{", "var", "pattern", "=", "target", ".", "name", ";", "var", "elements", "=", "pattern", ".", "elements", ";", "var", "numElements", "=", "elements", ".", "length", ";", "if", "(", "numElements", "!==", "1", ")", "{", "// For anything other than a single-element destructuring we need to generate a temporary", "// to ensure value is evaluated exactly once. Additionally, if we have zero elements", "// we need to emit *something* to ensure that in case a 'var' keyword was already emitted,", "// so in that case, we'll intentionally create that temporary.", "value", "=", "ensureIdentifier", "(", "value", ",", "/*reuseIdentifierExpressions*/", "numElements", "!==", "0", ")", ";", "}", "for", "(", "var", "i", "=", "0", ";", "i", "<", "numElements", ";", "i", "++", ")", "{", "var", "element", "=", "elements", "[", "i", "]", ";", "if", "(", "pattern", ".", "kind", "===", "161", "/* ObjectBindingPattern */", ")", "{", "// Rewrite element to a declaration with an initializer that fetches property", "var", "propName", "=", "element", ".", "propertyName", "||", "element", ".", "name", ";", "emitBindingElement", "(", "element", ",", "createPropertyAccessForDestructuringProperty", "(", "value", ",", "propName", ")", ")", ";", "}", "else", "if", "(", "element", ".", "kind", "!==", "187", "/* OmittedExpression */", ")", "{", "if", "(", "!", "element", ".", "dotDotDotToken", ")", "{", "// Rewrite element to a declaration that accesses array element at index i", "emitBindingElement", "(", "element", ",", "createElementAccessExpression", "(", "value", ",", "createNumericLiteral", "(", "i", ")", ")", ")", ";", "}", "else", "if", "(", "i", "===", "numElements", "-", "1", ")", "{", "emitBindingElement", "(", "element", ",", "createSliceCall", "(", "value", ",", "i", ")", ")", ";", "}", "}", "}", "}", "else", "{", "emitAssignment", "(", "target", ".", "name", ",", "value", ",", "/*shouldEmitCommaBeforeAssignment*/", "emitCount", ">", "0", ")", ";", "emitCount", "++", ";", "}", "}", "}", "function", "emitVariableDeclaration", "(", "node", ")", "{", "if", "(", "ts", ".", "isBindingPattern", "(", "node", ".", "name", ")", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "emitDestructuring", "(", "node", ",", "/*isAssignmentExpressionStatement*/", "false", ")", ";", "}", "else", "{", "emit", "(", "node", ".", "name", ")", ";", "emitOptional", "(", "\" = \"", ",", "node", ".", "initializer", ")", ";", "}", "}", "else", "{", "var", "initializer", "=", "node", ".", "initializer", ";", "if", "(", "!", "initializer", "&&", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "// downlevel emit for non-initialized let bindings defined in loops", "// for (...) {  let x; }", "// should be", "// for (...) { var <some-uniqie-name> = void 0; }", "// this is necessary to preserve ES6 semantic in scenarios like", "// for (...) { let x; console.log(x); x = 1 } // assignment on one iteration should not affect other iterations", "var", "isUninitializedLet", "=", "(", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "16384", "/* BlockScopedBindingInLoop */", ")", "&&", "(", "getCombinedFlagsForIdentifier", "(", "node", ".", "name", ")", "&", "16384", "/* Let */", ")", ";", "// NOTE: default initialization should not be added to let bindings in for-in\\for-of statements", "if", "(", "isUninitializedLet", "&&", "node", ".", "parent", ".", "parent", ".", "kind", "!==", "200", "/* ForInStatement */", "&&", "node", ".", "parent", ".", "parent", ".", "kind", "!==", "201", "/* ForOfStatement */", ")", "{", "initializer", "=", "createVoidZero", "(", ")", ";", "}", "}", "var", "exportChanged", "=", "isNameOfExportedSourceLevelDeclarationInSystemExternalModule", "(", "node", ".", "name", ")", ";", "if", "(", "exportChanged", ")", "{", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "node", ".", "name", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "}", "emitModuleMemberName", "(", "node", ")", ";", "emitOptional", "(", "\" = \"", ",", "initializer", ")", ";", "if", "(", "exportChanged", ")", "{", "write", "(", "\")\"", ")", ";", "}", "}", "}", "function", "emitExportVariableAssignments", "(", "node", ")", "{", "if", "(", "node", ".", "kind", "===", "187", "/* OmittedExpression */", ")", "{", "return", ";", "}", "var", "name", "=", "node", ".", "name", ";", "if", "(", "name", ".", "kind", "===", "69", "/* Identifier */", ")", "{", "emitExportMemberAssignments", "(", "name", ")", ";", "}", "else", "if", "(", "ts", ".", "isBindingPattern", "(", "name", ")", ")", "{", "ts", ".", "forEach", "(", "name", ".", "elements", ",", "emitExportVariableAssignments", ")", ";", "}", "}", "function", "getCombinedFlagsForIdentifier", "(", "node", ")", "{", "if", "(", "!", "node", ".", "parent", "||", "(", "node", ".", "parent", ".", "kind", "!==", "211", "/* VariableDeclaration */", "&&", "node", ".", "parent", ".", "kind", "!==", "163", "/* BindingElement */", ")", ")", "{", "return", "0", ";", "}", "return", "ts", ".", "getCombinedNodeFlags", "(", "node", ".", "parent", ")", ";", "}", "function", "isES6ExportedDeclaration", "(", "node", ")", "{", "return", "!", "!", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", "&&", "modulekind", "===", "5", "/* ES6 */", "&&", "node", ".", "parent", ".", "kind", "===", "248", "/* SourceFile */", ";", "}", "function", "emitVariableStatement", "(", "node", ")", "{", "var", "startIsEmitted", "=", "false", ";", "if", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", "{", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "// Exported ES6 module member", "write", "(", "\"export \"", ")", ";", "startIsEmitted", "=", "tryEmitStartOfVariableDeclarationList", "(", "node", ".", "declarationList", ")", ";", "}", "}", "else", "{", "startIsEmitted", "=", "tryEmitStartOfVariableDeclarationList", "(", "node", ".", "declarationList", ")", ";", "}", "if", "(", "startIsEmitted", ")", "{", "emitCommaList", "(", "node", ".", "declarationList", ".", "declarations", ")", ";", "write", "(", "\";\"", ")", ";", "}", "else", "{", "var", "atLeastOneItem", "=", "emitVariableDeclarationListSkippingUninitializedEntries", "(", "node", ".", "declarationList", ")", ";", "if", "(", "atLeastOneItem", ")", "{", "write", "(", "\";\"", ")", ";", "}", "}", "if", "(", "modulekind", "!==", "5", "/* ES6 */", "&&", "node", ".", "parent", "===", "currentSourceFile", ")", "{", "ts", ".", "forEach", "(", "node", ".", "declarationList", ".", "declarations", ",", "emitExportVariableAssignments", ")", ";", "}", "}", "function", "shouldEmitLeadingAndTrailingCommentsForVariableStatement", "(", "node", ")", "{", "// If we're not exporting the variables, there's nothing special here.", "// Always emit comments for these nodes.", "if", "(", "!", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", ")", "{", "return", "true", ";", "}", "// If we are exporting, but it's a top-level ES6 module exports,", "// we'll emit the declaration list verbatim, so emit comments too.", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "return", "true", ";", "}", "// Otherwise, only emit if we have at least one initializer present.", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "node", ".", "declarationList", ".", "declarations", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "declaration", "=", "_b", "[", "_a", "]", ";", "if", "(", "declaration", ".", "initializer", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}", "function", "emitParameter", "(", "node", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "if", "(", "ts", ".", "isBindingPattern", "(", "node", ".", "name", ")", ")", "{", "var", "name_24", "=", "createTempVariable", "(", "0", "/* Auto */", ")", ";", "if", "(", "!", "tempParameters", ")", "{", "tempParameters", "=", "[", "]", ";", "}", "tempParameters", ".", "push", "(", "name_24", ")", ";", "emit", "(", "name_24", ")", ";", "}", "else", "{", "emit", "(", "node", ".", "name", ")", ";", "}", "}", "else", "{", "if", "(", "node", ".", "dotDotDotToken", ")", "{", "write", "(", "\"...\"", ")", ";", "}", "emit", "(", "node", ".", "name", ")", ";", "emitOptional", "(", "\" = \"", ",", "node", ".", "initializer", ")", ";", "}", "}", "function", "emitDefaultValueAssignments", "(", "node", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "var", "tempIndex", "=", "0", ";", "ts", ".", "forEach", "(", "node", ".", "parameters", ",", "function", "(", "parameter", ")", "{", "// A rest parameter cannot have a binding pattern or an initializer,", "// so let's just ignore it.", "if", "(", "parameter", ".", "dotDotDotToken", ")", "{", "return", ";", "}", "var", "paramName", "=", "parameter", ".", "name", ",", "initializer", "=", "parameter", ".", "initializer", ";", "if", "(", "ts", ".", "isBindingPattern", "(", "paramName", ")", ")", "{", "// In cases where a binding pattern is simply '[]' or '{}',", "// we usually don't want to emit a var declaration; however, in the presence", "// of an initializer, we must emit that expression to preserve side effects.", "var", "hasBindingElements", "=", "paramName", ".", "elements", ".", "length", ">", "0", ";", "if", "(", "hasBindingElements", "||", "initializer", ")", "{", "writeLine", "(", ")", ";", "write", "(", "\"var \"", ")", ";", "if", "(", "hasBindingElements", ")", "{", "emitDestructuring", "(", "parameter", ",", "/*isAssignmentExpressionStatement*/", "false", ",", "tempParameters", "[", "tempIndex", "]", ")", ";", "}", "else", "{", "emit", "(", "tempParameters", "[", "tempIndex", "]", ")", ";", "write", "(", "\" = \"", ")", ";", "emit", "(", "initializer", ")", ";", "}", "write", "(", "\";\"", ")", ";", "tempIndex", "++", ";", "}", "}", "else", "if", "(", "initializer", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "parameter", ")", ";", "write", "(", "\"if (\"", ")", ";", "emitNodeWithoutSourceMap", "(", "paramName", ")", ";", "write", "(", "\" === void 0)\"", ")", ";", "emitEnd", "(", "parameter", ")", ";", "write", "(", "\" { \"", ")", ";", "emitStart", "(", "parameter", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "paramName", ")", ";", "write", "(", "\" = \"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "initializer", ")", ";", "emitEnd", "(", "parameter", ")", ";", "write", "(", "\"; }\"", ")", ";", "}", "}", ")", ";", "}", "}", "function", "emitRestParameter", "(", "node", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", "&&", "ts", ".", "hasRestParameter", "(", "node", ")", ")", "{", "var", "restIndex", "=", "node", ".", "parameters", ".", "length", "-", "1", ";", "var", "restParam", "=", "node", ".", "parameters", "[", "restIndex", "]", ";", "// A rest parameter cannot have a binding pattern, so let's just ignore it if it does.", "if", "(", "ts", ".", "isBindingPattern", "(", "restParam", ".", "name", ")", ")", "{", "return", ";", "}", "var", "tempName", "=", "createTempVariable", "(", "268435456", "/* _i */", ")", ".", "text", ";", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "restParam", ")", ";", "emitStart", "(", "restParam", ")", ";", "write", "(", "\"var \"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "restParam", ".", "name", ")", ";", "write", "(", "\" = [];\"", ")", ";", "emitEnd", "(", "restParam", ")", ";", "emitTrailingComments", "(", "restParam", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"for (\"", ")", ";", "emitStart", "(", "restParam", ")", ";", "write", "(", "\"var \"", "+", "tempName", "+", "\" = \"", "+", "restIndex", "+", "\";\"", ")", ";", "emitEnd", "(", "restParam", ")", ";", "write", "(", "\" \"", ")", ";", "emitStart", "(", "restParam", ")", ";", "write", "(", "tempName", "+", "\" < arguments.length;\"", ")", ";", "emitEnd", "(", "restParam", ")", ";", "write", "(", "\" \"", ")", ";", "emitStart", "(", "restParam", ")", ";", "write", "(", "tempName", "+", "\"++\"", ")", ";", "emitEnd", "(", "restParam", ")", ";", "write", "(", "\") {\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emitStart", "(", "restParam", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "restParam", ".", "name", ")", ";", "write", "(", "\"[\"", "+", "tempName", "+", "\" - \"", "+", "restIndex", "+", "\"] = arguments[\"", "+", "tempName", "+", "\"];\"", ")", ";", "emitEnd", "(", "restParam", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "}", "}", "function", "emitAccessor", "(", "node", ")", "{", "write", "(", "node", ".", "kind", "===", "145", "/* GetAccessor */", "?", "\"get \"", ":", "\"set \"", ")", ";", "emit", "(", "node", ".", "name", ")", ";", "emitSignatureAndBody", "(", "node", ")", ";", "}", "function", "shouldEmitAsArrowFunction", "(", "node", ")", "{", "return", "node", ".", "kind", "===", "174", "/* ArrowFunction */", "&&", "languageVersion", ">=", "2", "/* ES6 */", ";", "}", "function", "emitDeclarationName", "(", "node", ")", "{", "if", "(", "node", ".", "name", ")", "{", "emitNodeWithCommentsAndWithoutSourcemap", "(", "node", ".", "name", ")", ";", "}", "else", "{", "write", "(", "getGeneratedNameForNode", "(", "node", ")", ")", ";", "}", "}", "function", "shouldEmitFunctionName", "(", "node", ")", "{", "if", "(", "node", ".", "kind", "===", "173", "/* FunctionExpression */", ")", "{", "// Emit name if one is present", "return", "!", "!", "node", ".", "name", ";", "}", "if", "(", "node", ".", "kind", "===", "213", "/* FunctionDeclaration */", ")", "{", "// Emit name if one is present, or emit generated name in down-level case (for export default case)", "return", "!", "!", "node", ".", "name", "||", "languageVersion", "<", "2", "/* ES6 */", ";", "}", "}", "function", "emitFunctionDeclaration", "(", "node", ")", "{", "if", "(", "ts", ".", "nodeIsMissing", "(", "node", ".", "body", ")", ")", "{", "return", "emitCommentsOnNotEmittedNode", "(", "node", ")", ";", "}", "// TODO (yuisu) : we should not have special cases to condition emitting comments", "// but have one place to fix check for these conditions.", "if", "(", "node", ".", "kind", "!==", "143", "/* MethodDeclaration */", "&&", "node", ".", "kind", "!==", "142", "/* MethodSignature */", "&&", "node", ".", "parent", "&&", "node", ".", "parent", ".", "kind", "!==", "245", "/* PropertyAssignment */", "&&", "node", ".", "parent", ".", "kind", "!==", "168", "/* CallExpression */", ")", "{", "// 1. Methods will emit the comments as part of emitting method declaration", "// 2. If the function is a property of object literal, emitting leading-comments", "// is done by emitNodeWithoutSourceMap which then call this function.", "// In particular, we would like to avoid emit comments twice in following case:", "//      For example:", "//          var obj = {", "//              id:", "//                  /*comment*/ () => void", "//          }", "// 3. If the function is an argument in call expression, emitting of comments will be", "// taken care of in emit list of arguments inside of emitCallexpression", "emitLeadingComments", "(", "node", ")", ";", "}", "emitStart", "(", "node", ")", ";", "// For targeting below es6, emit functions-like declaration including arrow function using function keyword.", "// When targeting ES6, emit arrow function natively in ES6 by omitting function keyword and using fat arrow instead", "if", "(", "!", "shouldEmitAsArrowFunction", "(", "node", ")", ")", "{", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "write", "(", "\"export \"", ")", ";", "if", "(", "node", ".", "flags", "&", "1024", "/* Default */", ")", "{", "write", "(", "\"default \"", ")", ";", "}", "}", "write", "(", "\"function\"", ")", ";", "if", "(", "languageVersion", ">=", "2", "/* ES6 */", "&&", "node", ".", "asteriskToken", ")", "{", "write", "(", "\"*\"", ")", ";", "}", "write", "(", "\" \"", ")", ";", "}", "if", "(", "shouldEmitFunctionName", "(", "node", ")", ")", "{", "emitDeclarationName", "(", "node", ")", ";", "}", "emitSignatureAndBody", "(", "node", ")", ";", "if", "(", "modulekind", "!==", "5", "/* ES6 */", "&&", "node", ".", "kind", "===", "213", "/* FunctionDeclaration */", "&&", "node", ".", "parent", "===", "currentSourceFile", "&&", "node", ".", "name", ")", "{", "emitExportMemberAssignments", "(", "node", ".", "name", ")", ";", "}", "emitEnd", "(", "node", ")", ";", "if", "(", "node", ".", "kind", "!==", "143", "/* MethodDeclaration */", "&&", "node", ".", "kind", "!==", "142", "/* MethodSignature */", ")", "{", "emitTrailingComments", "(", "node", ")", ";", "}", "}", "function", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", "{", "if", "(", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "4", "/* CaptureThis */", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "node", ")", ";", "write", "(", "\"var _this = this;\"", ")", ";", "emitEnd", "(", "node", ")", ";", "}", "}", "function", "emitSignatureParameters", "(", "node", ")", "{", "increaseIndent", "(", ")", ";", "write", "(", "\"(\"", ")", ";", "if", "(", "node", ")", "{", "var", "parameters", "=", "node", ".", "parameters", ";", "var", "omitCount", "=", "languageVersion", "<", "2", "/* ES6 */", "&&", "ts", ".", "hasRestParameter", "(", "node", ")", "?", "1", ":", "0", ";", "emitList", "(", "parameters", ",", "0", ",", "parameters", ".", "length", "-", "omitCount", ",", "/*multiLine*/", "false", ",", "/*trailingComma*/", "false", ")", ";", "}", "write", "(", "\")\"", ")", ";", "decreaseIndent", "(", ")", ";", "}", "function", "emitSignatureParametersForArrow", "(", "node", ")", "{", "// Check whether the parameter list needs parentheses and preserve no-parenthesis", "if", "(", "node", ".", "parameters", ".", "length", "===", "1", "&&", "node", ".", "pos", "===", "node", ".", "parameters", "[", "0", "]", ".", "pos", ")", "{", "emit", "(", "node", ".", "parameters", "[", "0", "]", ")", ";", "return", ";", "}", "emitSignatureParameters", "(", "node", ")", ";", "}", "function", "emitAsyncFunctionBodyForES6", "(", "node", ")", "{", "var", "promiseConstructor", "=", "ts", ".", "getEntityNameFromTypeNode", "(", "node", ".", "type", ")", ";", "var", "isArrowFunction", "=", "node", ".", "kind", "===", "174", "/* ArrowFunction */", ";", "var", "hasLexicalArguments", "=", "(", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "4096", "/* CaptureArguments */", ")", "!==", "0", ";", "var", "args", ";", "// An async function is emit as an outer function that calls an inner", "// generator function. To preserve lexical bindings, we pass the current", "// `this` and `arguments` objects to `__awaiter`. The generator function", "// passed to `__awaiter` is executed inside of the callback to the", "// promise constructor.", "//", "// The emit for an async arrow without a lexical `arguments` binding might be:", "//", "//  // input", "//  let a = async (b) => { await b; }", "//", "//  // output", "//  let a = (b) => __awaiter(this, void 0, void 0, function* () {", "//      yield b;", "//  });", "//", "// The emit for an async arrow with a lexical `arguments` binding might be:", "//", "//  // input", "//  let a = async (b) => { await arguments[0]; }", "//", "//  // output", "//  let a = (b) => __awaiter(this, arguments, void 0, function* (arguments) {", "//      yield arguments[0];", "//  });", "//", "// The emit for an async function expression without a lexical `arguments` binding", "// might be:", "//", "//  // input", "//  let a = async function (b) {", "//      await b;", "//  }", "//", "//  // output", "//  let a = function (b) {", "//      return __awaiter(this, void 0, void 0, function* () {", "//          yield b;", "//      });", "//  }", "//", "// The emit for an async function expression with a lexical `arguments` binding", "// might be:", "//", "//  // input", "//  let a = async function (b) {", "//      await arguments[0];", "//  }", "//", "//  // output", "//  let a = function (b) {", "//      return __awaiter(this, arguments, void 0, function* (_arguments) {", "//          yield _arguments[0];", "//      });", "//  }", "//", "// The emit for an async function expression with a lexical `arguments` binding", "// and a return type annotation might be:", "//", "//  // input", "//  let a = async function (b): MyPromise<any> {", "//      await arguments[0];", "//  }", "//", "//  // output", "//  let a = function (b) {", "//      return __awaiter(this, arguments, MyPromise, function* (_arguments) {", "//          yield _arguments[0];", "//      });", "//  }", "//", "// If this is not an async arrow, emit the opening brace of the function body", "// and the start of the return statement.", "if", "(", "!", "isArrowFunction", ")", "{", "write", "(", "\" {\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"return\"", ")", ";", "}", "write", "(", "\" __awaiter(this\"", ")", ";", "if", "(", "hasLexicalArguments", ")", "{", "write", "(", "\", arguments\"", ")", ";", "}", "else", "{", "write", "(", "\", void 0\"", ")", ";", "}", "if", "(", "promiseConstructor", ")", "{", "write", "(", "\", \"", ")", ";", "emitNodeWithoutSourceMap", "(", "promiseConstructor", ")", ";", "}", "else", "{", "write", "(", "\", Promise\"", ")", ";", "}", "// Emit the call to __awaiter.", "if", "(", "hasLexicalArguments", ")", "{", "write", "(", "\", function* (_arguments)\"", ")", ";", "}", "else", "{", "write", "(", "\", function* ()\"", ")", ";", "}", "// Emit the signature and body for the inner generator function.", "emitFunctionBody", "(", "node", ")", ";", "write", "(", "\")\"", ")", ";", "// If this is not an async arrow, emit the closing brace of the outer function body.", "if", "(", "!", "isArrowFunction", ")", "{", "write", "(", "\";\"", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "}", "}", "function", "emitFunctionBody", "(", "node", ")", "{", "if", "(", "!", "node", ".", "body", ")", "{", "// There can be no body when there are parse errors.  Just emit an empty block", "// in that case.", "write", "(", "\" { }\"", ")", ";", "}", "else", "{", "if", "(", "node", ".", "body", ".", "kind", "===", "192", "/* Block */", ")", "{", "emitBlockFunctionBody", "(", "node", ",", "node", ".", "body", ")", ";", "}", "else", "{", "emitExpressionFunctionBody", "(", "node", ",", "node", ".", "body", ")", ";", "}", "}", "}", "function", "emitSignatureAndBody", "(", "node", ")", "{", "var", "saveTempFlags", "=", "tempFlags", ";", "var", "saveTempVariables", "=", "tempVariables", ";", "var", "saveTempParameters", "=", "tempParameters", ";", "tempFlags", "=", "0", ";", "tempVariables", "=", "undefined", ";", "tempParameters", "=", "undefined", ";", "// When targeting ES6, emit arrow function natively in ES6", "if", "(", "shouldEmitAsArrowFunction", "(", "node", ")", ")", "{", "emitSignatureParametersForArrow", "(", "node", ")", ";", "write", "(", "\" =>\"", ")", ";", "}", "else", "{", "emitSignatureParameters", "(", "node", ")", ";", "}", "var", "isAsync", "=", "ts", ".", "isAsyncFunctionLike", "(", "node", ")", ";", "if", "(", "isAsync", "&&", "languageVersion", "===", "2", "/* ES6 */", ")", "{", "emitAsyncFunctionBodyForES6", "(", "node", ")", ";", "}", "else", "{", "emitFunctionBody", "(", "node", ")", ";", "}", "if", "(", "!", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "emitExportMemberAssignment", "(", "node", ")", ";", "}", "tempFlags", "=", "saveTempFlags", ";", "tempVariables", "=", "saveTempVariables", ";", "tempParameters", "=", "saveTempParameters", ";", "}", "// Returns true if any preamble code was emitted.", "function", "emitFunctionBodyPreamble", "(", "node", ")", "{", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "emitDefaultValueAssignments", "(", "node", ")", ";", "emitRestParameter", "(", "node", ")", ";", "}", "function", "emitExpressionFunctionBody", "(", "node", ",", "body", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", "||", "node", ".", "flags", "&", "512", "/* Async */", ")", "{", "emitDownLevelExpressionFunctionBody", "(", "node", ",", "body", ")", ";", "return", ";", "}", "// For es6 and higher we can emit the expression as is.  However, in the case", "// where the expression might end up looking like a block when emitted, we'll", "// also wrap it in parentheses first.  For example if you have: a => <foo>{}", "// then we need to generate: a => ({})", "write", "(", "\" \"", ")", ";", "// Unwrap all type assertions.", "var", "current", "=", "body", ";", "while", "(", "current", ".", "kind", "===", "171", "/* TypeAssertionExpression */", ")", "{", "current", "=", "current", ".", "expression", ";", "}", "emitParenthesizedIf", "(", "body", ",", "current", ".", "kind", "===", "165", "/* ObjectLiteralExpression */", ")", ";", "}", "function", "emitDownLevelExpressionFunctionBody", "(", "node", ",", "body", ")", "{", "write", "(", "\" {\"", ")", ";", "scopeEmitStart", "(", "node", ")", ";", "increaseIndent", "(", ")", ";", "var", "outPos", "=", "writer", ".", "getTextPos", "(", ")", ";", "emitDetachedComments", "(", "node", ".", "body", ")", ";", "emitFunctionBodyPreamble", "(", "node", ")", ";", "var", "preambleEmitted", "=", "writer", ".", "getTextPos", "(", ")", "!==", "outPos", ";", "decreaseIndent", "(", ")", ";", "// If we didn't have to emit any preamble code, then attempt to keep the arrow", "// function on one line.", "if", "(", "!", "preambleEmitted", "&&", "nodeStartPositionsAreOnSameLine", "(", "node", ",", "body", ")", ")", "{", "write", "(", "\" \"", ")", ";", "emitStart", "(", "body", ")", ";", "write", "(", "\"return \"", ")", ";", "emit", "(", "body", ")", ";", "emitEnd", "(", "body", ")", ";", "write", "(", "\";\"", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "false", ")", ";", "write", "(", "\" \"", ")", ";", "}", "else", "{", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "node", ".", "body", ")", ";", "write", "(", "\"return \"", ")", ";", "emit", "(", "body", ")", ";", "write", "(", "\";\"", ")", ";", "emitTrailingComments", "(", "node", ".", "body", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "}", "emitStart", "(", "node", ".", "body", ")", ";", "write", "(", "\"}\"", ")", ";", "emitEnd", "(", "node", ".", "body", ")", ";", "scopeEmitEnd", "(", ")", ";", "}", "function", "emitBlockFunctionBody", "(", "node", ",", "body", ")", "{", "write", "(", "\" {\"", ")", ";", "scopeEmitStart", "(", "node", ")", ";", "var", "initialTextPos", "=", "writer", ".", "getTextPos", "(", ")", ";", "increaseIndent", "(", ")", ";", "emitDetachedComments", "(", "body", ".", "statements", ")", ";", "// Emit all the directive prologues (like \"use strict\").  These have to come before", "// any other preamble code we write (like parameter initializers).", "var", "startIndex", "=", "emitDirectivePrologues", "(", "body", ".", "statements", ",", "/*startWithNewLine*/", "true", ")", ";", "emitFunctionBodyPreamble", "(", "node", ")", ";", "decreaseIndent", "(", ")", ";", "var", "preambleEmitted", "=", "writer", ".", "getTextPos", "(", ")", "!==", "initialTextPos", ";", "if", "(", "!", "preambleEmitted", "&&", "nodeEndIsOnSameLineAsNodeStart", "(", "body", ",", "body", ")", ")", "{", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "body", ".", "statements", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "statement", "=", "_b", "[", "_a", "]", ";", "write", "(", "\" \"", ")", ";", "emit", "(", "statement", ")", ";", "}", "emitTempDeclarations", "(", "/*newLine*/", "false", ")", ";", "write", "(", "\" \"", ")", ";", "emitLeadingCommentsOfPosition", "(", "body", ".", "statements", ".", "end", ")", ";", "}", "else", "{", "increaseIndent", "(", ")", ";", "emitLinesStartingAt", "(", "body", ".", "statements", ",", "startIndex", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "writeLine", "(", ")", ";", "emitLeadingCommentsOfPosition", "(", "body", ".", "statements", ".", "end", ")", ";", "decreaseIndent", "(", ")", ";", "}", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "body", ".", "statements", ".", "end", ")", ";", "scopeEmitEnd", "(", ")", ";", "}", "function", "findInitialSuperCall", "(", "ctor", ")", "{", "if", "(", "ctor", ".", "body", ")", "{", "var", "statement", "=", "ctor", ".", "body", ".", "statements", "[", "0", "]", ";", "if", "(", "statement", "&&", "statement", ".", "kind", "===", "195", "/* ExpressionStatement */", ")", "{", "var", "expr", "=", "statement", ".", "expression", ";", "if", "(", "expr", "&&", "expr", ".", "kind", "===", "168", "/* CallExpression */", ")", "{", "var", "func", "=", "expr", ".", "expression", ";", "if", "(", "func", "&&", "func", ".", "kind", "===", "95", "/* SuperKeyword */", ")", "{", "return", "statement", ";", "}", "}", "}", "}", "}", "function", "emitParameterPropertyAssignments", "(", "node", ")", "{", "ts", ".", "forEach", "(", "node", ".", "parameters", ",", "function", "(", "param", ")", "{", "if", "(", "param", ".", "flags", "&", "112", "/* AccessibilityModifier */", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "param", ")", ";", "emitStart", "(", "param", ".", "name", ")", ";", "write", "(", "\"this.\"", ")", ";", "emitNodeWithoutSourceMap", "(", "param", ".", "name", ")", ";", "emitEnd", "(", "param", ".", "name", ")", ";", "write", "(", "\" = \"", ")", ";", "emit", "(", "param", ".", "name", ")", ";", "write", "(", "\";\"", ")", ";", "emitEnd", "(", "param", ")", ";", "}", "}", ")", ";", "}", "function", "emitMemberAccessForPropertyName", "(", "memberName", ")", "{", "// This does not emit source map because it is emitted by caller as caller", "// is aware how the property name changes to the property access", "// eg. public x = 10; becomes this.x and static x = 10 becomes className.x", "if", "(", "memberName", ".", "kind", "===", "9", "/* StringLiteral */", "||", "memberName", ".", "kind", "===", "8", "/* NumericLiteral */", ")", "{", "write", "(", "\"[\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "memberName", ")", ";", "write", "(", "\"]\"", ")", ";", "}", "else", "if", "(", "memberName", ".", "kind", "===", "136", "/* ComputedPropertyName */", ")", "{", "emitComputedPropertyName", "(", "memberName", ")", ";", "}", "else", "{", "write", "(", "\".\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "memberName", ")", ";", "}", "}", "function", "getInitializedProperties", "(", "node", ",", "isStatic", ")", "{", "var", "properties", "=", "[", "]", ";", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "node", ".", "members", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "member", "=", "_b", "[", "_a", "]", ";", "if", "(", "member", ".", "kind", "===", "141", "/* PropertyDeclaration */", "&&", "isStatic", "===", "(", "(", "member", ".", "flags", "&", "128", "/* Static */", ")", "!==", "0", ")", "&&", "member", ".", "initializer", ")", "{", "properties", ".", "push", "(", "member", ")", ";", "}", "}", "return", "properties", ";", "}", "function", "emitPropertyDeclarations", "(", "node", ",", "properties", ")", "{", "for", "(", "var", "_a", "=", "0", ";", "_a", "<", "properties", ".", "length", ";", "_a", "++", ")", "{", "var", "property", "=", "properties", "[", "_a", "]", ";", "emitPropertyDeclaration", "(", "node", ",", "property", ")", ";", "}", "}", "function", "emitPropertyDeclaration", "(", "node", ",", "property", ",", "receiver", ",", "isExpression", ")", "{", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "property", ")", ";", "emitStart", "(", "property", ")", ";", "emitStart", "(", "property", ".", "name", ")", ";", "if", "(", "receiver", ")", "{", "emit", "(", "receiver", ")", ";", "}", "else", "{", "if", "(", "property", ".", "flags", "&", "128", "/* Static */", ")", "{", "emitDeclarationName", "(", "node", ")", ";", "}", "else", "{", "write", "(", "\"this\"", ")", ";", "}", "}", "emitMemberAccessForPropertyName", "(", "property", ".", "name", ")", ";", "emitEnd", "(", "property", ".", "name", ")", ";", "write", "(", "\" = \"", ")", ";", "emit", "(", "property", ".", "initializer", ")", ";", "if", "(", "!", "isExpression", ")", "{", "write", "(", "\";\"", ")", ";", "}", "emitEnd", "(", "property", ")", ";", "emitTrailingComments", "(", "property", ")", ";", "}", "function", "emitMemberFunctionsForES5AndLower", "(", "node", ")", "{", "ts", ".", "forEach", "(", "node", ".", "members", ",", "function", "(", "member", ")", "{", "if", "(", "member", ".", "kind", "===", "191", "/* SemicolonClassElement */", ")", "{", "writeLine", "(", ")", ";", "write", "(", "\";\"", ")", ";", "}", "else", "if", "(", "member", ".", "kind", "===", "143", "/* MethodDeclaration */", "||", "node", ".", "kind", "===", "142", "/* MethodSignature */", ")", "{", "if", "(", "!", "member", ".", "body", ")", "{", "return", "emitCommentsOnNotEmittedNode", "(", "member", ")", ";", "}", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "member", ")", ";", "emitStart", "(", "member", ")", ";", "emitStart", "(", "member", ".", "name", ")", ";", "emitClassMemberPrefix", "(", "node", ",", "member", ")", ";", "emitMemberAccessForPropertyName", "(", "member", ".", "name", ")", ";", "emitEnd", "(", "member", ".", "name", ")", ";", "write", "(", "\" = \"", ")", ";", "emitFunctionDeclaration", "(", "member", ")", ";", "emitEnd", "(", "member", ")", ";", "write", "(", "\";\"", ")", ";", "emitTrailingComments", "(", "member", ")", ";", "}", "else", "if", "(", "member", ".", "kind", "===", "145", "/* GetAccessor */", "||", "member", ".", "kind", "===", "146", "/* SetAccessor */", ")", "{", "var", "accessors", "=", "ts", ".", "getAllAccessorDeclarations", "(", "node", ".", "members", ",", "member", ")", ";", "if", "(", "member", "===", "accessors", ".", "firstAccessor", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "member", ")", ";", "write", "(", "\"Object.defineProperty(\"", ")", ";", "emitStart", "(", "member", ".", "name", ")", ";", "emitClassMemberPrefix", "(", "node", ",", "member", ")", ";", "write", "(", "\", \"", ")", ";", "emitExpressionForPropertyName", "(", "member", ".", "name", ")", ";", "emitEnd", "(", "member", ".", "name", ")", ";", "write", "(", "\", {\"", ")", ";", "increaseIndent", "(", ")", ";", "if", "(", "accessors", ".", "getAccessor", ")", "{", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "accessors", ".", "getAccessor", ")", ";", "write", "(", "\"get: \"", ")", ";", "emitStart", "(", "accessors", ".", "getAccessor", ")", ";", "write", "(", "\"function \"", ")", ";", "emitSignatureAndBody", "(", "accessors", ".", "getAccessor", ")", ";", "emitEnd", "(", "accessors", ".", "getAccessor", ")", ";", "emitTrailingComments", "(", "accessors", ".", "getAccessor", ")", ";", "write", "(", "\",\"", ")", ";", "}", "if", "(", "accessors", ".", "setAccessor", ")", "{", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "accessors", ".", "setAccessor", ")", ";", "write", "(", "\"set: \"", ")", ";", "emitStart", "(", "accessors", ".", "setAccessor", ")", ";", "write", "(", "\"function \"", ")", ";", "emitSignatureAndBody", "(", "accessors", ".", "setAccessor", ")", ";", "emitEnd", "(", "accessors", ".", "setAccessor", ")", ";", "emitTrailingComments", "(", "accessors", ".", "setAccessor", ")", ";", "write", "(", "\",\"", ")", ";", "}", "writeLine", "(", ")", ";", "write", "(", "\"enumerable: true,\"", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"configurable: true\"", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"});\"", ")", ";", "emitEnd", "(", "member", ")", ";", "}", "}", "}", ")", ";", "}", "function", "emitMemberFunctionsForES6AndHigher", "(", "node", ")", "{", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "node", ".", "members", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "member", "=", "_b", "[", "_a", "]", ";", "if", "(", "(", "member", ".", "kind", "===", "143", "/* MethodDeclaration */", "||", "node", ".", "kind", "===", "142", "/* MethodSignature */", ")", "&&", "!", "member", ".", "body", ")", "{", "emitCommentsOnNotEmittedNode", "(", "member", ")", ";", "}", "else", "if", "(", "member", ".", "kind", "===", "143", "/* MethodDeclaration */", "||", "member", ".", "kind", "===", "145", "/* GetAccessor */", "||", "member", ".", "kind", "===", "146", "/* SetAccessor */", ")", "{", "writeLine", "(", ")", ";", "emitLeadingComments", "(", "member", ")", ";", "emitStart", "(", "member", ")", ";", "if", "(", "member", ".", "flags", "&", "128", "/* Static */", ")", "{", "write", "(", "\"static \"", ")", ";", "}", "if", "(", "member", ".", "kind", "===", "145", "/* GetAccessor */", ")", "{", "write", "(", "\"get \"", ")", ";", "}", "else", "if", "(", "member", ".", "kind", "===", "146", "/* SetAccessor */", ")", "{", "write", "(", "\"set \"", ")", ";", "}", "if", "(", "member", ".", "asteriskToken", ")", "{", "write", "(", "\"*\"", ")", ";", "}", "emit", "(", "member", ".", "name", ")", ";", "emitSignatureAndBody", "(", "member", ")", ";", "emitEnd", "(", "member", ")", ";", "emitTrailingComments", "(", "member", ")", ";", "}", "else", "if", "(", "member", ".", "kind", "===", "191", "/* SemicolonClassElement */", ")", "{", "writeLine", "(", ")", ";", "write", "(", "\";\"", ")", ";", "}", "}", "}", "function", "emitConstructor", "(", "node", ",", "baseTypeElement", ")", "{", "var", "saveTempFlags", "=", "tempFlags", ";", "var", "saveTempVariables", "=", "tempVariables", ";", "var", "saveTempParameters", "=", "tempParameters", ";", "tempFlags", "=", "0", ";", "tempVariables", "=", "undefined", ";", "tempParameters", "=", "undefined", ";", "emitConstructorWorker", "(", "node", ",", "baseTypeElement", ")", ";", "tempFlags", "=", "saveTempFlags", ";", "tempVariables", "=", "saveTempVariables", ";", "tempParameters", "=", "saveTempParameters", ";", "}", "function", "emitConstructorWorker", "(", "node", ",", "baseTypeElement", ")", "{", "// Check if we have property assignment inside class declaration.", "// If there is property assignment, we need to emit constructor whether users define it or not", "// If there is no property assignment, we can omit constructor if users do not define it", "var", "hasInstancePropertyWithInitializer", "=", "false", ";", "// Emit the constructor overload pinned comments", "ts", ".", "forEach", "(", "node", ".", "members", ",", "function", "(", "member", ")", "{", "if", "(", "member", ".", "kind", "===", "144", "/* Constructor */", "&&", "!", "member", ".", "body", ")", "{", "emitCommentsOnNotEmittedNode", "(", "member", ")", ";", "}", "// Check if there is any non-static property assignment", "if", "(", "member", ".", "kind", "===", "141", "/* PropertyDeclaration */", "&&", "member", ".", "initializer", "&&", "(", "member", ".", "flags", "&", "128", "/* Static */", ")", "===", "0", ")", "{", "hasInstancePropertyWithInitializer", "=", "true", ";", "}", "}", ")", ";", "var", "ctor", "=", "ts", ".", "getFirstConstructorWithBody", "(", "node", ")", ";", "// For target ES6 and above, if there is no user-defined constructor and there is no property assignment", "// do not emit constructor in class declaration.", "if", "(", "languageVersion", ">=", "2", "/* ES6 */", "&&", "!", "ctor", "&&", "!", "hasInstancePropertyWithInitializer", ")", "{", "return", ";", "}", "if", "(", "ctor", ")", "{", "emitLeadingComments", "(", "ctor", ")", ";", "}", "emitStart", "(", "ctor", "||", "node", ")", ";", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "write", "(", "\"function \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "emitSignatureParameters", "(", "ctor", ")", ";", "}", "else", "{", "write", "(", "\"constructor\"", ")", ";", "if", "(", "ctor", ")", "{", "emitSignatureParameters", "(", "ctor", ")", ";", "}", "else", "{", "// Based on EcmaScript6 section 14.5.14: Runtime Semantics: ClassDefinitionEvaluation.", "// If constructor is empty, then,", "//      If ClassHeritageopt is present, then", "//          Let constructor be the result of parsing the String \"constructor(... args){ super (...args);}\" using the syntactic grammar with the goal symbol MethodDefinition.", "//      Else,", "//          Let constructor be the result of parsing the String \"constructor( ){ }\" using the syntactic grammar with the goal symbol MethodDefinition", "if", "(", "baseTypeElement", ")", "{", "write", "(", "\"(...args)\"", ")", ";", "}", "else", "{", "write", "(", "\"()\"", ")", ";", "}", "}", "}", "var", "startIndex", "=", "0", ";", "write", "(", "\" {\"", ")", ";", "scopeEmitStart", "(", "node", ",", "\"constructor\"", ")", ";", "increaseIndent", "(", ")", ";", "if", "(", "ctor", ")", "{", "// Emit all the directive prologues (like \"use strict\").  These have to come before", "// any other preamble code we write (like parameter initializers).", "startIndex", "=", "emitDirectivePrologues", "(", "ctor", ".", "body", ".", "statements", ",", "/*startWithNewLine*/", "true", ")", ";", "emitDetachedComments", "(", "ctor", ".", "body", ".", "statements", ")", ";", "}", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "var", "superCall", ";", "if", "(", "ctor", ")", "{", "emitDefaultValueAssignments", "(", "ctor", ")", ";", "emitRestParameter", "(", "ctor", ")", ";", "if", "(", "baseTypeElement", ")", "{", "superCall", "=", "findInitialSuperCall", "(", "ctor", ")", ";", "if", "(", "superCall", ")", "{", "writeLine", "(", ")", ";", "emit", "(", "superCall", ")", ";", "}", "}", "emitParameterPropertyAssignments", "(", "ctor", ")", ";", "}", "else", "{", "if", "(", "baseTypeElement", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "baseTypeElement", ")", ";", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "write", "(", "\"_super.apply(this, arguments);\"", ")", ";", "}", "else", "{", "write", "(", "\"super(...args);\"", ")", ";", "}", "emitEnd", "(", "baseTypeElement", ")", ";", "}", "}", "emitPropertyDeclarations", "(", "node", ",", "getInitializedProperties", "(", "node", ",", "/*static:*/", "false", ")", ")", ";", "if", "(", "ctor", ")", "{", "var", "statements", "=", "ctor", ".", "body", ".", "statements", ";", "if", "(", "superCall", ")", "{", "statements", "=", "statements", ".", "slice", "(", "1", ")", ";", "}", "emitLinesStartingAt", "(", "statements", ",", "startIndex", ")", ";", "}", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "writeLine", "(", ")", ";", "if", "(", "ctor", ")", "{", "emitLeadingCommentsOfPosition", "(", "ctor", ".", "body", ".", "statements", ".", "end", ")", ";", "}", "decreaseIndent", "(", ")", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "ctor", "?", "ctor", ".", "body", ".", "statements", ".", "end", ":", "node", ".", "members", ".", "end", ")", ";", "scopeEmitEnd", "(", ")", ";", "emitEnd", "(", "ctor", "||", "node", ")", ";", "if", "(", "ctor", ")", "{", "emitTrailingComments", "(", "ctor", ")", ";", "}", "}", "function", "emitClassExpression", "(", "node", ")", "{", "return", "emitClassLikeDeclaration", "(", "node", ")", ";", "}", "function", "emitClassDeclaration", "(", "node", ")", "{", "return", "emitClassLikeDeclaration", "(", "node", ")", ";", "}", "function", "emitClassLikeDeclaration", "(", "node", ")", "{", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "emitClassLikeDeclarationBelowES6", "(", "node", ")", ";", "}", "else", "{", "emitClassLikeDeclarationForES6AndHigher", "(", "node", ")", ";", "}", "if", "(", "modulekind", "!==", "5", "/* ES6 */", "&&", "node", ".", "parent", "===", "currentSourceFile", "&&", "node", ".", "name", ")", "{", "emitExportMemberAssignments", "(", "node", ".", "name", ")", ";", "}", "}", "function", "emitClassLikeDeclarationForES6AndHigher", "(", "node", ")", "{", "var", "thisNodeIsDecorated", "=", "ts", ".", "nodeIsDecorated", "(", "node", ")", ";", "if", "(", "node", ".", "kind", "===", "214", "/* ClassDeclaration */", ")", "{", "if", "(", "thisNodeIsDecorated", ")", "{", "// To preserve the correct runtime semantics when decorators are applied to the class,", "// the emit needs to follow one of the following rules:", "//", "// * For a local class declaration:", "//", "//     @dec class C {", "//     }", "//", "//   The emit should be:", "//", "//     let C = class {", "//     };", "//     C = __decorate([dec], C);", "//", "// * For an exported class declaration:", "//", "//     @dec export class C {", "//     }", "//", "//   The emit should be:", "//", "//     export let C = class {", "//     };", "//     C = __decorate([dec], C);", "//", "// * For a default export of a class declaration with a name:", "//", "//     @dec default export class C {", "//     }", "//", "//   The emit should be:", "//", "//     let C = class {", "//     }", "//     C = __decorate([dec], C);", "//     export default C;", "//", "// * For a default export of a class declaration without a name:", "//", "//     @dec default export class {", "//     }", "//", "//   The emit should be:", "//", "//     let _default = class {", "//     }", "//     _default = __decorate([dec], _default);", "//     export default _default;", "//", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", "&&", "!", "(", "node", ".", "flags", "&", "1024", "/* Default */", ")", ")", "{", "write", "(", "\"export \"", ")", ";", "}", "write", "(", "\"let \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\" = \"", ")", ";", "}", "else", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "write", "(", "\"export \"", ")", ";", "if", "(", "node", ".", "flags", "&", "1024", "/* Default */", ")", "{", "write", "(", "\"default \"", ")", ";", "}", "}", "}", "// If the class has static properties, and it's a class expression, then we'll need", "// to specialize the emit a bit.  for a class expression of the form:", "//", "//      class C { static a = 1; static b = 2; ... }", "//", "// We'll emit:", "//", "//      (_temp = class C { ... }, _temp.a = 1, _temp.b = 2, _temp)", "//", "// This keeps the expression as an expression, while ensuring that the static parts", "// of it have been initialized by the time it is used.", "var", "staticProperties", "=", "getInitializedProperties", "(", "node", ",", "/*static:*/", "true", ")", ";", "var", "isClassExpressionWithStaticProperties", "=", "staticProperties", ".", "length", ">", "0", "&&", "node", ".", "kind", "===", "186", "/* ClassExpression */", ";", "var", "tempVariable", ";", "if", "(", "isClassExpressionWithStaticProperties", ")", "{", "tempVariable", "=", "createAndRecordTempVariable", "(", "0", "/* Auto */", ")", ";", "write", "(", "\"(\"", ")", ";", "increaseIndent", "(", ")", ";", "emit", "(", "tempVariable", ")", ";", "write", "(", "\" = \"", ")", ";", "}", "write", "(", "\"class\"", ")", ";", "// emit name if", "// - node has a name", "// - this is default export with static initializers", "if", "(", "(", "node", ".", "name", "||", "(", "node", ".", "flags", "&", "1024", "/* Default */", "&&", "staticProperties", ".", "length", ">", "0", ")", ")", "&&", "!", "thisNodeIsDecorated", ")", "{", "write", "(", "\" \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "}", "var", "baseTypeNode", "=", "ts", ".", "getClassExtendsHeritageClauseElement", "(", "node", ")", ";", "if", "(", "baseTypeNode", ")", "{", "write", "(", "\" extends \"", ")", ";", "emit", "(", "baseTypeNode", ".", "expression", ")", ";", "}", "write", "(", "\" {\"", ")", ";", "increaseIndent", "(", ")", ";", "scopeEmitStart", "(", "node", ")", ";", "writeLine", "(", ")", ";", "emitConstructor", "(", "node", ",", "baseTypeNode", ")", ";", "emitMemberFunctionsForES6AndHigher", "(", "node", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "node", ".", "members", ".", "end", ")", ";", "scopeEmitEnd", "(", ")", ";", "// TODO(rbuckton): Need to go back to `let _a = class C {}` approach, removing the defineProperty call for now.", "// For a decorated class, we need to assign its name (if it has one). This is because we emit", "// the class as a class expression to avoid the double-binding of the identifier:", "//", "//   let C = class {", "//   }", "//   Object.defineProperty(C, \"name\", { value: \"C\", configurable: true });", "//", "if", "(", "thisNodeIsDecorated", ")", "{", "write", "(", "\";\"", ")", ";", "}", "// Emit static property assignment. Because classDeclaration is lexically evaluated,", "// it is safe to emit static property assignment after classDeclaration", "// From ES6 specification:", "//      HasLexicalDeclaration (N) : Determines if the argument identifier has a binding in this environment record that was created using", "//                                  a lexical declaration such as a LexicalDeclaration or a ClassDeclaration.", "if", "(", "isClassExpressionWithStaticProperties", ")", "{", "for", "(", "var", "_a", "=", "0", ";", "_a", "<", "staticProperties", ".", "length", ";", "_a", "++", ")", "{", "var", "property", "=", "staticProperties", "[", "_a", "]", ";", "write", "(", "\",\"", ")", ";", "writeLine", "(", ")", ";", "emitPropertyDeclaration", "(", "node", ",", "property", ",", "/*receiver:*/", "tempVariable", ",", "/*isExpression:*/", "true", ")", ";", "}", "write", "(", "\",\"", ")", ";", "writeLine", "(", ")", ";", "emit", "(", "tempVariable", ")", ";", "decreaseIndent", "(", ")", ";", "write", "(", "\")\"", ")", ";", "}", "else", "{", "writeLine", "(", ")", ";", "emitPropertyDeclarations", "(", "node", ",", "staticProperties", ")", ";", "emitDecoratorsOfClass", "(", "node", ")", ";", "}", "// If this is an exported class, but not on the top level (i.e. on an internal", "// module), export it", "if", "(", "!", "isES6ExportedDeclaration", "(", "node", ")", "&&", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "node", ")", ";", "emitModuleMemberName", "(", "node", ")", ";", "write", "(", "\" = \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "emitEnd", "(", "node", ")", ";", "write", "(", "\";\"", ")", ";", "}", "else", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", "&&", "(", "node", ".", "flags", "&", "1024", "/* Default */", ")", "&&", "thisNodeIsDecorated", ")", "{", "// if this is a top level default export of decorated class, write the export after the declaration.", "writeLine", "(", ")", ";", "write", "(", "\"export default \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\";\"", ")", ";", "}", "}", "function", "emitClassLikeDeclarationBelowES6", "(", "node", ")", "{", "if", "(", "node", ".", "kind", "===", "214", "/* ClassDeclaration */", ")", "{", "// source file level classes in system modules are hoisted so 'var's for them are already defined", "if", "(", "!", "shouldHoistDeclarationInSystemJsModule", "(", "node", ")", ")", "{", "write", "(", "\"var \"", ")", ";", "}", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\" = \"", ")", ";", "}", "write", "(", "\"(function (\"", ")", ";", "var", "baseTypeNode", "=", "ts", ".", "getClassExtendsHeritageClauseElement", "(", "node", ")", ";", "if", "(", "baseTypeNode", ")", "{", "write", "(", "\"_super\"", ")", ";", "}", "write", "(", "\") {\"", ")", ";", "var", "saveTempFlags", "=", "tempFlags", ";", "var", "saveTempVariables", "=", "tempVariables", ";", "var", "saveTempParameters", "=", "tempParameters", ";", "var", "saveComputedPropertyNamesToGeneratedNames", "=", "computedPropertyNamesToGeneratedNames", ";", "tempFlags", "=", "0", ";", "tempVariables", "=", "undefined", ";", "tempParameters", "=", "undefined", ";", "computedPropertyNamesToGeneratedNames", "=", "undefined", ";", "increaseIndent", "(", ")", ";", "scopeEmitStart", "(", "node", ")", ";", "if", "(", "baseTypeNode", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "baseTypeNode", ")", ";", "write", "(", "\"__extends(\"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\", _super);\"", ")", ";", "emitEnd", "(", "baseTypeNode", ")", ";", "}", "writeLine", "(", ")", ";", "emitConstructor", "(", "node", ",", "baseTypeNode", ")", ";", "emitMemberFunctionsForES5AndLower", "(", "node", ")", ";", "emitPropertyDeclarations", "(", "node", ",", "getInitializedProperties", "(", "node", ",", "/*static:*/", "true", ")", ")", ";", "writeLine", "(", ")", ";", "emitDecoratorsOfClass", "(", "node", ")", ";", "writeLine", "(", ")", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "node", ".", "members", ".", "end", ",", "function", "(", ")", "{", "write", "(", "\"return \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "}", ")", ";", "write", "(", "\";\"", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "tempFlags", "=", "saveTempFlags", ";", "tempVariables", "=", "saveTempVariables", ";", "tempParameters", "=", "saveTempParameters", ";", "computedPropertyNamesToGeneratedNames", "=", "saveComputedPropertyNamesToGeneratedNames", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "node", ".", "members", ".", "end", ")", ";", "scopeEmitEnd", "(", ")", ";", "emitStart", "(", "node", ")", ";", "write", "(", "\")(\"", ")", ";", "if", "(", "baseTypeNode", ")", "{", "emit", "(", "baseTypeNode", ".", "expression", ")", ";", "}", "write", "(", "\")\"", ")", ";", "if", "(", "node", ".", "kind", "===", "214", "/* ClassDeclaration */", ")", "{", "write", "(", "\";\"", ")", ";", "}", "emitEnd", "(", "node", ")", ";", "if", "(", "node", ".", "kind", "===", "214", "/* ClassDeclaration */", ")", "{", "emitExportMemberAssignment", "(", "node", ")", ";", "}", "}", "function", "emitClassMemberPrefix", "(", "node", ",", "member", ")", "{", "emitDeclarationName", "(", "node", ")", ";", "if", "(", "!", "(", "member", ".", "flags", "&", "128", "/* Static */", ")", ")", "{", "write", "(", "\".prototype\"", ")", ";", "}", "}", "function", "emitDecoratorsOfClass", "(", "node", ")", "{", "emitDecoratorsOfMembers", "(", "node", ",", "/*staticFlag*/", "0", ")", ";", "emitDecoratorsOfMembers", "(", "node", ",", "128", "/* Static */", ")", ";", "emitDecoratorsOfConstructor", "(", "node", ")", ";", "}", "function", "emitDecoratorsOfConstructor", "(", "node", ")", "{", "var", "decorators", "=", "node", ".", "decorators", ";", "var", "constructor", "=", "ts", ".", "getFirstConstructorWithBody", "(", "node", ")", ";", "var", "hasDecoratedParameters", "=", "constructor", "&&", "ts", ".", "forEach", "(", "constructor", ".", "parameters", ",", "ts", ".", "nodeIsDecorated", ")", ";", "// skip decoration of the constructor if neither it nor its parameters are decorated", "if", "(", "!", "decorators", "&&", "!", "hasDecoratedParameters", ")", "{", "return", ";", "}", "// Emit the call to __decorate. Given the class:", "//", "//   @dec", "//   class C {", "//   }", "//", "// The emit for the class is:", "//", "//   C = __decorate([dec], C);", "//", "writeLine", "(", ")", ";", "emitStart", "(", "node", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\" = __decorate([\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "var", "decoratorCount", "=", "decorators", "?", "decorators", ".", "length", ":", "0", ";", "var", "argumentsWritten", "=", "emitList", "(", "decorators", ",", "0", ",", "decoratorCount", ",", "/*multiLine*/", "true", ",", "/*trailingComma*/", "false", ",", "/*leadingComma*/", "false", ",", "/*noTrailingNewLine*/", "true", ",", "function", "(", "decorator", ")", "{", "emitStart", "(", "decorator", ")", ";", "emit", "(", "decorator", ".", "expression", ")", ";", "emitEnd", "(", "decorator", ")", ";", "}", ")", ";", "argumentsWritten", "+=", "emitDecoratorsOfParameters", "(", "constructor", ",", "/*leadingComma*/", "argumentsWritten", ">", "0", ")", ";", "emitSerializedTypeMetadata", "(", "node", ",", "/*leadingComma*/", "argumentsWritten", ">=", "0", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"], \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\");\"", ")", ";", "emitEnd", "(", "node", ")", ";", "writeLine", "(", ")", ";", "}", "function", "emitDecoratorsOfMembers", "(", "node", ",", "staticFlag", ")", "{", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "node", ".", "members", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "member", "=", "_b", "[", "_a", "]", ";", "// only emit members in the correct group", "if", "(", "(", "member", ".", "flags", "&", "128", "/* Static */", ")", "!==", "staticFlag", ")", "{", "continue", ";", "}", "// skip members that cannot be decorated (such as the constructor)", "if", "(", "!", "ts", ".", "nodeCanBeDecorated", "(", "member", ")", ")", "{", "continue", ";", "}", "// skip a member if it or any of its parameters are not decorated", "if", "(", "!", "ts", ".", "nodeOrChildIsDecorated", "(", "member", ")", ")", "{", "continue", ";", "}", "// skip an accessor declaration if it is not the first accessor", "var", "decorators", "=", "void", "0", ";", "var", "functionLikeMember", "=", "void", "0", ";", "if", "(", "ts", ".", "isAccessor", "(", "member", ")", ")", "{", "var", "accessors", "=", "ts", ".", "getAllAccessorDeclarations", "(", "node", ".", "members", ",", "member", ")", ";", "if", "(", "member", "!==", "accessors", ".", "firstAccessor", ")", "{", "continue", ";", "}", "// get the decorators from the first accessor with decorators", "decorators", "=", "accessors", ".", "firstAccessor", ".", "decorators", ";", "if", "(", "!", "decorators", "&&", "accessors", ".", "secondAccessor", ")", "{", "decorators", "=", "accessors", ".", "secondAccessor", ".", "decorators", ";", "}", "// we only decorate parameters of the set accessor", "functionLikeMember", "=", "accessors", ".", "setAccessor", ";", "}", "else", "{", "decorators", "=", "member", ".", "decorators", ";", "// we only decorate the parameters here if this is a method", "if", "(", "member", ".", "kind", "===", "143", "/* MethodDeclaration */", ")", "{", "functionLikeMember", "=", "member", ";", "}", "}", "// Emit the call to __decorate. Given the following:", "//", "//   class C {", "//     @dec method(@dec2 x) {}", "//     @dec get accessor() {}", "//     @dec prop;", "//   }", "//", "// The emit for a method is:", "//", "//   __decorate([", "//       dec,", "//       __param(0, dec2),", "//       __metadata(\"design:type\", Function),", "//       __metadata(\"design:paramtypes\", [Object]),", "//       __metadata(\"design:returntype\", void 0)", "//   ], C.prototype, \"method\", undefined);", "//", "// The emit for an accessor is:", "//", "//   __decorate([", "//       dec", "//   ], C.prototype, \"accessor\", undefined);", "//", "// The emit for a property is:", "//", "//   __decorate([", "//       dec", "//   ], C.prototype, \"prop\");", "//", "writeLine", "(", ")", ";", "emitStart", "(", "member", ")", ";", "write", "(", "\"__decorate([\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "var", "decoratorCount", "=", "decorators", "?", "decorators", ".", "length", ":", "0", ";", "var", "argumentsWritten", "=", "emitList", "(", "decorators", ",", "0", ",", "decoratorCount", ",", "/*multiLine*/", "true", ",", "/*trailingComma*/", "false", ",", "/*leadingComma*/", "false", ",", "/*noTrailingNewLine*/", "true", ",", "function", "(", "decorator", ")", "{", "emitStart", "(", "decorator", ")", ";", "emit", "(", "decorator", ".", "expression", ")", ";", "emitEnd", "(", "decorator", ")", ";", "}", ")", ";", "argumentsWritten", "+=", "emitDecoratorsOfParameters", "(", "functionLikeMember", ",", "argumentsWritten", ">", "0", ")", ";", "emitSerializedTypeMetadata", "(", "member", ",", "argumentsWritten", ">", "0", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"], \"", ")", ";", "emitStart", "(", "member", ".", "name", ")", ";", "emitClassMemberPrefix", "(", "node", ",", "member", ")", ";", "write", "(", "\", \"", ")", ";", "emitExpressionForPropertyName", "(", "member", ".", "name", ")", ";", "emitEnd", "(", "member", ".", "name", ")", ";", "if", "(", "languageVersion", ">", "0", "/* ES3 */", ")", "{", "if", "(", "member", ".", "kind", "!==", "141", "/* PropertyDeclaration */", ")", "{", "// We emit `null` here to indicate to `__decorate` that it can invoke `Object.getOwnPropertyDescriptor` directly.", "// We have this extra argument here so that we can inject an explicit property descriptor at a later date.", "write", "(", "\", null\"", ")", ";", "}", "else", "{", "// We emit `void 0` here to indicate to `__decorate` that it can invoke `Object.defineProperty` directly, but that it", "// should not invoke `Object.getOwnPropertyDescriptor`.", "write", "(", "\", void 0\"", ")", ";", "}", "}", "write", "(", "\");\"", ")", ";", "emitEnd", "(", "member", ")", ";", "writeLine", "(", ")", ";", "}", "}", "function", "emitDecoratorsOfParameters", "(", "node", ",", "leadingComma", ")", "{", "var", "argumentsWritten", "=", "0", ";", "if", "(", "node", ")", "{", "var", "parameterIndex", "=", "0", ";", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "node", ".", "parameters", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "parameter", "=", "_b", "[", "_a", "]", ";", "if", "(", "ts", ".", "nodeIsDecorated", "(", "parameter", ")", ")", "{", "var", "decorators", "=", "parameter", ".", "decorators", ";", "argumentsWritten", "+=", "emitList", "(", "decorators", ",", "0", ",", "decorators", ".", "length", ",", "/*multiLine*/", "true", ",", "/*trailingComma*/", "false", ",", "/*leadingComma*/", "leadingComma", ",", "/*noTrailingNewLine*/", "true", ",", "function", "(", "decorator", ")", "{", "emitStart", "(", "decorator", ")", ";", "write", "(", "\"__param(\"", "+", "parameterIndex", "+", "\", \"", ")", ";", "emit", "(", "decorator", ".", "expression", ")", ";", "write", "(", "\")\"", ")", ";", "emitEnd", "(", "decorator", ")", ";", "}", ")", ";", "leadingComma", "=", "true", ";", "}", "++", "parameterIndex", ";", "}", "}", "return", "argumentsWritten", ";", "}", "function", "shouldEmitTypeMetadata", "(", "node", ")", "{", "// This method determines whether to emit the \"design:type\" metadata based on the node's kind.", "// The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata", "// compiler option is set.", "switch", "(", "node", ".", "kind", ")", "{", "case", "143", "/* MethodDeclaration */", ":", "case", "145", "/* GetAccessor */", ":", "case", "146", "/* SetAccessor */", ":", "case", "141", "/* PropertyDeclaration */", ":", "return", "true", ";", "}", "return", "false", ";", "}", "function", "shouldEmitReturnTypeMetadata", "(", "node", ")", "{", "// This method determines whether to emit the \"design:returntype\" metadata based on the node's kind.", "// The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata", "// compiler option is set.", "switch", "(", "node", ".", "kind", ")", "{", "case", "143", "/* MethodDeclaration */", ":", "return", "true", ";", "}", "return", "false", ";", "}", "function", "shouldEmitParamTypesMetadata", "(", "node", ")", "{", "// This method determines whether to emit the \"design:paramtypes\" metadata based on the node's kind.", "// The caller should have already tested whether the node has decorators and whether the emitDecoratorMetadata", "// compiler option is set.", "switch", "(", "node", ".", "kind", ")", "{", "case", "214", "/* ClassDeclaration */", ":", "case", "143", "/* MethodDeclaration */", ":", "case", "146", "/* SetAccessor */", ":", "return", "true", ";", "}", "return", "false", ";", "}", "/** Serializes the type of a declaration to an appropriate JS constructor value. Used by the __metadata decorator for a class member. */", "function", "emitSerializedTypeOfNode", "(", "node", ")", "{", "// serialization of the type of a declaration uses the following rules:", "//", "// * The serialized type of a ClassDeclaration is \"Function\"", "// * The serialized type of a ParameterDeclaration is the serialized type of its type annotation.", "// * The serialized type of a PropertyDeclaration is the serialized type of its type annotation.", "// * The serialized type of an AccessorDeclaration is the serialized type of the return type annotation of its getter or parameter type annotation of its setter.", "// * The serialized type of any other FunctionLikeDeclaration is \"Function\".", "// * The serialized type of any other node is \"void 0\".", "//", "// For rules on serializing type annotations, see `serializeTypeNode`.", "switch", "(", "node", ".", "kind", ")", "{", "case", "214", "/* ClassDeclaration */", ":", "write", "(", "\"Function\"", ")", ";", "return", ";", "case", "141", "/* PropertyDeclaration */", ":", "emitSerializedTypeNode", "(", "node", ".", "type", ")", ";", "return", ";", "case", "138", "/* Parameter */", ":", "emitSerializedTypeNode", "(", "node", ".", "type", ")", ";", "return", ";", "case", "145", "/* GetAccessor */", ":", "emitSerializedTypeNode", "(", "node", ".", "type", ")", ";", "return", ";", "case", "146", "/* SetAccessor */", ":", "emitSerializedTypeNode", "(", "ts", ".", "getSetAccessorTypeAnnotationNode", "(", "node", ")", ")", ";", "return", ";", "}", "if", "(", "ts", ".", "isFunctionLike", "(", "node", ")", ")", "{", "write", "(", "\"Function\"", ")", ";", "return", ";", "}", "write", "(", "\"void 0\"", ")", ";", "}", "function", "emitSerializedTypeNode", "(", "node", ")", "{", "if", "(", "node", ")", "{", "switch", "(", "node", ".", "kind", ")", "{", "case", "103", "/* VoidKeyword */", ":", "write", "(", "\"void 0\"", ")", ";", "return", ";", "case", "160", "/* ParenthesizedType */", ":", "emitSerializedTypeNode", "(", "node", ".", "type", ")", ";", "return", ";", "case", "152", "/* FunctionType */", ":", "case", "153", "/* ConstructorType */", ":", "write", "(", "\"Function\"", ")", ";", "return", ";", "case", "156", "/* ArrayType */", ":", "case", "157", "/* TupleType */", ":", "write", "(", "\"Array\"", ")", ";", "return", ";", "case", "150", "/* TypePredicate */", ":", "case", "120", "/* BooleanKeyword */", ":", "write", "(", "\"Boolean\"", ")", ";", "return", ";", "case", "130", "/* StringKeyword */", ":", "case", "9", "/* StringLiteral */", ":", "write", "(", "\"String\"", ")", ";", "return", ";", "case", "128", "/* NumberKeyword */", ":", "write", "(", "\"Number\"", ")", ";", "return", ";", "case", "131", "/* SymbolKeyword */", ":", "write", "(", "\"Symbol\"", ")", ";", "return", ";", "case", "151", "/* TypeReference */", ":", "emitSerializedTypeReferenceNode", "(", "node", ")", ";", "return", ";", "case", "154", "/* TypeQuery */", ":", "case", "155", "/* TypeLiteral */", ":", "case", "158", "/* UnionType */", ":", "case", "159", "/* IntersectionType */", ":", "case", "117", "/* AnyKeyword */", ":", "break", ";", "default", ":", "ts", ".", "Debug", ".", "fail", "(", "\"Cannot serialize unexpected type node.\"", ")", ";", "break", ";", "}", "}", "write", "(", "\"Object\"", ")", ";", "}", "/** Serializes a TypeReferenceNode to an appropriate JS constructor value. Used by the __metadata decorator. */", "function", "emitSerializedTypeReferenceNode", "(", "node", ")", "{", "var", "location", "=", "node", ".", "parent", ";", "while", "(", "ts", ".", "isDeclaration", "(", "location", ")", "||", "ts", ".", "isTypeNode", "(", "location", ")", ")", "{", "location", "=", "location", ".", "parent", ";", "}", "// Clone the type name and parent it to a location outside of the current declaration.", "var", "typeName", "=", "ts", ".", "cloneEntityName", "(", "node", ".", "typeName", ")", ";", "typeName", ".", "parent", "=", "location", ";", "var", "result", "=", "resolver", ".", "getTypeReferenceSerializationKind", "(", "typeName", ")", ";", "switch", "(", "result", ")", "{", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "Unknown", ":", "var", "temp", "=", "createAndRecordTempVariable", "(", "0", "/* Auto */", ")", ";", "write", "(", "\"(typeof (\"", ")", ";", "emitNodeWithoutSourceMap", "(", "temp", ")", ";", "write", "(", "\" = \"", ")", ";", "emitEntityNameAsExpression", "(", "typeName", ",", "/*useFallback*/", "true", ")", ";", "write", "(", "\") === 'function' && \"", ")", ";", "emitNodeWithoutSourceMap", "(", "temp", ")", ";", "write", "(", "\") || Object\"", ")", ";", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "TypeWithConstructSignatureAndValue", ":", "emitEntityNameAsExpression", "(", "typeName", ",", "/*useFallback*/", "false", ")", ";", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "VoidType", ":", "write", "(", "\"void 0\"", ")", ";", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "BooleanType", ":", "write", "(", "\"Boolean\"", ")", ";", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "NumberLikeType", ":", "write", "(", "\"Number\"", ")", ";", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "StringLikeType", ":", "write", "(", "\"String\"", ")", ";", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "ArrayLikeType", ":", "write", "(", "\"Array\"", ")", ";", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "ESSymbolType", ":", "if", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "{", "write", "(", "\"typeof Symbol === 'function' ? Symbol : Object\"", ")", ";", "}", "else", "{", "write", "(", "\"Symbol\"", ")", ";", "}", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "TypeWithCallSignature", ":", "write", "(", "\"Function\"", ")", ";", "break", ";", "case", "ts", ".", "TypeReferenceSerializationKind", ".", "ObjectType", ":", "write", "(", "\"Object\"", ")", ";", "break", ";", "}", "}", "/** Serializes the parameter types of a function or the constructor of a class. Used by the __metadata decorator for a method or set accessor. */", "function", "emitSerializedParameterTypesOfNode", "(", "node", ")", "{", "// serialization of parameter types uses the following rules:", "//", "// * If the declaration is a class, the parameters of the first constructor with a body are used.", "// * If the declaration is function-like and has a body, the parameters of the function are used.", "//", "// For the rules on serializing the type of each parameter declaration, see `serializeTypeOfDeclaration`.", "if", "(", "node", ")", "{", "var", "valueDeclaration", ";", "if", "(", "node", ".", "kind", "===", "214", "/* ClassDeclaration */", ")", "{", "valueDeclaration", "=", "ts", ".", "getFirstConstructorWithBody", "(", "node", ")", ";", "}", "else", "if", "(", "ts", ".", "isFunctionLike", "(", "node", ")", "&&", "ts", ".", "nodeIsPresent", "(", "node", ".", "body", ")", ")", "{", "valueDeclaration", "=", "node", ";", "}", "if", "(", "valueDeclaration", ")", "{", "var", "parameters", "=", "valueDeclaration", ".", "parameters", ";", "var", "parameterCount", "=", "parameters", ".", "length", ";", "if", "(", "parameterCount", ">", "0", ")", "{", "for", "(", "var", "i", "=", "0", ";", "i", "<", "parameterCount", ";", "i", "++", ")", "{", "if", "(", "i", ">", "0", ")", "{", "write", "(", "\", \"", ")", ";", "}", "if", "(", "parameters", "[", "i", "]", ".", "dotDotDotToken", ")", "{", "var", "parameterType", "=", "parameters", "[", "i", "]", ".", "type", ";", "if", "(", "parameterType", ".", "kind", "===", "156", "/* ArrayType */", ")", "{", "parameterType", "=", "parameterType", ".", "elementType", ";", "}", "else", "if", "(", "parameterType", ".", "kind", "===", "151", "/* TypeReference */", "&&", "parameterType", ".", "typeArguments", "&&", "parameterType", ".", "typeArguments", ".", "length", "===", "1", ")", "{", "parameterType", "=", "parameterType", ".", "typeArguments", "[", "0", "]", ";", "}", "else", "{", "parameterType", "=", "undefined", ";", "}", "emitSerializedTypeNode", "(", "parameterType", ")", ";", "}", "else", "{", "emitSerializedTypeOfNode", "(", "parameters", "[", "i", "]", ")", ";", "}", "}", "}", "}", "}", "}", "/** Serializes the return type of function. Used by the __metadata decorator for a method. */", "function", "emitSerializedReturnTypeOfNode", "(", "node", ")", "{", "if", "(", "node", "&&", "ts", ".", "isFunctionLike", "(", "node", ")", "&&", "node", ".", "type", ")", "{", "emitSerializedTypeNode", "(", "node", ".", "type", ")", ";", "return", ";", "}", "write", "(", "\"void 0\"", ")", ";", "}", "function", "emitSerializedTypeMetadata", "(", "node", ",", "writeComma", ")", "{", "// This method emits the serialized type metadata for a decorator target.", "// The caller should have already tested whether the node has decorators.", "var", "argumentsWritten", "=", "0", ";", "if", "(", "compilerOptions", ".", "emitDecoratorMetadata", ")", "{", "if", "(", "shouldEmitTypeMetadata", "(", "node", ")", ")", "{", "if", "(", "writeComma", ")", "{", "write", "(", "\", \"", ")", ";", "}", "writeLine", "(", ")", ";", "write", "(", "\"__metadata('design:type', \"", ")", ";", "emitSerializedTypeOfNode", "(", "node", ")", ";", "write", "(", "\")\"", ")", ";", "argumentsWritten", "++", ";", "}", "if", "(", "shouldEmitParamTypesMetadata", "(", "node", ")", ")", "{", "if", "(", "writeComma", "||", "argumentsWritten", ")", "{", "write", "(", "\", \"", ")", ";", "}", "writeLine", "(", ")", ";", "write", "(", "\"__metadata('design:paramtypes', [\"", ")", ";", "emitSerializedParameterTypesOfNode", "(", "node", ")", ";", "write", "(", "\"])\"", ")", ";", "argumentsWritten", "++", ";", "}", "if", "(", "shouldEmitReturnTypeMetadata", "(", "node", ")", ")", "{", "if", "(", "writeComma", "||", "argumentsWritten", ")", "{", "write", "(", "\", \"", ")", ";", "}", "writeLine", "(", ")", ";", "write", "(", "\"__metadata('design:returntype', \"", ")", ";", "emitSerializedReturnTypeOfNode", "(", "node", ")", ";", "write", "(", "\")\"", ")", ";", "argumentsWritten", "++", ";", "}", "}", "return", "argumentsWritten", ";", "}", "function", "emitInterfaceDeclaration", "(", "node", ")", "{", "emitCommentsOnNotEmittedNode", "(", "node", ")", ";", "}", "function", "shouldEmitEnumDeclaration", "(", "node", ")", "{", "var", "isConstEnum", "=", "ts", ".", "isConst", "(", "node", ")", ";", "return", "!", "isConstEnum", "||", "compilerOptions", ".", "preserveConstEnums", "||", "compilerOptions", ".", "isolatedModules", ";", "}", "function", "emitEnumDeclaration", "(", "node", ")", "{", "// const enums are completely erased during compilation.", "if", "(", "!", "shouldEmitEnumDeclaration", "(", "node", ")", ")", "{", "return", ";", "}", "if", "(", "!", "shouldHoistDeclarationInSystemJsModule", "(", "node", ")", ")", "{", "// do not emit var if variable was already hoisted", "if", "(", "!", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", "||", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "emitStart", "(", "node", ")", ";", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "write", "(", "\"export \"", ")", ";", "}", "write", "(", "\"var \"", ")", ";", "emit", "(", "node", ".", "name", ")", ";", "emitEnd", "(", "node", ")", ";", "write", "(", "\";\"", ")", ";", "}", "}", "writeLine", "(", ")", ";", "emitStart", "(", "node", ")", ";", "write", "(", "\"(function (\"", ")", ";", "emitStart", "(", "node", ".", "name", ")", ";", "write", "(", "getGeneratedNameForNode", "(", "node", ")", ")", ";", "emitEnd", "(", "node", ".", "name", ")", ";", "write", "(", "\") {\"", ")", ";", "increaseIndent", "(", ")", ";", "scopeEmitStart", "(", "node", ")", ";", "emitLines", "(", "node", ".", "members", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "node", ".", "members", ".", "end", ")", ";", "scopeEmitEnd", "(", ")", ";", "write", "(", "\")(\"", ")", ";", "emitModuleMemberName", "(", "node", ")", ";", "write", "(", "\" || (\"", ")", ";", "emitModuleMemberName", "(", "node", ")", ";", "write", "(", "\" = {}));\"", ")", ";", "emitEnd", "(", "node", ")", ";", "if", "(", "!", "isES6ExportedDeclaration", "(", "node", ")", "&&", "node", ".", "flags", "&", "1", "/* Export */", "&&", "!", "shouldHoistDeclarationInSystemJsModule", "(", "node", ")", ")", "{", "// do not emit var if variable was already hoisted", "writeLine", "(", ")", ";", "emitStart", "(", "node", ")", ";", "write", "(", "\"var \"", ")", ";", "emit", "(", "node", ".", "name", ")", ";", "write", "(", "\" = \"", ")", ";", "emitModuleMemberName", "(", "node", ")", ";", "emitEnd", "(", "node", ")", ";", "write", "(", "\";\"", ")", ";", "}", "if", "(", "modulekind", "!==", "5", "/* ES6 */", "&&", "node", ".", "parent", "===", "currentSourceFile", ")", "{", "if", "(", "modulekind", "===", "4", "/* System */", "&&", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", ")", "{", "// write the call to exporter for enum", "writeLine", "(", ")", ";", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\");\"", ")", ";", "}", "emitExportMemberAssignments", "(", "node", ".", "name", ")", ";", "}", "}", "function", "emitEnumMember", "(", "node", ")", "{", "var", "enumParent", "=", "node", ".", "parent", ";", "emitStart", "(", "node", ")", ";", "write", "(", "getGeneratedNameForNode", "(", "enumParent", ")", ")", ";", "write", "(", "\"[\"", ")", ";", "write", "(", "getGeneratedNameForNode", "(", "enumParent", ")", ")", ";", "write", "(", "\"[\"", ")", ";", "emitExpressionForPropertyName", "(", "node", ".", "name", ")", ";", "write", "(", "\"] = \"", ")", ";", "writeEnumMemberDeclarationValue", "(", "node", ")", ";", "write", "(", "\"] = \"", ")", ";", "emitExpressionForPropertyName", "(", "node", ".", "name", ")", ";", "emitEnd", "(", "node", ")", ";", "write", "(", "\";\"", ")", ";", "}", "function", "writeEnumMemberDeclarationValue", "(", "member", ")", "{", "var", "value", "=", "resolver", ".", "getConstantValue", "(", "member", ")", ";", "if", "(", "value", "!==", "undefined", ")", "{", "write", "(", "value", ".", "toString", "(", ")", ")", ";", "return", ";", "}", "else", "if", "(", "member", ".", "initializer", ")", "{", "emit", "(", "member", ".", "initializer", ")", ";", "}", "else", "{", "write", "(", "\"undefined\"", ")", ";", "}", "}", "function", "getInnerMostModuleDeclarationFromDottedModule", "(", "moduleDeclaration", ")", "{", "if", "(", "moduleDeclaration", ".", "body", ".", "kind", "===", "218", "/* ModuleDeclaration */", ")", "{", "var", "recursiveInnerModule", "=", "getInnerMostModuleDeclarationFromDottedModule", "(", "moduleDeclaration", ".", "body", ")", ";", "return", "recursiveInnerModule", "||", "moduleDeclaration", ".", "body", ";", "}", "}", "function", "shouldEmitModuleDeclaration", "(", "node", ")", "{", "return", "ts", ".", "isInstantiatedModule", "(", "node", ",", "compilerOptions", ".", "preserveConstEnums", "||", "compilerOptions", ".", "isolatedModules", ")", ";", "}", "function", "isModuleMergedWithES6Class", "(", "node", ")", "{", "return", "languageVersion", "===", "2", "/* ES6 */", "&&", "!", "!", "(", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "32768", "/* LexicalModuleMergesWithClass */", ")", ";", "}", "function", "emitModuleDeclaration", "(", "node", ")", "{", "// Emit only if this module is non-ambient.", "var", "shouldEmit", "=", "shouldEmitModuleDeclaration", "(", "node", ")", ";", "if", "(", "!", "shouldEmit", ")", "{", "return", "emitCommentsOnNotEmittedNode", "(", "node", ")", ";", "}", "var", "hoistedInDeclarationScope", "=", "shouldHoistDeclarationInSystemJsModule", "(", "node", ")", ";", "var", "emitVarForModule", "=", "!", "hoistedInDeclarationScope", "&&", "!", "isModuleMergedWithES6Class", "(", "node", ")", ";", "if", "(", "emitVarForModule", ")", "{", "emitStart", "(", "node", ")", ";", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "write", "(", "\"export \"", ")", ";", "}", "write", "(", "\"var \"", ")", ";", "emit", "(", "node", ".", "name", ")", ";", "write", "(", "\";\"", ")", ";", "emitEnd", "(", "node", ")", ";", "writeLine", "(", ")", ";", "}", "emitStart", "(", "node", ")", ";", "write", "(", "\"(function (\"", ")", ";", "emitStart", "(", "node", ".", "name", ")", ";", "write", "(", "getGeneratedNameForNode", "(", "node", ")", ")", ";", "emitEnd", "(", "node", ".", "name", ")", ";", "write", "(", "\") \"", ")", ";", "if", "(", "node", ".", "body", ".", "kind", "===", "219", "/* ModuleBlock */", ")", "{", "var", "saveTempFlags", "=", "tempFlags", ";", "var", "saveTempVariables", "=", "tempVariables", ";", "tempFlags", "=", "0", ";", "tempVariables", "=", "undefined", ";", "emit", "(", "node", ".", "body", ")", ";", "tempFlags", "=", "saveTempFlags", ";", "tempVariables", "=", "saveTempVariables", ";", "}", "else", "{", "write", "(", "\"{\"", ")", ";", "increaseIndent", "(", ")", ";", "scopeEmitStart", "(", "node", ")", ";", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "writeLine", "(", ")", ";", "emit", "(", "node", ".", "body", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "var", "moduleBlock", "=", "getInnerMostModuleDeclarationFromDottedModule", "(", "node", ")", ".", "body", ";", "emitToken", "(", "16", "/* CloseBraceToken */", ",", "moduleBlock", ".", "statements", ".", "end", ")", ";", "scopeEmitEnd", "(", ")", ";", "}", "write", "(", "\")(\"", ")", ";", "// write moduleDecl = containingModule.m only if it is not exported es6 module member", "if", "(", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", "&&", "!", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "emit", "(", "node", ".", "name", ")", ";", "write", "(", "\" = \"", ")", ";", "}", "emitModuleMemberName", "(", "node", ")", ";", "write", "(", "\" || (\"", ")", ";", "emitModuleMemberName", "(", "node", ")", ";", "write", "(", "\" = {}));\"", ")", ";", "emitEnd", "(", "node", ")", ";", "if", "(", "!", "isES6ExportedDeclaration", "(", "node", ")", "&&", "node", ".", "name", ".", "kind", "===", "69", "/* Identifier */", "&&", "node", ".", "parent", "===", "currentSourceFile", ")", "{", "if", "(", "modulekind", "===", "4", "/* System */", "&&", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", ")", "{", "writeLine", "(", ")", ";", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "emitDeclarationName", "(", "node", ")", ";", "write", "(", "\");\"", ")", ";", "}", "emitExportMemberAssignments", "(", "node", ".", "name", ")", ";", "}", "}", "/*\n             * Some bundlers (SystemJS builder) sometimes want to rename dependencies.\n             * Here we check if alternative name was provided for a given moduleName and return it if possible.\n             */", "function", "tryRenameExternalModule", "(", "moduleName", ")", "{", "if", "(", "currentSourceFile", ".", "renamedDependencies", "&&", "ts", ".", "hasProperty", "(", "currentSourceFile", ".", "renamedDependencies", ",", "moduleName", ".", "text", ")", ")", "{", "return", "\"\\\"\"", "+", "currentSourceFile", ".", "renamedDependencies", "[", "moduleName", ".", "text", "]", "+", "\"\\\"\"", ";", "}", "return", "undefined", ";", "}", "function", "emitRequire", "(", "moduleName", ")", "{", "if", "(", "moduleName", ".", "kind", "===", "9", "/* StringLiteral */", ")", "{", "write", "(", "\"require(\"", ")", ";", "var", "text", "=", "tryRenameExternalModule", "(", "moduleName", ")", ";", "if", "(", "text", ")", "{", "write", "(", "text", ")", ";", "}", "else", "{", "emitStart", "(", "moduleName", ")", ";", "emitLiteral", "(", "moduleName", ")", ";", "emitEnd", "(", "moduleName", ")", ";", "}", "emitToken", "(", "18", "/* CloseParenToken */", ",", "moduleName", ".", "end", ")", ";", "}", "else", "{", "write", "(", "\"require()\"", ")", ";", "}", "}", "function", "getNamespaceDeclarationNode", "(", "node", ")", "{", "if", "(", "node", ".", "kind", "===", "221", "/* ImportEqualsDeclaration */", ")", "{", "return", "node", ";", "}", "var", "importClause", "=", "node", ".", "importClause", ";", "if", "(", "importClause", "&&", "importClause", ".", "namedBindings", "&&", "importClause", ".", "namedBindings", ".", "kind", "===", "224", "/* NamespaceImport */", ")", "{", "return", "importClause", ".", "namedBindings", ";", "}", "}", "function", "isDefaultImport", "(", "node", ")", "{", "return", "node", ".", "kind", "===", "222", "/* ImportDeclaration */", "&&", "node", ".", "importClause", "&&", "!", "!", "node", ".", "importClause", ".", "name", ";", "}", "function", "emitExportImportAssignments", "(", "node", ")", "{", "if", "(", "ts", ".", "isAliasSymbolDeclaration", "(", "node", ")", "&&", "resolver", ".", "isValueAliasDeclaration", "(", "node", ")", ")", "{", "emitExportMemberAssignments", "(", "node", ".", "name", ")", ";", "}", "ts", ".", "forEachChild", "(", "node", ",", "emitExportImportAssignments", ")", ";", "}", "function", "emitImportDeclaration", "(", "node", ")", "{", "if", "(", "modulekind", "!==", "5", "/* ES6 */", ")", "{", "return", "emitExternalImportDeclaration", "(", "node", ")", ";", "}", "// ES6 import", "if", "(", "node", ".", "importClause", ")", "{", "var", "shouldEmitDefaultBindings", "=", "resolver", ".", "isReferencedAliasDeclaration", "(", "node", ".", "importClause", ")", ";", "var", "shouldEmitNamedBindings", "=", "node", ".", "importClause", ".", "namedBindings", "&&", "resolver", ".", "isReferencedAliasDeclaration", "(", "node", ".", "importClause", ".", "namedBindings", ",", "/* checkChildren */", "true", ")", ";", "if", "(", "shouldEmitDefaultBindings", "||", "shouldEmitNamedBindings", ")", "{", "write", "(", "\"import \"", ")", ";", "emitStart", "(", "node", ".", "importClause", ")", ";", "if", "(", "shouldEmitDefaultBindings", ")", "{", "emit", "(", "node", ".", "importClause", ".", "name", ")", ";", "if", "(", "shouldEmitNamedBindings", ")", "{", "write", "(", "\", \"", ")", ";", "}", "}", "if", "(", "shouldEmitNamedBindings", ")", "{", "emitLeadingComments", "(", "node", ".", "importClause", ".", "namedBindings", ")", ";", "emitStart", "(", "node", ".", "importClause", ".", "namedBindings", ")", ";", "if", "(", "node", ".", "importClause", ".", "namedBindings", ".", "kind", "===", "224", "/* NamespaceImport */", ")", "{", "write", "(", "\"* as \"", ")", ";", "emit", "(", "node", ".", "importClause", ".", "namedBindings", ".", "name", ")", ";", "}", "else", "{", "write", "(", "\"{ \"", ")", ";", "emitExportOrImportSpecifierList", "(", "node", ".", "importClause", ".", "namedBindings", ".", "elements", ",", "resolver", ".", "isReferencedAliasDeclaration", ")", ";", "write", "(", "\" }\"", ")", ";", "}", "emitEnd", "(", "node", ".", "importClause", ".", "namedBindings", ")", ";", "emitTrailingComments", "(", "node", ".", "importClause", ".", "namedBindings", ")", ";", "}", "emitEnd", "(", "node", ".", "importClause", ")", ";", "write", "(", "\" from \"", ")", ";", "emit", "(", "node", ".", "moduleSpecifier", ")", ";", "write", "(", "\";\"", ")", ";", "}", "}", "else", "{", "write", "(", "\"import \"", ")", ";", "emit", "(", "node", ".", "moduleSpecifier", ")", ";", "write", "(", "\";\"", ")", ";", "}", "}", "function", "emitExternalImportDeclaration", "(", "node", ")", "{", "if", "(", "ts", ".", "contains", "(", "externalImports", ",", "node", ")", ")", "{", "var", "isExportedImport", "=", "node", ".", "kind", "===", "221", "/* ImportEqualsDeclaration */", "&&", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", "!==", "0", ";", "var", "namespaceDeclaration", "=", "getNamespaceDeclarationNode", "(", "node", ")", ";", "if", "(", "modulekind", "!==", "2", "/* AMD */", ")", "{", "emitLeadingComments", "(", "node", ")", ";", "emitStart", "(", "node", ")", ";", "if", "(", "namespaceDeclaration", "&&", "!", "isDefaultImport", "(", "node", ")", ")", "{", "// import x = require(\"foo\")", "// import * as x from \"foo\"", "if", "(", "!", "isExportedImport", ")", "write", "(", "\"var \"", ")", ";", "emitModuleMemberName", "(", "namespaceDeclaration", ")", ";", "write", "(", "\" = \"", ")", ";", "}", "else", "{", "// import \"foo\"", "// import x from \"foo\"", "// import { x, y } from \"foo\"", "// import d, * as x from \"foo\"", "// import d, { x, y } from \"foo\"", "var", "isNakedImport", "=", "222", "/* ImportDeclaration */", "&&", "!", "node", ".", "importClause", ";", "if", "(", "!", "isNakedImport", ")", "{", "write", "(", "\"var \"", ")", ";", "write", "(", "getGeneratedNameForNode", "(", "node", ")", ")", ";", "write", "(", "\" = \"", ")", ";", "}", "}", "emitRequire", "(", "ts", ".", "getExternalModuleName", "(", "node", ")", ")", ";", "if", "(", "namespaceDeclaration", "&&", "isDefaultImport", "(", "node", ")", ")", "{", "// import d, * as x from \"foo\"", "write", "(", "\", \"", ")", ";", "emitModuleMemberName", "(", "namespaceDeclaration", ")", ";", "write", "(", "\" = \"", ")", ";", "write", "(", "getGeneratedNameForNode", "(", "node", ")", ")", ";", "}", "write", "(", "\";\"", ")", ";", "emitEnd", "(", "node", ")", ";", "emitExportImportAssignments", "(", "node", ")", ";", "emitTrailingComments", "(", "node", ")", ";", "}", "else", "{", "if", "(", "isExportedImport", ")", "{", "emitModuleMemberName", "(", "namespaceDeclaration", ")", ";", "write", "(", "\" = \"", ")", ";", "emit", "(", "namespaceDeclaration", ".", "name", ")", ";", "write", "(", "\";\"", ")", ";", "}", "else", "if", "(", "namespaceDeclaration", "&&", "isDefaultImport", "(", "node", ")", ")", "{", "// import d, * as x from \"foo\"", "write", "(", "\"var \"", ")", ";", "emitModuleMemberName", "(", "namespaceDeclaration", ")", ";", "write", "(", "\" = \"", ")", ";", "write", "(", "getGeneratedNameForNode", "(", "node", ")", ")", ";", "write", "(", "\";\"", ")", ";", "}", "emitExportImportAssignments", "(", "node", ")", ";", "}", "}", "}", "function", "emitImportEqualsDeclaration", "(", "node", ")", "{", "if", "(", "ts", ".", "isExternalModuleImportEqualsDeclaration", "(", "node", ")", ")", "{", "emitExternalImportDeclaration", "(", "node", ")", ";", "return", ";", "}", "// preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when", "// - current file is not external module", "// - import declaration is top level and target is value imported by entity name", "if", "(", "resolver", ".", "isReferencedAliasDeclaration", "(", "node", ")", "||", "(", "!", "ts", ".", "isExternalModule", "(", "currentSourceFile", ")", "&&", "resolver", ".", "isTopLevelValueImportEqualsWithEntityName", "(", "node", ")", ")", ")", "{", "emitLeadingComments", "(", "node", ")", ";", "emitStart", "(", "node", ")", ";", "// variable declaration for import-equals declaration can be hoisted in system modules", "// in this case 'var' should be omitted and emit should contain only initialization", "var", "variableDeclarationIsHoisted", "=", "shouldHoistVariable", "(", "node", ",", "/*checkIfSourceFileLevelDecl*/", "true", ")", ";", "// is it top level export import v = a.b.c in system module?", "// if yes - it needs to be rewritten as exporter('v', v = a.b.c)", "var", "isExported", "=", "isSourceFileLevelDeclarationInSystemJsModule", "(", "node", ",", "/*isExported*/", "true", ")", ";", "if", "(", "!", "variableDeclarationIsHoisted", ")", "{", "ts", ".", "Debug", ".", "assert", "(", "!", "isExported", ")", ";", "if", "(", "isES6ExportedDeclaration", "(", "node", ")", ")", "{", "write", "(", "\"export \"", ")", ";", "write", "(", "\"var \"", ")", ";", "}", "else", "if", "(", "!", "(", "node", ".", "flags", "&", "1", "/* Export */", ")", ")", "{", "write", "(", "\"var \"", ")", ";", "}", "}", "if", "(", "isExported", ")", "{", "write", "(", "exportFunctionForFile", "+", "\"(\\\"\"", ")", ";", "emitNodeWithoutSourceMap", "(", "node", ".", "name", ")", ";", "write", "(", "\"\\\", \"", ")", ";", "}", "emitModuleMemberName", "(", "node", ")", ";", "write", "(", "\" = \"", ")", ";", "emit", "(", "node", ".", "moduleReference", ")", ";", "if", "(", "isExported", ")", "{", "write", "(", "\")\"", ")", ";", "}", "write", "(", "\";\"", ")", ";", "emitEnd", "(", "node", ")", ";", "emitExportImportAssignments", "(", "node", ")", ";", "emitTrailingComments", "(", "node", ")", ";", "}", "}", "function", "emitExportDeclaration", "(", "node", ")", "{", "ts", ".", "Debug", ".", "assert", "(", "modulekind", "!==", "4", "/* System */", ")", ";", "if", "(", "modulekind", "!==", "5", "/* ES6 */", ")", "{", "if", "(", "node", ".", "moduleSpecifier", "&&", "(", "!", "node", ".", "exportClause", "||", "resolver", ".", "isValueAliasDeclaration", "(", "node", ")", ")", ")", "{", "emitStart", "(", "node", ")", ";", "var", "generatedName", "=", "getGeneratedNameForNode", "(", "node", ")", ";", "if", "(", "node", ".", "exportClause", ")", "{", "// export { x, y, ... } from \"foo\"", "if", "(", "modulekind", "!==", "2", "/* AMD */", ")", "{", "write", "(", "\"var \"", ")", ";", "write", "(", "generatedName", ")", ";", "write", "(", "\" = \"", ")", ";", "emitRequire", "(", "ts", ".", "getExternalModuleName", "(", "node", ")", ")", ";", "write", "(", "\";\"", ")", ";", "}", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "node", ".", "exportClause", ".", "elements", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "specifier", "=", "_b", "[", "_a", "]", ";", "if", "(", "resolver", ".", "isValueAliasDeclaration", "(", "specifier", ")", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "specifier", ")", ";", "emitContainingModuleName", "(", "specifier", ")", ";", "write", "(", "\".\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "specifier", ".", "name", ")", ";", "write", "(", "\" = \"", ")", ";", "write", "(", "generatedName", ")", ";", "write", "(", "\".\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "specifier", ".", "propertyName", "||", "specifier", ".", "name", ")", ";", "write", "(", "\";\"", ")", ";", "emitEnd", "(", "specifier", ")", ";", "}", "}", "}", "else", "{", "// export * from \"foo\"", "writeLine", "(", ")", ";", "write", "(", "\"__export(\"", ")", ";", "if", "(", "modulekind", "!==", "2", "/* AMD */", ")", "{", "emitRequire", "(", "ts", ".", "getExternalModuleName", "(", "node", ")", ")", ";", "}", "else", "{", "write", "(", "generatedName", ")", ";", "}", "write", "(", "\");\"", ")", ";", "}", "emitEnd", "(", "node", ")", ";", "}", "}", "else", "{", "if", "(", "!", "node", ".", "exportClause", "||", "resolver", ".", "isValueAliasDeclaration", "(", "node", ")", ")", "{", "write", "(", "\"export \"", ")", ";", "if", "(", "node", ".", "exportClause", ")", "{", "// export { x, y, ... }", "write", "(", "\"{ \"", ")", ";", "emitExportOrImportSpecifierList", "(", "node", ".", "exportClause", ".", "elements", ",", "resolver", ".", "isValueAliasDeclaration", ")", ";", "write", "(", "\" }\"", ")", ";", "}", "else", "{", "write", "(", "\"*\"", ")", ";", "}", "if", "(", "node", ".", "moduleSpecifier", ")", "{", "write", "(", "\" from \"", ")", ";", "emit", "(", "node", ".", "moduleSpecifier", ")", ";", "}", "write", "(", "\";\"", ")", ";", "}", "}", "}", "function", "emitExportOrImportSpecifierList", "(", "specifiers", ",", "shouldEmit", ")", "{", "ts", ".", "Debug", ".", "assert", "(", "modulekind", "===", "5", "/* ES6 */", ")", ";", "var", "needsComma", "=", "false", ";", "for", "(", "var", "_a", "=", "0", ";", "_a", "<", "specifiers", ".", "length", ";", "_a", "++", ")", "{", "var", "specifier", "=", "specifiers", "[", "_a", "]", ";", "if", "(", "shouldEmit", "(", "specifier", ")", ")", "{", "if", "(", "needsComma", ")", "{", "write", "(", "\", \"", ")", ";", "}", "if", "(", "specifier", ".", "propertyName", ")", "{", "emit", "(", "specifier", ".", "propertyName", ")", ";", "write", "(", "\" as \"", ")", ";", "}", "emit", "(", "specifier", ".", "name", ")", ";", "needsComma", "=", "true", ";", "}", "}", "}", "function", "emitExportAssignment", "(", "node", ")", "{", "if", "(", "!", "node", ".", "isExportEquals", "&&", "resolver", ".", "isValueAliasDeclaration", "(", "node", ")", ")", "{", "if", "(", "modulekind", "===", "5", "/* ES6 */", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "node", ")", ";", "write", "(", "\"export default \"", ")", ";", "var", "expression", "=", "node", ".", "expression", ";", "emit", "(", "expression", ")", ";", "if", "(", "expression", ".", "kind", "!==", "213", "/* FunctionDeclaration */", "&&", "expression", ".", "kind", "!==", "214", "/* ClassDeclaration */", ")", "{", "write", "(", "\";\"", ")", ";", "}", "emitEnd", "(", "node", ")", ";", "}", "else", "{", "writeLine", "(", ")", ";", "emitStart", "(", "node", ")", ";", "if", "(", "modulekind", "===", "4", "/* System */", ")", "{", "write", "(", "exportFunctionForFile", "+", "\"(\\\"default\\\",\"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\")\"", ")", ";", "}", "else", "{", "emitEs6ExportDefaultCompat", "(", "node", ")", ";", "emitContainingModuleName", "(", "node", ")", ";", "if", "(", "languageVersion", "===", "0", "/* ES3 */", ")", "{", "write", "(", "\"[\\\"default\\\"] = \"", ")", ";", "}", "else", "{", "write", "(", "\".default = \"", ")", ";", "}", "emit", "(", "node", ".", "expression", ")", ";", "}", "write", "(", "\";\"", ")", ";", "emitEnd", "(", "node", ")", ";", "}", "}", "}", "function", "collectExternalModuleInfo", "(", "sourceFile", ")", "{", "externalImports", "=", "[", "]", ";", "exportSpecifiers", "=", "{", "}", ";", "exportEquals", "=", "undefined", ";", "hasExportStars", "=", "false", ";", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "sourceFile", ".", "statements", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "node", "=", "_b", "[", "_a", "]", ";", "switch", "(", "node", ".", "kind", ")", "{", "case", "222", "/* ImportDeclaration */", ":", "if", "(", "!", "node", ".", "importClause", "||", "resolver", ".", "isReferencedAliasDeclaration", "(", "node", ".", "importClause", ",", "/*checkChildren*/", "true", ")", ")", "{", "// import \"mod\"", "// import x from \"mod\" where x is referenced", "// import * as x from \"mod\" where x is referenced", "// import { x, y } from \"mod\" where at least one import is referenced", "externalImports", ".", "push", "(", "node", ")", ";", "}", "break", ";", "case", "221", "/* ImportEqualsDeclaration */", ":", "if", "(", "node", ".", "moduleReference", ".", "kind", "===", "232", "/* ExternalModuleReference */", "&&", "resolver", ".", "isReferencedAliasDeclaration", "(", "node", ")", ")", "{", "// import x = require(\"mod\") where x is referenced", "externalImports", ".", "push", "(", "node", ")", ";", "}", "break", ";", "case", "228", "/* ExportDeclaration */", ":", "if", "(", "node", ".", "moduleSpecifier", ")", "{", "if", "(", "!", "node", ".", "exportClause", ")", "{", "// export * from \"mod\"", "externalImports", ".", "push", "(", "node", ")", ";", "hasExportStars", "=", "true", ";", "}", "else", "if", "(", "resolver", ".", "isValueAliasDeclaration", "(", "node", ")", ")", "{", "// export { x, y } from \"mod\" where at least one export is a value symbol", "externalImports", ".", "push", "(", "node", ")", ";", "}", "}", "else", "{", "// export { x, y }", "for", "(", "var", "_c", "=", "0", ",", "_d", "=", "node", ".", "exportClause", ".", "elements", ";", "_c", "<", "_d", ".", "length", ";", "_c", "++", ")", "{", "var", "specifier", "=", "_d", "[", "_c", "]", ";", "var", "name_25", "=", "(", "specifier", ".", "propertyName", "||", "specifier", ".", "name", ")", ".", "text", ";", "(", "exportSpecifiers", "[", "name_25", "]", "||", "(", "exportSpecifiers", "[", "name_25", "]", "=", "[", "]", ")", ")", ".", "push", "(", "specifier", ")", ";", "}", "}", "break", ";", "case", "227", "/* ExportAssignment */", ":", "if", "(", "node", ".", "isExportEquals", "&&", "!", "exportEquals", ")", "{", "// export = x", "exportEquals", "=", "node", ";", "}", "break", ";", "}", "}", "}", "function", "emitExportStarHelper", "(", ")", "{", "if", "(", "hasExportStars", ")", "{", "writeLine", "(", ")", ";", "write", "(", "\"function __export(m) {\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\"", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "}", "}", "function", "getLocalNameForExternalImport", "(", "node", ")", "{", "var", "namespaceDeclaration", "=", "getNamespaceDeclarationNode", "(", "node", ")", ";", "if", "(", "namespaceDeclaration", "&&", "!", "isDefaultImport", "(", "node", ")", ")", "{", "return", "ts", ".", "getSourceTextOfNodeFromSourceFile", "(", "currentSourceFile", ",", "namespaceDeclaration", ".", "name", ")", ";", "}", "if", "(", "node", ".", "kind", "===", "222", "/* ImportDeclaration */", "&&", "node", ".", "importClause", ")", "{", "return", "getGeneratedNameForNode", "(", "node", ")", ";", "}", "if", "(", "node", ".", "kind", "===", "228", "/* ExportDeclaration */", "&&", "node", ".", "moduleSpecifier", ")", "{", "return", "getGeneratedNameForNode", "(", "node", ")", ";", "}", "}", "function", "getExternalModuleNameText", "(", "importNode", ")", "{", "var", "moduleName", "=", "ts", ".", "getExternalModuleName", "(", "importNode", ")", ";", "if", "(", "moduleName", ".", "kind", "===", "9", "/* StringLiteral */", ")", "{", "return", "tryRenameExternalModule", "(", "moduleName", ")", "||", "getLiteralText", "(", "moduleName", ")", ";", "}", "return", "undefined", ";", "}", "function", "emitVariableDeclarationsForImports", "(", ")", "{", "if", "(", "externalImports", ".", "length", "===", "0", ")", "{", "return", ";", "}", "writeLine", "(", ")", ";", "var", "started", "=", "false", ";", "for", "(", "var", "_a", "=", "0", ";", "_a", "<", "externalImports", ".", "length", ";", "_a", "++", ")", "{", "var", "importNode", "=", "externalImports", "[", "_a", "]", ";", "// do not create variable declaration for exports and imports that lack import clause", "var", "skipNode", "=", "importNode", ".", "kind", "===", "228", "/* ExportDeclaration */", "||", "(", "importNode", ".", "kind", "===", "222", "/* ImportDeclaration */", "&&", "!", "importNode", ".", "importClause", ")", ";", "if", "(", "skipNode", ")", "{", "continue", ";", "}", "if", "(", "!", "started", ")", "{", "write", "(", "\"var \"", ")", ";", "started", "=", "true", ";", "}", "else", "{", "write", "(", "\", \"", ")", ";", "}", "write", "(", "getLocalNameForExternalImport", "(", "importNode", ")", ")", ";", "}", "if", "(", "started", ")", "{", "write", "(", "\";\"", ")", ";", "}", "}", "function", "emitLocalStorageForExportedNamesIfNecessary", "(", "exportedDeclarations", ")", "{", "// when resolving exports local exported entries/indirect exported entries in the module", "// should always win over entries with similar names that were added via star exports", "// to support this we store names of local/indirect exported entries in a set.", "// this set is used to filter names brought by star expors.", "if", "(", "!", "hasExportStars", ")", "{", "// local names set is needed only in presence of star exports", "return", "undefined", ";", "}", "// local names set should only be added if we have anything exported", "if", "(", "!", "exportedDeclarations", "&&", "ts", ".", "isEmpty", "(", "exportSpecifiers", ")", ")", "{", "// no exported declarations (export var ...) or export specifiers (export {x})", "// check if we have any non star export declarations.", "var", "hasExportDeclarationWithExportClause", "=", "false", ";", "for", "(", "var", "_a", "=", "0", ";", "_a", "<", "externalImports", ".", "length", ";", "_a", "++", ")", "{", "var", "externalImport", "=", "externalImports", "[", "_a", "]", ";", "if", "(", "externalImport", ".", "kind", "===", "228", "/* ExportDeclaration */", "&&", "externalImport", ".", "exportClause", ")", "{", "hasExportDeclarationWithExportClause", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "hasExportDeclarationWithExportClause", ")", "{", "// we still need to emit exportStar helper", "return", "emitExportStarFunction", "(", "/*localNames*/", "undefined", ")", ";", "}", "}", "var", "exportedNamesStorageRef", "=", "makeUniqueName", "(", "\"exportedNames\"", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"var \"", "+", "exportedNamesStorageRef", "+", "\" = {\"", ")", ";", "increaseIndent", "(", ")", ";", "var", "started", "=", "false", ";", "if", "(", "exportedDeclarations", ")", "{", "for", "(", "var", "i", "=", "0", ";", "i", "<", "exportedDeclarations", ".", "length", ";", "++", "i", ")", "{", "// write name of exported declaration, i.e 'export var x...'", "writeExportedName", "(", "exportedDeclarations", "[", "i", "]", ")", ";", "}", "}", "if", "(", "exportSpecifiers", ")", "{", "for", "(", "var", "n", "in", "exportSpecifiers", ")", "{", "for", "(", "var", "_b", "=", "0", ",", "_c", "=", "exportSpecifiers", "[", "n", "]", ";", "_b", "<", "_c", ".", "length", ";", "_b", "++", ")", "{", "var", "specifier", "=", "_c", "[", "_b", "]", ";", "// write name of export specified, i.e. 'export {x}'", "writeExportedName", "(", "specifier", ".", "name", ")", ";", "}", "}", "}", "for", "(", "var", "_d", "=", "0", ";", "_d", "<", "externalImports", ".", "length", ";", "_d", "++", ")", "{", "var", "externalImport", "=", "externalImports", "[", "_d", "]", ";", "if", "(", "externalImport", ".", "kind", "!==", "228", "/* ExportDeclaration */", ")", "{", "continue", ";", "}", "var", "exportDecl", "=", "externalImport", ";", "if", "(", "!", "exportDecl", ".", "exportClause", ")", "{", "// export * from ...", "continue", ";", "}", "for", "(", "var", "_e", "=", "0", ",", "_f", "=", "exportDecl", ".", "exportClause", ".", "elements", ";", "_e", "<", "_f", ".", "length", ";", "_e", "++", ")", "{", "var", "element", "=", "_f", "[", "_e", "]", ";", "// write name of indirectly exported entry, i.e. 'export {x} from ...'", "writeExportedName", "(", "element", ".", "name", "||", "element", ".", "propertyName", ")", ";", "}", "}", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"};\"", ")", ";", "return", "emitExportStarFunction", "(", "exportedNamesStorageRef", ")", ";", "function", "emitExportStarFunction", "(", "localNames", ")", "{", "var", "exportStarFunction", "=", "makeUniqueName", "(", "\"exportStar\"", ")", ";", "writeLine", "(", ")", ";", "// define an export star helper function", "write", "(", "\"function \"", "+", "exportStarFunction", "+", "\"(m) {\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"var exports = {};\"", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"for(var n in m) {\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"if (n !== \\\"default\\\"\"", ")", ";", "if", "(", "localNames", ")", "{", "write", "(", "\"&& !\"", "+", "localNames", "+", "\".hasOwnProperty(n)\"", ")", ";", "}", "write", "(", "\") exports[n] = m[n];\"", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "writeLine", "(", ")", ";", "write", "(", "exportFunctionForFile", "+", "\"(exports);\"", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "return", "exportStarFunction", ";", "}", "function", "writeExportedName", "(", "node", ")", "{", "// do not record default exports", "// they are local to module and never overwritten (explicitly skipped) by star export", "if", "(", "node", ".", "kind", "!==", "69", "/* Identifier */", "&&", "node", ".", "flags", "&", "1024", "/* Default */", ")", "{", "return", ";", "}", "if", "(", "started", ")", "{", "write", "(", "\",\"", ")", ";", "}", "else", "{", "started", "=", "true", ";", "}", "writeLine", "(", ")", ";", "write", "(", "\"'\"", ")", ";", "if", "(", "node", ".", "kind", "===", "69", "/* Identifier */", ")", "{", "emitNodeWithCommentsAndWithoutSourcemap", "(", "node", ")", ";", "}", "else", "{", "emitDeclarationName", "(", "node", ")", ";", "}", "write", "(", "\"': true\"", ")", ";", "}", "}", "function", "processTopLevelVariableAndFunctionDeclarations", "(", "node", ")", "{", "// per ES6 spec:", "// 15.2.1.16.4 ModuleDeclarationInstantiation() Concrete Method", "// - var declarations are initialized to undefined - 14.a.ii", "// - function/generator declarations are instantiated - 16.a.iv", "// this means that after module is instantiated but before its evaluation", "// exported functions are already accessible at import sites", "// in theory we should hoist only exported functions and its dependencies", "// in practice to simplify things we'll hoist all source level functions and variable declaration", "// including variables declarations for module and class declarations", "var", "hoistedVars", ";", "var", "hoistedFunctionDeclarations", ";", "var", "exportedDeclarations", ";", "visit", "(", "node", ")", ";", "if", "(", "hoistedVars", ")", "{", "writeLine", "(", ")", ";", "write", "(", "\"var \"", ")", ";", "var", "seen", "=", "{", "}", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "hoistedVars", ".", "length", ";", "++", "i", ")", "{", "var", "local", "=", "hoistedVars", "[", "i", "]", ";", "var", "name_26", "=", "local", ".", "kind", "===", "69", "/* Identifier */", "?", "local", ":", "local", ".", "name", ";", "if", "(", "name_26", ")", "{", "// do not emit duplicate entries (in case of declaration merging) in the list of hoisted variables", "var", "text", "=", "ts", ".", "unescapeIdentifier", "(", "name_26", ".", "text", ")", ";", "if", "(", "ts", ".", "hasProperty", "(", "seen", ",", "text", ")", ")", "{", "continue", ";", "}", "else", "{", "seen", "[", "text", "]", "=", "text", ";", "}", "}", "if", "(", "i", "!==", "0", ")", "{", "write", "(", "\", \"", ")", ";", "}", "if", "(", "local", ".", "kind", "===", "214", "/* ClassDeclaration */", "||", "local", ".", "kind", "===", "218", "/* ModuleDeclaration */", "||", "local", ".", "kind", "===", "217", "/* EnumDeclaration */", ")", "{", "emitDeclarationName", "(", "local", ")", ";", "}", "else", "{", "emit", "(", "local", ")", ";", "}", "var", "flags", "=", "ts", ".", "getCombinedNodeFlags", "(", "local", ".", "kind", "===", "69", "/* Identifier */", "?", "local", ".", "parent", ":", "local", ")", ";", "if", "(", "flags", "&", "1", "/* Export */", ")", "{", "if", "(", "!", "exportedDeclarations", ")", "{", "exportedDeclarations", "=", "[", "]", ";", "}", "exportedDeclarations", ".", "push", "(", "local", ")", ";", "}", "}", "write", "(", "\";\"", ")", ";", "}", "if", "(", "hoistedFunctionDeclarations", ")", "{", "for", "(", "var", "_a", "=", "0", ";", "_a", "<", "hoistedFunctionDeclarations", ".", "length", ";", "_a", "++", ")", "{", "var", "f", "=", "hoistedFunctionDeclarations", "[", "_a", "]", ";", "writeLine", "(", ")", ";", "emit", "(", "f", ")", ";", "if", "(", "f", ".", "flags", "&", "1", "/* Export */", ")", "{", "if", "(", "!", "exportedDeclarations", ")", "{", "exportedDeclarations", "=", "[", "]", ";", "}", "exportedDeclarations", ".", "push", "(", "f", ")", ";", "}", "}", "}", "return", "exportedDeclarations", ";", "function", "visit", "(", "node", ")", "{", "if", "(", "node", ".", "flags", "&", "2", "/* Ambient */", ")", "{", "return", ";", "}", "if", "(", "node", ".", "kind", "===", "213", "/* FunctionDeclaration */", ")", "{", "if", "(", "!", "hoistedFunctionDeclarations", ")", "{", "hoistedFunctionDeclarations", "=", "[", "]", ";", "}", "hoistedFunctionDeclarations", ".", "push", "(", "node", ")", ";", "return", ";", "}", "if", "(", "node", ".", "kind", "===", "214", "/* ClassDeclaration */", ")", "{", "if", "(", "!", "hoistedVars", ")", "{", "hoistedVars", "=", "[", "]", ";", "}", "hoistedVars", ".", "push", "(", "node", ")", ";", "return", ";", "}", "if", "(", "node", ".", "kind", "===", "217", "/* EnumDeclaration */", ")", "{", "if", "(", "shouldEmitEnumDeclaration", "(", "node", ")", ")", "{", "if", "(", "!", "hoistedVars", ")", "{", "hoistedVars", "=", "[", "]", ";", "}", "hoistedVars", ".", "push", "(", "node", ")", ";", "}", "return", ";", "}", "if", "(", "node", ".", "kind", "===", "218", "/* ModuleDeclaration */", ")", "{", "if", "(", "shouldEmitModuleDeclaration", "(", "node", ")", ")", "{", "if", "(", "!", "hoistedVars", ")", "{", "hoistedVars", "=", "[", "]", ";", "}", "hoistedVars", ".", "push", "(", "node", ")", ";", "}", "return", ";", "}", "if", "(", "node", ".", "kind", "===", "211", "/* VariableDeclaration */", "||", "node", ".", "kind", "===", "163", "/* BindingElement */", ")", "{", "if", "(", "shouldHoistVariable", "(", "node", ",", "/*checkIfSourceFileLevelDecl*/", "false", ")", ")", "{", "var", "name_27", "=", "node", ".", "name", ";", "if", "(", "name_27", ".", "kind", "===", "69", "/* Identifier */", ")", "{", "if", "(", "!", "hoistedVars", ")", "{", "hoistedVars", "=", "[", "]", ";", "}", "hoistedVars", ".", "push", "(", "name_27", ")", ";", "}", "else", "{", "ts", ".", "forEachChild", "(", "name_27", ",", "visit", ")", ";", "}", "}", "return", ";", "}", "if", "(", "ts", ".", "isInternalModuleImportEqualsDeclaration", "(", "node", ")", "&&", "resolver", ".", "isValueAliasDeclaration", "(", "node", ")", ")", "{", "if", "(", "!", "hoistedVars", ")", "{", "hoistedVars", "=", "[", "]", ";", "}", "hoistedVars", ".", "push", "(", "node", ".", "name", ")", ";", "return", ";", "}", "if", "(", "ts", ".", "isBindingPattern", "(", "node", ")", ")", "{", "ts", ".", "forEach", "(", "node", ".", "elements", ",", "visit", ")", ";", "return", ";", "}", "if", "(", "!", "ts", ".", "isDeclaration", "(", "node", ")", ")", "{", "ts", ".", "forEachChild", "(", "node", ",", "visit", ")", ";", "}", "}", "}", "function", "shouldHoistVariable", "(", "node", ",", "checkIfSourceFileLevelDecl", ")", "{", "if", "(", "checkIfSourceFileLevelDecl", "&&", "!", "shouldHoistDeclarationInSystemJsModule", "(", "node", ")", ")", "{", "return", "false", ";", "}", "// hoist variable if", "// - it is not block scoped", "// - it is top level block scoped", "// if block scoped variables are nested in some another block then", "// no other functions can use them except ones that are defined at least in the same block", "return", "(", "ts", ".", "getCombinedNodeFlags", "(", "node", ")", "&", "49152", "/* BlockScoped */", ")", "===", "0", "||", "ts", ".", "getEnclosingBlockScopeContainer", "(", "node", ")", ".", "kind", "===", "248", "/* SourceFile */", ";", "}", "function", "isCurrentFileSystemExternalModule", "(", ")", "{", "return", "modulekind", "===", "4", "/* System */", "&&", "ts", ".", "isExternalModule", "(", "currentSourceFile", ")", ";", "}", "function", "emitSystemModuleBody", "(", "node", ",", "dependencyGroups", ",", "startIndex", ")", "{", "// shape of the body in system modules:", "// function (exports) {", "//     <list of local aliases for imports>", "//     <hoisted function declarations>", "//     <hoisted variable declarations>", "//     return {", "//         setters: [", "//             <list of setter function for imports>", "//         ],", "//         execute: function() {", "//             <module statements>", "//         }", "//     }", "//     <temp declarations>", "// }", "// I.e:", "// import {x} from 'file1'", "// var y = 1;", "// export function foo() { return y + x(); }", "// console.log(y);", "// will be transformed to", "// function(exports) {", "//     var file1; // local alias", "//     var y;", "//     function foo() { return y + file1.x(); }", "//     exports(\"foo\", foo);", "//     return {", "//         setters: [", "//             function(v) { file1 = v }", "//         ],", "//         execute(): function() {", "//             y = 1;", "//             console.log(y);", "//         }", "//     };", "// }", "emitVariableDeclarationsForImports", "(", ")", ";", "writeLine", "(", ")", ";", "var", "exportedDeclarations", "=", "processTopLevelVariableAndFunctionDeclarations", "(", "node", ")", ";", "var", "exportStarFunction", "=", "emitLocalStorageForExportedNamesIfNecessary", "(", "exportedDeclarations", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"return {\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "emitSetters", "(", "exportStarFunction", ",", "dependencyGroups", ")", ";", "writeLine", "(", ")", ";", "emitExecute", "(", "node", ",", "startIndex", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "// return", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "}", "function", "emitSetters", "(", "exportStarFunction", ",", "dependencyGroups", ")", "{", "write", "(", "\"setters:[\"", ")", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "dependencyGroups", ".", "length", ";", "++", "i", ")", "{", "if", "(", "i", "!==", "0", ")", "{", "write", "(", "\",\"", ")", ";", "}", "writeLine", "(", ")", ";", "increaseIndent", "(", ")", ";", "var", "group", "=", "dependencyGroups", "[", "i", "]", ";", "// derive a unique name for parameter from the first named entry in the group", "var", "parameterName", "=", "makeUniqueName", "(", "ts", ".", "forEach", "(", "group", ",", "getLocalNameForExternalImport", ")", "||", "\"\"", ")", ";", "write", "(", "\"function (\"", "+", "parameterName", "+", "\") {\"", ")", ";", "increaseIndent", "(", ")", ";", "for", "(", "var", "_a", "=", "0", ";", "_a", "<", "group", ".", "length", ";", "_a", "++", ")", "{", "var", "entry", "=", "group", "[", "_a", "]", ";", "var", "importVariableName", "=", "getLocalNameForExternalImport", "(", "entry", ")", "||", "\"\"", ";", "switch", "(", "entry", ".", "kind", ")", "{", "case", "222", "/* ImportDeclaration */", ":", "if", "(", "!", "entry", ".", "importClause", ")", "{", "// 'import \"...\"' case", "// module is imported only for side-effects, no emit required", "break", ";", "}", "// fall-through", "case", "221", "/* ImportEqualsDeclaration */", ":", "ts", ".", "Debug", ".", "assert", "(", "importVariableName", "!==", "\"\"", ")", ";", "writeLine", "(", ")", ";", "// save import into the local", "write", "(", "importVariableName", "+", "\" = \"", "+", "parameterName", "+", "\";\"", ")", ";", "writeLine", "(", ")", ";", "break", ";", "case", "228", "/* ExportDeclaration */", ":", "ts", ".", "Debug", ".", "assert", "(", "importVariableName", "!==", "\"\"", ")", ";", "if", "(", "entry", ".", "exportClause", ")", "{", "// export {a, b as c} from 'foo'", "// emit as:", "// exports_({", "//    \"a\": _[\"a\"],", "//    \"c\": _[\"b\"]", "// });", "writeLine", "(", ")", ";", "write", "(", "exportFunctionForFile", "+", "\"({\"", ")", ";", "writeLine", "(", ")", ";", "increaseIndent", "(", ")", ";", "for", "(", "var", "i_2", "=", "0", ",", "len", "=", "entry", ".", "exportClause", ".", "elements", ".", "length", ";", "i_2", "<", "len", ";", "++", "i_2", ")", "{", "if", "(", "i_2", "!==", "0", ")", "{", "write", "(", "\",\"", ")", ";", "writeLine", "(", ")", ";", "}", "var", "e", "=", "entry", ".", "exportClause", ".", "elements", "[", "i_2", "]", ";", "write", "(", "\"\\\"\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "e", ".", "name", ")", ";", "write", "(", "\"\\\": \"", "+", "parameterName", "+", "\"[\\\"\"", ")", ";", "emitNodeWithCommentsAndWithoutSourcemap", "(", "e", ".", "propertyName", "||", "e", ".", "name", ")", ";", "write", "(", "\"\\\"]\"", ")", ";", "}", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"});\"", ")", ";", "}", "else", "{", "writeLine", "(", ")", ";", "// export * from 'foo'", "// emit as:", "// exportStar(_foo);", "write", "(", "exportStarFunction", "+", "\"(\"", "+", "parameterName", "+", "\");\"", ")", ";", "}", "writeLine", "(", ")", ";", "break", ";", "}", "}", "decreaseIndent", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "decreaseIndent", "(", ")", ";", "}", "write", "(", "\"],\"", ")", ";", "}", "function", "emitExecute", "(", "node", ",", "startIndex", ")", "{", "write", "(", "\"execute: function() {\"", ")", ";", "increaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "for", "(", "var", "i", "=", "startIndex", ";", "i", "<", "node", ".", "statements", ".", "length", ";", "++", "i", ")", "{", "var", "statement", "=", "node", ".", "statements", "[", "i", "]", ";", "switch", "(", "statement", ".", "kind", ")", "{", "// - function declarations are not emitted because they were already hoisted", "// - import declarations are not emitted since they are already handled in setters", "// - export declarations with module specifiers are not emitted since they were already written in setters", "// - export declarations without module specifiers are emitted preserving the order", "case", "213", "/* FunctionDeclaration */", ":", "case", "222", "/* ImportDeclaration */", ":", "continue", ";", "case", "228", "/* ExportDeclaration */", ":", "if", "(", "!", "statement", ".", "moduleSpecifier", ")", "{", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "statement", ".", "exportClause", ".", "elements", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "element", "=", "_b", "[", "_a", "]", ";", "// write call to exporter function for every export specifier in exports list", "emitExportSpecifierInSystemModule", "(", "element", ")", ";", "}", "}", "continue", ";", "case", "221", "/* ImportEqualsDeclaration */", ":", "if", "(", "!", "ts", ".", "isInternalModuleImportEqualsDeclaration", "(", "statement", ")", ")", "{", "// - import equals declarations that import external modules are not emitted", "continue", ";", "}", "// fall-though for import declarations that import internal modules", "default", ":", "writeLine", "(", ")", ";", "emit", "(", "statement", ")", ";", "}", "}", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"}\"", ")", ";", "// execute", "}", "function", "emitSystemModule", "(", "node", ")", "{", "collectExternalModuleInfo", "(", "node", ")", ";", "// System modules has the following shape", "// System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})", "// 'exports' here is a function 'exports<T>(name: string, value: T): T' that is used to publish exported values.", "// 'exports' returns its 'value' argument so in most cases expressions", "// that mutate exported values can be rewritten as:", "// expr -> exports('name', expr).", "// The only exception in this rule is postfix unary operators,", "// see comment to 'emitPostfixUnaryExpression' for more details", "ts", ".", "Debug", ".", "assert", "(", "!", "exportFunctionForFile", ")", ";", "// make sure that  name of 'exports' function does not conflict with existing identifiers", "exportFunctionForFile", "=", "makeUniqueName", "(", "\"exports\"", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"System.register(\"", ")", ";", "if", "(", "node", ".", "moduleName", ")", "{", "write", "(", "\"\\\"\"", "+", "node", ".", "moduleName", "+", "\"\\\", \"", ")", ";", "}", "write", "(", "\"[\"", ")", ";", "var", "groupIndices", "=", "{", "}", ";", "var", "dependencyGroups", "=", "[", "]", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "externalImports", ".", "length", ";", "++", "i", ")", "{", "var", "text", "=", "getExternalModuleNameText", "(", "externalImports", "[", "i", "]", ")", ";", "if", "(", "ts", ".", "hasProperty", "(", "groupIndices", ",", "text", ")", ")", "{", "// deduplicate/group entries in dependency list by the dependency name", "var", "groupIndex", "=", "groupIndices", "[", "text", "]", ";", "dependencyGroups", "[", "groupIndex", "]", ".", "push", "(", "externalImports", "[", "i", "]", ")", ";", "continue", ";", "}", "else", "{", "groupIndices", "[", "text", "]", "=", "dependencyGroups", ".", "length", ";", "dependencyGroups", ".", "push", "(", "[", "externalImports", "[", "i", "]", "]", ")", ";", "}", "if", "(", "i", "!==", "0", ")", "{", "write", "(", "\", \"", ")", ";", "}", "write", "(", "text", ")", ";", "}", "write", "(", "\"], function(\"", "+", "exportFunctionForFile", "+", "\") {\"", ")", ";", "writeLine", "(", ")", ";", "increaseIndent", "(", ")", ";", "var", "startIndex", "=", "emitDirectivePrologues", "(", "node", ".", "statements", ",", "/*startWithNewLine*/", "true", ")", ";", "emitEmitHelpers", "(", "node", ")", ";", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "emitSystemModuleBody", "(", "node", ",", "dependencyGroups", ",", "startIndex", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"});\"", ")", ";", "}", "function", "getAMDDependencyNames", "(", "node", ",", "includeNonAmdDependencies", ")", "{", "// names of modules with corresponding parameter in the factory function", "var", "aliasedModuleNames", "=", "[", "]", ";", "// names of modules with no corresponding parameters in factory function", "var", "unaliasedModuleNames", "=", "[", "]", ";", "var", "importAliasNames", "=", "[", "]", ";", "// names of the parameters in the factory function; these", "// parameters need to match the indexes of the corresponding", "// module names in aliasedModuleNames.", "// Fill in amd-dependency tags", "for", "(", "var", "_a", "=", "0", ",", "_b", "=", "node", ".", "amdDependencies", ";", "_a", "<", "_b", ".", "length", ";", "_a", "++", ")", "{", "var", "amdDependency", "=", "_b", "[", "_a", "]", ";", "if", "(", "amdDependency", ".", "name", ")", "{", "aliasedModuleNames", ".", "push", "(", "\"\\\"\"", "+", "amdDependency", ".", "path", "+", "\"\\\"\"", ")", ";", "importAliasNames", ".", "push", "(", "amdDependency", ".", "name", ")", ";", "}", "else", "{", "unaliasedModuleNames", ".", "push", "(", "\"\\\"\"", "+", "amdDependency", ".", "path", "+", "\"\\\"\"", ")", ";", "}", "}", "for", "(", "var", "_c", "=", "0", ";", "_c", "<", "externalImports", ".", "length", ";", "_c", "++", ")", "{", "var", "importNode", "=", "externalImports", "[", "_c", "]", ";", "// Find the name of the external module", "var", "externalModuleName", "=", "getExternalModuleNameText", "(", "importNode", ")", ";", "// Find the name of the module alias, if there is one", "var", "importAliasName", "=", "getLocalNameForExternalImport", "(", "importNode", ")", ";", "if", "(", "includeNonAmdDependencies", "&&", "importAliasName", ")", "{", "aliasedModuleNames", ".", "push", "(", "externalModuleName", ")", ";", "importAliasNames", ".", "push", "(", "importAliasName", ")", ";", "}", "else", "{", "unaliasedModuleNames", ".", "push", "(", "externalModuleName", ")", ";", "}", "}", "return", "{", "aliasedModuleNames", ":", "aliasedModuleNames", ",", "unaliasedModuleNames", ":", "unaliasedModuleNames", ",", "importAliasNames", ":", "importAliasNames", "}", ";", "}", "function", "emitAMDDependencies", "(", "node", ",", "includeNonAmdDependencies", ")", "{", "// An AMD define function has the following shape:", "//     define(id?, dependencies?, factory);", "//", "// This has the shape of", "//     define(name, [\"module1\", \"module2\"], function (module1Alias) {", "// The location of the alias in the parameter list in the factory function needs to", "// match the position of the module name in the dependency list.", "//", "// To ensure this is true in cases of modules with no aliases, e.g.:", "// `import \"module\"` or `<amd-dependency path= \"a.css\" />`", "// we need to add modules without alias names to the end of the dependencies list", "var", "dependencyNames", "=", "getAMDDependencyNames", "(", "node", ",", "includeNonAmdDependencies", ")", ";", "emitAMDDependencyList", "(", "dependencyNames", ")", ";", "write", "(", "\", \"", ")", ";", "emitAMDFactoryHeader", "(", "dependencyNames", ")", ";", "}", "function", "emitAMDDependencyList", "(", "_a", ")", "{", "var", "aliasedModuleNames", "=", "_a", ".", "aliasedModuleNames", ",", "unaliasedModuleNames", "=", "_a", ".", "unaliasedModuleNames", ";", "write", "(", "\"[\\\"require\\\", \\\"exports\\\"\"", ")", ";", "if", "(", "aliasedModuleNames", ".", "length", ")", "{", "write", "(", "\", \"", ")", ";", "write", "(", "aliasedModuleNames", ".", "join", "(", "\", \"", ")", ")", ";", "}", "if", "(", "unaliasedModuleNames", ".", "length", ")", "{", "write", "(", "\", \"", ")", ";", "write", "(", "unaliasedModuleNames", ".", "join", "(", "\", \"", ")", ")", ";", "}", "write", "(", "\"]\"", ")", ";", "}", "function", "emitAMDFactoryHeader", "(", "_a", ")", "{", "var", "importAliasNames", "=", "_a", ".", "importAliasNames", ";", "write", "(", "\"function (require, exports\"", ")", ";", "if", "(", "importAliasNames", ".", "length", ")", "{", "write", "(", "\", \"", ")", ";", "write", "(", "importAliasNames", ".", "join", "(", "\", \"", ")", ")", ";", "}", "write", "(", "\") {\"", ")", ";", "}", "function", "emitAMDModule", "(", "node", ")", "{", "emitEmitHelpers", "(", "node", ")", ";", "collectExternalModuleInfo", "(", "node", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"define(\"", ")", ";", "if", "(", "node", ".", "moduleName", ")", "{", "write", "(", "\"\\\"\"", "+", "node", ".", "moduleName", "+", "\"\\\", \"", ")", ";", "}", "emitAMDDependencies", "(", "node", ",", "/*includeNonAmdDependencies*/", "true", ")", ";", "increaseIndent", "(", ")", ";", "var", "startIndex", "=", "emitDirectivePrologues", "(", "node", ".", "statements", ",", "/*startWithNewLine*/", "true", ")", ";", "emitExportStarHelper", "(", ")", ";", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "emitLinesStartingAt", "(", "node", ".", "statements", ",", "startIndex", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "emitExportEquals", "(", "/*emitAsReturn*/", "true", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"});\"", ")", ";", "}", "function", "emitCommonJSModule", "(", "node", ")", "{", "var", "startIndex", "=", "emitDirectivePrologues", "(", "node", ".", "statements", ",", "/*startWithNewLine*/", "false", ")", ";", "emitEmitHelpers", "(", "node", ")", ";", "collectExternalModuleInfo", "(", "node", ")", ";", "emitExportStarHelper", "(", ")", ";", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "emitLinesStartingAt", "(", "node", ".", "statements", ",", "startIndex", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "emitExportEquals", "(", "/*emitAsReturn*/", "false", ")", ";", "}", "function", "emitUMDModule", "(", "node", ")", "{", "emitEmitHelpers", "(", "node", ")", ";", "collectExternalModuleInfo", "(", "node", ")", ";", "var", "dependencyNames", "=", "getAMDDependencyNames", "(", "node", ",", "/*includeNonAmdDependencies*/", "false", ")", ";", "// Module is detected first to support Browserify users that load into a browser with an AMD loader", "writeLines", "(", "\"(function (factory) {\\n    if (typeof module === 'object' && typeof module.exports === 'object') {\\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\\n    }\\n    else if (typeof define === 'function' && define.amd) {\\n        define(\"", ")", ";", "emitAMDDependencyList", "(", "dependencyNames", ")", ";", "write", "(", "\", factory);\"", ")", ";", "writeLines", "(", "\"    }\\n})(\"", ")", ";", "emitAMDFactoryHeader", "(", "dependencyNames", ")", ";", "increaseIndent", "(", ")", ";", "var", "startIndex", "=", "emitDirectivePrologues", "(", "node", ".", "statements", ",", "/*startWithNewLine*/", "true", ")", ";", "emitExportStarHelper", "(", ")", ";", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "emitLinesStartingAt", "(", "node", ".", "statements", ",", "startIndex", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "emitExportEquals", "(", "/*emitAsReturn*/", "true", ")", ";", "decreaseIndent", "(", ")", ";", "writeLine", "(", ")", ";", "write", "(", "\"});\"", ")", ";", "}", "function", "emitES6Module", "(", "node", ")", "{", "externalImports", "=", "undefined", ";", "exportSpecifiers", "=", "undefined", ";", "exportEquals", "=", "undefined", ";", "hasExportStars", "=", "false", ";", "var", "startIndex", "=", "emitDirectivePrologues", "(", "node", ".", "statements", ",", "/*startWithNewLine*/", "false", ")", ";", "emitEmitHelpers", "(", "node", ")", ";", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "emitLinesStartingAt", "(", "node", ".", "statements", ",", "startIndex", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "// Emit exportDefault if it exists will happen as part", "// or normal statement emit.", "}", "function", "emitExportEquals", "(", "emitAsReturn", ")", "{", "if", "(", "exportEquals", "&&", "resolver", ".", "isValueAliasDeclaration", "(", "exportEquals", ")", ")", "{", "writeLine", "(", ")", ";", "emitStart", "(", "exportEquals", ")", ";", "write", "(", "emitAsReturn", "?", "\"return \"", ":", "\"module.exports = \"", ")", ";", "emit", "(", "exportEquals", ".", "expression", ")", ";", "write", "(", "\";\"", ")", ";", "emitEnd", "(", "exportEquals", ")", ";", "}", "}", "function", "emitJsxElement", "(", "node", ")", "{", "switch", "(", "compilerOptions", ".", "jsx", ")", "{", "case", "2", "/* React */", ":", "jsxEmitReact", "(", "node", ")", ";", "break", ";", "case", "1", "/* Preserve */", ":", "// Fall back to preserve if None was specified (we'll error earlier)", "default", ":", "jsxEmitPreserve", "(", "node", ")", ";", "break", ";", "}", "}", "function", "trimReactWhitespaceAndApplyEntities", "(", "node", ")", "{", "var", "result", "=", "undefined", ";", "var", "text", "=", "ts", ".", "getTextOfNode", "(", "node", ",", "/*includeTrivia*/", "true", ")", ";", "var", "firstNonWhitespace", "=", "0", ";", "var", "lastNonWhitespace", "=", "-", "1", ";", "// JSX trims whitespace at the end and beginning of lines, except that the", "// start/end of a tag is considered a start/end of a line only if that line is", "// on the same line as the closing tag. See examples in tests/cases/conformance/jsx/tsxReactEmitWhitespace.tsx", "for", "(", "var", "i", "=", "0", ";", "i", "<", "text", ".", "length", ";", "i", "++", ")", "{", "var", "c", "=", "text", ".", "charCodeAt", "(", "i", ")", ";", "if", "(", "ts", ".", "isLineBreak", "(", "c", ")", ")", "{", "if", "(", "firstNonWhitespace", "!==", "-", "1", "&&", "(", "lastNonWhitespace", "-", "firstNonWhitespace", "+", "1", ">", "0", ")", ")", "{", "var", "part", "=", "text", ".", "substr", "(", "firstNonWhitespace", ",", "lastNonWhitespace", "-", "firstNonWhitespace", "+", "1", ")", ";", "result", "=", "(", "result", "?", "result", "+", "\"\\\" + ' ' + \\\"\"", ":", "\"\"", ")", "+", "ts", ".", "escapeString", "(", "part", ")", ";", "}", "firstNonWhitespace", "=", "-", "1", ";", "}", "else", "if", "(", "!", "ts", ".", "isWhiteSpace", "(", "c", ")", ")", "{", "lastNonWhitespace", "=", "i", ";", "if", "(", "firstNonWhitespace", "===", "-", "1", ")", "{", "firstNonWhitespace", "=", "i", ";", "}", "}", "}", "if", "(", "firstNonWhitespace", "!==", "-", "1", ")", "{", "var", "part", "=", "text", ".", "substr", "(", "firstNonWhitespace", ")", ";", "result", "=", "(", "result", "?", "result", "+", "\"\\\" + ' ' + \\\"\"", ":", "\"\"", ")", "+", "ts", ".", "escapeString", "(", "part", ")", ";", "}", "if", "(", "result", ")", "{", "// Replace entities like &nbsp;", "result", "=", "result", ".", "replace", "(", "/", "&(\\w+);", "/", "g", ",", "function", "(", "s", ",", "m", ")", "{", "if", "(", "entities", "[", "m", "]", "!==", "undefined", ")", "{", "return", "String", ".", "fromCharCode", "(", "entities", "[", "m", "]", ")", ";", "}", "else", "{", "return", "s", ";", "}", "}", ")", ";", "}", "return", "result", ";", "}", "function", "getTextToEmit", "(", "node", ")", "{", "switch", "(", "compilerOptions", ".", "jsx", ")", "{", "case", "2", "/* React */", ":", "var", "text", "=", "trimReactWhitespaceAndApplyEntities", "(", "node", ")", ";", "if", "(", "text", "===", "undefined", "||", "text", ".", "length", "===", "0", ")", "{", "return", "undefined", ";", "}", "else", "{", "return", "text", ";", "}", "case", "1", "/* Preserve */", ":", "default", ":", "return", "ts", ".", "getTextOfNode", "(", "node", ",", "/*includeTrivia*/", "true", ")", ";", "}", "}", "function", "emitJsxText", "(", "node", ")", "{", "switch", "(", "compilerOptions", ".", "jsx", ")", "{", "case", "2", "/* React */", ":", "write", "(", "\"\\\"\"", ")", ";", "write", "(", "trimReactWhitespaceAndApplyEntities", "(", "node", ")", ")", ";", "write", "(", "\"\\\"\"", ")", ";", "break", ";", "case", "1", "/* Preserve */", ":", "default", ":", "writer", ".", "writeLiteral", "(", "ts", ".", "getTextOfNode", "(", "node", ",", "/*includeTrivia*/", "true", ")", ")", ";", "break", ";", "}", "}", "function", "emitJsxExpression", "(", "node", ")", "{", "if", "(", "node", ".", "expression", ")", "{", "switch", "(", "compilerOptions", ".", "jsx", ")", "{", "case", "1", "/* Preserve */", ":", "default", ":", "write", "(", "\"{\"", ")", ";", "emit", "(", "node", ".", "expression", ")", ";", "write", "(", "\"}\"", ")", ";", "break", ";", "case", "2", "/* React */", ":", "emit", "(", "node", ".", "expression", ")", ";", "break", ";", "}", "}", "}", "function", "emitDirectivePrologues", "(", "statements", ",", "startWithNewLine", ")", "{", "for", "(", "var", "i", "=", "0", ";", "i", "<", "statements", ".", "length", ";", "++", "i", ")", "{", "if", "(", "ts", ".", "isPrologueDirective", "(", "statements", "[", "i", "]", ")", ")", "{", "if", "(", "startWithNewLine", "||", "i", ">", "0", ")", "{", "writeLine", "(", ")", ";", "}", "emit", "(", "statements", "[", "i", "]", ")", ";", "}", "else", "{", "// return index of the first non prologue directive", "return", "i", ";", "}", "}", "return", "statements", ".", "length", ";", "}", "function", "writeLines", "(", "text", ")", "{", "var", "lines", "=", "text", ".", "split", "(", "/", "\\r\\n|\\r|\\n", "/", "g", ")", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "lines", ".", "length", ";", "++", "i", ")", "{", "var", "line", "=", "lines", "[", "i", "]", ";", "if", "(", "line", ".", "length", ")", "{", "writeLine", "(", ")", ";", "write", "(", "line", ")", ";", "}", "}", "}", "function", "emitEmitHelpers", "(", "node", ")", "{", "// Only emit helpers if the user did not say otherwise.", "if", "(", "!", "compilerOptions", ".", "noEmitHelpers", ")", "{", "// Only Emit __extends function when target ES5.", "// For target ES6 and above, we can emit classDeclaration as is.", "if", "(", "(", "languageVersion", "<", "2", "/* ES6 */", ")", "&&", "(", "!", "extendsEmitted", "&&", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "8", "/* EmitExtends */", ")", ")", "{", "writeLines", "(", "extendsHelper", ")", ";", "extendsEmitted", "=", "true", ";", "}", "if", "(", "!", "decorateEmitted", "&&", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "16", "/* EmitDecorate */", ")", "{", "writeLines", "(", "decorateHelper", ")", ";", "if", "(", "compilerOptions", ".", "emitDecoratorMetadata", ")", "{", "writeLines", "(", "metadataHelper", ")", ";", "}", "decorateEmitted", "=", "true", ";", "}", "if", "(", "!", "paramEmitted", "&&", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "32", "/* EmitParam */", ")", "{", "writeLines", "(", "paramHelper", ")", ";", "paramEmitted", "=", "true", ";", "}", "if", "(", "!", "awaiterEmitted", "&&", "resolver", ".", "getNodeCheckFlags", "(", "node", ")", "&", "64", "/* EmitAwaiter */", ")", "{", "writeLines", "(", "awaiterHelper", ")", ";", "awaiterEmitted", "=", "true", ";", "}", "}", "}", "function", "emitSourceFileNode", "(", "node", ")", "{", "// Start new file on new line", "writeLine", "(", ")", ";", "emitShebang", "(", ")", ";", "emitDetachedComments", "(", "node", ")", ";", "if", "(", "ts", ".", "isExternalModule", "(", "node", ")", "||", "compilerOptions", ".", "isolatedModules", ")", "{", "var", "emitModule", "=", "moduleEmitDelegates", "[", "modulekind", "]", "||", "moduleEmitDelegates", "[", "1", "/* CommonJS */", "]", ";", "emitModule", "(", "node", ")", ";", "}", "else", "{", "// emit prologue directives prior to __extends", "var", "startIndex", "=", "emitDirectivePrologues", "(", "node", ".", "statements", ",", "/*startWithNewLine*/", "false", ")", ";", "externalImports", "=", "undefined", ";", "exportSpecifiers", "=", "undefined", ";", "exportEquals", "=", "undefined", ";", "hasExportStars", "=", "false", ";", "emitEmitHelpers", "(", "node", ")", ";", "emitCaptureThisForNodeIfNecessary", "(", "node", ")", ";", "emitLinesStartingAt", "(", "node", ".", "statements", ",", "startIndex", ")", ";", "emitTempDeclarations", "(", "/*newLine*/", "true", ")", ";", "}", "emitLeadingComments", "(", "node", ".", "endOfFileToken", ")", ";", "}", "function", "emitNodeWithCommentsAndWithoutSourcemap", "(", "node", ")", "{", "emitNodeConsideringCommentsOption", "(", "node", ",", "emitNodeWithoutSourceMap", ")", ";", "}", "function", "emitNodeConsideringCommentsOption", "(", "node", ",", "emitNodeConsideringSourcemap", ")", "{", "if", "(", "node", ")", "{", "if", "(", "node", ".", "flags", "&", "2", "/* Ambient */", ")", "{", "return", "emitCommentsOnNotEmittedNode", "(", "node", ")", ";", "}", "if", "(", "isSpecializedCommentHandling", "(", "node", ")", ")", "{", "// This is the node that will handle its own comments and sourcemap", "return", "emitNodeWithoutSourceMap", "(", "node", ")", ";", "}", "var", "emitComments_1", "=", "shouldEmitLeadingAndTrailingComments", "(", "node", ")", ";", "if", "(", "emitComments_1", ")", "{", "emitLeadingComments", "(", "node", ")", ";", "}", "emitNodeConsideringSourcemap", "(", "node", ")", ";", "if", "(", "emitComments_1", ")", "{", "emitTrailingComments", "(", "node", ")", ";", "}", "}", "}", "function", "emitNodeWithoutSourceMap", "(", "node", ")", "{", "if", "(", "node", ")", "{", "emitJavaScriptWorker", "(", "node", ")", ";", "}", "}", "function", "isSpecializedCommentHandling", "(", "node", ")", "{", "switch", "(", "node", ".", "kind", ")", "{", "// All of these entities are emitted in a specialized fashion.  As such, we allow", "// the specialized methods for each to handle the comments on the nodes.", "case", "215", "/* InterfaceDeclaration */", ":", "case", "213", "/* FunctionDeclaration */", ":", "case", "222", "/* ImportDeclaration */", ":", "case", "221", "/* ImportEqualsDeclaration */", ":", "case", "216", "/* TypeAliasDeclaration */", ":", "case", "227", "/* ExportAssignment */", ":", "return", "true", ";", "}", "}", "function", "shouldEmitLeadingAndTrailingComments", "(", "node", ")", "{", "switch", "(", "node", ".", "kind", ")", "{", "case", "193", "/* VariableStatement */", ":", "return", "shouldEmitLeadingAndTrailingCommentsForVariableStatement", "(", "node", ")", ";", "case", "218", "/* ModuleDeclaration */", ":", "// Only emit the leading/trailing comments for a module if we're actually", "// emitting the module as well.", "return", "shouldEmitModuleDeclaration", "(", "node", ")", ";", "case", "217", "/* EnumDeclaration */", ":", "// Only emit the leading/trailing comments for an enum if we're actually", "// emitting the module as well.", "return", "shouldEmitEnumDeclaration", "(", "node", ")", ";", "}", "// If the node is emitted in specialized fashion, dont emit comments as this node will handle", "// emitting comments when emitting itself", "ts", ".", "Debug", ".", "assert", "(", "!", "isSpecializedCommentHandling", "(", "node", ")", ")", ";", "// If this is the expression body of an arrow function that we're down-leveling,", "// then we don't want to emit comments when we emit the body.  It will have already", "// been taken care of when we emitted the 'return' statement for the function", "// expression body.", "if", "(", "node", ".", "kind", "!==", "192", "/* Block */", "&&", "node", ".", "parent", "&&", "node", ".", "parent", ".", "kind", "===", "174", "/* ArrowFunction */", "&&", "node", ".", "parent", ".", "body", "===", "node", "&&", "compilerOptions", ".", "target", "<=", "1", "/* ES5 */", ")", "{", "return", "false", ";", "}", "// Emit comments for everything else.", "return", "true", ";", "}", "function", "emitJavaScriptWorker", "(", "node", ")", "{", "// Check if the node can be emitted regardless of the ScriptTarget", "switch", "(", "node", ".", "kind", ")", "{", "case", "69", "/* Identifier */", ":", "return", "emitIdentifier", "(", "node", ")", ";", "case", "138", "/* Parameter */", ":", "return", "emitParameter", "(", "node", ")", ";", "case", "143", "/* MethodDeclaration */", ":", "case", "142", "/* MethodSignature */", ":", "return", "emitMethod", "(", "node", ")", ";", "case", "145", "/* GetAccessor */", ":", "case", "146", "/* SetAccessor */", ":", "return", "emitAccessor", "(", "node", ")", ";", "case", "97", "/* ThisKeyword */", ":", "return", "emitThis", "(", "node", ")", ";", "case", "95", "/* SuperKeyword */", ":", "return", "emitSuper", "(", "node", ")", ";", "case", "93", "/* NullKeyword */", ":", "return", "write", "(", "\"null\"", ")", ";", "case", "99", "/* TrueKeyword */", ":", "return", "write", "(", "\"true\"", ")", ";", "case", "84", "/* FalseKeyword */", ":", "return", "write", "(", "\"false\"", ")", ";", "case", "8", "/* NumericLiteral */", ":", "case", "9", "/* StringLiteral */", ":", "case", "10", "/* RegularExpressionLiteral */", ":", "case", "11", "/* NoSubstitutionTemplateLiteral */", ":", "case", "12", "/* TemplateHead */", ":", "case", "13", "/* TemplateMiddle */", ":", "case", "14", "/* TemplateTail */", ":", "return", "emitLiteral", "(", "node", ")", ";", "case", "183", "/* TemplateExpression */", ":", "return", "emitTemplateExpression", "(", "node", ")", ";", "case", "190", "/* TemplateSpan */", ":", "return", "emitTemplateSpan", "(", "node", ")", ";", "case", "233", "/* JsxElement */", ":", "case", "234", "/* JsxSelfClosingElement */", ":", "return", "emitJsxElement", "(", "node", ")", ";", "case", "236", "/* JsxText */", ":", "return", "emitJsxText", "(", "node", ")", ";", "case", "240", "/* JsxExpression */", ":", "return", "emitJsxExpression", "(", "node", ")", ";", "case", "135", "/* QualifiedName */", ":", "return", "emitQualifiedName", "(", "node", ")", ";", "case", "161", "/* ObjectBindingPattern */", ":", "return", "emitObjectBindingPattern", "(", "node", ")", ";", "case", "162", "/* ArrayBindingPattern */", ":", "return", "emitArrayBindingPattern", "(", "node", ")", ";", "case", "163", "/* BindingElement */", ":", "return", "emitBindingElement", "(", "node", ")", ";", "case", "164", "/* ArrayLiteralExpression */", ":", "return", "emitArrayLiteral", "(", "node", ")", ";", "case", "165", "/* ObjectLiteralExpression */", ":", "return", "emitObjectLiteral", "(", "node", ")", ";", "case", "245", "/* PropertyAssignment */", ":", "return", "emitPropertyAssignment", "(", "node", ")", ";", "case", "246", "/* ShorthandPropertyAssignment */", ":", "return", "emitShorthandPropertyAssignment", "(", "node", ")", ";", "case", "136", "/* ComputedPropertyName */", ":", "return", "emitComputedPropertyName", "(", "node", ")", ";", "case", "166", "/* PropertyAccessExpression */", ":", "return", "emitPropertyAccess", "(", "node", ")", ";", "case", "167", "/* ElementAccessExpression */", ":", "return", "emitIndexedAccess", "(", "node", ")", ";", "case", "168", "/* CallExpression */", ":", "return", "emitCallExpression", "(", "node", ")", ";", "case", "169", "/* NewExpression */", ":", "return", "emitNewExpression", "(", "node", ")", ";", "case", "170", "/* TaggedTemplateExpression */", ":", "return", "emitTaggedTemplateExpression", "(", "node", ")", ";", "case", "171", "/* TypeAssertionExpression */", ":", "return", "emit", "(", "node", ".", "expression", ")", ";", "case", "189", "/* AsExpression */", ":", "return", "emit", "(", "node", ".", "expression", ")", ";", "case", "172", "/* ParenthesizedExpression */", ":", "return", "emitParenExpression", "(", "node", ")", ";", "case", "213", "/* FunctionDeclaration */", ":", "case", "173", "/* FunctionExpression */", ":", "case", "174", "/* ArrowFunction */", ":", "return", "emitFunctionDeclaration", "(", "node", ")", ";", "case", "175", "/* DeleteExpression */", ":", "return", "emitDeleteExpression", "(", "node", ")", ";", "case", "176", "/* TypeOfExpression */", ":", "return", "emitTypeOfExpression", "(", "node", ")", ";", "case", "177", "/* VoidExpression */", ":", "return", "emitVoidExpression", "(", "node", ")", ";", "case", "178", "/* AwaitExpression */", ":", "return", "emitAwaitExpression", "(", "node", ")", ";", "case", "179", "/* PrefixUnaryExpression */", ":", "return", "emitPrefixUnaryExpression", "(", "node", ")", ";", "case", "180", "/* PostfixUnaryExpression */", ":", "return", "emitPostfixUnaryExpression", "(", "node", ")", ";", "case", "181", "/* BinaryExpression */", ":", "return", "emitBinaryExpression", "(", "node", ")", ";", "case", "182", "/* ConditionalExpression */", ":", "return", "emitConditionalExpression", "(", "node", ")", ";", "case", "185", "/* SpreadElementExpression */", ":", "return", "emitSpreadElementExpression", "(", "node", ")", ";", "case", "184", "/* YieldExpression */", ":", "return", "emitYieldExpression", "(", "node", ")", ";", "case", "187", "/* OmittedExpression */", ":", "return", ";", "case", "192", "/* Block */", ":", "case", "219", "/* ModuleBlock */", ":", "return", "emitBlock", "(", "node", ")", ";", "case", "193", "/* VariableStatement */", ":", "return", "emitVariableStatement", "(", "node", ")", ";", "case", "194", "/* EmptyStatement */", ":", "return", "write", "(", "\";\"", ")", ";", "case", "195", "/* ExpressionStatement */", ":", "return", "emitExpressionStatement", "(", "node", ")", ";", "case", "196", "/* IfStatement */", ":", "return", "emitIfStatement", "(", "node", ")", ";", "case", "197", "/* DoStatement */", ":", "return", "emitDoStatement", "(", "node", ")", ";", "case", "198", "/* WhileStatement */", ":", "return", "emitWhileStatement", "(", "node", ")", ";", "case", "199", "/* ForStatement */", ":", "return", "emitForStatement", "(", "node", ")", ";", "case", "201", "/* ForOfStatement */", ":", "case", "200", "/* ForInStatement */", ":", "return", "emitForInOrForOfStatement", "(", "node", ")", ";", "case", "202", "/* ContinueStatement */", ":", "case", "203", "/* BreakStatement */", ":", "return", "emitBreakOrContinueStatement", "(", "node", ")", ";", "case", "204", "/* ReturnStatement */", ":", "return", "emitReturnStatement", "(", "node", ")", ";", "case", "205", "/* WithStatement */", ":", "return", "emitWithStatement", "(", "node", ")", ";", "case", "206", "/* SwitchStatement */", ":", "return", "emitSwitchStatement", "(", "node", ")", ";", "case", "241", "/* CaseClause */", ":", "case", "242", "/* DefaultClause */", ":", "return", "emitCaseOrDefaultClause", "(", "node", ")", ";", "case", "207", "/* LabeledStatement */", ":", "return", "emitLabelledStatement", "(", "node", ")", ";", "case", "208", "/* ThrowStatement */", ":", "return", "emitThrowStatement", "(", "node", ")", ";", "case", "209", "/* TryStatement */", ":", "return", "emitTryStatement", "(", "node", ")", ";", "case", "244", "/* CatchClause */", ":", "return", "emitCatchClause", "(", "node", ")", ";", "case", "210", "/* DebuggerStatement */", ":", "return", "emitDebuggerStatement", "(", "node", ")", ";", "case", "211", "/* VariableDeclaration */", ":", "return", "emitVariableDeclaration", "(", "node", ")", ";", "case", "186", "/* ClassExpression */", ":", "return", "emitClassExpression", "(", "node", ")", ";", "case", "214", "/* ClassDeclaration */", ":", "return", "emitClassDeclaration", "(", "node", ")", ";", "case", "215", "/* InterfaceDeclaration */", ":", "return", "emitInterfaceDeclaration", "(", "node", ")", ";", "case", "217", "/* EnumDeclaration */", ":", "return", "emitEnumDeclaration", "(", "node", ")", ";", "case", "247", "/* EnumMember */", ":", "return", "emitEnumMember", "(", "node", ")", ";", "case", "218", "/* ModuleDeclaration */", ":", "return", "emitModuleDeclaration", "(", "node", ")", ";", "case", "222", "/* ImportDeclaration */", ":", "return", "emitImportDeclaration", "(", "node", ")", ";", "case", "221", "/* ImportEqualsDeclaration */", ":", "return", "emitImportEqualsDeclaration", "(", "node", ")", ";", "case", "228", "/* ExportDeclaration */", ":", "return", "emitExportDeclaration", "(", "node", ")", ";", "case", "227", "/* ExportAssignment */", ":", "return", "emitExportAssignment", "(", "node", ")", ";", "case", "248", "/* SourceFile */", ":", "return", "emitSourceFileNode", "(", "node", ")", ";", "}", "}", "function", "hasDetachedComments", "(", "pos", ")", "{", "return", "detachedCommentsInfo", "!==", "undefined", "&&", "ts", ".", "lastOrUndefined", "(", "detachedCommentsInfo", ")", ".", "nodePos", "===", "pos", ";", "}", "function", "getLeadingCommentsWithoutDetachedComments", "(", ")", "{", "// get the leading comments from detachedPos", "var", "leadingComments", "=", "ts", ".", "getLeadingCommentRanges", "(", "currentSourceFile", ".", "text", ",", "ts", ".", "lastOrUndefined", "(", "detachedCommentsInfo", ")", ".", "detachedCommentEndPos", ")", ";", "if", "(", "detachedCommentsInfo", ".", "length", "-", "1", ")", "{", "detachedCommentsInfo", ".", "pop", "(", ")", ";", "}", "else", "{", "detachedCommentsInfo", "=", "undefined", ";", "}", "return", "leadingComments", ";", "}", "function", "isPinnedComments", "(", "comment", ")", "{", "return", "currentSourceFile", ".", "text", ".", "charCodeAt", "(", "comment", ".", "pos", "+", "1", ")", "===", "42", "/* asterisk */", "&&", "currentSourceFile", ".", "text", ".", "charCodeAt", "(", "comment", ".", "pos", "+", "2", ")", "===", "33", "/* exclamation */", ";", "}", "/**\n             * Determine if the given comment is a triple-slash\n             *\n             * @return true if the comment is a triple-slash comment else false\n             **/", "function", "isTripleSlashComment", "(", "comment", ")", "{", "// Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text", "// so that we don't end up computing comment string and doing match for all // comments", "if", "(", "currentSourceFile", ".", "text", ".", "charCodeAt", "(", "comment", ".", "pos", "+", "1", ")", "===", "47", "/* slash */", "&&", "comment", ".", "pos", "+", "2", "<", "comment", ".", "end", "&&", "currentSourceFile", ".", "text", ".", "charCodeAt", "(", "comment", ".", "pos", "+", "2", ")", "===", "47", "/* slash */", ")", "{", "var", "textSubStr", "=", "currentSourceFile", ".", "text", ".", "substring", "(", "comment", ".", "pos", ",", "comment", ".", "end", ")", ";", "return", "textSubStr", ".", "match", "(", "ts", ".", "fullTripleSlashReferencePathRegEx", ")", "||", "textSubStr", ".", "match", "(", "ts", ".", "fullTripleSlashAMDReferencePathRegEx", ")", "?", "true", ":", "false", ";", "}", "return", "false", ";", "}", "function", "getLeadingCommentsToEmit", "(", "node", ")", "{", "// Emit the leading comments only if the parent's pos doesn't match because parent should take care of emitting these comments", "if", "(", "node", ".", "parent", ")", "{", "if", "(", "node", ".", "parent", ".", "kind", "===", "248", "/* SourceFile */", "||", "node", ".", "pos", "!==", "node", ".", "parent", ".", "pos", ")", "{", "if", "(", "hasDetachedComments", "(", "node", ".", "pos", ")", ")", "{", "// get comments without detached comments", "return", "getLeadingCommentsWithoutDetachedComments", "(", ")", ";", "}", "else", "{", "// get the leading comments from the node", "return", "ts", ".", "getLeadingCommentRangesOfNode", "(", "node", ",", "currentSourceFile", ")", ";", "}", "}", "}", "}", "function", "getTrailingCommentsToEmit", "(", "node", ")", "{", "// Emit the trailing comments only if the parent's pos doesn't match because parent should take care of emitting these comments", "if", "(", "node", ".", "parent", ")", "{", "if", "(", "node", ".", "parent", ".", "kind", "===", "248", "/* SourceFile */", "||", "node", ".", "end", "!==", "node", ".", "parent", ".", "end", ")", "{", "return", "ts", ".", "getTrailingCommentRanges", "(", "currentSourceFile", ".", "text", ",", "node", ".", "end", ")", ";", "}", "}", "}", "/**\n             * Emit comments associated with node that will not be emitted into JS file\n             */", "function", "emitCommentsOnNotEmittedNode", "(", "node", ")", "{", "emitLeadingCommentsWorker", "(", "node", ",", "/*isEmittedNode:*/", "false", ")", ";", "}", "function", "emitLeadingComments", "(", "node", ")", "{", "return", "emitLeadingCommentsWorker", "(", "node", ",", "/*isEmittedNode:*/", "true", ")", ";", "}", "function", "emitLeadingCommentsWorker", "(", "node", ",", "isEmittedNode", ")", "{", "if", "(", "compilerOptions", ".", "removeComments", ")", "{", "return", ";", "}", "var", "leadingComments", ";", "if", "(", "isEmittedNode", ")", "{", "leadingComments", "=", "getLeadingCommentsToEmit", "(", "node", ")", ";", "}", "else", "{", "// If the node will not be emitted in JS, remove all the comments(normal, pinned and ///) associated with the node,", "// unless it is a triple slash comment at the top of the file.", "// For Example:", "//      /// <reference-path ...>", "//      declare var x;", "//      /// <reference-path ...>", "//      interface F {}", "//  The first /// will NOT be removed while the second one will be removed eventhough both node will not be emitted", "if", "(", "node", ".", "pos", "===", "0", ")", "{", "leadingComments", "=", "ts", ".", "filter", "(", "getLeadingCommentsToEmit", "(", "node", ")", ",", "isTripleSlashComment", ")", ";", "}", "}", "ts", ".", "emitNewLineBeforeLeadingComments", "(", "currentSourceFile", ",", "writer", ",", "node", ",", "leadingComments", ")", ";", "// Leading comments are emitted at /*leading comment1 */space/*leading comment*/space", "ts", ".", "emitComments", "(", "currentSourceFile", ",", "writer", ",", "leadingComments", ",", "/*trailingSeparator:*/", "true", ",", "newLine", ",", "writeComment", ")", ";", "}", "function", "emitTrailingComments", "(", "node", ")", "{", "if", "(", "compilerOptions", ".", "removeComments", ")", "{", "return", ";", "}", "// Emit the trailing comments only if the parent's end doesn't match", "var", "trailingComments", "=", "getTrailingCommentsToEmit", "(", "node", ")", ";", "// trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/", "ts", ".", "emitComments", "(", "currentSourceFile", ",", "writer", ",", "trailingComments", ",", "/*trailingSeparator*/", "false", ",", "newLine", ",", "writeComment", ")", ";", "}", "/**\n             * Emit trailing comments at the position. The term trailing comment is used here to describe following comment:\n             *      x, /comment1/ y\n             *        ^ => pos; the function will emit \"comment1\" in the emitJS\n             */", "function", "emitTrailingCommentsOfPosition", "(", "pos", ")", "{", "if", "(", "compilerOptions", ".", "removeComments", ")", "{", "return", ";", "}", "var", "trailingComments", "=", "ts", ".", "getTrailingCommentRanges", "(", "currentSourceFile", ".", "text", ",", "pos", ")", ";", "// trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/", "ts", ".", "emitComments", "(", "currentSourceFile", ",", "writer", ",", "trailingComments", ",", "/*trailingSeparator*/", "true", ",", "newLine", ",", "writeComment", ")", ";", "}", "function", "emitLeadingCommentsOfPositionWorker", "(", "pos", ")", "{", "if", "(", "compilerOptions", ".", "removeComments", ")", "{", "return", ";", "}", "var", "leadingComments", ";", "if", "(", "hasDetachedComments", "(", "pos", ")", ")", "{", "// get comments without detached comments", "leadingComments", "=", "getLeadingCommentsWithoutDetachedComments", "(", ")", ";", "}", "else", "{", "// get the leading comments from the node", "leadingComments", "=", "ts", ".", "getLeadingCommentRanges", "(", "currentSourceFile", ".", "text", ",", "pos", ")", ";", "}", "ts", ".", "emitNewLineBeforeLeadingComments", "(", "currentSourceFile", ",", "writer", ",", "{", "pos", ":", "pos", ",", "end", ":", "pos", "}", ",", "leadingComments", ")", ";", "// Leading comments are emitted at /*leading comment1 */space/*leading comment*/space", "ts", ".", "emitComments", "(", "currentSourceFile", ",", "writer", ",", "leadingComments", ",", "/*trailingSeparator*/", "true", ",", "newLine", ",", "writeComment", ")", ";", "}", "function", "emitDetachedComments", "(", "node", ")", "{", "var", "leadingComments", ";", "if", "(", "compilerOptions", ".", "removeComments", ")", "{", "// removeComments is true, only reserve pinned comment at the top of file", "// For example:", "//      /*! Pinned Comment */", "//", "//      var x = 10;", "if", "(", "node", ".", "pos", "===", "0", ")", "{", "leadingComments", "=", "ts", ".", "filter", "(", "ts", ".", "getLeadingCommentRanges", "(", "currentSourceFile", ".", "text", ",", "node", ".", "pos", ")", ",", "isPinnedComments", ")", ";", "}", "}", "else", "{", "// removeComments is false, just get detached as normal and bypass the process to filter comment", "leadingComments", "=", "ts", ".", "getLeadingCommentRanges", "(", "currentSourceFile", ".", "text", ",", "node", ".", "pos", ")", ";", "}", "if", "(", "leadingComments", ")", "{", "var", "detachedComments", "=", "[", "]", ";", "var", "lastComment", ";", "ts", ".", "forEach", "(", "leadingComments", ",", "function", "(", "comment", ")", "{", "if", "(", "lastComment", ")", "{", "var", "lastCommentLine", "=", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "lastComment", ".", "end", ")", ";", "var", "commentLine", "=", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "comment", ".", "pos", ")", ";", "if", "(", "commentLine", ">=", "lastCommentLine", "+", "2", ")", "{", "// There was a blank line between the last comment and this comment.  This", "// comment is not part of the copyright comments.  Return what we have so", "// far.", "return", "detachedComments", ";", "}", "}", "detachedComments", ".", "push", "(", "comment", ")", ";", "lastComment", "=", "comment", ";", "}", ")", ";", "if", "(", "detachedComments", ".", "length", ")", "{", "// All comments look like they could have been part of the copyright header.  Make", "// sure there is at least one blank line between it and the node.  If not, it's not", "// a copyright header.", "var", "lastCommentLine", "=", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "ts", ".", "lastOrUndefined", "(", "detachedComments", ")", ".", "end", ")", ";", "var", "nodeLine", "=", "ts", ".", "getLineOfLocalPosition", "(", "currentSourceFile", ",", "ts", ".", "skipTrivia", "(", "currentSourceFile", ".", "text", ",", "node", ".", "pos", ")", ")", ";", "if", "(", "nodeLine", ">=", "lastCommentLine", "+", "2", ")", "{", "// Valid detachedComments", "ts", ".", "emitNewLineBeforeLeadingComments", "(", "currentSourceFile", ",", "writer", ",", "node", ",", "leadingComments", ")", ";", "ts", ".", "emitComments", "(", "currentSourceFile", ",", "writer", ",", "detachedComments", ",", "/*trailingSeparator*/", "true", ",", "newLine", ",", "writeComment", ")", ";", "var", "currentDetachedCommentInfo", "=", "{", "nodePos", ":", "node", ".", "pos", ",", "detachedCommentEndPos", ":", "ts", ".", "lastOrUndefined", "(", "detachedComments", ")", ".", "end", "}", ";", "if", "(", "detachedCommentsInfo", ")", "{", "detachedCommentsInfo", ".", "push", "(", "currentDetachedCommentInfo", ")", ";", "}", "else", "{", "detachedCommentsInfo", "=", "[", "currentDetachedCommentInfo", "]", ";", "}", "}", "}", "}", "}", "function", "emitShebang", "(", ")", "{", "var", "shebang", "=", "ts", ".", "getShebang", "(", "currentSourceFile", ".", "text", ")", ";", "if", "(", "shebang", ")", "{", "write", "(", "shebang", ")", ";", "}", "}", "var", "_a", ";", "}", "function", "emitFile", "(", "jsFilePath", ",", "sourceFile", ")", "{", "emitJavaScript", "(", "jsFilePath", ",", "sourceFile", ")", ";", "if", "(", "compilerOptions", ".", "declaration", ")", "{", "ts", ".", "writeDeclarationFile", "(", "jsFilePath", ",", "sourceFile", ",", "host", ",", "resolver", ",", "diagnostics", ")", ";", "}", "}", "}"], "docstring": "targetSourceFile is when users only want one file in entire project to be emitted. This is used in compileOnSave feature", "docstring_tokens": ["targetSourceFile", "is", "when", "users", "only", "want", "one", "file", "in", "entire", "project", "to", "be", "emitted", ".", "This", "is", "used", "in", "compileOnSave", "feature"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L29466-L35977", "partition": "test"}
{"repo": "rhyolight/sprinter.js", "path": "sprinter.js", "func_name": "sortIssues", "original_string": "function sortIssues(issues) {\n    var sorted;\n    // Issues might be pre-arranged by super/sub tasks.\n    if (Object.keys(issues).indexOf('supers') > -1) {\n        // Network format issue sort\n        issues.supers = _.sortBy(issues.supers, function(issue) {\n            return new Date(issue.updated_at);\n        }).reverse();\n\n        issues.singletons = _.sortBy(issues.singletons, function(issue) {\n            return new Date(issue.updated_at);\n        }).reverse();\n        sorted = issues;\n    } else {\n        sorted = _.sortBy(issues, function(issue) {\n            return new Date(issue.updated_at);\n        }).reverse();\n    }\n    return sorted;\n}", "language": "javascript", "code": "function sortIssues(issues) {\n    var sorted;\n    // Issues might be pre-arranged by super/sub tasks.\n    if (Object.keys(issues).indexOf('supers') > -1) {\n        // Network format issue sort\n        issues.supers = _.sortBy(issues.supers, function(issue) {\n            return new Date(issue.updated_at);\n        }).reverse();\n\n        issues.singletons = _.sortBy(issues.singletons, function(issue) {\n            return new Date(issue.updated_at);\n        }).reverse();\n        sorted = issues;\n    } else {\n        sorted = _.sortBy(issues, function(issue) {\n            return new Date(issue.updated_at);\n        }).reverse();\n    }\n    return sorted;\n}", "code_tokens": ["function", "sortIssues", "(", "issues", ")", "{", "var", "sorted", ";", "// Issues might be pre-arranged by super/sub tasks.", "if", "(", "Object", ".", "keys", "(", "issues", ")", ".", "indexOf", "(", "'supers'", ")", ">", "-", "1", ")", "{", "// Network format issue sort", "issues", ".", "supers", "=", "_", ".", "sortBy", "(", "issues", ".", "supers", ",", "function", "(", "issue", ")", "{", "return", "new", "Date", "(", "issue", ".", "updated_at", ")", ";", "}", ")", ".", "reverse", "(", ")", ";", "issues", ".", "singletons", "=", "_", ".", "sortBy", "(", "issues", ".", "singletons", ",", "function", "(", "issue", ")", "{", "return", "new", "Date", "(", "issue", ".", "updated_at", ")", ";", "}", ")", ".", "reverse", "(", ")", ";", "sorted", "=", "issues", ";", "}", "else", "{", "sorted", "=", "_", ".", "sortBy", "(", "issues", ",", "function", "(", "issue", ")", "{", "return", "new", "Date", "(", "issue", ".", "updated_at", ")", ";", "}", ")", ".", "reverse", "(", ")", ";", "}", "return", "sorted", ";", "}"], "docstring": "Sorts array of issue objects by last updated date.", "docstring_tokens": ["Sorts", "array", "of", "issue", "objects", "by", "last", "updated", "date", "."], "sha": "6b8cd6ed85a41d407787090c74a76efb981d13e0", "url": "https://github.com/rhyolight/sprinter.js/blob/6b8cd6ed85a41d407787090c74a76efb981d13e0/sprinter.js#L23-L42", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/form/Panel.js", "func_name": "", "original_string": "function(record) {\n        var me = this;\n\n        me._record = record;\n\n        if (record && record.data) {\n            me.setValues(record.data);\n        }\n\n        return this;\n    }", "language": "javascript", "code": "function(record) {\n        var me = this;\n\n        me._record = record;\n\n        if (record && record.data) {\n            me.setValues(record.data);\n        }\n\n        return this;\n    }", "code_tokens": ["function", "(", "record", ")", "{", "var", "me", "=", "this", ";", "me", ".", "_record", "=", "record", ";", "if", "(", "record", "&&", "record", ".", "data", ")", "{", "me", ".", "setValues", "(", "record", ".", "data", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Loads matching fields from a model instance into this form.\n@param {Ext.data.Model} record The model instance.\n@return {Ext.form.Panel} This form.", "docstring_tokens": ["Loads", "matching", "fields", "from", "a", "model", "instance", "into", "this", "form", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/form/Panel.js#L379-L389", "partition": "test"}
{"repo": "mesqueeb/vuex-easy-firestore", "path": "dist/index.cjs.js", "func_name": "setDefaultValues", "original_string": "function setDefaultValues (obj, defaultValues) {\n    if (!isWhat.isPlainObject(defaultValues))\n        console.error('[vuex-easy-firestore] Trying to merge target:', obj, 'onto a non-object (defaultValues):', defaultValues);\n    if (!isWhat.isPlainObject(obj))\n        console.error('[vuex-easy-firestore] Trying to merge a non-object:', obj, 'onto the defaultValues:', defaultValues);\n    var result = merge({ extensions: [convertTimestamps] }, defaultValues, obj);\n    return findAndReplaceAnything.findAndReplace(result, '%convertTimestamp%', null, { onlyPlainObjects: true });\n}", "language": "javascript", "code": "function setDefaultValues (obj, defaultValues) {\n    if (!isWhat.isPlainObject(defaultValues))\n        console.error('[vuex-easy-firestore] Trying to merge target:', obj, 'onto a non-object (defaultValues):', defaultValues);\n    if (!isWhat.isPlainObject(obj))\n        console.error('[vuex-easy-firestore] Trying to merge a non-object:', obj, 'onto the defaultValues:', defaultValues);\n    var result = merge({ extensions: [convertTimestamps] }, defaultValues, obj);\n    return findAndReplaceAnything.findAndReplace(result, '%convertTimestamp%', null, { onlyPlainObjects: true });\n}", "code_tokens": ["function", "setDefaultValues", "(", "obj", ",", "defaultValues", ")", "{", "if", "(", "!", "isWhat", ".", "isPlainObject", "(", "defaultValues", ")", ")", "console", ".", "error", "(", "'[vuex-easy-firestore] Trying to merge target:'", ",", "obj", ",", "'onto a non-object (defaultValues):'", ",", "defaultValues", ")", ";", "if", "(", "!", "isWhat", ".", "isPlainObject", "(", "obj", ")", ")", "console", ".", "error", "(", "'[vuex-easy-firestore] Trying to merge a non-object:'", ",", "obj", ",", "'onto the defaultValues:'", ",", "defaultValues", ")", ";", "var", "result", "=", "merge", "(", "{", "extensions", ":", "[", "convertTimestamps", "]", "}", ",", "defaultValues", ",", "obj", ")", ";", "return", "findAndReplaceAnything", ".", "findAndReplace", "(", "result", ",", "'%convertTimestamp%'", ",", "null", ",", "{", "onlyPlainObjects", ":", "true", "}", ")", ";", "}"], "docstring": "Merge an object onto defaultValues\n\n@export\n@param {object} obj\n@param {object} defaultValues\n@returns {AnyObject} the new object", "docstring_tokens": ["Merge", "an", "object", "onto", "defaultValues"], "sha": "08695ae1abd5c5bbfb6c3cfb618f17e7249f5667", "url": "https://github.com/mesqueeb/vuex-easy-firestore/blob/08695ae1abd5c5bbfb6c3cfb618f17e7249f5667/dist/index.cjs.js#L447-L454", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "onControlTableRowContextClick", "original_string": "function onControlTableRowContextClick(node, event)\n   {\n      event.preventDefault(); // Prevents default browser context menu from showing.\n      onNodeContextClick(node, { x: event.pageX, y: event.pageY });\n   }", "language": "javascript", "code": "function onControlTableRowContextClick(node, event)\n   {\n      event.preventDefault(); // Prevents default browser context menu from showing.\n      onNodeContextClick(node, { x: event.pageX, y: event.pageY });\n   }", "code_tokens": ["function", "onControlTableRowContextClick", "(", "node", ",", "event", ")", "{", "event", ".", "preventDefault", "(", ")", ";", "// Prevents default browser context menu from showing.", "onNodeContextClick", "(", "node", ",", "{", "x", ":", "event", ".", "pageX", ",", "y", ":", "event", ".", "pageY", "}", ")", ";", "}"], "docstring": "Handles a context click on a table row showing the related node context menu.\n\n@param {object}   node - Target node.\n@param {object}   event - mouse event", "docstring_tokens": ["Handles", "a", "context", "click", "on", "a", "table", "row", "showing", "the", "related", "node", "context", "menu", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L537-L541", "partition": "test"}
{"repo": "MathieuTurcotte/node-backoff", "path": "lib/strategy/exponential.js", "func_name": "ExponentialBackoffStrategy", "original_string": "function ExponentialBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;\n\n    if (options && options.factor !== undefined) {\n        precond.checkArgument(options.factor > 1,\n            'Exponential factor should be greater than 1 but got %s.',\n            options.factor);\n        this.factor_ = options.factor;\n    }\n}", "language": "javascript", "code": "function ExponentialBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;\n\n    if (options && options.factor !== undefined) {\n        precond.checkArgument(options.factor > 1,\n            'Exponential factor should be greater than 1 but got %s.',\n            options.factor);\n        this.factor_ = options.factor;\n    }\n}", "code_tokens": ["function", "ExponentialBackoffStrategy", "(", "options", ")", "{", "BackoffStrategy", ".", "call", "(", "this", ",", "options", ")", ";", "this", ".", "backoffDelay_", "=", "0", ";", "this", ".", "nextBackoffDelay_", "=", "this", ".", "getInitialDelay", "(", ")", ";", "this", ".", "factor_", "=", "ExponentialBackoffStrategy", ".", "DEFAULT_FACTOR", ";", "if", "(", "options", "&&", "options", ".", "factor", "!==", "undefined", ")", "{", "precond", ".", "checkArgument", "(", "options", ".", "factor", ">", "1", ",", "'Exponential factor should be greater than 1 but got %s.'", ",", "options", ".", "factor", ")", ";", "this", ".", "factor_", "=", "options", ".", "factor", ";", "}", "}"], "docstring": "Exponential backoff strategy.", "docstring_tokens": ["Exponential", "backoff", "strategy", "."], "sha": "f384eff062d585ebd878aab7ecf29eb56c1efd7d", "url": "https://github.com/MathieuTurcotte/node-backoff/blob/f384eff062d585ebd878aab7ecf29eb56c1efd7d/lib/strategy/exponential.js#L10-L22", "partition": "test"}
{"repo": "nearform/nscale-planner", "path": "lib/containerStatus.js", "func_name": "containerStatus", "original_string": "function containerStatus(original, status, parent) {\n\n  var state = {\n    topology: {\n      containers: {}\n    }\n  };\n\n  var container = {\n    id: original.id\n  };\n\n  if (parent === null) {\n    // nothing to do\n  } else if (parent !== undefined) {\n    container.containedBy = parent;\n  } else {\n    container.containedBy = original.containedBy;\n  }\n\n  if (typeof status === 'string') {\n\n    switch(status) {\n      case 'detached':\n        container.added   = false;\n        container.started = false;\n        container.running = false;\n        break;\n      case 'added':\n        container.added   = true;\n        break;\n      case 'started':\n        container.started = true;\n        break;\n      case 'running':\n        container.running = true;\n        break;\n\n      default:\n        throw new Error('unknown state');\n    }\n\n  } else {\n    _.forIn(status, function(value, key) {\n      container[key] = value;\n    });\n  }\n\n  if (container.added === false) {\n    delete container.containedBy;\n  }\n\n  state.topology.containers[container.id] = container;\n\n  return state;\n}", "language": "javascript", "code": "function containerStatus(original, status, parent) {\n\n  var state = {\n    topology: {\n      containers: {}\n    }\n  };\n\n  var container = {\n    id: original.id\n  };\n\n  if (parent === null) {\n    // nothing to do\n  } else if (parent !== undefined) {\n    container.containedBy = parent;\n  } else {\n    container.containedBy = original.containedBy;\n  }\n\n  if (typeof status === 'string') {\n\n    switch(status) {\n      case 'detached':\n        container.added   = false;\n        container.started = false;\n        container.running = false;\n        break;\n      case 'added':\n        container.added   = true;\n        break;\n      case 'started':\n        container.started = true;\n        break;\n      case 'running':\n        container.running = true;\n        break;\n\n      default:\n        throw new Error('unknown state');\n    }\n\n  } else {\n    _.forIn(status, function(value, key) {\n      container[key] = value;\n    });\n  }\n\n  if (container.added === false) {\n    delete container.containedBy;\n  }\n\n  state.topology.containers[container.id] = container;\n\n  return state;\n}", "code_tokens": ["function", "containerStatus", "(", "original", ",", "status", ",", "parent", ")", "{", "var", "state", "=", "{", "topology", ":", "{", "containers", ":", "{", "}", "}", "}", ";", "var", "container", "=", "{", "id", ":", "original", ".", "id", "}", ";", "if", "(", "parent", "===", "null", ")", "{", "// nothing to do", "}", "else", "if", "(", "parent", "!==", "undefined", ")", "{", "container", ".", "containedBy", "=", "parent", ";", "}", "else", "{", "container", ".", "containedBy", "=", "original", ".", "containedBy", ";", "}", "if", "(", "typeof", "status", "===", "'string'", ")", "{", "switch", "(", "status", ")", "{", "case", "'detached'", ":", "container", ".", "added", "=", "false", ";", "container", ".", "started", "=", "false", ";", "container", ".", "running", "=", "false", ";", "break", ";", "case", "'added'", ":", "container", ".", "added", "=", "true", ";", "break", ";", "case", "'started'", ":", "container", ".", "started", "=", "true", ";", "break", ";", "case", "'running'", ":", "container", ".", "running", "=", "true", ";", "break", ";", "default", ":", "throw", "new", "Error", "(", "'unknown state'", ")", ";", "}", "}", "else", "{", "_", ".", "forIn", "(", "status", ",", "function", "(", "value", ",", "key", ")", "{", "container", "[", "key", "]", "=", "value", ";", "}", ")", ";", "}", "if", "(", "container", ".", "added", "===", "false", ")", "{", "delete", "container", ".", "containedBy", ";", "}", "state", ".", "topology", ".", "containers", "[", "container", ".", "id", "]", "=", "container", ";", "return", "state", ";", "}"], "docstring": "Creates a container status to be used as a precondition\n\nValid values for the status parameters are:\n- a string, such as 'detached', 'added', 'started', 'running'\n- an object, such as { added: true, started: true, running: false }\n\n@param {object} original - the container\n@param {object|string} status - the status to set.\n@param {object} parent - the parent container's id.", "docstring_tokens": ["Creates", "a", "container", "status", "to", "be", "used", "as", "a", "precondition"], "sha": "40a33413dce28d2f95b3a8036a7c63a6c82b877e", "url": "https://github.com/nearform/nscale-planner/blob/40a33413dce28d2f95b3a8036a7c63a6c82b877e/lib/containerStatus.js#L32-L87", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/mediaType.js", "func_name": "splitKeyValuePair", "original_string": "function splitKeyValuePair(str) {\n  var index = str.indexOf('=');\n  var key;\n  var val;\n\n  if (index === -1) {\n    key = str;\n  } else {\n    key = str.substr(0, index);\n    val = str.substr(index + 1);\n  }\n\n  return [key, val];\n}", "language": "javascript", "code": "function splitKeyValuePair(str) {\n  var index = str.indexOf('=');\n  var key;\n  var val;\n\n  if (index === -1) {\n    key = str;\n  } else {\n    key = str.substr(0, index);\n    val = str.substr(index + 1);\n  }\n\n  return [key, val];\n}", "code_tokens": ["function", "splitKeyValuePair", "(", "str", ")", "{", "var", "index", "=", "str", ".", "indexOf", "(", "'='", ")", ";", "var", "key", ";", "var", "val", ";", "if", "(", "index", "===", "-", "1", ")", "{", "key", "=", "str", ";", "}", "else", "{", "key", "=", "str", ".", "substr", "(", "0", ",", "index", ")", ";", "val", "=", "str", ".", "substr", "(", "index", "+", "1", ")", ";", "}", "return", "[", "key", ",", "val", "]", ";", "}"], "docstring": "Split a key value pair.\n@private", "docstring_tokens": ["Split", "a", "key", "value", "pair", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/mediaType.js#L233-L246", "partition": "test"}
{"repo": "soldair/node-tailfd", "path": "tail.js", "func_name": "", "original_string": "function(tailInfo){\n    var z = this;\n    if(tailInfo) {\n      z.q.push(tailInfo);\n    }\n\n    var ti; \n    //for all changed fds fire readStream\n    for(var i = 0;i < z.q.length;++i) {\n      ti = z.q[i];\n\n      if(ti.reading) {\n        //still reading file\n        continue;\n      }\n\n      if (!z.tails[ti.stat.ino]) {\n        //remove timed out file tail from q\n        z.q.splice(i,1);\n        --i;\n        continue;\n      }\n\n      //truncated\n      if(ti.stat.size < ti.pos) {\n        ti.pos = 0;\n      }\n\n      var len = ti.stat.size-ti.pos;\n      //remove from queue because im doing this work.\n      z.q.splice(i,1);\n      --i;\n\n      z.readTail(ti,len);\n    }\n  }", "language": "javascript", "code": "function(tailInfo){\n    var z = this;\n    if(tailInfo) {\n      z.q.push(tailInfo);\n    }\n\n    var ti; \n    //for all changed fds fire readStream\n    for(var i = 0;i < z.q.length;++i) {\n      ti = z.q[i];\n\n      if(ti.reading) {\n        //still reading file\n        continue;\n      }\n\n      if (!z.tails[ti.stat.ino]) {\n        //remove timed out file tail from q\n        z.q.splice(i,1);\n        --i;\n        continue;\n      }\n\n      //truncated\n      if(ti.stat.size < ti.pos) {\n        ti.pos = 0;\n      }\n\n      var len = ti.stat.size-ti.pos;\n      //remove from queue because im doing this work.\n      z.q.splice(i,1);\n      --i;\n\n      z.readTail(ti,len);\n    }\n  }", "code_tokens": ["function", "(", "tailInfo", ")", "{", "var", "z", "=", "this", ";", "if", "(", "tailInfo", ")", "{", "z", ".", "q", ".", "push", "(", "tailInfo", ")", ";", "}", "var", "ti", ";", "//for all changed fds fire readStream", "for", "(", "var", "i", "=", "0", ";", "i", "<", "z", ".", "q", ".", "length", ";", "++", "i", ")", "{", "ti", "=", "z", ".", "q", "[", "i", "]", ";", "if", "(", "ti", ".", "reading", ")", "{", "//still reading file", "continue", ";", "}", "if", "(", "!", "z", ".", "tails", "[", "ti", ".", "stat", ".", "ino", "]", ")", "{", "//remove timed out file tail from q", "z", ".", "q", ".", "splice", "(", "i", ",", "1", ")", ";", "--", "i", ";", "continue", ";", "}", "//truncated", "if", "(", "ti", ".", "stat", ".", "size", "<", "ti", ".", "pos", ")", "{", "ti", ".", "pos", "=", "0", ";", "}", "var", "len", "=", "ti", ".", "stat", ".", "size", "-", "ti", ".", "pos", ";", "//remove from queue because im doing this work.", "z", ".", "q", ".", "splice", "(", "i", ",", "1", ")", ";", "--", "i", ";", "z", ".", "readTail", "(", "ti", ",", "len", ")", ";", "}", "}"], "docstring": "this emits the data events on the watcher emitter for all fds", "docstring_tokens": ["this", "emits", "the", "data", "events", "on", "the", "watcher", "emitter", "for", "all", "fds"], "sha": "ef87ec6389edb7f53b540972aa32256d0b4fc850", "url": "https://github.com/soldair/node-tailfd/blob/ef87ec6389edb7f53b540972aa32256d0b4fc850/tail.js#L173-L208", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/readers.js", "func_name": "FrameReader", "original_string": "function FrameReader(header, body, offset) {\n  this.header = header;\n  this.opcode = header.opcode;\n  this.offset = offset || 0;\n  this.buf = body;\n}", "language": "javascript", "code": "function FrameReader(header, body, offset) {\n  this.header = header;\n  this.opcode = header.opcode;\n  this.offset = offset || 0;\n  this.buf = body;\n}", "code_tokens": ["function", "FrameReader", "(", "header", ",", "body", ",", "offset", ")", "{", "this", ".", "header", "=", "header", ";", "this", ".", "opcode", "=", "header", ".", "opcode", ";", "this", ".", "offset", "=", "offset", "||", "0", ";", "this", ".", "buf", "=", "body", ";", "}"], "docstring": "Buffer forward reader of CQL binary frames\n@param {FrameHeader} header\n@param {Buffer} body\n@param {Number} [offset]", "docstring_tokens": ["Buffer", "forward", "reader", "of", "CQL", "binary", "frames"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/readers.js#L23-L28", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( model, id ) {\n\t\t\tvar coll = this.getCollection( model ),\n\t\t\t\tduplicate = coll && coll.get( id );\n\n\t\t\tif ( duplicate && model !== duplicate ) {\n\t\t\t\tif ( Backbone.Relational.showWarnings && typeof console !== 'undefined' ) {\n\t\t\t\t\tconsole.warn( 'Duplicate id! Old RelationalModel=%o, new RelationalModel=%o', duplicate, model );\n\t\t\t\t}\n\n\t\t\t\tthrow new Error( \"Cannot instantiate more than one Backbone.RelationalModel with the same id per type!\" );\n\t\t\t}\n\t\t}", "language": "javascript", "code": "function( model, id ) {\n\t\t\tvar coll = this.getCollection( model ),\n\t\t\t\tduplicate = coll && coll.get( id );\n\n\t\t\tif ( duplicate && model !== duplicate ) {\n\t\t\t\tif ( Backbone.Relational.showWarnings && typeof console !== 'undefined' ) {\n\t\t\t\t\tconsole.warn( 'Duplicate id! Old RelationalModel=%o, new RelationalModel=%o', duplicate, model );\n\t\t\t\t}\n\n\t\t\t\tthrow new Error( \"Cannot instantiate more than one Backbone.RelationalModel with the same id per type!\" );\n\t\t\t}\n\t\t}", "code_tokens": ["function", "(", "model", ",", "id", ")", "{", "var", "coll", "=", "this", ".", "getCollection", "(", "model", ")", ",", "duplicate", "=", "coll", "&&", "coll", ".", "get", "(", "id", ")", ";", "if", "(", "duplicate", "&&", "model", "!==", "duplicate", ")", "{", "if", "(", "Backbone", ".", "Relational", ".", "showWarnings", "&&", "typeof", "console", "!==", "'undefined'", ")", "{", "console", ".", "warn", "(", "'Duplicate id! Old RelationalModel=%o, new RelationalModel=%o'", ",", "duplicate", ",", "model", ")", ";", "}", "throw", "new", "Error", "(", "\"Cannot instantiate more than one Backbone.RelationalModel with the same id per type!\"", ")", ";", "}", "}"], "docstring": "Check if the given model may use the given `id`\n@param model\n@param [id]", "docstring_tokens": ["Check", "if", "the", "given", "model", "may", "use", "the", "given", "id"], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L435-L446", "partition": "test"}
{"repo": "azproduction/lmd", "path": "lib/coverage_apply.js", "func_name": "wrapConditionals", "original_string": "function wrapConditionals () {\n\t\tif (options.condition === false) {\n\t\t\t// condition coverage is disabled\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this, ret;\n\t\tif (self[0].start && analyzing.indexOf(self) < 0) {\n\t\t\tanalyzing.push(self);\n\t\t\tvar lineId = self[0].name + ':' + (self[0].start.line + lineOffset);\n\n\t\t\tself[1] = wrapCondition(self[1], lineId);\n\n\t\t\tself[2] = walker.walk(self[2]);\n\t\t\tself[3] = walker.walk(self[3]);\n\n\t\t\tanalyzing.pop(self);\n\n\t\t\treturn self;\n\t\t} else if (self[1]) {\n\t\t\tself[1] = wrapCondition(self[1], lineId);\n\t\t}\n\t}", "language": "javascript", "code": "function wrapConditionals () {\n\t\tif (options.condition === false) {\n\t\t\t// condition coverage is disabled\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this, ret;\n\t\tif (self[0].start && analyzing.indexOf(self) < 0) {\n\t\t\tanalyzing.push(self);\n\t\t\tvar lineId = self[0].name + ':' + (self[0].start.line + lineOffset);\n\n\t\t\tself[1] = wrapCondition(self[1], lineId);\n\n\t\t\tself[2] = walker.walk(self[2]);\n\t\t\tself[3] = walker.walk(self[3]);\n\n\t\t\tanalyzing.pop(self);\n\n\t\t\treturn self;\n\t\t} else if (self[1]) {\n\t\t\tself[1] = wrapCondition(self[1], lineId);\n\t\t}\n\t}", "code_tokens": ["function", "wrapConditionals", "(", ")", "{", "if", "(", "options", ".", "condition", "===", "false", ")", "{", "// condition coverage is disabled", "return", ";", "}", "var", "self", "=", "this", ",", "ret", ";", "if", "(", "self", "[", "0", "]", ".", "start", "&&", "analyzing", ".", "indexOf", "(", "self", ")", "<", "0", ")", "{", "analyzing", ".", "push", "(", "self", ")", ";", "var", "lineId", "=", "self", "[", "0", "]", ".", "name", "+", "':'", "+", "(", "self", "[", "0", "]", ".", "start", ".", "line", "+", "lineOffset", ")", ";", "self", "[", "1", "]", "=", "wrapCondition", "(", "self", "[", "1", "]", ",", "lineId", ")", ";", "self", "[", "2", "]", "=", "walker", ".", "walk", "(", "self", "[", "2", "]", ")", ";", "self", "[", "3", "]", "=", "walker", ".", "walk", "(", "self", "[", "3", "]", ")", ";", "analyzing", ".", "pop", "(", "self", ")", ";", "return", "self", ";", "}", "else", "if", "(", "self", "[", "1", "]", ")", "{", "self", "[", "1", "]", "=", "wrapCondition", "(", "self", "[", "1", "]", ",", "lineId", ")", ";", "}", "}"], "docstring": "This function wraps ternary conditionals in order to have condition coverage\n\n'this' is a node containing\n'this[0]' node descriptor\n'this[1]' decision block\n'this[2]' first statement\n'this[3]' second statement", "docstring_tokens": ["This", "function", "wraps", "ternary", "conditionals", "in", "order", "to", "have", "condition", "coverage"], "sha": "03410c36839728de683c697670e1b205dc8193ee", "url": "https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/lib/coverage_apply.js#L480-L502", "partition": "test"}
{"repo": "shinate/pretty-columns", "path": "index.js", "func_name": "realWidth", "original_string": "function realWidth(str) {\n    if (str == null)\n        return 0;\n    str = stripANSI(str);\n    return str.length + (stripEmoji(str).match(/[^\\x00-\\xff]/g) || []).length;\n}", "language": "javascript", "code": "function realWidth(str) {\n    if (str == null)\n        return 0;\n    str = stripANSI(str);\n    return str.length + (stripEmoji(str).match(/[^\\x00-\\xff]/g) || []).length;\n}", "code_tokens": ["function", "realWidth", "(", "str", ")", "{", "if", "(", "str", "==", "null", ")", "return", "0", ";", "str", "=", "stripANSI", "(", "str", ")", ";", "return", "str", ".", "length", "+", "(", "stripEmoji", "(", "str", ")", ".", "match", "(", "/", "[^\\x00-\\xff]", "/", "g", ")", "||", "[", "]", ")", ".", "length", ";", "}"], "docstring": "String real width\n\n@param {string} str\n@returns {number}\n\nEmoji: 2\nDouble-byte character: 2\nOthers: 1", "docstring_tokens": ["String", "real", "width"], "sha": "0caaf212f3db424aa7d5b6352da2c749a4323aad", "url": "https://github.com/shinate/pretty-columns/blob/0caaf212f3db424aa7d5b6352da2c749a4323aad/index.js#L76-L81", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "generate", "original_string": "function generate(patterns, options) {\n    var unixPatterns = patterns.map(patternUtils.unixifyPattern);\n    var unixIgnore = options.ignore.map(patternUtils.unixifyPattern);\n    var positivePatterns = getPositivePatterns(unixPatterns);\n    var negativePatterns = getNegativePatternsAsPositive(unixPatterns, unixIgnore);\n    var staticPatterns = positivePatterns.filter(patternUtils.isStaticPattern);\n    var dynamicPatterns = positivePatterns.filter(patternUtils.isDynamicPattern);\n    var staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\n    var dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\n    return staticTasks.concat(dynamicTasks);\n}", "language": "javascript", "code": "function generate(patterns, options) {\n    var unixPatterns = patterns.map(patternUtils.unixifyPattern);\n    var unixIgnore = options.ignore.map(patternUtils.unixifyPattern);\n    var positivePatterns = getPositivePatterns(unixPatterns);\n    var negativePatterns = getNegativePatternsAsPositive(unixPatterns, unixIgnore);\n    var staticPatterns = positivePatterns.filter(patternUtils.isStaticPattern);\n    var dynamicPatterns = positivePatterns.filter(patternUtils.isDynamicPattern);\n    var staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\n    var dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\n    return staticTasks.concat(dynamicTasks);\n}", "code_tokens": ["function", "generate", "(", "patterns", ",", "options", ")", "{", "var", "unixPatterns", "=", "patterns", ".", "map", "(", "patternUtils", ".", "unixifyPattern", ")", ";", "var", "unixIgnore", "=", "options", ".", "ignore", ".", "map", "(", "patternUtils", ".", "unixifyPattern", ")", ";", "var", "positivePatterns", "=", "getPositivePatterns", "(", "unixPatterns", ")", ";", "var", "negativePatterns", "=", "getNegativePatternsAsPositive", "(", "unixPatterns", ",", "unixIgnore", ")", ";", "var", "staticPatterns", "=", "positivePatterns", ".", "filter", "(", "patternUtils", ".", "isStaticPattern", ")", ";", "var", "dynamicPatterns", "=", "positivePatterns", ".", "filter", "(", "patternUtils", ".", "isDynamicPattern", ")", ";", "var", "staticTasks", "=", "convertPatternsToTasks", "(", "staticPatterns", ",", "negativePatterns", ",", "/* dynamic */", "false", ")", ";", "var", "dynamicTasks", "=", "convertPatternsToTasks", "(", "dynamicPatterns", ",", "negativePatterns", ",", "/* dynamic */", "true", ")", ";", "return", "staticTasks", ".", "concat", "(", "dynamicTasks", ")", ";", "}"], "docstring": "Generate tasks based on parent directory of each pattern.", "docstring_tokens": ["Generate", "tasks", "based", "on", "parent", "directory", "of", "each", "pattern", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L14074-L14084", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "", "original_string": "function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;\n    var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;\n\n    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n\n    if (!isOutEvent && !isOverEvent) {\n      // Must not be a mouse or pointer in or out - ignoring.\n      return null;\n    }\n\n    var win = void 0;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from = void 0;\n    var to = void 0;\n    if (isOutEvent) {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var eventInterface = void 0,\n        leaveEventType = void 0,\n        enterEventType = void 0,\n        eventTypePrefix = void 0;\n\n    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {\n      eventInterface = SyntheticMouseEvent;\n      leaveEventType = eventTypes$2.mouseLeave;\n      enterEventType = eventTypes$2.mouseEnter;\n      eventTypePrefix = 'mouse';\n    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {\n      eventInterface = SyntheticPointerEvent;\n      leaveEventType = eventTypes$2.pointerLeave;\n      enterEventType = eventTypes$2.pointerEnter;\n      eventTypePrefix = 'pointer';\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);\n    leave.type = eventTypePrefix + 'leave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);\n    enter.type = eventTypePrefix + 'enter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }", "language": "javascript", "code": "function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;\n    var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;\n\n    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n\n    if (!isOutEvent && !isOverEvent) {\n      // Must not be a mouse or pointer in or out - ignoring.\n      return null;\n    }\n\n    var win = void 0;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from = void 0;\n    var to = void 0;\n    if (isOutEvent) {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var eventInterface = void 0,\n        leaveEventType = void 0,\n        enterEventType = void 0,\n        eventTypePrefix = void 0;\n\n    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {\n      eventInterface = SyntheticMouseEvent;\n      leaveEventType = eventTypes$2.mouseLeave;\n      enterEventType = eventTypes$2.mouseEnter;\n      eventTypePrefix = 'mouse';\n    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {\n      eventInterface = SyntheticPointerEvent;\n      leaveEventType = eventTypes$2.pointerLeave;\n      enterEventType = eventTypes$2.pointerEnter;\n      eventTypePrefix = 'pointer';\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);\n    leave.type = eventTypePrefix + 'leave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);\n    enter.type = eventTypePrefix + 'enter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }", "code_tokens": ["function", "(", "topLevelType", ",", "targetInst", ",", "nativeEvent", ",", "nativeEventTarget", ")", "{", "var", "isOverEvent", "=", "topLevelType", "===", "TOP_MOUSE_OVER", "||", "topLevelType", "===", "TOP_POINTER_OVER", ";", "var", "isOutEvent", "=", "topLevelType", "===", "TOP_MOUSE_OUT", "||", "topLevelType", "===", "TOP_POINTER_OUT", ";", "if", "(", "isOverEvent", "&&", "(", "nativeEvent", ".", "relatedTarget", "||", "nativeEvent", ".", "fromElement", ")", ")", "{", "return", "null", ";", "}", "if", "(", "!", "isOutEvent", "&&", "!", "isOverEvent", ")", "{", "// Must not be a mouse or pointer in or out - ignoring.", "return", "null", ";", "}", "var", "win", "=", "void", "0", ";", "if", "(", "nativeEventTarget", ".", "window", "===", "nativeEventTarget", ")", "{", "// `nativeEventTarget` is probably a window object.", "win", "=", "nativeEventTarget", ";", "}", "else", "{", "// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.", "var", "doc", "=", "nativeEventTarget", ".", "ownerDocument", ";", "if", "(", "doc", ")", "{", "win", "=", "doc", ".", "defaultView", "||", "doc", ".", "parentWindow", ";", "}", "else", "{", "win", "=", "window", ";", "}", "}", "var", "from", "=", "void", "0", ";", "var", "to", "=", "void", "0", ";", "if", "(", "isOutEvent", ")", "{", "from", "=", "targetInst", ";", "var", "related", "=", "nativeEvent", ".", "relatedTarget", "||", "nativeEvent", ".", "toElement", ";", "to", "=", "related", "?", "getClosestInstanceFromNode", "(", "related", ")", ":", "null", ";", "}", "else", "{", "// Moving to a node from outside the window.", "from", "=", "null", ";", "to", "=", "targetInst", ";", "}", "if", "(", "from", "===", "to", ")", "{", "// Nothing pertains to our managed components.", "return", "null", ";", "}", "var", "eventInterface", "=", "void", "0", ",", "leaveEventType", "=", "void", "0", ",", "enterEventType", "=", "void", "0", ",", "eventTypePrefix", "=", "void", "0", ";", "if", "(", "topLevelType", "===", "TOP_MOUSE_OUT", "||", "topLevelType", "===", "TOP_MOUSE_OVER", ")", "{", "eventInterface", "=", "SyntheticMouseEvent", ";", "leaveEventType", "=", "eventTypes$2", ".", "mouseLeave", ";", "enterEventType", "=", "eventTypes$2", ".", "mouseEnter", ";", "eventTypePrefix", "=", "'mouse'", ";", "}", "else", "if", "(", "topLevelType", "===", "TOP_POINTER_OUT", "||", "topLevelType", "===", "TOP_POINTER_OVER", ")", "{", "eventInterface", "=", "SyntheticPointerEvent", ";", "leaveEventType", "=", "eventTypes$2", ".", "pointerLeave", ";", "enterEventType", "=", "eventTypes$2", ".", "pointerEnter", ";", "eventTypePrefix", "=", "'pointer'", ";", "}", "var", "fromNode", "=", "from", "==", "null", "?", "win", ":", "getNodeFromInstance$1", "(", "from", ")", ";", "var", "toNode", "=", "to", "==", "null", "?", "win", ":", "getNodeFromInstance$1", "(", "to", ")", ";", "var", "leave", "=", "eventInterface", ".", "getPooled", "(", "leaveEventType", ",", "from", ",", "nativeEvent", ",", "nativeEventTarget", ")", ";", "leave", ".", "type", "=", "eventTypePrefix", "+", "'leave'", ";", "leave", ".", "target", "=", "fromNode", ";", "leave", ".", "relatedTarget", "=", "toNode", ";", "var", "enter", "=", "eventInterface", ".", "getPooled", "(", "enterEventType", ",", "to", ",", "nativeEvent", ",", "nativeEventTarget", ")", ";", "enter", ".", "type", "=", "eventTypePrefix", "+", "'enter'", ";", "enter", ".", "target", "=", "toNode", ";", "enter", ".", "relatedTarget", "=", "fromNode", ";", "accumulateEnterLeaveDispatches", "(", "leave", ",", "enter", ",", "from", ",", "to", ")", ";", "return", "[", "leave", ",", "enter", "]", ";", "}"], "docstring": "For almost every interaction we care about, there will be both a top-level\n`mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\nwe do not extract duplicate events. However, moving the mouse into the\nbrowser from outside will not fire a `mouseout` event. In this case, we use\nthe `mouseover` top-level event.", "docstring_tokens": ["For", "almost", "every", "interaction", "we", "care", "about", "there", "will", "be", "both", "a", "top", "-", "level", "mouseover", "and", "mouseout", "event", "that", "occurs", ".", "Only", "use", "mouseout", "so", "that", "we", "do", "not", "extract", "duplicate", "events", ".", "However", "moving", "the", "mouse", "into", "the", "browser", "from", "outside", "will", "not", "fire", "a", "mouseout", "event", ".", "In", "this", "case", "we", "use", "the", "mouseover", "top", "-", "level", "event", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L6275-L6352", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      // if we are not initialized, don't bother finalizing\n      if (!this._isInitialized) { return; }\n      this._isInitialized = false;\n  \n      this.triggerMethod('before:stop');\n  \n      // stop the sub-modules; depth-first, to make sure the\n      // sub-modules are stopped / finalized before parents\n      _.invoke(this.submodules, 'stop');\n  \n      // run the finalizers\n      this._finalizerCallbacks.run(undefined, this);\n  \n      // reset the initializers and finalizers\n      this._initializerCallbacks.reset();\n      this._finalizerCallbacks.reset();\n  \n      this.triggerMethod('stop');\n    }", "language": "javascript", "code": "function() {\n      // if we are not initialized, don't bother finalizing\n      if (!this._isInitialized) { return; }\n      this._isInitialized = false;\n  \n      this.triggerMethod('before:stop');\n  \n      // stop the sub-modules; depth-first, to make sure the\n      // sub-modules are stopped / finalized before parents\n      _.invoke(this.submodules, 'stop');\n  \n      // run the finalizers\n      this._finalizerCallbacks.run(undefined, this);\n  \n      // reset the initializers and finalizers\n      this._initializerCallbacks.reset();\n      this._finalizerCallbacks.reset();\n  \n      this.triggerMethod('stop');\n    }", "code_tokens": ["function", "(", ")", "{", "// if we are not initialized, don't bother finalizing", "if", "(", "!", "this", ".", "_isInitialized", ")", "{", "return", ";", "}", "this", ".", "_isInitialized", "=", "false", ";", "this", ".", "triggerMethod", "(", "'before:stop'", ")", ";", "// stop the sub-modules; depth-first, to make sure the", "// sub-modules are stopped / finalized before parents", "_", ".", "invoke", "(", "this", ".", "submodules", ",", "'stop'", ")", ";", "// run the finalizers", "this", ".", "_finalizerCallbacks", ".", "run", "(", "undefined", ",", "this", ")", ";", "// reset the initializers and finalizers", "this", ".", "_initializerCallbacks", ".", "reset", "(", ")", ";", "this", ".", "_finalizerCallbacks", ".", "reset", "(", ")", ";", "this", ".", "triggerMethod", "(", "'stop'", ")", ";", "}"], "docstring": "Stop this module by running its finalizers and then stop all of the sub-modules for this module", "docstring_tokens": ["Stop", "this", "module", "by", "running", "its", "finalizers", "and", "then", "stop", "all", "of", "the", "sub", "-", "modules", "for", "this", "module"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19860-L19879", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function() {\n        // Get the current value of the property\n        newClass = this._classStringForProperty(binding);\n        elem = this.$();\n\n        // If we had previously added a class to the element, remove it.\n        if (oldClass) {\n          elem.removeClass(oldClass);\n          // Also remove from classNames so that if the view gets rerendered,\n          // the class doesn't get added back to the DOM.\n          classNames.removeObject(oldClass);\n        }\n\n        // If necessary, add a new class. Make sure we keep track of it so\n        // it can be removed in the future.\n        if (newClass) {\n          elem.addClass(newClass);\n          oldClass = newClass;\n        } else {\n          oldClass = null;\n        }\n      }", "language": "javascript", "code": "function() {\n        // Get the current value of the property\n        newClass = this._classStringForProperty(binding);\n        elem = this.$();\n\n        // If we had previously added a class to the element, remove it.\n        if (oldClass) {\n          elem.removeClass(oldClass);\n          // Also remove from classNames so that if the view gets rerendered,\n          // the class doesn't get added back to the DOM.\n          classNames.removeObject(oldClass);\n        }\n\n        // If necessary, add a new class. Make sure we keep track of it so\n        // it can be removed in the future.\n        if (newClass) {\n          elem.addClass(newClass);\n          oldClass = newClass;\n        } else {\n          oldClass = null;\n        }\n      }", "code_tokens": ["function", "(", ")", "{", "// Get the current value of the property", "newClass", "=", "this", ".", "_classStringForProperty", "(", "binding", ")", ";", "elem", "=", "this", ".", "$", "(", ")", ";", "// If we had previously added a class to the element, remove it.", "if", "(", "oldClass", ")", "{", "elem", ".", "removeClass", "(", "oldClass", ")", ";", "// Also remove from classNames so that if the view gets rerendered,", "// the class doesn't get added back to the DOM.", "classNames", ".", "removeObject", "(", "oldClass", ")", ";", "}", "// If necessary, add a new class. Make sure we keep track of it so", "// it can be removed in the future.", "if", "(", "newClass", ")", "{", "elem", ".", "addClass", "(", "newClass", ")", ";", "oldClass", "=", "newClass", ";", "}", "else", "{", "oldClass", "=", "null", ";", "}", "}"], "docstring": "Set up an observer on the context. If the property changes, toggle the class name.", "docstring_tokens": ["Set", "up", "an", "observer", "on", "the", "context", ".", "If", "the", "property", "changes", "toggle", "the", "class", "name", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L23626-L23647", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "constructSelectEvent", "original_string": "function constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  var doc = getEventTargetDocument(nativeEventTarget);\n\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}", "language": "javascript", "code": "function constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  var doc = getEventTargetDocument(nativeEventTarget);\n\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}", "code_tokens": ["function", "constructSelectEvent", "(", "nativeEvent", ",", "nativeEventTarget", ")", "{", "// Ensure we have the right element, and that the user is not dragging a", "// selection (this matches native `select` event behavior). In HTML5, select", "// fires only on input and textarea thus if there's no focused element we", "// won't dispatch.", "var", "doc", "=", "getEventTargetDocument", "(", "nativeEventTarget", ")", ";", "if", "(", "mouseDown", "||", "activeElement$1", "==", "null", "||", "activeElement$1", "!==", "getActiveElement", "(", "doc", ")", ")", "{", "return", "null", ";", "}", "// Only fire when selection has actually changed.", "var", "currentSelection", "=", "getSelection", "(", "activeElement$1", ")", ";", "if", "(", "!", "lastSelection", "||", "!", "shallowEqual", "(", "lastSelection", ",", "currentSelection", ")", ")", "{", "lastSelection", "=", "currentSelection", ";", "var", "syntheticEvent", "=", "SyntheticEvent", ".", "getPooled", "(", "eventTypes$3", ".", "select", ",", "activeElementInst$1", ",", "nativeEvent", ",", "nativeEventTarget", ")", ";", "syntheticEvent", ".", "type", "=", "'select'", ";", "syntheticEvent", ".", "target", "=", "activeElement$1", ";", "accumulateTwoPhaseDispatches", "(", "syntheticEvent", ")", ";", "return", "syntheticEvent", ";", "}", "return", "null", ";", "}"], "docstring": "Poll selection to see whether it's changed.\n\n@param {object} nativeEvent\n@param {object} nativeEventTarget\n@return {?SyntheticEvent}", "docstring_tokens": ["Poll", "selection", "to", "see", "whether", "it", "s", "changed", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L7912-L7939", "partition": "test"}
{"repo": "pb82/MissMatch", "path": "lib/MissMatch.js", "func_name": "parseNumericLiteral", "original_string": "function parseNumericLiteral(AST) {\n    var literal = [], value;\n\n    while(hasNext() && validNum(peek())) {\n      literal[literal.length] = next();\n    }\n\n    value = parseFloat(literal.join(''));\n    \n    /**\n     * Thanks to CMS's answer on StackOverflow:\n     * http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\n     */\n    if(!isNaN(value) && isFinite(value)) {\n      newNode(value, newNode('=', AST).nodes);\n    } else {\n        unexpectedTokenException('numeric');\n    }\n  }", "language": "javascript", "code": "function parseNumericLiteral(AST) {\n    var literal = [], value;\n\n    while(hasNext() && validNum(peek())) {\n      literal[literal.length] = next();\n    }\n\n    value = parseFloat(literal.join(''));\n    \n    /**\n     * Thanks to CMS's answer on StackOverflow:\n     * http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\n     */\n    if(!isNaN(value) && isFinite(value)) {\n      newNode(value, newNode('=', AST).nodes);\n    } else {\n        unexpectedTokenException('numeric');\n    }\n  }", "code_tokens": ["function", "parseNumericLiteral", "(", "AST", ")", "{", "var", "literal", "=", "[", "]", ",", "value", ";", "while", "(", "hasNext", "(", ")", "&&", "validNum", "(", "peek", "(", ")", ")", ")", "{", "literal", "[", "literal", ".", "length", "]", "=", "next", "(", ")", ";", "}", "value", "=", "parseFloat", "(", "literal", ".", "join", "(", "''", ")", ")", ";", "/**\n     * Thanks to CMS's answer on StackOverflow:\n     * http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\n     */", "if", "(", "!", "isNaN", "(", "value", ")", "&&", "isFinite", "(", "value", ")", ")", "{", "newNode", "(", "value", ",", "newNode", "(", "'='", ",", "AST", ")", ".", "nodes", ")", ";", "}", "else", "{", "unexpectedTokenException", "(", "'numeric'", ")", ";", "}", "}"], "docstring": "Parse numeric literals like 1, 1.05, .05, 8e5...", "docstring_tokens": ["Parse", "numeric", "literals", "like", "1", "1", ".", "05", ".", "05", "8e5", "..."], "sha": "13153714c2e4b7fd613c3309131806cfb32ea39f", "url": "https://github.com/pb82/MissMatch/blob/13153714c2e4b7fd613c3309131806cfb32ea39f/lib/MissMatch.js#L317-L335", "partition": "test"}
{"repo": "Wiredcraft/file-register", "path": "lib/proto.js", "func_name": "subRegister", "original_string": "function subRegister(obj, name) {\n  var res;\n  res = isPrimitive(obj[name]) ? {} : obj[name];\n  return obj[name] = mixable(res).mixin(proto, 'register', 'extend');\n}", "language": "javascript", "code": "function subRegister(obj, name) {\n  var res;\n  res = isPrimitive(obj[name]) ? {} : obj[name];\n  return obj[name] = mixable(res).mixin(proto, 'register', 'extend');\n}", "code_tokens": ["function", "subRegister", "(", "obj", ",", "name", ")", "{", "var", "res", ";", "res", "=", "isPrimitive", "(", "obj", "[", "name", "]", ")", "?", "{", "}", ":", "obj", "[", "name", "]", ";", "return", "obj", "[", "name", "]", "=", "mixable", "(", "res", ")", ".", "mixin", "(", "proto", ",", "'register'", ",", "'extend'", ")", ";", "}"], "docstring": "Get or build a sub register for an object.", "docstring_tokens": ["Get", "or", "build", "a", "sub", "register", "for", "an", "object", "."], "sha": "6393edebdcd7074eba41fc2838988772da7b1766", "url": "https://github.com/Wiredcraft/file-register/blob/6393edebdcd7074eba41fc2838988772da7b1766/lib/proto.js#L16-L20", "partition": "test"}
{"repo": "tjmehta/coworkers", "path": "lib/rabbit-utils/create-app-channel.js", "func_name": "errorHandler", "original_string": "function errorHandler (app, key, err) {\n  // delete app key\n  delete app[key]\n  // log and adjust err message\n  const msg = `\"app.${key}\" unexpectedly errored: ${err.message}`\n  debug(msg, err)\n  err.message = msg\n  // throw the error\n  throw err\n}", "language": "javascript", "code": "function errorHandler (app, key, err) {\n  // delete app key\n  delete app[key]\n  // log and adjust err message\n  const msg = `\"app.${key}\" unexpectedly errored: ${err.message}`\n  debug(msg, err)\n  err.message = msg\n  // throw the error\n  throw err\n}", "code_tokens": ["function", "errorHandler", "(", "app", ",", "key", ",", "err", ")", "{", "// delete app key", "delete", "app", "[", "key", "]", "// log and adjust err message", "const", "msg", "=", "`", "${", "key", "}", "${", "err", ".", "message", "}", "`", "debug", "(", "msg", ",", "err", ")", "err", ".", "message", "=", "msg", "// throw the error", "throw", "err", "}"], "docstring": "channel error handler", "docstring_tokens": ["channel", "error", "handler"], "sha": "358049d2e77e9bfe4eab4ebf384ccb7cade9f11b", "url": "https://github.com/tjmehta/coworkers/blob/358049d2e77e9bfe4eab4ebf384ccb7cade9f11b/lib/rabbit-utils/create-app-channel.js#L71-L80", "partition": "test"}
{"repo": "ProseMirror/prosemirror-test-builder", "path": "src/build.js", "func_name": "mark", "original_string": "function mark(type, attrs) {\n  return function(...args) {\n    let mark = type.create(takeAttrs(attrs, args))\n    let {nodes, tag} = flatten(type.schema, args, n => mark.type.isInSet(n.marks) ? n : n.mark(mark.addToSet(n.marks)))\n    return {flat: nodes, tag}\n  }\n}", "language": "javascript", "code": "function mark(type, attrs) {\n  return function(...args) {\n    let mark = type.create(takeAttrs(attrs, args))\n    let {nodes, tag} = flatten(type.schema, args, n => mark.type.isInSet(n.marks) ? n : n.mark(mark.addToSet(n.marks)))\n    return {flat: nodes, tag}\n  }\n}", "code_tokens": ["function", "mark", "(", "type", ",", "attrs", ")", "{", "return", "function", "(", "...", "args", ")", "{", "let", "mark", "=", "type", ".", "create", "(", "takeAttrs", "(", "attrs", ",", "args", ")", ")", "let", "{", "nodes", ",", "tag", "}", "=", "flatten", "(", "type", ".", "schema", ",", "args", ",", "n", "=>", "mark", ".", "type", ".", "isInSet", "(", "n", ".", "marks", ")", "?", "n", ":", "n", ".", "mark", "(", "mark", ".", "addToSet", "(", "n", ".", "marks", ")", ")", ")", "return", "{", "flat", ":", "nodes", ",", "tag", "}", "}", "}"], "docstring": "Create a builder function for marks.", "docstring_tokens": ["Create", "a", "builder", "function", "for", "marks", "."], "sha": "bd55c5dea11aaefc1e398b91138fc323a8383c25", "url": "https://github.com/ProseMirror/prosemirror-test-builder/blob/bd55c5dea11aaefc1e398b91138fc323a8383c25/src/build.js#L74-L80", "partition": "test"}
{"repo": "sinnerschrader/schlump", "path": "src/css.js", "func_name": "combineCss", "original_string": "function combineCss(templates, scopedCss) {\n\tif (!Array.isArray(scopedCss)) {\n\t\tscopedCss = [scopedCss];\n\t}\n\treturn [\n\t\t...Object.keys(templates).map(name => templates[name].css),\n\t\t...scopedCss\n\t]\n\t.join('\\n').trim();\n}", "language": "javascript", "code": "function combineCss(templates, scopedCss) {\n\tif (!Array.isArray(scopedCss)) {\n\t\tscopedCss = [scopedCss];\n\t}\n\treturn [\n\t\t...Object.keys(templates).map(name => templates[name].css),\n\t\t...scopedCss\n\t]\n\t.join('\\n').trim();\n}", "code_tokens": ["function", "combineCss", "(", "templates", ",", "scopedCss", ")", "{", "if", "(", "!", "Array", ".", "isArray", "(", "scopedCss", ")", ")", "{", "scopedCss", "=", "[", "scopedCss", "]", ";", "}", "return", "[", "...", "Object", ".", "keys", "(", "templates", ")", ".", "map", "(", "name", "=>", "templates", "[", "name", "]", ".", "css", ")", ",", "...", "scopedCss", "]", ".", "join", "(", "'\\n'", ")", ".", "trim", "(", ")", ";", "}"], "docstring": "Returns a combined CSS from all component CSS and scopedCss.\n\n@param {object} templates A map of schlump templates\n@param {string[]} scopedCss A list of page CSS\n@returns {string} CSS result", "docstring_tokens": ["Returns", "a", "combined", "CSS", "from", "all", "component", "CSS", "and", "scopedCss", "."], "sha": "1049761c781c42cc1ce32e9fb53f32c4d055e32c", "url": "https://github.com/sinnerschrader/schlump/blob/1049761c781c42cc1ce32e9fb53f32c4d055e32c/src/css.js#L78-L87", "partition": "test"}
{"repo": "campsi/campsi-service-docs", "path": "lib/modules/queryBuilder.js", "func_name": "getStateFromOptions", "original_string": "function getStateFromOptions (options, propertyName) {\n  propertyName = propertyName || 'state';\n  const stateName = options[propertyName] || options.resource.defaultState;\n  let stateObj = options.resource.states[stateName] || {validate: false};\n  stateObj.name = stateName;\n  return stateObj;\n}", "language": "javascript", "code": "function getStateFromOptions (options, propertyName) {\n  propertyName = propertyName || 'state';\n  const stateName = options[propertyName] || options.resource.defaultState;\n  let stateObj = options.resource.states[stateName] || {validate: false};\n  stateObj.name = stateName;\n  return stateObj;\n}", "code_tokens": ["function", "getStateFromOptions", "(", "options", ",", "propertyName", ")", "{", "propertyName", "=", "propertyName", "||", "'state'", ";", "const", "stateName", "=", "options", "[", "propertyName", "]", "||", "options", ".", "resource", ".", "defaultState", ";", "let", "stateObj", "=", "options", ".", "resource", ".", "states", "[", "stateName", "]", "||", "{", "validate", ":", "false", "}", ";", "stateObj", ".", "name", "=", "stateName", ";", "return", "stateObj", ";", "}"], "docstring": "Retreive the state object descriptor from its name\n@param {object} options\n@param {string} [propertyName]\n@returns {State}", "docstring_tokens": ["Retreive", "the", "state", "object", "descriptor", "from", "its", "name"], "sha": "ce08f9599f9e96a6d57daac5975da7b041b0236c", "url": "https://github.com/campsi/campsi-service-docs/blob/ce08f9599f9e96a6d57daac5975da7b041b0236c/lib/modules/queryBuilder.js#L19-L25", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/types/time-uuid.js", "func_name": "getTimeWithTicks", "original_string": "function getTimeWithTicks(date, ticks) {\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    // time with ticks for the current time\n    date = new Date();\n    const time = date.getTime();\n    _ticksForCurrentTime++;\n    if(_ticksForCurrentTime > _ticksInMs || time > _lastTimestamp) {\n      _ticksForCurrentTime = 0;\n      _lastTimestamp = time;\n    }\n    ticks = _ticksForCurrentTime;\n  }\n  return {\n    time: date.getTime(),\n    ticks: getTicks(ticks)\n  };\n}", "language": "javascript", "code": "function getTimeWithTicks(date, ticks) {\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    // time with ticks for the current time\n    date = new Date();\n    const time = date.getTime();\n    _ticksForCurrentTime++;\n    if(_ticksForCurrentTime > _ticksInMs || time > _lastTimestamp) {\n      _ticksForCurrentTime = 0;\n      _lastTimestamp = time;\n    }\n    ticks = _ticksForCurrentTime;\n  }\n  return {\n    time: date.getTime(),\n    ticks: getTicks(ticks)\n  };\n}", "code_tokens": ["function", "getTimeWithTicks", "(", "date", ",", "ticks", ")", "{", "if", "(", "!", "(", "date", "instanceof", "Date", ")", "||", "isNaN", "(", "date", ".", "getTime", "(", ")", ")", ")", "{", "// time with ticks for the current time", "date", "=", "new", "Date", "(", ")", ";", "const", "time", "=", "date", ".", "getTime", "(", ")", ";", "_ticksForCurrentTime", "++", ";", "if", "(", "_ticksForCurrentTime", ">", "_ticksInMs", "||", "time", ">", "_lastTimestamp", ")", "{", "_ticksForCurrentTime", "=", "0", ";", "_lastTimestamp", "=", "time", ";", "}", "ticks", "=", "_ticksForCurrentTime", ";", "}", "return", "{", "time", ":", "date", ".", "getTime", "(", ")", ",", "ticks", ":", "getTicks", "(", "ticks", ")", "}", ";", "}"], "docstring": "Returns an object with the time representation of the date expressed in milliseconds since unix epoch\nand a ticks property for the 100-nanoseconds precision.\n@private\n@returns {{time: Number, ticks: Number}}", "docstring_tokens": ["Returns", "an", "object", "with", "the", "time", "representation", "of", "the", "date", "expressed", "in", "milliseconds", "since", "unix", "epoch", "and", "a", "ticks", "property", "for", "the", "100", "-", "nanoseconds", "precision", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/types/time-uuid.js#L330-L346", "partition": "test"}
{"repo": "tstachl/desk.js", "path": "lib/mixins/create.js", "func_name": "create", "original_string": "function create(parent, baseUrl, params, callback) {\n  parent.getClient().post(baseUrl, params, function(err, definition, response) {\n    if (err) return callback(err);\n    callback(null, new this(parent, definition));\n  }.bind(this));\n}", "language": "javascript", "code": "function create(parent, baseUrl, params, callback) {\n  parent.getClient().post(baseUrl, params, function(err, definition, response) {\n    if (err) return callback(err);\n    callback(null, new this(parent, definition));\n  }.bind(this));\n}", "code_tokens": ["function", "create", "(", "parent", ",", "baseUrl", ",", "params", ",", "callback", ")", "{", "parent", ".", "getClient", "(", ")", ".", "post", "(", "baseUrl", ",", "params", ",", "function", "(", "err", ",", "definition", ",", "response", ")", "{", "if", "(", "err", ")", "return", "callback", "(", "err", ")", ";", "callback", "(", "null", ",", "new", "this", "(", "parent", ",", "definition", ")", ")", ";", "}", ".", "bind", "(", "this", ")", ")", ";", "}"], "docstring": "Creates a new resource.\n\n@param {Function} parent The parent this resource should be attached to.\n@param {String} baseUrl That's needed for sub resources (/api/v2/customers/1/cases).\n@param {Object} params The params to use for the resource.\n@param {Function} callback The callback called with the new resource or error.\n@api public", "docstring_tokens": ["Creates", "a", "new", "resource", "."], "sha": "b339196cce68dbbc79d3075f2ebe82372972f4f5", "url": "https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/mixins/create.js#L19-L24", "partition": "test"}
{"repo": "unfoldingWord-dev/node-resource-container", "path": "lib/main.js", "func_name": "", "original_string": "function(chapterSlug, chunkSlug) {\n            let file = path.join(container_directory, content_dir, chapterSlug, chunkSlug + '.' + this.chunkExt);\n            return fs.readFileSync(file, {encoding: 'utf8'});\n        }", "language": "javascript", "code": "function(chapterSlug, chunkSlug) {\n            let file = path.join(container_directory, content_dir, chapterSlug, chunkSlug + '.' + this.chunkExt);\n            return fs.readFileSync(file, {encoding: 'utf8'});\n        }", "code_tokens": ["function", "(", "chapterSlug", ",", "chunkSlug", ")", "{", "let", "file", "=", "path", ".", "join", "(", "container_directory", ",", "content_dir", ",", "chapterSlug", ",", "chunkSlug", "+", "'.'", "+", "this", ".", "chunkExt", ")", ";", "return", "fs", ".", "readFileSync", "(", "file", ",", "{", "encoding", ":", "'utf8'", "}", ")", ";", "}"], "docstring": "Returns the contents of a chunk.\nIf the chunk does not exist or there is an exception an empty string will be returned.\n@param chapterSlug\n@param chunkSlug\n@returns string the contents of the chunk", "docstring_tokens": ["Returns", "the", "contents", "of", "a", "chunk", ".", "If", "the", "chunk", "does", "not", "exist", "or", "there", "is", "an", "exception", "an", "empty", "string", "will", "be", "returned", "."], "sha": "20c4b7bfd2fa3f397ee7e0e743567822912c305b", "url": "https://github.com/unfoldingWord-dev/node-resource-container/blob/20c4b7bfd2fa3f397ee7e0e743567822912c305b/lib/main.js#L124-L127", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/data/NodeInterface.js", "func_name": "", "original_string": "function(node, refNode, suppressEvents) {\n                    var me = this,\n                        index     = me.indexOf(refNode),\n                        oldParent = node.parentNode,\n                        refIndex  = index,\n                        ps;\n\n                    if (!refNode) { // like standard Dom, refNode can be null for append\n                        return me.appendChild(node);\n                    }\n\n                    // nothing to do\n                    if (node == refNode) {\n                        return false;\n                    }\n\n                    // Make sure it is a record with the NodeInterface\n                    node = me.createNode(node);\n\n                    if (suppressEvents !== true && me.fireEvent(\"beforeinsert\", me, node, refNode) === false) {\n                        return false;\n                    }\n\n                    // when moving internally, indexes will change after remove\n                    if (oldParent == me && me.indexOf(node) < index) {\n                        refIndex--;\n                    }\n\n                    // it's a move, make sure we move it cleanly\n                    if (oldParent) {\n                        if (suppressEvents !== true && node.fireEvent(\"beforemove\", node, oldParent, me, index, refNode) === false) {\n                            return false;\n                        }\n                        oldParent.removeChild(node);\n                    }\n\n                    if (refIndex === 0) {\n                        me.setFirstChild(node);\n                    }\n\n                    Ext.Array.splice(me.childNodes, refIndex, 0, node);\n                    node.parentNode = me;\n\n                    node.nextSibling = refNode;\n                    refNode.previousSibling = node;\n\n                    ps = me.childNodes[refIndex - 1];\n                    if (ps) {\n                        node.previousSibling = ps;\n                        ps.nextSibling = node;\n                        ps.updateInfo();\n                    } else {\n                        node.previousSibling = null;\n                    }\n\n                    node.updateInfo();\n\n                    if (!me.isLoaded()) {\n                        me.set('loaded', true);\n                    }\n                    // If this node didn't have any childnodes before, update myself\n                    else if (me.childNodes.length === 1) {\n                        me.set('loaded', me.isLoaded());\n                    }\n\n                    if (suppressEvents !== true) {\n                        me.fireEvent(\"insert\", me, node, refNode);\n\n                        if (oldParent) {\n                            node.fireEvent(\"move\", node, oldParent, me, refIndex, refNode);\n                        }\n                    }\n\n                    return node;\n                }", "language": "javascript", "code": "function(node, refNode, suppressEvents) {\n                    var me = this,\n                        index     = me.indexOf(refNode),\n                        oldParent = node.parentNode,\n                        refIndex  = index,\n                        ps;\n\n                    if (!refNode) { // like standard Dom, refNode can be null for append\n                        return me.appendChild(node);\n                    }\n\n                    // nothing to do\n                    if (node == refNode) {\n                        return false;\n                    }\n\n                    // Make sure it is a record with the NodeInterface\n                    node = me.createNode(node);\n\n                    if (suppressEvents !== true && me.fireEvent(\"beforeinsert\", me, node, refNode) === false) {\n                        return false;\n                    }\n\n                    // when moving internally, indexes will change after remove\n                    if (oldParent == me && me.indexOf(node) < index) {\n                        refIndex--;\n                    }\n\n                    // it's a move, make sure we move it cleanly\n                    if (oldParent) {\n                        if (suppressEvents !== true && node.fireEvent(\"beforemove\", node, oldParent, me, index, refNode) === false) {\n                            return false;\n                        }\n                        oldParent.removeChild(node);\n                    }\n\n                    if (refIndex === 0) {\n                        me.setFirstChild(node);\n                    }\n\n                    Ext.Array.splice(me.childNodes, refIndex, 0, node);\n                    node.parentNode = me;\n\n                    node.nextSibling = refNode;\n                    refNode.previousSibling = node;\n\n                    ps = me.childNodes[refIndex - 1];\n                    if (ps) {\n                        node.previousSibling = ps;\n                        ps.nextSibling = node;\n                        ps.updateInfo();\n                    } else {\n                        node.previousSibling = null;\n                    }\n\n                    node.updateInfo();\n\n                    if (!me.isLoaded()) {\n                        me.set('loaded', true);\n                    }\n                    // If this node didn't have any childnodes before, update myself\n                    else if (me.childNodes.length === 1) {\n                        me.set('loaded', me.isLoaded());\n                    }\n\n                    if (suppressEvents !== true) {\n                        me.fireEvent(\"insert\", me, node, refNode);\n\n                        if (oldParent) {\n                            node.fireEvent(\"move\", node, oldParent, me, refIndex, refNode);\n                        }\n                    }\n\n                    return node;\n                }", "code_tokens": ["function", "(", "node", ",", "refNode", ",", "suppressEvents", ")", "{", "var", "me", "=", "this", ",", "index", "=", "me", ".", "indexOf", "(", "refNode", ")", ",", "oldParent", "=", "node", ".", "parentNode", ",", "refIndex", "=", "index", ",", "ps", ";", "if", "(", "!", "refNode", ")", "{", "// like standard Dom, refNode can be null for append", "return", "me", ".", "appendChild", "(", "node", ")", ";", "}", "// nothing to do", "if", "(", "node", "==", "refNode", ")", "{", "return", "false", ";", "}", "// Make sure it is a record with the NodeInterface", "node", "=", "me", ".", "createNode", "(", "node", ")", ";", "if", "(", "suppressEvents", "!==", "true", "&&", "me", ".", "fireEvent", "(", "\"beforeinsert\"", ",", "me", ",", "node", ",", "refNode", ")", "===", "false", ")", "{", "return", "false", ";", "}", "// when moving internally, indexes will change after remove", "if", "(", "oldParent", "==", "me", "&&", "me", ".", "indexOf", "(", "node", ")", "<", "index", ")", "{", "refIndex", "--", ";", "}", "// it's a move, make sure we move it cleanly", "if", "(", "oldParent", ")", "{", "if", "(", "suppressEvents", "!==", "true", "&&", "node", ".", "fireEvent", "(", "\"beforemove\"", ",", "node", ",", "oldParent", ",", "me", ",", "index", ",", "refNode", ")", "===", "false", ")", "{", "return", "false", ";", "}", "oldParent", ".", "removeChild", "(", "node", ")", ";", "}", "if", "(", "refIndex", "===", "0", ")", "{", "me", ".", "setFirstChild", "(", "node", ")", ";", "}", "Ext", ".", "Array", ".", "splice", "(", "me", ".", "childNodes", ",", "refIndex", ",", "0", ",", "node", ")", ";", "node", ".", "parentNode", "=", "me", ";", "node", ".", "nextSibling", "=", "refNode", ";", "refNode", ".", "previousSibling", "=", "node", ";", "ps", "=", "me", ".", "childNodes", "[", "refIndex", "-", "1", "]", ";", "if", "(", "ps", ")", "{", "node", ".", "previousSibling", "=", "ps", ";", "ps", ".", "nextSibling", "=", "node", ";", "ps", ".", "updateInfo", "(", ")", ";", "}", "else", "{", "node", ".", "previousSibling", "=", "null", ";", "}", "node", ".", "updateInfo", "(", ")", ";", "if", "(", "!", "me", ".", "isLoaded", "(", ")", ")", "{", "me", ".", "set", "(", "'loaded'", ",", "true", ")", ";", "}", "// If this node didn't have any childnodes before, update myself", "else", "if", "(", "me", ".", "childNodes", ".", "length", "===", "1", ")", "{", "me", ".", "set", "(", "'loaded'", ",", "me", ".", "isLoaded", "(", ")", ")", ";", "}", "if", "(", "suppressEvents", "!==", "true", ")", "{", "me", ".", "fireEvent", "(", "\"insert\"", ",", "me", ",", "node", ",", "refNode", ")", ";", "if", "(", "oldParent", ")", "{", "node", ".", "fireEvent", "(", "\"move\"", ",", "node", ",", "oldParent", ",", "me", ",", "refIndex", ",", "refNode", ")", ";", "}", "}", "return", "node", ";", "}"], "docstring": "Inserts the first node before the second node in this nodes `childNodes` collection.\n@param {Ext.data.NodeInterface} node The node to insert.\n@param {Ext.data.NodeInterface} refNode The node to insert before (if `null` the node is appended).\n@return {Ext.data.NodeInterface} The inserted node.", "docstring_tokens": ["Inserts", "the", "first", "node", "before", "the", "second", "node", "in", "this", "nodes", "childNodes", "collection", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeInterface.js#L608-L682", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/input-generators/textfile.js", "func_name": "generateInput", "original_string": "function generateInput (options) {\n  return nodeCall(\n    fs.readFile,\n    options.source\n  )\n    .catch(function (err) {\n      options._abort(err);\n    })\n    .then(function (data) {\n      var error;\n\n      if (data) {\n        data.toString().split('\\n').every(function (line) {\n          var page = line.replace(/^\\s+|\\s+$/g, \"\");\n\n          if (!base.input(options, page)) {\n            error = common.prependMsgToErr(base.generatorError(), page, true);\n            return false;\n          }\n          return true;\n        });\n\n        if (error) {\n          console.error(error);\n          options._abort(error);\n        }\n      }\n\n      base.EOI(textfile);\n    });\n}", "language": "javascript", "code": "function generateInput (options) {\n  return nodeCall(\n    fs.readFile,\n    options.source\n  )\n    .catch(function (err) {\n      options._abort(err);\n    })\n    .then(function (data) {\n      var error;\n\n      if (data) {\n        data.toString().split('\\n').every(function (line) {\n          var page = line.replace(/^\\s+|\\s+$/g, \"\");\n\n          if (!base.input(options, page)) {\n            error = common.prependMsgToErr(base.generatorError(), page, true);\n            return false;\n          }\n          return true;\n        });\n\n        if (error) {\n          console.error(error);\n          options._abort(error);\n        }\n      }\n\n      base.EOI(textfile);\n    });\n}", "code_tokens": ["function", "generateInput", "(", "options", ")", "{", "return", "nodeCall", "(", "fs", ".", "readFile", ",", "options", ".", "source", ")", ".", "catch", "(", "function", "(", "err", ")", "{", "options", ".", "_abort", "(", "err", ")", ";", "}", ")", ".", "then", "(", "function", "(", "data", ")", "{", "var", "error", ";", "if", "(", "data", ")", "{", "data", ".", "toString", "(", ")", ".", "split", "(", "'\\n'", ")", ".", "every", "(", "function", "(", "line", ")", "{", "var", "page", "=", "line", ".", "replace", "(", "/", "^\\s+|\\s+$", "/", "g", ",", "\"\"", ")", ";", "if", "(", "!", "base", ".", "input", "(", "options", ",", "page", ")", ")", "{", "error", "=", "common", ".", "prependMsgToErr", "(", "base", ".", "generatorError", "(", ")", ",", "page", ",", "true", ")", ";", "return", "false", ";", "}", "return", "true", ";", "}", ")", ";", "if", "(", "error", ")", "{", "console", ".", "error", "(", "error", ")", ";", "options", ".", "_abort", "(", "error", ")", ";", "}", "}", "base", ".", "EOI", "(", "textfile", ")", ";", "}", ")", ";", "}"], "docstring": "Generate the snapshot arguments from a line oriented text file.\nEach line contains a single url we need a snapshot for.\n\n@param {Object} options - input generator options object.\n@param {String} options.source - path to the local input file.\n@returns {Promise} resolves when complete.", "docstring_tokens": ["Generate", "the", "snapshot", "arguments", "from", "a", "line", "oriented", "text", "file", ".", "Each", "line", "contains", "a", "single", "url", "we", "need", "a", "snapshot", "for", "."], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/input-generators/textfile.js#L33-L63", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "parseConfigFileTextToJson", "original_string": "function parseConfigFileTextToJson(fileName, jsonText) {\n        try {\n            return { config: /\\S/.test(jsonText) ? JSON.parse(jsonText) : {} };\n        }\n        catch (e) {\n            return { error: ts.createCompilerDiagnostic(ts.Diagnostics.Failed_to_parse_file_0_Colon_1, fileName, e.message) };\n        }\n    }", "language": "javascript", "code": "function parseConfigFileTextToJson(fileName, jsonText) {\n        try {\n            return { config: /\\S/.test(jsonText) ? JSON.parse(jsonText) : {} };\n        }\n        catch (e) {\n            return { error: ts.createCompilerDiagnostic(ts.Diagnostics.Failed_to_parse_file_0_Colon_1, fileName, e.message) };\n        }\n    }", "code_tokens": ["function", "parseConfigFileTextToJson", "(", "fileName", ",", "jsonText", ")", "{", "try", "{", "return", "{", "config", ":", "/", "\\S", "/", ".", "test", "(", "jsonText", ")", "?", "JSON", ".", "parse", "(", "jsonText", ")", ":", "{", "}", "}", ";", "}", "catch", "(", "e", ")", "{", "return", "{", "error", ":", "ts", ".", "createCompilerDiagnostic", "(", "ts", ".", "Diagnostics", ".", "Failed_to_parse_file_0_Colon_1", ",", "fileName", ",", "e", ".", "message", ")", "}", ";", "}", "}"], "docstring": "Parse the text of the tsconfig.json file\n@param fileName The path to the config file\n@param jsonText The text of the config file", "docstring_tokens": ["Parse", "the", "text", "of", "the", "tsconfig", ".", "json", "file"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L37281-L37288", "partition": "test"}
{"repo": "trendmicro-frontend/react-liquid-gauge", "path": "docs/bundle.js", "func_name": "shouldYield", "original_string": "function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }", "language": "javascript", "code": "function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }", "code_tokens": ["function", "shouldYield", "(", ")", "{", "if", "(", "deadline", "===", "null", ")", "{", "return", "false", ";", "}", "if", "(", "deadline", ".", "timeRemaining", "(", ")", ">", "timeHeuristicForUnitOfWork", ")", "{", "return", "false", ";", "}", "deadlineDidExpire", "=", "true", ";", "return", "true", ";", "}"], "docstring": "When working on async work, the reconciler asks the renderer if it should yield execution. For DOM, we implement this with requestIdleCallback.", "docstring_tokens": ["When", "working", "on", "async", "work", "the", "reconciler", "asks", "the", "renderer", "if", "it", "should", "yield", "execution", ".", "For", "DOM", "we", "implement", "this", "with", "requestIdleCallback", "."], "sha": "c8b24bd48a504539e25553a66097466f75917af6", "url": "https://github.com/trendmicro-frontend/react-liquid-gauge/blob/c8b24bd48a504539e25553a66097466f75917af6/docs/bundle.js#L27328-L27337", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(fullName) {\n        validateFullName(fullName);\n\n        var normalizedName = this.normalize(fullName);\n        var cached = this.resolveCache.get(normalizedName);\n\n        if (cached) { return cached; }\n\n        var resolved = this.resolver(normalizedName) || this.registry.get(normalizedName);\n\n        this.resolveCache.set(normalizedName, resolved);\n\n        return resolved;\n      }", "language": "javascript", "code": "function(fullName) {\n        validateFullName(fullName);\n\n        var normalizedName = this.normalize(fullName);\n        var cached = this.resolveCache.get(normalizedName);\n\n        if (cached) { return cached; }\n\n        var resolved = this.resolver(normalizedName) || this.registry.get(normalizedName);\n\n        this.resolveCache.set(normalizedName, resolved);\n\n        return resolved;\n      }", "code_tokens": ["function", "(", "fullName", ")", "{", "validateFullName", "(", "fullName", ")", ";", "var", "normalizedName", "=", "this", ".", "normalize", "(", "fullName", ")", ";", "var", "cached", "=", "this", ".", "resolveCache", ".", "get", "(", "normalizedName", ")", ";", "if", "(", "cached", ")", "{", "return", "cached", ";", "}", "var", "resolved", "=", "this", ".", "resolver", "(", "normalizedName", ")", "||", "this", ".", "registry", ".", "get", "(", "normalizedName", ")", ";", "this", ".", "resolveCache", ".", "set", "(", "normalizedName", ",", "resolved", ")", ";", "return", "resolved", ";", "}"], "docstring": "Given a fullName return the corresponding factory.\n\nBy default `resolve` will retrieve the factory from\nits container's registry.\n\n```javascript\nvar container = new Container();\ncontainer.register('api:twitter', Twitter);\n\ncontainer.resolve('api:twitter') // => Twitter\n```\n\nOptionally the container can be provided with a custom resolver.\nIf provided, `resolve` will first provide the custom resolver\nthe oppertunity to resolve the fullName, otherwise it will fallback\nto the registry.\n\n```javascript\nvar container = new Container();\ncontainer.resolver = function(fullName) {\nlookup via the module system of choice\n};\n\nthe twitter factory is added to the module system\ncontainer.resolve('api:twitter') // => Twitter\n```\n\n@method resolve\n@param {String} fullName\n@return {Function} fullName's factory", "docstring_tokens": ["Given", "a", "fullName", "return", "the", "corresponding", "factory", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L10922-L10935", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(outletName, view) {\n    var existingView = get(this, '_outlets.'+outletName);\n    return existingView &&\n      existingView.constructor === view.constructor &&\n      existingView.get('template') === view.get('template') &&\n      existingView.get('context') === view.get('context');\n  }", "language": "javascript", "code": "function(outletName, view) {\n    var existingView = get(this, '_outlets.'+outletName);\n    return existingView &&\n      existingView.constructor === view.constructor &&\n      existingView.get('template') === view.get('template') &&\n      existingView.get('context') === view.get('context');\n  }", "code_tokens": ["function", "(", "outletName", ",", "view", ")", "{", "var", "existingView", "=", "get", "(", "this", ",", "'_outlets.'", "+", "outletName", ")", ";", "return", "existingView", "&&", "existingView", ".", "constructor", "===", "view", ".", "constructor", "&&", "existingView", ".", "get", "(", "'template'", ")", "===", "view", ".", "get", "(", "'template'", ")", "&&", "existingView", ".", "get", "(", "'context'", ")", "===", "view", ".", "get", "(", "'context'", ")", ";", "}"], "docstring": "Determines if the view has already been created by checking if\nthe view has the same constructor, template, and context as the\nview in the `_outlets` object.\n\n@private\n@method _hasEquivalentView\n@param  {String} outletName The name of the outlet we are checking\n@param  {Object} view       An Ember.View\n@return {Boolean}", "docstring_tokens": ["Determines", "if", "the", "view", "has", "already", "been", "created", "by", "checking", "if", "the", "view", "has", "the", "same", "constructor", "template", "and", "context", "as", "the", "view", "in", "the", "_outlets", "object", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L38986-L38992", "partition": "test"}
{"repo": "fomeboy/agency", "path": "lib/journal.js", "func_name": "journal", "original_string": "function journal() {\n  'use strict';\n  \n  var fs = require('fs');\n\n  // private properties\n  var eventList = {\n    'creationEvents' : {},\n    'executionEvents' : {} \n  };\n  var logMode;\n\n  // sets the log method: 'q', 'v' or 'l'\n  // exposed by the agency constructor\n  function setLogMode(mode) {\n    logMode = mode;\n  }\n \n  // records the agent's validation and creation events in a temporary structure if log method is 'l' or \n  // outputs the same events to the console if method is 'v' \n  function logCreationEvent(id, type, message, time) {\n    \n    if (logMode === 'l') {\n      if (!eventList.creationEvents[id]) {\n        eventList.creationEvents[id] =  [];\n      }\n      eventList.creationEvents[id].push({'type': type, 'event': message, \"timestamp\": time});\n    } else if (logMode === 'v') {\n      console.log(type + ': Agent ' + id +  ' ' + message + ' on ' + time);\n    }\n\n  }\n\n  // records the agent's execution events in a temporary structure if log method is 'l' or \n  // outputs the same events to the console if method is 'v' \n  function logExecutionEvent(id, type, message, time) {\n\n    if (logMode === 'l') {\n      if (!eventList.executionEvents[id]) {\n        eventList.executionEvents[id] =  [];\n      }\n      eventList.executionEvents[id].push({'type': type, 'event': message, \"timestamp\": time});\n    } else if (logMode === 'v') {\n      console.log(type + ': Agent ' + id +  ' ' + message + ' on ' + time);\n    }\n\n  }\n\n  // outputs the contents of the temporary creation and execution structure to a specific file\n  // defined by the user; if file is not defined outputs to a default file; otherwise outputs error to the console\n  function report(logFile) {\n    var defaultLogFile = (new Date()).toJSON() + '.log';\n    var data = JSON.stringify(eventList, null, 3);\n\n    if (logFile) {\n      fs.writeFile(logFile, data, function(err) {\n        if(err) {\n          console.log('\\nCould not write log to file \"' + logFile + '\"\\n' + err);\n          fs.writeFile(defaultLogFile, data, function(err) {\n            if(err) {\n              console.log('Could not write log file: ' + err);\n            } else {\n              console.log('Log was written on default file \"' + defaultLogFile + '\"');\n            }\n          });\n        }\n      });\n    } else {\n      fs.writeFile(defaultLogFile, data, function(err) {\n        if(err) {\n          console.log('Could not write log file: ' + err);\n        }\n      });\n    }\n  }\n\n  //public interface\n  return {\n    setLogMode: setLogMode,\n    logCreationEvent: logCreationEvent,\n    logExecutionEvent: logExecutionEvent,\n    report: report\n  };\n}", "language": "javascript", "code": "function journal() {\n  'use strict';\n  \n  var fs = require('fs');\n\n  // private properties\n  var eventList = {\n    'creationEvents' : {},\n    'executionEvents' : {} \n  };\n  var logMode;\n\n  // sets the log method: 'q', 'v' or 'l'\n  // exposed by the agency constructor\n  function setLogMode(mode) {\n    logMode = mode;\n  }\n \n  // records the agent's validation and creation events in a temporary structure if log method is 'l' or \n  // outputs the same events to the console if method is 'v' \n  function logCreationEvent(id, type, message, time) {\n    \n    if (logMode === 'l') {\n      if (!eventList.creationEvents[id]) {\n        eventList.creationEvents[id] =  [];\n      }\n      eventList.creationEvents[id].push({'type': type, 'event': message, \"timestamp\": time});\n    } else if (logMode === 'v') {\n      console.log(type + ': Agent ' + id +  ' ' + message + ' on ' + time);\n    }\n\n  }\n\n  // records the agent's execution events in a temporary structure if log method is 'l' or \n  // outputs the same events to the console if method is 'v' \n  function logExecutionEvent(id, type, message, time) {\n\n    if (logMode === 'l') {\n      if (!eventList.executionEvents[id]) {\n        eventList.executionEvents[id] =  [];\n      }\n      eventList.executionEvents[id].push({'type': type, 'event': message, \"timestamp\": time});\n    } else if (logMode === 'v') {\n      console.log(type + ': Agent ' + id +  ' ' + message + ' on ' + time);\n    }\n\n  }\n\n  // outputs the contents of the temporary creation and execution structure to a specific file\n  // defined by the user; if file is not defined outputs to a default file; otherwise outputs error to the console\n  function report(logFile) {\n    var defaultLogFile = (new Date()).toJSON() + '.log';\n    var data = JSON.stringify(eventList, null, 3);\n\n    if (logFile) {\n      fs.writeFile(logFile, data, function(err) {\n        if(err) {\n          console.log('\\nCould not write log to file \"' + logFile + '\"\\n' + err);\n          fs.writeFile(defaultLogFile, data, function(err) {\n            if(err) {\n              console.log('Could not write log file: ' + err);\n            } else {\n              console.log('Log was written on default file \"' + defaultLogFile + '\"');\n            }\n          });\n        }\n      });\n    } else {\n      fs.writeFile(defaultLogFile, data, function(err) {\n        if(err) {\n          console.log('Could not write log file: ' + err);\n        }\n      });\n    }\n  }\n\n  //public interface\n  return {\n    setLogMode: setLogMode,\n    logCreationEvent: logCreationEvent,\n    logExecutionEvent: logExecutionEvent,\n    report: report\n  };\n}", "code_tokens": ["function", "journal", "(", ")", "{", "'use strict'", ";", "var", "fs", "=", "require", "(", "'fs'", ")", ";", "// private properties", "var", "eventList", "=", "{", "'creationEvents'", ":", "{", "}", ",", "'executionEvents'", ":", "{", "}", "}", ";", "var", "logMode", ";", "// sets the log method: 'q', 'v' or 'l'", "// exposed by the agency constructor", "function", "setLogMode", "(", "mode", ")", "{", "logMode", "=", "mode", ";", "}", "// records the agent's validation and creation events in a temporary structure if log method is 'l' or ", "// outputs the same events to the console if method is 'v' ", "function", "logCreationEvent", "(", "id", ",", "type", ",", "message", ",", "time", ")", "{", "if", "(", "logMode", "===", "'l'", ")", "{", "if", "(", "!", "eventList", ".", "creationEvents", "[", "id", "]", ")", "{", "eventList", ".", "creationEvents", "[", "id", "]", "=", "[", "]", ";", "}", "eventList", ".", "creationEvents", "[", "id", "]", ".", "push", "(", "{", "'type'", ":", "type", ",", "'event'", ":", "message", ",", "\"timestamp\"", ":", "time", "}", ")", ";", "}", "else", "if", "(", "logMode", "===", "'v'", ")", "{", "console", ".", "log", "(", "type", "+", "': Agent '", "+", "id", "+", "' '", "+", "message", "+", "' on '", "+", "time", ")", ";", "}", "}", "// records the agent's execution events in a temporary structure if log method is 'l' or ", "// outputs the same events to the console if method is 'v' ", "function", "logExecutionEvent", "(", "id", ",", "type", ",", "message", ",", "time", ")", "{", "if", "(", "logMode", "===", "'l'", ")", "{", "if", "(", "!", "eventList", ".", "executionEvents", "[", "id", "]", ")", "{", "eventList", ".", "executionEvents", "[", "id", "]", "=", "[", "]", ";", "}", "eventList", ".", "executionEvents", "[", "id", "]", ".", "push", "(", "{", "'type'", ":", "type", ",", "'event'", ":", "message", ",", "\"timestamp\"", ":", "time", "}", ")", ";", "}", "else", "if", "(", "logMode", "===", "'v'", ")", "{", "console", ".", "log", "(", "type", "+", "': Agent '", "+", "id", "+", "' '", "+", "message", "+", "' on '", "+", "time", ")", ";", "}", "}", "// outputs the contents of the temporary creation and execution structure to a specific file", "// defined by the user; if file is not defined outputs to a default file; otherwise outputs error to the console", "function", "report", "(", "logFile", ")", "{", "var", "defaultLogFile", "=", "(", "new", "Date", "(", ")", ")", ".", "toJSON", "(", ")", "+", "'.log'", ";", "var", "data", "=", "JSON", ".", "stringify", "(", "eventList", ",", "null", ",", "3", ")", ";", "if", "(", "logFile", ")", "{", "fs", ".", "writeFile", "(", "logFile", ",", "data", ",", "function", "(", "err", ")", "{", "if", "(", "err", ")", "{", "console", ".", "log", "(", "'\\nCould not write log to file \"'", "+", "logFile", "+", "'\"\\n'", "+", "err", ")", ";", "fs", ".", "writeFile", "(", "defaultLogFile", ",", "data", ",", "function", "(", "err", ")", "{", "if", "(", "err", ")", "{", "console", ".", "log", "(", "'Could not write log file: '", "+", "err", ")", ";", "}", "else", "{", "console", ".", "log", "(", "'Log was written on default file \"'", "+", "defaultLogFile", "+", "'\"'", ")", ";", "}", "}", ")", ";", "}", "}", ")", ";", "}", "else", "{", "fs", ".", "writeFile", "(", "defaultLogFile", ",", "data", ",", "function", "(", "err", ")", "{", "if", "(", "err", ")", "{", "console", ".", "log", "(", "'Could not write log file: '", "+", "err", ")", ";", "}", "}", ")", ";", "}", "}", "//public interface", "return", "{", "setLogMode", ":", "setLogMode", ",", "logCreationEvent", ":", "logCreationEvent", ",", "logExecutionEvent", ":", "logExecutionEvent", ",", "report", ":", "report", "}", ";", "}"], "docstring": "journal.js\n\nThe journal module implements the logging logic of agency.js\nThree methods are available by passing a parameter to the agency constructor:\n'q' quiet, produces no log\n'v' verbose, log is displayed on the console (recommended during development)\n'l' log, writes the creation and execution events in a file (recommended for production)\n\nCopyright 2016 Fernando Pires\n\nReleased under the MIT License.\n\n--------------------------------------------------------\n\nauthor:  Fernando Pires\nversion: 1.0.0", "docstring_tokens": ["journal", ".", "js"], "sha": "9a04b031142d5d44b09757444b899662b1d93b48", "url": "https://github.com/fomeboy/agency/blob/9a04b031142d5d44b09757444b899662b1d93b48/lib/journal.js#L20-L103", "partition": "test"}
{"repo": "apache/cordova-plugin-media", "path": "src/windows/MediaProxy.js", "func_name": "", "original_string": "function(win, lose, args) {\n        var id = args[0];\n        try {\n            var p = (Media.get(id)).node.currentTime;\n            win(p);\n        } catch (err) {\n            lose(err);\n        }\n    }", "language": "javascript", "code": "function(win, lose, args) {\n        var id = args[0];\n        try {\n            var p = (Media.get(id)).node.currentTime;\n            win(p);\n        } catch (err) {\n            lose(err);\n        }\n    }", "code_tokens": ["function", "(", "win", ",", "lose", ",", "args", ")", "{", "var", "id", "=", "args", "[", "0", "]", ";", "try", "{", "var", "p", "=", "(", "Media", ".", "get", "(", "id", ")", ")", ".", "node", ".", "currentTime", ";", "win", "(", "p", ")", ";", "}", "catch", "(", "err", ")", "{", "lose", "(", "err", ")", ";", "}", "}"], "docstring": "Gets current position in the audio", "docstring_tokens": ["Gets", "current", "position", "in", "the", "audio"], "sha": "b1c135342619f773fee3e8693a46992a133efd56", "url": "https://github.com/apache/cordova-plugin-media/blob/b1c135342619f773fee3e8693a46992a133efd56/src/windows/MediaProxy.js#L171-L179", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(view, index) {\n      // Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or\n      // Region#show() handles this.\n      var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);\n      var nestedViews;\n  \n      // set up the child view event forwarding\n      this.proxyChildEvents(view);\n  \n      view.once('render', function() {\n        // trigger the 'before:show' event on `view` if the collection view has already been shown\n        if (this._isShown && !this.isBuffering) {\n          Marionette.triggerMethodOn(view, 'before:show', view);\n        }\n  \n        // Trigger `before:attach` following `render` to avoid adding logic and event triggers\n        // to public method `renderChildView()`.\n        if (canTriggerAttach && this._triggerBeforeAttach) {\n          nestedViews = this._getViewAndNested(view);\n          this._triggerMethodMany(nestedViews, this, 'before:attach');\n        }\n      }, this);\n  \n      // Store the child view itself so we can properly remove and/or destroy it later\n      this.children.add(view);\n      this.renderChildView(view, index);\n  \n      // Trigger `attach`\n      if (canTriggerAttach && this._triggerAttach) {\n        nestedViews = this._getViewAndNested(view);\n        this._triggerMethodMany(nestedViews, this, 'attach');\n      }\n      // Trigger `show`\n      if (this._isShown && !this.isBuffering) {\n        Marionette.triggerMethodOn(view, 'show', view);\n      }\n    }", "language": "javascript", "code": "function(view, index) {\n      // Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or\n      // Region#show() handles this.\n      var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);\n      var nestedViews;\n  \n      // set up the child view event forwarding\n      this.proxyChildEvents(view);\n  \n      view.once('render', function() {\n        // trigger the 'before:show' event on `view` if the collection view has already been shown\n        if (this._isShown && !this.isBuffering) {\n          Marionette.triggerMethodOn(view, 'before:show', view);\n        }\n  \n        // Trigger `before:attach` following `render` to avoid adding logic and event triggers\n        // to public method `renderChildView()`.\n        if (canTriggerAttach && this._triggerBeforeAttach) {\n          nestedViews = this._getViewAndNested(view);\n          this._triggerMethodMany(nestedViews, this, 'before:attach');\n        }\n      }, this);\n  \n      // Store the child view itself so we can properly remove and/or destroy it later\n      this.children.add(view);\n      this.renderChildView(view, index);\n  \n      // Trigger `attach`\n      if (canTriggerAttach && this._triggerAttach) {\n        nestedViews = this._getViewAndNested(view);\n        this._triggerMethodMany(nestedViews, this, 'attach');\n      }\n      // Trigger `show`\n      if (this._isShown && !this.isBuffering) {\n        Marionette.triggerMethodOn(view, 'show', view);\n      }\n    }", "code_tokens": ["function", "(", "view", ",", "index", ")", "{", "// Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or", "// Region#show() handles this.", "var", "canTriggerAttach", "=", "this", ".", "_isShown", "&&", "!", "this", ".", "isBuffering", "&&", "Marionette", ".", "isNodeAttached", "(", "this", ".", "el", ")", ";", "var", "nestedViews", ";", "// set up the child view event forwarding", "this", ".", "proxyChildEvents", "(", "view", ")", ";", "view", ".", "once", "(", "'render'", ",", "function", "(", ")", "{", "// trigger the 'before:show' event on `view` if the collection view has already been shown", "if", "(", "this", ".", "_isShown", "&&", "!", "this", ".", "isBuffering", ")", "{", "Marionette", ".", "triggerMethodOn", "(", "view", ",", "'before:show'", ",", "view", ")", ";", "}", "// Trigger `before:attach` following `render` to avoid adding logic and event triggers", "// to public method `renderChildView()`.", "if", "(", "canTriggerAttach", "&&", "this", ".", "_triggerBeforeAttach", ")", "{", "nestedViews", "=", "this", ".", "_getViewAndNested", "(", "view", ")", ";", "this", ".", "_triggerMethodMany", "(", "nestedViews", ",", "this", ",", "'before:attach'", ")", ";", "}", "}", ",", "this", ")", ";", "// Store the child view itself so we can properly remove and/or destroy it later", "this", ".", "children", ".", "add", "(", "view", ")", ";", "this", ".", "renderChildView", "(", "view", ",", "index", ")", ";", "// Trigger `attach`", "if", "(", "canTriggerAttach", "&&", "this", ".", "_triggerAttach", ")", "{", "nestedViews", "=", "this", ".", "_getViewAndNested", "(", "view", ")", ";", "this", ".", "_triggerMethodMany", "(", "nestedViews", ",", "this", ",", "'attach'", ")", ";", "}", "// Trigger `show`", "if", "(", "this", ".", "_isShown", "&&", "!", "this", ".", "isBuffering", ")", "{", "Marionette", ".", "triggerMethodOn", "(", "view", ",", "'show'", ",", "view", ")", ";", "}", "}"], "docstring": "Internal Method. Add the view to children and render it at the given index.", "docstring_tokens": ["Internal", "Method", ".", "Add", "the", "view", "to", "children", "and", "render", "it", "at", "the", "given", "index", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18704-L18740", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/migration/ObjectStoreMigrator.js", "func_name": "createIndex", "original_string": "function createIndex(objectStore, indexSchema) {\n  let indexNames = Array.from(objectStore.indexNames)\n\n  if (indexNames.indexOf(indexSchema.name) !== -1) {\n    return\n  }\n\n  objectStore.createIndex(indexSchema.name, indexSchema.keyPath, {\n    unique: indexSchema.unique,\n    multiEntry: indexSchema.multiEntry\n  })\n}", "language": "javascript", "code": "function createIndex(objectStore, indexSchema) {\n  let indexNames = Array.from(objectStore.indexNames)\n\n  if (indexNames.indexOf(indexSchema.name) !== -1) {\n    return\n  }\n\n  objectStore.createIndex(indexSchema.name, indexSchema.keyPath, {\n    unique: indexSchema.unique,\n    multiEntry: indexSchema.multiEntry\n  })\n}", "code_tokens": ["function", "createIndex", "(", "objectStore", ",", "indexSchema", ")", "{", "let", "indexNames", "=", "Array", ".", "from", "(", "objectStore", ".", "indexNames", ")", "if", "(", "indexNames", ".", "indexOf", "(", "indexSchema", ".", "name", ")", "!==", "-", "1", ")", "{", "return", "}", "objectStore", ".", "createIndex", "(", "indexSchema", ".", "name", ",", "indexSchema", ".", "keyPath", ",", "{", "unique", ":", "indexSchema", ".", "unique", ",", "multiEntry", ":", "indexSchema", ".", "multiEntry", "}", ")", "}"], "docstring": "Creates a new index in the provided object store according to the provided\nindex schema.\n\n@param {IDBObjectStore} objectStore The native Indexed DB object store.\n@param {IndexSchema} indexSchema The schema of the index to create.", "docstring_tokens": ["Creates", "a", "new", "index", "in", "the", "provided", "object", "store", "according", "to", "the", "provided", "index", "schema", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/migration/ObjectStoreMigrator.js#L122-L133", "partition": "test"}
{"repo": "emmetio/codemirror-plugin", "path": "lib/extract-abbreviation.js", "func_name": "canExtract", "original_string": "function canExtract(editor, pos, config) {\n\tconst tokenType = editor.getTokenTypeAt(pos);\n\n\tif (config.type === 'stylesheet') {\n\t\treturn tokenType !== 'comment' && tokenType !== 'string';\n\t}\n\n\tif (config.syntax === 'html') {\n\t\treturn tokenType === null;\n\t}\n\n\tif (config.syntax === 'slim' || config.syntax === 'pug') {\n\t\treturn tokenType === null || tokenType === 'tag'\n\t\t\t|| (tokenType && /attribute/.test(tokenType));\n\t}\n\n\tif (config.syntax === 'haml') {\n\t\treturn tokenType === null || tokenType === 'attribute';\n\t}\n\n\tif (config.syntax === 'jsx') {\n\t\t// JSX a bit tricky, delegate it to caller\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "language": "javascript", "code": "function canExtract(editor, pos, config) {\n\tconst tokenType = editor.getTokenTypeAt(pos);\n\n\tif (config.type === 'stylesheet') {\n\t\treturn tokenType !== 'comment' && tokenType !== 'string';\n\t}\n\n\tif (config.syntax === 'html') {\n\t\treturn tokenType === null;\n\t}\n\n\tif (config.syntax === 'slim' || config.syntax === 'pug') {\n\t\treturn tokenType === null || tokenType === 'tag'\n\t\t\t|| (tokenType && /attribute/.test(tokenType));\n\t}\n\n\tif (config.syntax === 'haml') {\n\t\treturn tokenType === null || tokenType === 'attribute';\n\t}\n\n\tif (config.syntax === 'jsx') {\n\t\t// JSX a bit tricky, delegate it to caller\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "code_tokens": ["function", "canExtract", "(", "editor", ",", "pos", ",", "config", ")", "{", "const", "tokenType", "=", "editor", ".", "getTokenTypeAt", "(", "pos", ")", ";", "if", "(", "config", ".", "type", "===", "'stylesheet'", ")", "{", "return", "tokenType", "!==", "'comment'", "&&", "tokenType", "!==", "'string'", ";", "}", "if", "(", "config", ".", "syntax", "===", "'html'", ")", "{", "return", "tokenType", "===", "null", ";", "}", "if", "(", "config", ".", "syntax", "===", "'slim'", "||", "config", ".", "syntax", "===", "'pug'", ")", "{", "return", "tokenType", "===", "null", "||", "tokenType", "===", "'tag'", "||", "(", "tokenType", "&&", "/", "attribute", "/", ".", "test", "(", "tokenType", ")", ")", ";", "}", "if", "(", "config", ".", "syntax", "===", "'haml'", ")", "{", "return", "tokenType", "===", "null", "||", "tokenType", "===", "'attribute'", ";", "}", "if", "(", "config", ".", "syntax", "===", "'jsx'", ")", "{", "// JSX a bit tricky, delegate it to caller", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Check if abbreviation can be extracted from given position\n@param {CodeMirror.Editor} editor\n@param {CodeMirror.Position} pos\n@param {Object} config\n@return {Boolean}", "docstring_tokens": ["Check", "if", "abbreviation", "can", "be", "extracted", "from", "given", "position"], "sha": "2089c8b15b97858b82b33e6e81ee1b50954581c1", "url": "https://github.com/emmetio/codemirror-plugin/blob/2089c8b15b97858b82b33e6e81ee1b50954581c1/lib/extract-abbreviation.js#L61-L87", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/platform/src/data/sync/DatabaseDefinition.js", "func_name": "", "original_string": "function(config,callback,scope) {\n\t\t//\n\t\tExt.data.utilities.check('DatabaseDefinition', 'constructor', 'config', config, ['key','database_name','generation','system_name','replica_number']);\n\t\t//\n\t\tthis.set(config);\n\t\tconfig.config_id= 'definition';\n\t\tExt.data.DatabaseDefinition.superclass.constructor.call(this, config);\n\t}", "language": "javascript", "code": "function(config,callback,scope) {\n\t\t//\n\t\tExt.data.utilities.check('DatabaseDefinition', 'constructor', 'config', config, ['key','database_name','generation','system_name','replica_number']);\n\t\t//\n\t\tthis.set(config);\n\t\tconfig.config_id= 'definition';\n\t\tExt.data.DatabaseDefinition.superclass.constructor.call(this, config);\n\t}", "code_tokens": ["function", "(", "config", ",", "callback", ",", "scope", ")", "{", "//", "Ext", ".", "data", ".", "utilities", ".", "check", "(", "'DatabaseDefinition'", ",", "'constructor'", ",", "'config'", ",", "config", ",", "[", "'key'", ",", "'database_name'", ",", "'generation'", ",", "'system_name'", ",", "'replica_number'", "]", ")", ";", "//", "this", ".", "set", "(", "config", ")", ";", "config", ".", "config_id", "=", "'definition'", ";", "Ext", ".", "data", ".", "DatabaseDefinition", ".", "superclass", ".", "constructor", ".", "call", "(", "this", ",", "config", ")", ";", "}"], "docstring": "of the storage scheme JCM include the epoch of the clock here?", "docstring_tokens": ["of", "the", "storage", "scheme", "JCM", "include", "the", "epoch", "of", "the", "clock", "here?"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/platform/src/data/sync/DatabaseDefinition.js#L16-L23", "partition": "test"}
{"repo": "rrrene/inchjs", "path": "lib/inch.js", "func_name": "run", "original_string": "function run(inch_args, options) {\n  var callback = function(filename) {\n      LocalInch.run(inch_args || ['suggest'], filename, noop);\n    }\n\n  if( options.dry_run ) callback = noop;\n  retriever.run(PathExtractor.extractPaths(inch_args), callback);\n}", "language": "javascript", "code": "function run(inch_args, options) {\n  var callback = function(filename) {\n      LocalInch.run(inch_args || ['suggest'], filename, noop);\n    }\n\n  if( options.dry_run ) callback = noop;\n  retriever.run(PathExtractor.extractPaths(inch_args), callback);\n}", "code_tokens": ["function", "run", "(", "inch_args", ",", "options", ")", "{", "var", "callback", "=", "function", "(", "filename", ")", "{", "LocalInch", ".", "run", "(", "inch_args", "||", "[", "'suggest'", "]", ",", "filename", ",", "noop", ")", ";", "}", "if", "(", "options", ".", "dry_run", ")", "callback", "=", "noop", ";", "retriever", ".", "run", "(", "PathExtractor", ".", "extractPaths", "(", "inch_args", ")", ",", "callback", ")", ";", "}"], "docstring": "Runs a local version of Inch.", "docstring_tokens": ["Runs", "a", "local", "version", "of", "Inch", "."], "sha": "453b4dac7a75707afc217fbacdea501179e0e5a4", "url": "https://github.com/rrrene/inchjs/blob/453b4dac7a75707afc217fbacdea501179e0e5a4/lib/inch.js#L18-L25", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "", "original_string": "function(facetName) {\n    if (!this.isHierarchicalFacet(facetName)) {\n      throw new Error(\n        'Cannot get the breadcrumb of an unknown hierarchical facet: `' + facetName + '`');\n    }\n\n    var refinement = this.getHierarchicalRefinement(facetName)[0];\n    if (!refinement) return [];\n\n    var separator = this._getHierarchicalFacetSeparator(\n      this.getHierarchicalFacetByName(facetName)\n    );\n    var path = refinement.split(separator);\n    return map(path, trim);\n  }", "language": "javascript", "code": "function(facetName) {\n    if (!this.isHierarchicalFacet(facetName)) {\n      throw new Error(\n        'Cannot get the breadcrumb of an unknown hierarchical facet: `' + facetName + '`');\n    }\n\n    var refinement = this.getHierarchicalRefinement(facetName)[0];\n    if (!refinement) return [];\n\n    var separator = this._getHierarchicalFacetSeparator(\n      this.getHierarchicalFacetByName(facetName)\n    );\n    var path = refinement.split(separator);\n    return map(path, trim);\n  }", "code_tokens": ["function", "(", "facetName", ")", "{", "if", "(", "!", "this", ".", "isHierarchicalFacet", "(", "facetName", ")", ")", "{", "throw", "new", "Error", "(", "'Cannot get the breadcrumb of an unknown hierarchical facet: `'", "+", "facetName", "+", "'`'", ")", ";", "}", "var", "refinement", "=", "this", ".", "getHierarchicalRefinement", "(", "facetName", ")", "[", "0", "]", ";", "if", "(", "!", "refinement", ")", "return", "[", "]", ";", "var", "separator", "=", "this", ".", "_getHierarchicalFacetSeparator", "(", "this", ".", "getHierarchicalFacetByName", "(", "facetName", ")", ")", ";", "var", "path", "=", "refinement", ".", "split", "(", "separator", ")", ";", "return", "map", "(", "path", ",", "trim", ")", ";", "}"], "docstring": "Get the current breadcrumb for a hierarchical facet, as an array\n@param  {string} facetName Hierarchical facet name\n@return {array.<string>} the path as an array of string", "docstring_tokens": ["Get", "the", "current", "breadcrumb", "for", "a", "hierarchical", "facet", "as", "an", "array"], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L1692-L1706", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/views/Feed/FeedMeta.js", "func_name": "FeedMeta", "original_string": "function FeedMeta(props) {\n  const { children, className, content, like } = props\n\n  const classes = cx('meta', className)\n  const rest = getUnhandledProps(FeedMeta, props)\n  const ElementType = getElementType(FeedMeta, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedLike, val => ({ content: val }), like, { autoGenerateKey: false })}\n      {content}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function FeedMeta(props) {\n  const { children, className, content, like } = props\n\n  const classes = cx('meta', className)\n  const rest = getUnhandledProps(FeedMeta, props)\n  const ElementType = getElementType(FeedMeta, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedLike, val => ({ content: val }), like, { autoGenerateKey: false })}\n      {content}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "FeedMeta", "(", "props", ")", "{", "const", "{", "children", ",", "className", ",", "content", ",", "like", "}", "=", "props", "const", "classes", "=", "cx", "(", "'meta'", ",", "className", ")", "const", "rest", "=", "getUnhandledProps", "(", "FeedMeta", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "FeedMeta", ",", "props", ")", "if", "(", "!", "childrenUtils", ".", "isNil", "(", "children", ")", ")", "{", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "children", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "createShorthand", "(", "FeedLike", ",", "val", "=>", "(", "{", "content", ":", "val", "}", ")", ",", "like", ",", "{", "autoGenerateKey", ":", "false", "}", ")", "}", "\n      ", "{", "content", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A feed can contain a meta.", "docstring_tokens": ["A", "feed", "can", "contain", "a", "meta", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/views/Feed/FeedMeta.js#L17-L38", "partition": "test"}
{"repo": "nearform/nscale-kernel", "path": "lib/api.js", "func_name": "", "original_string": "function(user, identifier, comment, out, cb) {\n    logger.info('commit system: ' + identifier);\n    var systemId = _sr.findSystem(identifier);\n\n    _sr.commitRevision(user, systemId, comment, function(err, revisionId) {\n      _sr.getDeployedTargets(systemId, function(err, targets) {\n        if (targets) {\n          async.eachSeries(targets, function(target, next) {\n            if (target.commit === 'edits') {\n              _sr.markDeployedRevision(user, systemId, revisionId, target.env, function() {\n                next();\n              });\n            }\n            else {\n              next();\n            }\n          }, function() { \n            cb(err, revisionId); \n          });\n        }\n        else {\n          cb(err, revisionId);\n        }\n      });\n    });\n  }", "language": "javascript", "code": "function(user, identifier, comment, out, cb) {\n    logger.info('commit system: ' + identifier);\n    var systemId = _sr.findSystem(identifier);\n\n    _sr.commitRevision(user, systemId, comment, function(err, revisionId) {\n      _sr.getDeployedTargets(systemId, function(err, targets) {\n        if (targets) {\n          async.eachSeries(targets, function(target, next) {\n            if (target.commit === 'edits') {\n              _sr.markDeployedRevision(user, systemId, revisionId, target.env, function() {\n                next();\n              });\n            }\n            else {\n              next();\n            }\n          }, function() { \n            cb(err, revisionId); \n          });\n        }\n        else {\n          cb(err, revisionId);\n        }\n      });\n    });\n  }", "code_tokens": ["function", "(", "user", ",", "identifier", ",", "comment", ",", "out", ",", "cb", ")", "{", "logger", ".", "info", "(", "'commit system: '", "+", "identifier", ")", ";", "var", "systemId", "=", "_sr", ".", "findSystem", "(", "identifier", ")", ";", "_sr", ".", "commitRevision", "(", "user", ",", "systemId", ",", "comment", ",", "function", "(", "err", ",", "revisionId", ")", "{", "_sr", ".", "getDeployedTargets", "(", "systemId", ",", "function", "(", "err", ",", "targets", ")", "{", "if", "(", "targets", ")", "{", "async", ".", "eachSeries", "(", "targets", ",", "function", "(", "target", ",", "next", ")", "{", "if", "(", "target", ".", "commit", "===", "'edits'", ")", "{", "_sr", ".", "markDeployedRevision", "(", "user", ",", "systemId", ",", "revisionId", ",", "target", ".", "env", ",", "function", "(", ")", "{", "next", "(", ")", ";", "}", ")", ";", "}", "else", "{", "next", "(", ")", ";", "}", "}", ",", "function", "(", ")", "{", "cb", "(", "err", ",", "revisionId", ")", ";", "}", ")", ";", "}", "else", "{", "cb", "(", "err", ",", "revisionId", ")", ";", "}", "}", ")", ";", "}", ")", ";", "}"], "docstring": "commit the system", "docstring_tokens": ["commit", "the", "system"], "sha": "5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3", "url": "https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/api.js#L654-L679", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "rangeCheck", "original_string": "function rangeCheck(fnName, index, maxIndex) {\n  if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n    throw new Error('Failed to execute \\'' + fnName + '\\' on \\'TimeRanges\\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');\n  }\n}", "language": "javascript", "code": "function rangeCheck(fnName, index, maxIndex) {\n  if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n    throw new Error('Failed to execute \\'' + fnName + '\\' on \\'TimeRanges\\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');\n  }\n}", "code_tokens": ["function", "rangeCheck", "(", "fnName", ",", "index", ",", "maxIndex", ")", "{", "if", "(", "typeof", "index", "!==", "'number'", "||", "index", "<", "0", "||", "index", ">", "maxIndex", ")", "{", "throw", "new", "Error", "(", "'Failed to execute \\''", "+", "fnName", "+", "'\\' on \\'TimeRanges\\': The index provided ('", "+", "index", "+", "') is non-numeric or out of bounds (0-'", "+", "maxIndex", "+", "').'", ")", ";", "}", "}"], "docstring": "An object that contains ranges of time for various reasons.\n\n@typedef {Object} TimeRange\n\n@property {number} length\nThe number of time ranges represented by this Object\n\n@property {time-ranges:indexFunction} start\nReturns the time offset at which a specified time range begins.\n\n@property {time-ranges:indexFunction} end\nReturns the time offset at which a specified time range begins.\n\n@see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n \nCheck if any of the time ranges are over the maximum index.\n\n@param {string} fnName\nThe function name to use for logging\n\n@param {number} index\nThe index to check\n\n@param {number} maxIndex\nThe maximum possible index\n\n@throws {Error} if the timeRanges provided are over the maxIndex", "docstring_tokens": ["An", "object", "that", "contains", "ranges", "of", "time", "for", "various", "reasons", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L4656-L4660", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "removeTagRefinement", "original_string": "function removeTagRefinement(tag) {\n    if (!this.isTagRefined(tag)) return this;\n\n    var modification = {\n      tagRefinements: filter(this.tagRefinements, function(t) { return t !== tag; })\n    };\n\n    return this.setQueryParameters(modification);\n  }", "language": "javascript", "code": "function removeTagRefinement(tag) {\n    if (!this.isTagRefined(tag)) return this;\n\n    var modification = {\n      tagRefinements: filter(this.tagRefinements, function(t) { return t !== tag; })\n    };\n\n    return this.setQueryParameters(modification);\n  }", "code_tokens": ["function", "removeTagRefinement", "(", "tag", ")", "{", "if", "(", "!", "this", ".", "isTagRefined", "(", "tag", ")", ")", "return", "this", ";", "var", "modification", "=", "{", "tagRefinements", ":", "filter", "(", "this", ".", "tagRefinements", ",", "function", "(", "t", ")", "{", "return", "t", "!==", "tag", ";", "}", ")", "}", ";", "return", "this", ".", "setQueryParameters", "(", "modification", ")", ";", "}"], "docstring": "Remove a tag from the list of tag refinements\n@method\n@param {string} tag the tag to remove\n@return {SearchParameters}", "docstring_tokens": ["Remove", "a", "tag", "from", "the", "list", "of", "tag", "refinements"], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L1164-L1172", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/plugman/fetch.js", "func_name": "checkID", "original_string": "function checkID (expectedIdAndVersion, pinfo) {\n    if (!expectedIdAndVersion) return;\n\n    var parsedSpec = pluginSpec.parse(expectedIdAndVersion);\n\n    if (parsedSpec.id !== pinfo.id) {\n        throw new Error('Expected plugin to have ID \"' + parsedSpec.id + '\" but got \"' + pinfo.id + '\".');\n    }\n\n    if (parsedSpec.version && !semver.satisfies(pinfo.version, parsedSpec.version)) {\n        throw new Error('Expected plugin ' + pinfo.id + ' to satisfy version \"' + parsedSpec.version + '\" but got \"' + pinfo.version + '\".');\n    }\n}", "language": "javascript", "code": "function checkID (expectedIdAndVersion, pinfo) {\n    if (!expectedIdAndVersion) return;\n\n    var parsedSpec = pluginSpec.parse(expectedIdAndVersion);\n\n    if (parsedSpec.id !== pinfo.id) {\n        throw new Error('Expected plugin to have ID \"' + parsedSpec.id + '\" but got \"' + pinfo.id + '\".');\n    }\n\n    if (parsedSpec.version && !semver.satisfies(pinfo.version, parsedSpec.version)) {\n        throw new Error('Expected plugin ' + pinfo.id + ' to satisfy version \"' + parsedSpec.version + '\" but got \"' + pinfo.version + '\".');\n    }\n}", "code_tokens": ["function", "checkID", "(", "expectedIdAndVersion", ",", "pinfo", ")", "{", "if", "(", "!", "expectedIdAndVersion", ")", "return", ";", "var", "parsedSpec", "=", "pluginSpec", ".", "parse", "(", "expectedIdAndVersion", ")", ";", "if", "(", "parsedSpec", ".", "id", "!==", "pinfo", ".", "id", ")", "{", "throw", "new", "Error", "(", "'Expected plugin to have ID \"'", "+", "parsedSpec", ".", "id", "+", "'\" but got \"'", "+", "pinfo", ".", "id", "+", "'\".'", ")", ";", "}", "if", "(", "parsedSpec", ".", "version", "&&", "!", "semver", ".", "satisfies", "(", "pinfo", ".", "version", ",", "parsedSpec", ".", "version", ")", ")", "{", "throw", "new", "Error", "(", "'Expected plugin '", "+", "pinfo", ".", "id", "+", "' to satisfy version \"'", "+", "parsedSpec", ".", "version", "+", "'\" but got \"'", "+", "pinfo", ".", "version", "+", "'\".'", ")", ";", "}", "}"], "docstring": "Helper function for checking expected plugin IDs against reality.", "docstring_tokens": ["Helper", "function", "for", "checking", "expected", "plugin", "IDs", "against", "reality", "."], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/plugman/fetch.js#L182-L194", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/directory.js", "func_name": "move", "original_string": "function move(repoState, dirName, newDirName) {\n    // List entries to move\n    const filesToMove = readFilenamesRecursive(repoState, dirName);\n\n    // Push change to remove all entries\n    return filesToMove.reduce((repoState, oldPath) => {\n        const newPath = Path.join(\n            newDirName,\n            Path.relative(dirName, oldPath)\n        );\n\n        return FileUtils.move(repoState, oldPath, newPath);\n    }, repoState);\n}", "language": "javascript", "code": "function move(repoState, dirName, newDirName) {\n    // List entries to move\n    const filesToMove = readFilenamesRecursive(repoState, dirName);\n\n    // Push change to remove all entries\n    return filesToMove.reduce((repoState, oldPath) => {\n        const newPath = Path.join(\n            newDirName,\n            Path.relative(dirName, oldPath)\n        );\n\n        return FileUtils.move(repoState, oldPath, newPath);\n    }, repoState);\n}", "code_tokens": ["function", "move", "(", "repoState", ",", "dirName", ",", "newDirName", ")", "{", "// List entries to move", "const", "filesToMove", "=", "readFilenamesRecursive", "(", "repoState", ",", "dirName", ")", ";", "// Push change to remove all entries", "return", "filesToMove", ".", "reduce", "(", "(", "repoState", ",", "oldPath", ")", "=>", "{", "const", "newPath", "=", "Path", ".", "join", "(", "newDirName", ",", "Path", ".", "relative", "(", "dirName", ",", "oldPath", ")", ")", ";", "return", "FileUtils", ".", "move", "(", "repoState", ",", "oldPath", ",", "newPath", ")", ";", "}", ",", "repoState", ")", ";", "}"], "docstring": "Rename a directory", "docstring_tokens": ["Rename", "a", "directory"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/directory.js#L112-L125", "partition": "test"}
{"repo": "bholloway/browserify-nginject", "path": "lib/infer-angular.js", "func_name": "followReference", "original_string": "function followReference(node) {\n  var result;\n\n  // immediate function\n  if (testNode.isFunction(node)) {\n    return node;\n  }\n  // follow identifier\n  else {\n    var name = node.name;\n\n    // find the next highest scope and search for declaration\n    while (node.parent && !result) {\n      node = node.parent;\n      var isBlock = testNode.isBlockOrProgram(node);\n      if (isBlock) {\n\n        // look at the nodes breadth first and take the first result\n        esprimaTools.breadthFirst(node)\n          .some(function eachNode(subNode) {\n            switch (subNode.type) {\n              case 'FunctionDeclaration':\n                if (subNode.id.name === name) {\n                  result = subNode;\n                }\n                break;\n              case 'VariableDeclarator':\n                if (subNode.id.name === name) {\n                  result = subNode.init;\n                }\n                break;\n              case 'AssignmentExpression':\n                if ((subNode.left.type === 'Identifier') && (subNode.left.name === name)) {\n                  result = subNode.right;\n                }\n                break;\n            }\n            return !!result;\n          });\n      }\n    }\n\n    // recurse the result until we find a function\n    return result ? followReference(result) : null;\n  }\n\n\n}", "language": "javascript", "code": "function followReference(node) {\n  var result;\n\n  // immediate function\n  if (testNode.isFunction(node)) {\n    return node;\n  }\n  // follow identifier\n  else {\n    var name = node.name;\n\n    // find the next highest scope and search for declaration\n    while (node.parent && !result) {\n      node = node.parent;\n      var isBlock = testNode.isBlockOrProgram(node);\n      if (isBlock) {\n\n        // look at the nodes breadth first and take the first result\n        esprimaTools.breadthFirst(node)\n          .some(function eachNode(subNode) {\n            switch (subNode.type) {\n              case 'FunctionDeclaration':\n                if (subNode.id.name === name) {\n                  result = subNode;\n                }\n                break;\n              case 'VariableDeclarator':\n                if (subNode.id.name === name) {\n                  result = subNode.init;\n                }\n                break;\n              case 'AssignmentExpression':\n                if ((subNode.left.type === 'Identifier') && (subNode.left.name === name)) {\n                  result = subNode.right;\n                }\n                break;\n            }\n            return !!result;\n          });\n      }\n    }\n\n    // recurse the result until we find a function\n    return result ? followReference(result) : null;\n  }\n\n\n}", "code_tokens": ["function", "followReference", "(", "node", ")", "{", "var", "result", ";", "// immediate function", "if", "(", "testNode", ".", "isFunction", "(", "node", ")", ")", "{", "return", "node", ";", "}", "// follow identifier", "else", "{", "var", "name", "=", "node", ".", "name", ";", "// find the next highest scope and search for declaration", "while", "(", "node", ".", "parent", "&&", "!", "result", ")", "{", "node", "=", "node", ".", "parent", ";", "var", "isBlock", "=", "testNode", ".", "isBlockOrProgram", "(", "node", ")", ";", "if", "(", "isBlock", ")", "{", "// look at the nodes breadth first and take the first result", "esprimaTools", ".", "breadthFirst", "(", "node", ")", ".", "some", "(", "function", "eachNode", "(", "subNode", ")", "{", "switch", "(", "subNode", ".", "type", ")", "{", "case", "'FunctionDeclaration'", ":", "if", "(", "subNode", ".", "id", ".", "name", "===", "name", ")", "{", "result", "=", "subNode", ";", "}", "break", ";", "case", "'VariableDeclarator'", ":", "if", "(", "subNode", ".", "id", ".", "name", "===", "name", ")", "{", "result", "=", "subNode", ".", "init", ";", "}", "break", ";", "case", "'AssignmentExpression'", ":", "if", "(", "(", "subNode", ".", "left", ".", "type", "===", "'Identifier'", ")", "&&", "(", "subNode", ".", "left", ".", "name", "===", "name", ")", ")", "{", "result", "=", "subNode", ".", "right", ";", "}", "break", ";", "}", "return", "!", "!", "result", ";", "}", ")", ";", "}", "}", "// recurse the result until we find a function", "return", "result", "?", "followReference", "(", "result", ")", ":", "null", ";", "}", "}"], "docstring": "Given a function or reference that points to one will resolve to the function node.\n@param {object} node An esprima AST node of type function or identifier\n@returns {object|null} The AST node for the function that was resolved, or null if unresolved", "docstring_tokens": ["Given", "a", "function", "or", "reference", "that", "points", "to", "one", "will", "resolve", "to", "the", "function", "node", "."], "sha": "42cff52081b66d77e4e7fac923d4d824de13cfd3", "url": "https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/infer-angular.js#L42-L89", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getContextualTypeForInitializerExpression", "original_string": "function getContextualTypeForInitializerExpression(node) {\n            var declaration = node.parent;\n            if (node === declaration.initializer) {\n                if (declaration.type) {\n                    return getTypeFromTypeNode(declaration.type);\n                }\n                if (declaration.kind === 138 /* Parameter */) {\n                    var type = getContextuallyTypedParameterType(declaration);\n                    if (type) {\n                        return type;\n                    }\n                }\n                if (ts.isBindingPattern(declaration.name)) {\n                    return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ true);\n                }\n            }\n            return undefined;\n        }", "language": "javascript", "code": "function getContextualTypeForInitializerExpression(node) {\n            var declaration = node.parent;\n            if (node === declaration.initializer) {\n                if (declaration.type) {\n                    return getTypeFromTypeNode(declaration.type);\n                }\n                if (declaration.kind === 138 /* Parameter */) {\n                    var type = getContextuallyTypedParameterType(declaration);\n                    if (type) {\n                        return type;\n                    }\n                }\n                if (ts.isBindingPattern(declaration.name)) {\n                    return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ true);\n                }\n            }\n            return undefined;\n        }", "code_tokens": ["function", "getContextualTypeForInitializerExpression", "(", "node", ")", "{", "var", "declaration", "=", "node", ".", "parent", ";", "if", "(", "node", "===", "declaration", ".", "initializer", ")", "{", "if", "(", "declaration", ".", "type", ")", "{", "return", "getTypeFromTypeNode", "(", "declaration", ".", "type", ")", ";", "}", "if", "(", "declaration", ".", "kind", "===", "138", "/* Parameter */", ")", "{", "var", "type", "=", "getContextuallyTypedParameterType", "(", "declaration", ")", ";", "if", "(", "type", ")", "{", "return", "type", ";", "}", "}", "if", "(", "ts", ".", "isBindingPattern", "(", "declaration", ".", "name", ")", ")", "{", "return", "getTypeFromBindingPattern", "(", "declaration", ".", "name", ",", "/*includePatternInType*/", "true", ")", ";", "}", "}", "return", "undefined", ";", "}"], "docstring": "In a variable, parameter or property declaration with a type annotation, the contextual type of an initializer expression is the type of the variable, parameter or property. Otherwise, in a parameter declaration of a contextually typed function expression, the contextual type of an initializer expression is the contextual type of the parameter. Otherwise, in a variable or parameter declaration with a binding pattern name, the contextual type of an initializer expression is the type implied by the binding pattern.", "docstring_tokens": ["In", "a", "variable", "parameter", "or", "property", "declaration", "with", "a", "type", "annotation", "the", "contextual", "type", "of", "an", "initializer", "expression", "is", "the", "type", "of", "the", "variable", "parameter", "or", "property", ".", "Otherwise", "in", "a", "parameter", "declaration", "of", "a", "contextually", "typed", "function", "expression", "the", "contextual", "type", "of", "an", "initializer", "expression", "is", "the", "contextual", "type", "of", "the", "parameter", ".", "Otherwise", "in", "a", "variable", "or", "parameter", "declaration", "with", "a", "binding", "pattern", "name", "the", "contextual", "type", "of", "an", "initializer", "expression", "is", "the", "type", "implied", "by", "the", "binding", "pattern", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L19516-L19533", "partition": "test"}
{"repo": "chrisbateman/impetus", "path": "dist/impetus.js", "func_name": "normalizeEvent", "original_string": "function normalizeEvent(ev) {\n            if (ev.type === 'touchmove' || ev.type === 'touchstart' || ev.type === 'touchend') {\n                var touch = ev.targetTouches[0] || ev.changedTouches[0];\n                return {\n                    x: touch.clientX,\n                    y: touch.clientY,\n                    id: touch.identifier\n                };\n            } else {\n                // mouse events\n                return {\n                    x: ev.clientX,\n                    y: ev.clientY,\n                    id: null\n                };\n            }\n        }", "language": "javascript", "code": "function normalizeEvent(ev) {\n            if (ev.type === 'touchmove' || ev.type === 'touchstart' || ev.type === 'touchend') {\n                var touch = ev.targetTouches[0] || ev.changedTouches[0];\n                return {\n                    x: touch.clientX,\n                    y: touch.clientY,\n                    id: touch.identifier\n                };\n            } else {\n                // mouse events\n                return {\n                    x: ev.clientX,\n                    y: ev.clientY,\n                    id: null\n                };\n            }\n        }", "code_tokens": ["function", "normalizeEvent", "(", "ev", ")", "{", "if", "(", "ev", ".", "type", "===", "'touchmove'", "||", "ev", ".", "type", "===", "'touchstart'", "||", "ev", ".", "type", "===", "'touchend'", ")", "{", "var", "touch", "=", "ev", ".", "targetTouches", "[", "0", "]", "||", "ev", ".", "changedTouches", "[", "0", "]", ";", "return", "{", "x", ":", "touch", ".", "clientX", ",", "y", ":", "touch", ".", "clientY", ",", "id", ":", "touch", ".", "identifier", "}", ";", "}", "else", "{", "// mouse events", "return", "{", "x", ":", "ev", ".", "clientX", ",", "y", ":", "ev", ".", "clientY", ",", "id", ":", "null", "}", ";", "}", "}"], "docstring": "Creates a custom normalized event object from touch and mouse events\n@param  {Event} ev\n@returns {Object} with x, y, and id properties", "docstring_tokens": ["Creates", "a", "custom", "normalized", "event", "object", "from", "touch", "and", "mouse", "events"], "sha": "ef9fefec150655c06e2aec9e628422909fd5f4ce", "url": "https://github.com/chrisbateman/impetus/blob/ef9fefec150655c06e2aec9e628422909fd5f4ce/dist/impetus.js#L209-L225", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/collections/Breadcrumb/Breadcrumb.js", "func_name": "Breadcrumb", "original_string": "function Breadcrumb(props) {\n  const { children, className, divider, icon, sections, size } = props\n\n  const classes = cx('ui', size, 'breadcrumb', className)\n  const rest = getUnhandledProps(Breadcrumb, props)\n  const ElementType = getElementType(Breadcrumb, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const childElements = []\n\n  _.each(sections, (section, index) => {\n    // section\n    const breadcrumbElement = BreadcrumbSection.create(section)\n    childElements.push(breadcrumbElement)\n\n    // divider\n    if (index !== sections.length - 1) {\n      const key = `${breadcrumbElement.key}_divider` || JSON.stringify(section)\n      childElements.push(BreadcrumbDivider.create({ content: divider, icon, key }))\n    }\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childElements}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function Breadcrumb(props) {\n  const { children, className, divider, icon, sections, size } = props\n\n  const classes = cx('ui', size, 'breadcrumb', className)\n  const rest = getUnhandledProps(Breadcrumb, props)\n  const ElementType = getElementType(Breadcrumb, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  const childElements = []\n\n  _.each(sections, (section, index) => {\n    // section\n    const breadcrumbElement = BreadcrumbSection.create(section)\n    childElements.push(breadcrumbElement)\n\n    // divider\n    if (index !== sections.length - 1) {\n      const key = `${breadcrumbElement.key}_divider` || JSON.stringify(section)\n      childElements.push(BreadcrumbDivider.create({ content: divider, icon, key }))\n    }\n  })\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childElements}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "Breadcrumb", "(", "props", ")", "{", "const", "{", "children", ",", "className", ",", "divider", ",", "icon", ",", "sections", ",", "size", "}", "=", "props", "const", "classes", "=", "cx", "(", "'ui'", ",", "size", ",", "'breadcrumb'", ",", "className", ")", "const", "rest", "=", "getUnhandledProps", "(", "Breadcrumb", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "Breadcrumb", ",", "props", ")", "if", "(", "!", "childrenUtils", ".", "isNil", "(", "children", ")", ")", "{", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n        ", "{", "children", "}", "\n      ", "<", "/", "ElementType", ">", ")", "}", "const", "childElements", "=", "[", "]", "_", ".", "each", "(", "sections", ",", "(", "section", ",", "index", ")", "=>", "{", "// section", "const", "breadcrumbElement", "=", "BreadcrumbSection", ".", "create", "(", "section", ")", "childElements", ".", "push", "(", "breadcrumbElement", ")", "// divider", "if", "(", "index", "!==", "sections", ".", "length", "-", "1", ")", "{", "const", "key", "=", "`", "${", "breadcrumbElement", ".", "key", "}", "`", "||", "JSON", ".", "stringify", "(", "section", ")", "childElements", ".", "push", "(", "BreadcrumbDivider", ".", "create", "(", "{", "content", ":", "divider", ",", "icon", ",", "key", "}", ")", ")", "}", "}", ")", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "childElements", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A breadcrumb is used to show hierarchy between content.", "docstring_tokens": ["A", "breadcrumb", "is", "used", "to", "show", "hierarchy", "between", "content", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Breadcrumb/Breadcrumb.js#L13-L47", "partition": "test"}
{"repo": "frapontillo/angular-bootstrap-switch", "path": "dist/angular-bootstrap-switch.js", "func_name": "", "original_string": "function () {\n\n          attrs.$observe('switchActive', function (newValue) {\n\n            var active = getBooleanFromStringDefTrue(newValue);\n            // if we are disabling the switch, delay the deactivation so that the toggle can be switched\n            if (!active) {\n              $timeout(setActive);\n            } else {\n              // if we are enabling the switch, set active right away\n              setActive();\n            }\n          });\n\n          // When the model changes\n          controller.$render = function () {\n            initMaybe();\n            var newValue = controller.$modelValue;\n            if (newValue !== undefined && newValue !== null) {\n              element.bootstrapSwitch('state', newValue === getTrueValue(), true);\n            } else {\n              element.bootstrapSwitch('indeterminate', true, true);\n              controller.$setViewValue(undefined);\n            }\n            switchChange();\n          };\n\n          // angular attribute to switch property bindings\n          var bindings = {\n            'switchRadioOff': 'radioAllOff',\n            'switchOnText': 'onText',\n            'switchOffText': 'offText',\n            'switchOnColor': 'onColor',\n            'switchOffColor': 'offColor',\n            'switchAnimate': 'animate',\n            'switchSize': 'size',\n            'switchLabel': 'labelText',\n            'switchIcon': 'labelText',\n            'switchWrapper': 'wrapperClass',\n            'switchHandleWidth': 'handleWidth',\n            'switchLabelWidth': 'labelWidth',\n            'switchInverse': 'inverse',\n            'switchReadonly': 'readonly'\n          };\n\n          var observeProp = function(prop, bindings) {\n            return function() {\n              attrs.$observe(prop, function () {\n                setSwitchParamMaybe(element, bindings[prop], prop);\n              });\n            };\n          };\n\n          // for every angular-bound attribute, observe it and trigger the appropriate switch function\n          for (var prop in bindings) {\n            attrs.$observe(prop, observeProp(prop, bindings));\n          }\n        }", "language": "javascript", "code": "function () {\n\n          attrs.$observe('switchActive', function (newValue) {\n\n            var active = getBooleanFromStringDefTrue(newValue);\n            // if we are disabling the switch, delay the deactivation so that the toggle can be switched\n            if (!active) {\n              $timeout(setActive);\n            } else {\n              // if we are enabling the switch, set active right away\n              setActive();\n            }\n          });\n\n          // When the model changes\n          controller.$render = function () {\n            initMaybe();\n            var newValue = controller.$modelValue;\n            if (newValue !== undefined && newValue !== null) {\n              element.bootstrapSwitch('state', newValue === getTrueValue(), true);\n            } else {\n              element.bootstrapSwitch('indeterminate', true, true);\n              controller.$setViewValue(undefined);\n            }\n            switchChange();\n          };\n\n          // angular attribute to switch property bindings\n          var bindings = {\n            'switchRadioOff': 'radioAllOff',\n            'switchOnText': 'onText',\n            'switchOffText': 'offText',\n            'switchOnColor': 'onColor',\n            'switchOffColor': 'offColor',\n            'switchAnimate': 'animate',\n            'switchSize': 'size',\n            'switchLabel': 'labelText',\n            'switchIcon': 'labelText',\n            'switchWrapper': 'wrapperClass',\n            'switchHandleWidth': 'handleWidth',\n            'switchLabelWidth': 'labelWidth',\n            'switchInverse': 'inverse',\n            'switchReadonly': 'readonly'\n          };\n\n          var observeProp = function(prop, bindings) {\n            return function() {\n              attrs.$observe(prop, function () {\n                setSwitchParamMaybe(element, bindings[prop], prop);\n              });\n            };\n          };\n\n          // for every angular-bound attribute, observe it and trigger the appropriate switch function\n          for (var prop in bindings) {\n            attrs.$observe(prop, observeProp(prop, bindings));\n          }\n        }", "code_tokens": ["function", "(", ")", "{", "attrs", ".", "$observe", "(", "'switchActive'", ",", "function", "(", "newValue", ")", "{", "var", "active", "=", "getBooleanFromStringDefTrue", "(", "newValue", ")", ";", "// if we are disabling the switch, delay the deactivation so that the toggle can be switched", "if", "(", "!", "active", ")", "{", "$timeout", "(", "setActive", ")", ";", "}", "else", "{", "// if we are enabling the switch, set active right away", "setActive", "(", ")", ";", "}", "}", ")", ";", "// When the model changes", "controller", ".", "$render", "=", "function", "(", ")", "{", "initMaybe", "(", ")", ";", "var", "newValue", "=", "controller", ".", "$modelValue", ";", "if", "(", "newValue", "!==", "undefined", "&&", "newValue", "!==", "null", ")", "{", "element", ".", "bootstrapSwitch", "(", "'state'", ",", "newValue", "===", "getTrueValue", "(", ")", ",", "true", ")", ";", "}", "else", "{", "element", ".", "bootstrapSwitch", "(", "'indeterminate'", ",", "true", ",", "true", ")", ";", "controller", ".", "$setViewValue", "(", "undefined", ")", ";", "}", "switchChange", "(", ")", ";", "}", ";", "// angular attribute to switch property bindings", "var", "bindings", "=", "{", "'switchRadioOff'", ":", "'radioAllOff'", ",", "'switchOnText'", ":", "'onText'", ",", "'switchOffText'", ":", "'offText'", ",", "'switchOnColor'", ":", "'onColor'", ",", "'switchOffColor'", ":", "'offColor'", ",", "'switchAnimate'", ":", "'animate'", ",", "'switchSize'", ":", "'size'", ",", "'switchLabel'", ":", "'labelText'", ",", "'switchIcon'", ":", "'labelText'", ",", "'switchWrapper'", ":", "'wrapperClass'", ",", "'switchHandleWidth'", ":", "'handleWidth'", ",", "'switchLabelWidth'", ":", "'labelWidth'", ",", "'switchInverse'", ":", "'inverse'", ",", "'switchReadonly'", ":", "'readonly'", "}", ";", "var", "observeProp", "=", "function", "(", "prop", ",", "bindings", ")", "{", "return", "function", "(", ")", "{", "attrs", ".", "$observe", "(", "prop", ",", "function", "(", ")", "{", "setSwitchParamMaybe", "(", "element", ",", "bindings", "[", "prop", "]", ",", "prop", ")", ";", "}", ")", ";", "}", ";", "}", ";", "// for every angular-bound attribute, observe it and trigger the appropriate switch function", "for", "(", "var", "prop", "in", "bindings", ")", "{", "attrs", ".", "$observe", "(", "prop", ",", "observeProp", "(", "prop", ",", "bindings", ")", ")", ";", "}", "}"], "docstring": "Listen to model changes.", "docstring_tokens": ["Listen", "to", "model", "changes", "."], "sha": "e9616e34524ae48dbab730d553438b6657948692", "url": "https://github.com/frapontillo/angular-bootstrap-switch/blob/e9616e34524ae48dbab730d553438b6657948692/dist/angular-bootstrap-switch.js#L175-L232", "partition": "test"}
{"repo": "vanruesc/postprocessing", "path": "build/postprocessing.esm.js", "func_name": "smoothArea", "original_string": "function smoothArea(d, b) {\n\n\tconst a1 = b.min;\n\tconst a2 = b.max;\n\n\tconst b1X = Math.sqrt(a1.x * 2.0) * 0.5;\n\tconst b1Y = Math.sqrt(a1.y * 2.0) * 0.5;\n\tconst b2X = Math.sqrt(a2.x * 2.0) * 0.5;\n\tconst b2Y = Math.sqrt(a2.y * 2.0) * 0.5;\n\n\tconst p = saturate(d / SMOOTH_MAX_DISTANCE);\n\n\ta1.set(lerp(b1X, a1.x, p), lerp(b1Y, a1.y, p));\n\ta2.set(lerp(b2X, a2.x, p), lerp(b2Y, a2.y, p));\n\n\treturn b;\n\n}", "language": "javascript", "code": "function smoothArea(d, b) {\n\n\tconst a1 = b.min;\n\tconst a2 = b.max;\n\n\tconst b1X = Math.sqrt(a1.x * 2.0) * 0.5;\n\tconst b1Y = Math.sqrt(a1.y * 2.0) * 0.5;\n\tconst b2X = Math.sqrt(a2.x * 2.0) * 0.5;\n\tconst b2Y = Math.sqrt(a2.y * 2.0) * 0.5;\n\n\tconst p = saturate(d / SMOOTH_MAX_DISTANCE);\n\n\ta1.set(lerp(b1X, a1.x, p), lerp(b1Y, a1.y, p));\n\ta2.set(lerp(b2X, a2.x, p), lerp(b2Y, a2.y, p));\n\n\treturn b;\n\n}", "code_tokens": ["function", "smoothArea", "(", "d", ",", "b", ")", "{", "const", "a1", "=", "b", ".", "min", ";", "const", "a2", "=", "b", ".", "max", ";", "const", "b1X", "=", "Math", ".", "sqrt", "(", "a1", ".", "x", "*", "2.0", ")", "*", "0.5", ";", "const", "b1Y", "=", "Math", ".", "sqrt", "(", "a1", ".", "y", "*", "2.0", ")", "*", "0.5", ";", "const", "b2X", "=", "Math", ".", "sqrt", "(", "a2", ".", "x", "*", "2.0", ")", "*", "0.5", ";", "const", "b2Y", "=", "Math", ".", "sqrt", "(", "a2", ".", "y", "*", "2.0", ")", "*", "0.5", ";", "const", "p", "=", "saturate", "(", "d", "/", "SMOOTH_MAX_DISTANCE", ")", ";", "a1", ".", "set", "(", "lerp", "(", "b1X", ",", "a1", ".", "x", ",", "p", ")", ",", "lerp", "(", "b1Y", ",", "a1", ".", "y", ",", "p", ")", ")", ";", "a2", ".", "set", "(", "lerp", "(", "b2X", ",", "a2", ".", "x", ",", "p", ")", ",", "lerp", "(", "b2Y", ",", "a2", ".", "y", ",", "p", ")", ")", ";", "return", "b", ";", "}"], "docstring": "A smoothing function for small U-patterns.\n\n@private\n@param {Number} d - A smoothing factor.\n@param {Box2} b - The area that should be smoothed.\n@return {Box2} The smoothed area.", "docstring_tokens": ["A", "smoothing", "function", "for", "small", "U", "-", "patterns", "."], "sha": "43a6776c2a391ddd3539262e078b0f35b5563004", "url": "https://github.com/vanruesc/postprocessing/blob/43a6776c2a391ddd3539262e078b0f35b5563004/build/postprocessing.esm.js#L8225-L8242", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "onDocumentMouseDown", "original_string": "function onDocumentMouseDown(event) {\n    // Override default action\n    event.preventDefault();\n    // But not all of it\n    container.focus();\n    \n    // Only do something if the panorama is loaded\n    if (!loaded || !config.draggable) {\n        return;\n    }\n    \n    // Calculate mouse position relative to top left of viewer container\n    var pos = mousePosition(event);\n\n    // Log pitch / yaw of mouse click when debugging / placing hot spots\n    if (config.hotSpotDebug) {\n        var coords = mouseEventToCoords(event);\n        console.log('Pitch: ' + coords[0] + ', Yaw: ' + coords[1] + ', Center Pitch: ' +\n            config.pitch + ', Center Yaw: ' + config.yaw + ', HFOV: ' + config.hfov);\n    }\n    \n    // Turn off auto-rotation if enabled\n    stopAnimation();\n\n    stopOrientation();\n    config.roll = 0;\n\n    speed.hfov = 0;\n\n    isUserInteracting = true;\n    latestInteraction = Date.now();\n    \n    onPointerDownPointerX = pos.x;\n    onPointerDownPointerY = pos.y;\n    \n    onPointerDownYaw = config.yaw;\n    onPointerDownPitch = config.pitch;\n    \n    uiContainer.classList.add('pnlm-grabbing');\n    uiContainer.classList.remove('pnlm-grab');\n    \n    fireEvent('mousedown', event);\n    animateInit();\n}", "language": "javascript", "code": "function onDocumentMouseDown(event) {\n    // Override default action\n    event.preventDefault();\n    // But not all of it\n    container.focus();\n    \n    // Only do something if the panorama is loaded\n    if (!loaded || !config.draggable) {\n        return;\n    }\n    \n    // Calculate mouse position relative to top left of viewer container\n    var pos = mousePosition(event);\n\n    // Log pitch / yaw of mouse click when debugging / placing hot spots\n    if (config.hotSpotDebug) {\n        var coords = mouseEventToCoords(event);\n        console.log('Pitch: ' + coords[0] + ', Yaw: ' + coords[1] + ', Center Pitch: ' +\n            config.pitch + ', Center Yaw: ' + config.yaw + ', HFOV: ' + config.hfov);\n    }\n    \n    // Turn off auto-rotation if enabled\n    stopAnimation();\n\n    stopOrientation();\n    config.roll = 0;\n\n    speed.hfov = 0;\n\n    isUserInteracting = true;\n    latestInteraction = Date.now();\n    \n    onPointerDownPointerX = pos.x;\n    onPointerDownPointerY = pos.y;\n    \n    onPointerDownYaw = config.yaw;\n    onPointerDownPitch = config.pitch;\n    \n    uiContainer.classList.add('pnlm-grabbing');\n    uiContainer.classList.remove('pnlm-grab');\n    \n    fireEvent('mousedown', event);\n    animateInit();\n}", "code_tokens": ["function", "onDocumentMouseDown", "(", "event", ")", "{", "// Override default action", "event", ".", "preventDefault", "(", ")", ";", "// But not all of it", "container", ".", "focus", "(", ")", ";", "// Only do something if the panorama is loaded", "if", "(", "!", "loaded", "||", "!", "config", ".", "draggable", ")", "{", "return", ";", "}", "// Calculate mouse position relative to top left of viewer container", "var", "pos", "=", "mousePosition", "(", "event", ")", ";", "// Log pitch / yaw of mouse click when debugging / placing hot spots", "if", "(", "config", ".", "hotSpotDebug", ")", "{", "var", "coords", "=", "mouseEventToCoords", "(", "event", ")", ";", "console", ".", "log", "(", "'Pitch: '", "+", "coords", "[", "0", "]", "+", "', Yaw: '", "+", "coords", "[", "1", "]", "+", "', Center Pitch: '", "+", "config", ".", "pitch", "+", "', Center Yaw: '", "+", "config", ".", "yaw", "+", "', HFOV: '", "+", "config", ".", "hfov", ")", ";", "}", "// Turn off auto-rotation if enabled", "stopAnimation", "(", ")", ";", "stopOrientation", "(", ")", ";", "config", ".", "roll", "=", "0", ";", "speed", ".", "hfov", "=", "0", ";", "isUserInteracting", "=", "true", ";", "latestInteraction", "=", "Date", ".", "now", "(", ")", ";", "onPointerDownPointerX", "=", "pos", ".", "x", ";", "onPointerDownPointerY", "=", "pos", ".", "y", ";", "onPointerDownYaw", "=", "config", ".", "yaw", ";", "onPointerDownPitch", "=", "config", ".", "pitch", ";", "uiContainer", ".", "classList", ".", "add", "(", "'pnlm-grabbing'", ")", ";", "uiContainer", ".", "classList", ".", "remove", "(", "'pnlm-grab'", ")", ";", "fireEvent", "(", "'mousedown'", ",", "event", ")", ";", "animateInit", "(", ")", ";", "}"], "docstring": "Event handler for mouse clicks. Initializes panning. Prints center and click\nlocation coordinates when hot spot debugging is enabled.\n@private\n@param {MouseEvent} event - Document mouse down event.", "docstring_tokens": ["Event", "handler", "for", "mouse", "clicks", ".", "Initializes", "panning", ".", "Prints", "center", "and", "click", "location", "coordinates", "when", "hot", "spot", "debugging", "is", "enabled", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L676-L719", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(array, idx, amt, objects) {\n    if (array.replace) {\n      return array.replace(idx, amt, objects);\n    } else {\n      return utils._replace(array, idx, amt, objects);\n    }\n  }", "language": "javascript", "code": "function(array, idx, amt, objects) {\n    if (array.replace) {\n      return array.replace(idx, amt, objects);\n    } else {\n      return utils._replace(array, idx, amt, objects);\n    }\n  }", "code_tokens": ["function", "(", "array", ",", "idx", ",", "amt", ",", "objects", ")", "{", "if", "(", "array", ".", "replace", ")", "{", "return", "array", ".", "replace", "(", "idx", ",", "amt", ",", "objects", ")", ";", "}", "else", "{", "return", "utils", ".", "_replace", "(", "array", ",", "idx", ",", "amt", ",", "objects", ")", ";", "}", "}"], "docstring": "Replaces objects in an array with the passed objects.\n\n```javascript\nvar array = [1,2,3];\nEmber.EnumerableUtils.replace(array, 1, 2, [4, 5]); // [1, 4, 5]\n\nvar array = [1,2,3];\nEmber.EnumerableUtils.replace(array, 1, 1, [4, 5]); // [1, 4, 5, 3]\n\nvar array = [1,2,3];\nEmber.EnumerableUtils.replace(array, 10, 1, [4, 5]); // [1, 2, 3, 4, 5]\n```\n\n@method replace\n@param {Array} array The array the objects should be inserted into.\n@param {Number} idx Starting index in the array to replace. If *idx* >=\nlength, then append to the end of the array.\n@param {Number} amt Number of elements that should be removed from the array,\nstarting at *idx*\n@param {Array} objects An array of zero or more objects that should be\ninserted into the array at *idx*\n\n@return {Array} The modified array.", "docstring_tokens": ["Replaces", "objects", "in", "an", "array", "with", "the", "passed", "objects", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L2064-L2070", "partition": "test"}
{"repo": "yortus/asyncawait", "path": "src/async/makeAsyncFunc.js", "func_name": "makeAsyncFunc", "original_string": "function makeAsyncFunc(config) {\n    // Validate the specified configuration\n    config.validate();\n    // Create an async function tailored to the given options.\n    var result = function async(bodyFunc) {\n        // Create a semaphore for limiting top-level concurrency, if specified in options.\n        var semaphore = config.maxConcurrency ? new Semaphore(config.maxConcurrency) : Semaphore.unlimited;\n        // Choose and run the appropriate function factory based on whether the result should be iterable.\n        var makeFunc = config.isIterable ? makeAsyncIterator : makeAsyncNonIterator;\n        var result = makeFunc(bodyFunc, config, semaphore);\n        // Ensure the suspendable function's arity matches that of the function it wraps.\n        var arity = bodyFunc.length;\n        if (config.acceptsCallback)\n            ++arity;\n        result = makeFuncWithArity(result, arity);\n        return result;\n    };\n    // Add the mod() function, and return the result.\n    result.mod = makeModFunc(config);\n    return result;\n}", "language": "javascript", "code": "function makeAsyncFunc(config) {\n    // Validate the specified configuration\n    config.validate();\n    // Create an async function tailored to the given options.\n    var result = function async(bodyFunc) {\n        // Create a semaphore for limiting top-level concurrency, if specified in options.\n        var semaphore = config.maxConcurrency ? new Semaphore(config.maxConcurrency) : Semaphore.unlimited;\n        // Choose and run the appropriate function factory based on whether the result should be iterable.\n        var makeFunc = config.isIterable ? makeAsyncIterator : makeAsyncNonIterator;\n        var result = makeFunc(bodyFunc, config, semaphore);\n        // Ensure the suspendable function's arity matches that of the function it wraps.\n        var arity = bodyFunc.length;\n        if (config.acceptsCallback)\n            ++arity;\n        result = makeFuncWithArity(result, arity);\n        return result;\n    };\n    // Add the mod() function, and return the result.\n    result.mod = makeModFunc(config);\n    return result;\n}", "code_tokens": ["function", "makeAsyncFunc", "(", "config", ")", "{", "// Validate the specified configuration", "config", ".", "validate", "(", ")", ";", "// Create an async function tailored to the given options.", "var", "result", "=", "function", "async", "(", "bodyFunc", ")", "{", "// Create a semaphore for limiting top-level concurrency, if specified in options.", "var", "semaphore", "=", "config", ".", "maxConcurrency", "?", "new", "Semaphore", "(", "config", ".", "maxConcurrency", ")", ":", "Semaphore", ".", "unlimited", ";", "// Choose and run the appropriate function factory based on whether the result should be iterable.", "var", "makeFunc", "=", "config", ".", "isIterable", "?", "makeAsyncIterator", ":", "makeAsyncNonIterator", ";", "var", "result", "=", "makeFunc", "(", "bodyFunc", ",", "config", ",", "semaphore", ")", ";", "// Ensure the suspendable function's arity matches that of the function it wraps.", "var", "arity", "=", "bodyFunc", ".", "length", ";", "if", "(", "config", ".", "acceptsCallback", ")", "++", "arity", ";", "result", "=", "makeFuncWithArity", "(", "result", ",", "arity", ")", ";", "return", "result", ";", "}", ";", "// Add the mod() function, and return the result.", "result", ".", "mod", "=", "makeModFunc", "(", "config", ")", ";", "return", "result", ";", "}"], "docstring": "Function for creating a specific variant of the async function.", "docstring_tokens": ["Function", "for", "creating", "a", "specific", "variant", "of", "the", "async", "function", "."], "sha": "7b4f573ecc7e388a1b05fa0c454bbe5d1b0154f2", "url": "https://github.com/yortus/asyncawait/blob/7b4f573ecc7e388a1b05fa0c454bbe5d1b0154f2/src/async/makeAsyncFunc.js#L11-L31", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      var data = {};\n      data = this.serializeData();\n      data = this.mixinTemplateHelpers(data);\n  \n      this.triggerMethod('before:render:template');\n  \n      var template = this.getTemplate();\n      var html = Marionette.Renderer.render(template, data, this);\n      this.attachElContent(html);\n  \n      // the ui bindings is done here and not at the end of render since they\n      // will not be available until after the model is rendered, but should be\n      // available before the collection is rendered.\n      this.bindUIElements();\n      this.triggerMethod('render:template');\n    }", "language": "javascript", "code": "function() {\n      var data = {};\n      data = this.serializeData();\n      data = this.mixinTemplateHelpers(data);\n  \n      this.triggerMethod('before:render:template');\n  \n      var template = this.getTemplate();\n      var html = Marionette.Renderer.render(template, data, this);\n      this.attachElContent(html);\n  \n      // the ui bindings is done here and not at the end of render since they\n      // will not be available until after the model is rendered, but should be\n      // available before the collection is rendered.\n      this.bindUIElements();\n      this.triggerMethod('render:template');\n    }", "code_tokens": ["function", "(", ")", "{", "var", "data", "=", "{", "}", ";", "data", "=", "this", ".", "serializeData", "(", ")", ";", "data", "=", "this", ".", "mixinTemplateHelpers", "(", "data", ")", ";", "this", ".", "triggerMethod", "(", "'before:render:template'", ")", ";", "var", "template", "=", "this", ".", "getTemplate", "(", ")", ";", "var", "html", "=", "Marionette", ".", "Renderer", ".", "render", "(", "template", ",", "data", ",", "this", ")", ";", "this", ".", "attachElContent", "(", "html", ")", ";", "// the ui bindings is done here and not at the end of render since they", "// will not be available until after the model is rendered, but should be", "// available before the collection is rendered.", "this", ".", "bindUIElements", "(", ")", ";", "this", ".", "triggerMethod", "(", "'render:template'", ")", ";", "}"], "docstring": "Render the root template that the children views are appended to", "docstring_tokens": ["Render", "the", "root", "template", "that", "the", "children", "views", "are", "appended", "to"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19038-L19054", "partition": "test"}
{"repo": "zdfs/grunt-datadriver", "path": "tasks/datadriver.js", "func_name": "", "original_string": "function(cb, param) {\n            return function() {\n                var args = Array.prototype.slice.call(arguments, 1);\n\n                if(typeof param !== 'undefined') {\n                    args.unshift(param);\n                } else if (arguments.length === 1) {\n                    args.unshift(arguments[0]);\n                }\n\n                args.unshift(null);\n                cb.apply(null, args);\n            };\n        }", "language": "javascript", "code": "function(cb, param) {\n            return function() {\n                var args = Array.prototype.slice.call(arguments, 1);\n\n                if(typeof param !== 'undefined') {\n                    args.unshift(param);\n                } else if (arguments.length === 1) {\n                    args.unshift(arguments[0]);\n                }\n\n                args.unshift(null);\n                cb.apply(null, args);\n            };\n        }", "code_tokens": ["function", "(", "cb", ",", "param", ")", "{", "return", "function", "(", ")", "{", "var", "args", "=", "Array", ".", "prototype", ".", "slice", ".", "call", "(", "arguments", ",", "1", ")", ";", "if", "(", "typeof", "param", "!==", "'undefined'", ")", "{", "args", ".", "unshift", "(", "param", ")", ";", "}", "else", "if", "(", "arguments", ".", "length", "===", "1", ")", "{", "args", ".", "unshift", "(", "arguments", "[", "0", "]", ")", ";", "}", "args", ".", "unshift", "(", "null", ")", ";", "cb", ".", "apply", "(", "null", ",", "args", ")", ";", "}", ";", "}"], "docstring": "helper function for asyncjs", "docstring_tokens": ["helper", "function", "for", "asyncjs"], "sha": "8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e", "url": "https://github.com/zdfs/grunt-datadriver/blob/8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e/tasks/datadriver.js#L140-L153", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "spec/plugman/projects/android/cordova/lib/prepare.js", "func_name": "findAndroidLaunchModePreference", "original_string": "function findAndroidLaunchModePreference(platformConfig) {\n    var launchMode = platformConfig.getPreference('AndroidLaunchMode');\n    if (!launchMode) {\n        // Return a default value\n        return 'singleTop';\n    }\n\n    var expectedValues = ['standard', 'singleTop', 'singleTask', 'singleInstance'];\n    var valid = expectedValues.indexOf(launchMode) >= 0;\n    if (!valid) {\n        // Note: warn, but leave the launch mode as developer wanted, in case the list of options changes in the future\n        events.emit('warn', 'Unrecognized value for AndroidLaunchMode preference: ' +\n            launchMode + '. Expected values are: ' + expectedValues.join(', '));\n    }\n\n    return launchMode;\n}", "language": "javascript", "code": "function findAndroidLaunchModePreference(platformConfig) {\n    var launchMode = platformConfig.getPreference('AndroidLaunchMode');\n    if (!launchMode) {\n        // Return a default value\n        return 'singleTop';\n    }\n\n    var expectedValues = ['standard', 'singleTop', 'singleTask', 'singleInstance'];\n    var valid = expectedValues.indexOf(launchMode) >= 0;\n    if (!valid) {\n        // Note: warn, but leave the launch mode as developer wanted, in case the list of options changes in the future\n        events.emit('warn', 'Unrecognized value for AndroidLaunchMode preference: ' +\n            launchMode + '. Expected values are: ' + expectedValues.join(', '));\n    }\n\n    return launchMode;\n}", "code_tokens": ["function", "findAndroidLaunchModePreference", "(", "platformConfig", ")", "{", "var", "launchMode", "=", "platformConfig", ".", "getPreference", "(", "'AndroidLaunchMode'", ")", ";", "if", "(", "!", "launchMode", ")", "{", "// Return a default value", "return", "'singleTop'", ";", "}", "var", "expectedValues", "=", "[", "'standard'", ",", "'singleTop'", ",", "'singleTask'", ",", "'singleInstance'", "]", ";", "var", "valid", "=", "expectedValues", ".", "indexOf", "(", "launchMode", ")", ">=", "0", ";", "if", "(", "!", "valid", ")", "{", "// Note: warn, but leave the launch mode as developer wanted, in case the list of options changes in the future", "events", ".", "emit", "(", "'warn'", ",", "'Unrecognized value for AndroidLaunchMode preference: '", "+", "launchMode", "+", "'. Expected values are: '", "+", "expectedValues", ".", "join", "(", "', '", ")", ")", ";", "}", "return", "launchMode", ";", "}"], "docstring": "Gets and validates 'AndroidLaunchMode' prepference from config.xml. Returns\npreference value and warns if it doesn't seems to be valid\n\n@param   {ConfigParser}  platformConfig  A configParser instance for\nplatform.\n\n@return  {String}                  Preference's value from config.xml or\ndefault value, if there is no such preference. The default value is\n'singleTop'", "docstring_tokens": ["Gets", "and", "validates", "AndroidLaunchMode", "prepference", "from", "config", ".", "xml", ".", "Returns", "preference", "value", "and", "warns", "if", "it", "doesn", "t", "seems", "to", "be", "valid"], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/spec/plugman/projects/android/cordova/lib/prepare.js#L455-L471", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "checkDecorator", "original_string": "function checkDecorator(node) {\n            var signature = getResolvedSignature(node);\n            var returnType = getReturnTypeOfSignature(signature);\n            if (returnType.flags & 1 /* Any */) {\n                return;\n            }\n            var expectedReturnType;\n            var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);\n            var errorInfo;\n            switch (node.parent.kind) {\n                case 214 /* ClassDeclaration */:\n                    var classSymbol = getSymbolOfNode(node.parent);\n                    var classConstructorType = getTypeOfSymbol(classSymbol);\n                    expectedReturnType = getUnionType([classConstructorType, voidType]);\n                    break;\n                case 138 /* Parameter */:\n                    expectedReturnType = voidType;\n                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any);\n                    break;\n                case 141 /* PropertyDeclaration */:\n                    expectedReturnType = voidType;\n                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_return_type_of_a_property_decorator_function_must_be_either_void_or_any);\n                    break;\n                case 143 /* MethodDeclaration */:\n                case 145 /* GetAccessor */:\n                case 146 /* SetAccessor */:\n                    var methodType = getTypeOfNode(node.parent);\n                    var descriptorType = createTypedPropertyDescriptorType(methodType);\n                    expectedReturnType = getUnionType([descriptorType, voidType]);\n                    break;\n            }\n            checkTypeAssignableTo(returnType, expectedReturnType, node, headMessage, errorInfo);\n        }", "language": "javascript", "code": "function checkDecorator(node) {\n            var signature = getResolvedSignature(node);\n            var returnType = getReturnTypeOfSignature(signature);\n            if (returnType.flags & 1 /* Any */) {\n                return;\n            }\n            var expectedReturnType;\n            var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);\n            var errorInfo;\n            switch (node.parent.kind) {\n                case 214 /* ClassDeclaration */:\n                    var classSymbol = getSymbolOfNode(node.parent);\n                    var classConstructorType = getTypeOfSymbol(classSymbol);\n                    expectedReturnType = getUnionType([classConstructorType, voidType]);\n                    break;\n                case 138 /* Parameter */:\n                    expectedReturnType = voidType;\n                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any);\n                    break;\n                case 141 /* PropertyDeclaration */:\n                    expectedReturnType = voidType;\n                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_return_type_of_a_property_decorator_function_must_be_either_void_or_any);\n                    break;\n                case 143 /* MethodDeclaration */:\n                case 145 /* GetAccessor */:\n                case 146 /* SetAccessor */:\n                    var methodType = getTypeOfNode(node.parent);\n                    var descriptorType = createTypedPropertyDescriptorType(methodType);\n                    expectedReturnType = getUnionType([descriptorType, voidType]);\n                    break;\n            }\n            checkTypeAssignableTo(returnType, expectedReturnType, node, headMessage, errorInfo);\n        }", "code_tokens": ["function", "checkDecorator", "(", "node", ")", "{", "var", "signature", "=", "getResolvedSignature", "(", "node", ")", ";", "var", "returnType", "=", "getReturnTypeOfSignature", "(", "signature", ")", ";", "if", "(", "returnType", ".", "flags", "&", "1", "/* Any */", ")", "{", "return", ";", "}", "var", "expectedReturnType", ";", "var", "headMessage", "=", "getDiagnosticHeadMessageForDecoratorResolution", "(", "node", ")", ";", "var", "errorInfo", ";", "switch", "(", "node", ".", "parent", ".", "kind", ")", "{", "case", "214", "/* ClassDeclaration */", ":", "var", "classSymbol", "=", "getSymbolOfNode", "(", "node", ".", "parent", ")", ";", "var", "classConstructorType", "=", "getTypeOfSymbol", "(", "classSymbol", ")", ";", "expectedReturnType", "=", "getUnionType", "(", "[", "classConstructorType", ",", "voidType", "]", ")", ";", "break", ";", "case", "138", "/* Parameter */", ":", "expectedReturnType", "=", "voidType", ";", "errorInfo", "=", "ts", ".", "chainDiagnosticMessages", "(", "errorInfo", ",", "ts", ".", "Diagnostics", ".", "The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any", ")", ";", "break", ";", "case", "141", "/* PropertyDeclaration */", ":", "expectedReturnType", "=", "voidType", ";", "errorInfo", "=", "ts", ".", "chainDiagnosticMessages", "(", "errorInfo", ",", "ts", ".", "Diagnostics", ".", "The_return_type_of_a_property_decorator_function_must_be_either_void_or_any", ")", ";", "break", ";", "case", "143", "/* MethodDeclaration */", ":", "case", "145", "/* GetAccessor */", ":", "case", "146", "/* SetAccessor */", ":", "var", "methodType", "=", "getTypeOfNode", "(", "node", ".", "parent", ")", ";", "var", "descriptorType", "=", "createTypedPropertyDescriptorType", "(", "methodType", ")", ";", "expectedReturnType", "=", "getUnionType", "(", "[", "descriptorType", ",", "voidType", "]", ")", ";", "break", ";", "}", "checkTypeAssignableTo", "(", "returnType", ",", "expectedReturnType", ",", "node", ",", "headMessage", ",", "errorInfo", ")", ";", "}"], "docstring": "Check a decorator", "docstring_tokens": ["Check", "a", "decorator"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L23829-L23861", "partition": "test"}
{"repo": "socialally/browser-cookie", "path": "lib/cookie.js", "func_name": "get", "original_string": "function get(key, value) {\n  var i, parts, name, cookie;\n  var result = key ? undefined : {};\n  /* istanbul ignore next */\n  var cookies = (document.cookie || '').split('; ');\n  for (i = 0; i < cookies.length; i++) {\n    parts = cookies[i].split('=');\n    name = this.decode(parts.shift());\n    cookie = parts.join('=');\n    if (key && key === name) {\n      // if second argument (value) is a function it's a converter\n      result = this.read(cookie, value);\n      break;\n    }\n    // prevent storing a cookie that we couldn't decode\n    if (!key && (cookie = this.read(cookie)) !== undefined) {\n      result[name] = cookie;\n    }\n  }\n  return result;\n}", "language": "javascript", "code": "function get(key, value) {\n  var i, parts, name, cookie;\n  var result = key ? undefined : {};\n  /* istanbul ignore next */\n  var cookies = (document.cookie || '').split('; ');\n  for (i = 0; i < cookies.length; i++) {\n    parts = cookies[i].split('=');\n    name = this.decode(parts.shift());\n    cookie = parts.join('=');\n    if (key && key === name) {\n      // if second argument (value) is a function it's a converter\n      result = this.read(cookie, value);\n      break;\n    }\n    // prevent storing a cookie that we couldn't decode\n    if (!key && (cookie = this.read(cookie)) !== undefined) {\n      result[name] = cookie;\n    }\n  }\n  return result;\n}", "code_tokens": ["function", "get", "(", "key", ",", "value", ")", "{", "var", "i", ",", "parts", ",", "name", ",", "cookie", ";", "var", "result", "=", "key", "?", "undefined", ":", "{", "}", ";", "/* istanbul ignore next */", "var", "cookies", "=", "(", "document", ".", "cookie", "||", "''", ")", ".", "split", "(", "'; '", ")", ";", "for", "(", "i", "=", "0", ";", "i", "<", "cookies", ".", "length", ";", "i", "++", ")", "{", "parts", "=", "cookies", "[", "i", "]", ".", "split", "(", "'='", ")", ";", "name", "=", "this", ".", "decode", "(", "parts", ".", "shift", "(", ")", ")", ";", "cookie", "=", "parts", ".", "join", "(", "'='", ")", ";", "if", "(", "key", "&&", "key", "===", "name", ")", "{", "// if second argument (value) is a function it's a converter", "result", "=", "this", ".", "read", "(", "cookie", ",", "value", ")", ";", "break", ";", "}", "// prevent storing a cookie that we couldn't decode", "if", "(", "!", "key", "&&", "(", "cookie", "=", "this", ".", "read", "(", "cookie", ")", ")", "!==", "undefined", ")", "{", "result", "[", "name", "]", "=", "cookie", ";", "}", "}", "return", "result", ";", "}"], "docstring": "Get a cookie value.\n\n@param key The cookie key name.\n@param value A converter function used when reading the cookie value.", "docstring_tokens": ["Get", "a", "cookie", "value", "."], "sha": "c64f8abf894bd0d66248d2a6310013783c86dddf", "url": "https://github.com/socialally/browser-cookie/blob/c64f8abf894bd0d66248d2a6310013783c86dddf/lib/cookie.js#L64-L84", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/object-store/utils.js", "func_name": "getFieldPaths", "original_string": "function getFieldPaths(object, stopOnKeyRange = true) {\n  let fieldPaths = []\n  fieldPaths.containsKeyRange = false\n  generateFieldPaths(object, [])\n\n  return fieldPaths\n\n  function generateFieldPaths(object, parts) {\n    Object.keys(object).some((fieldName) => {\n      let value = object[fieldName]\n      if (stopOnKeyRange && (value instanceof IDBKeyRange)) {\n        fieldPaths = null\n        return true\n      }\n\n      let isTerminalValue =\n          !(value instanceof Object) ||\n          (value instanceof Date) ||\n          (value instanceof Array) ||\n          (value instanceof IDBKeyRange)\n      let fieldPath = parts.slice()\n      fieldPath.push(fieldName)\n\n      if (isTerminalValue) {\n        fieldPaths.push(fieldPath.join(\".\"))\n      } else {\n        generateFieldPaths(value, fieldPath)\n      }\n    })\n  }\n}", "language": "javascript", "code": "function getFieldPaths(object, stopOnKeyRange = true) {\n  let fieldPaths = []\n  fieldPaths.containsKeyRange = false\n  generateFieldPaths(object, [])\n\n  return fieldPaths\n\n  function generateFieldPaths(object, parts) {\n    Object.keys(object).some((fieldName) => {\n      let value = object[fieldName]\n      if (stopOnKeyRange && (value instanceof IDBKeyRange)) {\n        fieldPaths = null\n        return true\n      }\n\n      let isTerminalValue =\n          !(value instanceof Object) ||\n          (value instanceof Date) ||\n          (value instanceof Array) ||\n          (value instanceof IDBKeyRange)\n      let fieldPath = parts.slice()\n      fieldPath.push(fieldName)\n\n      if (isTerminalValue) {\n        fieldPaths.push(fieldPath.join(\".\"))\n      } else {\n        generateFieldPaths(value, fieldPath)\n      }\n    })\n  }\n}", "code_tokens": ["function", "getFieldPaths", "(", "object", ",", "stopOnKeyRange", "=", "true", ")", "{", "let", "fieldPaths", "=", "[", "]", "fieldPaths", ".", "containsKeyRange", "=", "false", "generateFieldPaths", "(", "object", ",", "[", "]", ")", "return", "fieldPaths", "function", "generateFieldPaths", "(", "object", ",", "parts", ")", "{", "Object", ".", "keys", "(", "object", ")", ".", "some", "(", "(", "fieldName", ")", "=>", "{", "let", "value", "=", "object", "[", "fieldName", "]", "if", "(", "stopOnKeyRange", "&&", "(", "value", "instanceof", "IDBKeyRange", ")", ")", "{", "fieldPaths", "=", "null", "return", "true", "}", "let", "isTerminalValue", "=", "!", "(", "value", "instanceof", "Object", ")", "||", "(", "value", "instanceof", "Date", ")", "||", "(", "value", "instanceof", "Array", ")", "||", "(", "value", "instanceof", "IDBKeyRange", ")", "let", "fieldPath", "=", "parts", ".", "slice", "(", ")", "fieldPath", ".", "push", "(", "fieldName", ")", "if", "(", "isTerminalValue", ")", "{", "fieldPaths", ".", "push", "(", "fieldPath", ".", "join", "(", "\".\"", ")", ")", "}", "else", "{", "generateFieldPaths", "(", "value", ",", "fieldPath", ")", "}", "}", ")", "}", "}"], "docstring": "Generates an array containing all field paths in the provided object.\n\nThe method also tests whether any of the leaf field values is an\n{@linkcode IDBKeyRange} instance, in such case the method returns\n{@code null}.\n\nThe method is used to determine whether the provided object can be turned\ninto and {@linkcode IDBKeyRange} instance for a compound record key, and if\nso, retrieve all field paths in the object so that its structure can be\nvalidated against the field paths of the storage.\n\n@param {Object} object The object from which the field paths are to be\nextracted.\n@param {boolean=} stopOnKeyRange When {@code true}, the method returns\n{@code null} if it encounters a key range.\n@return {?string[]} All field paths in the provided objects, unless the\nobject contains a field set to an {@linkcode IDBKeyRange} instance.", "docstring_tokens": ["Generates", "an", "array", "containing", "all", "field", "paths", "in", "the", "provided", "object", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/object-store/utils.js#L430-L460", "partition": "test"}
{"repo": "mcasimir/mobile-angular-ui", "path": "dist/js/mobile-angular-ui.gestures.js", "func_name": "", "original_string": "function(e) {\n      e = e.length ? e[0] : e;\n      var tr = window\n        .getComputedStyle(e, null)\n        .getPropertyValue(transformProperty);\n      return tr;\n    }", "language": "javascript", "code": "function(e) {\n      e = e.length ? e[0] : e;\n      var tr = window\n        .getComputedStyle(e, null)\n        .getPropertyValue(transformProperty);\n      return tr;\n    }", "code_tokens": ["function", "(", "e", ")", "{", "e", "=", "e", ".", "length", "?", "e", "[", "0", "]", ":", "e", ";", "var", "tr", "=", "window", ".", "getComputedStyle", "(", "e", ",", "null", ")", ".", "getPropertyValue", "(", "transformProperty", ")", ";", "return", "tr", ";", "}"], "docstring": "return current element transform matrix in a cross-browser way", "docstring_tokens": ["return", "current", "element", "transform", "matrix", "in", "a", "cross", "-", "browser", "way"], "sha": "5ec10ac8883e31beb91a940f133290a5146a126d", "url": "https://github.com/mcasimir/mobile-angular-ui/blob/5ec10ac8883e31beb91a940f133290a5146a126d/dist/js/mobile-angular-ui.gestures.js#L1263-L1269", "partition": "test"}
{"repo": "young-steveo/bottlejs", "path": "dist/bottle.js", "func_name": "constant", "original_string": "function constant(name, value) {\n        var parts = name.split(DELIMITER);\n        name = parts.pop();\n        defineConstant.call(parts.reduce(setValueObject, this.container), name, value);\n        return this;\n    }", "language": "javascript", "code": "function constant(name, value) {\n        var parts = name.split(DELIMITER);\n        name = parts.pop();\n        defineConstant.call(parts.reduce(setValueObject, this.container), name, value);\n        return this;\n    }", "code_tokens": ["function", "constant", "(", "name", ",", "value", ")", "{", "var", "parts", "=", "name", ".", "split", "(", "DELIMITER", ")", ";", "name", "=", "parts", ".", "pop", "(", ")", ";", "defineConstant", ".", "call", "(", "parts", ".", "reduce", "(", "setValueObject", ",", "this", ".", "container", ")", ",", "name", ",", "value", ")", ";", "return", "this", ";", "}"], "docstring": "Register a constant\n\n@param String name\n@param mixed value\n@return Bottle", "docstring_tokens": ["Register", "a", "constant"], "sha": "2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51", "url": "https://github.com/young-steveo/bottlejs/blob/2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51/dist/bottle.js#L368-L373", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Bus.js", "func_name": "unsubscribe", "original_string": "function unsubscribe(oSubscriber) {\n  let nUnsubscribed = 0;\n  const oEventsCallbacks = oSubscriber.events;\n  if (!oSubscriber || oEventsCallbacks === und) {\n    return false;\n  }\n  iterateObject(oEventsCallbacks, function (oItem, sChannelId) {\n    if (oChannels[sChannelId] === und) {\n      oChannels[sChannelId] = {};\n    }\n    nUnsubscribed = _removeSubscribersPerEvent(oItem, sChannelId, oSubscriber);\n  });\n\n  return nUnsubscribed > 0;\n}", "language": "javascript", "code": "function unsubscribe(oSubscriber) {\n  let nUnsubscribed = 0;\n  const oEventsCallbacks = oSubscriber.events;\n  if (!oSubscriber || oEventsCallbacks === und) {\n    return false;\n  }\n  iterateObject(oEventsCallbacks, function (oItem, sChannelId) {\n    if (oChannels[sChannelId] === und) {\n      oChannels[sChannelId] = {};\n    }\n    nUnsubscribed = _removeSubscribersPerEvent(oItem, sChannelId, oSubscriber);\n  });\n\n  return nUnsubscribed > 0;\n}", "code_tokens": ["function", "unsubscribe", "(", "oSubscriber", ")", "{", "let", "nUnsubscribed", "=", "0", ";", "const", "oEventsCallbacks", "=", "oSubscriber", ".", "events", ";", "if", "(", "!", "oSubscriber", "||", "oEventsCallbacks", "===", "und", ")", "{", "return", "false", ";", "}", "iterateObject", "(", "oEventsCallbacks", ",", "function", "(", "oItem", ",", "sChannelId", ")", "{", "if", "(", "oChannels", "[", "sChannelId", "]", "===", "und", ")", "{", "oChannels", "[", "sChannelId", "]", "=", "{", "}", ";", "}", "nUnsubscribed", "=", "_removeSubscribersPerEvent", "(", "oItem", ",", "sChannelId", ",", "oSubscriber", ")", ";", "}", ")", ";", "return", "nUnsubscribed", ">", "0", ";", "}"], "docstring": "unsubscribe gets the oEventsCallbacks methods and removes the handlers of the channel.\n@param {Object} oSubscriber\n@return {Boolean}", "docstring_tokens": ["unsubscribe", "gets", "the", "oEventsCallbacks", "methods", "and", "removes", "the", "handlers", "of", "the", "channel", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Bus.js#L180-L194", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "selectBestInvalidOverloadIndex", "original_string": "function selectBestInvalidOverloadIndex(candidates, argumentCount) {\n                var maxParamsSignatureIndex = -1;\n                var maxParams = -1;\n                for (var i = 0; i < candidates.length; i++) {\n                    var candidate = candidates[i];\n                    if (candidate.hasRestParameter || candidate.parameters.length >= argumentCount) {\n                        return i;\n                    }\n                    if (candidate.parameters.length > maxParams) {\n                        maxParams = candidate.parameters.length;\n                        maxParamsSignatureIndex = i;\n                    }\n                }\n                return maxParamsSignatureIndex;\n            }", "language": "javascript", "code": "function selectBestInvalidOverloadIndex(candidates, argumentCount) {\n                var maxParamsSignatureIndex = -1;\n                var maxParams = -1;\n                for (var i = 0; i < candidates.length; i++) {\n                    var candidate = candidates[i];\n                    if (candidate.hasRestParameter || candidate.parameters.length >= argumentCount) {\n                        return i;\n                    }\n                    if (candidate.parameters.length > maxParams) {\n                        maxParams = candidate.parameters.length;\n                        maxParamsSignatureIndex = i;\n                    }\n                }\n                return maxParamsSignatureIndex;\n            }", "code_tokens": ["function", "selectBestInvalidOverloadIndex", "(", "candidates", ",", "argumentCount", ")", "{", "var", "maxParamsSignatureIndex", "=", "-", "1", ";", "var", "maxParams", "=", "-", "1", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "candidates", ".", "length", ";", "i", "++", ")", "{", "var", "candidate", "=", "candidates", "[", "i", "]", ";", "if", "(", "candidate", ".", "hasRestParameter", "||", "candidate", ".", "parameters", ".", "length", ">=", "argumentCount", ")", "{", "return", "i", ";", "}", "if", "(", "candidate", ".", "parameters", ".", "length", ">", "maxParams", ")", "{", "maxParams", "=", "candidate", ".", "parameters", ".", "length", ";", "maxParamsSignatureIndex", "=", "i", ";", "}", "}", "return", "maxParamsSignatureIndex", ";", "}"], "docstring": "The selectedItemIndex could be negative for several reasons.\n1. There are too many arguments for all of the overloads\n2. None of the overloads were type compatible\nThe solution here is to try to pick the best overload by picking\neither the first one that has an appropriate number of parameters,\nor the one with the most parameters.", "docstring_tokens": ["The", "selectedItemIndex", "could", "be", "negative", "for", "several", "reasons", ".", "1", ".", "There", "are", "too", "many", "arguments", "for", "all", "of", "the", "overloads", "2", ".", "None", "of", "the", "overloads", "were", "type", "compatible", "The", "solution", "here", "is", "to", "try", "to", "pick", "the", "best", "overload", "by", "picking", "either", "the", "first", "one", "that", "has", "an", "appropriate", "number", "of", "parameters", "or", "the", "one", "with", "the", "most", "parameters", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L39184-L39198", "partition": "test"}
{"repo": "everitoken/evtjs", "path": "lib/format.js", "func_name": "UDecimalPad", "original_string": "function UDecimalPad(num, precision) {\n    var value = UDecimalString(num);\n    assert.equal(\"number\", typeof precision === 'undefined' ? 'undefined' : (0, _typeof3.default)(precision), \"precision\");\n\n    var part = value.split(\".\");\n\n    if (precision === 0 && part.length === 1) {\n        return part[0];\n    }\n\n    if (part.length === 1) {\n        return part[0] + '.' + \"0\".repeat(precision);\n    } else {\n        var pad = precision - part[1].length;\n        assert(pad >= 0, 'decimal \\'' + value + '\\' exceeds precision ' + precision);\n        return part[0] + '.' + part[1] + \"0\".repeat(pad);\n    }\n}", "language": "javascript", "code": "function UDecimalPad(num, precision) {\n    var value = UDecimalString(num);\n    assert.equal(\"number\", typeof precision === 'undefined' ? 'undefined' : (0, _typeof3.default)(precision), \"precision\");\n\n    var part = value.split(\".\");\n\n    if (precision === 0 && part.length === 1) {\n        return part[0];\n    }\n\n    if (part.length === 1) {\n        return part[0] + '.' + \"0\".repeat(precision);\n    } else {\n        var pad = precision - part[1].length;\n        assert(pad >= 0, 'decimal \\'' + value + '\\' exceeds precision ' + precision);\n        return part[0] + '.' + part[1] + \"0\".repeat(pad);\n    }\n}", "code_tokens": ["function", "UDecimalPad", "(", "num", ",", "precision", ")", "{", "var", "value", "=", "UDecimalString", "(", "num", ")", ";", "assert", ".", "equal", "(", "\"number\"", ",", "typeof", "precision", "===", "'undefined'", "?", "'undefined'", ":", "(", "0", ",", "_typeof3", ".", "default", ")", "(", "precision", ")", ",", "\"precision\"", ")", ";", "var", "part", "=", "value", ".", "split", "(", "\".\"", ")", ";", "if", "(", "precision", "===", "0", "&&", "part", ".", "length", "===", "1", ")", "{", "return", "part", "[", "0", "]", ";", "}", "if", "(", "part", ".", "length", "===", "1", ")", "{", "return", "part", "[", "0", "]", "+", "'.'", "+", "\"0\"", ".", "repeat", "(", "precision", ")", ";", "}", "else", "{", "var", "pad", "=", "precision", "-", "part", "[", "1", "]", ".", "length", ";", "assert", "(", "pad", ">=", "0", ",", "'decimal \\''", "+", "value", "+", "'\\' exceeds precision '", "+", "precision", ")", ";", "return", "part", "[", "0", "]", "+", "'.'", "+", "part", "[", "1", "]", "+", "\"0\"", ".", "repeat", "(", "pad", ")", ";", "}", "}"], "docstring": "Ensure a fixed number of decimal places.  Safe for large numbers.\n\n@see ./format.test.js\n\n@example UDecimalPad(10.2, 3) === '10.200'\n\n@arg {number|string|object.toString} value\n@arg {number} precision - number of decimal places\n@return {string} decimal part is added and zero padded to match precision", "docstring_tokens": ["Ensure", "a", "fixed", "number", "of", "decimal", "places", ".", "Safe", "for", "large", "numbers", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/lib/format.js#L373-L390", "partition": "test"}
{"repo": "GraFiddle/angular-chart", "path": "angular-chart.js", "func_name": "addIdentifier", "original_string": "function addIdentifier() {\n      $scope.dataAttributeChartID = 'chartid' + Math.floor(Math.random() * 1000000001);\n      angular.element($element).attr('id', $scope.dataAttributeChartID);\n      configuration.bindto = '#' + $scope.dataAttributeChartID;\n    }", "language": "javascript", "code": "function addIdentifier() {\n      $scope.dataAttributeChartID = 'chartid' + Math.floor(Math.random() * 1000000001);\n      angular.element($element).attr('id', $scope.dataAttributeChartID);\n      configuration.bindto = '#' + $scope.dataAttributeChartID;\n    }", "code_tokens": ["function", "addIdentifier", "(", ")", "{", "$scope", ".", "dataAttributeChartID", "=", "'chartid'", "+", "Math", ".", "floor", "(", "Math", ".", "random", "(", ")", "*", "1000000001", ")", ";", "angular", ".", "element", "(", "$element", ")", ".", "attr", "(", "'id'", ",", "$scope", ".", "dataAttributeChartID", ")", ";", "configuration", ".", "bindto", "=", "'#'", "+", "$scope", ".", "dataAttributeChartID", ";", "}"], "docstring": "Add unique identifier for each chart", "docstring_tokens": ["Add", "unique", "identifier", "for", "each", "chart"], "sha": "76620974f0547b5a9c86d2860b6b401af8aee5fc", "url": "https://github.com/GraFiddle/angular-chart/blob/76620974f0547b5a9c86d2860b6b401af8aee5fc/angular-chart.js#L893-L897", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/language.js", "func_name": "compareSpecs", "original_string": "function compareSpecs(a, b) {\n  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;\n}", "language": "javascript", "code": "function compareSpecs(a, b) {\n  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;\n}", "code_tokens": ["function", "compareSpecs", "(", "a", ",", "b", ")", "{", "return", "(", "b", ".", "q", "-", "a", ".", "q", ")", "||", "(", "b", ".", "s", "-", "a", ".", "s", ")", "||", "(", "a", ".", "o", "-", "b", ".", "o", ")", "||", "(", "a", ".", "i", "-", "b", ".", "i", ")", "||", "0", ";", "}"], "docstring": "Compare two specs.\n@private", "docstring_tokens": ["Compare", "two", "specs", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/language.js#L159-L161", "partition": "test"}
{"repo": "StupidStudio/stupid-imagesloader", "path": "imagesloader.js", "func_name": "convertImagesToSrc", "original_string": "function convertImagesToSrc(imgs){\n\t\tvar src = [];\n\t\tfor (var i = 0; i < imgs.length; i++) {\n\n\t\t\t/** If the img is an object (img) get the src  */\n\t\t\tif(typeof imgs[i]  == 'object'){\n\t\t\t\tsrc.push(imgs[i].src);\n\t\t\t}\n\t\t};\n\n\t\t/** If the src array is null return the original imgs array */\n\t\treturn src.length ? src : imgs;\n\t}", "language": "javascript", "code": "function convertImagesToSrc(imgs){\n\t\tvar src = [];\n\t\tfor (var i = 0; i < imgs.length; i++) {\n\n\t\t\t/** If the img is an object (img) get the src  */\n\t\t\tif(typeof imgs[i]  == 'object'){\n\t\t\t\tsrc.push(imgs[i].src);\n\t\t\t}\n\t\t};\n\n\t\t/** If the src array is null return the original imgs array */\n\t\treturn src.length ? src : imgs;\n\t}", "code_tokens": ["function", "convertImagesToSrc", "(", "imgs", ")", "{", "var", "src", "=", "[", "]", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "imgs", ".", "length", ";", "i", "++", ")", "{", "/** If the img is an object (img) get the src  */", "if", "(", "typeof", "imgs", "[", "i", "]", "==", "'object'", ")", "{", "src", ".", "push", "(", "imgs", "[", "i", "]", ".", "src", ")", ";", "}", "}", ";", "/** If the src array is null return the original imgs array */", "return", "src", ".", "length", "?", "src", ":", "imgs", ";", "}"], "docstring": "Convert img to src\n@param {array} imgs A collection og img/img paths\n@config {array} src A temporally array for storing img path/src\n@return {array} Return an array of img src's", "docstring_tokens": ["Convert", "img", "to", "src"], "sha": "92eafa59778b6657b745196ce508fef41546805d", "url": "https://github.com/StupidStudio/stupid-imagesloader/blob/92eafa59778b6657b745196ce508fef41546805d/imagesloader.js#L101-L113", "partition": "test"}
{"repo": "jesusprubio/sip-fake-stack", "path": "src/steroidsSocket.js", "func_name": "SteroidsSocket", "original_string": "function SteroidsSocket(options) {\n    var finalTarget;\n\n    if (options.target && net.isIPv6(options.target)) {\n        finalTarget = normalize6(options.target);\n    } else {\n        finalTarget = options.target;\n    }\n\n    this.target = finalTarget;\n    this.port = options.port || 80;\n    this.transport = options.transport || 'TCP';\n    this.lport = options.lport || null;\n    this.timeout = options.timeout || 8000;\n    this.allowHalfOpen = options.allowHalfOpen || null;\n    this.wsProto = options.wsProto || 'sip';\n    this.wsPath = options.wsPath || null;\n\n    // We init the socket in the send function to be able\n    // to detect timeouts using UDP (no \"received\" or similar event)\n}", "language": "javascript", "code": "function SteroidsSocket(options) {\n    var finalTarget;\n\n    if (options.target && net.isIPv6(options.target)) {\n        finalTarget = normalize6(options.target);\n    } else {\n        finalTarget = options.target;\n    }\n\n    this.target = finalTarget;\n    this.port = options.port || 80;\n    this.transport = options.transport || 'TCP';\n    this.lport = options.lport || null;\n    this.timeout = options.timeout || 8000;\n    this.allowHalfOpen = options.allowHalfOpen || null;\n    this.wsProto = options.wsProto || 'sip';\n    this.wsPath = options.wsPath || null;\n\n    // We init the socket in the send function to be able\n    // to detect timeouts using UDP (no \"received\" or similar event)\n}", "code_tokens": ["function", "SteroidsSocket", "(", "options", ")", "{", "var", "finalTarget", ";", "if", "(", "options", ".", "target", "&&", "net", ".", "isIPv6", "(", "options", ".", "target", ")", ")", "{", "finalTarget", "=", "normalize6", "(", "options", ".", "target", ")", ";", "}", "else", "{", "finalTarget", "=", "options", ".", "target", ";", "}", "this", ".", "target", "=", "finalTarget", ";", "this", ".", "port", "=", "options", ".", "port", "||", "80", ";", "this", ".", "transport", "=", "options", ".", "transport", "||", "'TCP'", ";", "this", ".", "lport", "=", "options", ".", "lport", "||", "null", ";", "this", ".", "timeout", "=", "options", ".", "timeout", "||", "8000", ";", "this", ".", "allowHalfOpen", "=", "options", ".", "allowHalfOpen", "||", "null", ";", "this", ".", "wsProto", "=", "options", ".", "wsProto", "||", "'sip'", ";", "this", ".", "wsPath", "=", "options", ".", "wsPath", "||", "null", ";", "// We init the socket in the send function to be able", "// to detect timeouts using UDP (no \"received\" or similar event)", "}"], "docstring": "Public stuff Constructor", "docstring_tokens": ["Public", "stuff", "Constructor"], "sha": "696754011043a9d75f3cde7de638690a9eca1c81", "url": "https://github.com/jesusprubio/sip-fake-stack/blob/696754011043a9d75f3cde7de638690a9eca1c81/src/steroidsSocket.js#L54-L74", "partition": "test"}
{"repo": "GeoSensorWebLab/polarmap.js", "path": "examples/PolarMap/alignment/demo.js", "func_name": "addToMap", "original_string": "function addToMap(location, map) {\n    var marker = L.marker(location.coordinates);\n    marker.addTo(map);\n  }", "language": "javascript", "code": "function addToMap(location, map) {\n    var marker = L.marker(location.coordinates);\n    marker.addTo(map);\n  }", "code_tokens": ["function", "addToMap", "(", "location", ",", "map", ")", "{", "var", "marker", "=", "L", ".", "marker", "(", "location", ".", "coordinates", ")", ";", "marker", ".", "addTo", "(", "map", ")", ";", "}"], "docstring": "Have to create a separate marker for each map else weirdness happens", "docstring_tokens": ["Have", "to", "create", "a", "separate", "marker", "for", "each", "map", "else", "weirdness", "happens"], "sha": "fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b", "url": "https://github.com/GeoSensorWebLab/polarmap.js/blob/fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b/examples/PolarMap/alignment/demo.js#L35-L38", "partition": "test"}
{"repo": "AustP/jwt-express", "path": "jwt-express.js", "func_name": "", "original_string": "function(res) {\n        if (this.options.cookies) {\n            res.cookie(this.options.cookie, this.token, this.options.cookieOptions);\n        }\n        \n        return this;\n    }", "language": "javascript", "code": "function(res) {\n        if (this.options.cookies) {\n            res.cookie(this.options.cookie, this.token, this.options.cookieOptions);\n        }\n        \n        return this;\n    }", "code_tokens": ["function", "(", "res", ")", "{", "if", "(", "this", ".", "options", ".", "cookies", ")", "{", "res", ".", "cookie", "(", "this", ".", "options", ".", "cookie", ",", "this", ".", "token", ",", "this", ".", "options", ".", "cookieOptions", ")", ";", "}", "return", "this", ";", "}"], "docstring": "store - stores the JWT in the cookie\n@param object res The Express HTTP Response object\n@return this", "docstring_tokens": ["store", "-", "stores", "the", "JWT", "in", "the", "cookie"], "sha": "f33e5c858e19826b7d767939a7048e3c5ff66387", "url": "https://github.com/AustP/jwt-express/blob/f33e5c858e19826b7d767939a7048e3c5ff66387/jwt-express.js#L59-L65", "partition": "test"}
{"repo": "zaproxy/zaproxy", "path": "src/scripts/templates/targeted/Find HTML comments.js", "func_name": "invokeWith", "original_string": "function invokeWith(msg) {\n\t// Debugging can be done using println like this\n\tprint('Finding comments in ' + msg.getRequestHeader().getURI().toString()); \n\n\tvar body = msg.getResponseBody().toString()\n\t// Look for html comments\n\tif (body.indexOf('<!--') > 0) {\n\t\tvar o = body.indexOf('<!--');\n\t\twhile (o > 0) {\n\t\t\tvar e = body.indexOf('-->', o);\n\t\t\tprint(\"\\t\" + body.substr(o,e-o+3)) \n\t\t\to = body.indexOf('<!--', e);\n\t\t}\n\t}\n}", "language": "javascript", "code": "function invokeWith(msg) {\n\t// Debugging can be done using println like this\n\tprint('Finding comments in ' + msg.getRequestHeader().getURI().toString()); \n\n\tvar body = msg.getResponseBody().toString()\n\t// Look for html comments\n\tif (body.indexOf('<!--') > 0) {\n\t\tvar o = body.indexOf('<!--');\n\t\twhile (o > 0) {\n\t\t\tvar e = body.indexOf('-->', o);\n\t\t\tprint(\"\\t\" + body.substr(o,e-o+3)) \n\t\t\to = body.indexOf('<!--', e);\n\t\t}\n\t}\n}", "code_tokens": ["function", "invokeWith", "(", "msg", ")", "{", "// Debugging can be done using println like this", "print", "(", "'Finding comments in '", "+", "msg", ".", "getRequestHeader", "(", ")", ".", "getURI", "(", ")", ".", "toString", "(", ")", ")", ";", "var", "body", "=", "msg", ".", "getResponseBody", "(", ")", ".", "toString", "(", ")", "// Look for html comments", "if", "(", "body", ".", "indexOf", "(", "'<!--'", ")", ">", "0", ")", "{", "var", "o", "=", "body", ".", "indexOf", "(", "'<!--'", ")", ";", "while", "(", "o", ">", "0", ")", "{", "var", "e", "=", "body", ".", "indexOf", "(", "'-->'", ",", "o", ")", ";", "print", "(", "\"\\t\"", "+", "body", ".", "substr", "(", "o", ",", "e", "-", "o", "+", "3", ")", ")", "o", "=", "body", ".", "indexOf", "(", "'<!--'", ",", "e", ")", ";", "}", "}", "}"], "docstring": "Targeted scripts can only be invoked by you, the user, eg via a right-click option on the Sites or History tabs", "docstring_tokens": ["Targeted", "scripts", "can", "only", "be", "invoked", "by", "you", "the", "user", "eg", "via", "a", "right", "-", "click", "option", "on", "the", "Sites", "or", "History", "tabs"], "sha": "688486b806508970d048228059045c9f5b6725d0", "url": "https://github.com/zaproxy/zaproxy/blob/688486b806508970d048228059045c9f5b6725d0/src/scripts/templates/targeted/Find HTML comments.js#L3-L17", "partition": "test"}
{"repo": "jeka-kiselyov/mdict", "path": "mdict-parser.js", "func_name": "read_definition", "original_string": "function read_definition(input, block, keyinfo) {\n      var scanner = Scanner(input).readBlock(block.comp_size, block.decomp_size);\n      scanner.forward(keyinfo.offset - block.decomp_offset);\n      return scanner.readText();\n    }", "language": "javascript", "code": "function read_definition(input, block, keyinfo) {\n      var scanner = Scanner(input).readBlock(block.comp_size, block.decomp_size);\n      scanner.forward(keyinfo.offset - block.decomp_offset);\n      return scanner.readText();\n    }", "code_tokens": ["function", "read_definition", "(", "input", ",", "block", ",", "keyinfo", ")", "{", "var", "scanner", "=", "Scanner", "(", "input", ")", ".", "readBlock", "(", "block", ".", "comp_size", ",", "block", ".", "decomp_size", ")", ";", "scanner", ".", "forward", "(", "keyinfo", ".", "offset", "-", "block", ".", "decomp_offset", ")", ";", "return", "scanner", ".", "readText", "(", ")", ";", "}"], "docstring": "Read definition in text for given keyinfo object.\n@param input record block sliced from the file\n@param block record block index\n@param keyinfo a object with property of record's offset and optional size for the given keyword\n@return definition in text", "docstring_tokens": ["Read", "definition", "in", "text", "for", "given", "keyinfo", "object", "."], "sha": "540898e63991cb0c8985ed8fb29eb11a59f35089", "url": "https://github.com/jeka-kiselyov/mdict/blob/540898e63991cb0c8985ed8fb29eb11a59f35089/mdict-parser.js#L641-L645", "partition": "test"}
{"repo": "MiguelTVMS/GitCapsule", "path": "lib/gitrepository.js", "func_name": "createGitRepository", "original_string": "function createGitRepository(basePath, options) {\n    if (typeof (options) === \"undefined\")\n        options = defaultRepositoryOptions;\n\n    var gitRepository = new GitRepository();\n    configureGitRepository(gitRepository, basePath, options);\n    return gitRepository;\n}", "language": "javascript", "code": "function createGitRepository(basePath, options) {\n    if (typeof (options) === \"undefined\")\n        options = defaultRepositoryOptions;\n\n    var gitRepository = new GitRepository();\n    configureGitRepository(gitRepository, basePath, options);\n    return gitRepository;\n}", "code_tokens": ["function", "createGitRepository", "(", "basePath", ",", "options", ")", "{", "if", "(", "typeof", "(", "options", ")", "===", "\"undefined\"", ")", "options", "=", "defaultRepositoryOptions", ";", "var", "gitRepository", "=", "new", "GitRepository", "(", ")", ";", "configureGitRepository", "(", "gitRepository", ",", "basePath", ",", "options", ")", ";", "return", "gitRepository", ";", "}"], "docstring": "Create a instance of a GitCapsule.\n@param  {string} basePath The path where the repository will be stored locally.\n@param  {RepositoryOptions} options? the repository options that will be used.\n@returns GitRepository", "docstring_tokens": ["Create", "a", "instance", "of", "a", "GitCapsule", "."], "sha": "cea800170bd4a47541413e93f0961ea16e2ff6f0", "url": "https://github.com/MiguelTVMS/GitCapsule/blob/cea800170bd4a47541413e93f0961ea16e2ff6f0/lib/gitrepository.js#L385-L392", "partition": "test"}
{"repo": "rstone770/babelify-external-helpers", "path": "source/module-injector.js", "func_name": "", "original_string": "function (browserify, name, source) {\n  if (utility.isNullOrUndefined(browserify)) {\n    throw 'browserify must be defined.';\n  }\n\n  if (!utility.isNonEmptyString(name)) {\n    throw 'name must be defined.';\n  }\n\n  if (utility.isNullOrUndefined(source)) {\n    throw 'source must be defined.';\n  }\n\n  this._browserify = browserify;\n  this._name = name;\n  this._source = source;\n  this._hasModule = false;\n  this._hasResolver = false;\n}", "language": "javascript", "code": "function (browserify, name, source) {\n  if (utility.isNullOrUndefined(browserify)) {\n    throw 'browserify must be defined.';\n  }\n\n  if (!utility.isNonEmptyString(name)) {\n    throw 'name must be defined.';\n  }\n\n  if (utility.isNullOrUndefined(source)) {\n    throw 'source must be defined.';\n  }\n\n  this._browserify = browserify;\n  this._name = name;\n  this._source = source;\n  this._hasModule = false;\n  this._hasResolver = false;\n}", "code_tokens": ["function", "(", "browserify", ",", "name", ",", "source", ")", "{", "if", "(", "utility", ".", "isNullOrUndefined", "(", "browserify", ")", ")", "{", "throw", "'browserify must be defined.'", ";", "}", "if", "(", "!", "utility", ".", "isNonEmptyString", "(", "name", ")", ")", "{", "throw", "'name must be defined.'", ";", "}", "if", "(", "utility", ".", "isNullOrUndefined", "(", "source", ")", ")", "{", "throw", "'source must be defined.'", ";", "}", "this", ".", "_browserify", "=", "browserify", ";", "this", ".", "_name", "=", "name", ";", "this", ".", "_source", "=", "source", ";", "this", ".", "_hasModule", "=", "false", ";", "this", ".", "_hasResolver", "=", "false", ";", "}"], "docstring": "Babel external helper module injector.\n\nThis object will configure browserify to accept a streaming source and then\nresolve any relevant compile time bindings to the built module. The module\ncan later by referenced by name later down the browserify pipeline and modified\nfurther.\n\n@param {!Browserify} browserify\n@param {!String} name\n@param {!Readable} source", "docstring_tokens": ["Babel", "external", "helper", "module", "injector", "."], "sha": "9c6f07b1a882409ba4ae55fbd91e9ee829aab91e", "url": "https://github.com/rstone770/babelify-external-helpers/blob/9c6f07b1a882409ba4ae55fbd91e9ee829aab91e/source/module-injector.js#L30-L48", "partition": "test"}
{"repo": "developmentseed/kes", "path": "src/utils.js", "func_name": "getSystemBucket", "original_string": "function getSystemBucket(config) {\n  let bucket = get(config, 'buckets.internal');\n  if (bucket && typeof bucket === 'string') {\n    return bucket;\n  }\n\n  bucket = get(config, 'system_bucket');\n  if (bucket && typeof bucket === 'string') {\n    return bucket;\n  }\n  return undefined;\n}", "language": "javascript", "code": "function getSystemBucket(config) {\n  let bucket = get(config, 'buckets.internal');\n  if (bucket && typeof bucket === 'string') {\n    return bucket;\n  }\n\n  bucket = get(config, 'system_bucket');\n  if (bucket && typeof bucket === 'string') {\n    return bucket;\n  }\n  return undefined;\n}", "code_tokens": ["function", "getSystemBucket", "(", "config", ")", "{", "let", "bucket", "=", "get", "(", "config", ",", "'buckets.internal'", ")", ";", "if", "(", "bucket", "&&", "typeof", "bucket", "===", "'string'", ")", "{", "return", "bucket", ";", "}", "bucket", "=", "get", "(", "config", ",", "'system_bucket'", ")", ";", "if", "(", "bucket", "&&", "typeof", "bucket", "===", "'string'", ")", "{", "return", "bucket", ";", "}", "return", "undefined", ";", "}"], "docstring": "Discover and returns the system bucket used for deployment\n\n@param {Object} config - cumulus config object\n@returns {string} name of the bucket", "docstring_tokens": ["Discover", "and", "returns", "the", "system", "bucket", "used", "for", "deployment"], "sha": "c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6", "url": "https://github.com/developmentseed/kes/blob/c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6/src/utils.js#L272-L283", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/async/index.js", "func_name": "known", "original_string": "function known (outputFile) {\n    var result = false;\n    this.csFactory(function (done) {\n      result =\n        this._exists(outputFile) || this.filesDone.indexOf(outputFile) > -1;\n      done();\n    }.bind(this), L_WAIT)();\n    return result;\n  }", "language": "javascript", "code": "function known (outputFile) {\n    var result = false;\n    this.csFactory(function (done) {\n      result =\n        this._exists(outputFile) || this.filesDone.indexOf(outputFile) > -1;\n      done();\n    }.bind(this), L_WAIT)();\n    return result;\n  }", "code_tokens": ["function", "known", "(", "outputFile", ")", "{", "var", "result", "=", "false", ";", "this", ".", "csFactory", "(", "function", "(", "done", ")", "{", "result", "=", "this", ".", "_exists", "(", "outputFile", ")", "||", "this", ".", "filesDone", ".", "indexOf", "(", "outputFile", ")", ">", "-", "1", ";", "done", "(", ")", ";", "}", ".", "bind", "(", "this", ")", ",", "L_WAIT", ")", "(", ")", ";", "return", "result", ";", "}"], "docstring": "Check if a file is being processed or has already been processed.\n\n@param {String} outputFile - The outputFile to check.\n@returns {Boolean} true if the fi", "docstring_tokens": ["Check", "if", "a", "file", "is", "being", "processed", "or", "has", "already", "been", "processed", "."], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/async/index.js#L264-L272", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(regionDefinitions, defaults) {\n      regionDefinitions = Marionette._getValue(regionDefinitions, this, arguments);\n  \n      return _.reduce(regionDefinitions, function(regions, definition, name) {\n        if (_.isString(definition)) {\n          definition = {selector: definition};\n        }\n        if (definition.selector) {\n          definition = _.defaults({}, definition, defaults);\n        }\n  \n        regions[name] = this.addRegion(name, definition);\n        return regions;\n      }, {}, this);\n    }", "language": "javascript", "code": "function(regionDefinitions, defaults) {\n      regionDefinitions = Marionette._getValue(regionDefinitions, this, arguments);\n  \n      return _.reduce(regionDefinitions, function(regions, definition, name) {\n        if (_.isString(definition)) {\n          definition = {selector: definition};\n        }\n        if (definition.selector) {\n          definition = _.defaults({}, definition, defaults);\n        }\n  \n        regions[name] = this.addRegion(name, definition);\n        return regions;\n      }, {}, this);\n    }", "code_tokens": ["function", "(", "regionDefinitions", ",", "defaults", ")", "{", "regionDefinitions", "=", "Marionette", ".", "_getValue", "(", "regionDefinitions", ",", "this", ",", "arguments", ")", ";", "return", "_", ".", "reduce", "(", "regionDefinitions", ",", "function", "(", "regions", ",", "definition", ",", "name", ")", "{", "if", "(", "_", ".", "isString", "(", "definition", ")", ")", "{", "definition", "=", "{", "selector", ":", "definition", "}", ";", "}", "if", "(", "definition", ".", "selector", ")", "{", "definition", "=", "_", ".", "defaults", "(", "{", "}", ",", "definition", ",", "defaults", ")", ";", "}", "regions", "[", "name", "]", "=", "this", ".", "addRegion", "(", "name", ",", "definition", ")", ";", "return", "regions", ";", "}", ",", "{", "}", ",", "this", ")", ";", "}"], "docstring": "Add multiple regions using an object literal or a function that returns an object literal, where each key becomes the region name, and each value is the region definition.", "docstring_tokens": ["Add", "multiple", "regions", "using", "an", "object", "literal", "or", "a", "function", "that", "returns", "an", "object", "literal", "where", "each", "key", "becomes", "the", "region", "name", "and", "each", "value", "is", "the", "region", "definition", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L17528-L17542", "partition": "test"}
{"repo": "jasmith79/decorators-js", "path": "dist/decorators.js", "func_name": "pipe", "original_string": "function pipe() {\n    for (var _len6 = arguments.length, fs = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      fs[_key6] = arguments[_key6];\n    }\n\n    return function () {\n      var _this3 = this;\n\n      var first = fs.shift();\n\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return fs.reduce(function (acc, f) {\n        return f.call(_this3, acc);\n      }, first.apply(this, args));\n    };\n  }", "language": "javascript", "code": "function pipe() {\n    for (var _len6 = arguments.length, fs = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      fs[_key6] = arguments[_key6];\n    }\n\n    return function () {\n      var _this3 = this;\n\n      var first = fs.shift();\n\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return fs.reduce(function (acc, f) {\n        return f.call(_this3, acc);\n      }, first.apply(this, args));\n    };\n  }", "code_tokens": ["function", "pipe", "(", ")", "{", "for", "(", "var", "_len6", "=", "arguments", ".", "length", ",", "fs", "=", "Array", "(", "_len6", ")", ",", "_key6", "=", "0", ";", "_key6", "<", "_len6", ";", "_key6", "++", ")", "{", "fs", "[", "_key6", "]", "=", "arguments", "[", "_key6", "]", ";", "}", "return", "function", "(", ")", "{", "var", "_this3", "=", "this", ";", "var", "first", "=", "fs", ".", "shift", "(", ")", ";", "for", "(", "var", "_len7", "=", "arguments", ".", "length", ",", "args", "=", "Array", "(", "_len7", ")", ",", "_key7", "=", "0", ";", "_key7", "<", "_len7", ";", "_key7", "++", ")", "{", "args", "[", "_key7", "]", "=", "arguments", "[", "_key7", "]", ";", "}", "return", "fs", ".", "reduce", "(", "function", "(", "acc", ",", "f", ")", "{", "return", "f", ".", "call", "(", "_this3", ",", "acc", ")", ";", "}", ",", "first", ".", "apply", "(", "this", ",", "args", ")", ")", ";", "}", ";", "}"], "docstring": "pipe Forward function composition.", "docstring_tokens": ["pipe", "Forward", "function", "composition", "."], "sha": "9d34c8056f6ffa7dba07cc4e0919e6e243beea33", "url": "https://github.com/jasmith79/decorators-js/blob/9d34c8056f6ffa7dba07cc4e0919e6e243beea33/dist/decorators.js#L225-L243", "partition": "test"}
{"repo": "AlverLyu/sm.js", "path": "lib/sm2.js", "func_name": "SM2Curve", "original_string": "function SM2Curve(params) {\n  if (!(this instanceof SM2Curve)) {\n    return new SM2Curve(params);\n  }\n\n  elliptic.curve.short.call(this, params);\n}", "language": "javascript", "code": "function SM2Curve(params) {\n  if (!(this instanceof SM2Curve)) {\n    return new SM2Curve(params);\n  }\n\n  elliptic.curve.short.call(this, params);\n}", "code_tokens": ["function", "SM2Curve", "(", "params", ")", "{", "if", "(", "!", "(", "this", "instanceof", "SM2Curve", ")", ")", "{", "return", "new", "SM2Curve", "(", "params", ")", ";", "}", "elliptic", ".", "curve", ".", "short", ".", "call", "(", "this", ",", "params", ")", ";", "}"], "docstring": "The SM2 elliptic curve", "docstring_tokens": ["The", "SM2", "elliptic", "curve"], "sha": "6beab32a225f8e4465387c2c995aa2df77f8c67c", "url": "https://github.com/AlverLyu/sm.js/blob/6beab32a225f8e4465387c2c995aa2df77f8c67c/lib/sm2.js#L25-L31", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/elements/Rail/Rail.js", "func_name": "Rail", "original_string": "function Rail(props) {\n  const {\n    attached,\n    children,\n    className,\n    close,\n    content,\n    dividing,\n    internal,\n    position,\n    size,\n  } = props\n\n  const classes = cx(\n    'ui',\n    position,\n    size,\n    useKeyOnly(attached, 'attached'),\n    useKeyOnly(dividing, 'dividing'),\n    useKeyOnly(internal, 'internal'),\n    useKeyOrValueAndKey(close, 'close'),\n    'rail',\n    className,\n  )\n  const rest = getUnhandledProps(Rail, props)\n  const ElementType = getElementType(Rail, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function Rail(props) {\n  const {\n    attached,\n    children,\n    className,\n    close,\n    content,\n    dividing,\n    internal,\n    position,\n    size,\n  } = props\n\n  const classes = cx(\n    'ui',\n    position,\n    size,\n    useKeyOnly(attached, 'attached'),\n    useKeyOnly(dividing, 'dividing'),\n    useKeyOnly(internal, 'internal'),\n    useKeyOrValueAndKey(close, 'close'),\n    'rail',\n    className,\n  )\n  const rest = getUnhandledProps(Rail, props)\n  const ElementType = getElementType(Rail, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "Rail", "(", "props", ")", "{", "const", "{", "attached", ",", "children", ",", "className", ",", "close", ",", "content", ",", "dividing", ",", "internal", ",", "position", ",", "size", ",", "}", "=", "props", "const", "classes", "=", "cx", "(", "'ui'", ",", "position", ",", "size", ",", "useKeyOnly", "(", "attached", ",", "'attached'", ")", ",", "useKeyOnly", "(", "dividing", ",", "'dividing'", ")", ",", "useKeyOnly", "(", "internal", ",", "'internal'", ")", ",", "useKeyOrValueAndKey", "(", "close", ",", "'close'", ")", ",", "'rail'", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "Rail", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "Rail", ",", "props", ")", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "childrenUtils", ".", "isNil", "(", "children", ")", "?", "content", ":", "children", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A rail is used to show accompanying content outside the boundaries of the main view of a site.", "docstring_tokens": ["A", "rail", "is", "used", "to", "show", "accompanying", "content", "outside", "the", "boundaries", "of", "the", "main", "view", "of", "a", "site", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Rail/Rail.js#L19-L51", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/types/time-uuid.js", "func_name": "getNodeId", "original_string": "function getNodeId(nodeId) {\n  let buffer = nodeId;\n  if (typeof nodeId === 'string') {\n    buffer = utils.allocBufferFromString(nodeId, 'ascii');\n  }\n  if (!(buffer instanceof Buffer)) {\n    //Generate\n    buffer = getRandomBytes(6);\n  }\n  else if (buffer.length !== 6) {\n    throw new Error('Node identifier must have 6 bytes');\n  }\n  return buffer;\n}", "language": "javascript", "code": "function getNodeId(nodeId) {\n  let buffer = nodeId;\n  if (typeof nodeId === 'string') {\n    buffer = utils.allocBufferFromString(nodeId, 'ascii');\n  }\n  if (!(buffer instanceof Buffer)) {\n    //Generate\n    buffer = getRandomBytes(6);\n  }\n  else if (buffer.length !== 6) {\n    throw new Error('Node identifier must have 6 bytes');\n  }\n  return buffer;\n}", "code_tokens": ["function", "getNodeId", "(", "nodeId", ")", "{", "let", "buffer", "=", "nodeId", ";", "if", "(", "typeof", "nodeId", "===", "'string'", ")", "{", "buffer", "=", "utils", ".", "allocBufferFromString", "(", "nodeId", ",", "'ascii'", ")", ";", "}", "if", "(", "!", "(", "buffer", "instanceof", "Buffer", ")", ")", "{", "//Generate", "buffer", "=", "getRandomBytes", "(", "6", ")", ";", "}", "else", "if", "(", "buffer", ".", "length", "!==", "6", ")", "{", "throw", "new", "Error", "(", "'Node identifier must have 6 bytes'", ")", ";", "}", "return", "buffer", ";", "}"], "docstring": "Returns a buffer of length 6 representing the clock identifier\n@param {String|Buffer} nodeId\n@returns {Buffer}\n@private", "docstring_tokens": ["Returns", "a", "buffer", "of", "length", "6", "representing", "the", "clock", "identifier"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/types/time-uuid.js#L292-L305", "partition": "test"}
{"repo": "pb82/MissMatch", "path": "lib/MissMatch.js", "func_name": "parseProperties", "original_string": "function parseProperties(node) {\n    consume(); // '('\n\n    while(true) {\n      clear();\n      /**\n       * Properties always have to start with '.' or ':'\n       * o(.x, :y) matches an object with at least an owned property\n       * 'x' and a owned or inherited property 'y'. \n       */\n      if(peek() === '.') {\n        parseProperty(node,false);  // own property\n      } else if(peek() === ':') {\n        parseProperty(node,true);   // prototype property\n      } else {\n        unexpectedTokenException('. or :');\n      }\n      clear();\n\n      if(peek() !== ',') {\n        break;\n      }\n      consume(); // ','\n    }\n  }", "language": "javascript", "code": "function parseProperties(node) {\n    consume(); // '('\n\n    while(true) {\n      clear();\n      /**\n       * Properties always have to start with '.' or ':'\n       * o(.x, :y) matches an object with at least an owned property\n       * 'x' and a owned or inherited property 'y'. \n       */\n      if(peek() === '.') {\n        parseProperty(node,false);  // own property\n      } else if(peek() === ':') {\n        parseProperty(node,true);   // prototype property\n      } else {\n        unexpectedTokenException('. or :');\n      }\n      clear();\n\n      if(peek() !== ',') {\n        break;\n      }\n      consume(); // ','\n    }\n  }", "code_tokens": ["function", "parseProperties", "(", "node", ")", "{", "consume", "(", ")", ";", "// '('", "while", "(", "true", ")", "{", "clear", "(", ")", ";", "/**\n       * Properties always have to start with '.' or ':'\n       * o(.x, :y) matches an object with at least an owned property\n       * 'x' and a owned or inherited property 'y'. \n       */", "if", "(", "peek", "(", ")", "===", "'.'", ")", "{", "parseProperty", "(", "node", ",", "false", ")", ";", "// own property", "}", "else", "if", "(", "peek", "(", ")", "===", "':'", ")", "{", "parseProperty", "(", "node", ",", "true", ")", ";", "// prototype property", "}", "else", "{", "unexpectedTokenException", "(", "'. or :'", ")", ";", "}", "clear", "(", ")", ";", "if", "(", "peek", "(", ")", "!==", "','", ")", "{", "break", ";", "}", "consume", "(", ")", ";", "// ','", "}", "}"], "docstring": "Parse the property list of an object pattern.", "docstring_tokens": ["Parse", "the", "property", "list", "of", "an", "object", "pattern", "."], "sha": "13153714c2e4b7fd613c3309131806cfb32ea39f", "url": "https://github.com/pb82/MissMatch/blob/13153714c2e4b7fd613c3309131806cfb32ea39f/lib/MissMatch.js#L197-L221", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/transaction/ReadOnlyTransaction.js", "func_name": "executeEventListeners", "original_string": "function executeEventListeners(listeners, ...parameters) {\n  listeners.forEach((listener) => {\n    try {\n      listener.apply(null, parameters)\n    } catch (error) {\n      console.error(\"An event listener threw an error\", error)\n    }\n  })\n}", "language": "javascript", "code": "function executeEventListeners(listeners, ...parameters) {\n  listeners.forEach((listener) => {\n    try {\n      listener.apply(null, parameters)\n    } catch (error) {\n      console.error(\"An event listener threw an error\", error)\n    }\n  })\n}", "code_tokens": ["function", "executeEventListeners", "(", "listeners", ",", "...", "parameters", ")", "{", "listeners", ".", "forEach", "(", "(", "listener", ")", "=>", "{", "try", "{", "listener", ".", "apply", "(", "null", ",", "parameters", ")", "}", "catch", "(", "error", ")", "{", "console", ".", "error", "(", "\"An event listener threw an error\"", ",", "error", ")", "}", "}", ")", "}"], "docstring": "Executes the provided event listeners with the provided parameters. Any\nerrors thrown by the executed event listeners will be caught and logged to\nthe console, and then the remaining event listeners will be executed.\n\n@param {function(...*)[]} listeners The event listeners to execute.\n@param {...*} parameters The parameters to pass to the event listeners as\narguments.", "docstring_tokens": ["Executes", "the", "provided", "event", "listeners", "with", "the", "provided", "parameters", ".", "Any", "errors", "thrown", "by", "the", "executed", "event", "listeners", "will", "be", "caught", "and", "logged", "to", "the", "console", "and", "then", "the", "remaining", "event", "listeners", "will", "be", "executed", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/transaction/ReadOnlyTransaction.js#L235-L243", "partition": "test"}
{"repo": "YR/data-store", "path": "src/lib/DataStore.js", "func_name": "serialise", "original_string": "function serialise(key, data, config) {\n  if (isPlainObject(data)) {\n    const obj = {};\n\n    for (const prop in data) {\n      const keyChain = key ? `${key}/${prop}` : prop;\n      const value = data[prop];\n\n      if (config[keyChain] !== false) {\n        if (isPlainObject(value)) {\n          obj[prop] = serialise(keyChain, value, config);\n        } else if (value != null && typeof value === 'object' && 'toJSON' in value) {\n          obj[prop] = value.toJSON();\n        } else {\n          obj[prop] = value;\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  return config[key] !== false ? data : null;\n}", "language": "javascript", "code": "function serialise(key, data, config) {\n  if (isPlainObject(data)) {\n    const obj = {};\n\n    for (const prop in data) {\n      const keyChain = key ? `${key}/${prop}` : prop;\n      const value = data[prop];\n\n      if (config[keyChain] !== false) {\n        if (isPlainObject(value)) {\n          obj[prop] = serialise(keyChain, value, config);\n        } else if (value != null && typeof value === 'object' && 'toJSON' in value) {\n          obj[prop] = value.toJSON();\n        } else {\n          obj[prop] = value;\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  return config[key] !== false ? data : null;\n}", "code_tokens": ["function", "serialise", "(", "key", ",", "data", ",", "config", ")", "{", "if", "(", "isPlainObject", "(", "data", ")", ")", "{", "const", "obj", "=", "{", "}", ";", "for", "(", "const", "prop", "in", "data", ")", "{", "const", "keyChain", "=", "key", "?", "`", "${", "key", "}", "${", "prop", "}", "`", ":", "prop", ";", "const", "value", "=", "data", "[", "prop", "]", ";", "if", "(", "config", "[", "keyChain", "]", "!==", "false", ")", "{", "if", "(", "isPlainObject", "(", "value", ")", ")", "{", "obj", "[", "prop", "]", "=", "serialise", "(", "keyChain", ",", "value", ",", "config", ")", ";", "}", "else", "if", "(", "value", "!=", "null", "&&", "typeof", "value", "===", "'object'", "&&", "'toJSON'", "in", "value", ")", "{", "obj", "[", "prop", "]", "=", "value", ".", "toJSON", "(", ")", ";", "}", "else", "{", "obj", "[", "prop", "]", "=", "value", ";", "}", "}", "}", "return", "obj", ";", "}", "return", "config", "[", "key", "]", "!==", "false", "?", "data", ":", "null", ";", "}"], "docstring": "Retrieve serialisable 'data'\n@param {String} key\n@param {Object} data\n@param {Object} config\n@returns {Object}", "docstring_tokens": ["Retrieve", "serialisable", "data"], "sha": "bf8f581f850b9ebcb0fd319001ca69d0d9ff967f", "url": "https://github.com/YR/data-store/blob/bf8f581f850b9ebcb0fd319001ca69d0d9ff967f/src/lib/DataStore.js#L519-L542", "partition": "test"}
{"repo": "Everyplay/serverbone-acl", "path": "index.js", "func_name": "", "original_string": "function (permissions) {\n    _.merge(this.permissions, permissions, function (a, b) {\n      return _.isArray(a) ? a.concat(b) : undefined;\n    });\n    return this;\n  }", "language": "javascript", "code": "function (permissions) {\n    _.merge(this.permissions, permissions, function (a, b) {\n      return _.isArray(a) ? a.concat(b) : undefined;\n    });\n    return this;\n  }", "code_tokens": ["function", "(", "permissions", ")", "{", "_", ".", "merge", "(", "this", ".", "permissions", ",", "permissions", ",", "function", "(", "a", ",", "b", ")", "{", "return", "_", ".", "isArray", "(", "a", ")", "?", "a", ".", "concat", "(", "b", ")", ":", "undefined", ";", "}", ")", ";", "return", "this", ";", "}"], "docstring": "allows additional permissions for this acl\n\n@param  {Object} permissions", "docstring_tokens": ["allows", "additional", "permissions", "for", "this", "acl"], "sha": "389221e3c1d7016a18b5a770d20b675c8c3e6d48", "url": "https://github.com/Everyplay/serverbone-acl/blob/389221e3c1d7016a18b5a770d20b675c8c3e6d48/index.js#L89-L94", "partition": "test"}
{"repo": "10xLaCroixDrinker/grunt-node-version", "path": "tasks/node_version.js", "func_name": "", "original_string": "function(loc, callback) {\n      var command = nvmInit + 'nvm ls';\n\n      if (loc === 'remote') {\n        command += '-remote';\n      }\n\n      childProcess.exec(command, cmdOpts, function(err, stdout, stderr) {\n        var data = stripColorCodes(stdout.toString()).replace(/\\s+/g, '|'),\n            available = data.split('|');\n\n        for (var i = 0; i < available.length; i++) {\n          // Trim whitespace\n          available[i] = available[i].replace(/\\s/g, '');\n          // Validate\n          var ver = semver.valid(available[i]);\n          if (ver) {\n            if (loc === 'remote') {\n              remotes.push(ver);\n            } else if (loc === 'local') {\n              locals.push(ver);\n            }\n          }\n        }\n\n        callback();\n      });\n    }", "language": "javascript", "code": "function(loc, callback) {\n      var command = nvmInit + 'nvm ls';\n\n      if (loc === 'remote') {\n        command += '-remote';\n      }\n\n      childProcess.exec(command, cmdOpts, function(err, stdout, stderr) {\n        var data = stripColorCodes(stdout.toString()).replace(/\\s+/g, '|'),\n            available = data.split('|');\n\n        for (var i = 0; i < available.length; i++) {\n          // Trim whitespace\n          available[i] = available[i].replace(/\\s/g, '');\n          // Validate\n          var ver = semver.valid(available[i]);\n          if (ver) {\n            if (loc === 'remote') {\n              remotes.push(ver);\n            } else if (loc === 'local') {\n              locals.push(ver);\n            }\n          }\n        }\n\n        callback();\n      });\n    }", "code_tokens": ["function", "(", "loc", ",", "callback", ")", "{", "var", "command", "=", "nvmInit", "+", "'nvm ls'", ";", "if", "(", "loc", "===", "'remote'", ")", "{", "command", "+=", "'-remote'", ";", "}", "childProcess", ".", "exec", "(", "command", ",", "cmdOpts", ",", "function", "(", "err", ",", "stdout", ",", "stderr", ")", "{", "var", "data", "=", "stripColorCodes", "(", "stdout", ".", "toString", "(", ")", ")", ".", "replace", "(", "/", "\\s+", "/", "g", ",", "'|'", ")", ",", "available", "=", "data", ".", "split", "(", "'|'", ")", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "available", ".", "length", ";", "i", "++", ")", "{", "// Trim whitespace", "available", "[", "i", "]", "=", "available", "[", "i", "]", ".", "replace", "(", "/", "\\s", "/", "g", ",", "''", ")", ";", "// Validate", "var", "ver", "=", "semver", ".", "valid", "(", "available", "[", "i", "]", ")", ";", "if", "(", "ver", ")", "{", "if", "(", "loc", "===", "'remote'", ")", "{", "remotes", ".", "push", "(", "ver", ")", ";", "}", "else", "if", "(", "loc", "===", "'local'", ")", "{", "locals", ".", "push", "(", "ver", ")", ";", "}", "}", "}", "callback", "(", ")", ";", "}", ")", ";", "}"], "docstring": "Check for available node versions", "docstring_tokens": ["Check", "for", "available", "node", "versions"], "sha": "d16beba04f6a6325d2fa8202750165d3fc69b35b", "url": "https://github.com/10xLaCroixDrinker/grunt-node-version/blob/d16beba04f6a6325d2fa8202750165d3fc69b35b/tasks/node_version.js#L181-L208", "partition": "test"}
{"repo": "Cropster/ember-l10n", "path": "lib/commands/utils/validate/validate-placeholders.js", "func_name": "validatePlaceholders", "original_string": "function validatePlaceholders(\n  { id, idPlural, translations },\n  validationErrors\n) {\n  // search for {{placeholderName}}\n  // Also search for e.g. Chinese symbols in the placeholderName\n  let pattern = /{{\\s*(\\S+?)\\s*?}}/g;\n  let placeholders = id.match(pattern) || [];\n\n  // We also want to add placeholders from the plural string\n  if (idPlural) {\n    let pluralPlaceholders = idPlural.match(pattern) || [];\n    pluralPlaceholders.forEach((placeholder) => {\n      if (!placeholders.includes(placeholder)) {\n        placeholders.push(placeholder);\n      }\n    });\n  }\n\n  if (!placeholders.length) {\n    return;\n  }\n\n  translations.forEach((translation) => {\n    let translatedPlaceholders = translation.match(pattern) || [];\n\n    // Search for placeholders in the translated string that are not in the original string\n    let invalidPlaceholder = translatedPlaceholders.find(\n      (placeholder) => !placeholders.includes(placeholder)\n    );\n    if (invalidPlaceholder) {\n      validationErrors.push({\n        id,\n        translation,\n        message: `The placeholder \"${invalidPlaceholder}\" seems to be wrongly translated. Allowed: ${placeholders.join(\n          ', '\n        )}`,\n        level: 'ERROR'\n      });\n    }\n  });\n}", "language": "javascript", "code": "function validatePlaceholders(\n  { id, idPlural, translations },\n  validationErrors\n) {\n  // search for {{placeholderName}}\n  // Also search for e.g. Chinese symbols in the placeholderName\n  let pattern = /{{\\s*(\\S+?)\\s*?}}/g;\n  let placeholders = id.match(pattern) || [];\n\n  // We also want to add placeholders from the plural string\n  if (idPlural) {\n    let pluralPlaceholders = idPlural.match(pattern) || [];\n    pluralPlaceholders.forEach((placeholder) => {\n      if (!placeholders.includes(placeholder)) {\n        placeholders.push(placeholder);\n      }\n    });\n  }\n\n  if (!placeholders.length) {\n    return;\n  }\n\n  translations.forEach((translation) => {\n    let translatedPlaceholders = translation.match(pattern) || [];\n\n    // Search for placeholders in the translated string that are not in the original string\n    let invalidPlaceholder = translatedPlaceholders.find(\n      (placeholder) => !placeholders.includes(placeholder)\n    );\n    if (invalidPlaceholder) {\n      validationErrors.push({\n        id,\n        translation,\n        message: `The placeholder \"${invalidPlaceholder}\" seems to be wrongly translated. Allowed: ${placeholders.join(\n          ', '\n        )}`,\n        level: 'ERROR'\n      });\n    }\n  });\n}", "code_tokens": ["function", "validatePlaceholders", "(", "{", "id", ",", "idPlural", ",", "translations", "}", ",", "validationErrors", ")", "{", "// search for {{placeholderName}}", "// Also search for e.g. Chinese symbols in the placeholderName", "let", "pattern", "=", "/", "{{\\s*(\\S+?)\\s*?}}", "/", "g", ";", "let", "placeholders", "=", "id", ".", "match", "(", "pattern", ")", "||", "[", "]", ";", "// We also want to add placeholders from the plural string", "if", "(", "idPlural", ")", "{", "let", "pluralPlaceholders", "=", "idPlural", ".", "match", "(", "pattern", ")", "||", "[", "]", ";", "pluralPlaceholders", ".", "forEach", "(", "(", "placeholder", ")", "=>", "{", "if", "(", "!", "placeholders", ".", "includes", "(", "placeholder", ")", ")", "{", "placeholders", ".", "push", "(", "placeholder", ")", ";", "}", "}", ")", ";", "}", "if", "(", "!", "placeholders", ".", "length", ")", "{", "return", ";", "}", "translations", ".", "forEach", "(", "(", "translation", ")", "=>", "{", "let", "translatedPlaceholders", "=", "translation", ".", "match", "(", "pattern", ")", "||", "[", "]", ";", "// Search for placeholders in the translated string that are not in the original string", "let", "invalidPlaceholder", "=", "translatedPlaceholders", ".", "find", "(", "(", "placeholder", ")", "=>", "!", "placeholders", ".", "includes", "(", "placeholder", ")", ")", ";", "if", "(", "invalidPlaceholder", ")", "{", "validationErrors", ".", "push", "(", "{", "id", ",", "translation", ",", "message", ":", "`", "${", "invalidPlaceholder", "}", "${", "placeholders", ".", "join", "(", "', '", ")", "}", "`", ",", "level", ":", "'ERROR'", "}", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Validate the regular placeholders of an item.\nThis possibly modifies the given validationErrors.\n\n@method _validatePlaceholder\n@param {String} id\n@param {String} idPlural\n@param {String[]} translations\n@private", "docstring_tokens": ["Validate", "the", "regular", "placeholders", "of", "an", "item", ".", "This", "possibly", "modifies", "the", "given", "validationErrors", "."], "sha": "f5e31fd6333007f4d33fc24b688e5f6ff660a59b", "url": "https://github.com/Cropster/ember-l10n/blob/f5e31fd6333007f4d33fc24b688e5f6ff660a59b/lib/commands/utils/validate/validate-placeholders.js#L11-L52", "partition": "test"}
{"repo": "d3plus/d3plus-hierarchy", "path": "src/nest.js", "func_name": "bubble", "original_string": "function bubble(values) {\n\n  return values.map(d => {\n\n    if (d.key && d.values) {\n      if (d.values[0].key === \"undefined\") return d.values[0].values[0];\n      else d.values = bubble(d.values);\n    }\n\n    return d;\n\n  });\n\n}", "language": "javascript", "code": "function bubble(values) {\n\n  return values.map(d => {\n\n    if (d.key && d.values) {\n      if (d.values[0].key === \"undefined\") return d.values[0].values[0];\n      else d.values = bubble(d.values);\n    }\n\n    return d;\n\n  });\n\n}", "code_tokens": ["function", "bubble", "(", "values", ")", "{", "return", "values", ".", "map", "(", "d", "=>", "{", "if", "(", "d", ".", "key", "&&", "d", ".", "values", ")", "{", "if", "(", "d", ".", "values", "[", "0", "]", ".", "key", "===", "\"undefined\"", ")", "return", "d", ".", "values", "[", "0", "]", ".", "values", "[", "0", "]", ";", "else", "d", ".", "values", "=", "bubble", "(", "d", ".", "values", ")", ";", "}", "return", "d", ";", "}", ")", ";", "}"], "docstring": "Bubbles up values that do not nest to the furthest key.\n@param {Array} *values* The \"values\" of a nest object.\n@private", "docstring_tokens": ["Bubbles", "up", "values", "that", "do", "not", "nest", "to", "the", "furthest", "key", "."], "sha": "b53a557b6d45d8bbb00ce97272061452c455ce6c", "url": "https://github.com/d3plus/d3plus-hierarchy/blob/b53a557b6d45d8bbb00ce97272061452c455ce6c/src/nest.js#L26-L39", "partition": "test"}
{"repo": "pb82/MissMatch", "path": "lib/MissMatch.js", "func_name": "curry", "original_string": "function curry(fun, args) {\n    return function (x) {        \n      return fun.apply(bindingContext, args.concat([x]));\n    };\n  }", "language": "javascript", "code": "function curry(fun, args) {\n    return function (x) {        \n      return fun.apply(bindingContext, args.concat([x]));\n    };\n  }", "code_tokens": ["function", "curry", "(", "fun", ",", "args", ")", "{", "return", "function", "(", "x", ")", "{", "return", "fun", ".", "apply", "(", "bindingContext", ",", "args", ".", "concat", "(", "[", "x", "]", ")", ")", ";", "}", ";", "}"], "docstring": "curry takes a function, and a partial list of arguments and returns\na function that can be executed with the rest of the arguments.\n\n--> var max = curry(Math.max, [2,5]);\n--> max(4);\n--> 5", "docstring_tokens": ["curry", "takes", "a", "function", "and", "a", "partial", "list", "of", "arguments", "and", "returns", "a", "function", "that", "can", "be", "executed", "with", "the", "rest", "of", "the", "arguments", "."], "sha": "13153714c2e4b7fd613c3309131806cfb32ea39f", "url": "https://github.com/pb82/MissMatch/blob/13153714c2e4b7fd613c3309131806cfb32ea39f/lib/MissMatch.js#L448-L452", "partition": "test"}
{"repo": "retextjs/retext-sentiment", "path": "index.js", "func_name": "sentiment", "original_string": "function sentiment(options) {\n  return transformer\n\n  function transformer(node) {\n    var concatenate = concatenateFactory()\n\n    visit(node, any(options))\n    visit(node, concatenate)\n\n    concatenate.done()\n  }\n}", "language": "javascript", "code": "function sentiment(options) {\n  return transformer\n\n  function transformer(node) {\n    var concatenate = concatenateFactory()\n\n    visit(node, any(options))\n    visit(node, concatenate)\n\n    concatenate.done()\n  }\n}", "code_tokens": ["function", "sentiment", "(", "options", ")", "{", "return", "transformer", "function", "transformer", "(", "node", ")", "{", "var", "concatenate", "=", "concatenateFactory", "(", ")", "visit", "(", "node", ",", "any", "(", "options", ")", ")", "visit", "(", "node", ",", "concatenate", ")", "concatenate", ".", "done", "(", ")", "}", "}"], "docstring": "Patch `polarity` and `valence` properties on nodes with a value and word-nodes.  Then, patch the same properties on their parents.", "docstring_tokens": ["Patch", "polarity", "and", "valence", "properties", "on", "nodes", "with", "a", "value", "and", "word", "-", "nodes", ".", "Then", "patch", "the", "same", "properties", "on", "their", "parents", "."], "sha": "c16297b152426091c21a34210d7026e2934fe22a", "url": "https://github.com/retextjs/retext-sentiment/blob/c16297b152426091c21a34210d7026e2934fe22a/index.js#L17-L28", "partition": "test"}
{"repo": "ticup/emotional", "path": "index.js", "func_name": "getXml", "original_string": "function getXml(path, finish) {\n  fs.readFile(path, function(err, data) {\n      if (err) throw err;\n      xmlParser.parseString(data, function (err, result) {\n        if (err) throw err;\n        finish(result);\n      });\n  });\n}", "language": "javascript", "code": "function getXml(path, finish) {\n  fs.readFile(path, function(err, data) {\n      if (err) throw err;\n      xmlParser.parseString(data, function (err, result) {\n        if (err) throw err;\n        finish(result);\n      });\n  });\n}", "code_tokens": ["function", "getXml", "(", "path", ",", "finish", ")", "{", "fs", ".", "readFile", "(", "path", ",", "function", "(", "err", ",", "data", ")", "{", "if", "(", "err", ")", "throw", "err", ";", "xmlParser", ".", "parseString", "(", "data", ",", "function", "(", "err", ",", "result", ")", "{", "if", "(", "err", ")", "throw", "err", ";", "finish", "(", "result", ")", ";", "}", ")", ";", "}", ")", ";", "}"], "docstring": "Read and Parse XML file from given path, pass result to finish Any error that occurs is simpy thrown.", "docstring_tokens": ["Read", "and", "Parse", "XML", "file", "from", "given", "path", "pass", "result", "to", "finish", "Any", "error", "that", "occurs", "is", "simpy", "thrown", "."], "sha": "ab43abab8715d3ecefc359a7649dfdbeba8095ce", "url": "https://github.com/ticup/emotional/blob/ab43abab8715d3ecefc359a7649dfdbeba8095ce/index.js#L392-L400", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getContextualTypeForElementExpression", "original_string": "function getContextualTypeForElementExpression(node) {\n            var arrayLiteral = node.parent;\n            var type = getContextualType(arrayLiteral);\n            if (type) {\n                var index = ts.indexOf(arrayLiteral.elements, node);\n                return getTypeOfPropertyOfContextualType(type, \"\" + index)\n                    || getIndexTypeOfContextualType(type, 1 /* Number */)\n                    || (languageVersion >= 2 /* ES6 */ ? getElementTypeOfIterable(type, /*errorNode*/ undefined) : undefined);\n            }\n            return undefined;\n        }", "language": "javascript", "code": "function getContextualTypeForElementExpression(node) {\n            var arrayLiteral = node.parent;\n            var type = getContextualType(arrayLiteral);\n            if (type) {\n                var index = ts.indexOf(arrayLiteral.elements, node);\n                return getTypeOfPropertyOfContextualType(type, \"\" + index)\n                    || getIndexTypeOfContextualType(type, 1 /* Number */)\n                    || (languageVersion >= 2 /* ES6 */ ? getElementTypeOfIterable(type, /*errorNode*/ undefined) : undefined);\n            }\n            return undefined;\n        }", "code_tokens": ["function", "getContextualTypeForElementExpression", "(", "node", ")", "{", "var", "arrayLiteral", "=", "node", ".", "parent", ";", "var", "type", "=", "getContextualType", "(", "arrayLiteral", ")", ";", "if", "(", "type", ")", "{", "var", "index", "=", "ts", ".", "indexOf", "(", "arrayLiteral", ".", "elements", ",", "node", ")", ";", "return", "getTypeOfPropertyOfContextualType", "(", "type", ",", "\"\"", "+", "index", ")", "||", "getIndexTypeOfContextualType", "(", "type", ",", "1", "/* Number */", ")", "||", "(", "languageVersion", ">=", "2", "/* ES6 */", "?", "getElementTypeOfIterable", "(", "type", ",", "/*errorNode*/", "undefined", ")", ":", "undefined", ")", ";", "}", "return", "undefined", ";", "}"], "docstring": "In an array literal contextually typed by a type T, the contextual type of an element expression at index N is the type of the property with the numeric name N in T, if one exists. Otherwise, if T has a numeric index signature, it is the type of the numeric index signature in T. Otherwise, in ES6 and higher, the contextual type is the iterated type of T.", "docstring_tokens": ["In", "an", "array", "literal", "contextually", "typed", "by", "a", "type", "T", "the", "contextual", "type", "of", "an", "element", "expression", "at", "index", "N", "is", "the", "type", "of", "the", "property", "with", "the", "numeric", "name", "N", "in", "T", "if", "one", "exists", ".", "Otherwise", "if", "T", "has", "a", "numeric", "index", "signature", "it", "is", "the", "type", "of", "the", "numeric", "index", "signature", "in", "T", ".", "Otherwise", "in", "ES6", "and", "higher", "the", "contextual", "type", "is", "the", "iterated", "type", "of", "T", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L19692-L19702", "partition": "test"}
{"repo": "nearform/nscale-kernel", "path": "lib/api.js", "func_name": "", "original_string": "function(user, identifier, containerIdentifier, revision, target, out, cb) {\n    var containerDef;\n    var systemId;\n\n    systemId = _sr.findSystem(identifier);\n    if (!systemId) {\n      logger.error(ERR_NOSYSID); return cb(new Error(ERR_NOSYSID));\n    }\n    var systemRoot = _sr.repoPath(systemId);\n    out.initProgress(9, '--> finding container');\n\n    fetchTarget(systemId, target, revision, function(err, target) {\n      if (err) { return cb(err); }\n        _builder.loadMatchingTargets(systemId, revision, target, function(err, targets) {\n          if (err) { return cb(err); }\n          _builder.findContainer(systemId, revision, targets, containerIdentifier, function(err, containerDefId, targets) {\n            if (err) { out.stdout(err); logger.error(err); return cb(err); }\n            if (!containerDefId) { out.stdout(ERR_NOCDEF); logger.error(ERR_NOCDEF); return cb(ERR_NOCDEF); }\n            async.eachSeries(_.values(targets), function(json, cb) {\n              var root = buildSys(json);\n              containerDef = root.containerDefByDefId(containerDefId);\n              json.repoPath = systemRoot;\n\n              if (!containerDef.specific || !containerDef.specific.repositoryUrl) {\n                return _builder.build(user, systemId, targets, json, containerDef, target, out, cb);\n              }\n\n              _synchrotron.synch(json, containerDef, out, function(err) {\n                if (err) { out.stdout(err); logger.error(err); return cb(err); }\n                _builder.build(user, systemId, targets, json, containerDef, target, out, cb);\n              });\n            }, cb);\n        });\n      });\n    });\n  }", "language": "javascript", "code": "function(user, identifier, containerIdentifier, revision, target, out, cb) {\n    var containerDef;\n    var systemId;\n\n    systemId = _sr.findSystem(identifier);\n    if (!systemId) {\n      logger.error(ERR_NOSYSID); return cb(new Error(ERR_NOSYSID));\n    }\n    var systemRoot = _sr.repoPath(systemId);\n    out.initProgress(9, '--> finding container');\n\n    fetchTarget(systemId, target, revision, function(err, target) {\n      if (err) { return cb(err); }\n        _builder.loadMatchingTargets(systemId, revision, target, function(err, targets) {\n          if (err) { return cb(err); }\n          _builder.findContainer(systemId, revision, targets, containerIdentifier, function(err, containerDefId, targets) {\n            if (err) { out.stdout(err); logger.error(err); return cb(err); }\n            if (!containerDefId) { out.stdout(ERR_NOCDEF); logger.error(ERR_NOCDEF); return cb(ERR_NOCDEF); }\n            async.eachSeries(_.values(targets), function(json, cb) {\n              var root = buildSys(json);\n              containerDef = root.containerDefByDefId(containerDefId);\n              json.repoPath = systemRoot;\n\n              if (!containerDef.specific || !containerDef.specific.repositoryUrl) {\n                return _builder.build(user, systemId, targets, json, containerDef, target, out, cb);\n              }\n\n              _synchrotron.synch(json, containerDef, out, function(err) {\n                if (err) { out.stdout(err); logger.error(err); return cb(err); }\n                _builder.build(user, systemId, targets, json, containerDef, target, out, cb);\n              });\n            }, cb);\n        });\n      });\n    });\n  }", "code_tokens": ["function", "(", "user", ",", "identifier", ",", "containerIdentifier", ",", "revision", ",", "target", ",", "out", ",", "cb", ")", "{", "var", "containerDef", ";", "var", "systemId", ";", "systemId", "=", "_sr", ".", "findSystem", "(", "identifier", ")", ";", "if", "(", "!", "systemId", ")", "{", "logger", ".", "error", "(", "ERR_NOSYSID", ")", ";", "return", "cb", "(", "new", "Error", "(", "ERR_NOSYSID", ")", ")", ";", "}", "var", "systemRoot", "=", "_sr", ".", "repoPath", "(", "systemId", ")", ";", "out", ".", "initProgress", "(", "9", ",", "'--> finding container'", ")", ";", "fetchTarget", "(", "systemId", ",", "target", ",", "revision", ",", "function", "(", "err", ",", "target", ")", "{", "if", "(", "err", ")", "{", "return", "cb", "(", "err", ")", ";", "}", "_builder", ".", "loadMatchingTargets", "(", "systemId", ",", "revision", ",", "target", ",", "function", "(", "err", ",", "targets", ")", "{", "if", "(", "err", ")", "{", "return", "cb", "(", "err", ")", ";", "}", "_builder", ".", "findContainer", "(", "systemId", ",", "revision", ",", "targets", ",", "containerIdentifier", ",", "function", "(", "err", ",", "containerDefId", ",", "targets", ")", "{", "if", "(", "err", ")", "{", "out", ".", "stdout", "(", "err", ")", ";", "logger", ".", "error", "(", "err", ")", ";", "return", "cb", "(", "err", ")", ";", "}", "if", "(", "!", "containerDefId", ")", "{", "out", ".", "stdout", "(", "ERR_NOCDEF", ")", ";", "logger", ".", "error", "(", "ERR_NOCDEF", ")", ";", "return", "cb", "(", "ERR_NOCDEF", ")", ";", "}", "async", ".", "eachSeries", "(", "_", ".", "values", "(", "targets", ")", ",", "function", "(", "json", ",", "cb", ")", "{", "var", "root", "=", "buildSys", "(", "json", ")", ";", "containerDef", "=", "root", ".", "containerDefByDefId", "(", "containerDefId", ")", ";", "json", ".", "repoPath", "=", "systemRoot", ";", "if", "(", "!", "containerDef", ".", "specific", "||", "!", "containerDef", ".", "specific", ".", "repositoryUrl", ")", "{", "return", "_builder", ".", "build", "(", "user", ",", "systemId", ",", "targets", ",", "json", ",", "containerDef", ",", "target", ",", "out", ",", "cb", ")", ";", "}", "_synchrotron", ".", "synch", "(", "json", ",", "containerDef", ",", "out", ",", "function", "(", "err", ")", "{", "if", "(", "err", ")", "{", "out", ".", "stdout", "(", "err", ")", ";", "logger", ".", "error", "(", "err", ")", ";", "return", "cb", "(", "err", ")", ";", "}", "_builder", ".", "build", "(", "user", ",", "systemId", ",", "targets", ",", "json", ",", "containerDef", ",", "target", ",", "out", ",", "cb", ")", ";", "}", ")", ";", "}", ",", "cb", ")", ";", "}", ")", ";", "}", ")", ";", "}", ")", ";", "}"], "docstring": "build a container", "docstring_tokens": ["build", "a", "container"], "sha": "5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3", "url": "https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/api.js#L137-L172", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "", "original_string": "function ( docId, cacheDir ) {\n    var obj = Object.create( cache );\n    obj.load( docId, cacheDir );\n    return obj;\n  }", "language": "javascript", "code": "function ( docId, cacheDir ) {\n    var obj = Object.create( cache );\n    obj.load( docId, cacheDir );\n    return obj;\n  }", "code_tokens": ["function", "(", "docId", ",", "cacheDir", ")", "{", "var", "obj", "=", "Object", ".", "create", "(", "cache", ")", ";", "obj", ".", "load", "(", "docId", ",", "cacheDir", ")", ";", "return", "obj", ";", "}"], "docstring": "Load a cache identified by the given Id. If the element does not exists, then initialize an empty\ncache storage.\n\n@method create\n@param docId {String} the id of the cache, would also be used as the name of the file cache\n@param [cacheDir] {String} directory for the cache entry\n@returns {cache} cache instance", "docstring_tokens": ["Load", "a", "cache", "identified", "by", "the", "given", "Id", ".", "If", "the", "element", "does", "not", "exists", "then", "initialize", "an", "empty", "cache", "storage", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L15448-L15452", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/charset.js", "func_name": "specify", "original_string": "function specify(charset, spec, index) {\n  var s = 0;\n  if(spec.charset.toLowerCase() === charset.toLowerCase()){\n    s |= 1;\n  } else if (spec.charset !== '*' ) {\n    return null\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s\n  }\n}", "language": "javascript", "code": "function specify(charset, spec, index) {\n  var s = 0;\n  if(spec.charset.toLowerCase() === charset.toLowerCase()){\n    s |= 1;\n  } else if (spec.charset !== '*' ) {\n    return null\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s\n  }\n}", "code_tokens": ["function", "specify", "(", "charset", ",", "spec", ",", "index", ")", "{", "var", "s", "=", "0", ";", "if", "(", "spec", ".", "charset", ".", "toLowerCase", "(", ")", "===", "charset", ".", "toLowerCase", "(", ")", ")", "{", "s", "|=", "1", ";", "}", "else", "if", "(", "spec", ".", "charset", "!==", "'*'", ")", "{", "return", "null", "}", "return", "{", "i", ":", "index", ",", "o", ":", "spec", ".", "i", ",", "q", ":", "spec", ".", "q", ",", "s", ":", "s", "}", "}"], "docstring": "Get the specificity of the charset.\n@private", "docstring_tokens": ["Get", "the", "specificity", "of", "the", "charset", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/charset.js#L101-L115", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function() {\n      this.regionManager = this.getRegionManager();\n      this.regionManager._parent = this;\n  \n      this.listenTo(this.regionManager, 'before:add:region', function(name) {\n        this.triggerMethod('before:add:region', name);\n      });\n  \n      this.listenTo(this.regionManager, 'add:region', function(name, region) {\n        this[name] = region;\n        this.triggerMethod('add:region', name, region);\n      });\n  \n      this.listenTo(this.regionManager, 'before:remove:region', function(name) {\n        this.triggerMethod('before:remove:region', name);\n      });\n  \n      this.listenTo(this.regionManager, 'remove:region', function(name, region) {\n        delete this[name];\n        this.triggerMethod('remove:region', name, region);\n      });\n    }", "language": "javascript", "code": "function() {\n      this.regionManager = this.getRegionManager();\n      this.regionManager._parent = this;\n  \n      this.listenTo(this.regionManager, 'before:add:region', function(name) {\n        this.triggerMethod('before:add:region', name);\n      });\n  \n      this.listenTo(this.regionManager, 'add:region', function(name, region) {\n        this[name] = region;\n        this.triggerMethod('add:region', name, region);\n      });\n  \n      this.listenTo(this.regionManager, 'before:remove:region', function(name) {\n        this.triggerMethod('before:remove:region', name);\n      });\n  \n      this.listenTo(this.regionManager, 'remove:region', function(name, region) {\n        delete this[name];\n        this.triggerMethod('remove:region', name, region);\n      });\n    }", "code_tokens": ["function", "(", ")", "{", "this", ".", "regionManager", "=", "this", ".", "getRegionManager", "(", ")", ";", "this", ".", "regionManager", ".", "_parent", "=", "this", ";", "this", ".", "listenTo", "(", "this", ".", "regionManager", ",", "'before:add:region'", ",", "function", "(", "name", ")", "{", "this", ".", "triggerMethod", "(", "'before:add:region'", ",", "name", ")", ";", "}", ")", ";", "this", ".", "listenTo", "(", "this", ".", "regionManager", ",", "'add:region'", ",", "function", "(", "name", ",", "region", ")", "{", "this", "[", "name", "]", "=", "region", ";", "this", ".", "triggerMethod", "(", "'add:region'", ",", "name", ",", "region", ")", ";", "}", ")", ";", "this", ".", "listenTo", "(", "this", ".", "regionManager", ",", "'before:remove:region'", ",", "function", "(", "name", ")", "{", "this", ".", "triggerMethod", "(", "'before:remove:region'", ",", "name", ")", ";", "}", ")", ";", "this", ".", "listenTo", "(", "this", ".", "regionManager", ",", "'remove:region'", ",", "function", "(", "name", ",", "region", ")", "{", "delete", "this", "[", "name", "]", ";", "this", ".", "triggerMethod", "(", "'remove:region'", ",", "name", ",", "region", ")", ";", "}", ")", ";", "}"], "docstring": "Internal method to initialize the region manager and all regions in it", "docstring_tokens": ["Internal", "method", "to", "initialize", "the", "region", "manager", "and", "all", "regions", "in", "it"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19289-L19310", "partition": "test"}
{"repo": "wrote/read-dir-structure", "path": "build/index.js", "func_name": "lstatFiles", "original_string": "async function lstatFiles(dirPath, dirContent) {\n  const readFiles = dirContent.map(async (relativePath) => {\n    const path = join(dirPath, relativePath)\n    const ls = await makePromise(lstat, path)\n    return {\n      lstat: ls,\n      path,\n      relativePath,\n    }\n  })\n  const res = await Promise.all(readFiles)\n  return res\n}", "language": "javascript", "code": "async function lstatFiles(dirPath, dirContent) {\n  const readFiles = dirContent.map(async (relativePath) => {\n    const path = join(dirPath, relativePath)\n    const ls = await makePromise(lstat, path)\n    return {\n      lstat: ls,\n      path,\n      relativePath,\n    }\n  })\n  const res = await Promise.all(readFiles)\n  return res\n}", "code_tokens": ["async", "function", "lstatFiles", "(", "dirPath", ",", "dirContent", ")", "{", "const", "readFiles", "=", "dirContent", ".", "map", "(", "async", "(", "relativePath", ")", "=>", "{", "const", "path", "=", "join", "(", "dirPath", ",", "relativePath", ")", "const", "ls", "=", "await", "makePromise", "(", "lstat", ",", "path", ")", "return", "{", "lstat", ":", "ls", ",", "path", ",", "relativePath", ",", "}", "}", ")", "const", "res", "=", "await", "Promise", ".", "all", "(", "readFiles", ")", "return", "res", "}"], "docstring": "Update information about directory's content with lstat.\n@param {string} dirPath Path to the root directory\n@param {!Array<string>} dirContent\n@returns {Promise<Array<_readDirStructure.File>>} An array with file objects.", "docstring_tokens": ["Update", "information", "about", "directory", "s", "content", "with", "lstat", "."], "sha": "b3fcd367d122ad96c8123f5cf2783ac164205c2a", "url": "https://github.com/wrote/read-dir-structure/blob/b3fcd367d122ad96c8123f5cf2783ac164205c2a/build/index.js#L11-L23", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(type) {\n    type = this.modelFor(type);\n\n    var typeMap = this.typeMapFor(type),\n        findAllCache = typeMap.findAllCache;\n\n    if (findAllCache) { return findAllCache; }\n\n    var array = this.recordArrayManager.createRecordArray(type);\n\n    typeMap.findAllCache = array;\n    return array;\n  }", "language": "javascript", "code": "function(type) {\n    type = this.modelFor(type);\n\n    var typeMap = this.typeMapFor(type),\n        findAllCache = typeMap.findAllCache;\n\n    if (findAllCache) { return findAllCache; }\n\n    var array = this.recordArrayManager.createRecordArray(type);\n\n    typeMap.findAllCache = array;\n    return array;\n  }", "code_tokens": ["function", "(", "type", ")", "{", "type", "=", "this", ".", "modelFor", "(", "type", ")", ";", "var", "typeMap", "=", "this", ".", "typeMapFor", "(", "type", ")", ",", "findAllCache", "=", "typeMap", ".", "findAllCache", ";", "if", "(", "findAllCache", ")", "{", "return", "findAllCache", ";", "}", "var", "array", "=", "this", ".", "recordArrayManager", ".", "createRecordArray", "(", "type", ")", ";", "typeMap", ".", "findAllCache", "=", "array", ";", "return", "array", ";", "}"], "docstring": "This method returns a filtered array that contains all of the known records\nfor a given type.\n\nNote that because it's just a filter, it will have any locally\ncreated records of the type.\n\nAlso note that multiple calls to `all` for a given type will always\nreturn the same RecordArray.\n\nExample\n\n```javascript\nvar local_posts = store.all(App.Post);\n```\n\n@method all\n@param {String or subclass of DS.Model} type\n@return {DS.RecordArray}", "docstring_tokens": ["This", "method", "returns", "a", "filtered", "array", "that", "contains", "all", "of", "the", "known", "records", "for", "a", "given", "type", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L2634-L2646", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/core/utils/Extra.js", "func_name": "", "original_string": "function(prop, desc, type) {\n\t\tvar defaults = {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t\t, fn\n\t\t, camelType\n\t\t, self = this\n\t\t;\n\n\t\ttype = type.toLowerCase();\n\t\tcamelType = type.replace(/^[gs]/, function($1) { return $1.toUpperCase(); });\n\n\t\t// define function object for fallback\n\t\tif (o.typeOf(desc) === 'function') {\n\t\t\tfn = desc;\n\t\t\tdesc = {};\n\t\t\tdesc[type] = fn;\n\t\t} else if (o.typeOf(desc[type]) === 'function') {\n\t\t\tfn = desc[type];\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tif (Env.can('define_property')) {\n\t\t\tif (Object.defineProperty) {\n\t\t\t\treturn Object.defineProperty(this, prop, o.extend({}, defaults, desc));\n\t\t\t} else {\n\t\t\t\treturn self['__define' + camelType + 'ter__'](prop, fn);\n\t\t\t}\n\t\t}\n\t}", "language": "javascript", "code": "function(prop, desc, type) {\n\t\tvar defaults = {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t\t, fn\n\t\t, camelType\n\t\t, self = this\n\t\t;\n\n\t\ttype = type.toLowerCase();\n\t\tcamelType = type.replace(/^[gs]/, function($1) { return $1.toUpperCase(); });\n\n\t\t// define function object for fallback\n\t\tif (o.typeOf(desc) === 'function') {\n\t\t\tfn = desc;\n\t\t\tdesc = {};\n\t\t\tdesc[type] = fn;\n\t\t} else if (o.typeOf(desc[type]) === 'function') {\n\t\t\tfn = desc[type];\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tif (Env.can('define_property')) {\n\t\t\tif (Object.defineProperty) {\n\t\t\t\treturn Object.defineProperty(this, prop, o.extend({}, defaults, desc));\n\t\t\t} else {\n\t\t\t\treturn self['__define' + camelType + 'ter__'](prop, fn);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["function", "(", "prop", ",", "desc", ",", "type", ")", "{", "var", "defaults", "=", "{", "enumerable", ":", "true", ",", "configurable", ":", "true", "}", ",", "fn", ",", "camelType", ",", "self", "=", "this", ";", "type", "=", "type", ".", "toLowerCase", "(", ")", ";", "camelType", "=", "type", ".", "replace", "(", "/", "^[gs]", "/", ",", "function", "(", "$1", ")", "{", "return", "$1", ".", "toUpperCase", "(", ")", ";", "}", ")", ";", "// define function object for fallback", "if", "(", "o", ".", "typeOf", "(", "desc", ")", "===", "'function'", ")", "{", "fn", "=", "desc", ";", "desc", "=", "{", "}", ";", "desc", "[", "type", "]", "=", "fn", ";", "}", "else", "if", "(", "o", ".", "typeOf", "(", "desc", "[", "type", "]", ")", "===", "'function'", ")", "{", "fn", "=", "desc", "[", "type", "]", ";", "}", "else", "{", "return", ";", "}", "if", "(", "Env", ".", "can", "(", "'define_property'", ")", ")", "{", "if", "(", "Object", ".", "defineProperty", ")", "{", "return", "Object", ".", "defineProperty", "(", "this", ",", "prop", ",", "o", ".", "extend", "(", "{", "}", ",", "defaults", ",", "desc", ")", ")", ";", "}", "else", "{", "return", "self", "[", "'__define'", "+", "camelType", "+", "'ter__'", "]", "(", "prop", ",", "fn", ")", ";", "}", "}", "}"], "docstring": "Defines getter or setter, depending on a type param\n\n@method defineGSetter\n@static\n@private\n@param {String} prop Property name\n@param {Object} desc Set of key-value pairs defining descriptor for the property\n@param {String} type Can take value of 'set' or 'get'", "docstring_tokens": ["Defines", "getter", "or", "setter", "depending", "on", "a", "type", "param"], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Extra.js#L78-L109", "partition": "test"}
{"repo": "hszy00232/postcss-inline-block", "path": "index.js", "func_name": "inlineBlockFix", "original_string": "function inlineBlockFix(decl){\n    \tvar origRule = decl.parent;\n    \torigRule.append(\n\t    \t{\n\t    \t\tprop:'*display',\n\t    \t\tvalue:'inline'\n\t    \t},\n\t    \t{\n\t    \t\tprop:'*zoom',\n\t    \t\tvalue:'1'\n\t    \t}\n    \t);\n    }", "language": "javascript", "code": "function inlineBlockFix(decl){\n    \tvar origRule = decl.parent;\n    \torigRule.append(\n\t    \t{\n\t    \t\tprop:'*display',\n\t    \t\tvalue:'inline'\n\t    \t},\n\t    \t{\n\t    \t\tprop:'*zoom',\n\t    \t\tvalue:'1'\n\t    \t}\n    \t);\n    }", "code_tokens": ["function", "inlineBlockFix", "(", "decl", ")", "{", "var", "origRule", "=", "decl", ".", "parent", ";", "origRule", ".", "append", "(", "{", "prop", ":", "'*display'", ",", "value", ":", "'inline'", "}", ",", "{", "prop", ":", "'*zoom'", ",", "value", ":", "'1'", "}", ")", ";", "}"], "docstring": "Work with options here", "docstring_tokens": ["Work", "with", "options", "here"], "sha": "a27f67b773bc9510d1802acc5822e8408fa40c59", "url": "https://github.com/hszy00232/postcss-inline-block/blob/a27f67b773bc9510d1802acc5822e8408fa40c59/index.js#L6-L18", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function() {\n    set(this, 'isReloading', true);\n\n    var  record = this;\n\n    var promiseLabel = \"DS: Model#reload of \" + this;\n    var promise = new Ember.RSVP.Promise(function(resolve){\n       record.send('reloadRecord', resolve);\n    }, promiseLabel).then(function() {\n      record.set('isReloading', false);\n      record.set('isError', false);\n      return record;\n    }, function(reason) {\n      record.set('isError', true);\n      throw reason;\n    }, \"DS: Model#reload complete, update flags\");\n\n    return DS.PromiseObject.create({ promise: promise });\n  }", "language": "javascript", "code": "function() {\n    set(this, 'isReloading', true);\n\n    var  record = this;\n\n    var promiseLabel = \"DS: Model#reload of \" + this;\n    var promise = new Ember.RSVP.Promise(function(resolve){\n       record.send('reloadRecord', resolve);\n    }, promiseLabel).then(function() {\n      record.set('isReloading', false);\n      record.set('isError', false);\n      return record;\n    }, function(reason) {\n      record.set('isError', true);\n      throw reason;\n    }, \"DS: Model#reload complete, update flags\");\n\n    return DS.PromiseObject.create({ promise: promise });\n  }", "code_tokens": ["function", "(", ")", "{", "set", "(", "this", ",", "'isReloading'", ",", "true", ")", ";", "var", "record", "=", "this", ";", "var", "promiseLabel", "=", "\"DS: Model#reload of \"", "+", "this", ";", "var", "promise", "=", "new", "Ember", ".", "RSVP", ".", "Promise", "(", "function", "(", "resolve", ")", "{", "record", ".", "send", "(", "'reloadRecord'", ",", "resolve", ")", ";", "}", ",", "promiseLabel", ")", ".", "then", "(", "function", "(", ")", "{", "record", ".", "set", "(", "'isReloading'", ",", "false", ")", ";", "record", ".", "set", "(", "'isError'", ",", "false", ")", ";", "return", "record", ";", "}", ",", "function", "(", "reason", ")", "{", "record", ".", "set", "(", "'isError'", ",", "true", ")", ";", "throw", "reason", ";", "}", ",", "\"DS: Model#reload complete, update flags\"", ")", ";", "return", "DS", ".", "PromiseObject", ".", "create", "(", "{", "promise", ":", "promise", "}", ")", ";", "}"], "docstring": "Reload the record from the adapter.\n\nThis will only work if the record has already finished loading\nand has not yet been modified (`isLoaded` but not `isDirty`,\nor `isSaving`).\n\nExample\n\n```javascript\nApp.ModelViewRoute = Ember.Route.extend({\nactions: {\nreload: function() {\nthis.get('model').reload();\n}\n}\n});\n```\n\n@method reload\n@return {Promise} a promise that will be resolved with the record when the\nadapter returns successfully or rejected if the adapter returns\nwith an error.", "docstring_tokens": ["Reload", "the", "record", "from", "the", "adapter", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L5404-L5422", "partition": "test"}
{"repo": "azproduction/lmd", "path": "stats_server/views/statics/vendors/3d/d3.js", "func_name": "d3_behavior_zoomDelta", "original_string": "function d3_behavior_zoomDelta() {\n\n  // mousewheel events are totally broken!\n  // https://bugs.webkit.org/show_bug.cgi?id=40441\n  // not only that, but Chrome and Safari differ in re. to acceleration!\n  if (!d3_behavior_zoomDiv) {\n    d3_behavior_zoomDiv = d3.select(\"body\").append(\"div\")\n        .style(\"visibility\", \"hidden\")\n        .style(\"top\", 0)\n        .style(\"height\", 0)\n        .style(\"width\", 0)\n        .style(\"overflow-y\", \"scroll\")\n      .append(\"div\")\n        .style(\"height\", \"2000px\")\n      .node().parentNode;\n  }\n\n  var e = d3.event, delta;\n  try {\n    d3_behavior_zoomDiv.scrollTop = 1000;\n    d3_behavior_zoomDiv.dispatchEvent(e);\n    delta = 1000 - d3_behavior_zoomDiv.scrollTop;\n  } catch (error) {\n    delta = e.wheelDelta || (-e.detail * 5);\n  }\n\n  return delta * .005;\n}", "language": "javascript", "code": "function d3_behavior_zoomDelta() {\n\n  // mousewheel events are totally broken!\n  // https://bugs.webkit.org/show_bug.cgi?id=40441\n  // not only that, but Chrome and Safari differ in re. to acceleration!\n  if (!d3_behavior_zoomDiv) {\n    d3_behavior_zoomDiv = d3.select(\"body\").append(\"div\")\n        .style(\"visibility\", \"hidden\")\n        .style(\"top\", 0)\n        .style(\"height\", 0)\n        .style(\"width\", 0)\n        .style(\"overflow-y\", \"scroll\")\n      .append(\"div\")\n        .style(\"height\", \"2000px\")\n      .node().parentNode;\n  }\n\n  var e = d3.event, delta;\n  try {\n    d3_behavior_zoomDiv.scrollTop = 1000;\n    d3_behavior_zoomDiv.dispatchEvent(e);\n    delta = 1000 - d3_behavior_zoomDiv.scrollTop;\n  } catch (error) {\n    delta = e.wheelDelta || (-e.detail * 5);\n  }\n\n  return delta * .005;\n}", "code_tokens": ["function", "d3_behavior_zoomDelta", "(", ")", "{", "// mousewheel events are totally broken!", "// https://bugs.webkit.org/show_bug.cgi?id=40441", "// not only that, but Chrome and Safari differ in re. to acceleration!", "if", "(", "!", "d3_behavior_zoomDiv", ")", "{", "d3_behavior_zoomDiv", "=", "d3", ".", "select", "(", "\"body\"", ")", ".", "append", "(", "\"div\"", ")", ".", "style", "(", "\"visibility\"", ",", "\"hidden\"", ")", ".", "style", "(", "\"top\"", ",", "0", ")", ".", "style", "(", "\"height\"", ",", "0", ")", ".", "style", "(", "\"width\"", ",", "0", ")", ".", "style", "(", "\"overflow-y\"", ",", "\"scroll\"", ")", ".", "append", "(", "\"div\"", ")", ".", "style", "(", "\"height\"", ",", "\"2000px\"", ")", ".", "node", "(", ")", ".", "parentNode", ";", "}", "var", "e", "=", "d3", ".", "event", ",", "delta", ";", "try", "{", "d3_behavior_zoomDiv", ".", "scrollTop", "=", "1000", ";", "d3_behavior_zoomDiv", ".", "dispatchEvent", "(", "e", ")", ";", "delta", "=", "1000", "-", "d3_behavior_zoomDiv", ".", "scrollTop", ";", "}", "catch", "(", "error", ")", "{", "delta", "=", "e", ".", "wheelDelta", "||", "(", "-", "e", ".", "detail", "*", "5", ")", ";", "}", "return", "delta", "*", ".005", ";", "}"], "docstring": "detect the pixels that would be scrolled by this wheel event", "docstring_tokens": ["detect", "the", "pixels", "that", "would", "be", "scrolled", "by", "this", "wheel", "event"], "sha": "03410c36839728de683c697670e1b205dc8193ee", "url": "https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/stats_server/views/statics/vendors/3d/d3.js#L4499-L4526", "partition": "test"}
{"repo": "trendmicro-frontend/react-liquid-gauge", "path": "docs/bundle.js", "func_name": "mountClassInstance", "original_string": "function mountClassInstance(workInProgress, renderExpirationTime) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n\n    var props = workInProgress.pendingProps;\n    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n      workInProgress.internalContextTag |= AsyncUpdates;\n    }\n\n    if (typeof instance.componentWillMount === 'function') {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }", "language": "javascript", "code": "function mountClassInstance(workInProgress, renderExpirationTime) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n\n    var props = workInProgress.pendingProps;\n    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n      workInProgress.internalContextTag |= AsyncUpdates;\n    }\n\n    if (typeof instance.componentWillMount === 'function') {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }", "code_tokens": ["function", "mountClassInstance", "(", "workInProgress", ",", "renderExpirationTime", ")", "{", "var", "current", "=", "workInProgress", ".", "alternate", ";", "{", "checkClassInstance", "(", "workInProgress", ")", ";", "}", "var", "instance", "=", "workInProgress", ".", "stateNode", ";", "var", "state", "=", "instance", ".", "state", "||", "null", ";", "var", "props", "=", "workInProgress", ".", "pendingProps", ";", "!", "props", "?", "invariant", "(", "false", ",", "'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'", ")", ":", "void", "0", ";", "var", "unmaskedContext", "=", "getUnmaskedContext", "(", "workInProgress", ")", ";", "instance", ".", "props", "=", "props", ";", "instance", ".", "state", "=", "workInProgress", ".", "memoizedState", "=", "state", ";", "instance", ".", "refs", "=", "emptyObject", ";", "instance", ".", "context", "=", "getMaskedContext", "(", "workInProgress", ",", "unmaskedContext", ")", ";", "if", "(", "enableAsyncSubtreeAPI", "&&", "workInProgress", ".", "type", "!=", "null", "&&", "workInProgress", ".", "type", ".", "prototype", "!=", "null", "&&", "workInProgress", ".", "type", ".", "prototype", ".", "unstable_isAsyncReactComponent", "===", "true", ")", "{", "workInProgress", ".", "internalContextTag", "|=", "AsyncUpdates", ";", "}", "if", "(", "typeof", "instance", ".", "componentWillMount", "===", "'function'", ")", "{", "callComponentWillMount", "(", "workInProgress", ",", "instance", ")", ";", "// If we had additional state updates during this life-cycle, let's", "// process them now.", "var", "updateQueue", "=", "workInProgress", ".", "updateQueue", ";", "if", "(", "updateQueue", "!==", "null", ")", "{", "instance", ".", "state", "=", "processUpdateQueue", "(", "current", ",", "workInProgress", ",", "updateQueue", ",", "instance", ",", "props", ",", "renderExpirationTime", ")", ";", "}", "}", "if", "(", "typeof", "instance", ".", "componentDidMount", "===", "'function'", ")", "{", "workInProgress", ".", "effectTag", "|=", "Update", ";", "}", "}"], "docstring": "Invokes the mount life-cycles on a previously never rendered instance.", "docstring_tokens": ["Invokes", "the", "mount", "life", "-", "cycles", "on", "a", "previously", "never", "rendered", "instance", "."], "sha": "c8b24bd48a504539e25553a66097466f75917af6", "url": "https://github.com/trendmicro-frontend/react-liquid-gauge/blob/c8b24bd48a504539e25553a66097466f75917af6/docs/bundle.js#L22680-L22716", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/data/NodeStore.js", "func_name": "", "original_string": "function(node1, node2) {\n        // A shortcut for siblings\n        if (node1.parentNode === node2.parentNode) {\n            return (node1.data.index < node2.data.index) ? -1 : 1;\n        }\n\n        // @NOTE: with the following algorithm we can only go 80 levels deep in the tree\n        // and each node can contain 10000 direct children max\n        var weight1 = 0,\n            weight2 = 0,\n            parent1 = node1,\n            parent2 = node2;\n\n        while (parent1) {\n            weight1 += (Math.pow(10, (parent1.data.depth+1) * -4) * (parent1.data.index+1));\n            parent1 = parent1.parentNode;\n        }\n        while (parent2) {\n            weight2 += (Math.pow(10, (parent2.data.depth+1) * -4) * (parent2.data.index+1));\n            parent2 = parent2.parentNode;\n        }\n\n        if (weight1 > weight2) {\n            return 1;\n        } else if (weight1 < weight2) {\n            return -1;\n        }\n        return (node1.data.index > node2.data.index) ? 1 : -1;\n    }", "language": "javascript", "code": "function(node1, node2) {\n        // A shortcut for siblings\n        if (node1.parentNode === node2.parentNode) {\n            return (node1.data.index < node2.data.index) ? -1 : 1;\n        }\n\n        // @NOTE: with the following algorithm we can only go 80 levels deep in the tree\n        // and each node can contain 10000 direct children max\n        var weight1 = 0,\n            weight2 = 0,\n            parent1 = node1,\n            parent2 = node2;\n\n        while (parent1) {\n            weight1 += (Math.pow(10, (parent1.data.depth+1) * -4) * (parent1.data.index+1));\n            parent1 = parent1.parentNode;\n        }\n        while (parent2) {\n            weight2 += (Math.pow(10, (parent2.data.depth+1) * -4) * (parent2.data.index+1));\n            parent2 = parent2.parentNode;\n        }\n\n        if (weight1 > weight2) {\n            return 1;\n        } else if (weight1 < weight2) {\n            return -1;\n        }\n        return (node1.data.index > node2.data.index) ? 1 : -1;\n    }", "code_tokens": ["function", "(", "node1", ",", "node2", ")", "{", "// A shortcut for siblings", "if", "(", "node1", ".", "parentNode", "===", "node2", ".", "parentNode", ")", "{", "return", "(", "node1", ".", "data", ".", "index", "<", "node2", ".", "data", ".", "index", ")", "?", "-", "1", ":", "1", ";", "}", "// @NOTE: with the following algorithm we can only go 80 levels deep in the tree", "// and each node can contain 10000 direct children max", "var", "weight1", "=", "0", ",", "weight2", "=", "0", ",", "parent1", "=", "node1", ",", "parent2", "=", "node2", ";", "while", "(", "parent1", ")", "{", "weight1", "+=", "(", "Math", ".", "pow", "(", "10", ",", "(", "parent1", ".", "data", ".", "depth", "+", "1", ")", "*", "-", "4", ")", "*", "(", "parent1", ".", "data", ".", "index", "+", "1", ")", ")", ";", "parent1", "=", "parent1", ".", "parentNode", ";", "}", "while", "(", "parent2", ")", "{", "weight2", "+=", "(", "Math", ".", "pow", "(", "10", ",", "(", "parent2", ".", "data", ".", "depth", "+", "1", ")", "*", "-", "4", ")", "*", "(", "parent2", ".", "data", ".", "index", "+", "1", ")", ")", ";", "parent2", "=", "parent2", ".", "parentNode", ";", "}", "if", "(", "weight1", ">", "weight2", ")", "{", "return", "1", ";", "}", "else", "if", "(", "weight1", "<", "weight2", ")", "{", "return", "-", "1", ";", "}", "return", "(", "node1", ".", "data", ".", "index", ">", "node2", ".", "data", ".", "index", ")", "?", "1", ":", "-", "1", ";", "}"], "docstring": "This is a custom tree sorting algorithm. It uses the index property on each node to determine\nhow to sort siblings. It uses the depth property plus the index to create a weight for each node.\nThis weight algorithm has the limitation of not being able to go more then 80 levels in depth, or\nmore then 10k nodes per parent. The end result is a flat collection being correctly sorted based\non this one single sort function.\n@param {Ext.data.NodeInterface} node1\n@param {Ext.data.NodeInterface} node2\n@return {Number}\n@private", "docstring_tokens": ["This", "is", "a", "custom", "tree", "sorting", "algorithm", ".", "It", "uses", "the", "index", "property", "on", "each", "node", "to", "determine", "how", "to", "sort", "siblings", ".", "It", "uses", "the", "depth", "property", "plus", "the", "index", "to", "create", "a", "weight", "for", "each", "node", ".", "This", "weight", "algorithm", "has", "the", "limitation", "of", "not", "being", "able", "to", "go", "more", "then", "80", "levels", "in", "depth", "or", "more", "then", "10k", "nodes", "per", "parent", ".", "The", "end", "result", "is", "a", "flat", "collection", "being", "correctly", "sorted", "based", "on", "this", "one", "single", "sort", "function", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeStore.js#L116-L144", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/metadata/schema-parser.js", "func_name": "SchemaParserV1", "original_string": "function SchemaParserV1(options, cc) {\n  SchemaParser.call(this, options, cc);\n  this.selectTable = _selectTableV1;\n  this.selectColumns = _selectColumnsV1;\n  this.selectUdt = _selectUdtV1;\n  this.selectAggregates = _selectAggregatesV1;\n  this.selectFunctions = _selectFunctionsV1;\n}", "language": "javascript", "code": "function SchemaParserV1(options, cc) {\n  SchemaParser.call(this, options, cc);\n  this.selectTable = _selectTableV1;\n  this.selectColumns = _selectColumnsV1;\n  this.selectUdt = _selectUdtV1;\n  this.selectAggregates = _selectAggregatesV1;\n  this.selectFunctions = _selectFunctionsV1;\n}", "code_tokens": ["function", "SchemaParserV1", "(", "options", ",", "cc", ")", "{", "SchemaParser", ".", "call", "(", "this", ",", "options", ",", "cc", ")", ";", "this", ".", "selectTable", "=", "_selectTableV1", ";", "this", ".", "selectColumns", "=", "_selectColumnsV1", ";", "this", ".", "selectUdt", "=", "_selectUdtV1", ";", "this", ".", "selectAggregates", "=", "_selectAggregatesV1", ";", "this", ".", "selectFunctions", "=", "_selectFunctionsV1", ";", "}"], "docstring": "Used to parse schema information for Cassandra versions 1.2.x, and 2.x\n@param {ClientOptions} options The client options\n@param {ControlConnection} cc\n@constructor\n@ignore", "docstring_tokens": ["Used", "to", "parse", "schema", "information", "for", "Cassandra", "versions", "1", ".", "2", ".", "x", "and", "2", ".", "x"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/metadata/schema-parser.js#L403-L410", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(name) {\n    var args = [], i, l;\n    for (i = 1, l = arguments.length; i < l; i++) {\n      args.push(arguments[i]);\n    }\n    Ember.sendEvent(this, name, args);\n  }", "language": "javascript", "code": "function(name) {\n    var args = [], i, l;\n    for (i = 1, l = arguments.length; i < l; i++) {\n      args.push(arguments[i]);\n    }\n    Ember.sendEvent(this, name, args);\n  }", "code_tokens": ["function", "(", "name", ")", "{", "var", "args", "=", "[", "]", ",", "i", ",", "l", ";", "for", "(", "i", "=", "1", ",", "l", "=", "arguments", ".", "length", ";", "i", "<", "l", ";", "i", "++", ")", "{", "args", ".", "push", "(", "arguments", "[", "i", "]", ")", ";", "}", "Ember", ".", "sendEvent", "(", "this", ",", "name", ",", "args", ")", ";", "}"], "docstring": "Triggers a named event for the object. Any additional arguments\nwill be passed as parameters to the functions that are subscribed to the\nevent.\n\n```javascript\nperson.on('didEat', function(food) {\nconsole.log('person ate some ' + food);\n});\n\nperson.trigger('didEat', 'broccoli');\n\noutputs: person ate some broccoli\n```\n@method trigger\n@param {String} name The name of the event\n@param {Object...} args Optional arguments to pass on", "docstring_tokens": ["Triggers", "a", "named", "event", "for", "the", "object", ".", "Any", "additional", "arguments", "will", "be", "passed", "as", "parameters", "to", "the", "functions", "that", "are", "subscribed", "to", "the", "event", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L18312-L18318", "partition": "test"}
{"repo": "indrasantosa/node-s3-public-url", "path": "index.js", "func_name": "publicS3URI", "original_string": "function publicS3URI(string) {\n\treturn encodeURIComponent(string)\n\t\t.replace(/%20/img, '+')\n\t\t.replace(/%2F/img, '/')\n    .replace(/\\\"/img, \"%22\")\n    .replace(/\\#/img, \"%23\")\n    .replace(/\\$/img, \"%24\")\n    .replace(/\\&/img, \"%26\")\n    .replace(/\\'/img, \"%27\")\n\t\t.replace(/\\(/img, \"%28\")\n    .replace(/\\)/img, \"%29\")\n    .replace(/\\,/img, \"%2C\")\n    .replace(/\\:/img, \"%3A\")\n    .replace(/\\;/img, \"%3B\")\n    .replace(/\\=/img, \"%3D\")\n    .replace(/\\?/img, \"%3F\")\n    .replace(/\\@/img, \"%40\");\n}", "language": "javascript", "code": "function publicS3URI(string) {\n\treturn encodeURIComponent(string)\n\t\t.replace(/%20/img, '+')\n\t\t.replace(/%2F/img, '/')\n    .replace(/\\\"/img, \"%22\")\n    .replace(/\\#/img, \"%23\")\n    .replace(/\\$/img, \"%24\")\n    .replace(/\\&/img, \"%26\")\n    .replace(/\\'/img, \"%27\")\n\t\t.replace(/\\(/img, \"%28\")\n    .replace(/\\)/img, \"%29\")\n    .replace(/\\,/img, \"%2C\")\n    .replace(/\\:/img, \"%3A\")\n    .replace(/\\;/img, \"%3B\")\n    .replace(/\\=/img, \"%3D\")\n    .replace(/\\?/img, \"%3F\")\n    .replace(/\\@/img, \"%40\");\n}", "code_tokens": ["function", "publicS3URI", "(", "string", ")", "{", "return", "encodeURIComponent", "(", "string", ")", ".", "replace", "(", "/", "%20", "/", "img", ",", "'+'", ")", ".", "replace", "(", "/", "%2F", "/", "img", ",", "'/'", ")", ".", "replace", "(", "/", "\\\"", "/", "img", ",", "\"%22\"", ")", ".", "replace", "(", "/", "\\#", "/", "img", ",", "\"%23\"", ")", ".", "replace", "(", "/", "\\$", "/", "img", ",", "\"%24\"", ")", ".", "replace", "(", "/", "\\&", "/", "img", ",", "\"%26\"", ")", ".", "replace", "(", "/", "\\'", "/", "img", ",", "\"%27\"", ")", ".", "replace", "(", "/", "\\(", "/", "img", ",", "\"%28\"", ")", ".", "replace", "(", "/", "\\)", "/", "img", ",", "\"%29\"", ")", ".", "replace", "(", "/", "\\,", "/", "img", ",", "\"%2C\"", ")", ".", "replace", "(", "/", "\\:", "/", "img", ",", "\"%3A\"", ")", ".", "replace", "(", "/", "\\;", "/", "img", ",", "\"%3B\"", ")", ".", "replace", "(", "/", "\\=", "/", "img", ",", "\"%3D\"", ")", ".", "replace", "(", "/", "\\?", "/", "img", ",", "\"%3F\"", ")", ".", "replace", "(", "/", "\\@", "/", "img", ",", "\"%40\"", ")", ";", "}"], "docstring": "node-s3-encode-url", "docstring_tokens": ["node", "-", "s3", "-", "encode", "-", "url"], "sha": "e42a09f3e35b79611a2ae9cbb5ecddc9de7804f0", "url": "https://github.com/indrasantosa/node-s3-public-url/blob/e42a09f3e35b79611a2ae9cbb5ecddc9de7804f0/index.js#L5-L22", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getSymbolOfPartOfRightHandSideOfImportEquals", "original_string": "function getSymbolOfPartOfRightHandSideOfImportEquals(entityName, importDeclaration) {\n            if (!importDeclaration) {\n                importDeclaration = ts.getAncestor(entityName, 221 /* ImportEqualsDeclaration */);\n                ts.Debug.assert(importDeclaration !== undefined);\n            }\n            // There are three things we might try to look for. In the following examples,\n            // the search term is enclosed in |...|:\n            //\n            //     import a = |b|; // Namespace\n            //     import a = |b.c|; // Value, type, namespace\n            //     import a = |b.c|.d; // Namespace\n            if (entityName.kind === 69 /* Identifier */ && ts.isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {\n                entityName = entityName.parent;\n            }\n            // Check for case 1 and 3 in the above example\n            if (entityName.kind === 69 /* Identifier */ || entityName.parent.kind === 135 /* QualifiedName */) {\n                return resolveEntityName(entityName, 1536 /* Namespace */);\n            }\n            else {\n                // Case 2 in above example\n                // entityName.kind could be a QualifiedName or a Missing identifier\n                ts.Debug.assert(entityName.parent.kind === 221 /* ImportEqualsDeclaration */);\n                return resolveEntityName(entityName, 107455 /* Value */ | 793056 /* Type */ | 1536 /* Namespace */);\n            }\n        }", "language": "javascript", "code": "function getSymbolOfPartOfRightHandSideOfImportEquals(entityName, importDeclaration) {\n            if (!importDeclaration) {\n                importDeclaration = ts.getAncestor(entityName, 221 /* ImportEqualsDeclaration */);\n                ts.Debug.assert(importDeclaration !== undefined);\n            }\n            // There are three things we might try to look for. In the following examples,\n            // the search term is enclosed in |...|:\n            //\n            //     import a = |b|; // Namespace\n            //     import a = |b.c|; // Value, type, namespace\n            //     import a = |b.c|.d; // Namespace\n            if (entityName.kind === 69 /* Identifier */ && ts.isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {\n                entityName = entityName.parent;\n            }\n            // Check for case 1 and 3 in the above example\n            if (entityName.kind === 69 /* Identifier */ || entityName.parent.kind === 135 /* QualifiedName */) {\n                return resolveEntityName(entityName, 1536 /* Namespace */);\n            }\n            else {\n                // Case 2 in above example\n                // entityName.kind could be a QualifiedName or a Missing identifier\n                ts.Debug.assert(entityName.parent.kind === 221 /* ImportEqualsDeclaration */);\n                return resolveEntityName(entityName, 107455 /* Value */ | 793056 /* Type */ | 1536 /* Namespace */);\n            }\n        }", "code_tokens": ["function", "getSymbolOfPartOfRightHandSideOfImportEquals", "(", "entityName", ",", "importDeclaration", ")", "{", "if", "(", "!", "importDeclaration", ")", "{", "importDeclaration", "=", "ts", ".", "getAncestor", "(", "entityName", ",", "221", "/* ImportEqualsDeclaration */", ")", ";", "ts", ".", "Debug", ".", "assert", "(", "importDeclaration", "!==", "undefined", ")", ";", "}", "// There are three things we might try to look for. In the following examples,", "// the search term is enclosed in |...|:", "//", "//     import a = |b|; // Namespace", "//     import a = |b.c|; // Value, type, namespace", "//     import a = |b.c|.d; // Namespace", "if", "(", "entityName", ".", "kind", "===", "69", "/* Identifier */", "&&", "ts", ".", "isRightSideOfQualifiedNameOrPropertyAccess", "(", "entityName", ")", ")", "{", "entityName", "=", "entityName", ".", "parent", ";", "}", "// Check for case 1 and 3 in the above example", "if", "(", "entityName", ".", "kind", "===", "69", "/* Identifier */", "||", "entityName", ".", "parent", ".", "kind", "===", "135", "/* QualifiedName */", ")", "{", "return", "resolveEntityName", "(", "entityName", ",", "1536", "/* Namespace */", ")", ";", "}", "else", "{", "// Case 2 in above example", "// entityName.kind could be a QualifiedName or a Missing identifier", "ts", ".", "Debug", ".", "assert", "(", "entityName", ".", "parent", ".", "kind", "===", "221", "/* ImportEqualsDeclaration */", ")", ";", "return", "resolveEntityName", "(", "entityName", ",", "107455", "/* Value */", "|", "793056", "/* Type */", "|", "1536", "/* Namespace */", ")", ";", "}", "}"], "docstring": "This function is only for imports with entity names", "docstring_tokens": ["This", "function", "is", "only", "for", "imports", "with", "entity", "names"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L14067-L14091", "partition": "test"}
{"repo": "duaraghav8/Ethlint", "path": "lib/utils/ast-utils.js", "func_name": "throwIfInvalidNode", "original_string": "function throwIfInvalidNode(node, functionName) {\n    if (!exports.isASTNode(node)) {\n        throw new Error(functionName + \"(): \" + util.inspect(node) + \" is not a valid AST node.\");\n    }\n}", "language": "javascript", "code": "function throwIfInvalidNode(node, functionName) {\n    if (!exports.isASTNode(node)) {\n        throw new Error(functionName + \"(): \" + util.inspect(node) + \" is not a valid AST node.\");\n    }\n}", "code_tokens": ["function", "throwIfInvalidNode", "(", "node", ",", "functionName", ")", "{", "if", "(", "!", "exports", ".", "isASTNode", "(", "node", ")", ")", "{", "throw", "new", "Error", "(", "functionName", "+", "\"(): \"", "+", "util", ".", "inspect", "(", "node", ")", "+", "\" is not a valid AST node.\"", ")", ";", "}", "}"], "docstring": "For internal use. Throws if is passed an invalid AST node, else does nothing.", "docstring_tokens": ["For", "internal", "use", ".", "Throws", "if", "is", "passed", "an", "invalid", "AST", "node", "else", "does", "nothing", "."], "sha": "7d264373709561148c7166601ac39370e78f74b1", "url": "https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/utils/ast-utils.js#L16-L20", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "removeListener", "original_string": "function removeListener(obj, eventName, target, method) {\n  Ember.assert(\"You must pass at least an object and event name to Ember.removeListener\", !!obj && !!eventName);\n\n  if (!method && 'function' === typeof target) {\n    method = target;\n    target = null;\n  }\n\n  function _removeListener(target, method) {\n    var actions = actionsFor(obj, eventName),\n        actionIndex = indexOf(actions, target, method);\n\n    // action doesn't exist, give up silently\n    if (actionIndex === -1) { return; }\n\n    actions.splice(actionIndex, 3);\n\n    if ('function' === typeof obj.didRemoveListener) {\n      obj.didRemoveListener(eventName, target, method);\n    }\n  }\n\n  if (method) {\n    _removeListener(target, method);\n  } else {\n    var meta = obj[META_KEY],\n        actions = meta && meta.listeners && meta.listeners[eventName];\n\n    if (!actions) { return; }\n    for (var i = actions.length - 3; i >= 0; i -= 3) {\n      _removeListener(actions[i], actions[i+1]);\n    }\n  }\n}", "language": "javascript", "code": "function removeListener(obj, eventName, target, method) {\n  Ember.assert(\"You must pass at least an object and event name to Ember.removeListener\", !!obj && !!eventName);\n\n  if (!method && 'function' === typeof target) {\n    method = target;\n    target = null;\n  }\n\n  function _removeListener(target, method) {\n    var actions = actionsFor(obj, eventName),\n        actionIndex = indexOf(actions, target, method);\n\n    // action doesn't exist, give up silently\n    if (actionIndex === -1) { return; }\n\n    actions.splice(actionIndex, 3);\n\n    if ('function' === typeof obj.didRemoveListener) {\n      obj.didRemoveListener(eventName, target, method);\n    }\n  }\n\n  if (method) {\n    _removeListener(target, method);\n  } else {\n    var meta = obj[META_KEY],\n        actions = meta && meta.listeners && meta.listeners[eventName];\n\n    if (!actions) { return; }\n    for (var i = actions.length - 3; i >= 0; i -= 3) {\n      _removeListener(actions[i], actions[i+1]);\n    }\n  }\n}", "code_tokens": ["function", "removeListener", "(", "obj", ",", "eventName", ",", "target", ",", "method", ")", "{", "Ember", ".", "assert", "(", "\"You must pass at least an object and event name to Ember.removeListener\"", ",", "!", "!", "obj", "&&", "!", "!", "eventName", ")", ";", "if", "(", "!", "method", "&&", "'function'", "===", "typeof", "target", ")", "{", "method", "=", "target", ";", "target", "=", "null", ";", "}", "function", "_removeListener", "(", "target", ",", "method", ")", "{", "var", "actions", "=", "actionsFor", "(", "obj", ",", "eventName", ")", ",", "actionIndex", "=", "indexOf", "(", "actions", ",", "target", ",", "method", ")", ";", "// action doesn't exist, give up silently", "if", "(", "actionIndex", "===", "-", "1", ")", "{", "return", ";", "}", "actions", ".", "splice", "(", "actionIndex", ",", "3", ")", ";", "if", "(", "'function'", "===", "typeof", "obj", ".", "didRemoveListener", ")", "{", "obj", ".", "didRemoveListener", "(", "eventName", ",", "target", ",", "method", ")", ";", "}", "}", "if", "(", "method", ")", "{", "_removeListener", "(", "target", ",", "method", ")", ";", "}", "else", "{", "var", "meta", "=", "obj", "[", "META_KEY", "]", ",", "actions", "=", "meta", "&&", "meta", ".", "listeners", "&&", "meta", ".", "listeners", "[", "eventName", "]", ";", "if", "(", "!", "actions", ")", "{", "return", ";", "}", "for", "(", "var", "i", "=", "actions", ".", "length", "-", "3", ";", "i", ">=", "0", ";", "i", "-=", "3", ")", "{", "_removeListener", "(", "actions", "[", "i", "]", ",", "actions", "[", "i", "+", "1", "]", ")", ";", "}", "}", "}"], "docstring": "Remove an event listener\n\nArguments should match those passed to `Ember.addListener`.\n\n@method removeListener\n@for Ember\n@param obj\n@param {String} eventName\n@param {Object|Function} targetOrMethod A target object or a function\n@param {Function|String} method A function or the name of a function to be called on `target`", "docstring_tokens": ["Remove", "an", "event", "listener"], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L2424-L2457", "partition": "test"}
{"repo": "IntrospectiveSystems/xGraph", "path": "lib/IDBCache.js", "func_name": "remDir", "original_string": "function remDir(path) {\n\t\t\treturn (new Promise(async (resolve, _reject) => {\n\t\t\t\tif (fs.existsSync(path)) {\n\t\t\t\t\tlet files = fs.readdirSync(path);\n\t\t\t\t\tlet promiseArray = [];\n\n\t\t\t\t\tfor (let fileIndex = 0; fileIndex < files.length; fileIndex++) {\n\t\t\t\t\t\tpromiseArray.push(new Promise(async (resolve2, _reject2) => {\n\t\t\t\t\t\t\tlet curPath = path + '/' + files[fileIndex];\n\t\t\t\t\t\t\tif (fs.lstatSync(curPath).isDirectory()) {\n\t\t\t\t\t\t\t\t// recurse\n\t\t\t\t\t\t\t\tawait remDir(curPath);\n\t\t\t\t\t\t\t\tresolve2();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// delete file\n\t\t\t\t\t\t\t\tlog.v('Removing Entity ', files[fileIndex].split('.')[0]);\n\t\t\t\t\t\t\t\tfs.unlinkSync(curPath);\n\t\t\t\t\t\t\t\tresolve2();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\t//make sure all the sub files and directories have been removed;\n\t\t\t\t\tawait Promise.all(promiseArray);\n\t\t\t\t\tlog.v('Removing Module Directory ', path);\n\t\t\t\t\tfs.rmdirSync(path);\n\t\t\t\t\tresolve();\n\t\t\t\t} else {\n\t\t\t\t\tlog.v('trying to remove nonexistant path ', path);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}));\n\t\t}", "language": "javascript", "code": "function remDir(path) {\n\t\t\treturn (new Promise(async (resolve, _reject) => {\n\t\t\t\tif (fs.existsSync(path)) {\n\t\t\t\t\tlet files = fs.readdirSync(path);\n\t\t\t\t\tlet promiseArray = [];\n\n\t\t\t\t\tfor (let fileIndex = 0; fileIndex < files.length; fileIndex++) {\n\t\t\t\t\t\tpromiseArray.push(new Promise(async (resolve2, _reject2) => {\n\t\t\t\t\t\t\tlet curPath = path + '/' + files[fileIndex];\n\t\t\t\t\t\t\tif (fs.lstatSync(curPath).isDirectory()) {\n\t\t\t\t\t\t\t\t// recurse\n\t\t\t\t\t\t\t\tawait remDir(curPath);\n\t\t\t\t\t\t\t\tresolve2();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// delete file\n\t\t\t\t\t\t\t\tlog.v('Removing Entity ', files[fileIndex].split('.')[0]);\n\t\t\t\t\t\t\t\tfs.unlinkSync(curPath);\n\t\t\t\t\t\t\t\tresolve2();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\t//make sure all the sub files and directories have been removed;\n\t\t\t\t\tawait Promise.all(promiseArray);\n\t\t\t\t\tlog.v('Removing Module Directory ', path);\n\t\t\t\t\tfs.rmdirSync(path);\n\t\t\t\t\tresolve();\n\t\t\t\t} else {\n\t\t\t\t\tlog.v('trying to remove nonexistant path ', path);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}));\n\t\t}", "code_tokens": ["function", "remDir", "(", "path", ")", "{", "return", "(", "new", "Promise", "(", "async", "(", "resolve", ",", "_reject", ")", "=>", "{", "if", "(", "fs", ".", "existsSync", "(", "path", ")", ")", "{", "let", "files", "=", "fs", ".", "readdirSync", "(", "path", ")", ";", "let", "promiseArray", "=", "[", "]", ";", "for", "(", "let", "fileIndex", "=", "0", ";", "fileIndex", "<", "files", ".", "length", ";", "fileIndex", "++", ")", "{", "promiseArray", ".", "push", "(", "new", "Promise", "(", "async", "(", "resolve2", ",", "_reject2", ")", "=>", "{", "let", "curPath", "=", "path", "+", "'/'", "+", "files", "[", "fileIndex", "]", ";", "if", "(", "fs", ".", "lstatSync", "(", "curPath", ")", ".", "isDirectory", "(", ")", ")", "{", "// recurse", "await", "remDir", "(", "curPath", ")", ";", "resolve2", "(", ")", ";", "}", "else", "{", "// delete file", "log", ".", "v", "(", "'Removing Entity '", ",", "files", "[", "fileIndex", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", ";", "fs", ".", "unlinkSync", "(", "curPath", ")", ";", "resolve2", "(", ")", ";", "}", "}", ")", ")", ";", "}", "//make sure all the sub files and directories have been removed;", "await", "Promise", ".", "all", "(", "promiseArray", ")", ";", "log", ".", "v", "(", "'Removing Module Directory '", ",", "path", ")", ";", "fs", ".", "rmdirSync", "(", "path", ")", ";", "resolve", "(", ")", ";", "}", "else", "{", "log", ".", "v", "(", "'trying to remove nonexistant path '", ",", "path", ")", ";", "resolve", "(", ")", ";", "}", "}", ")", ")", ";", "}"], "docstring": "Recursive directory deletion\n@param {string} path the directory to be recursively removed", "docstring_tokens": ["Recursive", "directory", "deletion"], "sha": "86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0", "url": "https://github.com/IntrospectiveSystems/xGraph/blob/86bc86f6cd7aab4c5259532ce28fb7f8ac5424e0/lib/IDBCache.js#L318-L349", "partition": "test"}
{"repo": "sendanor/nor-api", "path": "src/index.js", "func_name": "do_create_req", "original_string": "function do_create_req(config, routes) {\n\troutes = routes || {};\n\n\tvar version = routes.version || {};\n\tif(version && (typeof version === 'object')) {\n\t} else {\n\t\tversion = {'self':routes.version || config.pkg.version};\n\t}\n\t\n\tif(!version.api) {\n\t\tversion.api = api_config.pkg.version;\n\t}\n\t\n\troutes.version = version;\n\n\tvar router = new RequestRouter(routes);\n\tvar req_counter = 0;\n\n\t/* Inner Request handler */\n\tfunction do_req(req, res) {\n\t\treq_counter += 1;\n\t\treturn router.resolve( req, res );\n\t} // do_req\n\n\treturn do_req;\n}", "language": "javascript", "code": "function do_create_req(config, routes) {\n\troutes = routes || {};\n\n\tvar version = routes.version || {};\n\tif(version && (typeof version === 'object')) {\n\t} else {\n\t\tversion = {'self':routes.version || config.pkg.version};\n\t}\n\t\n\tif(!version.api) {\n\t\tversion.api = api_config.pkg.version;\n\t}\n\t\n\troutes.version = version;\n\n\tvar router = new RequestRouter(routes);\n\tvar req_counter = 0;\n\n\t/* Inner Request handler */\n\tfunction do_req(req, res) {\n\t\treq_counter += 1;\n\t\treturn router.resolve( req, res );\n\t} // do_req\n\n\treturn do_req;\n}", "code_tokens": ["function", "do_create_req", "(", "config", ",", "routes", ")", "{", "routes", "=", "routes", "||", "{", "}", ";", "var", "version", "=", "routes", ".", "version", "||", "{", "}", ";", "if", "(", "version", "&&", "(", "typeof", "version", "===", "'object'", ")", ")", "{", "}", "else", "{", "version", "=", "{", "'self'", ":", "routes", ".", "version", "||", "config", ".", "pkg", ".", "version", "}", ";", "}", "if", "(", "!", "version", ".", "api", ")", "{", "version", ".", "api", "=", "api_config", ".", "pkg", ".", "version", ";", "}", "routes", ".", "version", "=", "version", ";", "var", "router", "=", "new", "RequestRouter", "(", "routes", ")", ";", "var", "req_counter", "=", "0", ";", "/* Inner Request handler */", "function", "do_req", "(", "req", ",", "res", ")", "{", "req_counter", "+=", "1", ";", "return", "router", ".", "resolve", "(", "req", ",", "res", ")", ";", "}", "// do_req", "return", "do_req", ";", "}"], "docstring": "Builder for generic HTTP Request Handler", "docstring_tokens": ["Builder", "for", "generic", "HTTP", "Request", "Handler"], "sha": "50c88c6a606443e89f978a75057902a65d8312bd", "url": "https://github.com/sendanor/nor-api/blob/50c88c6a606443e89f978a75057902a65d8312bd/src/index.js#L37-L62", "partition": "test"}
{"repo": "bkrem/react-d3-tree", "path": "src/util/index.js", "func_name": "parseCSV", "original_string": "function parseCSV(csvFilePath, attributeFields) {\n  return new Promise((resolve, reject) => {\n    try {\n      csv(csvFilePath, data => resolve(_transformToHierarchy(data, attributeFields))); // lol hello Lisp\n    } catch (err) {\n      reject(err);\n    }\n  });\n}", "language": "javascript", "code": "function parseCSV(csvFilePath, attributeFields) {\n  return new Promise((resolve, reject) => {\n    try {\n      csv(csvFilePath, data => resolve(_transformToHierarchy(data, attributeFields))); // lol hello Lisp\n    } catch (err) {\n      reject(err);\n    }\n  });\n}", "code_tokens": ["function", "parseCSV", "(", "csvFilePath", ",", "attributeFields", ")", "{", "return", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "try", "{", "csv", "(", "csvFilePath", ",", "data", "=>", "resolve", "(", "_transformToHierarchy", "(", "data", ",", "attributeFields", ")", ")", ")", ";", "// lol hello Lisp", "}", "catch", "(", "err", ")", "{", "reject", "(", "err", ")", ";", "}", "}", ")", ";", "}"], "docstring": "parseCSV - Parses a CSV file into a hierarchy structure.\n\n@param {string} csvFilePath     Path to CSV file to be parsed.\n@param {array<string>|undefined} attributeFields Set of column names to be used as attributes (optional)\n\n@return {Promise} Returns hierarchy array if resolved, error object if rejected.", "docstring_tokens": ["parseCSV", "-", "Parses", "a", "CSV", "file", "into", "a", "hierarchy", "structure", "."], "sha": "9084afca0f35e73dd6b7e7433a09907decd9f308", "url": "https://github.com/bkrem/react-d3-tree/blob/9084afca0f35e73dd6b7e7433a09907decd9f308/src/util/index.js#L72-L80", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function() {\n    Ember.assert(\"You must call advanceReadiness on an instance of Ember.Application\", this instanceof Ember.Application);\n    this._readinessDeferrals--;\n\n    if (this._readinessDeferrals === 0) {\n      Ember.run.once(this, this.didBecomeReady);\n    }\n  }", "language": "javascript", "code": "function() {\n    Ember.assert(\"You must call advanceReadiness on an instance of Ember.Application\", this instanceof Ember.Application);\n    this._readinessDeferrals--;\n\n    if (this._readinessDeferrals === 0) {\n      Ember.run.once(this, this.didBecomeReady);\n    }\n  }", "code_tokens": ["function", "(", ")", "{", "Ember", ".", "assert", "(", "\"You must call advanceReadiness on an instance of Ember.Application\"", ",", "this", "instanceof", "Ember", ".", "Application", ")", ";", "this", ".", "_readinessDeferrals", "--", ";", "if", "(", "this", ".", "_readinessDeferrals", "===", "0", ")", "{", "Ember", ".", "run", ".", "once", "(", "this", ",", "this", ".", "didBecomeReady", ")", ";", "}", "}"], "docstring": "Call `advanceReadiness` after any asynchronous setup logic has completed.\nEach call to `deferReadiness` must be matched by a call to `advanceReadiness`\nor the application will never become ready and routing will not begin.\n\n@method advanceReadiness\n@see {Ember.Application#deferReadiness}", "docstring_tokens": ["Call", "advanceReadiness", "after", "any", "asynchronous", "setup", "logic", "has", "completed", ".", "Each", "call", "to", "deferReadiness", "must", "be", "matched", "by", "a", "call", "to", "advanceReadiness", "or", "the", "application", "will", "never", "become", "ready", "and", "routing", "will", "not", "begin", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L40945-L40952", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(addedAt) {\n      var viewComparator = this.getViewComparator();\n      var models = this.collection.models;\n      addedAt = Math.min(Math.max(addedAt, 0), models.length - 1);\n  \n      if (viewComparator) {\n        var addedModel;\n        // Preserve `at` location, even for a sorted view\n        if (addedAt) {\n          addedModel = models[addedAt];\n          models = models.slice(0, addedAt).concat(models.slice(addedAt + 1));\n        }\n        models = this._sortModelsBy(models, viewComparator);\n        if (addedModel) {\n          models.splice(addedAt, 0, addedModel);\n        }\n      }\n  \n      // Filter after sorting in case the filter uses the index\n      if (this.getOption('filter')) {\n        models = _.filter(models, function(model, index) {\n          return this._shouldAddChild(model, index);\n        }, this);\n      }\n  \n      return models;\n    }", "language": "javascript", "code": "function(addedAt) {\n      var viewComparator = this.getViewComparator();\n      var models = this.collection.models;\n      addedAt = Math.min(Math.max(addedAt, 0), models.length - 1);\n  \n      if (viewComparator) {\n        var addedModel;\n        // Preserve `at` location, even for a sorted view\n        if (addedAt) {\n          addedModel = models[addedAt];\n          models = models.slice(0, addedAt).concat(models.slice(addedAt + 1));\n        }\n        models = this._sortModelsBy(models, viewComparator);\n        if (addedModel) {\n          models.splice(addedAt, 0, addedModel);\n        }\n      }\n  \n      // Filter after sorting in case the filter uses the index\n      if (this.getOption('filter')) {\n        models = _.filter(models, function(model, index) {\n          return this._shouldAddChild(model, index);\n        }, this);\n      }\n  \n      return models;\n    }", "code_tokens": ["function", "(", "addedAt", ")", "{", "var", "viewComparator", "=", "this", ".", "getViewComparator", "(", ")", ";", "var", "models", "=", "this", ".", "collection", ".", "models", ";", "addedAt", "=", "Math", ".", "min", "(", "Math", ".", "max", "(", "addedAt", ",", "0", ")", ",", "models", ".", "length", "-", "1", ")", ";", "if", "(", "viewComparator", ")", "{", "var", "addedModel", ";", "// Preserve `at` location, even for a sorted view", "if", "(", "addedAt", ")", "{", "addedModel", "=", "models", "[", "addedAt", "]", ";", "models", "=", "models", ".", "slice", "(", "0", ",", "addedAt", ")", ".", "concat", "(", "models", ".", "slice", "(", "addedAt", "+", "1", ")", ")", ";", "}", "models", "=", "this", ".", "_sortModelsBy", "(", "models", ",", "viewComparator", ")", ";", "if", "(", "addedModel", ")", "{", "models", ".", "splice", "(", "addedAt", ",", "0", ",", "addedModel", ")", ";", "}", "}", "// Filter after sorting in case the filter uses the index", "if", "(", "this", ".", "getOption", "(", "'filter'", ")", ")", "{", "models", "=", "_", ".", "filter", "(", "models", ",", "function", "(", "model", ",", "index", ")", "{", "return", "this", ".", "_shouldAddChild", "(", "model", ",", "index", ")", ";", "}", ",", "this", ")", ";", "}", "return", "models", ";", "}"], "docstring": "Allow the collection to be sorted by a custom view comparator", "docstring_tokens": ["Allow", "the", "collection", "to", "be", "sorted", "by", "a", "custom", "view", "comparator"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18512-L18538", "partition": "test"}
{"repo": "ljharb/map-tojson", "path": "index.js", "func_name": "", "original_string": "function (map, receive) {\n\tvar entries = mapEntries.call(map);\n\tvar next;\n\tdo {\n\t\tnext = entries.next();\n\t} while (!next.done && receive(next.value));\n}", "language": "javascript", "code": "function (map, receive) {\n\tvar entries = mapEntries.call(map);\n\tvar next;\n\tdo {\n\t\tnext = entries.next();\n\t} while (!next.done && receive(next.value));\n}", "code_tokens": ["function", "(", "map", ",", "receive", ")", "{", "var", "entries", "=", "mapEntries", ".", "call", "(", "map", ")", ";", "var", "next", ";", "do", "{", "next", "=", "entries", ".", "next", "(", ")", ";", "}", "while", "(", "!", "next", ".", "done", "&&", "receive", "(", "next", ".", "value", ")", ")", ";", "}"], "docstring": "polyfilled Maps with es6-shim might exist without for..of", "docstring_tokens": ["polyfilled", "Maps", "with", "es6", "-", "shim", "might", "exist", "without", "for", "..", "of"], "sha": "3e907585b2a29061e7028d5f3a6236ba91eb776d", "url": "https://github.com/ljharb/map-tojson/blob/3e907585b2a29061e7028d5f3a6236ba91eb776d/index.js#L12-L18", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "_copyCacheEntry", "original_string": "function _copyCacheEntry ( cacheEntry ) {\n        var copy = _.clone( cacheEntry );\n        if ( _.isObject( copy.attributes ) ) copy.attributes = _.clone( copy.attributes );\n        return copy;\n    }", "language": "javascript", "code": "function _copyCacheEntry ( cacheEntry ) {\n        var copy = _.clone( cacheEntry );\n        if ( _.isObject( copy.attributes ) ) copy.attributes = _.clone( copy.attributes );\n        return copy;\n    }", "code_tokens": ["function", "_copyCacheEntry", "(", "cacheEntry", ")", "{", "var", "copy", "=", "_", ".", "clone", "(", "cacheEntry", ")", ";", "if", "(", "_", ".", "isObject", "(", "copy", ".", "attributes", ")", ")", "copy", ".", "attributes", "=", "_", ".", "clone", "(", "copy", ".", "attributes", ")", ";", "return", "copy", ";", "}"], "docstring": "Creates a copy of a cache entry and returns it. Protects the original cache entry from modification, except for\nthe _pluginData property, which remains writable and can be accessed from the copy.\n\nNB The `attribute` property is cloned and protected, too, if it exists.\n\n@param   {CachedTemplateData} cacheEntry\n@returns {CachedTemplateData}", "docstring_tokens": ["Creates", "a", "copy", "of", "a", "cache", "entry", "and", "returns", "it", ".", "Protects", "the", "original", "cache", "entry", "from", "modification", "except", "for", "the", "_pluginData", "property", "which", "remains", "writable", "and", "can", "be", "accessed", "from", "the", "copy", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L15507-L15511", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "bindChildren", "original_string": "function bindChildren(node) {\n            // Before we recurse into a node's chilren, we first save the existing parent, container\n            // and block-container.  Then after we pop out of processing the children, we restore\n            // these saved values.\n            var saveParent = parent;\n            var saveContainer = container;\n            var savedBlockScopeContainer = blockScopeContainer;\n            // This node will now be set as the parent of all of its children as we recurse into them.\n            parent = node;\n            // Depending on what kind of node this is, we may have to adjust the current container\n            // and block-container.   If the current node is a container, then it is automatically\n            // considered the current block-container as well.  Also, for containers that we know\n            // may contain locals, we proactively initialize the .locals field. We do this because\n            // it's highly likely that the .locals will be needed to place some child in (for example,\n            // a parameter, or variable declaration).\n            //\n            // However, we do not proactively create the .locals for block-containers because it's\n            // totally normal and common for block-containers to never actually have a block-scoped\n            // variable in them.  We don't want to end up allocating an object for every 'block' we\n            // run into when most of them won't be necessary.\n            //\n            // Finally, if this is a block-container, then we clear out any existing .locals object\n            // it may contain within it.  This happens in incremental scenarios.  Because we can be\n            // reusing a node from a previous compilation, that node may have had 'locals' created\n            // for it.  We must clear this so we don't accidently move any stale data forward from\n            // a previous compilation.\n            var containerFlags = getContainerFlags(node);\n            if (containerFlags & 1 /* IsContainer */) {\n                container = blockScopeContainer = node;\n                if (containerFlags & 4 /* HasLocals */) {\n                    container.locals = {};\n                }\n                addToContainerChain(container);\n            }\n            else if (containerFlags & 2 /* IsBlockScopedContainer */) {\n                blockScopeContainer = node;\n                blockScopeContainer.locals = undefined;\n            }\n            if (node.kind === 215 /* InterfaceDeclaration */) {\n                seenThisKeyword = false;\n                ts.forEachChild(node, bind);\n                node.flags = seenThisKeyword ? node.flags | 524288 /* ContainsThis */ : node.flags & ~524288 /* ContainsThis */;\n            }\n            else {\n                ts.forEachChild(node, bind);\n            }\n            container = saveContainer;\n            parent = saveParent;\n            blockScopeContainer = savedBlockScopeContainer;\n        }", "language": "javascript", "code": "function bindChildren(node) {\n            // Before we recurse into a node's chilren, we first save the existing parent, container\n            // and block-container.  Then after we pop out of processing the children, we restore\n            // these saved values.\n            var saveParent = parent;\n            var saveContainer = container;\n            var savedBlockScopeContainer = blockScopeContainer;\n            // This node will now be set as the parent of all of its children as we recurse into them.\n            parent = node;\n            // Depending on what kind of node this is, we may have to adjust the current container\n            // and block-container.   If the current node is a container, then it is automatically\n            // considered the current block-container as well.  Also, for containers that we know\n            // may contain locals, we proactively initialize the .locals field. We do this because\n            // it's highly likely that the .locals will be needed to place some child in (for example,\n            // a parameter, or variable declaration).\n            //\n            // However, we do not proactively create the .locals for block-containers because it's\n            // totally normal and common for block-containers to never actually have a block-scoped\n            // variable in them.  We don't want to end up allocating an object for every 'block' we\n            // run into when most of them won't be necessary.\n            //\n            // Finally, if this is a block-container, then we clear out any existing .locals object\n            // it may contain within it.  This happens in incremental scenarios.  Because we can be\n            // reusing a node from a previous compilation, that node may have had 'locals' created\n            // for it.  We must clear this so we don't accidently move any stale data forward from\n            // a previous compilation.\n            var containerFlags = getContainerFlags(node);\n            if (containerFlags & 1 /* IsContainer */) {\n                container = blockScopeContainer = node;\n                if (containerFlags & 4 /* HasLocals */) {\n                    container.locals = {};\n                }\n                addToContainerChain(container);\n            }\n            else if (containerFlags & 2 /* IsBlockScopedContainer */) {\n                blockScopeContainer = node;\n                blockScopeContainer.locals = undefined;\n            }\n            if (node.kind === 215 /* InterfaceDeclaration */) {\n                seenThisKeyword = false;\n                ts.forEachChild(node, bind);\n                node.flags = seenThisKeyword ? node.flags | 524288 /* ContainsThis */ : node.flags & ~524288 /* ContainsThis */;\n            }\n            else {\n                ts.forEachChild(node, bind);\n            }\n            container = saveContainer;\n            parent = saveParent;\n            blockScopeContainer = savedBlockScopeContainer;\n        }", "code_tokens": ["function", "bindChildren", "(", "node", ")", "{", "// Before we recurse into a node's chilren, we first save the existing parent, container", "// and block-container.  Then after we pop out of processing the children, we restore", "// these saved values.", "var", "saveParent", "=", "parent", ";", "var", "saveContainer", "=", "container", ";", "var", "savedBlockScopeContainer", "=", "blockScopeContainer", ";", "// This node will now be set as the parent of all of its children as we recurse into them.", "parent", "=", "node", ";", "// Depending on what kind of node this is, we may have to adjust the current container", "// and block-container.   If the current node is a container, then it is automatically", "// considered the current block-container as well.  Also, for containers that we know", "// may contain locals, we proactively initialize the .locals field. We do this because", "// it's highly likely that the .locals will be needed to place some child in (for example,", "// a parameter, or variable declaration).", "//", "// However, we do not proactively create the .locals for block-containers because it's", "// totally normal and common for block-containers to never actually have a block-scoped", "// variable in them.  We don't want to end up allocating an object for every 'block' we", "// run into when most of them won't be necessary.", "//", "// Finally, if this is a block-container, then we clear out any existing .locals object", "// it may contain within it.  This happens in incremental scenarios.  Because we can be", "// reusing a node from a previous compilation, that node may have had 'locals' created", "// for it.  We must clear this so we don't accidently move any stale data forward from", "// a previous compilation.", "var", "containerFlags", "=", "getContainerFlags", "(", "node", ")", ";", "if", "(", "containerFlags", "&", "1", "/* IsContainer */", ")", "{", "container", "=", "blockScopeContainer", "=", "node", ";", "if", "(", "containerFlags", "&", "4", "/* HasLocals */", ")", "{", "container", ".", "locals", "=", "{", "}", ";", "}", "addToContainerChain", "(", "container", ")", ";", "}", "else", "if", "(", "containerFlags", "&", "2", "/* IsBlockScopedContainer */", ")", "{", "blockScopeContainer", "=", "node", ";", "blockScopeContainer", ".", "locals", "=", "undefined", ";", "}", "if", "(", "node", ".", "kind", "===", "215", "/* InterfaceDeclaration */", ")", "{", "seenThisKeyword", "=", "false", ";", "ts", ".", "forEachChild", "(", "node", ",", "bind", ")", ";", "node", ".", "flags", "=", "seenThisKeyword", "?", "node", ".", "flags", "|", "524288", "/* ContainsThis */", ":", "node", ".", "flags", "&", "~", "524288", "/* ContainsThis */", ";", "}", "else", "{", "ts", ".", "forEachChild", "(", "node", ",", "bind", ")", ";", "}", "container", "=", "saveContainer", ";", "parent", "=", "saveParent", ";", "blockScopeContainer", "=", "savedBlockScopeContainer", ";", "}"], "docstring": "All container nodes are kept on a linked list in declaration order. This list is used by the getLocalNameOfContainer function in the type checker to validate that the local name used for a container is unique.", "docstring_tokens": ["All", "container", "nodes", "are", "kept", "on", "a", "linked", "list", "in", "declaration", "order", ".", "This", "list", "is", "used", "by", "the", "getLocalNameOfContainer", "function", "in", "the", "type", "checker", "to", "validate", "that", "the", "local", "name", "used", "for", "a", "container", "is", "unique", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L4417-L4466", "partition": "test"}
{"repo": "GeoSensorWebLab/polarmap.js", "path": "src/map/Map.js", "func_name": "", "original_string": "function (group) {\n    var map = this;\n\n    if (group.eachLayer) {\n      group.eachLayer(function (layer) {\n        map._updateAllLayers(layer);\n      });\n    } else {\n      if (group.redraw) {\n        group.redraw();\n      } else if (group.update) {\n        group.update();\n      } else {\n        console.log(\"Don't know how to update\", group);\n      }\n    }\n  }", "language": "javascript", "code": "function (group) {\n    var map = this;\n\n    if (group.eachLayer) {\n      group.eachLayer(function (layer) {\n        map._updateAllLayers(layer);\n      });\n    } else {\n      if (group.redraw) {\n        group.redraw();\n      } else if (group.update) {\n        group.update();\n      } else {\n        console.log(\"Don't know how to update\", group);\n      }\n    }\n  }", "code_tokens": ["function", "(", "group", ")", "{", "var", "map", "=", "this", ";", "if", "(", "group", ".", "eachLayer", ")", "{", "group", ".", "eachLayer", "(", "function", "(", "layer", ")", "{", "map", ".", "_updateAllLayers", "(", "layer", ")", ";", "}", ")", ";", "}", "else", "{", "if", "(", "group", ".", "redraw", ")", "{", "group", ".", "redraw", "(", ")", ";", "}", "else", "if", "(", "group", ".", "update", ")", "{", "group", ".", "update", "(", ")", ";", "}", "else", "{", "console", ".", "log", "(", "\"Don't know how to update\"", ",", "group", ")", ";", "}", "}", "}"], "docstring": "This recurses through all the map's layers to update layer positions after their positions moved.", "docstring_tokens": ["This", "recurses", "through", "all", "the", "map", "s", "layers", "to", "update", "layer", "positions", "after", "their", "positions", "moved", "."], "sha": "fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b", "url": "https://github.com/GeoSensorWebLab/polarmap.js/blob/fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b/src/map/Map.js#L138-L154", "partition": "test"}
{"repo": "snapptop/ninjs-lodash", "path": "lib/url.js", "func_name": "clean", "original_string": "function clean(src) {\n  let pidx = src.indexOf('http')\n  if(pidx > 0) src = src.substr(pidx)\n  return src ? pidx >= 0 || src.indexOf('//') >= 0 ? src : '/' + src : ''\n}", "language": "javascript", "code": "function clean(src) {\n  let pidx = src.indexOf('http')\n  if(pidx > 0) src = src.substr(pidx)\n  return src ? pidx >= 0 || src.indexOf('//') >= 0 ? src : '/' + src : ''\n}", "code_tokens": ["function", "clean", "(", "src", ")", "{", "let", "pidx", "=", "src", ".", "indexOf", "(", "'http'", ")", "if", "(", "pidx", ">", "0", ")", "src", "=", "src", ".", "substr", "(", "pidx", ")", "return", "src", "?", "pidx", ">=", "0", "||", "src", ".", "indexOf", "(", "'//'", ")", ">=", "0", "?", "src", ":", "'/'", "+", "src", ":", "''", "}"], "docstring": "cleans url to be properly formatted", "docstring_tokens": ["cleans", "url", "to", "be", "properly", "formatted"], "sha": "fab253b7d96cc9bb3f2a1057efff2684c200bcee", "url": "https://github.com/snapptop/ninjs-lodash/blob/fab253b7d96cc9bb3f2a1057efff2684c200bcee/lib/url.js#L95-L99", "partition": "test"}
{"repo": "MartinKolarik/ractive-route", "path": "demo/js/vendor/ractive.js", "func_name": "", "original_string": "function() {\n\t\t\t\tif ( !this.selfUpdating ) {\n\t\t\t\t\tthis.deferred = true;\n\t\t\t\t}\n\t\t\t\tvar i = this.refs.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tthis.refs[ i ].update();\n\t\t\t\t}\n\t\t\t\tif ( this.deferred ) {\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.deferred = false;\n\t\t\t\t}\n\t\t\t}", "language": "javascript", "code": "function() {\n\t\t\t\tif ( !this.selfUpdating ) {\n\t\t\t\t\tthis.deferred = true;\n\t\t\t\t}\n\t\t\t\tvar i = this.refs.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tthis.refs[ i ].update();\n\t\t\t\t}\n\t\t\t\tif ( this.deferred ) {\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.deferred = false;\n\t\t\t\t}\n\t\t\t}", "code_tokens": ["function", "(", ")", "{", "if", "(", "!", "this", ".", "selfUpdating", ")", "{", "this", ".", "deferred", "=", "true", ";", "}", "var", "i", "=", "this", ".", "refs", ".", "length", ";", "while", "(", "i", "--", ")", "{", "this", ".", "refs", "[", "i", "]", ".", "update", "(", ")", ";", "}", "if", "(", "this", ".", "deferred", ")", "{", "this", ".", "update", "(", ")", ";", "this", ".", "deferred", "=", "false", ";", "}", "}"], "docstring": "This method forces the evaluator to sync with the current model in the case of a smart update", "docstring_tokens": ["This", "method", "forces", "the", "evaluator", "to", "sync", "with", "the", "current", "model", "in", "the", "case", "of", "a", "smart", "update"], "sha": "0557db606a8bd4f19d18e41e99b40450a27c04c9", "url": "https://github.com/MartinKolarik/ractive-route/blob/0557db606a8bd4f19d18e41e99b40450a27c04c9/demo/js/vendor/ractive.js#L3742-L3754", "partition": "test"}
{"repo": "dataminr/react-components", "path": "src/js/mixins/DataMixins.js", "func_name": "", "original_string": "function() {\n                store.on('change:' + this.props.componentId, this.onDataReceived);\n                store.on('fail:' + this.props.componentId, this.onError);\n            }", "language": "javascript", "code": "function() {\n                store.on('change:' + this.props.componentId, this.onDataReceived);\n                store.on('fail:' + this.props.componentId, this.onError);\n            }", "code_tokens": ["function", "(", ")", "{", "store", ".", "on", "(", "'change:'", "+", "this", ".", "props", ".", "componentId", ",", "this", ".", "onDataReceived", ")", ";", "store", ".", "on", "(", "'fail:'", "+", "this", ".", "props", ".", "componentId", ",", "this", ".", "onError", ")", ";", "}"], "docstring": "Adds the listeners required when requesting data from the server.", "docstring_tokens": ["Adds", "the", "listeners", "required", "when", "requesting", "data", "from", "the", "server", "."], "sha": "0aa29ed8562ee35fd8e682a5052ac979cd409de7", "url": "https://github.com/dataminr/react-components/blob/0aa29ed8562ee35fd8e682a5052ac979cd409de7/src/js/mixins/DataMixins.js#L68-L71", "partition": "test"}
{"repo": "cloudinary/cloudinary_js", "path": "webpack.config.js", "func_name": "resolveLodash", "original_string": "function resolveLodash(context, request, callback) {\n  if (/^lodash\\//.test(request)) {\n    callback(null, {\n      commonjs: request,\n      commonjs2: request,\n      amd: request,\n      root: ['_', request.split('/')[1]]\n    });\n  } else {\n    callback();\n  }\n}", "language": "javascript", "code": "function resolveLodash(context, request, callback) {\n  if (/^lodash\\//.test(request)) {\n    callback(null, {\n      commonjs: request,\n      commonjs2: request,\n      amd: request,\n      root: ['_', request.split('/')[1]]\n    });\n  } else {\n    callback();\n  }\n}", "code_tokens": ["function", "resolveLodash", "(", "context", ",", "request", ",", "callback", ")", "{", "if", "(", "/", "^lodash\\/", "/", ".", "test", "(", "request", ")", ")", "{", "callback", "(", "null", ",", "{", "commonjs", ":", "request", ",", "commonjs2", ":", "request", ",", "amd", ":", "request", ",", "root", ":", "[", "'_'", ",", "request", ".", "split", "(", "'/'", ")", "[", "1", "]", "]", "}", ")", ";", "}", "else", "{", "callback", "(", ")", ";", "}", "}"], "docstring": "This function is used by webpack to resolve individual lodash modules\n@param context\n@param request\n@param callback", "docstring_tokens": ["This", "function", "is", "used", "by", "webpack", "to", "resolve", "individual", "lodash", "modules"], "sha": "c5ef98e858ba83e7c2c13a1d898748b571a5931b", "url": "https://github.com/cloudinary/cloudinary_js/blob/c5ef98e858ba83e7c2c13a1d898748b571a5931b/webpack.config.js#L33-L44", "partition": "test"}
{"repo": "etabits/node-penguin", "path": "statics/js/31-combodate.js", "func_name": "getNearest", "original_string": "function getNearest($select, value) {\n                var delta = {};\n                $select.children('option').each(function(i, opt){\n                    var optValue = $(opt).attr('value'),\n                    distance;\n\n                    if(optValue === '') return;\n                    distance = Math.abs(optValue - value); \n                    if(typeof delta.distance === 'undefined' || distance < delta.distance) {\n                        delta = {value: optValue, distance: distance};\n                    } \n                }); \n                return delta.value;\n            }", "language": "javascript", "code": "function getNearest($select, value) {\n                var delta = {};\n                $select.children('option').each(function(i, opt){\n                    var optValue = $(opt).attr('value'),\n                    distance;\n\n                    if(optValue === '') return;\n                    distance = Math.abs(optValue - value); \n                    if(typeof delta.distance === 'undefined' || distance < delta.distance) {\n                        delta = {value: optValue, distance: distance};\n                    } \n                }); \n                return delta.value;\n            }", "code_tokens": ["function", "getNearest", "(", "$select", ",", "value", ")", "{", "var", "delta", "=", "{", "}", ";", "$select", ".", "children", "(", "'option'", ")", ".", "each", "(", "function", "(", "i", ",", "opt", ")", "{", "var", "optValue", "=", "$", "(", "opt", ")", ".", "attr", "(", "'value'", ")", ",", "distance", ";", "if", "(", "optValue", "===", "''", ")", "return", ";", "distance", "=", "Math", ".", "abs", "(", "optValue", "-", "value", ")", ";", "if", "(", "typeof", "delta", ".", "distance", "===", "'undefined'", "||", "distance", "<", "delta", ".", "distance", ")", "{", "delta", "=", "{", "value", ":", "optValue", ",", "distance", ":", "distance", "}", ";", "}", "}", ")", ";", "return", "delta", ".", "value", ";", "}"], "docstring": "function to find nearest value in select options", "docstring_tokens": ["function", "to", "find", "nearest", "value", "in", "select", "options"], "sha": "1e22637c388506f0bc40bcf7457f193aab28cd23", "url": "https://github.com/etabits/node-penguin/blob/1e22637c388506f0bc40bcf7457f193aab28cd23/statics/js/31-combodate.js#L349-L362", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "isWriteAccess", "original_string": "function isWriteAccess(node) {\n            if (node.kind === 69 /* Identifier */ && ts.isDeclarationName(node)) {\n                return true;\n            }\n            var parent = node.parent;\n            if (parent) {\n                if (parent.kind === 180 /* PostfixUnaryExpression */ || parent.kind === 179 /* PrefixUnaryExpression */) {\n                    return true;\n                }\n                else if (parent.kind === 181 /* BinaryExpression */ && parent.left === node) {\n                    var operator = parent.operatorToken.kind;\n                    return 56 /* FirstAssignment */ <= operator && operator <= 68 /* LastAssignment */;\n                }\n            }\n            return false;\n        }", "language": "javascript", "code": "function isWriteAccess(node) {\n            if (node.kind === 69 /* Identifier */ && ts.isDeclarationName(node)) {\n                return true;\n            }\n            var parent = node.parent;\n            if (parent) {\n                if (parent.kind === 180 /* PostfixUnaryExpression */ || parent.kind === 179 /* PrefixUnaryExpression */) {\n                    return true;\n                }\n                else if (parent.kind === 181 /* BinaryExpression */ && parent.left === node) {\n                    var operator = parent.operatorToken.kind;\n                    return 56 /* FirstAssignment */ <= operator && operator <= 68 /* LastAssignment */;\n                }\n            }\n            return false;\n        }", "code_tokens": ["function", "isWriteAccess", "(", "node", ")", "{", "if", "(", "node", ".", "kind", "===", "69", "/* Identifier */", "&&", "ts", ".", "isDeclarationName", "(", "node", ")", ")", "{", "return", "true", ";", "}", "var", "parent", "=", "node", ".", "parent", ";", "if", "(", "parent", ")", "{", "if", "(", "parent", ".", "kind", "===", "180", "/* PostfixUnaryExpression */", "||", "parent", ".", "kind", "===", "179", "/* PrefixUnaryExpression */", ")", "{", "return", "true", ";", "}", "else", "if", "(", "parent", ".", "kind", "===", "181", "/* BinaryExpression */", "&&", "parent", ".", "left", "===", "node", ")", "{", "var", "operator", "=", "parent", ".", "operatorToken", ".", "kind", ";", "return", "56", "/* FirstAssignment */", "<=", "operator", "&&", "operator", "<=", "68", "/* LastAssignment */", ";", "}", "}", "return", "false", ";", "}"], "docstring": "A node is considered a writeAccess iff it is a name of a declaration or a target of an assignment", "docstring_tokens": ["A", "node", "is", "considered", "a", "writeAccess", "iff", "it", "is", "a", "name", "of", "a", "declaration", "or", "a", "target", "of", "an", "assignment"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L47573-L47588", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "unescapeIdentifier", "original_string": "function unescapeIdentifier(identifier) {\n        return identifier.length >= 3 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ && identifier.charCodeAt(2) === 95 /* _ */ ? identifier.substr(1) : identifier;\n    }", "language": "javascript", "code": "function unescapeIdentifier(identifier) {\n        return identifier.length >= 3 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ && identifier.charCodeAt(2) === 95 /* _ */ ? identifier.substr(1) : identifier;\n    }", "code_tokens": ["function", "unescapeIdentifier", "(", "identifier", ")", "{", "return", "identifier", ".", "length", ">=", "3", "&&", "identifier", ".", "charCodeAt", "(", "0", ")", "===", "95", "/* _ */", "&&", "identifier", ".", "charCodeAt", "(", "1", ")", "===", "95", "/* _ */", "&&", "identifier", ".", "charCodeAt", "(", "2", ")", "===", "95", "/* _ */", "?", "identifier", ".", "substr", "(", "1", ")", ":", "identifier", ";", "}"], "docstring": "Remove extra underscore from escaped identifier", "docstring_tokens": ["Remove", "extra", "underscore", "from", "escaped", "identifier"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L5319-L5321", "partition": "test"}
{"repo": "kevinoid/travis-status", "path": "lib/git-status-checker.js", "func_name": "gitUrlPath", "original_string": "function gitUrlPath(gitUrl) {\n  // Foreign URL for remote helper\n  // See transport_get in transport.c\n  // Note:  url.parse considers second : as part of path.  So check this first.\n  const foreignParts = /^([A-Za-z0-9][A-Za-z0-9+.-]*)::(.*)$/.exec(gitUrl);\n  if (foreignParts) {\n    return foreignParts[2];\n  }\n\n  // Typical URL\n  const gitUrlObj = url.parse(gitUrl);\n  if (gitUrlObj.protocol) {\n    return gitUrlObj.path;\n  }\n\n  // SCP-like syntax.  Host can be wrapped in [] to disambiguate path.\n  // See parse_connect_url and host_end in connect.c\n  const scpParts = /^([^@/]+)@(\\[[^]\\/]+\\]|[^:/]+):(.*)$/.exec(gitUrl);\n  if (scpParts) {\n    return scpParts[3];\n  }\n\n  // Assume URL is a local path\n  return gitUrl;\n}", "language": "javascript", "code": "function gitUrlPath(gitUrl) {\n  // Foreign URL for remote helper\n  // See transport_get in transport.c\n  // Note:  url.parse considers second : as part of path.  So check this first.\n  const foreignParts = /^([A-Za-z0-9][A-Za-z0-9+.-]*)::(.*)$/.exec(gitUrl);\n  if (foreignParts) {\n    return foreignParts[2];\n  }\n\n  // Typical URL\n  const gitUrlObj = url.parse(gitUrl);\n  if (gitUrlObj.protocol) {\n    return gitUrlObj.path;\n  }\n\n  // SCP-like syntax.  Host can be wrapped in [] to disambiguate path.\n  // See parse_connect_url and host_end in connect.c\n  const scpParts = /^([^@/]+)@(\\[[^]\\/]+\\]|[^:/]+):(.*)$/.exec(gitUrl);\n  if (scpParts) {\n    return scpParts[3];\n  }\n\n  // Assume URL is a local path\n  return gitUrl;\n}", "code_tokens": ["function", "gitUrlPath", "(", "gitUrl", ")", "{", "// Foreign URL for remote helper", "// See transport_get in transport.c", "// Note:  url.parse considers second : as part of path.  So check this first.", "const", "foreignParts", "=", "/", "^([A-Za-z0-9][A-Za-z0-9+.-]*)::(.*)$", "/", ".", "exec", "(", "gitUrl", ")", ";", "if", "(", "foreignParts", ")", "{", "return", "foreignParts", "[", "2", "]", ";", "}", "// Typical URL", "const", "gitUrlObj", "=", "url", ".", "parse", "(", "gitUrl", ")", ";", "if", "(", "gitUrlObj", ".", "protocol", ")", "{", "return", "gitUrlObj", ".", "path", ";", "}", "// SCP-like syntax.  Host can be wrapped in [] to disambiguate path.", "// See parse_connect_url and host_end in connect.c", "const", "scpParts", "=", "/", "^([^@/]+)@(\\[[^]\\/]+\\]|[^:/]+):(.*)$", "/", ".", "exec", "(", "gitUrl", ")", ";", "if", "(", "scpParts", ")", "{", "return", "scpParts", "[", "3", "]", ";", "}", "// Assume URL is a local path", "return", "gitUrl", ";", "}"], "docstring": "Gets the path portion of a git URL.\n@param {string} gitUrl Git URL to parse.\n@return {string} Path portion of the URL.\n@private", "docstring_tokens": ["Gets", "the", "path", "portion", "of", "a", "git", "URL", "."], "sha": "4432996e44c111046cbf0ca7b0054fe1a0a7032d", "url": "https://github.com/kevinoid/travis-status/blob/4432996e44c111046cbf0ca7b0054fe1a0a7032d/lib/git-status-checker.js#L218-L242", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "repeat", "original_string": "function repeat(str, num) {\n      if (typeof str !== 'string') {\n        throw new TypeError('repeat-string expects a string.');\n      }\n    \n      if (num === 1) return str;\n      if (num === 2) return str + str;\n    \n      var max = str.length * num;\n      if (cache !== str || typeof cache === 'undefined') {\n        cache = str;\n        res = '';\n      }\n    \n      while (max > res.length && num > 0) {\n        if (num & 1) {\n          res += str;\n        }\n    \n        num >>= 1;\n        if (!num) break;\n        str += str;\n      }\n    \n      return res.substr(0, max);\n    }", "language": "javascript", "code": "function repeat(str, num) {\n      if (typeof str !== 'string') {\n        throw new TypeError('repeat-string expects a string.');\n      }\n    \n      if (num === 1) return str;\n      if (num === 2) return str + str;\n    \n      var max = str.length * num;\n      if (cache !== str || typeof cache === 'undefined') {\n        cache = str;\n        res = '';\n      }\n    \n      while (max > res.length && num > 0) {\n        if (num & 1) {\n          res += str;\n        }\n    \n        num >>= 1;\n        if (!num) break;\n        str += str;\n      }\n    \n      return res.substr(0, max);\n    }", "code_tokens": ["function", "repeat", "(", "str", ",", "num", ")", "{", "if", "(", "typeof", "str", "!==", "'string'", ")", "{", "throw", "new", "TypeError", "(", "'repeat-string expects a string.'", ")", ";", "}", "if", "(", "num", "===", "1", ")", "return", "str", ";", "if", "(", "num", "===", "2", ")", "return", "str", "+", "str", ";", "var", "max", "=", "str", ".", "length", "*", "num", ";", "if", "(", "cache", "!==", "str", "||", "typeof", "cache", "===", "'undefined'", ")", "{", "cache", "=", "str", ";", "res", "=", "''", ";", "}", "while", "(", "max", ">", "res", ".", "length", "&&", "num", ">", "0", ")", "{", "if", "(", "num", "&", "1", ")", "{", "res", "+=", "str", ";", "}", "num", ">>=", "1", ";", "if", "(", "!", "num", ")", "break", ";", "str", "+=", "str", ";", "}", "return", "res", ".", "substr", "(", "0", ",", "max", ")", ";", "}"], "docstring": "Repeat the given `string` the specified `number`\nof times.\n\n**Example:**\n\n```js\nvar repeat =  require('repeat-string');\nrepeat('A', 5);\n//=> AAAAA\n```\n\n@param {String} `string` The string to repeat\n@param {Number} `number` The number of times to repeat the string\n@return {String} Repeated string\n@api public", "docstring_tokens": ["Repeat", "the", "given", "string", "the", "specified", "number", "of", "times", "."], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L44231-L44256", "partition": "test"}
{"repo": "tstachl/desk.js", "path": "lib/resource/company.js", "func_name": "Company", "original_string": "function Company(parent, definition) {\n  var key;\n  for (key in updateMixin) {\n    this[key] = updateMixin[key];\n  }\n  Company.super_.apply(this, arguments);\n}", "language": "javascript", "code": "function Company(parent, definition) {\n  var key;\n  for (key in updateMixin) {\n    this[key] = updateMixin[key];\n  }\n  Company.super_.apply(this, arguments);\n}", "code_tokens": ["function", "Company", "(", "parent", ",", "definition", ")", "{", "var", "key", ";", "for", "(", "key", "in", "updateMixin", ")", "{", "this", "[", "key", "]", "=", "updateMixin", "[", "key", "]", ";", "}", "Company", ".", "super_", ".", "apply", "(", "this", ",", "arguments", ")", ";", "}"], "docstring": "Initialize a new `Company` with the given `parent` and `definition`.\n\n@param {Function} parent The parent this resource is attached to.\n@param {Object} definition The resource definition.\n@api private", "docstring_tokens": ["Initialize", "a", "new", "Company", "with", "the", "given", "parent", "and", "definition", "."], "sha": "b339196cce68dbbc79d3075f2ebe82372972f4f5", "url": "https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/resource/company.js#L21-L27", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/language.js", "func_name": "preferredLanguages", "original_string": "function preferredLanguages(accept, provided) {\n  // RFC 2616 sec 14.4: no header = *\n  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');\n\n  if (!provided) {\n    // sorted list of all languages\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullLanguage);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getLanguagePriority(type, accepts, index);\n  });\n\n  // sorted list of accepted languages\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}", "language": "javascript", "code": "function preferredLanguages(accept, provided) {\n  // RFC 2616 sec 14.4: no header = *\n  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');\n\n  if (!provided) {\n    // sorted list of all languages\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullLanguage);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getLanguagePriority(type, accepts, index);\n  });\n\n  // sorted list of accepted languages\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}", "code_tokens": ["function", "preferredLanguages", "(", "accept", ",", "provided", ")", "{", "// RFC 2616 sec 14.4: no header = *", "var", "accepts", "=", "parseAcceptLanguage", "(", "accept", "===", "undefined", "?", "'*'", ":", "accept", "||", "''", ")", ";", "if", "(", "!", "provided", ")", "{", "// sorted list of all languages", "return", "accepts", ".", "filter", "(", "isQuality", ")", ".", "sort", "(", "compareSpecs", ")", ".", "map", "(", "getFullLanguage", ")", ";", "}", "var", "priorities", "=", "provided", ".", "map", "(", "function", "getPriority", "(", "type", ",", "index", ")", "{", "return", "getLanguagePriority", "(", "type", ",", "accepts", ",", "index", ")", ";", "}", ")", ";", "// sorted list of accepted languages", "return", "priorities", ".", "filter", "(", "isQuality", ")", ".", "sort", "(", "compareSpecs", ")", ".", "map", "(", "function", "getLanguage", "(", "priority", ")", "{", "return", "provided", "[", "priorities", ".", "indexOf", "(", "priority", ")", "]", ";", "}", ")", ";", "}"], "docstring": "Get the preferred languages from an Accept-Language header.\n@public", "docstring_tokens": ["Get", "the", "preferred", "languages", "from", "an", "Accept", "-", "Language", "header", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/language.js#L132-L152", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "onDocumentMouseUp", "original_string": "function onDocumentMouseUp(event) {\n    if (!isUserInteracting) {\n        return;\n    }\n    isUserInteracting = false;\n    if (Date.now() - latestInteraction > 15) {\n        // Prevents jump when user rapidly moves mouse, stops, and then\n        // releases the mouse button\n        speed.pitch = speed.yaw = 0;\n    }\n    uiContainer.classList.add('pnlm-grab');\n    uiContainer.classList.remove('pnlm-grabbing');\n    latestInteraction = Date.now();\n\n    fireEvent('mouseup', event);\n}", "language": "javascript", "code": "function onDocumentMouseUp(event) {\n    if (!isUserInteracting) {\n        return;\n    }\n    isUserInteracting = false;\n    if (Date.now() - latestInteraction > 15) {\n        // Prevents jump when user rapidly moves mouse, stops, and then\n        // releases the mouse button\n        speed.pitch = speed.yaw = 0;\n    }\n    uiContainer.classList.add('pnlm-grab');\n    uiContainer.classList.remove('pnlm-grabbing');\n    latestInteraction = Date.now();\n\n    fireEvent('mouseup', event);\n}", "code_tokens": ["function", "onDocumentMouseUp", "(", "event", ")", "{", "if", "(", "!", "isUserInteracting", ")", "{", "return", ";", "}", "isUserInteracting", "=", "false", ";", "if", "(", "Date", ".", "now", "(", ")", "-", "latestInteraction", ">", "15", ")", "{", "// Prevents jump when user rapidly moves mouse, stops, and then", "// releases the mouse button", "speed", ".", "pitch", "=", "speed", ".", "yaw", "=", "0", ";", "}", "uiContainer", ".", "classList", ".", "add", "(", "'pnlm-grab'", ")", ";", "uiContainer", ".", "classList", ".", "remove", "(", "'pnlm-grabbing'", ")", ";", "latestInteraction", "=", "Date", ".", "now", "(", ")", ";", "fireEvent", "(", "'mouseup'", ",", "event", ")", ";", "}"], "docstring": "Event handler for mouse up events. Stops panning.\n@private", "docstring_tokens": ["Event", "handler", "for", "mouse", "up", "events", ".", "Stops", "panning", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L791-L806", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/conflict.js", "func_name": "_getSolvedEntries", "original_string": "function _getSolvedEntries(treeConflict) {\n    const parentEntries = treeConflict.getParent().getTreeEntries();\n    const baseEntries = treeConflict.getBase().getTreeEntries();\n    const headEntries = treeConflict.getHead().getTreeEntries();\n\n    const baseDiff = _diffEntries(parentEntries, baseEntries);\n    const headDiff = _diffEntries(parentEntries, headEntries);\n\n    const resolvedEntries = treeConflict.getConflicts().map((solvedConflict) => {\n        // Convert to TreeEntries (or null for deletion)\n        if (solvedConflict.isDeleted()) {\n            return null;\n        } else {\n            return new TreeEntry({\n                sha: solvedConflict.getSolvedSha() || null\n            });\n        }\n    });\n\n    return parentEntries.merge(baseDiff, headDiff, resolvedEntries)\n    // Remove deleted entries\n    .filter(function nonNull(entry) {\n        return entry !== null;\n    });\n}", "language": "javascript", "code": "function _getSolvedEntries(treeConflict) {\n    const parentEntries = treeConflict.getParent().getTreeEntries();\n    const baseEntries = treeConflict.getBase().getTreeEntries();\n    const headEntries = treeConflict.getHead().getTreeEntries();\n\n    const baseDiff = _diffEntries(parentEntries, baseEntries);\n    const headDiff = _diffEntries(parentEntries, headEntries);\n\n    const resolvedEntries = treeConflict.getConflicts().map((solvedConflict) => {\n        // Convert to TreeEntries (or null for deletion)\n        if (solvedConflict.isDeleted()) {\n            return null;\n        } else {\n            return new TreeEntry({\n                sha: solvedConflict.getSolvedSha() || null\n            });\n        }\n    });\n\n    return parentEntries.merge(baseDiff, headDiff, resolvedEntries)\n    // Remove deleted entries\n    .filter(function nonNull(entry) {\n        return entry !== null;\n    });\n}", "code_tokens": ["function", "_getSolvedEntries", "(", "treeConflict", ")", "{", "const", "parentEntries", "=", "treeConflict", ".", "getParent", "(", ")", ".", "getTreeEntries", "(", ")", ";", "const", "baseEntries", "=", "treeConflict", ".", "getBase", "(", ")", ".", "getTreeEntries", "(", ")", ";", "const", "headEntries", "=", "treeConflict", ".", "getHead", "(", ")", ".", "getTreeEntries", "(", ")", ";", "const", "baseDiff", "=", "_diffEntries", "(", "parentEntries", ",", "baseEntries", ")", ";", "const", "headDiff", "=", "_diffEntries", "(", "parentEntries", ",", "headEntries", ")", ";", "const", "resolvedEntries", "=", "treeConflict", ".", "getConflicts", "(", ")", ".", "map", "(", "(", "solvedConflict", ")", "=>", "{", "// Convert to TreeEntries (or null for deletion)", "if", "(", "solvedConflict", ".", "isDeleted", "(", ")", ")", "{", "return", "null", ";", "}", "else", "{", "return", "new", "TreeEntry", "(", "{", "sha", ":", "solvedConflict", ".", "getSolvedSha", "(", ")", "||", "null", "}", ")", ";", "}", "}", ")", ";", "return", "parentEntries", ".", "merge", "(", "baseDiff", ",", "headDiff", ",", "resolvedEntries", ")", "// Remove deleted entries", ".", "filter", "(", "function", "nonNull", "(", "entry", ")", "{", "return", "entry", "!==", "null", ";", "}", ")", ";", "}"], "docstring": "Returns the final TreeEntries for a solved TreeConflict.\n@param {TreeConflict} treeConflict\n@return {Map<Path, TreeEntry>} Some TreeEntries have a null SHA\nbecause of new solved content.", "docstring_tokens": ["Returns", "the", "final", "TreeEntries", "for", "a", "solved", "TreeConflict", "."], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/conflict.js#L176-L200", "partition": "test"}
{"repo": "standardhealth/shr-json-schema-export", "path": "lib/export.js", "func_name": "isOrWasAList", "original_string": "function isOrWasAList(value) {\n  if (value.card.isList) {\n    return true;\n  }\n  const cardConstraints = value.constraintsFilter.own.card.constraints;\n  return cardConstraints.some((oneCard) => oneCard.isList);\n}", "language": "javascript", "code": "function isOrWasAList(value) {\n  if (value.card.isList) {\n    return true;\n  }\n  const cardConstraints = value.constraintsFilter.own.card.constraints;\n  return cardConstraints.some((oneCard) => oneCard.isList);\n}", "code_tokens": ["function", "isOrWasAList", "(", "value", ")", "{", "if", "(", "value", ".", "card", ".", "isList", ")", "{", "return", "true", ";", "}", "const", "cardConstraints", "=", "value", ".", "constraintsFilter", ".", "own", ".", "card", ".", "constraints", ";", "return", "cardConstraints", ".", "some", "(", "(", "oneCard", ")", "=>", "oneCard", ".", "isList", ")", ";", "}"], "docstring": "Determine if a value or one of its ancestors is or was a list.\n\n@param {Value} value - the value to test.\n@return {boolean} True if the value or any of its ancestors ever had a cardinality greater than 1.", "docstring_tokens": ["Determine", "if", "a", "value", "or", "one", "of", "its", "ancestors", "is", "or", "was", "a", "list", "."], "sha": "7f6d0994185028edc3cf930e233592f5fd54c57d", "url": "https://github.com/standardhealth/shr-json-schema-export/blob/7f6d0994185028edc3cf930e233592f5fd54c57d/lib/export.js#L1060-L1066", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "checkTypeParameter", "original_string": "function checkTypeParameter(node) {\n            // Grammar Checking\n            if (node.expression) {\n                grammarErrorOnFirstToken(node.expression, ts.Diagnostics.Type_expected);\n            }\n            checkSourceElement(node.constraint);\n            if (produceDiagnostics) {\n                checkTypeParameterHasIllegalReferencesInConstraint(node);\n                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);\n            }\n            // TODO: Check multiple declarations are identical\n        }", "language": "javascript", "code": "function checkTypeParameter(node) {\n            // Grammar Checking\n            if (node.expression) {\n                grammarErrorOnFirstToken(node.expression, ts.Diagnostics.Type_expected);\n            }\n            checkSourceElement(node.constraint);\n            if (produceDiagnostics) {\n                checkTypeParameterHasIllegalReferencesInConstraint(node);\n                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);\n            }\n            // TODO: Check multiple declarations are identical\n        }", "code_tokens": ["function", "checkTypeParameter", "(", "node", ")", "{", "// Grammar Checking", "if", "(", "node", ".", "expression", ")", "{", "grammarErrorOnFirstToken", "(", "node", ".", "expression", ",", "ts", ".", "Diagnostics", ".", "Type_expected", ")", ";", "}", "checkSourceElement", "(", "node", ".", "constraint", ")", ";", "if", "(", "produceDiagnostics", ")", "{", "checkTypeParameterHasIllegalReferencesInConstraint", "(", "node", ")", ";", "checkTypeNameIsReserved", "(", "node", ".", "name", ",", "ts", ".", "Diagnostics", ".", "Type_parameter_name_cannot_be_0", ")", ";", "}", "// TODO: Check multiple declarations are identical", "}"], "docstring": "DECLARATION AND STATEMENT TYPE CHECKING", "docstring_tokens": ["DECLARATION", "AND", "STATEMENT", "TYPE", "CHECKING"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L22848-L22859", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "suspendListener", "original_string": "function suspendListener(obj, eventName, target, method, callback) {\n  if (!method && 'function' === typeof target) {\n    method = target;\n    target = null;\n  }\n\n  var actions = actionsFor(obj, eventName),\n      actionIndex = indexOf(actions, target, method);\n\n  if (actionIndex !== -1) {\n    actions[actionIndex+2] |= SUSPENDED; // mark the action as suspended\n  }\n\n  function tryable()   { return callback.call(target); }\n  function finalizer() { if (actionIndex !== -1) { actions[actionIndex+2] &= ~SUSPENDED; } }\n\n  return Ember.tryFinally(tryable, finalizer);\n}", "language": "javascript", "code": "function suspendListener(obj, eventName, target, method, callback) {\n  if (!method && 'function' === typeof target) {\n    method = target;\n    target = null;\n  }\n\n  var actions = actionsFor(obj, eventName),\n      actionIndex = indexOf(actions, target, method);\n\n  if (actionIndex !== -1) {\n    actions[actionIndex+2] |= SUSPENDED; // mark the action as suspended\n  }\n\n  function tryable()   { return callback.call(target); }\n  function finalizer() { if (actionIndex !== -1) { actions[actionIndex+2] &= ~SUSPENDED; } }\n\n  return Ember.tryFinally(tryable, finalizer);\n}", "code_tokens": ["function", "suspendListener", "(", "obj", ",", "eventName", ",", "target", ",", "method", ",", "callback", ")", "{", "if", "(", "!", "method", "&&", "'function'", "===", "typeof", "target", ")", "{", "method", "=", "target", ";", "target", "=", "null", ";", "}", "var", "actions", "=", "actionsFor", "(", "obj", ",", "eventName", ")", ",", "actionIndex", "=", "indexOf", "(", "actions", ",", "target", ",", "method", ")", ";", "if", "(", "actionIndex", "!==", "-", "1", ")", "{", "actions", "[", "actionIndex", "+", "2", "]", "|=", "SUSPENDED", ";", "// mark the action as suspended", "}", "function", "tryable", "(", ")", "{", "return", "callback", ".", "call", "(", "target", ")", ";", "}", "function", "finalizer", "(", ")", "{", "if", "(", "actionIndex", "!==", "-", "1", ")", "{", "actions", "[", "actionIndex", "+", "2", "]", "&=", "~", "SUSPENDED", ";", "}", "}", "return", "Ember", ".", "tryFinally", "(", "tryable", ",", "finalizer", ")", ";", "}"], "docstring": "Suspend listener during callback.\n\nThis should only be used by the target of the event listener\nwhen it is taking an action that would cause the event, e.g.\nan object might suspend its property change listener while it is\nsetting that property.\n\n@method suspendListener\n@for Ember\n\n@private\n@param obj\n@param {String} eventName\n@param {Object|Function} targetOrMethod A target object or a function\n@param {Function|String} method A function or the name of a function to be called on `target`\n@param {Function} callback", "docstring_tokens": ["Suspend", "listener", "during", "callback", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L2477-L2494", "partition": "test"}
{"repo": "algolia/vue-instantsearch", "path": "docs/plugins/assets.js", "func_name": "assets", "original_string": "function assets(userOptions = {}) {\n  const options = {\n    ...defaults,\n    ...userOptions,\n  };\n\n  return (files, metalsmith, cb) => {\n    const src = metalsmith.path(options.source);\n    const dest = options.destination;\n\n    // copied almost line for line from https://github.com/segmentio/metalsmith/blob/master/lib/index.js\n    readdir(src, (readDirError, arr) => {\n      if (readDirError) {\n        cb(readDirError);\n        return;\n      }\n\n      each(arr, read, err => cb(err, files));\n    });\n\n    function read(file, done) {\n      const name = path.join(dest, path.relative(src, file));\n      fs.stat(file, (statError, stats) => {\n        if (statError) {\n          done(statError);\n          return;\n        }\n\n        fs.readFile(file, (err, buffer) => {\n          if (err) {\n            done(err);\n            return;\n          }\n\n          const newFile = {};\n\n          newFile.contents = buffer;\n          newFile.stats = stats;\n\n          newFile.mode = mode(stats).toOctal();\n          files[name] = newFile;\n          done();\n        });\n      });\n    }\n  };\n}", "language": "javascript", "code": "function assets(userOptions = {}) {\n  const options = {\n    ...defaults,\n    ...userOptions,\n  };\n\n  return (files, metalsmith, cb) => {\n    const src = metalsmith.path(options.source);\n    const dest = options.destination;\n\n    // copied almost line for line from https://github.com/segmentio/metalsmith/blob/master/lib/index.js\n    readdir(src, (readDirError, arr) => {\n      if (readDirError) {\n        cb(readDirError);\n        return;\n      }\n\n      each(arr, read, err => cb(err, files));\n    });\n\n    function read(file, done) {\n      const name = path.join(dest, path.relative(src, file));\n      fs.stat(file, (statError, stats) => {\n        if (statError) {\n          done(statError);\n          return;\n        }\n\n        fs.readFile(file, (err, buffer) => {\n          if (err) {\n            done(err);\n            return;\n          }\n\n          const newFile = {};\n\n          newFile.contents = buffer;\n          newFile.stats = stats;\n\n          newFile.mode = mode(stats).toOctal();\n          files[name] = newFile;\n          done();\n        });\n      });\n    }\n  };\n}", "code_tokens": ["function", "assets", "(", "userOptions", "=", "{", "}", ")", "{", "const", "options", "=", "{", "...", "defaults", ",", "...", "userOptions", ",", "}", ";", "return", "(", "files", ",", "metalsmith", ",", "cb", ")", "=>", "{", "const", "src", "=", "metalsmith", ".", "path", "(", "options", ".", "source", ")", ";", "const", "dest", "=", "options", ".", "destination", ";", "// copied almost line for line from https://github.com/segmentio/metalsmith/blob/master/lib/index.js", "readdir", "(", "src", ",", "(", "readDirError", ",", "arr", ")", "=>", "{", "if", "(", "readDirError", ")", "{", "cb", "(", "readDirError", ")", ";", "return", ";", "}", "each", "(", "arr", ",", "read", ",", "err", "=>", "cb", "(", "err", ",", "files", ")", ")", ";", "}", ")", ";", "function", "read", "(", "file", ",", "done", ")", "{", "const", "name", "=", "path", ".", "join", "(", "dest", ",", "path", ".", "relative", "(", "src", ",", "file", ")", ")", ";", "fs", ".", "stat", "(", "file", ",", "(", "statError", ",", "stats", ")", "=>", "{", "if", "(", "statError", ")", "{", "done", "(", "statError", ")", ";", "return", ";", "}", "fs", ".", "readFile", "(", "file", ",", "(", "err", ",", "buffer", ")", "=>", "{", "if", "(", "err", ")", "{", "done", "(", "err", ")", ";", "return", ";", "}", "const", "newFile", "=", "{", "}", ";", "newFile", ".", "contents", "=", "buffer", ";", "newFile", ".", "stats", "=", "stats", ";", "newFile", ".", "mode", "=", "mode", "(", "stats", ")", ".", "toOctal", "(", ")", ";", "files", "[", "name", "]", "=", "newFile", ";", "done", "(", ")", ";", "}", ")", ";", "}", ")", ";", "}", "}", ";", "}"], "docstring": "Metalsmith plugin to include static assets.\n\n@param {Object} userOptions (optional)\n@property {String} source Path to copy static assets from (relative to working directory). Defaults to './public'\n@property {String} destination Path to copy static assets to (relative to destination directory). Defaults to '.'\n@return {Function} a Metalsmith plugin", "docstring_tokens": ["Metalsmith", "plugin", "to", "include", "static", "assets", "."], "sha": "2a21b5226908f1f71c9ac28372de56d01eda813d", "url": "https://github.com/algolia/vue-instantsearch/blob/2a21b5226908f1f71c9ac28372de56d01eda813d/docs/plugins/assets.js#L33-L79", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function() {\n        if (this.state) {\n          forEach(this.state.handlerInfos, function(handlerInfo) {\n            var handler = handlerInfo.handler;\n            if (handler.exit) {\n              handler.exit();\n            }\n          });\n        }\n\n        this.state = new TransitionState();\n        this.currentHandlerInfos = null;\n      }", "language": "javascript", "code": "function() {\n        if (this.state) {\n          forEach(this.state.handlerInfos, function(handlerInfo) {\n            var handler = handlerInfo.handler;\n            if (handler.exit) {\n              handler.exit();\n            }\n          });\n        }\n\n        this.state = new TransitionState();\n        this.currentHandlerInfos = null;\n      }", "code_tokens": ["function", "(", ")", "{", "if", "(", "this", ".", "state", ")", "{", "forEach", "(", "this", ".", "state", ".", "handlerInfos", ",", "function", "(", "handlerInfo", ")", "{", "var", "handler", "=", "handlerInfo", ".", "handler", ";", "if", "(", "handler", ".", "exit", ")", "{", "handler", ".", "exit", "(", ")", ";", "}", "}", ")", ";", "}", "this", ".", "state", "=", "new", "TransitionState", "(", ")", ";", "this", ".", "currentHandlerInfos", "=", "null", ";", "}"], "docstring": "Clears the current and target route handlers and triggers exit\non each of them starting at the leaf and traversing up through\nits ancestors.", "docstring_tokens": ["Clears", "the", "current", "and", "target", "route", "handlers", "and", "triggers", "exit", "on", "each", "of", "them", "starting", "at", "the", "leaf", "and", "traversing", "up", "through", "its", "ancestors", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L33254-L33266", "partition": "test"}
{"repo": "intelligo-systems/intelligo.js", "path": "dist/svm/SvmLinear.js", "func_name": "modelStringToModelMap", "original_string": "function modelStringToModelMap(modelString) {\n\tvar matches = LIB_LINEAR_MODEL_PATTERN.exec(modelString);\n\tif (!matches) {\n\t\tconsole.log(modelString);\n\t\tthrow new Error(\"Model does not match SVM-Linear format\");\n\t};\n\tvar labels = matches[1].split(/\\s+/);\n\tvar mapLabelToMapFeatureToWeight = {};\n\tfor (var iLabel in labels) {\n\t\tvar label = labels[iLabel];\n\t\tmapLabelToMapFeatureToWeight[label]={};\n\t}\n\n\tvar weightsMatrix = matches[3];\n\t// each line represents a feature; each column represents a label:\n\n\tvar weightsLines = weightsMatrix.split(NEWLINE);\n\tfor (var feature in weightsLines) {\n\t\tvar weights = weightsLines[feature].split(/\\s+/);\n\t\tweights.pop(); // ignore lal]st weight, which is empty (-space)\n\t\tif (weights.length==0)\n\t\t\tcontinue; // ignore empty lines\n//\t\tif (isNaN(parseFloat(weights[weights.length-1])))\n//\t\t\tweights.pop();\n\t\tif (weights.length==1 && labels.length==2)\n\t\t\tweights[1] = -weights[0];\n\t\tif (weights.length!=labels.length)\n\t\t\tthrow new Error(\"Model does not match SVM-Linear format: there are \"+labels.length+\" labels (\"+labels+\") and \"+weights.length+\" weights (\"+weights+\")\");\n\t\tfor (var iLabel in labels) {\n\t\t\tvar label = labels[iLabel];\n\t\t\tvar weight = parseFloat(weights[iLabel]);\n\t\t\tif (Math.abs(weight)>=MIN_WEIGHT)\n\t\t\t\tmapLabelToMapFeatureToWeight[label][feature]=weight;\n\t\t}\n\t}\n\n\treturn mapLabelToMapFeatureToWeight;\n}", "language": "javascript", "code": "function modelStringToModelMap(modelString) {\n\tvar matches = LIB_LINEAR_MODEL_PATTERN.exec(modelString);\n\tif (!matches) {\n\t\tconsole.log(modelString);\n\t\tthrow new Error(\"Model does not match SVM-Linear format\");\n\t};\n\tvar labels = matches[1].split(/\\s+/);\n\tvar mapLabelToMapFeatureToWeight = {};\n\tfor (var iLabel in labels) {\n\t\tvar label = labels[iLabel];\n\t\tmapLabelToMapFeatureToWeight[label]={};\n\t}\n\n\tvar weightsMatrix = matches[3];\n\t// each line represents a feature; each column represents a label:\n\n\tvar weightsLines = weightsMatrix.split(NEWLINE);\n\tfor (var feature in weightsLines) {\n\t\tvar weights = weightsLines[feature].split(/\\s+/);\n\t\tweights.pop(); // ignore lal]st weight, which is empty (-space)\n\t\tif (weights.length==0)\n\t\t\tcontinue; // ignore empty lines\n//\t\tif (isNaN(parseFloat(weights[weights.length-1])))\n//\t\t\tweights.pop();\n\t\tif (weights.length==1 && labels.length==2)\n\t\t\tweights[1] = -weights[0];\n\t\tif (weights.length!=labels.length)\n\t\t\tthrow new Error(\"Model does not match SVM-Linear format: there are \"+labels.length+\" labels (\"+labels+\") and \"+weights.length+\" weights (\"+weights+\")\");\n\t\tfor (var iLabel in labels) {\n\t\t\tvar label = labels[iLabel];\n\t\t\tvar weight = parseFloat(weights[iLabel]);\n\t\t\tif (Math.abs(weight)>=MIN_WEIGHT)\n\t\t\t\tmapLabelToMapFeatureToWeight[label][feature]=weight;\n\t\t}\n\t}\n\n\treturn mapLabelToMapFeatureToWeight;\n}", "code_tokens": ["function", "modelStringToModelMap", "(", "modelString", ")", "{", "var", "matches", "=", "LIB_LINEAR_MODEL_PATTERN", ".", "exec", "(", "modelString", ")", ";", "if", "(", "!", "matches", ")", "{", "console", ".", "log", "(", "modelString", ")", ";", "throw", "new", "Error", "(", "\"Model does not match SVM-Linear format\"", ")", ";", "}", ";", "var", "labels", "=", "matches", "[", "1", "]", ".", "split", "(", "/", "\\s+", "/", ")", ";", "var", "mapLabelToMapFeatureToWeight", "=", "{", "}", ";", "for", "(", "var", "iLabel", "in", "labels", ")", "{", "var", "label", "=", "labels", "[", "iLabel", "]", ";", "mapLabelToMapFeatureToWeight", "[", "label", "]", "=", "{", "}", ";", "}", "var", "weightsMatrix", "=", "matches", "[", "3", "]", ";", "// each line represents a feature; each column represents a label:", "var", "weightsLines", "=", "weightsMatrix", ".", "split", "(", "NEWLINE", ")", ";", "for", "(", "var", "feature", "in", "weightsLines", ")", "{", "var", "weights", "=", "weightsLines", "[", "feature", "]", ".", "split", "(", "/", "\\s+", "/", ")", ";", "weights", ".", "pop", "(", ")", ";", "// ignore lal]st weight, which is empty (-space)", "if", "(", "weights", ".", "length", "==", "0", ")", "continue", ";", "// ignore empty lines", "//\t\tif (isNaN(parseFloat(weights[weights.length-1])))", "//\t\t\tweights.pop();", "if", "(", "weights", ".", "length", "==", "1", "&&", "labels", ".", "length", "==", "2", ")", "weights", "[", "1", "]", "=", "-", "weights", "[", "0", "]", ";", "if", "(", "weights", ".", "length", "!=", "labels", ".", "length", ")", "throw", "new", "Error", "(", "\"Model does not match SVM-Linear format: there are \"", "+", "labels", ".", "length", "+", "\" labels (\"", "+", "labels", "+", "\") and \"", "+", "weights", ".", "length", "+", "\" weights (\"", "+", "weights", "+", "\")\"", ")", ";", "for", "(", "var", "iLabel", "in", "labels", ")", "{", "var", "label", "=", "labels", "[", "iLabel", "]", ";", "var", "weight", "=", "parseFloat", "(", "weights", "[", "iLabel", "]", ")", ";", "if", "(", "Math", ".", "abs", "(", "weight", ")", ">=", "MIN_WEIGHT", ")", "mapLabelToMapFeatureToWeight", "[", "label", "]", "[", "feature", "]", "=", "weight", ";", "}", "}", "return", "mapLabelToMapFeatureToWeight", ";", "}"], "docstring": "weights smaller than this are ignored, to save space \nA utility that converts a model in the SvmLinear format to a matrix of feature weights per label.\n@param modelString a string.\n@returns mapLabelToMapFeatureToWeight.", "docstring_tokens": ["weights", "smaller", "than", "this", "are", "ignored", "to", "save", "space", "A", "utility", "that", "converts", "a", "model", "in", "the", "SvmLinear", "format", "to", "a", "matrix", "of", "feature", "weights", "per", "label", "."], "sha": "9e75d48214fb41d346462f5d886bd92cc9956df6", "url": "https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/svm/SvmLinear.js#L259-L296", "partition": "test"}
{"repo": "duaraghav8/Ethlint", "path": "lib/rule-context.js", "func_name": "RuleContext", "original_string": "function RuleContext(ruleName, ruleDesc, ruleMeta, Solium) {\n    let contextObject = this;\n\n    // Set contect attribute 'options' iff options were provided.\n    ruleDesc.options && Object.assign(contextObject, { options: ruleDesc.options });\n\n    //set read-only properties of the context object\n    Object.defineProperties(contextObject, {\n\n        name: {\n            value: ruleName,\n            writable: false\t//though the default is false anyway, I think its better to express your intention clearly\n        },\n\n        meta: {\n            value: ruleDesc,\n            writable: false\n        }\n\n    });\n\n    //inherit all Solium methods which are of relevance to the rule\n    INHERITABLE_METHODS.forEach(function(methodName) {\n        contextObject [methodName] = function(s, z, a, b, o) {\t//every method will receive 5 arguments tops\n            return Solium [methodName].call(Solium, s, z, a, b, o);\n        };\n    });\n\n    /**\n     * wrapper around Solium.report () which adds some additional information to the error object\n     * @param {Object} error An object describing the lint error, sent by the rule currently running\n     */\n    contextObject.report = function(error) {\n\n        if (!isErrObjectValid(error)) {\n            throw new Error(\n                `Rule \"${ruleName}\": invalid error object was passed. AJV message:${EOL}${util.inspect(isErrObjectValid.errors)}`\n            );\n        }\n\n        Object.assign(error, { ruleName: ruleName, ruleMeta: ruleMeta, type: contextObject.meta.type });\n        Solium.report(error);\n\n    };\n}", "language": "javascript", "code": "function RuleContext(ruleName, ruleDesc, ruleMeta, Solium) {\n    let contextObject = this;\n\n    // Set contect attribute 'options' iff options were provided.\n    ruleDesc.options && Object.assign(contextObject, { options: ruleDesc.options });\n\n    //set read-only properties of the context object\n    Object.defineProperties(contextObject, {\n\n        name: {\n            value: ruleName,\n            writable: false\t//though the default is false anyway, I think its better to express your intention clearly\n        },\n\n        meta: {\n            value: ruleDesc,\n            writable: false\n        }\n\n    });\n\n    //inherit all Solium methods which are of relevance to the rule\n    INHERITABLE_METHODS.forEach(function(methodName) {\n        contextObject [methodName] = function(s, z, a, b, o) {\t//every method will receive 5 arguments tops\n            return Solium [methodName].call(Solium, s, z, a, b, o);\n        };\n    });\n\n    /**\n     * wrapper around Solium.report () which adds some additional information to the error object\n     * @param {Object} error An object describing the lint error, sent by the rule currently running\n     */\n    contextObject.report = function(error) {\n\n        if (!isErrObjectValid(error)) {\n            throw new Error(\n                `Rule \"${ruleName}\": invalid error object was passed. AJV message:${EOL}${util.inspect(isErrObjectValid.errors)}`\n            );\n        }\n\n        Object.assign(error, { ruleName: ruleName, ruleMeta: ruleMeta, type: contextObject.meta.type });\n        Solium.report(error);\n\n    };\n}", "code_tokens": ["function", "RuleContext", "(", "ruleName", ",", "ruleDesc", ",", "ruleMeta", ",", "Solium", ")", "{", "let", "contextObject", "=", "this", ";", "// Set contect attribute 'options' iff options were provided.", "ruleDesc", ".", "options", "&&", "Object", ".", "assign", "(", "contextObject", ",", "{", "options", ":", "ruleDesc", ".", "options", "}", ")", ";", "//set read-only properties of the context object", "Object", ".", "defineProperties", "(", "contextObject", ",", "{", "name", ":", "{", "value", ":", "ruleName", ",", "writable", ":", "false", "//though the default is false anyway, I think its better to express your intention clearly", "}", ",", "meta", ":", "{", "value", ":", "ruleDesc", ",", "writable", ":", "false", "}", "}", ")", ";", "//inherit all Solium methods which are of relevance to the rule", "INHERITABLE_METHODS", ".", "forEach", "(", "function", "(", "methodName", ")", "{", "contextObject", "[", "methodName", "]", "=", "function", "(", "s", ",", "z", ",", "a", ",", "b", ",", "o", ")", "{", "//every method will receive 5 arguments tops", "return", "Solium", "[", "methodName", "]", ".", "call", "(", "Solium", ",", "s", ",", "z", ",", "a", ",", "b", ",", "o", ")", ";", "}", ";", "}", ")", ";", "/**\n     * wrapper around Solium.report () which adds some additional information to the error object\n     * @param {Object} error An object describing the lint error, sent by the rule currently running\n     */", "contextObject", ".", "report", "=", "function", "(", "error", ")", "{", "if", "(", "!", "isErrObjectValid", "(", "error", ")", ")", "{", "throw", "new", "Error", "(", "`", "${", "ruleName", "}", "${", "EOL", "}", "${", "util", ".", "inspect", "(", "isErrObjectValid", ".", "errors", ")", "}", "`", ")", ";", "}", "Object", ".", "assign", "(", "error", ",", "{", "ruleName", ":", "ruleName", ",", "ruleMeta", ":", "ruleMeta", ",", "type", ":", "contextObject", ".", "meta", ".", "type", "}", ")", ";", "Solium", ".", "report", "(", "error", ")", ";", "}", ";", "}"], "docstring": "context object Constructor to set read-only properties and provide additional functionality to the rules using it\n@param {String} ruleName Name of the rule the object is for\n@param {Object} ruleDesc Description of the rule the object is for\n@param {Object} ruleMeta meta object defined inside the rule file by rule developer\n@param {Object} Solium Main Solium object from which to inherit functionality to provide to the rules", "docstring_tokens": ["context", "object", "Constructor", "to", "set", "read", "-", "only", "properties", "and", "provide", "additional", "functionality", "to", "the", "rules", "using", "it"], "sha": "7d264373709561148c7166601ac39370e78f74b1", "url": "https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/rule-context.js#L23-L67", "partition": "test"}
{"repo": "Microsoft/azure-pipelines-extensions", "path": "package.js", "func_name": "", "original_string": "function(folderName, task) {\r\n    var defer = Q.defer();\r\n\r\n    var vn = (task.name || folderName);\r\n\r\n    if (!task.id || !check.isUUID(task.id)) {\r\n        defer.reject(createError(vn + ': id is a required guid'));\r\n    };\r\n\r\n    if (!task.name || !check.isAlphanumeric(task.name)) {\r\n        defer.reject(createError(vn + ': name is a required alphanumeric string'));\r\n    }\r\n\r\n    if (!task.friendlyName || !check.isLength(task.friendlyName, 1, 40)) {\r\n        defer.reject(createError(vn + ': friendlyName is a required string <= 40 chars'));\r\n    }\r\n\r\n    if (!task.instanceNameFormat) {\r\n        defer.reject(createError(vn + ': instanceNameFormat is required'));    \r\n    }\r\n\r\n    // resolve if not already rejected\r\n    defer.resolve();\r\n    return defer.promise;\r\n}", "language": "javascript", "code": "function(folderName, task) {\r\n    var defer = Q.defer();\r\n\r\n    var vn = (task.name || folderName);\r\n\r\n    if (!task.id || !check.isUUID(task.id)) {\r\n        defer.reject(createError(vn + ': id is a required guid'));\r\n    };\r\n\r\n    if (!task.name || !check.isAlphanumeric(task.name)) {\r\n        defer.reject(createError(vn + ': name is a required alphanumeric string'));\r\n    }\r\n\r\n    if (!task.friendlyName || !check.isLength(task.friendlyName, 1, 40)) {\r\n        defer.reject(createError(vn + ': friendlyName is a required string <= 40 chars'));\r\n    }\r\n\r\n    if (!task.instanceNameFormat) {\r\n        defer.reject(createError(vn + ': instanceNameFormat is required'));    \r\n    }\r\n\r\n    // resolve if not already rejected\r\n    defer.resolve();\r\n    return defer.promise;\r\n}", "code_tokens": ["function", "(", "folderName", ",", "task", ")", "{", "var", "defer", "=", "Q", ".", "defer", "(", ")", ";", "var", "vn", "=", "(", "task", ".", "name", "||", "folderName", ")", ";", "if", "(", "!", "task", ".", "id", "||", "!", "check", ".", "isUUID", "(", "task", ".", "id", ")", ")", "{", "defer", ".", "reject", "(", "createError", "(", "vn", "+", "': id is a required guid'", ")", ")", ";", "}", ";", "if", "(", "!", "task", ".", "name", "||", "!", "check", ".", "isAlphanumeric", "(", "task", ".", "name", ")", ")", "{", "defer", ".", "reject", "(", "createError", "(", "vn", "+", "': name is a required alphanumeric string'", ")", ")", ";", "}", "if", "(", "!", "task", ".", "friendlyName", "||", "!", "check", ".", "isLength", "(", "task", ".", "friendlyName", ",", "1", ",", "40", ")", ")", "{", "defer", ".", "reject", "(", "createError", "(", "vn", "+", "': friendlyName is a required string <= 40 chars'", ")", ")", ";", "}", "if", "(", "!", "task", ".", "instanceNameFormat", ")", "{", "defer", ".", "reject", "(", "createError", "(", "vn", "+", "': instanceNameFormat is required'", ")", ")", ";", "}", "// resolve if not already rejected\r", "defer", ".", "resolve", "(", ")", ";", "return", "defer", ".", "promise", ";", "}"], "docstring": "Validates the structure of a task.json file.", "docstring_tokens": ["Validates", "the", "structure", "of", "a", "task", ".", "json", "file", "."], "sha": "be2b1c4772ec5c67958915d0f3ecb8509ea93d43", "url": "https://github.com/Microsoft/azure-pipelines-extensions/blob/be2b1c4772ec5c67958915d0f3ecb8509ea93d43/package.js#L22-L46", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "animateMove", "original_string": "function animateMove(axis) {\n    var t = animatedMove[axis];\n    var normTime = Math.min(1, Math.max((Date.now() - t.startTime) / 1000 / (t.duration / 1000), 0));\n    var result = t.startPosition + config.animationTimingFunction(normTime) * (t.endPosition - t.startPosition);\n    if ((t.endPosition > t.startPosition && result >= t.endPosition) ||\n        (t.endPosition < t.startPosition && result <= t.endPosition) ||\n        t.endPosition === t.startPosition) {\n        result = t.endPosition;\n        speed[axis] = 0;\n        delete animatedMove[axis];\n    }\n    config[axis] = result;\n}", "language": "javascript", "code": "function animateMove(axis) {\n    var t = animatedMove[axis];\n    var normTime = Math.min(1, Math.max((Date.now() - t.startTime) / 1000 / (t.duration / 1000), 0));\n    var result = t.startPosition + config.animationTimingFunction(normTime) * (t.endPosition - t.startPosition);\n    if ((t.endPosition > t.startPosition && result >= t.endPosition) ||\n        (t.endPosition < t.startPosition && result <= t.endPosition) ||\n        t.endPosition === t.startPosition) {\n        result = t.endPosition;\n        speed[axis] = 0;\n        delete animatedMove[axis];\n    }\n    config[axis] = result;\n}", "code_tokens": ["function", "animateMove", "(", "axis", ")", "{", "var", "t", "=", "animatedMove", "[", "axis", "]", ";", "var", "normTime", "=", "Math", ".", "min", "(", "1", ",", "Math", ".", "max", "(", "(", "Date", ".", "now", "(", ")", "-", "t", ".", "startTime", ")", "/", "1000", "/", "(", "t", ".", "duration", "/", "1000", ")", ",", "0", ")", ")", ";", "var", "result", "=", "t", ".", "startPosition", "+", "config", ".", "animationTimingFunction", "(", "normTime", ")", "*", "(", "t", ".", "endPosition", "-", "t", ".", "startPosition", ")", ";", "if", "(", "(", "t", ".", "endPosition", ">", "t", ".", "startPosition", "&&", "result", ">=", "t", ".", "endPosition", ")", "||", "(", "t", ".", "endPosition", "<", "t", ".", "startPosition", "&&", "result", "<=", "t", ".", "endPosition", ")", "||", "t", ".", "endPosition", "===", "t", ".", "startPosition", ")", "{", "result", "=", "t", ".", "endPosition", ";", "speed", "[", "axis", "]", "=", "0", ";", "delete", "animatedMove", "[", "axis", "]", ";", "}", "config", "[", "axis", "]", "=", "result", ";", "}"], "docstring": "Animates moves.\n@param {string} axis - Axis to animate\n@private", "docstring_tokens": ["Animates", "moves", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L1298-L1310", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/encoding.js", "func_name": "preferredEncodings", "original_string": "function preferredEncodings(accept, provided) {\n  var accepts = parseAcceptEncoding(accept || '');\n\n  if (!provided) {\n    // sorted list of all encodings\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullEncoding);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getEncodingPriority(type, accepts, index);\n  });\n\n  // sorted list of accepted encodings\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}", "language": "javascript", "code": "function preferredEncodings(accept, provided) {\n  var accepts = parseAcceptEncoding(accept || '');\n\n  if (!provided) {\n    // sorted list of all encodings\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullEncoding);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getEncodingPriority(type, accepts, index);\n  });\n\n  // sorted list of accepted encodings\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}", "code_tokens": ["function", "preferredEncodings", "(", "accept", ",", "provided", ")", "{", "var", "accepts", "=", "parseAcceptEncoding", "(", "accept", "||", "''", ")", ";", "if", "(", "!", "provided", ")", "{", "// sorted list of all encodings", "return", "accepts", ".", "filter", "(", "isQuality", ")", ".", "sort", "(", "compareSpecs", ")", ".", "map", "(", "getFullEncoding", ")", ";", "}", "var", "priorities", "=", "provided", ".", "map", "(", "function", "getPriority", "(", "type", ",", "index", ")", "{", "return", "getEncodingPriority", "(", "type", ",", "accepts", ",", "index", ")", ";", "}", ")", ";", "// sorted list of accepted encodings", "return", "priorities", ".", "filter", "(", "isQuality", ")", ".", "sort", "(", "compareSpecs", ")", ".", "map", "(", "function", "getEncoding", "(", "priority", ")", "{", "return", "provided", "[", "priorities", ".", "indexOf", "(", "priority", ")", "]", ";", "}", ")", ";", "}"], "docstring": "Get the preferred encodings from an Accept-Encoding header.\n@public", "docstring_tokens": ["Get", "the", "preferred", "encodings", "from", "an", "Accept", "-", "Encoding", "header", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/encoding.js#L138-L157", "partition": "test"}
{"repo": "db-migrate/mongodb", "path": "index.js", "func_name": "", "original_string": "function (name, callback) {\n    return this._run('insert', this.internals.migrationTable, {name: name, run_on: new Date()})\n      .nodeify(callback);\n  }", "language": "javascript", "code": "function (name, callback) {\n    return this._run('insert', this.internals.migrationTable, {name: name, run_on: new Date()})\n      .nodeify(callback);\n  }", "code_tokens": ["function", "(", "name", ",", "callback", ")", "{", "return", "this", ".", "_run", "(", "'insert'", ",", "this", ".", "internals", ".", "migrationTable", ",", "{", "name", ":", "name", ",", "run_on", ":", "new", "Date", "(", ")", "}", ")", ".", "nodeify", "(", "callback", ")", ";", "}"], "docstring": "Inserts a migration record into the migration collection\n\n@param name                - The name of the migration being run\n@param callback", "docstring_tokens": ["Inserts", "a", "migration", "record", "into", "the", "migration", "collection"], "sha": "2a1c449c15b65d64707e79c6a41f740a121d56fe", "url": "https://github.com/db-migrate/mongodb/blob/2a1c449c15b65d64707e79c6a41f740a121d56fe/index.js#L200-L203", "partition": "test"}
{"repo": "young-steveo/bottlejs", "path": "dist/bottle.js", "func_name": "setValueObject", "original_string": "function setValueObject(container, name) {\n        var nestedContainer = container[name];\n        if (!nestedContainer) {\n            nestedContainer = {};\n            defineValue.call(container, name, nestedContainer);\n        }\n        return nestedContainer;\n    }", "language": "javascript", "code": "function setValueObject(container, name) {\n        var nestedContainer = container[name];\n        if (!nestedContainer) {\n            nestedContainer = {};\n            defineValue.call(container, name, nestedContainer);\n        }\n        return nestedContainer;\n    }", "code_tokens": ["function", "setValueObject", "(", "container", ",", "name", ")", "{", "var", "nestedContainer", "=", "container", "[", "name", "]", ";", "if", "(", "!", "nestedContainer", ")", "{", "nestedContainer", "=", "{", "}", ";", "defineValue", ".", "call", "(", "container", ",", "name", ",", "nestedContainer", ")", ";", "}", "return", "nestedContainer", ";", "}"], "docstring": "Iterator for setting a plain object literal via defineValue\n\n@param Object container\n@param string name", "docstring_tokens": ["Iterator", "for", "setting", "a", "plain", "object", "literal", "via", "defineValue"], "sha": "2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51", "url": "https://github.com/young-steveo/bottlejs/blob/2e7652ac79aeafa2b51b12a7f7afcd1086ff5c51/dist/bottle.js#L320-L327", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/core/utils/Dom.js", "func_name": "", "original_string": "function(node, root) {\n\t\tvar x = 0, y = 0, parent, doc = document, nodeRect, rootRect;\n\n\t\tnode = node;\n\t\troot = root || doc.body;\n\n\t\t// Returns the x, y cordinate for an element on IE 6 and IE 7\n\t\tfunction getIEPos(node) {\n\t\t\tvar bodyElm, rect, x = 0, y = 0;\n\n\t\t\tif (node) {\n\t\t\t\trect = node.getBoundingClientRect();\n\t\t\t\tbodyElm = doc.compatMode === \"CSS1Compat\" ? doc.documentElement : doc.body;\n\t\t\t\tx = rect.left + bodyElm.scrollLeft;\n\t\t\t\ty = rect.top + bodyElm.scrollTop;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx : x,\n\t\t\t\ty : y\n\t\t\t};\n\t\t}\n\n\t\t// Use getBoundingClientRect on IE 6 and IE 7 but not on IE 8 in standards mode\n\t\tif (node && node.getBoundingClientRect && Env.browser === 'IE' && (!doc.documentMode || doc.documentMode < 8)) {\n\t\t\tnodeRect = getIEPos(node);\n\t\t\trootRect = getIEPos(root);\n\n\t\t\treturn {\n\t\t\t\tx : nodeRect.x - rootRect.x,\n\t\t\t\ty : nodeRect.y - rootRect.y\n\t\t\t};\n\t\t}\n\n\t\tparent = node;\n\t\twhile (parent && parent != root && parent.nodeType) {\n\t\t\tx += parent.offsetLeft || 0;\n\t\t\ty += parent.offsetTop || 0;\n\t\t\tparent = parent.offsetParent;\n\t\t}\n\n\t\tparent = node.parentNode;\n\t\twhile (parent && parent != root && parent.nodeType) {\n\t\t\tx -= parent.scrollLeft || 0;\n\t\t\ty -= parent.scrollTop || 0;\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\treturn {\n\t\t\tx : x,\n\t\t\ty : y\n\t\t};\n\t}", "language": "javascript", "code": "function(node, root) {\n\t\tvar x = 0, y = 0, parent, doc = document, nodeRect, rootRect;\n\n\t\tnode = node;\n\t\troot = root || doc.body;\n\n\t\t// Returns the x, y cordinate for an element on IE 6 and IE 7\n\t\tfunction getIEPos(node) {\n\t\t\tvar bodyElm, rect, x = 0, y = 0;\n\n\t\t\tif (node) {\n\t\t\t\trect = node.getBoundingClientRect();\n\t\t\t\tbodyElm = doc.compatMode === \"CSS1Compat\" ? doc.documentElement : doc.body;\n\t\t\t\tx = rect.left + bodyElm.scrollLeft;\n\t\t\t\ty = rect.top + bodyElm.scrollTop;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx : x,\n\t\t\t\ty : y\n\t\t\t};\n\t\t}\n\n\t\t// Use getBoundingClientRect on IE 6 and IE 7 but not on IE 8 in standards mode\n\t\tif (node && node.getBoundingClientRect && Env.browser === 'IE' && (!doc.documentMode || doc.documentMode < 8)) {\n\t\t\tnodeRect = getIEPos(node);\n\t\t\trootRect = getIEPos(root);\n\n\t\t\treturn {\n\t\t\t\tx : nodeRect.x - rootRect.x,\n\t\t\t\ty : nodeRect.y - rootRect.y\n\t\t\t};\n\t\t}\n\n\t\tparent = node;\n\t\twhile (parent && parent != root && parent.nodeType) {\n\t\t\tx += parent.offsetLeft || 0;\n\t\t\ty += parent.offsetTop || 0;\n\t\t\tparent = parent.offsetParent;\n\t\t}\n\n\t\tparent = node.parentNode;\n\t\twhile (parent && parent != root && parent.nodeType) {\n\t\t\tx -= parent.scrollLeft || 0;\n\t\t\ty -= parent.scrollTop || 0;\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\treturn {\n\t\t\tx : x,\n\t\t\ty : y\n\t\t};\n\t}", "code_tokens": ["function", "(", "node", ",", "root", ")", "{", "var", "x", "=", "0", ",", "y", "=", "0", ",", "parent", ",", "doc", "=", "document", ",", "nodeRect", ",", "rootRect", ";", "node", "=", "node", ";", "root", "=", "root", "||", "doc", ".", "body", ";", "// Returns the x, y cordinate for an element on IE 6 and IE 7", "function", "getIEPos", "(", "node", ")", "{", "var", "bodyElm", ",", "rect", ",", "x", "=", "0", ",", "y", "=", "0", ";", "if", "(", "node", ")", "{", "rect", "=", "node", ".", "getBoundingClientRect", "(", ")", ";", "bodyElm", "=", "doc", ".", "compatMode", "===", "\"CSS1Compat\"", "?", "doc", ".", "documentElement", ":", "doc", ".", "body", ";", "x", "=", "rect", ".", "left", "+", "bodyElm", ".", "scrollLeft", ";", "y", "=", "rect", ".", "top", "+", "bodyElm", ".", "scrollTop", ";", "}", "return", "{", "x", ":", "x", ",", "y", ":", "y", "}", ";", "}", "// Use getBoundingClientRect on IE 6 and IE 7 but not on IE 8 in standards mode", "if", "(", "node", "&&", "node", ".", "getBoundingClientRect", "&&", "Env", ".", "browser", "===", "'IE'", "&&", "(", "!", "doc", ".", "documentMode", "||", "doc", ".", "documentMode", "<", "8", ")", ")", "{", "nodeRect", "=", "getIEPos", "(", "node", ")", ";", "rootRect", "=", "getIEPos", "(", "root", ")", ";", "return", "{", "x", ":", "nodeRect", ".", "x", "-", "rootRect", ".", "x", ",", "y", ":", "nodeRect", ".", "y", "-", "rootRect", ".", "y", "}", ";", "}", "parent", "=", "node", ";", "while", "(", "parent", "&&", "parent", "!=", "root", "&&", "parent", ".", "nodeType", ")", "{", "x", "+=", "parent", ".", "offsetLeft", "||", "0", ";", "y", "+=", "parent", ".", "offsetTop", "||", "0", ";", "parent", "=", "parent", ".", "offsetParent", ";", "}", "parent", "=", "node", ".", "parentNode", ";", "while", "(", "parent", "&&", "parent", "!=", "root", "&&", "parent", ".", "nodeType", ")", "{", "x", "-=", "parent", ".", "scrollLeft", "||", "0", ";", "y", "-=", "parent", ".", "scrollTop", "||", "0", ";", "parent", "=", "parent", ".", "parentNode", ";", "}", "return", "{", "x", ":", "x", ",", "y", ":", "y", "}", ";", "}"], "docstring": "Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.\n\n@method getPos\n@static\n@param {Element} node HTML element or element id to get x, y position from.\n@param {Element} root Optional root element to stop calculations at.\n@return {object} Absolute position of the specified element object with x, y fields.", "docstring_tokens": ["Returns", "the", "absolute", "x", "y", "position", "of", "an", "Element", ".", "The", "position", "will", "be", "returned", "in", "a", "object", "with", "x", "y", "fields", "."], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Dom.js#L107-L159", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "encodeLastRecordedSourceMapSpan", "original_string": "function encodeLastRecordedSourceMapSpan() {\n                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {\n                        return;\n                    }\n                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;\n                    // Line/Comma delimiters\n                    if (lastEncodedSourceMapSpan.emittedLine === lastRecordedSourceMapSpan.emittedLine) {\n                        // Emit comma to separate the entry\n                        if (sourceMapData.sourceMapMappings) {\n                            sourceMapData.sourceMapMappings += \",\";\n                        }\n                    }\n                    else {\n                        // Emit line delimiters\n                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {\n                            sourceMapData.sourceMapMappings += \";\";\n                        }\n                        prevEncodedEmittedColumn = 1;\n                    }\n                    // 1. Relative Column 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);\n                    // 2. Relative sourceIndex\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);\n                    // 3. Relative sourceLine 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);\n                    // 4. Relative sourceColumn 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);\n                    // 5. Relative namePosition 0 based\n                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {\n                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);\n                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;\n                    }\n                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;\n                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);\n                    function base64VLQFormatEncode(inValue) {\n                        function base64FormatEncode(inValue) {\n                            if (inValue < 64) {\n                                return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(inValue);\n                            }\n                            throw TypeError(inValue + \": not a 64 based value\");\n                        }\n                        // Add a new least significant bit that has the sign of the value.\n                        // if negative number the least significant bit that gets added to the number has value 1\n                        // else least significant bit value that gets added is 0\n                        // eg. -1 changes to binary : 01 [1] => 3\n                        //     +1 changes to binary : 01 [0] => 2\n                        if (inValue < 0) {\n                            inValue = ((-inValue) << 1) + 1;\n                        }\n                        else {\n                            inValue = inValue << 1;\n                        }\n                        // Encode 5 bits at a time starting from least significant bits\n                        var encodedStr = \"\";\n                        do {\n                            var currentDigit = inValue & 31; // 11111\n                            inValue = inValue >> 5;\n                            if (inValue > 0) {\n                                // There are still more digits to decode, set the msb (6th bit)\n                                currentDigit = currentDigit | 32;\n                            }\n                            encodedStr = encodedStr + base64FormatEncode(currentDigit);\n                        } while (inValue > 0);\n                        return encodedStr;\n                    }\n                }", "language": "javascript", "code": "function encodeLastRecordedSourceMapSpan() {\n                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {\n                        return;\n                    }\n                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;\n                    // Line/Comma delimiters\n                    if (lastEncodedSourceMapSpan.emittedLine === lastRecordedSourceMapSpan.emittedLine) {\n                        // Emit comma to separate the entry\n                        if (sourceMapData.sourceMapMappings) {\n                            sourceMapData.sourceMapMappings += \",\";\n                        }\n                    }\n                    else {\n                        // Emit line delimiters\n                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {\n                            sourceMapData.sourceMapMappings += \";\";\n                        }\n                        prevEncodedEmittedColumn = 1;\n                    }\n                    // 1. Relative Column 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);\n                    // 2. Relative sourceIndex\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);\n                    // 3. Relative sourceLine 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);\n                    // 4. Relative sourceColumn 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);\n                    // 5. Relative namePosition 0 based\n                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {\n                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);\n                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;\n                    }\n                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;\n                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);\n                    function base64VLQFormatEncode(inValue) {\n                        function base64FormatEncode(inValue) {\n                            if (inValue < 64) {\n                                return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(inValue);\n                            }\n                            throw TypeError(inValue + \": not a 64 based value\");\n                        }\n                        // Add a new least significant bit that has the sign of the value.\n                        // if negative number the least significant bit that gets added to the number has value 1\n                        // else least significant bit value that gets added is 0\n                        // eg. -1 changes to binary : 01 [1] => 3\n                        //     +1 changes to binary : 01 [0] => 2\n                        if (inValue < 0) {\n                            inValue = ((-inValue) << 1) + 1;\n                        }\n                        else {\n                            inValue = inValue << 1;\n                        }\n                        // Encode 5 bits at a time starting from least significant bits\n                        var encodedStr = \"\";\n                        do {\n                            var currentDigit = inValue & 31; // 11111\n                            inValue = inValue >> 5;\n                            if (inValue > 0) {\n                                // There are still more digits to decode, set the msb (6th bit)\n                                currentDigit = currentDigit | 32;\n                            }\n                            encodedStr = encodedStr + base64FormatEncode(currentDigit);\n                        } while (inValue > 0);\n                        return encodedStr;\n                    }\n                }", "code_tokens": ["function", "encodeLastRecordedSourceMapSpan", "(", ")", "{", "if", "(", "!", "lastRecordedSourceMapSpan", "||", "lastRecordedSourceMapSpan", "===", "lastEncodedSourceMapSpan", ")", "{", "return", ";", "}", "var", "prevEncodedEmittedColumn", "=", "lastEncodedSourceMapSpan", ".", "emittedColumn", ";", "// Line/Comma delimiters", "if", "(", "lastEncodedSourceMapSpan", ".", "emittedLine", "===", "lastRecordedSourceMapSpan", ".", "emittedLine", ")", "{", "// Emit comma to separate the entry", "if", "(", "sourceMapData", ".", "sourceMapMappings", ")", "{", "sourceMapData", ".", "sourceMapMappings", "+=", "\",\"", ";", "}", "}", "else", "{", "// Emit line delimiters", "for", "(", "var", "encodedLine", "=", "lastEncodedSourceMapSpan", ".", "emittedLine", ";", "encodedLine", "<", "lastRecordedSourceMapSpan", ".", "emittedLine", ";", "encodedLine", "++", ")", "{", "sourceMapData", ".", "sourceMapMappings", "+=", "\";\"", ";", "}", "prevEncodedEmittedColumn", "=", "1", ";", "}", "// 1. Relative Column 0 based", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "emittedColumn", "-", "prevEncodedEmittedColumn", ")", ";", "// 2. Relative sourceIndex", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "sourceIndex", "-", "lastEncodedSourceMapSpan", ".", "sourceIndex", ")", ";", "// 3. Relative sourceLine 0 based", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "sourceLine", "-", "lastEncodedSourceMapSpan", ".", "sourceLine", ")", ";", "// 4. Relative sourceColumn 0 based", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "sourceColumn", "-", "lastEncodedSourceMapSpan", ".", "sourceColumn", ")", ";", "// 5. Relative namePosition 0 based", "if", "(", "lastRecordedSourceMapSpan", ".", "nameIndex", ">=", "0", ")", "{", "sourceMapData", ".", "sourceMapMappings", "+=", "base64VLQFormatEncode", "(", "lastRecordedSourceMapSpan", ".", "nameIndex", "-", "lastEncodedNameIndex", ")", ";", "lastEncodedNameIndex", "=", "lastRecordedSourceMapSpan", ".", "nameIndex", ";", "}", "lastEncodedSourceMapSpan", "=", "lastRecordedSourceMapSpan", ";", "sourceMapData", ".", "sourceMapDecodedMappings", ".", "push", "(", "lastEncodedSourceMapSpan", ")", ";", "function", "base64VLQFormatEncode", "(", "inValue", ")", "{", "function", "base64FormatEncode", "(", "inValue", ")", "{", "if", "(", "inValue", "<", "64", ")", "{", "return", "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"", ".", "charAt", "(", "inValue", ")", ";", "}", "throw", "TypeError", "(", "inValue", "+", "\": not a 64 based value\"", ")", ";", "}", "// Add a new least significant bit that has the sign of the value.", "// if negative number the least significant bit that gets added to the number has value 1", "// else least significant bit value that gets added is 0", "// eg. -1 changes to binary : 01 [1] => 3", "//     +1 changes to binary : 01 [0] => 2", "if", "(", "inValue", "<", "0", ")", "{", "inValue", "=", "(", "(", "-", "inValue", ")", "<<", "1", ")", "+", "1", ";", "}", "else", "{", "inValue", "=", "inValue", "<<", "1", ";", "}", "// Encode 5 bits at a time starting from least significant bits", "var", "encodedStr", "=", "\"\"", ";", "do", "{", "var", "currentDigit", "=", "inValue", "&", "31", ";", "// 11111", "inValue", "=", "inValue", ">>", "5", ";", "if", "(", "inValue", ">", "0", ")", "{", "// There are still more digits to decode, set the msb (6th bit)", "currentDigit", "=", "currentDigit", "|", "32", ";", "}", "encodedStr", "=", "encodedStr", "+", "base64FormatEncode", "(", "currentDigit", ")", ";", "}", "while", "(", "inValue", ">", "0", ")", ";", "return", "encodedStr", ";", "}", "}"], "docstring": "Encoding for sourcemap span", "docstring_tokens": ["Encoding", "for", "sourcemap", "span"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L29711-L29776", "partition": "test"}
{"repo": "fasttime/eslint-plugin-fasttime-rules", "path": "lib/nice-space-before-function-paren.js", "func_name": "checkFunction", "original_string": "function checkFunction(node)\n    {\n        const functionConfig = getConfigForFunction(node);\n        if (functionConfig === 'ignore')\n            return;\n        const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n        const leftToken = sourceCode.getTokenBefore(rightToken);\n        const text =\n        sourceCode\n        .text\n        .slice(leftToken.range[1], rightToken.range[0])\n        .replace(/\\/\\*[^]*?\\*\\//g, '');\n        if (astUtils.LINEBREAK_MATCHER.test(text))\n            return;\n        const hasSpacing = /\\s/.test(text);\n        if (hasSpacing && functionConfig === 'never')\n        {\n            const report =\n            {\n                node,\n                loc: leftToken.loc.end,\n                message: 'Unexpected space before function parentheses.',\n                fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]]),\n            };\n            context.report(report);\n        }\n        else if (!hasSpacing && functionConfig === 'always')\n        {\n            const report =\n            {\n                node,\n                loc: leftToken.loc.end,\n                message: 'Missing space before function parentheses.',\n                fix: fixer => fixer.insertTextAfter(leftToken, ' '),\n            };\n            context.report(report);\n        }\n    }", "language": "javascript", "code": "function checkFunction(node)\n    {\n        const functionConfig = getConfigForFunction(node);\n        if (functionConfig === 'ignore')\n            return;\n        const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n        const leftToken = sourceCode.getTokenBefore(rightToken);\n        const text =\n        sourceCode\n        .text\n        .slice(leftToken.range[1], rightToken.range[0])\n        .replace(/\\/\\*[^]*?\\*\\//g, '');\n        if (astUtils.LINEBREAK_MATCHER.test(text))\n            return;\n        const hasSpacing = /\\s/.test(text);\n        if (hasSpacing && functionConfig === 'never')\n        {\n            const report =\n            {\n                node,\n                loc: leftToken.loc.end,\n                message: 'Unexpected space before function parentheses.',\n                fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]]),\n            };\n            context.report(report);\n        }\n        else if (!hasSpacing && functionConfig === 'always')\n        {\n            const report =\n            {\n                node,\n                loc: leftToken.loc.end,\n                message: 'Missing space before function parentheses.',\n                fix: fixer => fixer.insertTextAfter(leftToken, ' '),\n            };\n            context.report(report);\n        }\n    }", "code_tokens": ["function", "checkFunction", "(", "node", ")", "{", "const", "functionConfig", "=", "getConfigForFunction", "(", "node", ")", ";", "if", "(", "functionConfig", "===", "'ignore'", ")", "return", ";", "const", "rightToken", "=", "sourceCode", ".", "getFirstToken", "(", "node", ",", "astUtils", ".", "isOpeningParenToken", ")", ";", "const", "leftToken", "=", "sourceCode", ".", "getTokenBefore", "(", "rightToken", ")", ";", "const", "text", "=", "sourceCode", ".", "text", ".", "slice", "(", "leftToken", ".", "range", "[", "1", "]", ",", "rightToken", ".", "range", "[", "0", "]", ")", ".", "replace", "(", "/", "\\/\\*[^]*?\\*\\/", "/", "g", ",", "''", ")", ";", "if", "(", "astUtils", ".", "LINEBREAK_MATCHER", ".", "test", "(", "text", ")", ")", "return", ";", "const", "hasSpacing", "=", "/", "\\s", "/", ".", "test", "(", "text", ")", ";", "if", "(", "hasSpacing", "&&", "functionConfig", "===", "'never'", ")", "{", "const", "report", "=", "{", "node", ",", "loc", ":", "leftToken", ".", "loc", ".", "end", ",", "message", ":", "'Unexpected space before function parentheses.'", ",", "fix", ":", "fixer", "=>", "fixer", ".", "removeRange", "(", "[", "leftToken", ".", "range", "[", "1", "]", ",", "rightToken", ".", "range", "[", "0", "]", "]", ")", ",", "}", ";", "context", ".", "report", "(", "report", ")", ";", "}", "else", "if", "(", "!", "hasSpacing", "&&", "functionConfig", "===", "'always'", ")", "{", "const", "report", "=", "{", "node", ",", "loc", ":", "leftToken", ".", "loc", ".", "end", ",", "message", ":", "'Missing space before function parentheses.'", ",", "fix", ":", "fixer", "=>", "fixer", ".", "insertTextAfter", "(", "leftToken", ",", "' '", ")", ",", "}", ";", "context", ".", "report", "(", "report", ")", ";", "}", "}"], "docstring": "Checks the parens of a function node.\n@param {ASTNode} node A function node.\n@returns {void}", "docstring_tokens": ["Checks", "the", "parens", "of", "a", "function", "node", "."], "sha": "57580844e4c88cb1353581a3b7281983793039aa", "url": "https://github.com/fasttime/eslint-plugin-fasttime-rules/blob/57580844e4c88cb1353581a3b7281983793039aa/lib/nice-space-before-function-paren.js#L66-L103", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/field/Checkbox.js", "func_name": "", "original_string": "function(e) {\n        var me = this,\n            oldChecked = me._checked,\n            newChecked = me.getChecked();\n\n        // only fire the event when the value changes\n        if (oldChecked != newChecked) {\n            if (newChecked) {\n                me.fireEvent('check', me, e);\n            } else {\n                me.fireEvent('uncheck', me, e);\n            }\n\n            me.fireEvent('change', me, newChecked, oldChecked);\n        }\n    }", "language": "javascript", "code": "function(e) {\n        var me = this,\n            oldChecked = me._checked,\n            newChecked = me.getChecked();\n\n        // only fire the event when the value changes\n        if (oldChecked != newChecked) {\n            if (newChecked) {\n                me.fireEvent('check', me, e);\n            } else {\n                me.fireEvent('uncheck', me, e);\n            }\n\n            me.fireEvent('change', me, newChecked, oldChecked);\n        }\n    }", "code_tokens": ["function", "(", "e", ")", "{", "var", "me", "=", "this", ",", "oldChecked", "=", "me", ".", "_checked", ",", "newChecked", "=", "me", ".", "getChecked", "(", ")", ";", "// only fire the event when the value changes", "if", "(", "oldChecked", "!=", "newChecked", ")", "{", "if", "(", "newChecked", ")", "{", "me", ".", "fireEvent", "(", "'check'", ",", "me", ",", "e", ")", ";", "}", "else", "{", "me", ".", "fireEvent", "(", "'uncheck'", ",", "me", ",", "e", ")", ";", "}", "me", ".", "fireEvent", "(", "'change'", ",", "me", ",", "newChecked", ",", "oldChecked", ")", ";", "}", "}"], "docstring": "Fires the `check` or `uncheck` event when the checked value of this component changes.\n@private", "docstring_tokens": ["Fires", "the", "check", "or", "uncheck", "event", "when", "the", "checked", "value", "of", "this", "component", "changes", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/field/Checkbox.js#L246-L261", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/data/NodeInterface.js", "func_name": "", "original_string": "function(destroy) {\n                    var me = this;\n\n                    // clear any references from the node\n                    me.parentNode = me.previousSibling = me.nextSibling = null;\n                    if (destroy) {\n                        me.firstChild = me.lastChild = null;\n                    }\n                }", "language": "javascript", "code": "function(destroy) {\n                    var me = this;\n\n                    // clear any references from the node\n                    me.parentNode = me.previousSibling = me.nextSibling = null;\n                    if (destroy) {\n                        me.firstChild = me.lastChild = null;\n                    }\n                }", "code_tokens": ["function", "(", "destroy", ")", "{", "var", "me", "=", "this", ";", "// clear any references from the node", "me", ".", "parentNode", "=", "me", ".", "previousSibling", "=", "me", ".", "nextSibling", "=", "null", ";", "if", "(", "destroy", ")", "{", "me", ".", "firstChild", "=", "me", ".", "lastChild", "=", "null", ";", "}", "}"], "docstring": "Clear the node.\n@private\n@param {Boolean} destroy `true` to destroy the node.", "docstring_tokens": ["Clear", "the", "node", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeInterface.js#L564-L572", "partition": "test"}
{"repo": "yahoo/locator", "path": "lib/bundleLocator.js", "func_name": "", "original_string": "function (res) {\n        var bundle = this._bundles[res.bundleName],\n            type = res.type,\n            subtype,\n            selector = res.selector,\n            name = res.name;\n\n        if (!bundle.resources[selector]) {\n            bundle.resources[selector] = {};\n        }\n        if (!bundle.resources[selector][type]) {\n            bundle.resources[selector][type] = {};\n        }\n        if (res.hasOwnProperty('subtype')) {\n            subtype = res.subtype;\n            if (!bundle.resources[selector][type][subtype]) {\n                bundle.resources[selector][type][subtype] = {};\n            }\n            bundle.resources[selector][type][subtype][name] = res;\n        } else {\n            bundle.resources[selector][type][name] = res;\n        }\n    }", "language": "javascript", "code": "function (res) {\n        var bundle = this._bundles[res.bundleName],\n            type = res.type,\n            subtype,\n            selector = res.selector,\n            name = res.name;\n\n        if (!bundle.resources[selector]) {\n            bundle.resources[selector] = {};\n        }\n        if (!bundle.resources[selector][type]) {\n            bundle.resources[selector][type] = {};\n        }\n        if (res.hasOwnProperty('subtype')) {\n            subtype = res.subtype;\n            if (!bundle.resources[selector][type][subtype]) {\n                bundle.resources[selector][type][subtype] = {};\n            }\n            bundle.resources[selector][type][subtype][name] = res;\n        } else {\n            bundle.resources[selector][type][name] = res;\n        }\n    }", "code_tokens": ["function", "(", "res", ")", "{", "var", "bundle", "=", "this", ".", "_bundles", "[", "res", ".", "bundleName", "]", ",", "type", "=", "res", ".", "type", ",", "subtype", ",", "selector", "=", "res", ".", "selector", ",", "name", "=", "res", ".", "name", ";", "if", "(", "!", "bundle", ".", "resources", "[", "selector", "]", ")", "{", "bundle", ".", "resources", "[", "selector", "]", "=", "{", "}", ";", "}", "if", "(", "!", "bundle", ".", "resources", "[", "selector", "]", "[", "type", "]", ")", "{", "bundle", ".", "resources", "[", "selector", "]", "[", "type", "]", "=", "{", "}", ";", "}", "if", "(", "res", ".", "hasOwnProperty", "(", "'subtype'", ")", ")", "{", "subtype", "=", "res", ".", "subtype", ";", "if", "(", "!", "bundle", ".", "resources", "[", "selector", "]", "[", "type", "]", "[", "subtype", "]", ")", "{", "bundle", ".", "resources", "[", "selector", "]", "[", "type", "]", "[", "subtype", "]", "=", "{", "}", ";", "}", "bundle", ".", "resources", "[", "selector", "]", "[", "type", "]", "[", "subtype", "]", "[", "name", "]", "=", "res", ";", "}", "else", "{", "bundle", ".", "resources", "[", "selector", "]", "[", "type", "]", "[", "name", "]", "=", "res", ";", "}", "}"], "docstring": "Handles the resource.\n@private\n@method _onResource\n@param {object} res The resource.", "docstring_tokens": ["Handles", "the", "resource", "."], "sha": "563e6d453556dd776572761bd8e002e6e1ac64b6", "url": "https://github.com/yahoo/locator/blob/563e6d453556dd776572761bd8e002e6e1ac64b6/lib/bundleLocator.js#L551-L573", "partition": "test"}
{"repo": "liabru/matter-js", "path": "src/render/Render.js", "func_name": "", "original_string": "function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    }", "language": "javascript", "code": "function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    }", "code_tokens": ["function", "(", "render", ",", "background", ")", "{", "var", "cssBackground", "=", "background", ";", "if", "(", "/", "(jpg|gif|png)$", "/", ".", "test", "(", "background", ")", ")", "cssBackground", "=", "'url('", "+", "background", "+", "')'", ";", "render", ".", "canvas", ".", "style", ".", "background", "=", "cssBackground", ";", "render", ".", "canvas", ".", "style", ".", "backgroundSize", "=", "\"contain\"", ";", "render", ".", "currentBackground", "=", "background", ";", "}"], "docstring": "Applies the background to the canvas using CSS.\n@method applyBackground\n@private\n@param {render} render\n@param {string} background", "docstring_tokens": ["Applies", "the", "background", "to", "the", "canvas", "using", "CSS", "."], "sha": "2ec247b7af1c6b5da6ee05c73274ed5822c73503", "url": "https://github.com/liabru/matter-js/blob/2ec247b7af1c6b5da6ee05c73274ed5822c73503/src/render/Render.js#L1385-L1394", "partition": "test"}
{"repo": "bvellacott/sforce-mocks", "path": "mocks.js", "func_name": "", "original_string": "function(obj) {\n\t\t\tvar schema = sforce.db.schema;\n\t\t\tvar objDesc = schema[obj.type];\n\t\t\tif(typeof objDesc === 'undefined')\n\t\t\t\tthrow 'No type exists by the name: ' + obj.type;\n\t\t\tfor(var key in obj) {\n\t\t\t\tif({ Id:false, type:true }[key])\n\t\t\t\t\tcontinue;\n\t\t\t\tvar fieldDesc = null;\n\t\t\t\tfor(var i = 0; i < objDesc.fields.length; i++) {\n\t\t\t\t\tvar fd = objDesc.fields[i];\n\t\t\t\t\tif(fd.name === key) {\n\t\t\t\t\t\tfieldDesc = fd;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fieldDesc == null)\n\t\t\t\t\tthrow 'No field exists by the name: ' + key + 'in the type: ' + obj.type;\n\t\t\t}\n\t\t}", "language": "javascript", "code": "function(obj) {\n\t\t\tvar schema = sforce.db.schema;\n\t\t\tvar objDesc = schema[obj.type];\n\t\t\tif(typeof objDesc === 'undefined')\n\t\t\t\tthrow 'No type exists by the name: ' + obj.type;\n\t\t\tfor(var key in obj) {\n\t\t\t\tif({ Id:false, type:true }[key])\n\t\t\t\t\tcontinue;\n\t\t\t\tvar fieldDesc = null;\n\t\t\t\tfor(var i = 0; i < objDesc.fields.length; i++) {\n\t\t\t\t\tvar fd = objDesc.fields[i];\n\t\t\t\t\tif(fd.name === key) {\n\t\t\t\t\t\tfieldDesc = fd;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fieldDesc == null)\n\t\t\t\t\tthrow 'No field exists by the name: ' + key + 'in the type: ' + obj.type;\n\t\t\t}\n\t\t}", "code_tokens": ["function", "(", "obj", ")", "{", "var", "schema", "=", "sforce", ".", "db", ".", "schema", ";", "var", "objDesc", "=", "schema", "[", "obj", ".", "type", "]", ";", "if", "(", "typeof", "objDesc", "===", "'undefined'", ")", "throw", "'No type exists by the name: '", "+", "obj", ".", "type", ";", "for", "(", "var", "key", "in", "obj", ")", "{", "if", "(", "{", "Id", ":", "false", ",", "type", ":", "true", "}", "[", "key", "]", ")", "continue", ";", "var", "fieldDesc", "=", "null", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "objDesc", ".", "fields", ".", "length", ";", "i", "++", ")", "{", "var", "fd", "=", "objDesc", ".", "fields", "[", "i", "]", ";", "if", "(", "fd", ".", "name", "===", "key", ")", "{", "fieldDesc", "=", "fd", ";", "break", ";", "}", "}", "if", "(", "fieldDesc", "==", "null", ")", "throw", "'No field exists by the name: '", "+", "key", "+", "'in the type: '", "+", "obj", ".", "type", ";", "}", "}"], "docstring": "Validates a given objects against the schema", "docstring_tokens": ["Validates", "a", "given", "objects", "against", "the", "schema"], "sha": "d49129d81cb41a820621a4cf38766f0e85db7f43", "url": "https://github.com/bvellacott/sforce-mocks/blob/d49129d81cb41a820621a4cf38766f0e85db7f43/mocks.js#L104-L123", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(behavior, i) {\n        var triggersHash = _.clone(_.result(behavior, 'triggers')) || {};\n  \n        triggersHash = Marionette.normalizeUIKeys(triggersHash, getBehaviorsUI(behavior));\n  \n        _.each(triggersHash, _.bind(this._setHandlerForBehavior, this, behavior, i));\n      }", "language": "javascript", "code": "function(behavior, i) {\n        var triggersHash = _.clone(_.result(behavior, 'triggers')) || {};\n  \n        triggersHash = Marionette.normalizeUIKeys(triggersHash, getBehaviorsUI(behavior));\n  \n        _.each(triggersHash, _.bind(this._setHandlerForBehavior, this, behavior, i));\n      }", "code_tokens": ["function", "(", "behavior", ",", "i", ")", "{", "var", "triggersHash", "=", "_", ".", "clone", "(", "_", ".", "result", "(", "behavior", ",", "'triggers'", ")", ")", "||", "{", "}", ";", "triggersHash", "=", "Marionette", ".", "normalizeUIKeys", "(", "triggersHash", ",", "getBehaviorsUI", "(", "behavior", ")", ")", ";", "_", ".", "each", "(", "triggersHash", ",", "_", ".", "bind", "(", "this", ".", "_setHandlerForBehavior", ",", "this", ",", "behavior", ",", "i", ")", ")", ";", "}"], "docstring": "Internal method to build all trigger handlers for a given behavior", "docstring_tokens": ["Internal", "method", "to", "build", "all", "trigger", "handlers", "for", "a", "given", "behavior"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19514-L19520", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/object-store/query-engine.js", "func_name": "prepareFilteringOptimization", "original_string": "function prepareFilteringOptimization(storages, filter) {\n  if (filter instanceof Function) {\n    for (let [keyPath, storageAndScore] of storages) {\n      storageAndScore.filter = filter\n    }\n\n    return\n  }\n\n  for (let [keyPath, storageAndScore] of storages) {\n    let normalizedFilter = normalizeFilter(filter, keyPath)\n    if (normalizedFilter instanceof Function) {\n      let isOptimizableFilter =\n          (filter instanceof Object) &&\n          !(filter instanceof Date) &&\n          !(filter instanceof Array) &&\n          !(filter instanceof IDBKeyRange)\n      if (isOptimizableFilter) {\n        let partialOptimization = partiallyOptimizeFilter(filter, keyPath)\n        storageAndScore.keyRange = partialOptimization.keyRange\n        storageAndScore.filter = partialOptimization.filter\n        if (partialOptimization.score) {\n          storageAndScore.score += 1 + partialOptimization.score\n        }\n      } else {\n        storageAndScore.filter = normalizedFilter\n      }\n    } else {\n      storageAndScore.keyRange = normalizedFilter\n      storageAndScore.score += 2\n    }\n  }\n}", "language": "javascript", "code": "function prepareFilteringOptimization(storages, filter) {\n  if (filter instanceof Function) {\n    for (let [keyPath, storageAndScore] of storages) {\n      storageAndScore.filter = filter\n    }\n\n    return\n  }\n\n  for (let [keyPath, storageAndScore] of storages) {\n    let normalizedFilter = normalizeFilter(filter, keyPath)\n    if (normalizedFilter instanceof Function) {\n      let isOptimizableFilter =\n          (filter instanceof Object) &&\n          !(filter instanceof Date) &&\n          !(filter instanceof Array) &&\n          !(filter instanceof IDBKeyRange)\n      if (isOptimizableFilter) {\n        let partialOptimization = partiallyOptimizeFilter(filter, keyPath)\n        storageAndScore.keyRange = partialOptimization.keyRange\n        storageAndScore.filter = partialOptimization.filter\n        if (partialOptimization.score) {\n          storageAndScore.score += 1 + partialOptimization.score\n        }\n      } else {\n        storageAndScore.filter = normalizedFilter\n      }\n    } else {\n      storageAndScore.keyRange = normalizedFilter\n      storageAndScore.score += 2\n    }\n  }\n}", "code_tokens": ["function", "prepareFilteringOptimization", "(", "storages", ",", "filter", ")", "{", "if", "(", "filter", "instanceof", "Function", ")", "{", "for", "(", "let", "[", "keyPath", ",", "storageAndScore", "]", "of", "storages", ")", "{", "storageAndScore", ".", "filter", "=", "filter", "}", "return", "}", "for", "(", "let", "[", "keyPath", ",", "storageAndScore", "]", "of", "storages", ")", "{", "let", "normalizedFilter", "=", "normalizeFilter", "(", "filter", ",", "keyPath", ")", "if", "(", "normalizedFilter", "instanceof", "Function", ")", "{", "let", "isOptimizableFilter", "=", "(", "filter", "instanceof", "Object", ")", "&&", "!", "(", "filter", "instanceof", "Date", ")", "&&", "!", "(", "filter", "instanceof", "Array", ")", "&&", "!", "(", "filter", "instanceof", "IDBKeyRange", ")", "if", "(", "isOptimizableFilter", ")", "{", "let", "partialOptimization", "=", "partiallyOptimizeFilter", "(", "filter", ",", "keyPath", ")", "storageAndScore", ".", "keyRange", "=", "partialOptimization", ".", "keyRange", "storageAndScore", ".", "filter", "=", "partialOptimization", ".", "filter", "if", "(", "partialOptimization", ".", "score", ")", "{", "storageAndScore", ".", "score", "+=", "1", "+", "partialOptimization", ".", "score", "}", "}", "else", "{", "storageAndScore", ".", "filter", "=", "normalizedFilter", "}", "}", "else", "{", "storageAndScore", ".", "keyRange", "=", "normalizedFilter", "storageAndScore", ".", "score", "+=", "2", "}", "}", "}"], "docstring": "Calculates the best possible filtering optimizations for the provided\nstorages, updating the provided map with optimized filtering info and\noptimization score for each storage.\n\n@param {Map<string[], {storage: AbstractReadOnlyStorage, score: number, keyRange: (undefined|IDBKeyRange), filter: ?function(*, (number|string|Date|Array)): boolean}>} storages\nMap of storage key paths to storages and information related to how\nthe query would be executed on each of them, including the\nperformance optimization score (the higher is better).\n@param {?(undefined|number|string|Date|Array|IDBKeyRange|Object<string, (number|string|Date|Array|IDBKeyRange)>|function(*, (number|string|Date|Array)): boolean)=} filter\nThe filter, restricting the records returned by this method. If a\nfunction is provided, the first argument will be set to the record\nand the second argument will be set to the primary key of the record.", "docstring_tokens": ["Calculates", "the", "best", "possible", "filtering", "optimizations", "for", "the", "provided", "storages", "updating", "the", "provided", "map", "with", "optimized", "filtering", "info", "and", "optimization", "score", "for", "each", "storage", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/object-store/query-engine.js#L404-L436", "partition": "test"}
{"repo": "jeka-kiselyov/mdict", "path": "mdict-parser.js", "func_name": "harvest", "original_string": "function harvest(outcomes) {\n    return Promise.settle(outcomes).then(function(results) {\n      if (results.length === 0) {\n        return reject(\"** NOT FOUND **\");\n      }\n      \n      var solved = [], failed = [];\n      for (var i = 0; i < results.length; i++) {\n        if (results[i].isResolved()) {\n          solved.push(results[i].value());\n        } else {\n          failed.push(results[i].reason());\n        }\n      }\n      return solved.length ? solved : failed;\n    });\n  }", "language": "javascript", "code": "function harvest(outcomes) {\n    return Promise.settle(outcomes).then(function(results) {\n      if (results.length === 0) {\n        return reject(\"** NOT FOUND **\");\n      }\n      \n      var solved = [], failed = [];\n      for (var i = 0; i < results.length; i++) {\n        if (results[i].isResolved()) {\n          solved.push(results[i].value());\n        } else {\n          failed.push(results[i].reason());\n        }\n      }\n      return solved.length ? solved : failed;\n    });\n  }", "code_tokens": ["function", "harvest", "(", "outcomes", ")", "{", "return", "Promise", ".", "settle", "(", "outcomes", ")", ".", "then", "(", "function", "(", "results", ")", "{", "if", "(", "results", ".", "length", "===", "0", ")", "{", "return", "reject", "(", "\"** NOT FOUND **\"", ")", ";", "}", "var", "solved", "=", "[", "]", ",", "failed", "=", "[", "]", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "results", ".", "length", ";", "i", "++", ")", "{", "if", "(", "results", "[", "i", "]", ".", "isResolved", "(", ")", ")", "{", "solved", ".", "push", "(", "results", "[", "i", "]", ".", "value", "(", ")", ")", ";", "}", "else", "{", "failed", ".", "push", "(", "results", "[", "i", "]", ".", "reason", "(", ")", ")", ";", "}", "}", "return", "solved", ".", "length", "?", "solved", ":", "failed", ";", "}", ")", ";", "}"], "docstring": "Harvest any resolved promises, if all failed then return reasons.", "docstring_tokens": ["Harvest", "any", "resolved", "promises", "if", "all", "failed", "then", "return", "reasons", "."], "sha": "540898e63991cb0c8985ed8fb29eb11a59f35089", "url": "https://github.com/jeka-kiselyov/mdict/blob/540898e63991cb0c8985ed8fb29eb11a59f35089/mdict-parser.js#L197-L213", "partition": "test"}
{"repo": "wavesoft/gulp-jbb-profile", "path": "lib/ProfileIndex.js", "func_name": "", "original_string": "function( name ) {\n\t\tvar id = this._properties[name];\n\t\tif (id === undefined) {\n\t\t\tif (this.shortNames) {\n\t\t\t\tid = this._properties[name] = 'p' + (this._propID++).toString()\n\t\t\t} else {\n\t\t\t\tid = this._properties[name] = 'p' + name[0].toUpperCase() +\n\t\t\t\t\tname.substr(1).toLowerCase().replace(/[,\\.\\- \\_]/g, '_')\n\t\t\t}\n\t\t}\n\t}", "language": "javascript", "code": "function( name ) {\n\t\tvar id = this._properties[name];\n\t\tif (id === undefined) {\n\t\t\tif (this.shortNames) {\n\t\t\t\tid = this._properties[name] = 'p' + (this._propID++).toString()\n\t\t\t} else {\n\t\t\t\tid = this._properties[name] = 'p' + name[0].toUpperCase() +\n\t\t\t\t\tname.substr(1).toLowerCase().replace(/[,\\.\\- \\_]/g, '_')\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["function", "(", "name", ")", "{", "var", "id", "=", "this", ".", "_properties", "[", "name", "]", ";", "if", "(", "id", "===", "undefined", ")", "{", "if", "(", "this", ".", "shortNames", ")", "{", "id", "=", "this", ".", "_properties", "[", "name", "]", "=", "'p'", "+", "(", "this", ".", "_propID", "++", ")", ".", "toString", "(", ")", "}", "else", "{", "id", "=", "this", ".", "_properties", "[", "name", "]", "=", "'p'", "+", "name", "[", "0", "]", ".", "toUpperCase", "(", ")", "+", "name", ".", "substr", "(", "1", ")", ".", "toLowerCase", "(", ")", ".", "replace", "(", "/", "[,\\.\\- \\_]", "/", "g", ",", "'_'", ")", "}", "}", "}"], "docstring": "Return the property variable name, used to optimize for size\nthe minified result.", "docstring_tokens": ["Return", "the", "property", "variable", "name", "used", "to", "optimize", "for", "size", "the", "minified", "result", "."], "sha": "3e9bc0ca733ae0325a09a461f504fc847e256f7a", "url": "https://github.com/wavesoft/gulp-jbb-profile/blob/3e9bc0ca733ae0325a09a461f504fc847e256f7a/lib/ProfileIndex.js#L112-L122", "partition": "test"}
{"repo": "taskcluster/taskcluster-lib-stats", "path": "src/stats.js", "func_name": "", "original_string": "function(handler, options) {\n  assert(handler instanceof Function, \"A handler must be provided\");\n  assert(options,                     \"options required\");\n  assert(options.drain,               \"options.drain is required\");\n  assert(options.component,           \"options.component is required\");\n\n  // Create a reporter\n  var reporter = series.HandlerReports.reporter(options.drain);\n\n  // Wrap handler and let that be it\n  return function(message) {\n    // Create most of the point\n    var point = {\n      component:      options.component,\n      duration:       undefined,\n      exchange:       message.exchange || '',\n      redelivered:    (message.redelivered ? 'true' : 'false'),\n      error:          'false'\n    };\n\n    // Start timer\n    var start = process.hrtime();\n\n    // Handle the message\n    return Promise.resolve(handler(message)).then(function() {\n      // Get duration\n      var d = process.hrtime(start);\n\n      // Convert to milliseconds\n      point.duration = d[0] * 1000 + (d[1] / 1000000);\n\n      // Send point to reporter\n      reporter(point);\n    }, function(err) {\n      // Get duration\n      var d = process.hrtime(start);\n\n      // Convert to milliseconds\n      point.duration = d[0] * 1000 + (d[1] / 1000000);\n\n      // Flag and error\n      point.error = 'true';\n\n      // Send point to reporter\n      reporter(point);\n\n      // Re-throw the error\n      throw err;\n    });\n  };\n}", "language": "javascript", "code": "function(handler, options) {\n  assert(handler instanceof Function, \"A handler must be provided\");\n  assert(options,                     \"options required\");\n  assert(options.drain,               \"options.drain is required\");\n  assert(options.component,           \"options.component is required\");\n\n  // Create a reporter\n  var reporter = series.HandlerReports.reporter(options.drain);\n\n  // Wrap handler and let that be it\n  return function(message) {\n    // Create most of the point\n    var point = {\n      component:      options.component,\n      duration:       undefined,\n      exchange:       message.exchange || '',\n      redelivered:    (message.redelivered ? 'true' : 'false'),\n      error:          'false'\n    };\n\n    // Start timer\n    var start = process.hrtime();\n\n    // Handle the message\n    return Promise.resolve(handler(message)).then(function() {\n      // Get duration\n      var d = process.hrtime(start);\n\n      // Convert to milliseconds\n      point.duration = d[0] * 1000 + (d[1] / 1000000);\n\n      // Send point to reporter\n      reporter(point);\n    }, function(err) {\n      // Get duration\n      var d = process.hrtime(start);\n\n      // Convert to milliseconds\n      point.duration = d[0] * 1000 + (d[1] / 1000000);\n\n      // Flag and error\n      point.error = 'true';\n\n      // Send point to reporter\n      reporter(point);\n\n      // Re-throw the error\n      throw err;\n    });\n  };\n}", "code_tokens": ["function", "(", "handler", ",", "options", ")", "{", "assert", "(", "handler", "instanceof", "Function", ",", "\"A handler must be provided\"", ")", ";", "assert", "(", "options", ",", "\"options required\"", ")", ";", "assert", "(", "options", ".", "drain", ",", "\"options.drain is required\"", ")", ";", "assert", "(", "options", ".", "component", ",", "\"options.component is required\"", ")", ";", "// Create a reporter", "var", "reporter", "=", "series", ".", "HandlerReports", ".", "reporter", "(", "options", ".", "drain", ")", ";", "// Wrap handler and let that be it", "return", "function", "(", "message", ")", "{", "// Create most of the point", "var", "point", "=", "{", "component", ":", "options", ".", "component", ",", "duration", ":", "undefined", ",", "exchange", ":", "message", ".", "exchange", "||", "''", ",", "redelivered", ":", "(", "message", ".", "redelivered", "?", "'true'", ":", "'false'", ")", ",", "error", ":", "'false'", "}", ";", "// Start timer", "var", "start", "=", "process", ".", "hrtime", "(", ")", ";", "// Handle the message", "return", "Promise", ".", "resolve", "(", "handler", "(", "message", ")", ")", ".", "then", "(", "function", "(", ")", "{", "// Get duration", "var", "d", "=", "process", ".", "hrtime", "(", "start", ")", ";", "// Convert to milliseconds", "point", ".", "duration", "=", "d", "[", "0", "]", "*", "1000", "+", "(", "d", "[", "1", "]", "/", "1000000", ")", ";", "// Send point to reporter", "reporter", "(", "point", ")", ";", "}", ",", "function", "(", "err", ")", "{", "// Get duration", "var", "d", "=", "process", ".", "hrtime", "(", "start", ")", ";", "// Convert to milliseconds", "point", ".", "duration", "=", "d", "[", "0", "]", "*", "1000", "+", "(", "d", "[", "1", "]", "/", "1000000", ")", ";", "// Flag and error", "point", ".", "error", "=", "'true'", ";", "// Send point to reporter", "reporter", "(", "point", ")", ";", "// Re-throw the error", "throw", "err", ";", "}", ")", ";", "}", ";", "}"], "docstring": "Create a handler timer for AMQP messages received through\ntaskcluster-client. Please note, that this relies on that messages format.\n\noptions:\n{\ndrain:        new Influx(...),  // Place to send events\ncomponent:    'queue'           // Identifier for taskcluster component\n}", "docstring_tokens": ["Create", "a", "handler", "timer", "for", "AMQP", "messages", "received", "through", "taskcluster", "-", "client", ".", "Please", "note", "that", "this", "relies", "on", "that", "messages", "format", "."], "sha": "1760c7037a07f0a4a715c6aa93475209f8bcbfc6", "url": "https://github.com/taskcluster/taskcluster-lib-stats/blob/1760c7037a07f0a4a715c6aa93475209f8bcbfc6/src/stats.js#L315-L365", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/async/index.js", "func_name": "Notifier", "original_string": "function Notifier () {\n\n  // Create the serial execution context mechanism.\n  this.csFactory = createLockFactory();\n\n  // The private files collection\n  // Contains a file and timer: \"filename\": {timer: timerid}\n  // Used for tracking work left to do. When empty, work is done.\n  this.files = {};\n\n  // Contains files successfully processed\n  this.filesDone = [];\n\n  // Contains files unsuccessfully processed\n  this.filesNotDone = [];\n\n  // true if a timeout occurred, or set by abort\n  this.errors = [];\n\n  // the holder of the current failure timeout padding\n  this.padTimeout = TIMEOUT_PAD_FLOOR;\n\n  // our reference to the listener\n  this.callback = null;\n\n  // our reference to the watcher (an interval id)\n  // initial value undefined is important\n  // this.watcher;\n\n  // the working pollInterval for this run\n  // this.interval\n\n  // flag set by qEmpty callback\n  // when the last item from the queue is given to a worker\n  this.qempty = false;\n}", "language": "javascript", "code": "function Notifier () {\n\n  // Create the serial execution context mechanism.\n  this.csFactory = createLockFactory();\n\n  // The private files collection\n  // Contains a file and timer: \"filename\": {timer: timerid}\n  // Used for tracking work left to do. When empty, work is done.\n  this.files = {};\n\n  // Contains files successfully processed\n  this.filesDone = [];\n\n  // Contains files unsuccessfully processed\n  this.filesNotDone = [];\n\n  // true if a timeout occurred, or set by abort\n  this.errors = [];\n\n  // the holder of the current failure timeout padding\n  this.padTimeout = TIMEOUT_PAD_FLOOR;\n\n  // our reference to the listener\n  this.callback = null;\n\n  // our reference to the watcher (an interval id)\n  // initial value undefined is important\n  // this.watcher;\n\n  // the working pollInterval for this run\n  // this.interval\n\n  // flag set by qEmpty callback\n  // when the last item from the queue is given to a worker\n  this.qempty = false;\n}", "code_tokens": ["function", "Notifier", "(", ")", "{", "// Create the serial execution context mechanism.", "this", ".", "csFactory", "=", "createLockFactory", "(", ")", ";", "// The private files collection", "// Contains a file and timer: \"filename\": {timer: timerid}", "// Used for tracking work left to do. When empty, work is done.", "this", ".", "files", "=", "{", "}", ";", "// Contains files successfully processed", "this", ".", "filesDone", "=", "[", "]", ";", "// Contains files unsuccessfully processed", "this", ".", "filesNotDone", "=", "[", "]", ";", "// true if a timeout occurred, or set by abort", "this", ".", "errors", "=", "[", "]", ";", "// the holder of the current failure timeout padding", "this", ".", "padTimeout", "=", "TIMEOUT_PAD_FLOOR", ";", "// our reference to the listener", "this", ".", "callback", "=", "null", ";", "// our reference to the watcher (an interval id)", "// initial value undefined is important", "// this.watcher;", "// the working pollInterval for this run", "// this.interval", "// flag set by qEmpty callback", "// when the last item from the queue is given to a worker", "this", ".", "qempty", "=", "false", ";", "}"], "docstring": "Notifier Constructor\nPolls the outputDir and when all the files exist,\ncalls the listener indicating the snapshots are done.", "docstring_tokens": ["Notifier", "Constructor", "Polls", "the", "outputDir", "and", "when", "all", "the", "files", "exist", "calls", "the", "listener", "indicating", "the", "snapshots", "are", "done", "."], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/async/index.js#L56-L91", "partition": "test"}
{"repo": "johnspackman/chrome-remote-multiplex", "path": "dist/multiplex.js", "func_name": "copyToClient", "original_string": "function copyToClient(req, res) {\n        return httpGet({\n          hostname: t.options.remoteClientHostname,\n          port: t.options.remoteClientPort,\n          path: req.originalUrl,\n          method: 'GET'\n        }).then(function (obj) {\n          var contentType = getContentType(obj.response);\n          if (contentType) res.set(\"Content-Type\", contentType);\n          res.send(obj.data);\n        });\n      }", "language": "javascript", "code": "function copyToClient(req, res) {\n        return httpGet({\n          hostname: t.options.remoteClientHostname,\n          port: t.options.remoteClientPort,\n          path: req.originalUrl,\n          method: 'GET'\n        }).then(function (obj) {\n          var contentType = getContentType(obj.response);\n          if (contentType) res.set(\"Content-Type\", contentType);\n          res.send(obj.data);\n        });\n      }", "code_tokens": ["function", "copyToClient", "(", "req", ",", "res", ")", "{", "return", "httpGet", "(", "{", "hostname", ":", "t", ".", "options", ".", "remoteClientHostname", ",", "port", ":", "t", ".", "options", ".", "remoteClientPort", ",", "path", ":", "req", ".", "originalUrl", ",", "method", ":", "'GET'", "}", ")", ".", "then", "(", "function", "(", "obj", ")", "{", "var", "contentType", "=", "getContentType", "(", "obj", ".", "response", ")", ";", "if", "(", "contentType", ")", "res", ".", "set", "(", "\"Content-Type\"", ",", "contentType", ")", ";", "res", ".", "send", "(", "obj", ".", "data", ")", ";", "}", ")", ";", "}"], "docstring": "Gets data from the remote server and copies it to the client", "docstring_tokens": ["Gets", "data", "from", "the", "remote", "server", "and", "copies", "it", "to", "the", "client"], "sha": "b4588e7411a6438a31c75ac7e01c55abdde3b95d", "url": "https://github.com/johnspackman/chrome-remote-multiplex/blob/b4588e7411a6438a31c75ac7e01c55abdde3b95d/dist/multiplex.js#L706-L717", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "spec/helpers/various-utils.js", "func_name": "dashedKeyAlternatives", "original_string": "function dashedKeyAlternatives ( hash ) {\n    var keys = _.keys( toDashedProperties( hash ) );\n    return _.filter( keys, function ( key ) {\n            return key.search(/[^-]-[a-z]/) !== -1;\n        } );\n}", "language": "javascript", "code": "function dashedKeyAlternatives ( hash ) {\n    var keys = _.keys( toDashedProperties( hash ) );\n    return _.filter( keys, function ( key ) {\n            return key.search(/[^-]-[a-z]/) !== -1;\n        } );\n}", "code_tokens": ["function", "dashedKeyAlternatives", "(", "hash", ")", "{", "var", "keys", "=", "_", ".", "keys", "(", "toDashedProperties", "(", "hash", ")", ")", ";", "return", "_", ".", "filter", "(", "keys", ",", "function", "(", "key", ")", "{", "return", "key", ".", "search", "(", "/", "[^-]-[a-z]", "/", ")", "!==", "-", "1", ";", "}", ")", ";", "}"], "docstring": "Returns an array of dashed key names, which are the alternative names for all camel-cased key names in a hash.\n\nSimple key names (not camel-cased) are ignored and don't show up in the array.\n\nE.g., dashedKeyAlternatives( { foo: \"whatever\", barBaz: \"whatever\" } ) returns [ \"bar-baz\" ].\n\n@param   {Object} hash\n@returns {string[]}", "docstring_tokens": ["Returns", "an", "array", "of", "dashed", "key", "names", "which", "are", "the", "alternative", "names", "for", "all", "camel", "-", "cased", "key", "names", "in", "a", "hash", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/spec/helpers/various-utils.js#L182-L187", "partition": "test"}
{"repo": "intelligo-systems/intelligo.js", "path": "features/FeatureLookupTable.js", "func_name": "", "original_string": "function(feature) {\n\t\tif (!(feature in this.featureNameToFeatureIndex)) {\n\t\t\tvar newIndex = this.featureIndexToFeatureName.length;\n\t\t\tthis.featureIndexToFeatureName.push(feature);\n\t\t\tthis.featureNameToFeatureIndex[feature] = newIndex;\n\t\t}\n\t}", "language": "javascript", "code": "function(feature) {\n\t\tif (!(feature in this.featureNameToFeatureIndex)) {\n\t\t\tvar newIndex = this.featureIndexToFeatureName.length;\n\t\t\tthis.featureIndexToFeatureName.push(feature);\n\t\t\tthis.featureNameToFeatureIndex[feature] = newIndex;\n\t\t}\n\t}", "code_tokens": ["function", "(", "feature", ")", "{", "if", "(", "!", "(", "feature", "in", "this", ".", "featureNameToFeatureIndex", ")", ")", "{", "var", "newIndex", "=", "this", ".", "featureIndexToFeatureName", ".", "length", ";", "this", ".", "featureIndexToFeatureName", ".", "push", "(", "feature", ")", ";", "this", ".", "featureNameToFeatureIndex", "[", "feature", "]", "=", "newIndex", ";", "}", "}"], "docstring": "add a single feature, if it does not exist", "docstring_tokens": ["add", "a", "single", "feature", "if", "it", "does", "not", "exist"], "sha": "9e75d48214fb41d346462f5d886bd92cc9956df6", "url": "https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/features/FeatureLookupTable.js#L13-L19", "partition": "test"}
{"repo": "joyent/node-ldapjs", "path": "lib/client/client.js", "func_name": "RequestQueue", "original_string": "function RequestQueue(opts) {\n  if (!opts || typeof (opts) !== 'object') {\n    opts = {};\n  }\n  this.size = (opts.size > 0) ? opts.size : Infinity;\n  this.timeout = (opts.timeout > 0) ? opts.timeout : 0;\n  this._queue = [];\n  this._timer = null;\n  this._frozen = false;\n}", "language": "javascript", "code": "function RequestQueue(opts) {\n  if (!opts || typeof (opts) !== 'object') {\n    opts = {};\n  }\n  this.size = (opts.size > 0) ? opts.size : Infinity;\n  this.timeout = (opts.timeout > 0) ? opts.timeout : 0;\n  this._queue = [];\n  this._timer = null;\n  this._frozen = false;\n}", "code_tokens": ["function", "RequestQueue", "(", "opts", ")", "{", "if", "(", "!", "opts", "||", "typeof", "(", "opts", ")", "!==", "'object'", ")", "{", "opts", "=", "{", "}", ";", "}", "this", ".", "size", "=", "(", "opts", ".", "size", ">", "0", ")", "?", "opts", ".", "size", ":", "Infinity", ";", "this", ".", "timeout", "=", "(", "opts", ".", "timeout", ">", "0", ")", "?", "opts", ".", "timeout", ":", "0", ";", "this", ".", "_queue", "=", "[", "]", ";", "this", ".", "_timer", "=", "null", ";", "this", ".", "_frozen", "=", "false", ";", "}"], "docstring": "Queue to contain LDAP requests.\n\n@param {Object} opts queue options\n\nAccepted Options:\n- size: Maximum queue size\n- timeout: Set timeout between first queue insertion and queue flush.", "docstring_tokens": ["Queue", "to", "contain", "LDAP", "requests", "."], "sha": "ad451edc18d7768c3ddee1a1dd472d2bbafdae5e", "url": "https://github.com/joyent/node-ldapjs/blob/ad451edc18d7768c3ddee1a1dd472d2bbafdae5e/lib/client/client.js#L104-L113", "partition": "test"}
{"repo": "MicroMinion/mm-services-kademlia", "path": "src/kad/rpc.js", "func_name": "RPC", "original_string": "function RPC (contact, options) {\n  assert(this instanceof RPC, 'Invalid instance supplied')\n  assert(contact instanceof Contact, 'Invalid contact was supplied')\n\n  events.EventEmitter.call(this)\n\n  options = options || {}\n\n  if (options.replyto) {\n    assert(options.replyto instanceof Contact, 'Invalid contact was supplied')\n  }\n\n  this._hooks = {\n    before: {},\n    after: {}\n  }\n  this._pendingCalls = {}\n  this._contact = options.replyto || contact\n  this._log = options && options.logger\n  this.readyState = 0\n\n  this.open()\n}", "language": "javascript", "code": "function RPC (contact, options) {\n  assert(this instanceof RPC, 'Invalid instance supplied')\n  assert(contact instanceof Contact, 'Invalid contact was supplied')\n\n  events.EventEmitter.call(this)\n\n  options = options || {}\n\n  if (options.replyto) {\n    assert(options.replyto instanceof Contact, 'Invalid contact was supplied')\n  }\n\n  this._hooks = {\n    before: {},\n    after: {}\n  }\n  this._pendingCalls = {}\n  this._contact = options.replyto || contact\n  this._log = options && options.logger\n  this.readyState = 0\n\n  this.open()\n}", "code_tokens": ["function", "RPC", "(", "contact", ",", "options", ")", "{", "assert", "(", "this", "instanceof", "RPC", ",", "'Invalid instance supplied'", ")", "assert", "(", "contact", "instanceof", "Contact", ",", "'Invalid contact was supplied'", ")", "events", ".", "EventEmitter", ".", "call", "(", "this", ")", "options", "=", "options", "||", "{", "}", "if", "(", "options", ".", "replyto", ")", "{", "assert", "(", "options", ".", "replyto", "instanceof", "Contact", ",", "'Invalid contact was supplied'", ")", "}", "this", ".", "_hooks", "=", "{", "before", ":", "{", "}", ",", "after", ":", "{", "}", "}", "this", ".", "_pendingCalls", "=", "{", "}", "this", ".", "_contact", "=", "options", ".", "replyto", "||", "contact", "this", ".", "_log", "=", "options", "&&", "options", ".", "logger", "this", ".", "readyState", "=", "0", "this", ".", "open", "(", ")", "}"], "docstring": "Represents an RPC interface\n@constructor\n@param {Contact} contact - Your node's {@link Contact} information\n@param {Object} options\n@param {Contact} options.replyto - Optional alternate public contact\n@param {Logger} options.logger - Logger instance to use\n@property {Number} readyState - Closed: 0, Transitioning: 1, Open: 2", "docstring_tokens": ["Represents", "an", "RPC", "interface"], "sha": "05792cbc0351ab7d5ca3491cb0a7ff83a95c3407", "url": "https://github.com/MicroMinion/mm-services-kademlia/blob/05792cbc0351ab7d5ca3491cb0a7ff83a95c3407/src/kad/rpc.js#L20-L42", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "loadScene", "original_string": "function loadScene(sceneId, targetPitch, targetYaw, targetHfov, fadeDone) {\n    loaded = false;\n    animatedMove = {};\n    \n    // Set up fade if specified\n    var fadeImg, workingPitch, workingYaw, workingHfov;\n    if (config.sceneFadeDuration && !fadeDone) {\n        var data = renderer.render(config.pitch * Math.PI / 180, config.yaw * Math.PI / 180, config.hfov * Math.PI / 180, {returnImage: true});\n        if (data !== undefined) {\n            fadeImg = new Image();\n            fadeImg.className = 'pnlm-fade-img';\n            fadeImg.style.transition = 'opacity ' + (config.sceneFadeDuration / 1000) + 's';\n            fadeImg.style.width = '100%';\n            fadeImg.style.height = '100%';\n            fadeImg.onload = function() {\n                loadScene(sceneId, targetPitch, targetYaw, targetHfov, true);\n            };\n            fadeImg.src = data;\n            renderContainer.appendChild(fadeImg);\n            renderer.fadeImg = fadeImg;\n            return;\n        }\n    }\n    \n    // Set new pointing\n    if (targetPitch === 'same') {\n        workingPitch = config.pitch;\n    } else {\n        workingPitch = targetPitch;\n    }\n    if (targetYaw === 'same') {\n        workingYaw = config.yaw;\n    } else if (targetYaw === 'sameAzimuth') {\n        workingYaw = config.yaw + (config.northOffset || 0) - (initialConfig.scenes[sceneId].northOffset || 0);\n    } else {\n        workingYaw = targetYaw;\n    }\n    if (targetHfov === 'same') {\n        workingHfov = config.hfov;\n    } else {\n        workingHfov = targetHfov;\n    }\n    \n    // Destroy hot spots from previous scene\n    destroyHotSpots();\n    \n    // Create the new config for the scene\n    mergeConfig(sceneId);\n\n    // Stop motion\n    speed.yaw = speed.pitch = speed.hfov = 0;\n\n    // Reload scene\n    processOptions();\n    if (workingPitch !== undefined) {\n        config.pitch = workingPitch;\n    }\n    if (workingYaw !== undefined) {\n        config.yaw = workingYaw;\n    }\n    if (workingHfov !== undefined) {\n        config.hfov = workingHfov;\n    }\n    fireEvent('scenechange', sceneId);\n    load();\n\n    // Properly handle switching to dynamic scenes\n    update = config.dynamicUpdate === true;\n    if (config.dynamic) {\n        panoImage = config.panorama;\n        onImageLoad();\n    }\n}", "language": "javascript", "code": "function loadScene(sceneId, targetPitch, targetYaw, targetHfov, fadeDone) {\n    loaded = false;\n    animatedMove = {};\n    \n    // Set up fade if specified\n    var fadeImg, workingPitch, workingYaw, workingHfov;\n    if (config.sceneFadeDuration && !fadeDone) {\n        var data = renderer.render(config.pitch * Math.PI / 180, config.yaw * Math.PI / 180, config.hfov * Math.PI / 180, {returnImage: true});\n        if (data !== undefined) {\n            fadeImg = new Image();\n            fadeImg.className = 'pnlm-fade-img';\n            fadeImg.style.transition = 'opacity ' + (config.sceneFadeDuration / 1000) + 's';\n            fadeImg.style.width = '100%';\n            fadeImg.style.height = '100%';\n            fadeImg.onload = function() {\n                loadScene(sceneId, targetPitch, targetYaw, targetHfov, true);\n            };\n            fadeImg.src = data;\n            renderContainer.appendChild(fadeImg);\n            renderer.fadeImg = fadeImg;\n            return;\n        }\n    }\n    \n    // Set new pointing\n    if (targetPitch === 'same') {\n        workingPitch = config.pitch;\n    } else {\n        workingPitch = targetPitch;\n    }\n    if (targetYaw === 'same') {\n        workingYaw = config.yaw;\n    } else if (targetYaw === 'sameAzimuth') {\n        workingYaw = config.yaw + (config.northOffset || 0) - (initialConfig.scenes[sceneId].northOffset || 0);\n    } else {\n        workingYaw = targetYaw;\n    }\n    if (targetHfov === 'same') {\n        workingHfov = config.hfov;\n    } else {\n        workingHfov = targetHfov;\n    }\n    \n    // Destroy hot spots from previous scene\n    destroyHotSpots();\n    \n    // Create the new config for the scene\n    mergeConfig(sceneId);\n\n    // Stop motion\n    speed.yaw = speed.pitch = speed.hfov = 0;\n\n    // Reload scene\n    processOptions();\n    if (workingPitch !== undefined) {\n        config.pitch = workingPitch;\n    }\n    if (workingYaw !== undefined) {\n        config.yaw = workingYaw;\n    }\n    if (workingHfov !== undefined) {\n        config.hfov = workingHfov;\n    }\n    fireEvent('scenechange', sceneId);\n    load();\n\n    // Properly handle switching to dynamic scenes\n    update = config.dynamicUpdate === true;\n    if (config.dynamic) {\n        panoImage = config.panorama;\n        onImageLoad();\n    }\n}", "code_tokens": ["function", "loadScene", "(", "sceneId", ",", "targetPitch", ",", "targetYaw", ",", "targetHfov", ",", "fadeDone", ")", "{", "loaded", "=", "false", ";", "animatedMove", "=", "{", "}", ";", "// Set up fade if specified", "var", "fadeImg", ",", "workingPitch", ",", "workingYaw", ",", "workingHfov", ";", "if", "(", "config", ".", "sceneFadeDuration", "&&", "!", "fadeDone", ")", "{", "var", "data", "=", "renderer", ".", "render", "(", "config", ".", "pitch", "*", "Math", ".", "PI", "/", "180", ",", "config", ".", "yaw", "*", "Math", ".", "PI", "/", "180", ",", "config", ".", "hfov", "*", "Math", ".", "PI", "/", "180", ",", "{", "returnImage", ":", "true", "}", ")", ";", "if", "(", "data", "!==", "undefined", ")", "{", "fadeImg", "=", "new", "Image", "(", ")", ";", "fadeImg", ".", "className", "=", "'pnlm-fade-img'", ";", "fadeImg", ".", "style", ".", "transition", "=", "'opacity '", "+", "(", "config", ".", "sceneFadeDuration", "/", "1000", ")", "+", "'s'", ";", "fadeImg", ".", "style", ".", "width", "=", "'100%'", ";", "fadeImg", ".", "style", ".", "height", "=", "'100%'", ";", "fadeImg", ".", "onload", "=", "function", "(", ")", "{", "loadScene", "(", "sceneId", ",", "targetPitch", ",", "targetYaw", ",", "targetHfov", ",", "true", ")", ";", "}", ";", "fadeImg", ".", "src", "=", "data", ";", "renderContainer", ".", "appendChild", "(", "fadeImg", ")", ";", "renderer", ".", "fadeImg", "=", "fadeImg", ";", "return", ";", "}", "}", "// Set new pointing", "if", "(", "targetPitch", "===", "'same'", ")", "{", "workingPitch", "=", "config", ".", "pitch", ";", "}", "else", "{", "workingPitch", "=", "targetPitch", ";", "}", "if", "(", "targetYaw", "===", "'same'", ")", "{", "workingYaw", "=", "config", ".", "yaw", ";", "}", "else", "if", "(", "targetYaw", "===", "'sameAzimuth'", ")", "{", "workingYaw", "=", "config", ".", "yaw", "+", "(", "config", ".", "northOffset", "||", "0", ")", "-", "(", "initialConfig", ".", "scenes", "[", "sceneId", "]", ".", "northOffset", "||", "0", ")", ";", "}", "else", "{", "workingYaw", "=", "targetYaw", ";", "}", "if", "(", "targetHfov", "===", "'same'", ")", "{", "workingHfov", "=", "config", ".", "hfov", ";", "}", "else", "{", "workingHfov", "=", "targetHfov", ";", "}", "// Destroy hot spots from previous scene", "destroyHotSpots", "(", ")", ";", "// Create the new config for the scene", "mergeConfig", "(", "sceneId", ")", ";", "// Stop motion", "speed", ".", "yaw", "=", "speed", ".", "pitch", "=", "speed", ".", "hfov", "=", "0", ";", "// Reload scene", "processOptions", "(", ")", ";", "if", "(", "workingPitch", "!==", "undefined", ")", "{", "config", ".", "pitch", "=", "workingPitch", ";", "}", "if", "(", "workingYaw", "!==", "undefined", ")", "{", "config", ".", "yaw", "=", "workingYaw", ";", "}", "if", "(", "workingHfov", "!==", "undefined", ")", "{", "config", ".", "hfov", "=", "workingHfov", ";", "}", "fireEvent", "(", "'scenechange'", ",", "sceneId", ")", ";", "load", "(", ")", ";", "// Properly handle switching to dynamic scenes", "update", "=", "config", ".", "dynamicUpdate", "===", "true", ";", "if", "(", "config", ".", "dynamic", ")", "{", "panoImage", "=", "config", ".", "panorama", ";", "onImageLoad", "(", ")", ";", "}", "}"], "docstring": "Loads scene.\n@private\n@param {string} sceneId - Identifier of scene configuration to merge in.\n@param {number} targetPitch - Pitch viewer should be centered on once scene loads.\n@param {number} targetYaw - Yaw viewer should be centered on once scene loads.\n@param {number} targetHfov - HFOV viewer should use once scene loads.\n@param {boolean} [fadeDone] - If `true`, fade setup is skipped.", "docstring_tokens": ["Loads", "scene", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L2229-L2301", "partition": "test"}
{"repo": "hbouvier/node-tts", "path": "swagger-ui/lib/shred.bundle.js", "func_name": "", "original_string": "function(options) {\n            // Prepare chars if needed\n            if (!options.chars || (options.chars.length !== 128 && options.chars.length !== 256))\n                throw new Error(\"Encoding '\"+options.type+\"' has incorrect 'chars' (must be of len 128 or 256)\");\n            \n            if (options.chars.length === 128)\n                options.chars = asciiString + options.chars;\n            \n            if (!options.charsBuf) {\n                options.charsBuf = new Buffer(options.chars, 'ucs2');\n            }\n            \n            if (!options.revCharsBuf) {\n                options.revCharsBuf = new Buffer(65536);\n                var defChar = iconv.defaultCharSingleByte.charCodeAt(0);\n                for (var i = 0; i < options.revCharsBuf.length; i++)\n                    options.revCharsBuf[i] = defChar;\n                for (var i = 0; i < options.chars.length; i++)\n                    options.revCharsBuf[options.chars.charCodeAt(i)] = i;\n            }\n            \n            return {\n                toEncoding: function(str) {\n                    str = ensureString(str);\n                    \n                    var buf = new Buffer(str.length);\n                    var revCharsBuf = options.revCharsBuf;\n                    for (var i = 0; i < str.length; i++)\n                        buf[i] = revCharsBuf[str.charCodeAt(i)];\n                    \n                    return buf;\n                },\n                fromEncoding: function(buf) {\n                    buf = ensureBuffer(buf);\n                    \n                    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n                    var charsBuf = options.charsBuf;\n                    var newBuf = new Buffer(buf.length*2);\n                    var idx1 = 0, idx2 = 0;\n                    for (var i = 0, _len = buf.length; i < _len; i++) {\n                        idx1 = buf[i]*2; idx2 = i*2;\n                        newBuf[idx2] = charsBuf[idx1];\n                        newBuf[idx2+1] = charsBuf[idx1+1];\n                    }\n                    return newBuf.toString('ucs2');\n                }\n            };\n        }", "language": "javascript", "code": "function(options) {\n            // Prepare chars if needed\n            if (!options.chars || (options.chars.length !== 128 && options.chars.length !== 256))\n                throw new Error(\"Encoding '\"+options.type+\"' has incorrect 'chars' (must be of len 128 or 256)\");\n            \n            if (options.chars.length === 128)\n                options.chars = asciiString + options.chars;\n            \n            if (!options.charsBuf) {\n                options.charsBuf = new Buffer(options.chars, 'ucs2');\n            }\n            \n            if (!options.revCharsBuf) {\n                options.revCharsBuf = new Buffer(65536);\n                var defChar = iconv.defaultCharSingleByte.charCodeAt(0);\n                for (var i = 0; i < options.revCharsBuf.length; i++)\n                    options.revCharsBuf[i] = defChar;\n                for (var i = 0; i < options.chars.length; i++)\n                    options.revCharsBuf[options.chars.charCodeAt(i)] = i;\n            }\n            \n            return {\n                toEncoding: function(str) {\n                    str = ensureString(str);\n                    \n                    var buf = new Buffer(str.length);\n                    var revCharsBuf = options.revCharsBuf;\n                    for (var i = 0; i < str.length; i++)\n                        buf[i] = revCharsBuf[str.charCodeAt(i)];\n                    \n                    return buf;\n                },\n                fromEncoding: function(buf) {\n                    buf = ensureBuffer(buf);\n                    \n                    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n                    var charsBuf = options.charsBuf;\n                    var newBuf = new Buffer(buf.length*2);\n                    var idx1 = 0, idx2 = 0;\n                    for (var i = 0, _len = buf.length; i < _len; i++) {\n                        idx1 = buf[i]*2; idx2 = i*2;\n                        newBuf[idx2] = charsBuf[idx1];\n                        newBuf[idx2+1] = charsBuf[idx1+1];\n                    }\n                    return newBuf.toString('ucs2');\n                }\n            };\n        }", "code_tokens": ["function", "(", "options", ")", "{", "// Prepare chars if needed", "if", "(", "!", "options", ".", "chars", "||", "(", "options", ".", "chars", ".", "length", "!==", "128", "&&", "options", ".", "chars", ".", "length", "!==", "256", ")", ")", "throw", "new", "Error", "(", "\"Encoding '\"", "+", "options", ".", "type", "+", "\"' has incorrect 'chars' (must be of len 128 or 256)\"", ")", ";", "if", "(", "options", ".", "chars", ".", "length", "===", "128", ")", "options", ".", "chars", "=", "asciiString", "+", "options", ".", "chars", ";", "if", "(", "!", "options", ".", "charsBuf", ")", "{", "options", ".", "charsBuf", "=", "new", "Buffer", "(", "options", ".", "chars", ",", "'ucs2'", ")", ";", "}", "if", "(", "!", "options", ".", "revCharsBuf", ")", "{", "options", ".", "revCharsBuf", "=", "new", "Buffer", "(", "65536", ")", ";", "var", "defChar", "=", "iconv", ".", "defaultCharSingleByte", ".", "charCodeAt", "(", "0", ")", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "options", ".", "revCharsBuf", ".", "length", ";", "i", "++", ")", "options", ".", "revCharsBuf", "[", "i", "]", "=", "defChar", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "options", ".", "chars", ".", "length", ";", "i", "++", ")", "options", ".", "revCharsBuf", "[", "options", ".", "chars", ".", "charCodeAt", "(", "i", ")", "]", "=", "i", ";", "}", "return", "{", "toEncoding", ":", "function", "(", "str", ")", "{", "str", "=", "ensureString", "(", "str", ")", ";", "var", "buf", "=", "new", "Buffer", "(", "str", ".", "length", ")", ";", "var", "revCharsBuf", "=", "options", ".", "revCharsBuf", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "str", ".", "length", ";", "i", "++", ")", "buf", "[", "i", "]", "=", "revCharsBuf", "[", "str", ".", "charCodeAt", "(", "i", ")", "]", ";", "return", "buf", ";", "}", ",", "fromEncoding", ":", "function", "(", "buf", ")", "{", "buf", "=", "ensureBuffer", "(", "buf", ")", ";", "// Strings are immutable in JS -> we use ucs2 buffer to speed up computations.", "var", "charsBuf", "=", "options", ".", "charsBuf", ";", "var", "newBuf", "=", "new", "Buffer", "(", "buf", ".", "length", "*", "2", ")", ";", "var", "idx1", "=", "0", ",", "idx2", "=", "0", ";", "for", "(", "var", "i", "=", "0", ",", "_len", "=", "buf", ".", "length", ";", "i", "<", "_len", ";", "i", "++", ")", "{", "idx1", "=", "buf", "[", "i", "]", "*", "2", ";", "idx2", "=", "i", "*", "2", ";", "newBuf", "[", "idx2", "]", "=", "charsBuf", "[", "idx1", "]", ";", "newBuf", "[", "idx2", "+", "1", "]", "=", "charsBuf", "[", "idx1", "+", "1", "]", ";", "}", "return", "newBuf", ".", "toString", "(", "'ucs2'", ")", ";", "}", "}", ";", "}"], "docstring": "Codepage single-byte encodings.", "docstring_tokens": ["Codepage", "single", "-", "byte", "encodings", "."], "sha": "6b49053bb7f667681d526dc21d5d6b71f3bf644d", "url": "https://github.com/hbouvier/node-tts/blob/6b49053bb7f667681d526dc21d5d6b71f3bf644d/swagger-ui/lib/shred.bundle.js#L2278-L2325", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(record, json, relationship) {\n    var key = relationship.key,\n        belongsTo = get(record, key);\n    key = this.keyForAttribute(key);\n    json[key + \"_type\"] = Ember.String.capitalize(belongsTo.constructor.typeKey);\n  }", "language": "javascript", "code": "function(record, json, relationship) {\n    var key = relationship.key,\n        belongsTo = get(record, key);\n    key = this.keyForAttribute(key);\n    json[key + \"_type\"] = Ember.String.capitalize(belongsTo.constructor.typeKey);\n  }", "code_tokens": ["function", "(", "record", ",", "json", ",", "relationship", ")", "{", "var", "key", "=", "relationship", ".", "key", ",", "belongsTo", "=", "get", "(", "record", ",", "key", ")", ";", "key", "=", "this", ".", "keyForAttribute", "(", "key", ")", ";", "json", "[", "key", "+", "\"_type\"", "]", "=", "Ember", ".", "String", ".", "capitalize", "(", "belongsTo", ".", "constructor", ".", "typeKey", ")", ";", "}"], "docstring": "Serializes a polymorphic type as a fully capitalized model name.\n\n@method serializePolymorphicType\n@param {DS.Model} record\n@param {Object} json\n@param relationship", "docstring_tokens": ["Serializes", "a", "polymorphic", "type", "as", "a", "fully", "capitalized", "model", "name", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L10140-L10145", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(name, region) {\n      this.triggerMethod('before:remove:region', name, region);\n      region.empty();\n      region.stopListening();\n  \n      delete region._parent;\n      delete this._regions[name];\n      this.length--;\n      this.triggerMethod('remove:region', name, region);\n    }", "language": "javascript", "code": "function(name, region) {\n      this.triggerMethod('before:remove:region', name, region);\n      region.empty();\n      region.stopListening();\n  \n      delete region._parent;\n      delete this._regions[name];\n      this.length--;\n      this.triggerMethod('remove:region', name, region);\n    }", "code_tokens": ["function", "(", "name", ",", "region", ")", "{", "this", ".", "triggerMethod", "(", "'before:remove:region'", ",", "name", ",", "region", ")", ";", "region", ".", "empty", "(", ")", ";", "region", ".", "stopListening", "(", ")", ";", "delete", "region", ".", "_parent", ";", "delete", "this", ".", "_regions", "[", "name", "]", ";", "this", ".", "length", "--", ";", "this", ".", "triggerMethod", "(", "'remove:region'", ",", "name", ",", "region", ")", ";", "}"], "docstring": "internal method to remove a region", "docstring_tokens": ["internal", "method", "to", "remove", "a", "region"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L17619-L17628", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "onImageLoad", "original_string": "function onImageLoad() {\n    if (!renderer)\n        renderer = new libpannellum.renderer(renderContainer);\n\n    // Only add event listeners once\n    if (!listenersAdded) {\n        listenersAdded = true;\n        dragFix.addEventListener('mousedown', onDocumentMouseDown, false);\n        document.addEventListener('mousemove', onDocumentMouseMove, false);\n        document.addEventListener('mouseup', onDocumentMouseUp, false);\n        if (config.mouseZoom) {\n            uiContainer.addEventListener('mousewheel', onDocumentMouseWheel, false);\n            uiContainer.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);\n        }\n        if (config.doubleClickZoom) {\n            dragFix.addEventListener('dblclick', onDocumentDoubleClick, false);\n        }\n        container.addEventListener('mozfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('webkitfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('msfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('fullscreenchange', onFullScreenChange, false);\n        window.addEventListener('resize', onDocumentResize, false);\n        window.addEventListener('orientationchange', onDocumentResize, false);\n        if (!config.disableKeyboardCtrl) {\n            container.addEventListener('keydown', onDocumentKeyPress, false);\n            container.addEventListener('keyup', onDocumentKeyUp, false);\n            container.addEventListener('blur', clearKeys, false);\n        }\n        document.addEventListener('mouseleave', onDocumentMouseUp, false);\n        if (document.documentElement.style.pointerAction === '' &&\n            document.documentElement.style.touchAction === '') {\n            dragFix.addEventListener('pointerdown', onDocumentPointerDown, false);\n            dragFix.addEventListener('pointermove', onDocumentPointerMove, false);\n            dragFix.addEventListener('pointerup', onDocumentPointerUp, false);\n            dragFix.addEventListener('pointerleave', onDocumentPointerUp, false);\n        } else {\n            dragFix.addEventListener('touchstart', onDocumentTouchStart, false);\n            dragFix.addEventListener('touchmove', onDocumentTouchMove, false);\n            dragFix.addEventListener('touchend', onDocumentTouchEnd, false);\n        }\n\n        // Deal with MS pointer events\n        if (window.navigator.pointerEnabled)\n            container.style.touchAction = 'none';\n    }\n\n    renderInit();\n    setHfov(config.hfov); // possibly adapt hfov after configuration and canvas is complete; prevents empty space on top or bottom by zomming out too much\n    setTimeout(function(){isTimedOut = true;}, 500);\n}", "language": "javascript", "code": "function onImageLoad() {\n    if (!renderer)\n        renderer = new libpannellum.renderer(renderContainer);\n\n    // Only add event listeners once\n    if (!listenersAdded) {\n        listenersAdded = true;\n        dragFix.addEventListener('mousedown', onDocumentMouseDown, false);\n        document.addEventListener('mousemove', onDocumentMouseMove, false);\n        document.addEventListener('mouseup', onDocumentMouseUp, false);\n        if (config.mouseZoom) {\n            uiContainer.addEventListener('mousewheel', onDocumentMouseWheel, false);\n            uiContainer.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);\n        }\n        if (config.doubleClickZoom) {\n            dragFix.addEventListener('dblclick', onDocumentDoubleClick, false);\n        }\n        container.addEventListener('mozfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('webkitfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('msfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('fullscreenchange', onFullScreenChange, false);\n        window.addEventListener('resize', onDocumentResize, false);\n        window.addEventListener('orientationchange', onDocumentResize, false);\n        if (!config.disableKeyboardCtrl) {\n            container.addEventListener('keydown', onDocumentKeyPress, false);\n            container.addEventListener('keyup', onDocumentKeyUp, false);\n            container.addEventListener('blur', clearKeys, false);\n        }\n        document.addEventListener('mouseleave', onDocumentMouseUp, false);\n        if (document.documentElement.style.pointerAction === '' &&\n            document.documentElement.style.touchAction === '') {\n            dragFix.addEventListener('pointerdown', onDocumentPointerDown, false);\n            dragFix.addEventListener('pointermove', onDocumentPointerMove, false);\n            dragFix.addEventListener('pointerup', onDocumentPointerUp, false);\n            dragFix.addEventListener('pointerleave', onDocumentPointerUp, false);\n        } else {\n            dragFix.addEventListener('touchstart', onDocumentTouchStart, false);\n            dragFix.addEventListener('touchmove', onDocumentTouchMove, false);\n            dragFix.addEventListener('touchend', onDocumentTouchEnd, false);\n        }\n\n        // Deal with MS pointer events\n        if (window.navigator.pointerEnabled)\n            container.style.touchAction = 'none';\n    }\n\n    renderInit();\n    setHfov(config.hfov); // possibly adapt hfov after configuration and canvas is complete; prevents empty space on top or bottom by zomming out too much\n    setTimeout(function(){isTimedOut = true;}, 500);\n}", "code_tokens": ["function", "onImageLoad", "(", ")", "{", "if", "(", "!", "renderer", ")", "renderer", "=", "new", "libpannellum", ".", "renderer", "(", "renderContainer", ")", ";", "// Only add event listeners once", "if", "(", "!", "listenersAdded", ")", "{", "listenersAdded", "=", "true", ";", "dragFix", ".", "addEventListener", "(", "'mousedown'", ",", "onDocumentMouseDown", ",", "false", ")", ";", "document", ".", "addEventListener", "(", "'mousemove'", ",", "onDocumentMouseMove", ",", "false", ")", ";", "document", ".", "addEventListener", "(", "'mouseup'", ",", "onDocumentMouseUp", ",", "false", ")", ";", "if", "(", "config", ".", "mouseZoom", ")", "{", "uiContainer", ".", "addEventListener", "(", "'mousewheel'", ",", "onDocumentMouseWheel", ",", "false", ")", ";", "uiContainer", ".", "addEventListener", "(", "'DOMMouseScroll'", ",", "onDocumentMouseWheel", ",", "false", ")", ";", "}", "if", "(", "config", ".", "doubleClickZoom", ")", "{", "dragFix", ".", "addEventListener", "(", "'dblclick'", ",", "onDocumentDoubleClick", ",", "false", ")", ";", "}", "container", ".", "addEventListener", "(", "'mozfullscreenchange'", ",", "onFullScreenChange", ",", "false", ")", ";", "container", ".", "addEventListener", "(", "'webkitfullscreenchange'", ",", "onFullScreenChange", ",", "false", ")", ";", "container", ".", "addEventListener", "(", "'msfullscreenchange'", ",", "onFullScreenChange", ",", "false", ")", ";", "container", ".", "addEventListener", "(", "'fullscreenchange'", ",", "onFullScreenChange", ",", "false", ")", ";", "window", ".", "addEventListener", "(", "'resize'", ",", "onDocumentResize", ",", "false", ")", ";", "window", ".", "addEventListener", "(", "'orientationchange'", ",", "onDocumentResize", ",", "false", ")", ";", "if", "(", "!", "config", ".", "disableKeyboardCtrl", ")", "{", "container", ".", "addEventListener", "(", "'keydown'", ",", "onDocumentKeyPress", ",", "false", ")", ";", "container", ".", "addEventListener", "(", "'keyup'", ",", "onDocumentKeyUp", ",", "false", ")", ";", "container", ".", "addEventListener", "(", "'blur'", ",", "clearKeys", ",", "false", ")", ";", "}", "document", ".", "addEventListener", "(", "'mouseleave'", ",", "onDocumentMouseUp", ",", "false", ")", ";", "if", "(", "document", ".", "documentElement", ".", "style", ".", "pointerAction", "===", "''", "&&", "document", ".", "documentElement", ".", "style", ".", "touchAction", "===", "''", ")", "{", "dragFix", ".", "addEventListener", "(", "'pointerdown'", ",", "onDocumentPointerDown", ",", "false", ")", ";", "dragFix", ".", "addEventListener", "(", "'pointermove'", ",", "onDocumentPointerMove", ",", "false", ")", ";", "dragFix", ".", "addEventListener", "(", "'pointerup'", ",", "onDocumentPointerUp", ",", "false", ")", ";", "dragFix", ".", "addEventListener", "(", "'pointerleave'", ",", "onDocumentPointerUp", ",", "false", ")", ";", "}", "else", "{", "dragFix", ".", "addEventListener", "(", "'touchstart'", ",", "onDocumentTouchStart", ",", "false", ")", ";", "dragFix", ".", "addEventListener", "(", "'touchmove'", ",", "onDocumentTouchMove", ",", "false", ")", ";", "dragFix", ".", "addEventListener", "(", "'touchend'", ",", "onDocumentTouchEnd", ",", "false", ")", ";", "}", "// Deal with MS pointer events", "if", "(", "window", ".", "navigator", ".", "pointerEnabled", ")", "container", ".", "style", ".", "touchAction", "=", "'none'", ";", "}", "renderInit", "(", ")", ";", "setHfov", "(", "config", ".", "hfov", ")", ";", "// possibly adapt hfov after configuration and canvas is complete; prevents empty space on top or bottom by zomming out too much", "setTimeout", "(", "function", "(", ")", "{", "isTimedOut", "=", "true", ";", "}", ",", "500", ")", ";", "}"], "docstring": "Create renderer and initialize event listeners once image is loaded.\n@private", "docstring_tokens": ["Create", "renderer", "and", "initialize", "event", "listeners", "once", "image", "is", "loaded", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L466-L515", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getParametersFromRightHandSideOfAssignment", "original_string": "function getParametersFromRightHandSideOfAssignment(rightHandSide) {\n            while (rightHandSide.kind === 172 /* ParenthesizedExpression */) {\n                rightHandSide = rightHandSide.expression;\n            }\n            switch (rightHandSide.kind) {\n                case 173 /* FunctionExpression */:\n                case 174 /* ArrowFunction */:\n                    return rightHandSide.parameters;\n                case 186 /* ClassExpression */:\n                    for (var _i = 0, _a = rightHandSide.members; _i < _a.length; _i++) {\n                        var member = _a[_i];\n                        if (member.kind === 144 /* Constructor */) {\n                            return member.parameters;\n                        }\n                    }\n                    break;\n            }\n            return emptyArray;\n        }", "language": "javascript", "code": "function getParametersFromRightHandSideOfAssignment(rightHandSide) {\n            while (rightHandSide.kind === 172 /* ParenthesizedExpression */) {\n                rightHandSide = rightHandSide.expression;\n            }\n            switch (rightHandSide.kind) {\n                case 173 /* FunctionExpression */:\n                case 174 /* ArrowFunction */:\n                    return rightHandSide.parameters;\n                case 186 /* ClassExpression */:\n                    for (var _i = 0, _a = rightHandSide.members; _i < _a.length; _i++) {\n                        var member = _a[_i];\n                        if (member.kind === 144 /* Constructor */) {\n                            return member.parameters;\n                        }\n                    }\n                    break;\n            }\n            return emptyArray;\n        }", "code_tokens": ["function", "getParametersFromRightHandSideOfAssignment", "(", "rightHandSide", ")", "{", "while", "(", "rightHandSide", ".", "kind", "===", "172", "/* ParenthesizedExpression */", ")", "{", "rightHandSide", "=", "rightHandSide", ".", "expression", ";", "}", "switch", "(", "rightHandSide", ".", "kind", ")", "{", "case", "173", "/* FunctionExpression */", ":", "case", "174", "/* ArrowFunction */", ":", "return", "rightHandSide", ".", "parameters", ";", "case", "186", "/* ClassExpression */", ":", "for", "(", "var", "_i", "=", "0", ",", "_a", "=", "rightHandSide", ".", "members", ";", "_i", "<", "_a", ".", "length", ";", "_i", "++", ")", "{", "var", "member", "=", "_a", "[", "_i", "]", ";", "if", "(", "member", ".", "kind", "===", "144", "/* Constructor */", ")", "{", "return", "member", ".", "parameters", ";", "}", "}", "break", ";", "}", "return", "emptyArray", ";", "}"], "docstring": "Digs into an an initializer or RHS operand of an assignment operation\nto get the parameters of an apt signature corresponding to a\nfunction expression or a class expression.\n\n@param rightHandSide the expression which may contain an appropriate set of parameters\n@returns the parameters of a signature found on the RHS if one exists; otherwise 'emptyArray'.", "docstring_tokens": ["Digs", "into", "an", "an", "initializer", "or", "RHS", "operand", "of", "an", "assignment", "operation", "to", "get", "the", "parameters", "of", "an", "apt", "signature", "corresponding", "to", "a", "function", "expression", "or", "a", "class", "expression", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L48416-L48434", "partition": "test"}
{"repo": "cloudinary/cloudinary_js", "path": "js/jquery.cloudinary.js", "func_name": "Cloudinary", "original_string": "function Cloudinary(options) {\n      var configuration;\n      this.devicePixelRatioCache = {};\n      this.responsiveConfig = {};\n      this.responsiveResizeInitialized = false;\n      configuration = new Configuration(options);\n      this.config = function(newConfig, newValue) {\n        return configuration.config(newConfig, newValue);\n      };\n\n      /**\n       * Use \\<meta\\> tags in the document to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */\n      this.fromDocument = function() {\n        configuration.fromDocument();\n        return this;\n      };\n\n      /**\n       * Use environment variables to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */\n      this.fromEnvironment = function() {\n        configuration.fromEnvironment();\n        return this;\n      };\n\n      /**\n       * Initialize configuration.\n       * @function Cloudinary#init\n       * @see Configuration#init\n       * @return {Cloudinary} this for chaining\n       */\n      this.init = function() {\n        configuration.init();\n        return this;\n      };\n    }", "language": "javascript", "code": "function Cloudinary(options) {\n      var configuration;\n      this.devicePixelRatioCache = {};\n      this.responsiveConfig = {};\n      this.responsiveResizeInitialized = false;\n      configuration = new Configuration(options);\n      this.config = function(newConfig, newValue) {\n        return configuration.config(newConfig, newValue);\n      };\n\n      /**\n       * Use \\<meta\\> tags in the document to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */\n      this.fromDocument = function() {\n        configuration.fromDocument();\n        return this;\n      };\n\n      /**\n       * Use environment variables to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */\n      this.fromEnvironment = function() {\n        configuration.fromEnvironment();\n        return this;\n      };\n\n      /**\n       * Initialize configuration.\n       * @function Cloudinary#init\n       * @see Configuration#init\n       * @return {Cloudinary} this for chaining\n       */\n      this.init = function() {\n        configuration.init();\n        return this;\n      };\n    }", "code_tokens": ["function", "Cloudinary", "(", "options", ")", "{", "var", "configuration", ";", "this", ".", "devicePixelRatioCache", "=", "{", "}", ";", "this", ".", "responsiveConfig", "=", "{", "}", ";", "this", ".", "responsiveResizeInitialized", "=", "false", ";", "configuration", "=", "new", "Configuration", "(", "options", ")", ";", "this", ".", "config", "=", "function", "(", "newConfig", ",", "newValue", ")", "{", "return", "configuration", ".", "config", "(", "newConfig", ",", "newValue", ")", ";", "}", ";", "/**\n       * Use \\<meta\\> tags in the document to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */", "this", ".", "fromDocument", "=", "function", "(", ")", "{", "configuration", ".", "fromDocument", "(", ")", ";", "return", "this", ";", "}", ";", "/**\n       * Use environment variables to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */", "this", ".", "fromEnvironment", "=", "function", "(", ")", "{", "configuration", ".", "fromEnvironment", "(", ")", ";", "return", "this", ";", "}", ";", "/**\n       * Initialize configuration.\n       * @function Cloudinary#init\n       * @see Configuration#init\n       * @return {Cloudinary} this for chaining\n       */", "this", ".", "init", "=", "function", "(", ")", "{", "configuration", ".", "init", "(", ")", ";", "return", "this", ";", "}", ";", "}"], "docstring": "Main Cloudinary class\n@class Cloudinary\n@param {Object} options - options to configure Cloudinary\n@see Configuration for more details\n@example\nvar cl = new cloudinary.Cloudinary( { cloud_name: \"mycloud\"});\nvar imgTag = cl.image(\"myPicID\");", "docstring_tokens": ["Main", "Cloudinary", "class"], "sha": "c5ef98e858ba83e7c2c13a1d898748b571a5931b", "url": "https://github.com/cloudinary/cloudinary_js/blob/c5ef98e858ba83e7c2c13a1d898748b571a5931b/js/jquery.cloudinary.js#L3561-L3599", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/metadata/materialized-view.js", "func_name": "MaterializedView", "original_string": "function MaterializedView(name) {\n  DataCollection.call(this, name);\n  /**\n   * Name of the table.\n   * @type {String}\n   */\n  this.tableName = null;\n  /**\n   * View where clause.\n   * @type {String}\n   */\n  this.whereClause = null;\n  /**\n   * Determines if all the table columns where are included in the view.\n   * @type {boolean}\n   */\n  this.includeAllColumns = false;\n}", "language": "javascript", "code": "function MaterializedView(name) {\n  DataCollection.call(this, name);\n  /**\n   * Name of the table.\n   * @type {String}\n   */\n  this.tableName = null;\n  /**\n   * View where clause.\n   * @type {String}\n   */\n  this.whereClause = null;\n  /**\n   * Determines if all the table columns where are included in the view.\n   * @type {boolean}\n   */\n  this.includeAllColumns = false;\n}", "code_tokens": ["function", "MaterializedView", "(", "name", ")", "{", "DataCollection", ".", "call", "(", "this", ",", "name", ")", ";", "/**\n   * Name of the table.\n   * @type {String}\n   */", "this", ".", "tableName", "=", "null", ";", "/**\n   * View where clause.\n   * @type {String}\n   */", "this", ".", "whereClause", "=", "null", ";", "/**\n   * Determines if all the table columns where are included in the view.\n   * @type {boolean}\n   */", "this", ".", "includeAllColumns", "=", "false", ";", "}"], "docstring": "Creates a new MaterializedView.\n@param {String} name Name of the View.\n@classdesc Describes a CQL materialized view.\n@alias module:metadata~MaterializedView\n@augments {module:metadata~DataCollection}\n@constructor", "docstring_tokens": ["Creates", "a", "new", "MaterializedView", "."], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/metadata/materialized-view.js#L12-L29", "partition": "test"}
{"repo": "cloudinary/cloudinary_js", "path": "js/jquery.cloudinary.js", "func_name": "Configuration", "original_string": "function Configuration(options) {\n      if (options == null) {\n        options = {};\n      }\n      this.configuration = Util.cloneDeep(options);\n      Util.defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n    }", "language": "javascript", "code": "function Configuration(options) {\n      if (options == null) {\n        options = {};\n      }\n      this.configuration = Util.cloneDeep(options);\n      Util.defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n    }", "code_tokens": ["function", "Configuration", "(", "options", ")", "{", "if", "(", "options", "==", "null", ")", "{", "options", "=", "{", "}", ";", "}", "this", ".", "configuration", "=", "Util", ".", "cloneDeep", "(", "options", ")", ";", "Util", ".", "defaults", "(", "this", ".", "configuration", ",", "DEFAULT_CONFIGURATION_PARAMS", ")", ";", "}"], "docstring": "Cloudinary configuration class\n@constructor Configuration\n@param {Object} options - configuration parameters", "docstring_tokens": ["Cloudinary", "configuration", "class"], "sha": "c5ef98e858ba83e7c2c13a1d898748b571a5931b", "url": "https://github.com/cloudinary/cloudinary_js/blob/c5ef98e858ba83e7c2c13a1d898748b571a5931b/js/jquery.cloudinary.js#L1899-L1905", "partition": "test"}
{"repo": "mrlannigan/node-akamai", "path": "lib/purge.js", "func_name": "", "original_string": "function () {\n        // Apply the modifier to the current `options`\n        options = lodash.assign(options, modifier);\n\n        // Create new wrapper function.\n        var AkamaiPurgeChain = function AkamaiPurgeChain (username, password, objects) {\n          return AkamaiPurge(username, password, objects, options);\n        };\n\n        // Apply new modifiers to given wrapper function\n        applyModifiers(AkamaiPurgeChain, options);\n\n        // Expose current `options`\n        AkamaiPurgeChain.options = options;\n\n        return AkamaiPurgeChain;\n      }", "language": "javascript", "code": "function () {\n        // Apply the modifier to the current `options`\n        options = lodash.assign(options, modifier);\n\n        // Create new wrapper function.\n        var AkamaiPurgeChain = function AkamaiPurgeChain (username, password, objects) {\n          return AkamaiPurge(username, password, objects, options);\n        };\n\n        // Apply new modifiers to given wrapper function\n        applyModifiers(AkamaiPurgeChain, options);\n\n        // Expose current `options`\n        AkamaiPurgeChain.options = options;\n\n        return AkamaiPurgeChain;\n      }", "code_tokens": ["function", "(", ")", "{", "// Apply the modifier to the current `options`", "options", "=", "lodash", ".", "assign", "(", "options", ",", "modifier", ")", ";", "// Create new wrapper function.", "var", "AkamaiPurgeChain", "=", "function", "AkamaiPurgeChain", "(", "username", ",", "password", ",", "objects", ")", "{", "return", "AkamaiPurge", "(", "username", ",", "password", ",", "objects", ",", "options", ")", ";", "}", ";", "// Apply new modifiers to given wrapper function", "applyModifiers", "(", "AkamaiPurgeChain", ",", "options", ")", ";", "// Expose current `options`", "AkamaiPurgeChain", ".", "options", "=", "options", ";", "return", "AkamaiPurgeChain", ";", "}"], "docstring": "Returns a new function pre-configured with the options that exist up to this point", "docstring_tokens": ["Returns", "a", "new", "function", "pre", "-", "configured", "with", "the", "options", "that", "exist", "up", "to", "this", "point"], "sha": "ccffb1c439293bd98a9f3d90b15c800ddf29338e", "url": "https://github.com/mrlannigan/node-akamai/blob/ccffb1c439293bd98a9f3d90b15c800ddf29338e/lib/purge.js#L105-L121", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(regions) {\n      var defaults = {\n        regionClass: this.getOption('regionClass'),\n        parentEl: _.partial(_.result, this, 'el')\n      };\n  \n      return this.regionManager.addRegions(regions, defaults);\n    }", "language": "javascript", "code": "function(regions) {\n      var defaults = {\n        regionClass: this.getOption('regionClass'),\n        parentEl: _.partial(_.result, this, 'el')\n      };\n  \n      return this.regionManager.addRegions(regions, defaults);\n    }", "code_tokens": ["function", "(", "regions", ")", "{", "var", "defaults", "=", "{", "regionClass", ":", "this", ".", "getOption", "(", "'regionClass'", ")", ",", "parentEl", ":", "_", ".", "partial", "(", "_", ".", "result", ",", "this", ",", "'el'", ")", "}", ";", "return", "this", ".", "regionManager", ".", "addRegions", "(", "regions", ",", "defaults", ")", ";", "}"], "docstring": "internal method to build regions", "docstring_tokens": ["internal", "method", "to", "build", "regions"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L19242-L19249", "partition": "test"}
{"repo": "bholloway/browserify-nginject", "path": "lib/process-node.js", "func_name": "processNode", "original_string": "function processNode(node) {\n\n  // check if the function is part of a variable assignment\n  var isVarAssignment = (node.parent.type === 'VariableDeclarator');\n\n  // the parameters of the function, converted to literal strings\n  var params = node.params\n    .map(paramToLiteral);\n\n  // [ 'arg', ..., function(arg) {} ]\n  //  place inline\n  if ((node.type === 'FunctionExpression') && !isVarAssignment) {\n    esprimaTools.nodeSplicer(node)({\n      parent  : node.parent,\n      type    : 'ArrayExpression',\n      elements: params.concat(node)\n    });\n  }\n\n  // fn.$inject = [ 'arg', ... ]\n  //  hoist before any intervening return statement\n  else {\n    var appendTo = isVarAssignment ? node.parent.parent : node;\n    esprimaTools.nodeSplicer(appendTo, offset)({\n      type      : 'ExpressionStatement',\n      expression: {\n        type    : 'AssignmentExpression',\n        operator: '=',\n        left    : {\n          type    : 'MemberExpression',\n          computed: false,\n          object  : {\n            type: 'Identifier',\n            name: node.id.name\n          },\n          property: {\n            type: 'Identifier',\n            name: '$inject'\n          }\n        },\n        right   : {\n          type    : 'ArrayExpression',\n          elements: params\n        }\n      }\n    });\n  }\n}", "language": "javascript", "code": "function processNode(node) {\n\n  // check if the function is part of a variable assignment\n  var isVarAssignment = (node.parent.type === 'VariableDeclarator');\n\n  // the parameters of the function, converted to literal strings\n  var params = node.params\n    .map(paramToLiteral);\n\n  // [ 'arg', ..., function(arg) {} ]\n  //  place inline\n  if ((node.type === 'FunctionExpression') && !isVarAssignment) {\n    esprimaTools.nodeSplicer(node)({\n      parent  : node.parent,\n      type    : 'ArrayExpression',\n      elements: params.concat(node)\n    });\n  }\n\n  // fn.$inject = [ 'arg', ... ]\n  //  hoist before any intervening return statement\n  else {\n    var appendTo = isVarAssignment ? node.parent.parent : node;\n    esprimaTools.nodeSplicer(appendTo, offset)({\n      type      : 'ExpressionStatement',\n      expression: {\n        type    : 'AssignmentExpression',\n        operator: '=',\n        left    : {\n          type    : 'MemberExpression',\n          computed: false,\n          object  : {\n            type: 'Identifier',\n            name: node.id.name\n          },\n          property: {\n            type: 'Identifier',\n            name: '$inject'\n          }\n        },\n        right   : {\n          type    : 'ArrayExpression',\n          elements: params\n        }\n      }\n    });\n  }\n}", "code_tokens": ["function", "processNode", "(", "node", ")", "{", "// check if the function is part of a variable assignment", "var", "isVarAssignment", "=", "(", "node", ".", "parent", ".", "type", "===", "'VariableDeclarator'", ")", ";", "// the parameters of the function, converted to literal strings", "var", "params", "=", "node", ".", "params", ".", "map", "(", "paramToLiteral", ")", ";", "// [ 'arg', ..., function(arg) {} ]", "//  place inline", "if", "(", "(", "node", ".", "type", "===", "'FunctionExpression'", ")", "&&", "!", "isVarAssignment", ")", "{", "esprimaTools", ".", "nodeSplicer", "(", "node", ")", "(", "{", "parent", ":", "node", ".", "parent", ",", "type", ":", "'ArrayExpression'", ",", "elements", ":", "params", ".", "concat", "(", "node", ")", "}", ")", ";", "}", "// fn.$inject = [ 'arg', ... ]", "//  hoist before any intervening return statement", "else", "{", "var", "appendTo", "=", "isVarAssignment", "?", "node", ".", "parent", ".", "parent", ":", "node", ";", "esprimaTools", ".", "nodeSplicer", "(", "appendTo", ",", "offset", ")", "(", "{", "type", ":", "'ExpressionStatement'", ",", "expression", ":", "{", "type", ":", "'AssignmentExpression'", ",", "operator", ":", "'='", ",", "left", ":", "{", "type", ":", "'MemberExpression'", ",", "computed", ":", "false", ",", "object", ":", "{", "type", ":", "'Identifier'", ",", "name", ":", "node", ".", "id", ".", "name", "}", ",", "property", ":", "{", "type", ":", "'Identifier'", ",", "name", ":", "'$inject'", "}", "}", ",", "right", ":", "{", "type", ":", "'ArrayExpression'", ",", "elements", ":", "params", "}", "}", "}", ")", ";", "}", "}"], "docstring": "Add explicit dependency statements to the node.\n@param {object} node An esprima AST function-type node", "docstring_tokens": ["Add", "explicit", "dependency", "statements", "to", "the", "node", "."], "sha": "42cff52081b66d77e4e7fac923d4d824de13cfd3", "url": "https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/process-node.js#L11-L58", "partition": "test"}
{"repo": "wilmoore/curry2.js", "path": "index.js", "func_name": "curry2", "original_string": "function curry2 (fn, self) {\n  var out = function () {\n    if (arguments.length === 0) return out\n\n    return arguments.length > 1\n      ? fn.apply(self, arguments)\n      : bind.call(fn, self, arguments[0])\n  }\n\n  out.uncurry = function uncurry () {\n    return fn\n  }\n\n  return out\n}", "language": "javascript", "code": "function curry2 (fn, self) {\n  var out = function () {\n    if (arguments.length === 0) return out\n\n    return arguments.length > 1\n      ? fn.apply(self, arguments)\n      : bind.call(fn, self, arguments[0])\n  }\n\n  out.uncurry = function uncurry () {\n    return fn\n  }\n\n  return out\n}", "code_tokens": ["function", "curry2", "(", "fn", ",", "self", ")", "{", "var", "out", "=", "function", "(", ")", "{", "if", "(", "arguments", ".", "length", "===", "0", ")", "return", "out", "return", "arguments", ".", "length", ">", "1", "?", "fn", ".", "apply", "(", "self", ",", "arguments", ")", ":", "bind", ".", "call", "(", "fn", ",", "self", ",", "arguments", "[", "0", "]", ")", "}", "out", ".", "uncurry", "=", "function", "uncurry", "(", ")", "{", "return", "fn", "}", "return", "out", "}"], "docstring": "Curry a binary function.\n\n@param {Function} fn\nBinary function to curry.\n\n@param {Object} [self]\nFunction `this` context.\n\n@return {Function|*}\nIf partially applied, return unary function, otherwise, return result of full application.", "docstring_tokens": ["Curry", "a", "binary", "function", "."], "sha": "9864f54362b50d4c6fea62fa9d54224e1d136b70", "url": "https://github.com/wilmoore/curry2.js/blob/9864f54362b50d4c6fea62fa9d54224e1d136b70/index.js#L28-L42", "partition": "test"}
{"repo": "cedx/coveralls.js", "path": "example/main.js", "func_name": "main", "original_string": "async function main() { // eslint-disable-line no-unused-vars\n  try {\n    const coverage = await promises.readFile('/path/to/coverage.report', 'utf8');\n    await new Client().upload(coverage);\n    console.log('The report was sent successfully.');\n  }\n\n  catch (error) {\n    console.log(`An error occurred: ${error.message}`);\n    if (error instanceof ClientError) console.log(`From: ${error.uri}`);\n  }\n}", "language": "javascript", "code": "async function main() { // eslint-disable-line no-unused-vars\n  try {\n    const coverage = await promises.readFile('/path/to/coverage.report', 'utf8');\n    await new Client().upload(coverage);\n    console.log('The report was sent successfully.');\n  }\n\n  catch (error) {\n    console.log(`An error occurred: ${error.message}`);\n    if (error instanceof ClientError) console.log(`From: ${error.uri}`);\n  }\n}", "code_tokens": ["async", "function", "main", "(", ")", "{", "// eslint-disable-line no-unused-vars", "try", "{", "const", "coverage", "=", "await", "promises", ".", "readFile", "(", "'/path/to/coverage.report'", ",", "'utf8'", ")", ";", "await", "new", "Client", "(", ")", ".", "upload", "(", "coverage", ")", ";", "console", ".", "log", "(", "'The report was sent successfully.'", ")", ";", "}", "catch", "(", "error", ")", "{", "console", ".", "log", "(", "`", "${", "error", ".", "message", "}", "`", ")", ";", "if", "(", "error", "instanceof", "ClientError", ")", "console", ".", "log", "(", "`", "${", "error", ".", "uri", "}", "`", ")", ";", "}", "}"], "docstring": "Uploads a coverage report.", "docstring_tokens": ["Uploads", "a", "coverage", "report", "."], "sha": "42ee63e3e6f6ffc695809f0c722cef7792edf0c5", "url": "https://github.com/cedx/coveralls.js/blob/42ee63e3e6f6ffc695809f0c722cef7792edf0c5/example/main.js#L5-L16", "partition": "test"}
{"repo": "sendanor/nor-api", "path": "src/Router.js", "func_name": "_resolve", "original_string": "function _resolve(routes, path, req, res) {\n\treturn Q.fcall(function() {\n\n\t\tpath = path || [];\n\n\t\tvar obj = routes;\n\t\t\n\t\t// Resolve promises first\n\t\tif(IS.obj(obj) && IS.fun(obj.then)) {\n\t\t\tvar p = obj.then(function(ret) {\n\t\t\t\treturn _resolve(ret, path, req, res);\n\t\t\t});\n\t\t\treturn p;\n\t\t}\n\n\t\t// Resolve functions first\n\t\tif(IS.fun(obj)) {\n\t\t\tvar p2 = Q.when(obj(req, res)).then(function(ret) {\n\t\t\t\treturn _resolve(ret, path, req, res);\n\t\t\t});\n\t\t\treturn p2;\n\t\t}\n\t\t\n\t\t// If the resource is undefined, return flags.notFound (resulting to a HTTP error 404).\n\t\tif(obj === undefined) {\n\t\t\treturn flags.notFound;\n\t\t}\n\t\t\n\t\t// If path is at the end, then return the current resource.\n\t\tif(path.length === 0) {\n\t\t\treturn obj;\n\t\t}\n\t\t\n\t\t// Handle arrays\n\t\tif(IS.array(obj)) {\n\t\t\tvar k = path[0],\n\t\t\t    n = parseInt(path.shift(), 10);\n\t\t\tif(k === \"length\") {\n\t\t\t\treturn _resolve(obj.length, path.shift(), req, res);\n\t\t\t}\n\t\t\tif(k !== \"\"+n) {\n\t\t\t\treturn Q.fcall(function() { throw new errors.HTTPError({'code':400, 'desc':'Bad Request'}); });\n\t\t\t}\n\t\t\treturn _resolve(obj[n], path.shift(), req, res);\n\t\t}\n\t\t\n\t\t// Handle objects\n\t\tif(IS.obj(obj)) {\n\t\t\tvar k2 = path[0];\n\t\t\tif(obj[k2] === undefined) {\n\t\t\t\treturn flags.notFound;\n\t\t\t}\n\t\t\tif(!obj.hasOwnProperty(k2)) {\n\t\t\t\treturn Q.fcall(function() { throw new errors.HTTPError({'code':403, 'desc':'Forbidden'}); });\n\t\t\t}\n\t\t\treturn _resolve(obj[path.shift()], path, req, res);\n\t\t}\n\t\t\n\t\t// Returns notFound because we still have keys in the path but nowhere to go.\n\t\treturn flags.notFound;\n\t});\n}", "language": "javascript", "code": "function _resolve(routes, path, req, res) {\n\treturn Q.fcall(function() {\n\n\t\tpath = path || [];\n\n\t\tvar obj = routes;\n\t\t\n\t\t// Resolve promises first\n\t\tif(IS.obj(obj) && IS.fun(obj.then)) {\n\t\t\tvar p = obj.then(function(ret) {\n\t\t\t\treturn _resolve(ret, path, req, res);\n\t\t\t});\n\t\t\treturn p;\n\t\t}\n\n\t\t// Resolve functions first\n\t\tif(IS.fun(obj)) {\n\t\t\tvar p2 = Q.when(obj(req, res)).then(function(ret) {\n\t\t\t\treturn _resolve(ret, path, req, res);\n\t\t\t});\n\t\t\treturn p2;\n\t\t}\n\t\t\n\t\t// If the resource is undefined, return flags.notFound (resulting to a HTTP error 404).\n\t\tif(obj === undefined) {\n\t\t\treturn flags.notFound;\n\t\t}\n\t\t\n\t\t// If path is at the end, then return the current resource.\n\t\tif(path.length === 0) {\n\t\t\treturn obj;\n\t\t}\n\t\t\n\t\t// Handle arrays\n\t\tif(IS.array(obj)) {\n\t\t\tvar k = path[0],\n\t\t\t    n = parseInt(path.shift(), 10);\n\t\t\tif(k === \"length\") {\n\t\t\t\treturn _resolve(obj.length, path.shift(), req, res);\n\t\t\t}\n\t\t\tif(k !== \"\"+n) {\n\t\t\t\treturn Q.fcall(function() { throw new errors.HTTPError({'code':400, 'desc':'Bad Request'}); });\n\t\t\t}\n\t\t\treturn _resolve(obj[n], path.shift(), req, res);\n\t\t}\n\t\t\n\t\t// Handle objects\n\t\tif(IS.obj(obj)) {\n\t\t\tvar k2 = path[0];\n\t\t\tif(obj[k2] === undefined) {\n\t\t\t\treturn flags.notFound;\n\t\t\t}\n\t\t\tif(!obj.hasOwnProperty(k2)) {\n\t\t\t\treturn Q.fcall(function() { throw new errors.HTTPError({'code':403, 'desc':'Forbidden'}); });\n\t\t\t}\n\t\t\treturn _resolve(obj[path.shift()], path, req, res);\n\t\t}\n\t\t\n\t\t// Returns notFound because we still have keys in the path but nowhere to go.\n\t\treturn flags.notFound;\n\t});\n}", "code_tokens": ["function", "_resolve", "(", "routes", ",", "path", ",", "req", ",", "res", ")", "{", "return", "Q", ".", "fcall", "(", "function", "(", ")", "{", "path", "=", "path", "||", "[", "]", ";", "var", "obj", "=", "routes", ";", "// Resolve promises first", "if", "(", "IS", ".", "obj", "(", "obj", ")", "&&", "IS", ".", "fun", "(", "obj", ".", "then", ")", ")", "{", "var", "p", "=", "obj", ".", "then", "(", "function", "(", "ret", ")", "{", "return", "_resolve", "(", "ret", ",", "path", ",", "req", ",", "res", ")", ";", "}", ")", ";", "return", "p", ";", "}", "// Resolve functions first", "if", "(", "IS", ".", "fun", "(", "obj", ")", ")", "{", "var", "p2", "=", "Q", ".", "when", "(", "obj", "(", "req", ",", "res", ")", ")", ".", "then", "(", "function", "(", "ret", ")", "{", "return", "_resolve", "(", "ret", ",", "path", ",", "req", ",", "res", ")", ";", "}", ")", ";", "return", "p2", ";", "}", "// If the resource is undefined, return flags.notFound (resulting to a HTTP error 404).", "if", "(", "obj", "===", "undefined", ")", "{", "return", "flags", ".", "notFound", ";", "}", "// If path is at the end, then return the current resource.", "if", "(", "path", ".", "length", "===", "0", ")", "{", "return", "obj", ";", "}", "// Handle arrays", "if", "(", "IS", ".", "array", "(", "obj", ")", ")", "{", "var", "k", "=", "path", "[", "0", "]", ",", "n", "=", "parseInt", "(", "path", ".", "shift", "(", ")", ",", "10", ")", ";", "if", "(", "k", "===", "\"length\"", ")", "{", "return", "_resolve", "(", "obj", ".", "length", ",", "path", ".", "shift", "(", ")", ",", "req", ",", "res", ")", ";", "}", "if", "(", "k", "!==", "\"\"", "+", "n", ")", "{", "return", "Q", ".", "fcall", "(", "function", "(", ")", "{", "throw", "new", "errors", ".", "HTTPError", "(", "{", "'code'", ":", "400", ",", "'desc'", ":", "'Bad Request'", "}", ")", ";", "}", ")", ";", "}", "return", "_resolve", "(", "obj", "[", "n", "]", ",", "path", ".", "shift", "(", ")", ",", "req", ",", "res", ")", ";", "}", "// Handle objects", "if", "(", "IS", ".", "obj", "(", "obj", ")", ")", "{", "var", "k2", "=", "path", "[", "0", "]", ";", "if", "(", "obj", "[", "k2", "]", "===", "undefined", ")", "{", "return", "flags", ".", "notFound", ";", "}", "if", "(", "!", "obj", ".", "hasOwnProperty", "(", "k2", ")", ")", "{", "return", "Q", ".", "fcall", "(", "function", "(", ")", "{", "throw", "new", "errors", ".", "HTTPError", "(", "{", "'code'", ":", "403", ",", "'desc'", ":", "'Forbidden'", "}", ")", ";", "}", ")", ";", "}", "return", "_resolve", "(", "obj", "[", "path", ".", "shift", "(", ")", "]", ",", "path", ",", "req", ",", "res", ")", ";", "}", "// Returns notFound because we still have keys in the path but nowhere to go.", "return", "flags", ".", "notFound", ";", "}", ")", ";", "}"], "docstring": "Internal target resolver\n@param routes Object prepresenting routes to resources.\n@param path Path to the resource as an array of keys.", "docstring_tokens": ["Internal", "target", "resolver"], "sha": "50c88c6a606443e89f978a75057902a65d8312bd", "url": "https://github.com/sendanor/nor-api/blob/50c88c6a606443e89f978a75057902a65d8312bd/src/Router.js#L13-L74", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/app/Application.js", "func_name": "", "original_string": "function(name, profileName) {\n        var instances = this.getControllerInstances(),\n            appName   = this.getName(),\n            format    = Ext.String.format,\n            topLevelName;\n\n        if (name instanceof Ext.app.Controller) {\n            return name;\n        }\n\n        if (instances[name]) {\n            return instances[name];\n        } else {\n            topLevelName = format(\"{0}.controller.{1}\", appName, name);\n            profileName  = format(\"{0}.controller.{1}.{2}\", appName, profileName, name);\n\n            return instances[profileName] || instances[topLevelName];\n        }\n    }", "language": "javascript", "code": "function(name, profileName) {\n        var instances = this.getControllerInstances(),\n            appName   = this.getName(),\n            format    = Ext.String.format,\n            topLevelName;\n\n        if (name instanceof Ext.app.Controller) {\n            return name;\n        }\n\n        if (instances[name]) {\n            return instances[name];\n        } else {\n            topLevelName = format(\"{0}.controller.{1}\", appName, name);\n            profileName  = format(\"{0}.controller.{1}.{2}\", appName, profileName, name);\n\n            return instances[profileName] || instances[topLevelName];\n        }\n    }", "code_tokens": ["function", "(", "name", ",", "profileName", ")", "{", "var", "instances", "=", "this", ".", "getControllerInstances", "(", ")", ",", "appName", "=", "this", ".", "getName", "(", ")", ",", "format", "=", "Ext", ".", "String", ".", "format", ",", "topLevelName", ";", "if", "(", "name", "instanceof", "Ext", ".", "app", ".", "Controller", ")", "{", "return", "name", ";", "}", "if", "(", "instances", "[", "name", "]", ")", "{", "return", "instances", "[", "name", "]", ";", "}", "else", "{", "topLevelName", "=", "format", "(", "\"{0}.controller.{1}\"", ",", "appName", ",", "name", ")", ";", "profileName", "=", "format", "(", "\"{0}.controller.{1}.{2}\"", ",", "appName", ",", "profileName", ",", "name", ")", ";", "return", "instances", "[", "profileName", "]", "||", "instances", "[", "topLevelName", "]", ";", "}", "}"], "docstring": "Returns the Controller instance for the given controller name.\n@param {String} name The name of the Controller.\n@param {String} [profileName] Optional profile name. If passed, this is the same as calling\n`getController('profileName.controllerName')`.\n@return {Ext.app.Controller} controller instance or undefined.", "docstring_tokens": ["Returns", "the", "Controller", "instance", "for", "the", "given", "controller", "name", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/app/Application.js#L580-L598", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "", "original_string": "function(options) {\n      var destroyOptions = options || {};\n      var shouldCheckEmpty = true;\n      var childViews = this.children.map(_.identity);\n  \n      if (!_.isUndefined(destroyOptions.checkEmpty)) {\n        shouldCheckEmpty = destroyOptions.checkEmpty;\n      }\n  \n      this.children.each(this.removeChildView, this);\n  \n      if (shouldCheckEmpty) {\n        this.checkEmpty();\n      }\n      return childViews;\n    }", "language": "javascript", "code": "function(options) {\n      var destroyOptions = options || {};\n      var shouldCheckEmpty = true;\n      var childViews = this.children.map(_.identity);\n  \n      if (!_.isUndefined(destroyOptions.checkEmpty)) {\n        shouldCheckEmpty = destroyOptions.checkEmpty;\n      }\n  \n      this.children.each(this.removeChildView, this);\n  \n      if (shouldCheckEmpty) {\n        this.checkEmpty();\n      }\n      return childViews;\n    }", "code_tokens": ["function", "(", "options", ")", "{", "var", "destroyOptions", "=", "options", "||", "{", "}", ";", "var", "shouldCheckEmpty", "=", "true", ";", "var", "childViews", "=", "this", ".", "children", ".", "map", "(", "_", ".", "identity", ")", ";", "if", "(", "!", "_", ".", "isUndefined", "(", "destroyOptions", ".", "checkEmpty", ")", ")", "{", "shouldCheckEmpty", "=", "destroyOptions", ".", "checkEmpty", ";", "}", "this", ".", "children", ".", "each", "(", "this", ".", "removeChildView", ",", "this", ")", ";", "if", "(", "shouldCheckEmpty", ")", "{", "this", ".", "checkEmpty", "(", ")", ";", "}", "return", "childViews", ";", "}"], "docstring": "Destroy the child views that this collection view is holding on to, if any", "docstring_tokens": ["Destroy", "the", "child", "views", "that", "this", "collection", "view", "is", "holding", "on", "to", "if", "any"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L18885-L18900", "partition": "test"}
{"repo": "olegpolyakov/sendpulse", "path": "index.js", "func_name": "addEmails", "original_string": "function addEmails(callback,id,emails){\n    if ((id===undefined) || (emails === undefined) || (! emails.length)) {\n        return callback(returnError(\"Empty email or book id\"));\n    }\n    var data = {emails: serialize(emails)};\n    sendRequest( 'addressbooks/' + id + '/emails', 'POST', data, true, callback );\n}", "language": "javascript", "code": "function addEmails(callback,id,emails){\n    if ((id===undefined) || (emails === undefined) || (! emails.length)) {\n        return callback(returnError(\"Empty email or book id\"));\n    }\n    var data = {emails: serialize(emails)};\n    sendRequest( 'addressbooks/' + id + '/emails', 'POST', data, true, callback );\n}", "code_tokens": ["function", "addEmails", "(", "callback", ",", "id", ",", "emails", ")", "{", "if", "(", "(", "id", "===", "undefined", ")", "||", "(", "emails", "===", "undefined", ")", "||", "(", "!", "emails", ".", "length", ")", ")", "{", "return", "callback", "(", "returnError", "(", "\"Empty email or book id\"", ")", ")", ";", "}", "var", "data", "=", "{", "emails", ":", "serialize", "(", "emails", ")", "}", ";", "sendRequest", "(", "'addressbooks/'", "+", "id", "+", "'/emails'", ",", "'POST'", ",", "data", ",", "true", ",", "callback", ")", ";", "}"], "docstring": "Add new emails to address book\n\n@param callback\n@param id\n@param emails", "docstring_tokens": ["Add", "new", "emails", "to", "address", "book"], "sha": "7c8230e75c918a8a110f641ddb241006a1f86ac1", "url": "https://github.com/olegpolyakov/sendpulse/blob/7c8230e75c918a8a110f641ddb241006a1f86ac1/index.js#L361-L367", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "getClosestInstanceFromNode", "original_string": "function getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  while (!node[internalInstanceKey]) {\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n\n  return null;\n}", "language": "javascript", "code": "function getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  while (!node[internalInstanceKey]) {\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n\n  return null;\n}", "code_tokens": ["function", "getClosestInstanceFromNode", "(", "node", ")", "{", "if", "(", "node", "[", "internalInstanceKey", "]", ")", "{", "return", "node", "[", "internalInstanceKey", "]", ";", "}", "while", "(", "!", "node", "[", "internalInstanceKey", "]", ")", "{", "if", "(", "node", ".", "parentNode", ")", "{", "node", "=", "node", ".", "parentNode", ";", "}", "else", "{", "// Top of the tree. This node must not be part of a React tree (or is", "// unmounted, potentially).", "return", "null", ";", "}", "}", "var", "inst", "=", "node", "[", "internalInstanceKey", "]", ";", "if", "(", "inst", ".", "tag", "===", "HostComponent", "||", "inst", ".", "tag", "===", "HostText", ")", "{", "// In Fiber, this will always be the deepest root.", "return", "inst", ";", "}", "return", "null", ";", "}"], "docstring": "Given a DOM node, return the closest ReactDOMComponent or\nReactDOMTextComponent instance ancestor.", "docstring_tokens": ["Given", "a", "DOM", "node", "return", "the", "closest", "ReactDOMComponent", "or", "ReactDOMTextComponent", "instance", "ancestor", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L3265-L3287", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "extglob", "original_string": "function extglob(str, opts) {\n  opts = opts || {};\n  var o = {}, i = 0;\n\n  // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!(');\n\n  // support file extension negation\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n    return escape('[^.]+');\n  });\n\n  // create a unique key for caching by\n  // combining the string and options\n  var key = str\n    + String(!!opts.regex)\n    + String(!!opts.contains)\n    + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + (i++) + '__';\n    // use the prefix of the _last_ (outtermost) pattern\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length;\n\n  // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex\n    ? toRegex(str, opts.contains, opts.negate)\n    : str;\n\n  result = result.split('.').join('\\\\.');\n\n  // cache the result and return it\n  return (cache[key] = result);\n}", "language": "javascript", "code": "function extglob(str, opts) {\n  opts = opts || {};\n  var o = {}, i = 0;\n\n  // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!(');\n\n  // support file extension negation\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n    return escape('[^.]+');\n  });\n\n  // create a unique key for caching by\n  // combining the string and options\n  var key = str\n    + String(!!opts.regex)\n    + String(!!opts.contains)\n    + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + (i++) + '__';\n    // use the prefix of the _last_ (outtermost) pattern\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length;\n\n  // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex\n    ? toRegex(str, opts.contains, opts.negate)\n    : str;\n\n  result = result.split('.').join('\\\\.');\n\n  // cache the result and return it\n  return (cache[key] = result);\n}", "code_tokens": ["function", "extglob", "(", "str", ",", "opts", ")", "{", "opts", "=", "opts", "||", "{", "}", ";", "var", "o", "=", "{", "}", ",", "i", "=", "0", ";", "// fix common character reversals", "// '*!(.js)' => '*.!(js)'", "str", "=", "str", ".", "replace", "(", "/", "!\\(([^\\w*()])", "/", "g", ",", "'$1!('", ")", ";", "// support file extension negation", "str", "=", "str", ".", "replace", "(", "/", "([*\\/])\\.!\\([*]\\)", "/", "g", ",", "function", "(", "m", ",", "ch", ")", "{", "if", "(", "ch", "===", "'/'", ")", "{", "return", "escape", "(", "'\\\\/[^.]+'", ")", ";", "}", "return", "escape", "(", "'[^.]+'", ")", ";", "}", ")", ";", "// create a unique key for caching by", "// combining the string and options", "var", "key", "=", "str", "+", "String", "(", "!", "!", "opts", ".", "regex", ")", "+", "String", "(", "!", "!", "opts", ".", "contains", ")", "+", "String", "(", "!", "!", "opts", ".", "escape", ")", ";", "if", "(", "cache", ".", "hasOwnProperty", "(", "key", ")", ")", "{", "return", "cache", "[", "key", "]", ";", "}", "if", "(", "!", "(", "re", "instanceof", "RegExp", ")", ")", "{", "re", "=", "regex", "(", ")", ";", "}", "opts", ".", "negate", "=", "false", ";", "var", "m", ";", "while", "(", "m", "=", "re", ".", "exec", "(", "str", ")", ")", "{", "var", "prefix", "=", "m", "[", "1", "]", ";", "var", "inner", "=", "m", "[", "3", "]", ";", "if", "(", "prefix", "===", "'!'", ")", "{", "opts", ".", "negate", "=", "true", ";", "}", "var", "id", "=", "'__EXTGLOB_'", "+", "(", "i", "++", ")", "+", "'__'", ";", "// use the prefix of the _last_ (outtermost) pattern", "o", "[", "id", "]", "=", "wrap", "(", "inner", ",", "prefix", ",", "opts", ".", "escape", ")", ";", "str", "=", "str", ".", "split", "(", "m", "[", "0", "]", ")", ".", "join", "(", "id", ")", ";", "}", "var", "keys", "=", "Object", ".", "keys", "(", "o", ")", ";", "var", "len", "=", "keys", ".", "length", ";", "// we have to loop again to allow us to convert", "// patterns in reverse order (starting with the", "// innermost/last pattern first)", "while", "(", "len", "--", ")", "{", "var", "prop", "=", "keys", "[", "len", "]", ";", "str", "=", "str", ".", "split", "(", "prop", ")", ".", "join", "(", "o", "[", "prop", "]", ")", ";", "}", "var", "result", "=", "opts", ".", "regex", "?", "toRegex", "(", "str", ",", "opts", ".", "contains", ",", "opts", ".", "negate", ")", ":", "str", ";", "result", "=", "result", ".", "split", "(", "'.'", ")", ".", "join", "(", "'\\\\.'", ")", ";", "// cache the result and return it", "return", "(", "cache", "[", "key", "]", "=", "result", ")", ";", "}"], "docstring": "Convert the given extglob `string` to a regex-compatible\nstring.\n\n```js\nvar extglob = require('extglob');\nextglob('!(a?(b))');\n//=> '(?!a(?:b)?)[^/]*?'\n```\n\n@param {String} `str` The string to convert.\n@param {Object} `options`\n@option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n@option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n@return {String}\n@api public", "docstring_tokens": ["Convert", "the", "given", "extglob", "string", "to", "a", "regex", "-", "compatible", "string", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L43890-L43956", "partition": "test"}
{"repo": "luizbills/fixed-game-loop", "path": "src/fixed-game-loop.js", "func_name": "", "original_string": "function() {\n    if (this._initialized && !this._isPaused) {\n      return false;\n    }\n\n    var pauseDuration;\n\n    this._isPaused = false;\n    this._prevTime = now();\n\n    pauseDuration = this._prevTime - this._pauseTime;\n    this._onResume(pauseDuration);\n\n    this._requestID = raf.request(this._tick);\n\n    return true;\n  }", "language": "javascript", "code": "function() {\n    if (this._initialized && !this._isPaused) {\n      return false;\n    }\n\n    var pauseDuration;\n\n    this._isPaused = false;\n    this._prevTime = now();\n\n    pauseDuration = this._prevTime - this._pauseTime;\n    this._onResume(pauseDuration);\n\n    this._requestID = raf.request(this._tick);\n\n    return true;\n  }", "code_tokens": ["function", "(", ")", "{", "if", "(", "this", ".", "_initialized", "&&", "!", "this", ".", "_isPaused", ")", "{", "return", "false", ";", "}", "var", "pauseDuration", ";", "this", ".", "_isPaused", "=", "false", ";", "this", ".", "_prevTime", "=", "now", "(", ")", ";", "pauseDuration", "=", "this", ".", "_prevTime", "-", "this", ".", "_pauseTime", ";", "this", ".", "_onResume", "(", "pauseDuration", ")", ";", "this", ".", "_requestID", "=", "raf", ".", "request", "(", "this", ".", "_tick", ")", ";", "return", "true", ";", "}"], "docstring": "resumes the timer", "docstring_tokens": ["resumes", "the", "timer"], "sha": "b235cf7f096a5883ac73923212dd535aa1cfaafd", "url": "https://github.com/luizbills/fixed-game-loop/blob/b235cf7f096a5883ac73923212dd535aa1cfaafd/src/fixed-game-loop.js#L59-L75", "partition": "test"}
{"repo": "azproduction/lmd", "path": "bin/lmd_builder.js", "func_name": "getSandboxMap", "original_string": "function getSandboxMap(ast) {\n        var map = {};\n\n        walker.with_walkers({\n            // looking for first var with sandbox item;\n            \"var\" : function (vars) {\n                for (var i = 0, c = vars.length, varItem; i < c; i++) {\n                    varItem = vars[i];\n                    if (varItem[0] === 'sandbox') {\n                        varItem[1][1].forEach(function (objectVar) {\n                            map[objectVar[0]] = objectVar[1][1];\n                        });\n                        throw 0;\n                    }\n                }\n            }\n        }, function () {\n            try {\n                return walker.walk(ast);\n            } catch (e) {}\n        });\n\n        return map;\n    }", "language": "javascript", "code": "function getSandboxMap(ast) {\n        var map = {};\n\n        walker.with_walkers({\n            // looking for first var with sandbox item;\n            \"var\" : function (vars) {\n                for (var i = 0, c = vars.length, varItem; i < c; i++) {\n                    varItem = vars[i];\n                    if (varItem[0] === 'sandbox') {\n                        varItem[1][1].forEach(function (objectVar) {\n                            map[objectVar[0]] = objectVar[1][1];\n                        });\n                        throw 0;\n                    }\n                }\n            }\n        }, function () {\n            try {\n                return walker.walk(ast);\n            } catch (e) {}\n        });\n\n        return map;\n    }", "code_tokens": ["function", "getSandboxMap", "(", "ast", ")", "{", "var", "map", "=", "{", "}", ";", "walker", ".", "with_walkers", "(", "{", "// looking for first var with sandbox item;", "\"var\"", ":", "function", "(", "vars", ")", "{", "for", "(", "var", "i", "=", "0", ",", "c", "=", "vars", ".", "length", ",", "varItem", ";", "i", "<", "c", ";", "i", "++", ")", "{", "varItem", "=", "vars", "[", "i", "]", ";", "if", "(", "varItem", "[", "0", "]", "===", "'sandbox'", ")", "{", "varItem", "[", "1", "]", "[", "1", "]", ".", "forEach", "(", "function", "(", "objectVar", ")", "{", "map", "[", "objectVar", "[", "0", "]", "]", "=", "objectVar", "[", "1", "]", "[", "1", "]", ";", "}", ")", ";", "throw", "0", ";", "}", "}", "}", "}", ",", "function", "(", ")", "{", "try", "{", "return", "walker", ".", "walk", "(", "ast", ")", ";", "}", "catch", "(", "e", ")", "{", "}", "}", ")", ";", "return", "map", ";", "}"], "docstring": "Uses variable sandbox for create replacement map\n\n@param {Object} ast toplevel AST\n\n@return {Object} {name: replaceName} map", "docstring_tokens": ["Uses", "variable", "sandbox", "for", "create", "replacement", "map"], "sha": "03410c36839728de683c697670e1b205dc8193ee", "url": "https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/bin/lmd_builder.js#L429-L452", "partition": "test"}
{"repo": "arusahni/ngtweet", "path": "dist/ngtweet.js", "func_name": "diffArrays", "original_string": "function diffArrays(arr1, arr2) {\n        if (!Array.isArray(arr1) || !Array.isArray(arr2)) {\n            return true;\n        }\n        if (arr1.length !== arr2.length) {\n            return true;\n        }\n        for (var i = 0, len = arr1.length; i < len; i++) {\n            if (arr1[i] !== arr2[i]) {\n                return true;\n            }\n        }\n        return false;\n    }", "language": "javascript", "code": "function diffArrays(arr1, arr2) {\n        if (!Array.isArray(arr1) || !Array.isArray(arr2)) {\n            return true;\n        }\n        if (arr1.length !== arr2.length) {\n            return true;\n        }\n        for (var i = 0, len = arr1.length; i < len; i++) {\n            if (arr1[i] !== arr2[i]) {\n                return true;\n            }\n        }\n        return false;\n    }", "code_tokens": ["function", "diffArrays", "(", "arr1", ",", "arr2", ")", "{", "if", "(", "!", "Array", ".", "isArray", "(", "arr1", ")", "||", "!", "Array", ".", "isArray", "(", "arr2", ")", ")", "{", "return", "true", ";", "}", "if", "(", "arr1", ".", "length", "!==", "arr2", ".", "length", ")", "{", "return", "true", ";", "}", "for", "(", "var", "i", "=", "0", ",", "len", "=", "arr1", ".", "length", ";", "i", "<", "len", ";", "i", "++", ")", "{", "if", "(", "arr1", "[", "i", "]", "!==", "arr2", "[", "i", "]", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "Diff two arrays.\n@param {Array} arr1 - The first array\n@param {Array} arr2 - The second array\n@return {boolean} true if the arrays are different, false otherwise", "docstring_tokens": ["Diff", "two", "arrays", "."], "sha": "60e19c174be0f868193568858ad8172def50d5fa", "url": "https://github.com/arusahni/ngtweet/blob/60e19c174be0f868193568858ad8172def50d5fa/dist/ngtweet.js#L116-L129", "partition": "test"}
{"repo": "ParksProjets/C-Preprocessor", "path": "bin/global.js", "func_name": "error", "original_string": "function error(msg, addHint) {\n\tconsole.log('\\x1b[31m');\n\tconsole.log('The compiler has stopped on an error')\n\tconsole.log(`\\x1b[1;31mError: ${msg}\\x1b[0m`);\n\n\tif (addHint)\n\t\tconsole.log(`\\nPlease use -h to show the usage`);\n\n\tprocess.exit(1);\n}", "language": "javascript", "code": "function error(msg, addHint) {\n\tconsole.log('\\x1b[31m');\n\tconsole.log('The compiler has stopped on an error')\n\tconsole.log(`\\x1b[1;31mError: ${msg}\\x1b[0m`);\n\n\tif (addHint)\n\t\tconsole.log(`\\nPlease use -h to show the usage`);\n\n\tprocess.exit(1);\n}", "code_tokens": ["function", "error", "(", "msg", ",", "addHint", ")", "{", "console", ".", "log", "(", "'\\x1b[31m'", ")", ";", "console", ".", "log", "(", "'The compiler has stopped on an error'", ")", "console", ".", "log", "(", "`", "\\x1b", "${", "msg", "}", "\\x1b", "`", ")", ";", "if", "(", "addHint", ")", "console", ".", "log", "(", "`", "\\n", "`", ")", ";", "process", ".", "exit", "(", "1", ")", ";", "}"], "docstring": "Show an error", "docstring_tokens": ["Show", "an", "error"], "sha": "9c9ea8901b801cc42c69192bacd39814c415cd3b", "url": "https://github.com/ParksProjets/C-Preprocessor/blob/9c9ea8901b801cc42c69192bacd39814c415cd3b/bin/global.js#L39-L48", "partition": "test"}
{"repo": "aldeste/dinosaur-fetcher", "path": "src/index.js", "func_name": "getRandomArrValue", "original_string": "function getRandomArrValue(arr, min = 0, max = arr.length - 1) {\n  return arr[getRandomInt(min, max)];\n}", "language": "javascript", "code": "function getRandomArrValue(arr, min = 0, max = arr.length - 1) {\n  return arr[getRandomInt(min, max)];\n}", "code_tokens": ["function", "getRandomArrValue", "(", "arr", ",", "min", "=", "0", ",", "max", "=", "arr", ".", "length", "-", "1", ")", "{", "return", "arr", "[", "getRandomInt", "(", "min", ",", "max", ")", "]", ";", "}"], "docstring": "Get a random value from an array\n@param  {Array}  arr Array of values\n@param  {Number} min Minimum key value\n@param  {Number} max Maximum key value\n@return              Random value from initial array", "docstring_tokens": ["Get", "a", "random", "value", "from", "an", "array"], "sha": "7eeebacdcdfc3808a9728099160a310246bdbdb6", "url": "https://github.com/aldeste/dinosaur-fetcher/blob/7eeebacdcdfc3808a9728099160a310246bdbdb6/src/index.js#L22-L24", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/direct/RemotingProvider.js", "func_name": "", "original_string": "function(action, method, args) {\n        var me = this,\n            callData = method.getCallData(args),\n            data = callData.data,\n            callback = callData.callback,\n            scope = callData.scope,\n            transaction;\n\n        transaction = Ext.create('Ext.direct.Transaction', {\n            provider: me,\n            args: args,\n            action: action,\n            method: method.getName(),\n            data: data,\n            callback: scope && Ext.isFunction(callback) ? Ext.Function.bind(callback, scope) : callback\n        });\n\n        if (me.fireEvent('beforecall', me, transaction, method) !== false) {\n            Ext.direct.Manager.addTransaction(transaction);\n            me.queueTransaction(transaction);\n            me.fireEvent('call', me, transaction, method);\n        }\n    }", "language": "javascript", "code": "function(action, method, args) {\n        var me = this,\n            callData = method.getCallData(args),\n            data = callData.data,\n            callback = callData.callback,\n            scope = callData.scope,\n            transaction;\n\n        transaction = Ext.create('Ext.direct.Transaction', {\n            provider: me,\n            args: args,\n            action: action,\n            method: method.getName(),\n            data: data,\n            callback: scope && Ext.isFunction(callback) ? Ext.Function.bind(callback, scope) : callback\n        });\n\n        if (me.fireEvent('beforecall', me, transaction, method) !== false) {\n            Ext.direct.Manager.addTransaction(transaction);\n            me.queueTransaction(transaction);\n            me.fireEvent('call', me, transaction, method);\n        }\n    }", "code_tokens": ["function", "(", "action", ",", "method", ",", "args", ")", "{", "var", "me", "=", "this", ",", "callData", "=", "method", ".", "getCallData", "(", "args", ")", ",", "data", "=", "callData", ".", "data", ",", "callback", "=", "callData", ".", "callback", ",", "scope", "=", "callData", ".", "scope", ",", "transaction", ";", "transaction", "=", "Ext", ".", "create", "(", "'Ext.direct.Transaction'", ",", "{", "provider", ":", "me", ",", "args", ":", "args", ",", "action", ":", "action", ",", "method", ":", "method", ".", "getName", "(", ")", ",", "data", ":", "data", ",", "callback", ":", "scope", "&&", "Ext", ".", "isFunction", "(", "callback", ")", "?", "Ext", ".", "Function", ".", "bind", "(", "callback", ",", "scope", ")", ":", "callback", "}", ")", ";", "if", "(", "me", ".", "fireEvent", "(", "'beforecall'", ",", "me", ",", "transaction", ",", "method", ")", "!==", "false", ")", "{", "Ext", ".", "direct", ".", "Manager", ".", "addTransaction", "(", "transaction", ")", ";", "me", ".", "queueTransaction", "(", "transaction", ")", ";", "me", ".", "fireEvent", "(", "'call'", ",", "me", ",", "transaction", ",", "method", ")", ";", "}", "}"], "docstring": "Configure a direct request.\n@private\n@param {String} action The action being executed.\n@param {Object} method The method being executed.\n@param {Array} args", "docstring_tokens": ["Configure", "a", "direct", "request", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/direct/RemotingProvider.js#L332-L354", "partition": "test"}
{"repo": "icelab/draft-js-single-line-plugin", "path": "lib/utils.js", "func_name": "condenseBlocks", "original_string": "function condenseBlocks(editorState, blocks, options) {\n  blocks = blocks || editorState.getCurrentContent().getBlocksAsArray();\n  var text = (0, _immutable.List)();\n  var characterList = (0, _immutable.List)();\n\n  // Gather all the text/characterList and concat them\n  blocks.forEach(function (block) {\n    // Atomic blocks should be ignored (stripped)\n    if (block.getType() !== 'atomic') {\n      text = text.push(replaceNewlines(block.getText()));\n      characterList = characterList.concat(block.getCharacterList());\n    }\n  });\n\n  // Strip entities?\n  if (options.stripEntities) {\n    characterList = characterList.map(stripEntityFromCharacterMetadata);\n  }\n\n  // Create a new content block\n  var contentBlock = new _draftJs.ContentBlock({\n    key: (0, _draftJs.genKey)(),\n    text: text.join(''),\n    type: 'unstyled',\n    characterList: characterList,\n    depth: 0\n  });\n\n  // Update the editor state with the compressed version\n  var newContentState = _draftJs.ContentState.createFromBlockArray([contentBlock]);\n  // Create the new state as an undoable action\n  editorState = _draftJs.EditorState.push(editorState, newContentState, 'remove-range');\n  // Move the selection to the end\n  return _draftJs.EditorState.moveFocusToEnd(editorState);\n}", "language": "javascript", "code": "function condenseBlocks(editorState, blocks, options) {\n  blocks = blocks || editorState.getCurrentContent().getBlocksAsArray();\n  var text = (0, _immutable.List)();\n  var characterList = (0, _immutable.List)();\n\n  // Gather all the text/characterList and concat them\n  blocks.forEach(function (block) {\n    // Atomic blocks should be ignored (stripped)\n    if (block.getType() !== 'atomic') {\n      text = text.push(replaceNewlines(block.getText()));\n      characterList = characterList.concat(block.getCharacterList());\n    }\n  });\n\n  // Strip entities?\n  if (options.stripEntities) {\n    characterList = characterList.map(stripEntityFromCharacterMetadata);\n  }\n\n  // Create a new content block\n  var contentBlock = new _draftJs.ContentBlock({\n    key: (0, _draftJs.genKey)(),\n    text: text.join(''),\n    type: 'unstyled',\n    characterList: characterList,\n    depth: 0\n  });\n\n  // Update the editor state with the compressed version\n  var newContentState = _draftJs.ContentState.createFromBlockArray([contentBlock]);\n  // Create the new state as an undoable action\n  editorState = _draftJs.EditorState.push(editorState, newContentState, 'remove-range');\n  // Move the selection to the end\n  return _draftJs.EditorState.moveFocusToEnd(editorState);\n}", "code_tokens": ["function", "condenseBlocks", "(", "editorState", ",", "blocks", ",", "options", ")", "{", "blocks", "=", "blocks", "||", "editorState", ".", "getCurrentContent", "(", ")", ".", "getBlocksAsArray", "(", ")", ";", "var", "text", "=", "(", "0", ",", "_immutable", ".", "List", ")", "(", ")", ";", "var", "characterList", "=", "(", "0", ",", "_immutable", ".", "List", ")", "(", ")", ";", "// Gather all the text/characterList and concat them", "blocks", ".", "forEach", "(", "function", "(", "block", ")", "{", "// Atomic blocks should be ignored (stripped)", "if", "(", "block", ".", "getType", "(", ")", "!==", "'atomic'", ")", "{", "text", "=", "text", ".", "push", "(", "replaceNewlines", "(", "block", ".", "getText", "(", ")", ")", ")", ";", "characterList", "=", "characterList", ".", "concat", "(", "block", ".", "getCharacterList", "(", ")", ")", ";", "}", "}", ")", ";", "// Strip entities?", "if", "(", "options", ".", "stripEntities", ")", "{", "characterList", "=", "characterList", ".", "map", "(", "stripEntityFromCharacterMetadata", ")", ";", "}", "// Create a new content block", "var", "contentBlock", "=", "new", "_draftJs", ".", "ContentBlock", "(", "{", "key", ":", "(", "0", ",", "_draftJs", ".", "genKey", ")", "(", ")", ",", "text", ":", "text", ".", "join", "(", "''", ")", ",", "type", ":", "'unstyled'", ",", "characterList", ":", "characterList", ",", "depth", ":", "0", "}", ")", ";", "// Update the editor state with the compressed version", "var", "newContentState", "=", "_draftJs", ".", "ContentState", ".", "createFromBlockArray", "(", "[", "contentBlock", "]", ")", ";", "// Create the new state as an undoable action", "editorState", "=", "_draftJs", ".", "EditorState", ".", "push", "(", "editorState", ",", "newContentState", ",", "'remove-range'", ")", ";", "// Move the selection to the end", "return", "_draftJs", ".", "EditorState", ".", "moveFocusToEnd", "(", "editorState", ")", ";", "}"], "docstring": "Condense an array of content blocks into a single block\n@param  {EditorState} editorState draft-js EditorState instance\n@param  {Array} blocks Array of ContentBlocks\n@param  {Object} options\n@return {EditorState} A modified EditorState instance", "docstring_tokens": ["Condense", "an", "array", "of", "content", "blocks", "into", "a", "single", "block"], "sha": "cc52e52642c4a4451d2f47e7342e8952277dd2ab", "url": "https://github.com/icelab/draft-js-single-line-plugin/blob/cc52e52642c4a4451d2f47e7342e8952277dd2ab/lib/utils.js#L41-L75", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "throttle", "original_string": "function throttle(fn, wait) {\n  var last = Date.now();\n\n  var throttled = function throttled() {\n    var now = Date.now();\n\n    if (now - last >= wait) {\n      fn.apply(undefined, arguments);\n      last = now;\n    }\n  };\n\n  return throttled;\n}", "language": "javascript", "code": "function throttle(fn, wait) {\n  var last = Date.now();\n\n  var throttled = function throttled() {\n    var now = Date.now();\n\n    if (now - last >= wait) {\n      fn.apply(undefined, arguments);\n      last = now;\n    }\n  };\n\n  return throttled;\n}", "code_tokens": ["function", "throttle", "(", "fn", ",", "wait", ")", "{", "var", "last", "=", "Date", ".", "now", "(", ")", ";", "var", "throttled", "=", "function", "throttled", "(", ")", "{", "var", "now", "=", "Date", ".", "now", "(", ")", ";", "if", "(", "now", "-", "last", ">=", "wait", ")", "{", "fn", ".", "apply", "(", "undefined", ",", "arguments", ")", ";", "last", "=", "now", ";", "}", "}", ";", "return", "throttled", ";", "}"], "docstring": "Wraps the given function, `fn`, with a new function that only invokes `fn`\nat most once per every `wait` milliseconds.\n\n@param  {Function} fn\nThe function to be throttled.\n\n@param  {Number}   wait\nThe number of milliseconds by which to throttle.\n\n@return {Function}", "docstring_tokens": ["Wraps", "the", "given", "function", "fn", "with", "a", "new", "function", "that", "only", "invokes", "fn", "at", "most", "once", "per", "every", "wait", "milliseconds", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L2193-L2206", "partition": "test"}
{"repo": "AndreasMadsen/article", "path": "lib/helpers-dom.js", "func_name": "styleParser", "original_string": "function styleParser(style) {\n  style = style || '';\n\n  var tokens = style.trim().split(/\\s*(?:;|:)\\s*/);\n  var output = {};\n  for (var i = 1, l = tokens.length; i < l; i += 2) {\n    output[tokens[i - 1]] = tokens[i];\n  }\n  return output;\n}", "language": "javascript", "code": "function styleParser(style) {\n  style = style || '';\n\n  var tokens = style.trim().split(/\\s*(?:;|:)\\s*/);\n  var output = {};\n  for (var i = 1, l = tokens.length; i < l; i += 2) {\n    output[tokens[i - 1]] = tokens[i];\n  }\n  return output;\n}", "code_tokens": ["function", "styleParser", "(", "style", ")", "{", "style", "=", "style", "||", "''", ";", "var", "tokens", "=", "style", ".", "trim", "(", ")", ".", "split", "(", "/", "\\s*(?:;|:)\\s*", "/", ")", ";", "var", "output", "=", "{", "}", ";", "for", "(", "var", "i", "=", "1", ",", "l", "=", "tokens", ".", "length", ";", "i", "<", "l", ";", "i", "+=", "2", ")", "{", "output", "[", "tokens", "[", "i", "-", "1", "]", "]", "=", "tokens", "[", "i", "]", ";", "}", "return", "output", ";", "}"], "docstring": "Parse style attribute intro object", "docstring_tokens": ["Parse", "style", "attribute", "intro", "object"], "sha": "8cf3777fc9dc72d041214faae1b8d65d37a7d134", "url": "https://github.com/AndreasMadsen/article/blob/8cf3777fc9dc72d041214faae1b8d65d37a7d134/lib/helpers-dom.js#L147-L156", "partition": "test"}
{"repo": "Katochimoto/xblocks-core", "path": "src/xblocks/block.js", "func_name": "lifecycleRemoved", "original_string": "function lifecycleRemoved() {\n    this[ Constants.INSERTED ] = false;\n\n    const block = this[ Constants.BLOCK ];\n\n    if (block) {\n        block.destroy();\n        this[ Constants.BLOCK ] = undefined;\n    }\n}", "language": "javascript", "code": "function lifecycleRemoved() {\n    this[ Constants.INSERTED ] = false;\n\n    const block = this[ Constants.BLOCK ];\n\n    if (block) {\n        block.destroy();\n        this[ Constants.BLOCK ] = undefined;\n    }\n}", "code_tokens": ["function", "lifecycleRemoved", "(", ")", "{", "this", "[", "Constants", ".", "INSERTED", "]", "=", "false", ";", "const", "block", "=", "this", "[", "Constants", ".", "BLOCK", "]", ";", "if", "(", "block", ")", "{", "block", ".", "destroy", "(", ")", ";", "this", "[", "Constants", ".", "BLOCK", "]", "=", "undefined", ";", "}", "}"], "docstring": "The callback of the remote in DOM.\n@this HTMLElement\n@private", "docstring_tokens": ["The", "callback", "of", "the", "remote", "in", "DOM", "."], "sha": "714102b7c2adb4ae197403df252e967a1b967bb1", "url": "https://github.com/Katochimoto/xblocks-core/blob/714102b7c2adb4ae197403df252e967a1b967bb1/src/xblocks/block.js#L392-L401", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(parsedName) {\n    var templateName = parsedName.fullNameWithoutType.replace(/\\./g, '/');\n\n    if (Ember.TEMPLATES[templateName]) {\n      return Ember.TEMPLATES[templateName];\n    }\n\n    templateName = decamelize(templateName);\n    if (Ember.TEMPLATES[templateName]) {\n      return Ember.TEMPLATES[templateName];\n    }\n  }", "language": "javascript", "code": "function(parsedName) {\n    var templateName = parsedName.fullNameWithoutType.replace(/\\./g, '/');\n\n    if (Ember.TEMPLATES[templateName]) {\n      return Ember.TEMPLATES[templateName];\n    }\n\n    templateName = decamelize(templateName);\n    if (Ember.TEMPLATES[templateName]) {\n      return Ember.TEMPLATES[templateName];\n    }\n  }", "code_tokens": ["function", "(", "parsedName", ")", "{", "var", "templateName", "=", "parsedName", ".", "fullNameWithoutType", ".", "replace", "(", "/", "\\.", "/", "g", ",", "'/'", ")", ";", "if", "(", "Ember", ".", "TEMPLATES", "[", "templateName", "]", ")", "{", "return", "Ember", ".", "TEMPLATES", "[", "templateName", "]", ";", "}", "templateName", "=", "decamelize", "(", "templateName", ")", ";", "if", "(", "Ember", ".", "TEMPLATES", "[", "templateName", "]", ")", "{", "return", "Ember", ".", "TEMPLATES", "[", "templateName", "]", ";", "}", "}"], "docstring": "Look up the template in Ember.TEMPLATES\n\n@protected\n@param {Object} parsedName a parseName object with the parsed\nfullName lookup string\n@method resolveTemplate", "docstring_tokens": ["Look", "up", "the", "template", "in", "Ember", ".", "TEMPLATES"], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L40476-L40487", "partition": "test"}
{"repo": "tstachl/desk.js", "path": "lib/resource/index.js", "func_name": "Resource", "original_string": "function Resource(parent, definition) {\n  this.parent = parent;\n  this.definition = definition;\n\n  // add mixins\n  this._link = linkMixin;\n\n  this._setup();\n}", "language": "javascript", "code": "function Resource(parent, definition) {\n  this.parent = parent;\n  this.definition = definition;\n\n  // add mixins\n  this._link = linkMixin;\n\n  this._setup();\n}", "code_tokens": ["function", "Resource", "(", "parent", ",", "definition", ")", "{", "this", ".", "parent", "=", "parent", ";", "this", ".", "definition", "=", "definition", ";", "// add mixins", "this", ".", "_link", "=", "linkMixin", ";", "this", ".", "_setup", "(", ")", ";", "}"], "docstring": "Initialize a new `Resource` with the given `parent` and `definition`.\n\n@param {Function} parent The parent this resource is attached to.\n@param {Object} definition The resource definition.\n@api private", "docstring_tokens": ["Initialize", "a", "new", "Resource", "with", "the", "given", "parent", "and", "definition", "."], "sha": "b339196cce68dbbc79d3075f2ebe82372972f4f5", "url": "https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/resource/index.js#L21-L29", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/cordova/project_metadata.js", "func_name": "getPlugins", "original_string": "function getPlugins (projectRoot) {\n    var xml = cordova_util.projectConfig(projectRoot);\n    var cfg = new ConfigParser(xml);\n\n    // Map variables object to an array\n    var plugins = cfg.getPlugins().map(function (plugin) {\n        var result = {\n            name: plugin.name\n        };\n\n        if (semver.validRange(plugin.spec, true)) {\n            result.version = plugin.spec;\n        } else {\n            result.src = plugin.spec;\n        }\n\n        var variablesObject = plugin.variables;\n        var variablesArray = [];\n        if (variablesObject) {\n            for (var variable in variablesObject) {\n                variablesArray.push({\n                    name: variable,\n                    value: variablesObject[variable]\n                });\n            }\n        }\n        result.variables = variablesArray;\n        return result;\n    });\n\n    return Promise.resolve(plugins);\n}", "language": "javascript", "code": "function getPlugins (projectRoot) {\n    var xml = cordova_util.projectConfig(projectRoot);\n    var cfg = new ConfigParser(xml);\n\n    // Map variables object to an array\n    var plugins = cfg.getPlugins().map(function (plugin) {\n        var result = {\n            name: plugin.name\n        };\n\n        if (semver.validRange(plugin.spec, true)) {\n            result.version = plugin.spec;\n        } else {\n            result.src = plugin.spec;\n        }\n\n        var variablesObject = plugin.variables;\n        var variablesArray = [];\n        if (variablesObject) {\n            for (var variable in variablesObject) {\n                variablesArray.push({\n                    name: variable,\n                    value: variablesObject[variable]\n                });\n            }\n        }\n        result.variables = variablesArray;\n        return result;\n    });\n\n    return Promise.resolve(plugins);\n}", "code_tokens": ["function", "getPlugins", "(", "projectRoot", ")", "{", "var", "xml", "=", "cordova_util", ".", "projectConfig", "(", "projectRoot", ")", ";", "var", "cfg", "=", "new", "ConfigParser", "(", "xml", ")", ";", "// Map variables object to an array", "var", "plugins", "=", "cfg", ".", "getPlugins", "(", ")", ".", "map", "(", "function", "(", "plugin", ")", "{", "var", "result", "=", "{", "name", ":", "plugin", ".", "name", "}", ";", "if", "(", "semver", ".", "validRange", "(", "plugin", ".", "spec", ",", "true", ")", ")", "{", "result", ".", "version", "=", "plugin", ".", "spec", ";", "}", "else", "{", "result", ".", "src", "=", "plugin", ".", "spec", ";", "}", "var", "variablesObject", "=", "plugin", ".", "variables", ";", "var", "variablesArray", "=", "[", "]", ";", "if", "(", "variablesObject", ")", "{", "for", "(", "var", "variable", "in", "variablesObject", ")", "{", "variablesArray", ".", "push", "(", "{", "name", ":", "variable", ",", "value", ":", "variablesObject", "[", "variable", "]", "}", ")", ";", "}", "}", "result", ".", "variables", "=", "variablesArray", ";", "return", "result", ";", "}", ")", ";", "return", "Promise", ".", "resolve", "(", "plugins", ")", ";", "}"], "docstring": "Returns all the plugins that are currently saved into config.xml\n@return {Promise<{id: string, version: string, variables: {name: string, value: string}[]}[]>}\ne.g: [ {id: 'org.apache.cordova.device', variables: [{name: 'APP_ID', value: 'my-app-id'}, {name: 'APP_NAME', value: 'my-app-name'}]} ]", "docstring_tokens": ["Returns", "all", "the", "plugins", "that", "are", "currently", "saved", "into", "config", ".", "xml"], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/project_metadata.js#L54-L85", "partition": "test"}
{"repo": "mcasimir/mobile-angular-ui", "path": "dist/js/mobile-angular-ui.gestures.js", "func_name": "", "original_string": "function(t) {\n        var absAngle = abs(t.angle);\n        absAngle = absAngle >= 90 ? absAngle - 90 : absAngle;\n\n        var validDistance = t.total - t.distance <= TURNAROUND_MAX;\n        var validAngle = absAngle <= ANGLE_THRESHOLD || absAngle >= 90 - ANGLE_THRESHOLD;\n        var validVelocity = t.averageVelocity >= VELOCITY_THRESHOLD;\n\n        return validDistance && validAngle && validVelocity;\n      }", "language": "javascript", "code": "function(t) {\n        var absAngle = abs(t.angle);\n        absAngle = absAngle >= 90 ? absAngle - 90 : absAngle;\n\n        var validDistance = t.total - t.distance <= TURNAROUND_MAX;\n        var validAngle = absAngle <= ANGLE_THRESHOLD || absAngle >= 90 - ANGLE_THRESHOLD;\n        var validVelocity = t.averageVelocity >= VELOCITY_THRESHOLD;\n\n        return validDistance && validAngle && validVelocity;\n      }", "code_tokens": ["function", "(", "t", ")", "{", "var", "absAngle", "=", "abs", "(", "t", ".", "angle", ")", ";", "absAngle", "=", "absAngle", ">=", "90", "?", "absAngle", "-", "90", ":", "absAngle", ";", "var", "validDistance", "=", "t", ".", "total", "-", "t", ".", "distance", "<=", "TURNAROUND_MAX", ";", "var", "validAngle", "=", "absAngle", "<=", "ANGLE_THRESHOLD", "||", "absAngle", ">=", "90", "-", "ANGLE_THRESHOLD", ";", "var", "validVelocity", "=", "t", ".", "averageVelocity", ">=", "VELOCITY_THRESHOLD", ";", "return", "validDistance", "&&", "validAngle", "&&", "validVelocity", ";", "}"], "docstring": "start to consider only if movement exceeded MOVEMENT_THRESHOLD", "docstring_tokens": ["start", "to", "consider", "only", "if", "movement", "exceeded", "MOVEMENT_THRESHOLD"], "sha": "5ec10ac8883e31beb91a940f133290a5146a126d", "url": "https://github.com/mcasimir/mobile-angular-ui/blob/5ec10ac8883e31beb91a940f133290a5146a126d/dist/js/mobile-angular-ui.gestures.js#L416-L425", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/core/class/Loader.js", "func_name": "", "original_string": "function(url, onLoad, onError, scope, charset) {\n            var script = document.createElement('script'),\n                me = this,\n                onLoadFn = function() {\n                    me.cleanupScriptElement(script);\n                    onLoad.call(scope);\n                },\n                onErrorFn = function() {\n                    me.cleanupScriptElement(script);\n                    onError.call(scope);\n                };\n\n            script.type = 'text/javascript';\n            script.src = url;\n            script.onload = onLoadFn;\n            script.onerror = onErrorFn;\n            script.onreadystatechange = function() {\n                if (this.readyState === 'loaded' || this.readyState === 'complete') {\n                    onLoadFn();\n                }\n            };\n\n            if (charset) {\n                script.charset = charset;\n            }\n            \n            this.documentHead.appendChild(script);\n\n            return script;\n        }", "language": "javascript", "code": "function(url, onLoad, onError, scope, charset) {\n            var script = document.createElement('script'),\n                me = this,\n                onLoadFn = function() {\n                    me.cleanupScriptElement(script);\n                    onLoad.call(scope);\n                },\n                onErrorFn = function() {\n                    me.cleanupScriptElement(script);\n                    onError.call(scope);\n                };\n\n            script.type = 'text/javascript';\n            script.src = url;\n            script.onload = onLoadFn;\n            script.onerror = onErrorFn;\n            script.onreadystatechange = function() {\n                if (this.readyState === 'loaded' || this.readyState === 'complete') {\n                    onLoadFn();\n                }\n            };\n\n            if (charset) {\n                script.charset = charset;\n            }\n            \n            this.documentHead.appendChild(script);\n\n            return script;\n        }", "code_tokens": ["function", "(", "url", ",", "onLoad", ",", "onError", ",", "scope", ",", "charset", ")", "{", "var", "script", "=", "document", ".", "createElement", "(", "'script'", ")", ",", "me", "=", "this", ",", "onLoadFn", "=", "function", "(", ")", "{", "me", ".", "cleanupScriptElement", "(", "script", ")", ";", "onLoad", ".", "call", "(", "scope", ")", ";", "}", ",", "onErrorFn", "=", "function", "(", ")", "{", "me", ".", "cleanupScriptElement", "(", "script", ")", ";", "onError", ".", "call", "(", "scope", ")", ";", "}", ";", "script", ".", "type", "=", "'text/javascript'", ";", "script", ".", "src", "=", "url", ";", "script", ".", "onload", "=", "onLoadFn", ";", "script", ".", "onerror", "=", "onErrorFn", ";", "script", ".", "onreadystatechange", "=", "function", "(", ")", "{", "if", "(", "this", ".", "readyState", "===", "'loaded'", "||", "this", ".", "readyState", "===", "'complete'", ")", "{", "onLoadFn", "(", ")", ";", "}", "}", ";", "if", "(", "charset", ")", "{", "script", ".", "charset", "=", "charset", ";", "}", "this", ".", "documentHead", ".", "appendChild", "(", "script", ")", ";", "return", "script", ";", "}"], "docstring": "Inject a script element to document's head, call onLoad and onError accordingly\n@private", "docstring_tokens": ["Inject", "a", "script", "element", "to", "document", "s", "head", "call", "onLoad", "and", "onError", "accordingly"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/core/class/Loader.js#L582-L611", "partition": "test"}
{"repo": "jerrybendy/url-search-params-polyfill", "path": "index.js", "func_name": "URLSearchParamsPolyfill", "original_string": "function URLSearchParamsPolyfill(search) {\n        search = search || \"\";\n\n        // support construct object with another URLSearchParams instance\n        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {\n            search = search.toString();\n        }\n        this [__URLSearchParams__] = parseToDict(search);\n    }", "language": "javascript", "code": "function URLSearchParamsPolyfill(search) {\n        search = search || \"\";\n\n        // support construct object with another URLSearchParams instance\n        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {\n            search = search.toString();\n        }\n        this [__URLSearchParams__] = parseToDict(search);\n    }", "code_tokens": ["function", "URLSearchParamsPolyfill", "(", "search", ")", "{", "search", "=", "search", "||", "\"\"", ";", "// support construct object with another URLSearchParams instance", "if", "(", "search", "instanceof", "URLSearchParams", "||", "search", "instanceof", "URLSearchParamsPolyfill", ")", "{", "search", "=", "search", ".", "toString", "(", ")", ";", "}", "this", "[", "__URLSearchParams__", "]", "=", "parseToDict", "(", "search", ")", ";", "}"], "docstring": "Make a URLSearchParams instance\n\n@param {object|string|URLSearchParams} search\n@constructor", "docstring_tokens": ["Make", "a", "URLSearchParams", "instance"], "sha": "cb66794b60f603dd35e71e3031f2479e678a78c8", "url": "https://github.com/jerrybendy/url-search-params-polyfill/blob/cb66794b60f603dd35e71e3031f2479e678a78c8/index.js#L37-L45", "partition": "test"}
{"repo": "emmetio/codemirror-plugin", "path": "lib/commands/wrap-with-abbreviation.js", "func_name": "getWrappingContentRange", "original_string": "function getWrappingContentRange(editor) {\n\tif (editor.somethingSelected()) {\n\t\tconst sel = editor.listSelections().filter(sel => sel.anchor !== sel.head)[0];\n\t\tif (sel) {\n\t\t\treturn  comparePos(sel.anchor, sel.head) < 0\n\t\t\t\t? { from: sel.anchor, to: sel.head }\n\t\t\t\t: { from: sel.head, to: sel.anchor };\n\t\t}\n\t}\n\n\t// Nothing selected, find parent HTML node and return range for its content\n\treturn getTagRangeForPos(editor, editor.getCursor());\n}", "language": "javascript", "code": "function getWrappingContentRange(editor) {\n\tif (editor.somethingSelected()) {\n\t\tconst sel = editor.listSelections().filter(sel => sel.anchor !== sel.head)[0];\n\t\tif (sel) {\n\t\t\treturn  comparePos(sel.anchor, sel.head) < 0\n\t\t\t\t? { from: sel.anchor, to: sel.head }\n\t\t\t\t: { from: sel.head, to: sel.anchor };\n\t\t}\n\t}\n\n\t// Nothing selected, find parent HTML node and return range for its content\n\treturn getTagRangeForPos(editor, editor.getCursor());\n}", "code_tokens": ["function", "getWrappingContentRange", "(", "editor", ")", "{", "if", "(", "editor", ".", "somethingSelected", "(", ")", ")", "{", "const", "sel", "=", "editor", ".", "listSelections", "(", ")", ".", "filter", "(", "sel", "=>", "sel", ".", "anchor", "!==", "sel", ".", "head", ")", "[", "0", "]", ";", "if", "(", "sel", ")", "{", "return", "comparePos", "(", "sel", ".", "anchor", ",", "sel", ".", "head", ")", "<", "0", "?", "{", "from", ":", "sel", ".", "anchor", ",", "to", ":", "sel", ".", "head", "}", ":", "{", "from", ":", "sel", ".", "head", ",", "to", ":", "sel", ".", "anchor", "}", ";", "}", "}", "// Nothing selected, find parent HTML node and return range for its content", "return", "getTagRangeForPos", "(", "editor", ",", "editor", ".", "getCursor", "(", ")", ")", ";", "}"], "docstring": "Returns content range that should be wrapped\n@param {CodeMirror} editor", "docstring_tokens": ["Returns", "content", "range", "that", "should", "be", "wrapped"], "sha": "2089c8b15b97858b82b33e6e81ee1b50954581c1", "url": "https://github.com/emmetio/codemirror-plugin/blob/2089c8b15b97858b82b33e6e81ee1b50954581c1/lib/commands/wrap-with-abbreviation.js#L35-L47", "partition": "test"}
{"repo": "johntitus/node-horseman", "path": "lib/actions.js", "func_name": "evaluatePage", "original_string": "function evaluatePage(page, fn) {\n\tvar args =  Array.prototype.slice.call(arguments, 2);\n\treturn this.ready.then(function() {\n\t\tvar stack;\n\t\tpage = page || this.page;\n\t\tvar res = HorsemanPromise.fromCallback(function(done) {\n\t\t\t\t// Wrap fn to be able to catch exceptions and reject Promise\n\t\t\t\tstack = HorsemanPromise.reject(new Error('See next line'));\n\t\t\t\treturn page.evaluate(function evaluatePage(fnstr, args) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar fn;\n\t\t\t\t\t\teval('fn = ' + fnstr);\n\n\t\t\t\t\t\tvar res = fn.apply(this, args); // Call fn with args\n\t\t\t\t\t\treturn { res: res };\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\treturn { err: err, iserr: err instanceof Error };\n\t\t\t\t\t}\n\t\t\t\t}, fn.toString(), args, done);\n\t\t\t})\n\t\t\t.then(function handleErrback(args) {\n\t\t\t\treturn stack.catch(function(err) {\n\t\t\t\t\tif (args.err) {\n\t\t\t\t\t\tif (args.iserr) {\n\t\t\t\t\t\t\tvar stack = err.stack.split('\\n').slice(1);\n\t\t\t\t\t\t\t// Append Node stack to Phantom stack\n\t\t\t\t\t\t\targs.err.stack += '\\n' + stack.join('\\n');\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn HorsemanPromise.reject(args.err);\n\t\t\t\t\t}\n\t\t\t\t\treturn args.res;\n\t\t\t\t});\n\t\t\t});\n\t\tstack.catch(function() {});\n\t\treturn res;\n\t});\n}", "language": "javascript", "code": "function evaluatePage(page, fn) {\n\tvar args =  Array.prototype.slice.call(arguments, 2);\n\treturn this.ready.then(function() {\n\t\tvar stack;\n\t\tpage = page || this.page;\n\t\tvar res = HorsemanPromise.fromCallback(function(done) {\n\t\t\t\t// Wrap fn to be able to catch exceptions and reject Promise\n\t\t\t\tstack = HorsemanPromise.reject(new Error('See next line'));\n\t\t\t\treturn page.evaluate(function evaluatePage(fnstr, args) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar fn;\n\t\t\t\t\t\teval('fn = ' + fnstr);\n\n\t\t\t\t\t\tvar res = fn.apply(this, args); // Call fn with args\n\t\t\t\t\t\treturn { res: res };\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\treturn { err: err, iserr: err instanceof Error };\n\t\t\t\t\t}\n\t\t\t\t}, fn.toString(), args, done);\n\t\t\t})\n\t\t\t.then(function handleErrback(args) {\n\t\t\t\treturn stack.catch(function(err) {\n\t\t\t\t\tif (args.err) {\n\t\t\t\t\t\tif (args.iserr) {\n\t\t\t\t\t\t\tvar stack = err.stack.split('\\n').slice(1);\n\t\t\t\t\t\t\t// Append Node stack to Phantom stack\n\t\t\t\t\t\t\targs.err.stack += '\\n' + stack.join('\\n');\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn HorsemanPromise.reject(args.err);\n\t\t\t\t\t}\n\t\t\t\t\treturn args.res;\n\t\t\t\t});\n\t\t\t});\n\t\tstack.catch(function() {});\n\t\treturn res;\n\t});\n}", "code_tokens": ["function", "evaluatePage", "(", "page", ",", "fn", ")", "{", "var", "args", "=", "Array", ".", "prototype", ".", "slice", ".", "call", "(", "arguments", ",", "2", ")", ";", "return", "this", ".", "ready", ".", "then", "(", "function", "(", ")", "{", "var", "stack", ";", "page", "=", "page", "||", "this", ".", "page", ";", "var", "res", "=", "HorsemanPromise", ".", "fromCallback", "(", "function", "(", "done", ")", "{", "// Wrap fn to be able to catch exceptions and reject Promise", "stack", "=", "HorsemanPromise", ".", "reject", "(", "new", "Error", "(", "'See next line'", ")", ")", ";", "return", "page", ".", "evaluate", "(", "function", "evaluatePage", "(", "fnstr", ",", "args", ")", "{", "try", "{", "var", "fn", ";", "eval", "(", "'fn = '", "+", "fnstr", ")", ";", "var", "res", "=", "fn", ".", "apply", "(", "this", ",", "args", ")", ";", "// Call fn with args", "return", "{", "res", ":", "res", "}", ";", "}", "catch", "(", "err", ")", "{", "return", "{", "err", ":", "err", ",", "iserr", ":", "err", "instanceof", "Error", "}", ";", "}", "}", ",", "fn", ".", "toString", "(", ")", ",", "args", ",", "done", ")", ";", "}", ")", ".", "then", "(", "function", "handleErrback", "(", "args", ")", "{", "return", "stack", ".", "catch", "(", "function", "(", "err", ")", "{", "if", "(", "args", ".", "err", ")", "{", "if", "(", "args", ".", "iserr", ")", "{", "var", "stack", "=", "err", ".", "stack", ".", "split", "(", "'\\n'", ")", ".", "slice", "(", "1", ")", ";", "// Append Node stack to Phantom stack", "args", ".", "err", ".", "stack", "+=", "'\\n'", "+", "stack", ".", "join", "(", "'\\n'", ")", ";", "}", "return", "HorsemanPromise", ".", "reject", "(", "args", ".", "err", ")", ";", "}", "return", "args", ".", "res", ";", "}", ")", ";", "}", ")", ";", "stack", ".", "catch", "(", "function", "(", ")", "{", "}", ")", ";", "return", "res", ";", "}", ")", ";", "}"], "docstring": "Evaluates a function on the given page.\n@this Horseman\n@param {Page} page\n@param {function} fn\n@param {...*} [arguments]", "docstring_tokens": ["Evaluates", "a", "function", "on", "the", "given", "page", "."], "sha": "831699df1708d96c91d8010a8ee975c4d022fe0e", "url": "https://github.com/johntitus/node-horseman/blob/831699df1708d96c91d8010a8ee975c4d022fe0e/lib/actions.js#L985-L1021", "partition": "test"}
{"repo": "farbelous/bootstrap-popover-picker", "path": "src/js/picker.js", "func_name": "", "original_string": "function(val) {\n                val = this.setValue(val);\n                if ((val !== false) && (val !== '')) {\n                    if (this.hasInput()) {\n                        this.input.val(this.getValue());\n                    } else {\n                        this.element.data('pickerValue', this.getValue());\n                    }\n                    this._trigger('pickerSetSourceValue', {\n                        pickerValue: val\n                    });\n                }\n                return val;\n            }", "language": "javascript", "code": "function(val) {\n                val = this.setValue(val);\n                if ((val !== false) && (val !== '')) {\n                    if (this.hasInput()) {\n                        this.input.val(this.getValue());\n                    } else {\n                        this.element.data('pickerValue', this.getValue());\n                    }\n                    this._trigger('pickerSetSourceValue', {\n                        pickerValue: val\n                    });\n                }\n                return val;\n            }", "code_tokens": ["function", "(", "val", ")", "{", "val", "=", "this", ".", "setValue", "(", "val", ")", ";", "if", "(", "(", "val", "!==", "false", ")", "&&", "(", "val", "!==", "''", ")", ")", "{", "if", "(", "this", ".", "hasInput", "(", ")", ")", "{", "this", ".", "input", ".", "val", "(", "this", ".", "getValue", "(", ")", ")", ";", "}", "else", "{", "this", ".", "element", ".", "data", "(", "'pickerValue'", ",", "this", ".", "getValue", "(", ")", ")", ";", "}", "this", ".", "_trigger", "(", "'pickerSetSourceValue'", ",", "{", "pickerValue", ":", "val", "}", ")", ";", "}", "return", "val", ";", "}"], "docstring": "Calls setValue and if it's a valid item value, sets the input or element value", "docstring_tokens": ["Calls", "setValue", "and", "if", "it", "s", "a", "valid", "item", "value", "sets", "the", "input", "or", "element", "value"], "sha": "f0087902fbea37428d677f0eee11fdc2cd3fd0d5", "url": "https://github.com/farbelous/bootstrap-popover-picker/blob/f0087902fbea37428d677f0eee11fdc2cd3fd0d5/src/js/picker.js#L612-L625", "partition": "test"}
{"repo": "flightjs/jasmine-flight", "path": "lib/jasmine-flight.js", "func_name": "setupComponent", "original_string": "function setupComponent (fixture, options) {\n    // tear down any existing component instance\n    if (this.component) {\n      this.component.teardown();\n      this.$node.remove();\n    }\n\n    if (fixture instanceof jQuery || typeof fixture === 'string') {\n      // use the fixture to create component root node\n      this.$node = $(fixture).addClass('component-root');\n    } else {\n      // create an empty component root node\n      this.$node = $('<div class=\"component-root\" />');\n      options = fixture;\n      fixture = null;\n    }\n\n    // append component root node to body\n    $('body').append(this.$node);\n\n    // normalize options\n    options = options === undefined ? {} : options;\n\n    // instantiate component on component root node\n    this.component = (new this.Component()).initialize(this.$node, options);\n  }", "language": "javascript", "code": "function setupComponent (fixture, options) {\n    // tear down any existing component instance\n    if (this.component) {\n      this.component.teardown();\n      this.$node.remove();\n    }\n\n    if (fixture instanceof jQuery || typeof fixture === 'string') {\n      // use the fixture to create component root node\n      this.$node = $(fixture).addClass('component-root');\n    } else {\n      // create an empty component root node\n      this.$node = $('<div class=\"component-root\" />');\n      options = fixture;\n      fixture = null;\n    }\n\n    // append component root node to body\n    $('body').append(this.$node);\n\n    // normalize options\n    options = options === undefined ? {} : options;\n\n    // instantiate component on component root node\n    this.component = (new this.Component()).initialize(this.$node, options);\n  }", "code_tokens": ["function", "setupComponent", "(", "fixture", ",", "options", ")", "{", "// tear down any existing component instance", "if", "(", "this", ".", "component", ")", "{", "this", ".", "component", ".", "teardown", "(", ")", ";", "this", ".", "$node", ".", "remove", "(", ")", ";", "}", "if", "(", "fixture", "instanceof", "jQuery", "||", "typeof", "fixture", "===", "'string'", ")", "{", "// use the fixture to create component root node", "this", ".", "$node", "=", "$", "(", "fixture", ")", ".", "addClass", "(", "'component-root'", ")", ";", "}", "else", "{", "// create an empty component root node", "this", ".", "$node", "=", "$", "(", "'<div class=\"component-root\" />'", ")", ";", "options", "=", "fixture", ";", "fixture", "=", "null", ";", "}", "// append component root node to body", "$", "(", "'body'", ")", ".", "append", "(", "this", ".", "$node", ")", ";", "// normalize options", "options", "=", "options", "===", "undefined", "?", "{", "}", ":", "options", ";", "// instantiate component on component root node", "this", ".", "component", "=", "(", "new", "this", ".", "Component", "(", ")", ")", ".", "initialize", "(", "this", ".", "$node", ",", "options", ")", ";", "}"], "docstring": "setupComponent\n- Assumes it has been called in the context of a jasmine spec.\n- Creates a new HTML element and attaches to it an instance of this.Component\n- If a fixture is provided, the fixture will serve as the component root.\n\n@param fixture: HTML or jQuery fixture\n@param options: component initialization options", "docstring_tokens": ["setupComponent", "-", "Assumes", "it", "has", "been", "called", "in", "the", "context", "of", "a", "jasmine", "spec", ".", "-", "Creates", "a", "new", "HTML", "element", "and", "attaches", "to", "it", "an", "instance", "of", "this", ".", "Component", "-", "If", "a", "fixture", "is", "provided", "the", "fixture", "will", "serve", "as", "the", "component", "root", "."], "sha": "8b82f490aaf239adc8369927bbf72e207efffdb1", "url": "https://github.com/flightjs/jasmine-flight/blob/8b82f490aaf239adc8369927bbf72e207efffdb1/lib/jasmine-flight.js#L20-L45", "partition": "test"}
{"repo": "cybersettler/websemble", "path": "backend/service/RESTService.js", "func_name": "", "original_string": "function(url, data) {\n    let request = parseRequest(url, data);\n    let resource = getRequestedResource(request);\n    return resource.put(request)\n      .then(returnResponse);\n\n    function returnResponse(result) { // eslint-disable-line require-jsdoc\n      return new RESTResponse(url, \"PUT\", result);\n    }\n  }", "language": "javascript", "code": "function(url, data) {\n    let request = parseRequest(url, data);\n    let resource = getRequestedResource(request);\n    return resource.put(request)\n      .then(returnResponse);\n\n    function returnResponse(result) { // eslint-disable-line require-jsdoc\n      return new RESTResponse(url, \"PUT\", result);\n    }\n  }", "code_tokens": ["function", "(", "url", ",", "data", ")", "{", "let", "request", "=", "parseRequest", "(", "url", ",", "data", ")", ";", "let", "resource", "=", "getRequestedResource", "(", "request", ")", ";", "return", "resource", ".", "put", "(", "request", ")", ".", "then", "(", "returnResponse", ")", ";", "function", "returnResponse", "(", "result", ")", "{", "// eslint-disable-line require-jsdoc", "return", "new", "RESTResponse", "(", "url", ",", "\"PUT\"", ",", "result", ")", ";", "}", "}"], "docstring": "Handle PUT request.\n@param {string} url - Resource locator.\n@param {Object} data - Resource data.\n@return {Promise} Updated resource.", "docstring_tokens": ["Handle", "PUT", "request", "."], "sha": "2cf2b3343207e7ded03f018310c9ca6680f734e8", "url": "https://github.com/cybersettler/websemble/blob/2cf2b3343207e7ded03f018310c9ca6680f734e8/backend/service/RESTService.js#L62-L71", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/DependencyInjector.js", "func_name": "resolveNamespace", "original_string": "function resolveNamespace(sNamespace) {\n  var oObj = root,\n    aElements = sNamespace.split('.'),\n    sElement;\n  while (!!( sElement = aElements.shift() )) {\n    oObj = oObj[sElement] !== und ? oObj[sElement] : oObj[sElement] = {};\n  }\n  return oObj;\n}", "language": "javascript", "code": "function resolveNamespace(sNamespace) {\n  var oObj = root,\n    aElements = sNamespace.split('.'),\n    sElement;\n  while (!!( sElement = aElements.shift() )) {\n    oObj = oObj[sElement] !== und ? oObj[sElement] : oObj[sElement] = {};\n  }\n  return oObj;\n}", "code_tokens": ["function", "resolveNamespace", "(", "sNamespace", ")", "{", "var", "oObj", "=", "root", ",", "aElements", "=", "sNamespace", ".", "split", "(", "'.'", ")", ",", "sElement", ";", "while", "(", "!", "!", "(", "sElement", "=", "aElements", ".", "shift", "(", ")", ")", ")", "{", "oObj", "=", "oObj", "[", "sElement", "]", "!==", "und", "?", "oObj", "[", "sElement", "]", ":", "oObj", "[", "sElement", "]", "=", "{", "}", ";", "}", "return", "oObj", ";", "}"], "docstring": "Create or get a namespace by a namespace defined as string\n@param {String}sNamespace\n@return {Object}\n@private", "docstring_tokens": ["Create", "or", "get", "a", "namespace", "by", "a", "namespace", "defined", "as", "string"], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/DependencyInjector.js#L60-L68", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Module.js", "func_name": "stopAll", "original_string": "function stopAll() {\n  const oModules = getModules();\n  iterateObject(oModules, function (_oModule, sModuleId) {\n    if (!isTypeOf(_oModule, sNotDefined)) {\n      _stopOneByOne(_oModule, sModuleId);\n    }\n  });\n}", "language": "javascript", "code": "function stopAll() {\n  const oModules = getModules();\n  iterateObject(oModules, function (_oModule, sModuleId) {\n    if (!isTypeOf(_oModule, sNotDefined)) {\n      _stopOneByOne(_oModule, sModuleId);\n    }\n  });\n}", "code_tokens": ["function", "stopAll", "(", ")", "{", "const", "oModules", "=", "getModules", "(", ")", ";", "iterateObject", "(", "oModules", ",", "function", "(", "_oModule", ",", "sModuleId", ")", "{", "if", "(", "!", "isTypeOf", "(", "_oModule", ",", "sNotDefined", ")", ")", "{", "_stopOneByOne", "(", "_oModule", ",", "sModuleId", ")", ";", "}", "}", ")", ";", "}"], "docstring": "stopAll is the method that will finish all the registered and started modules.", "docstring_tokens": ["stopAll", "is", "the", "method", "that", "will", "finish", "all", "the", "registered", "and", "started", "modules", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Module.js#L526-L533", "partition": "test"}
{"repo": "unfoldingWord-dev/node-resource-container", "path": "lib/utils/compression.js", "func_name": "", "original_string": "function(sourceFile, destDir) {\n        return new Promise(function(resolve, reject) {\n            var zip = new AdmZip(sourceFile);\n            try {\n                zip.extractAllTo(destDir);\n                resolve(destDir);\n            } catch(err) {\n                reject(err);\n            }\n        });\n    }", "language": "javascript", "code": "function(sourceFile, destDir) {\n        return new Promise(function(resolve, reject) {\n            var zip = new AdmZip(sourceFile);\n            try {\n                zip.extractAllTo(destDir);\n                resolve(destDir);\n            } catch(err) {\n                reject(err);\n            }\n        });\n    }", "code_tokens": ["function", "(", "sourceFile", ",", "destDir", ")", "{", "return", "new", "Promise", "(", "function", "(", "resolve", ",", "reject", ")", "{", "var", "zip", "=", "new", "AdmZip", "(", "sourceFile", ")", ";", "try", "{", "zip", ".", "extractAllTo", "(", "destDir", ")", ";", "resolve", "(", "destDir", ")", ";", "}", "catch", "(", "err", ")", "{", "reject", "(", "err", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Extracts a zip to a directory.\nThis will fail if the destination already exists.\n\n@param sourceFile {string}\n@param destDir {string}\n@returns {Promise.<string>} path to the destination", "docstring_tokens": ["Extracts", "a", "zip", "to", "a", "directory", ".", "This", "will", "fail", "if", "the", "destination", "already", "exists", "."], "sha": "20c4b7bfd2fa3f397ee7e0e743567822912c305b", "url": "https://github.com/unfoldingWord-dev/node-resource-container/blob/20c4b7bfd2fa3f397ee7e0e743567822912c305b/lib/utils/compression.js#L51-L61", "partition": "test"}
{"repo": "remarkjs/remark-validate-links", "path": "index.js", "func_name": "getHash", "original_string": "function getHash(uri) {\n  var hash = parse(uri).hash\n  return hash ? hash.slice(1) : null\n}", "language": "javascript", "code": "function getHash(uri) {\n  var hash = parse(uri).hash\n  return hash ? hash.slice(1) : null\n}", "code_tokens": ["function", "getHash", "(", "uri", ")", "{", "var", "hash", "=", "parse", "(", "uri", ")", ".", "hash", "return", "hash", "?", "hash", ".", "slice", "(", "1", ")", ":", "null", "}"], "docstring": "Get the `hash` of `uri`, if applicable.", "docstring_tokens": ["Get", "the", "hash", "of", "uri", "if", "applicable", "."], "sha": "caa1f9fa8ca09567951cf28f9252f642ab36ad9a", "url": "https://github.com/remarkjs/remark-validate-links/blob/caa1f9fa8ca09567951cf28f9252f642ab36ad9a/index.js#L418-L421", "partition": "test"}
{"repo": "rootsdev/gedcomx-fs-js", "path": "src/Error.js", "func_name": "", "original_string": "function(json){\n    \n    // Protect against forgetting the new keyword when calling the constructor\n    if(!(this instanceof Error)){\n      return new Error(json);\n    }\n    \n    // If the given object is already an instance then just return it. DON'T copy it.\n    if(Error.isInstance(json)){\n      return json;\n    }\n    \n    this.init(json);\n  }", "language": "javascript", "code": "function(json){\n    \n    // Protect against forgetting the new keyword when calling the constructor\n    if(!(this instanceof Error)){\n      return new Error(json);\n    }\n    \n    // If the given object is already an instance then just return it. DON'T copy it.\n    if(Error.isInstance(json)){\n      return json;\n    }\n    \n    this.init(json);\n  }", "code_tokens": ["function", "(", "json", ")", "{", "// Protect against forgetting the new keyword when calling the constructor", "if", "(", "!", "(", "this", "instanceof", "Error", ")", ")", "{", "return", "new", "Error", "(", "json", ")", ";", "}", "// If the given object is already an instance then just return it. DON'T copy it.", "if", "(", "Error", ".", "isInstance", "(", "json", ")", ")", "{", "return", "json", ";", "}", "this", ".", "init", "(", "json", ")", ";", "}"], "docstring": "A common representation of an error on the FamilySearch platform.\n\n@class Error\n@extends Base\n@param {Object} [json]", "docstring_tokens": ["A", "common", "representation", "of", "an", "error", "on", "the", "FamilySearch", "platform", "."], "sha": "47b6c6c9a609e163d80673d08fc83073f730d9d8", "url": "https://github.com/rootsdev/gedcomx-fs-js/blob/47b6c6c9a609e163d80673d08fc83073f730d9d8/src/Error.js#L10-L23", "partition": "test"}
{"repo": "encharm/xcase", "path": "benchmark.js", "func_name": "onCycle", "original_string": "function onCycle(event) {\n  if(objectPool.length == 0) {\n    throw new Error('Pool ran out of objects');\n  }\n  console.log(String(event.target));\n  initPool();  \n}", "language": "javascript", "code": "function onCycle(event) {\n  if(objectPool.length == 0) {\n    throw new Error('Pool ran out of objects');\n  }\n  console.log(String(event.target));\n  initPool();  \n}", "code_tokens": ["function", "onCycle", "(", "event", ")", "{", "if", "(", "objectPool", ".", "length", "==", "0", ")", "{", "throw", "new", "Error", "(", "'Pool ran out of objects'", ")", ";", "}", "console", ".", "log", "(", "String", "(", "event", ".", "target", ")", ")", ";", "initPool", "(", ")", ";", "}"], "docstring": "pool for testing in place camelizeKeys", "docstring_tokens": ["pool", "for", "testing", "in", "place", "camelizeKeys"], "sha": "8af0a2edd440639cb2385d2bfabb3f3ab2db9148", "url": "https://github.com/encharm/xcase/blob/8af0a2edd440639cb2385d2bfabb3f3ab2db9148/benchmark.js#L29-L35", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getBaseConstructorTypeOfClass", "original_string": "function getBaseConstructorTypeOfClass(type) {\n            if (!type.resolvedBaseConstructorType) {\n                var baseTypeNode = getBaseTypeNodeOfClass(type);\n                if (!baseTypeNode) {\n                    return type.resolvedBaseConstructorType = undefinedType;\n                }\n                if (!pushTypeResolution(type, 1 /* ResolvedBaseConstructorType */)) {\n                    return unknownType;\n                }\n                var baseConstructorType = checkExpression(baseTypeNode.expression);\n                if (baseConstructorType.flags & 80896 /* ObjectType */) {\n                    // Resolving the members of a class requires us to resolve the base class of that class.\n                    // We force resolution here such that we catch circularities now.\n                    resolveStructuredTypeMembers(baseConstructorType);\n                }\n                if (!popTypeResolution()) {\n                    error(type.symbol.valueDeclaration, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));\n                    return type.resolvedBaseConstructorType = unknownType;\n                }\n                if (baseConstructorType !== unknownType && baseConstructorType !== nullType && !isConstructorType(baseConstructorType)) {\n                    error(baseTypeNode.expression, ts.Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));\n                    return type.resolvedBaseConstructorType = unknownType;\n                }\n                type.resolvedBaseConstructorType = baseConstructorType;\n            }\n            return type.resolvedBaseConstructorType;\n        }", "language": "javascript", "code": "function getBaseConstructorTypeOfClass(type) {\n            if (!type.resolvedBaseConstructorType) {\n                var baseTypeNode = getBaseTypeNodeOfClass(type);\n                if (!baseTypeNode) {\n                    return type.resolvedBaseConstructorType = undefinedType;\n                }\n                if (!pushTypeResolution(type, 1 /* ResolvedBaseConstructorType */)) {\n                    return unknownType;\n                }\n                var baseConstructorType = checkExpression(baseTypeNode.expression);\n                if (baseConstructorType.flags & 80896 /* ObjectType */) {\n                    // Resolving the members of a class requires us to resolve the base class of that class.\n                    // We force resolution here such that we catch circularities now.\n                    resolveStructuredTypeMembers(baseConstructorType);\n                }\n                if (!popTypeResolution()) {\n                    error(type.symbol.valueDeclaration, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));\n                    return type.resolvedBaseConstructorType = unknownType;\n                }\n                if (baseConstructorType !== unknownType && baseConstructorType !== nullType && !isConstructorType(baseConstructorType)) {\n                    error(baseTypeNode.expression, ts.Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));\n                    return type.resolvedBaseConstructorType = unknownType;\n                }\n                type.resolvedBaseConstructorType = baseConstructorType;\n            }\n            return type.resolvedBaseConstructorType;\n        }", "code_tokens": ["function", "getBaseConstructorTypeOfClass", "(", "type", ")", "{", "if", "(", "!", "type", ".", "resolvedBaseConstructorType", ")", "{", "var", "baseTypeNode", "=", "getBaseTypeNodeOfClass", "(", "type", ")", ";", "if", "(", "!", "baseTypeNode", ")", "{", "return", "type", ".", "resolvedBaseConstructorType", "=", "undefinedType", ";", "}", "if", "(", "!", "pushTypeResolution", "(", "type", ",", "1", "/* ResolvedBaseConstructorType */", ")", ")", "{", "return", "unknownType", ";", "}", "var", "baseConstructorType", "=", "checkExpression", "(", "baseTypeNode", ".", "expression", ")", ";", "if", "(", "baseConstructorType", ".", "flags", "&", "80896", "/* ObjectType */", ")", "{", "// Resolving the members of a class requires us to resolve the base class of that class.", "// We force resolution here such that we catch circularities now.", "resolveStructuredTypeMembers", "(", "baseConstructorType", ")", ";", "}", "if", "(", "!", "popTypeResolution", "(", ")", ")", "{", "error", "(", "type", ".", "symbol", ".", "valueDeclaration", ",", "ts", ".", "Diagnostics", ".", "_0_is_referenced_directly_or_indirectly_in_its_own_base_expression", ",", "symbolToString", "(", "type", ".", "symbol", ")", ")", ";", "return", "type", ".", "resolvedBaseConstructorType", "=", "unknownType", ";", "}", "if", "(", "baseConstructorType", "!==", "unknownType", "&&", "baseConstructorType", "!==", "nullType", "&&", "!", "isConstructorType", "(", "baseConstructorType", ")", ")", "{", "error", "(", "baseTypeNode", ".", "expression", ",", "ts", ".", "Diagnostics", ".", "Type_0_is_not_a_constructor_function_type", ",", "typeToString", "(", "baseConstructorType", ")", ")", ";", "return", "type", ".", "resolvedBaseConstructorType", "=", "unknownType", ";", "}", "type", ".", "resolvedBaseConstructorType", "=", "baseConstructorType", ";", "}", "return", "type", ".", "resolvedBaseConstructorType", ";", "}"], "docstring": "The base constructor of a class can resolve to undefinedType if the class has no extends clause, unknownType if an error occurred during resolution of the extends expression, nullType if the extends expression is the null value, or an object type with at least one construct signature.", "docstring_tokens": ["The", "base", "constructor", "of", "a", "class", "can", "resolve", "to", "undefinedType", "if", "the", "class", "has", "no", "extends", "clause", "unknownType", "if", "an", "error", "occurred", "during", "resolution", "of", "the", "extends", "expression", "nullType", "if", "the", "extends", "expression", "is", "the", "null", "value", "or", "an", "object", "type", "with", "at", "least", "one", "construct", "signature", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L15796-L15822", "partition": "test"}
{"repo": "AustP/jwt-express", "path": "jwt-express.js", "func_name": "", "original_string": "function() {\n        return function(req, res, next) {\n            var jwt = req[this.options.reqProperty] || {};\n            \n            if (!jwt.valid) {\n                next(new JWTExpressError('JWT is invalid'));\n            } else {\n                next();\n            }\n        }.bind(this);\n    }", "language": "javascript", "code": "function() {\n        return function(req, res, next) {\n            var jwt = req[this.options.reqProperty] || {};\n            \n            if (!jwt.valid) {\n                next(new JWTExpressError('JWT is invalid'));\n            } else {\n                next();\n            }\n        }.bind(this);\n    }", "code_tokens": ["function", "(", ")", "{", "return", "function", "(", "req", ",", "res", ",", "next", ")", "{", "var", "jwt", "=", "req", "[", "this", ".", "options", ".", "reqProperty", "]", "||", "{", "}", ";", "if", "(", "!", "jwt", ".", "valid", ")", "{", "next", "(", "new", "JWTExpressError", "(", "'JWT is invalid'", ")", ")", ";", "}", "else", "{", "next", "(", ")", ";", "}", "}", ".", "bind", "(", "this", ")", ";", "}"], "docstring": "valid - requires that a JWT is valid\n@return function middleware", "docstring_tokens": ["valid", "-", "requires", "that", "a", "JWT", "is", "valid"], "sha": "f33e5c858e19826b7d767939a7048e3c5ff66387", "url": "https://github.com/AustP/jwt-express/blob/f33e5c858e19826b7d767939a7048e3c5ff66387/jwt-express.js#L313-L323", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/charset.js", "func_name": "parseCharset", "original_string": "function parseCharset(str, i) {\n  var match = simpleCharsetRegExp.exec(str);\n  if (!match) return null;\n\n  var charset = match[1];\n  var q = 1;\n  if (match[2]) {\n    var params = match[2].split(';')\n    for (var j = 0; j < params.length; j++) {\n      var p = params[j].trim().split('=');\n      if (p[0] === 'q') {\n        q = parseFloat(p[1]);\n        break;\n      }\n    }\n  }\n\n  return {\n    charset: charset,\n    q: q,\n    i: i\n  };\n}", "language": "javascript", "code": "function parseCharset(str, i) {\n  var match = simpleCharsetRegExp.exec(str);\n  if (!match) return null;\n\n  var charset = match[1];\n  var q = 1;\n  if (match[2]) {\n    var params = match[2].split(';')\n    for (var j = 0; j < params.length; j++) {\n      var p = params[j].trim().split('=');\n      if (p[0] === 'q') {\n        q = parseFloat(p[1]);\n        break;\n      }\n    }\n  }\n\n  return {\n    charset: charset,\n    q: q,\n    i: i\n  };\n}", "code_tokens": ["function", "parseCharset", "(", "str", ",", "i", ")", "{", "var", "match", "=", "simpleCharsetRegExp", ".", "exec", "(", "str", ")", ";", "if", "(", "!", "match", ")", "return", "null", ";", "var", "charset", "=", "match", "[", "1", "]", ";", "var", "q", "=", "1", ";", "if", "(", "match", "[", "2", "]", ")", "{", "var", "params", "=", "match", "[", "2", "]", ".", "split", "(", "';'", ")", "for", "(", "var", "j", "=", "0", ";", "j", "<", "params", ".", "length", ";", "j", "++", ")", "{", "var", "p", "=", "params", "[", "j", "]", ".", "trim", "(", ")", ".", "split", "(", "'='", ")", ";", "if", "(", "p", "[", "0", "]", "===", "'q'", ")", "{", "q", "=", "parseFloat", "(", "p", "[", "1", "]", ")", ";", "break", ";", "}", "}", "}", "return", "{", "charset", ":", "charset", ",", "q", ":", "q", ",", "i", ":", "i", "}", ";", "}"], "docstring": "Parse a charset from the Accept-Charset header.\n@private", "docstring_tokens": ["Parse", "a", "charset", "from", "the", "Accept", "-", "Charset", "header", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/charset.js#L53-L75", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(obj, callback, thisArg) {\n    return obj.filter ? obj.filter.call(obj, callback, thisArg) : filter.call(obj, callback, thisArg);\n  }", "language": "javascript", "code": "function(obj, callback, thisArg) {\n    return obj.filter ? obj.filter.call(obj, callback, thisArg) : filter.call(obj, callback, thisArg);\n  }", "code_tokens": ["function", "(", "obj", ",", "callback", ",", "thisArg", ")", "{", "return", "obj", ".", "filter", "?", "obj", ".", "filter", ".", "call", "(", "obj", ",", "callback", ",", "thisArg", ")", ":", "filter", ".", "call", "(", "obj", ",", "callback", ",", "thisArg", ")", ";", "}"], "docstring": "Calls the filter function on the passed object with a specified callback. This\nuses `Ember.ArrayPolyfill`'s-filter method when necessary.\n\n@method filter\n@param {Object} obj The object to call filter on\n@param {Function} callback The callback to execute\n@param {Object} thisArg Value to use as this when executing *callback*\n\n@return {Array} An array containing the filtered values", "docstring_tokens": ["Calls", "the", "filter", "function", "on", "the", "passed", "object", "with", "a", "specified", "callback", ".", "This", "uses", "Ember", ".", "ArrayPolyfill", "s", "-", "filter", "method", "when", "necessary", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L1946-L1948", "partition": "test"}
{"repo": "viridia/certainty", "path": "lib/format/formatSet.js", "func_name": "formatSet", "original_string": "function formatSet(value, options) {\n  return 'Set(' + registry.format(Array.from(value.values()), options) + ')';\n}", "language": "javascript", "code": "function formatSet(value, options) {\n  return 'Set(' + registry.format(Array.from(value.values()), options) + ')';\n}", "code_tokens": ["function", "formatSet", "(", "value", ",", "options", ")", "{", "return", "'Set('", "+", "registry", ".", "format", "(", "Array", ".", "from", "(", "value", ".", "values", "(", ")", ")", ",", "options", ")", "+", "')'", ";", "}"], "docstring": "Convert a set value to a printable string representation.\n@param {Set} value The value to format.\n@param {Object} options Formatting options.\n@protected", "docstring_tokens": ["Convert", "a", "set", "value", "to", "a", "printable", "string", "representation", "."], "sha": "ab4294df65dfda324ef0713a3a22657959958f80", "url": "https://github.com/viridia/certainty/blob/ab4294df65dfda324ef0713a3a22657959958f80/lib/format/formatSet.js#L8-L10", "partition": "test"}
{"repo": "node-inspector/v8-debug", "path": "InjectedScript/InjectedScriptSource.js", "func_name": "", "original_string": "function(callArgumentJson)\n    {\n        callArgumentJson = nullifyObjectProto(callArgumentJson);\n        var objectId = callArgumentJson.objectId;\n        if (objectId) {\n            var parsedArgId = this._parseObjectId(objectId);\n            if (!parsedArgId || parsedArgId[\"injectedScriptId\"] !== injectedScriptId)\n                throw \"Arguments should belong to the same JavaScript world as the target object.\";\n\n            var resolvedArg = this._objectForId(parsedArgId);\n            if (!this._isDefined(resolvedArg))\n                throw \"Could not find object with given id\";\n\n            return resolvedArg;\n        } else if (\"value\" in callArgumentJson) {\n            var value = callArgumentJson.value;\n            if (callArgumentJson.type === \"number\" && typeof value !== \"number\")\n                value = Number(value);\n            return value;\n        }\n        return undefined;\n    }", "language": "javascript", "code": "function(callArgumentJson)\n    {\n        callArgumentJson = nullifyObjectProto(callArgumentJson);\n        var objectId = callArgumentJson.objectId;\n        if (objectId) {\n            var parsedArgId = this._parseObjectId(objectId);\n            if (!parsedArgId || parsedArgId[\"injectedScriptId\"] !== injectedScriptId)\n                throw \"Arguments should belong to the same JavaScript world as the target object.\";\n\n            var resolvedArg = this._objectForId(parsedArgId);\n            if (!this._isDefined(resolvedArg))\n                throw \"Could not find object with given id\";\n\n            return resolvedArg;\n        } else if (\"value\" in callArgumentJson) {\n            var value = callArgumentJson.value;\n            if (callArgumentJson.type === \"number\" && typeof value !== \"number\")\n                value = Number(value);\n            return value;\n        }\n        return undefined;\n    }", "code_tokens": ["function", "(", "callArgumentJson", ")", "{", "callArgumentJson", "=", "nullifyObjectProto", "(", "callArgumentJson", ")", ";", "var", "objectId", "=", "callArgumentJson", ".", "objectId", ";", "if", "(", "objectId", ")", "{", "var", "parsedArgId", "=", "this", ".", "_parseObjectId", "(", "objectId", ")", ";", "if", "(", "!", "parsedArgId", "||", "parsedArgId", "[", "\"injectedScriptId\"", "]", "!==", "injectedScriptId", ")", "throw", "\"Arguments should belong to the same JavaScript world as the target object.\"", ";", "var", "resolvedArg", "=", "this", ".", "_objectForId", "(", "parsedArgId", ")", ";", "if", "(", "!", "this", ".", "_isDefined", "(", "resolvedArg", ")", ")", "throw", "\"Could not find object with given id\"", ";", "return", "resolvedArg", ";", "}", "else", "if", "(", "\"value\"", "in", "callArgumentJson", ")", "{", "var", "value", "=", "callArgumentJson", ".", "value", ";", "if", "(", "callArgumentJson", ".", "type", "===", "\"number\"", "&&", "typeof", "value", "!==", "\"number\"", ")", "value", "=", "Number", "(", "value", ")", ";", "return", "value", ";", "}", "return", "undefined", ";", "}"], "docstring": "Resolves a value from CallArgument description.\n@param {!RuntimeAgent.CallArgument} callArgumentJson\n@return {*} resolved value\n@throws {string} error message", "docstring_tokens": ["Resolves", "a", "value", "from", "CallArgument", "description", "."], "sha": "4f0e85fec5f6746ac1123f2d3061f1b53c6a404d", "url": "https://github.com/node-inspector/v8-debug/blob/4f0e85fec5f6746ac1123f2d3061f1b53c6a404d/InjectedScript/InjectedScriptSource.js#L773-L794", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/hooks/scriptsFinder.js", "func_name": "getApplicationHookScriptsFromDir", "original_string": "function getApplicationHookScriptsFromDir (dir) {\n    if (!(fs.existsSync(dir))) {\n        return [];\n    }\n\n    var compareNumbers = function (a, b) {\n        // TODO SG looks very complex, do we really need this?\n        return isNaN(parseInt(a, 10)) ? a.toLowerCase().localeCompare(b.toLowerCase ? b.toLowerCase() : b)\n            : parseInt(a, 10) > parseInt(b, 10) ? 1 : parseInt(a, 10) < parseInt(b, 10) ? -1 : 0;\n    };\n\n    var scripts = fs.readdirSync(dir).sort(compareNumbers).filter(function (s) {\n        return s[0] !== '.';\n    });\n    return scripts.map(function (scriptPath) {\n        // for old style hook files we don't use module loader for backward compatibility\n        return { path: scriptPath, fullPath: path.join(dir, scriptPath), useModuleLoader: false };\n    });\n}", "language": "javascript", "code": "function getApplicationHookScriptsFromDir (dir) {\n    if (!(fs.existsSync(dir))) {\n        return [];\n    }\n\n    var compareNumbers = function (a, b) {\n        // TODO SG looks very complex, do we really need this?\n        return isNaN(parseInt(a, 10)) ? a.toLowerCase().localeCompare(b.toLowerCase ? b.toLowerCase() : b)\n            : parseInt(a, 10) > parseInt(b, 10) ? 1 : parseInt(a, 10) < parseInt(b, 10) ? -1 : 0;\n    };\n\n    var scripts = fs.readdirSync(dir).sort(compareNumbers).filter(function (s) {\n        return s[0] !== '.';\n    });\n    return scripts.map(function (scriptPath) {\n        // for old style hook files we don't use module loader for backward compatibility\n        return { path: scriptPath, fullPath: path.join(dir, scriptPath), useModuleLoader: false };\n    });\n}", "code_tokens": ["function", "getApplicationHookScriptsFromDir", "(", "dir", ")", "{", "if", "(", "!", "(", "fs", ".", "existsSync", "(", "dir", ")", ")", ")", "{", "return", "[", "]", ";", "}", "var", "compareNumbers", "=", "function", "(", "a", ",", "b", ")", "{", "// TODO SG looks very complex, do we really need this?", "return", "isNaN", "(", "parseInt", "(", "a", ",", "10", ")", ")", "?", "a", ".", "toLowerCase", "(", ")", ".", "localeCompare", "(", "b", ".", "toLowerCase", "?", "b", ".", "toLowerCase", "(", ")", ":", "b", ")", ":", "parseInt", "(", "a", ",", "10", ")", ">", "parseInt", "(", "b", ",", "10", ")", "?", "1", ":", "parseInt", "(", "a", ",", "10", ")", "<", "parseInt", "(", "b", ",", "10", ")", "?", "-", "1", ":", "0", ";", "}", ";", "var", "scripts", "=", "fs", ".", "readdirSync", "(", "dir", ")", ".", "sort", "(", "compareNumbers", ")", ".", "filter", "(", "function", "(", "s", ")", "{", "return", "s", "[", "0", "]", "!==", "'.'", ";", "}", ")", ";", "return", "scripts", ".", "map", "(", "function", "(", "scriptPath", ")", "{", "// for old style hook files we don't use module loader for backward compatibility", "return", "{", "path", ":", "scriptPath", ",", "fullPath", ":", "path", ".", "join", "(", "dir", ",", "scriptPath", ")", ",", "useModuleLoader", ":", "false", "}", ";", "}", ")", ";", "}"], "docstring": "Gets application level hooks from the directrory specified.", "docstring_tokens": ["Gets", "application", "level", "hooks", "from", "the", "directrory", "specified", "."], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/hooks/scriptsFinder.js#L82-L100", "partition": "test"}
{"repo": "hash-bang/async-chainable", "path": "index.js", "func_name": "runWhile", "original_string": "function runWhile(iter, limit, callback) {\n\tvar index = 0;\n\tvar hasExited = false;\n\tvar err;\n\tvar running = 0;\n\tif (!Number.isFinite(limit)) limit = 10;\n\n\tvar invoke = function() {\n\t\titer.call(this._context, function(taskErr, taskResult) {\n\t\t\tif (taskErr) err = taskErr;\n\t\t\tif (taskErr || !taskResult) hasExited = true;\n\t\t\t--running;\n\t\t\tif (err && !running) {\n\t\t\t\tcallback(err, res);\n\t\t\t} else if (running <= 0 && hasExited) {\n\t\t\t\tcallback(err);\n\t\t\t} else if (!hasExited) {\n\t\t\t\tsetTimeout(invoke);\n\t\t\t}\n\t\t}, index++);\n\t};\n\n\tfor (var i = 0; i < limit; i++) {\n\t\trunning++;\n\n\t\tsetTimeout(invoke);\n\t}\n\n\treturn this;\n}", "language": "javascript", "code": "function runWhile(iter, limit, callback) {\n\tvar index = 0;\n\tvar hasExited = false;\n\tvar err;\n\tvar running = 0;\n\tif (!Number.isFinite(limit)) limit = 10;\n\n\tvar invoke = function() {\n\t\titer.call(this._context, function(taskErr, taskResult) {\n\t\t\tif (taskErr) err = taskErr;\n\t\t\tif (taskErr || !taskResult) hasExited = true;\n\t\t\t--running;\n\t\t\tif (err && !running) {\n\t\t\t\tcallback(err, res);\n\t\t\t} else if (running <= 0 && hasExited) {\n\t\t\t\tcallback(err);\n\t\t\t} else if (!hasExited) {\n\t\t\t\tsetTimeout(invoke);\n\t\t\t}\n\t\t}, index++);\n\t};\n\n\tfor (var i = 0; i < limit; i++) {\n\t\trunning++;\n\n\t\tsetTimeout(invoke);\n\t}\n\n\treturn this;\n}", "code_tokens": ["function", "runWhile", "(", "iter", ",", "limit", ",", "callback", ")", "{", "var", "index", "=", "0", ";", "var", "hasExited", "=", "false", ";", "var", "err", ";", "var", "running", "=", "0", ";", "if", "(", "!", "Number", ".", "isFinite", "(", "limit", ")", ")", "limit", "=", "10", ";", "var", "invoke", "=", "function", "(", ")", "{", "iter", ".", "call", "(", "this", ".", "_context", ",", "function", "(", "taskErr", ",", "taskResult", ")", "{", "if", "(", "taskErr", ")", "err", "=", "taskErr", ";", "if", "(", "taskErr", "||", "!", "taskResult", ")", "hasExited", "=", "true", ";", "--", "running", ";", "if", "(", "err", "&&", "!", "running", ")", "{", "callback", "(", "err", ",", "res", ")", ";", "}", "else", "if", "(", "running", "<=", "0", "&&", "hasExited", ")", "{", "callback", "(", "err", ")", ";", "}", "else", "if", "(", "!", "hasExited", ")", "{", "setTimeout", "(", "invoke", ")", ";", "}", "}", ",", "index", "++", ")", ";", "}", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "limit", ";", "i", "++", ")", "{", "running", "++", ";", "setTimeout", "(", "invoke", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Internal function to run a callback until it returns a falsy value\n@param {function} iter The function to invoke on each call with the arguments (next, index)\n@param {number} limit The number of parallel threads to execute. This must be a finite number (defaults to 10 if not)\n@param {function} callback The function to invoke when iter finally returns a falsy value\n@return {Object} This chainable object", "docstring_tokens": ["Internal", "function", "to", "run", "a", "callback", "until", "it", "returns", "a", "falsy", "value"], "sha": "9f2ef431598472ed3ac8d8a518b3108ef138c0e8", "url": "https://github.com/hash-bang/async-chainable/blob/9f2ef431598472ed3ac8d8a518b3108ef138c0e8/index.js#L1048-L1077", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "isDeeplyNestedGeneric", "original_string": "function isDeeplyNestedGeneric(type, stack, depth) {\n            // We track type references (created by createTypeReference) and instantiated types (created by instantiateType)\n            if (type.flags & (4096 /* Reference */ | 131072 /* Instantiated */) && depth >= 5) {\n                var symbol = type.symbol;\n                var count = 0;\n                for (var i = 0; i < depth; i++) {\n                    var t = stack[i];\n                    if (t.flags & (4096 /* Reference */ | 131072 /* Instantiated */) && t.symbol === symbol) {\n                        count++;\n                        if (count >= 5)\n                            return true;\n                    }\n                }\n            }\n            return false;\n        }", "language": "javascript", "code": "function isDeeplyNestedGeneric(type, stack, depth) {\n            // We track type references (created by createTypeReference) and instantiated types (created by instantiateType)\n            if (type.flags & (4096 /* Reference */ | 131072 /* Instantiated */) && depth >= 5) {\n                var symbol = type.symbol;\n                var count = 0;\n                for (var i = 0; i < depth; i++) {\n                    var t = stack[i];\n                    if (t.flags & (4096 /* Reference */ | 131072 /* Instantiated */) && t.symbol === symbol) {\n                        count++;\n                        if (count >= 5)\n                            return true;\n                    }\n                }\n            }\n            return false;\n        }", "code_tokens": ["function", "isDeeplyNestedGeneric", "(", "type", ",", "stack", ",", "depth", ")", "{", "// We track type references (created by createTypeReference) and instantiated types (created by instantiateType)", "if", "(", "type", ".", "flags", "&", "(", "4096", "/* Reference */", "|", "131072", "/* Instantiated */", ")", "&&", "depth", ">=", "5", ")", "{", "var", "symbol", "=", "type", ".", "symbol", ";", "var", "count", "=", "0", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "depth", ";", "i", "++", ")", "{", "var", "t", "=", "stack", "[", "i", "]", ";", "if", "(", "t", ".", "flags", "&", "(", "4096", "/* Reference */", "|", "131072", "/* Instantiated */", ")", "&&", "t", ".", "symbol", "===", "symbol", ")", "{", "count", "++", ";", "if", "(", "count", ">=", "5", ")", "return", "true", ";", "}", "}", "}", "return", "false", ";", "}"], "docstring": "Return true if the given type is part of a deeply nested chain of generic instantiations. We consider this to be the case when structural type comparisons have been started for 10 or more instantiations of the same generic type. It is possible, though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely expanding. Effectively, we will generate a false positive when two types are structurally equal to at least 10 levels, but unequal at some level beyond that.", "docstring_tokens": ["Return", "true", "if", "the", "given", "type", "is", "part", "of", "a", "deeply", "nested", "chain", "of", "generic", "instantiations", ".", "We", "consider", "this", "to", "be", "the", "case", "when", "structural", "type", "comparisons", "have", "been", "started", "for", "10", "or", "more", "instantiations", "of", "the", "same", "generic", "type", ".", "It", "is", "possible", "though", "highly", "unlikely", "for", "this", "test", "to", "be", "true", "in", "a", "situation", "where", "a", "chain", "of", "instantiations", "is", "not", "infinitely", "expanding", ".", "Effectively", "we", "will", "generate", "a", "false", "positive", "when", "two", "types", "are", "structurally", "equal", "to", "at", "least", "10", "levels", "but", "unequal", "at", "some", "level", "beyond", "that", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L18338-L18353", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "createTimeRangesObj", "original_string": "function createTimeRangesObj(ranges) {\n  if (ranges === undefined || ranges.length === 0) {\n    return {\n      length: 0,\n      start: function start() {\n        throw new Error('This TimeRanges object is empty');\n      },\n      end: function end() {\n        throw new Error('This TimeRanges object is empty');\n      }\n    };\n  }\n  return {\n    length: ranges.length,\n    start: getRange.bind(null, 'start', 0, ranges),\n    end: getRange.bind(null, 'end', 1, ranges)\n  };\n}", "language": "javascript", "code": "function createTimeRangesObj(ranges) {\n  if (ranges === undefined || ranges.length === 0) {\n    return {\n      length: 0,\n      start: function start() {\n        throw new Error('This TimeRanges object is empty');\n      },\n      end: function end() {\n        throw new Error('This TimeRanges object is empty');\n      }\n    };\n  }\n  return {\n    length: ranges.length,\n    start: getRange.bind(null, 'start', 0, ranges),\n    end: getRange.bind(null, 'end', 1, ranges)\n  };\n}", "code_tokens": ["function", "createTimeRangesObj", "(", "ranges", ")", "{", "if", "(", "ranges", "===", "undefined", "||", "ranges", ".", "length", "===", "0", ")", "{", "return", "{", "length", ":", "0", ",", "start", ":", "function", "start", "(", ")", "{", "throw", "new", "Error", "(", "'This TimeRanges object is empty'", ")", ";", "}", ",", "end", ":", "function", "end", "(", ")", "{", "throw", "new", "Error", "(", "'This TimeRanges object is empty'", ")", ";", "}", "}", ";", "}", "return", "{", "length", ":", "ranges", ".", "length", ",", "start", ":", "getRange", ".", "bind", "(", "null", ",", "'start'", ",", "0", ",", "ranges", ")", ",", "end", ":", "getRange", ".", "bind", "(", "null", ",", "'end'", ",", "1", ",", "ranges", ")", "}", ";", "}"], "docstring": "Create a time range object givent ranges of time.\n\n@param {Array} [ranges]\nAn array of time ranges.", "docstring_tokens": ["Create", "a", "time", "range", "object", "givent", "ranges", "of", "time", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L4695-L4712", "partition": "test"}
{"repo": "Raynos/graphics", "path": "element/plain-text.js", "func_name": "plainText", "original_string": "function plainText(content) {\n    var textSize = getTextSize(content)\n\n    return new Element(new TextElement(\"left\", content)\n        , textSize.width, textSize.height)\n}", "language": "javascript", "code": "function plainText(content) {\n    var textSize = getTextSize(content)\n\n    return new Element(new TextElement(\"left\", content)\n        , textSize.width, textSize.height)\n}", "code_tokens": ["function", "plainText", "(", "content", ")", "{", "var", "textSize", "=", "getTextSize", "(", "content", ")", "return", "new", "Element", "(", "new", "TextElement", "(", "\"left\"", ",", "content", ")", ",", "textSize", ".", "width", ",", "textSize", ".", "height", ")", "}"], "docstring": "String -> Element", "docstring_tokens": ["String", "-", ">", "Element"], "sha": "6c156db7419c9f02b22d277c0579432c7f261e68", "url": "https://github.com/Raynos/graphics/blob/6c156db7419c9f02b22d277c0579432c7f261e68/element/plain-text.js#L29-L34", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "wrapGlob", "original_string": "function wrapGlob(glob, opts) {\n  var prefix = (opts && !opts.contains) ? '^' : '';\n  var after = (opts && !opts.contains) ? '$' : '';\n  glob = ('(?:' + glob + ')' + after);\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n  return prefix + glob;\n}", "language": "javascript", "code": "function wrapGlob(glob, opts) {\n  var prefix = (opts && !opts.contains) ? '^' : '';\n  var after = (opts && !opts.contains) ? '$' : '';\n  glob = ('(?:' + glob + ')' + after);\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n  return prefix + glob;\n}", "code_tokens": ["function", "wrapGlob", "(", "glob", ",", "opts", ")", "{", "var", "prefix", "=", "(", "opts", "&&", "!", "opts", ".", "contains", ")", "?", "'^'", ":", "''", ";", "var", "after", "=", "(", "opts", "&&", "!", "opts", ".", "contains", ")", "?", "'$'", ":", "''", ";", "glob", "=", "(", "'(?:'", "+", "glob", "+", "')'", "+", "after", ")", ";", "if", "(", "opts", "&&", "opts", ".", "negate", ")", "{", "return", "prefix", "+", "(", "'(?!^'", "+", "glob", "+", "').*$'", ")", ";", "}", "return", "prefix", "+", "glob", ";", "}"], "docstring": "Create the regex to do the matching. If the leading\ncharacter in the `glob` is `!` a negation regex is returned.\n\n@param {String} `glob`\n@param {Boolean} `negate`", "docstring_tokens": ["Create", "the", "regex", "to", "do", "the", "matching", ".", "If", "the", "leading", "character", "in", "the", "glob", "is", "!", "a", "negation", "regex", "is", "returned", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L42401-L42409", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(obj) {\n    Ember.assert('Must pass a valid object to Ember.Binding.disconnect()', !!obj);\n\n    var twoWay = !this._oneWay;\n\n    // remove an observer on the object so we're no longer notified of\n    // changes that should update bindings.\n    Ember.removeObserver(obj, this._from, this, this.fromDidChange);\n\n    // if the binding is two-way, remove the observer from the target as well\n    if (twoWay) { Ember.removeObserver(obj, this._to, this, this.toDidChange); }\n\n    this._readyToSync = false; // disable scheduled syncs...\n    return this;\n  }", "language": "javascript", "code": "function(obj) {\n    Ember.assert('Must pass a valid object to Ember.Binding.disconnect()', !!obj);\n\n    var twoWay = !this._oneWay;\n\n    // remove an observer on the object so we're no longer notified of\n    // changes that should update bindings.\n    Ember.removeObserver(obj, this._from, this, this.fromDidChange);\n\n    // if the binding is two-way, remove the observer from the target as well\n    if (twoWay) { Ember.removeObserver(obj, this._to, this, this.toDidChange); }\n\n    this._readyToSync = false; // disable scheduled syncs...\n    return this;\n  }", "code_tokens": ["function", "(", "obj", ")", "{", "Ember", ".", "assert", "(", "'Must pass a valid object to Ember.Binding.disconnect()'", ",", "!", "!", "obj", ")", ";", "var", "twoWay", "=", "!", "this", ".", "_oneWay", ";", "// remove an observer on the object so we're no longer notified of", "// changes that should update bindings.", "Ember", ".", "removeObserver", "(", "obj", ",", "this", ".", "_from", ",", "this", ",", "this", ".", "fromDidChange", ")", ";", "// if the binding is two-way, remove the observer from the target as well", "if", "(", "twoWay", ")", "{", "Ember", ".", "removeObserver", "(", "obj", ",", "this", ".", "_to", ",", "this", ",", "this", ".", "toDidChange", ")", ";", "}", "this", ".", "_readyToSync", "=", "false", ";", "// disable scheduled syncs...", "return", "this", ";", "}"], "docstring": "Disconnects the binding instance. Changes will no longer be relayed. You\nwill not usually need to call this method.\n\n@method disconnect\n@param {Object} obj The root object you passed when connecting the binding.\n@return {Ember.Binding} `this`", "docstring_tokens": ["Disconnects", "the", "binding", "instance", ".", "Changes", "will", "no", "longer", "be", "relayed", ".", "You", "will", "not", "usually", "need", "to", "call", "this", "method", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L7402-L7416", "partition": "test"}
{"repo": "WebReflection/dom4", "path": "build/dom4.max.js", "func_name": "CustomEvent", "original_string": "function CustomEvent(type, eventInitDict) {\n        /*jshint eqnull:true */\n        var event = document.createEvent(eventName);\n        if (typeof type != 'string') {\n          throw new Error('An event name must be provided');\n        }\n        if (eventName == 'Event') {\n          event.initCustomEvent = initCustomEvent;\n        }\n        if (eventInitDict == null) {\n          eventInitDict = defaultInitDict;\n        }\n        event.initCustomEvent(\n          type,\n          eventInitDict.bubbles,\n          eventInitDict.cancelable,\n          eventInitDict.detail\n        );\n        return event;\n      }", "language": "javascript", "code": "function CustomEvent(type, eventInitDict) {\n        /*jshint eqnull:true */\n        var event = document.createEvent(eventName);\n        if (typeof type != 'string') {\n          throw new Error('An event name must be provided');\n        }\n        if (eventName == 'Event') {\n          event.initCustomEvent = initCustomEvent;\n        }\n        if (eventInitDict == null) {\n          eventInitDict = defaultInitDict;\n        }\n        event.initCustomEvent(\n          type,\n          eventInitDict.bubbles,\n          eventInitDict.cancelable,\n          eventInitDict.detail\n        );\n        return event;\n      }", "code_tokens": ["function", "CustomEvent", "(", "type", ",", "eventInitDict", ")", "{", "/*jshint eqnull:true */", "var", "event", "=", "document", ".", "createEvent", "(", "eventName", ")", ";", "if", "(", "typeof", "type", "!=", "'string'", ")", "{", "throw", "new", "Error", "(", "'An event name must be provided'", ")", ";", "}", "if", "(", "eventName", "==", "'Event'", ")", "{", "event", ".", "initCustomEvent", "=", "initCustomEvent", ";", "}", "if", "(", "eventInitDict", "==", "null", ")", "{", "eventInitDict", "=", "defaultInitDict", ";", "}", "event", ".", "initCustomEvent", "(", "type", ",", "eventInitDict", ".", "bubbles", ",", "eventInitDict", ".", "cancelable", ",", "eventInitDict", ".", "detail", ")", ";", "return", "event", ";", "}"], "docstring": "the infamous substitute", "docstring_tokens": ["the", "infamous", "substitute"], "sha": "2189e1b75d442ab4f776e69d0d77d23b8ed4581b", "url": "https://github.com/WebReflection/dom4/blob/2189e1b75d442ab4f776e69d0d77d23b8ed4581b/build/dom4.max.js#L456-L475", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Module.js", "func_name": "_delete", "original_string": "function _delete(sModuleId) {\n  const oModules = getModules();\n  if (!isTypeOf(oModules[sModuleId], sNotDefined)) {\n    delete oModules[sModuleId];\n    return true;\n  }\n  return false;\n}", "language": "javascript", "code": "function _delete(sModuleId) {\n  const oModules = getModules();\n  if (!isTypeOf(oModules[sModuleId], sNotDefined)) {\n    delete oModules[sModuleId];\n    return true;\n  }\n  return false;\n}", "code_tokens": ["function", "_delete", "(", "sModuleId", ")", "{", "const", "oModules", "=", "getModules", "(", ")", ";", "if", "(", "!", "isTypeOf", "(", "oModules", "[", "sModuleId", "]", ",", "sNotDefined", ")", ")", "{", "delete", "oModules", "[", "sModuleId", "]", ";", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "_delete is a wrapper method that will call the native delete javascript function\nIt's important to test the full code.\n@param {String} sModuleId\n@return {Boolean}", "docstring_tokens": ["_delete", "is", "a", "wrapper", "method", "that", "will", "call", "the", "native", "delete", "javascript", "function", "It", "s", "important", "to", "test", "the", "full", "code", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Module.js#L573-L580", "partition": "test"}
{"repo": "bkrem/react-d3-tree", "path": "src/util/index.js", "func_name": "parseFlatJSON", "original_string": "function parseFlatJSON(jsonFilePath, attributeFields) {\n  return new Promise((resolve, reject) => {\n    try {\n      json(jsonFilePath, data => resolve(_transformToHierarchy(data, attributeFields)));\n    } catch (err) {\n      reject(err);\n    }\n  });\n}", "language": "javascript", "code": "function parseFlatJSON(jsonFilePath, attributeFields) {\n  return new Promise((resolve, reject) => {\n    try {\n      json(jsonFilePath, data => resolve(_transformToHierarchy(data, attributeFields)));\n    } catch (err) {\n      reject(err);\n    }\n  });\n}", "code_tokens": ["function", "parseFlatJSON", "(", "jsonFilePath", ",", "attributeFields", ")", "{", "return", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "try", "{", "json", "(", "jsonFilePath", ",", "data", "=>", "resolve", "(", "_transformToHierarchy", "(", "data", ",", "attributeFields", ")", ")", ")", ";", "}", "catch", "(", "err", ")", "{", "reject", "(", "err", ")", ";", "}", "}", ")", ";", "}"], "docstring": "parseFlatJSON - Parses a flat JSON file into a hierarchy structure.\n\n@param {string} jsonFilePath Path to flat JSON file to be parsed.\n@param {array<string>|undefined} attributeFields Set of `link` fields to be used as attributes\n\n@return {Promise} Returns hierarchy array if resolved, error object if rejected.", "docstring_tokens": ["parseFlatJSON", "-", "Parses", "a", "flat", "JSON", "file", "into", "a", "hierarchy", "structure", "."], "sha": "9084afca0f35e73dd6b7e7433a09907decd9f308", "url": "https://github.com/bkrem/react-d3-tree/blob/9084afca0f35e73dd6b7e7433a09907decd9f308/src/util/index.js#L107-L115", "partition": "test"}
{"repo": "BeneathTheInk/temple-mustache", "path": "src/model.js", "func_name": "", "original_string": "function(fn) {\n\t\tvar index = 0,\n\t\t\tmodel = this;\n\n\t\twhile (model != null) {\n\t\t\tif (fn.call(this, model, index++)) return model;\n\t\t\tmodel = model.parent;\n\t\t}\n\t}", "language": "javascript", "code": "function(fn) {\n\t\tvar index = 0,\n\t\t\tmodel = this;\n\n\t\twhile (model != null) {\n\t\t\tif (fn.call(this, model, index++)) return model;\n\t\t\tmodel = model.parent;\n\t\t}\n\t}", "code_tokens": ["function", "(", "fn", ")", "{", "var", "index", "=", "0", ",", "model", "=", "this", ";", "while", "(", "model", "!=", "null", ")", "{", "if", "(", "fn", ".", "call", "(", "this", ",", "model", ",", "index", "++", ")", ")", "return", "model", ";", "model", "=", "model", ".", "parent", ";", "}", "}"], "docstring": "returns the first model which passes the function", "docstring_tokens": ["returns", "the", "first", "model", "which", "passes", "the", "function"], "sha": "5a66d6a443f5f98f09483fd03d9ba9ee11fb4ae9", "url": "https://github.com/BeneathTheInk/temple-mustache/blob/5a66d6a443f5f98f09483fd03d9ba9ee11fb4ae9/src/model.js#L86-L94", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(callback, binding) {\n    get(this, 'relationshipsByName').forEach(function(name, relationship) {\n      callback.call(binding, name, relationship);\n    });\n  }", "language": "javascript", "code": "function(callback, binding) {\n    get(this, 'relationshipsByName').forEach(function(name, relationship) {\n      callback.call(binding, name, relationship);\n    });\n  }", "code_tokens": ["function", "(", "callback", ",", "binding", ")", "{", "get", "(", "this", ",", "'relationshipsByName'", ")", ".", "forEach", "(", "function", "(", "name", ",", "relationship", ")", "{", "callback", ".", "call", "(", "binding", ",", "name", ",", "relationship", ")", ";", "}", ")", ";", "}"], "docstring": "Given a callback, iterates over each of the relationships in the model,\ninvoking the callback with the name of each relationship and its relationship\ndescriptor.\n\n@method eachRelationship\n@static\n@param {Function} callback the callback to invoke\n@param {any} binding the value to which the callback's `this` should be bound", "docstring_tokens": ["Given", "a", "callback", "iterates", "over", "each", "of", "the", "relationships", "in", "the", "model", "invoking", "the", "callback", "with", "the", "name", "of", "each", "relationship", "and", "its", "relationship", "descriptor", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L7115-L7119", "partition": "test"}
{"repo": "rootsdev/gedcomx-fs-js", "path": "src/Reservation.js", "func_name": "", "original_string": "function(json){\n    \n    // Protect against forgetting the new keyword when calling the constructor\n    if(!(this instanceof Reservation)){\n      return new Reservation(json);\n    }\n    \n    // If the given object is already an instance then just return it. DON'T copy it.\n    if(Reservation.isInstance(json)){\n      return json;\n    }\n    \n    this.init(json);\n  }", "language": "javascript", "code": "function(json){\n    \n    // Protect against forgetting the new keyword when calling the constructor\n    if(!(this instanceof Reservation)){\n      return new Reservation(json);\n    }\n    \n    // If the given object is already an instance then just return it. DON'T copy it.\n    if(Reservation.isInstance(json)){\n      return json;\n    }\n    \n    this.init(json);\n  }", "code_tokens": ["function", "(", "json", ")", "{", "// Protect against forgetting the new keyword when calling the constructor", "if", "(", "!", "(", "this", "instanceof", "Reservation", ")", ")", "{", "return", "new", "Reservation", "(", "json", ")", ";", "}", "// If the given object is already an instance then just return it. DON'T copy it.", "if", "(", "Reservation", ".", "isInstance", "(", "json", ")", ")", "{", "return", "json", ";", "}", "this", ".", "init", "(", "json", ")", ";", "}"], "docstring": "LDS ordinance reservation\n\n@class Reservation\n@extends Conclusion\n@param {Object} [json]", "docstring_tokens": ["LDS", "ordinance", "reservation"], "sha": "47b6c6c9a609e163d80673d08fc83073f730d9d8", "url": "https://github.com/rootsdev/gedcomx-fs-js/blob/47b6c6c9a609e163d80673d08fc83073f730d9d8/src/Reservation.js#L10-L23", "partition": "test"}
{"repo": "italia/bootstrap-italia", "path": "src/js/plugins/password-strength-meter/password-strength-meter.js", "func_name": "scoreText", "original_string": "function scoreText(score) {\n      if (score === -1) {\n        return options.shortPass\n      }\n\n      score = score < 0 ? 0 : score\n\n      if (score < 26) {\n        return options.shortPass\n      }\n      if (score < 51) {\n        return options.badPass\n      }\n      if (score < 76) {\n        return options.goodPass\n      }\n\n      return options.strongPass\n    }", "language": "javascript", "code": "function scoreText(score) {\n      if (score === -1) {\n        return options.shortPass\n      }\n\n      score = score < 0 ? 0 : score\n\n      if (score < 26) {\n        return options.shortPass\n      }\n      if (score < 51) {\n        return options.badPass\n      }\n      if (score < 76) {\n        return options.goodPass\n      }\n\n      return options.strongPass\n    }", "code_tokens": ["function", "scoreText", "(", "score", ")", "{", "if", "(", "score", "===", "-", "1", ")", "{", "return", "options", ".", "shortPass", "}", "score", "=", "score", "<", "0", "?", "0", ":", "score", "if", "(", "score", "<", "26", ")", "{", "return", "options", ".", "shortPass", "}", "if", "(", "score", "<", "51", ")", "{", "return", "options", ".", "badPass", "}", "if", "(", "score", "<", "76", ")", "{", "return", "options", ".", "goodPass", "}", "return", "options", ".", "strongPass", "}"], "docstring": "Returns strings based on the score given.\n\n@param int score Score base.\n@return string", "docstring_tokens": ["Returns", "strings", "based", "on", "the", "score", "given", "."], "sha": "9d2177a1c0c731f83636d2164bd22702ef5767c2", "url": "https://github.com/italia/bootstrap-italia/blob/9d2177a1c0c731f83636d2164bd22702ef5767c2/src/js/plugins/password-strength-meter/password-strength-meter.js#L27-L45", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(key, value) {\n    var exactValue = function(item) { return get(item, key) === value; },\n        hasValue = function(item) { return !!get(item, key); },\n        use = (arguments.length === 2 ? exactValue : hasValue);\n\n    return this.reject(use);\n  }", "language": "javascript", "code": "function(key, value) {\n    var exactValue = function(item) { return get(item, key) === value; },\n        hasValue = function(item) { return !!get(item, key); },\n        use = (arguments.length === 2 ? exactValue : hasValue);\n\n    return this.reject(use);\n  }", "code_tokens": ["function", "(", "key", ",", "value", ")", "{", "var", "exactValue", "=", "function", "(", "item", ")", "{", "return", "get", "(", "item", ",", "key", ")", "===", "value", ";", "}", ",", "hasValue", "=", "function", "(", "item", ")", "{", "return", "!", "!", "get", "(", "item", ",", "key", ")", ";", "}", ",", "use", "=", "(", "arguments", ".", "length", "===", "2", "?", "exactValue", ":", "hasValue", ")", ";", "return", "this", ".", "reject", "(", "use", ")", ";", "}"], "docstring": "Returns an array with the items that do not have truthy values for\nkey.  You can pass an optional second argument with the target value.  Otherwise\nthis will match any property that evaluates to false.\n\n@method rejectBy\n@param {String} key the property to test\n@param {String} [value] optional value to test against.\n@return {Array} rejected array", "docstring_tokens": ["Returns", "an", "array", "with", "the", "items", "that", "do", "not", "have", "truthy", "values", "for", "key", ".", "You", "can", "pass", "an", "optional", "second", "argument", "with", "the", "target", "value", ".", "Otherwise", "this", "will", "match", "any", "property", "that", "evaluates", "to", "false", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L14373-L14379", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( modelType ) {\n\t\t\t_.find( this._subModels, function( subModelDef ) {\n\t\t\t\treturn _.find( subModelDef.subModels || [], function( subModelTypeName, typeValue ) {\n\t\t\t\t\tvar subModelType = this.getObjectByName( subModelTypeName );\n\n\t\t\t\t\tif ( modelType === subModelType ) {\n\t\t\t\t\t\t// Set 'modelType' as a child of the found superModel\n\t\t\t\t\t\tsubModelDef.superModelType._subModels[ typeValue ] = modelType;\n\n\t\t\t\t\t\t// Set '_superModel', '_subModelTypeValue', and '_subModelTypeAttribute' on 'modelType'.\n\t\t\t\t\t\tmodelType._superModel = subModelDef.superModelType;\n\t\t\t\t\t\tmodelType._subModelTypeValue = typeValue;\n\t\t\t\t\t\tmodelType._subModelTypeAttribute = subModelDef.superModelType.prototype.subModelTypeAttribute;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}, this );\n\t\t\t}, this );\n\t\t}", "language": "javascript", "code": "function( modelType ) {\n\t\t\t_.find( this._subModels, function( subModelDef ) {\n\t\t\t\treturn _.find( subModelDef.subModels || [], function( subModelTypeName, typeValue ) {\n\t\t\t\t\tvar subModelType = this.getObjectByName( subModelTypeName );\n\n\t\t\t\t\tif ( modelType === subModelType ) {\n\t\t\t\t\t\t// Set 'modelType' as a child of the found superModel\n\t\t\t\t\t\tsubModelDef.superModelType._subModels[ typeValue ] = modelType;\n\n\t\t\t\t\t\t// Set '_superModel', '_subModelTypeValue', and '_subModelTypeAttribute' on 'modelType'.\n\t\t\t\t\t\tmodelType._superModel = subModelDef.superModelType;\n\t\t\t\t\t\tmodelType._subModelTypeValue = typeValue;\n\t\t\t\t\t\tmodelType._subModelTypeAttribute = subModelDef.superModelType.prototype.subModelTypeAttribute;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}, this );\n\t\t\t}, this );\n\t\t}", "code_tokens": ["function", "(", "modelType", ")", "{", "_", ".", "find", "(", "this", ".", "_subModels", ",", "function", "(", "subModelDef", ")", "{", "return", "_", ".", "find", "(", "subModelDef", ".", "subModels", "||", "[", "]", ",", "function", "(", "subModelTypeName", ",", "typeValue", ")", "{", "var", "subModelType", "=", "this", ".", "getObjectByName", "(", "subModelTypeName", ")", ";", "if", "(", "modelType", "===", "subModelType", ")", "{", "// Set 'modelType' as a child of the found superModel", "subModelDef", ".", "superModelType", ".", "_subModels", "[", "typeValue", "]", "=", "modelType", ";", "// Set '_superModel', '_subModelTypeValue', and '_subModelTypeAttribute' on 'modelType'.", "modelType", ".", "_superModel", "=", "subModelDef", ".", "superModelType", ";", "modelType", ".", "_subModelTypeValue", "=", "typeValue", ";", "modelType", ".", "_subModelTypeAttribute", "=", "subModelDef", ".", "superModelType", ".", "prototype", ".", "subModelTypeAttribute", ";", "return", "true", ";", "}", "}", ",", "this", ")", ";", "}", ",", "this", ")", ";", "}"], "docstring": "Check if the given modelType is registered as another model's subModel. If so, add it to the super model's\n'_subModels', and set the modelType's '_superModel', '_subModelTypeName', and '_subModelTypeAttribute'.\n\n@param {Backbone.RelationalModel} modelType", "docstring_tokens": ["Check", "if", "the", "given", "modelType", "is", "registered", "as", "another", "model", "s", "subModel", ".", "If", "so", "add", "it", "to", "the", "super", "model", "s", "_subModels", "and", "set", "the", "modelType", "s", "_superModel", "_subModelTypeName", "and", "_subModelTypeAttribute", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L193-L210", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "getEventTargetDocument", "original_string": "function getEventTargetDocument(eventTarget) {\n  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n}", "language": "javascript", "code": "function getEventTargetDocument(eventTarget) {\n  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n}", "code_tokens": ["function", "getEventTargetDocument", "(", "eventTarget", ")", "{", "return", "eventTarget", ".", "window", "===", "eventTarget", "?", "eventTarget", ".", "document", ":", "eventTarget", ".", "nodeType", "===", "DOCUMENT_NODE", "?", "eventTarget", ":", "eventTarget", ".", "ownerDocument", ";", "}"], "docstring": "Get document associated with the event target.\n\n@param {object} nativeEventTarget\n@return {Document}", "docstring_tokens": ["Get", "document", "associated", "with", "the", "event", "target", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L7901-L7903", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/charset.js", "func_name": "preferredCharsets", "original_string": "function preferredCharsets(accept, provided) {\n  // RFC 2616 sec 14.2: no header = *\n  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');\n\n  if (!provided) {\n    // sorted list of all charsets\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullCharset);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getCharsetPriority(type, accepts, index);\n  });\n\n  // sorted list of accepted charsets\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}", "language": "javascript", "code": "function preferredCharsets(accept, provided) {\n  // RFC 2616 sec 14.2: no header = *\n  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');\n\n  if (!provided) {\n    // sorted list of all charsets\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullCharset);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getCharsetPriority(type, accepts, index);\n  });\n\n  // sorted list of accepted charsets\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}", "code_tokens": ["function", "preferredCharsets", "(", "accept", ",", "provided", ")", "{", "// RFC 2616 sec 14.2: no header = *", "var", "accepts", "=", "parseAcceptCharset", "(", "accept", "===", "undefined", "?", "'*'", ":", "accept", "||", "''", ")", ";", "if", "(", "!", "provided", ")", "{", "// sorted list of all charsets", "return", "accepts", ".", "filter", "(", "isQuality", ")", ".", "sort", "(", "compareSpecs", ")", ".", "map", "(", "getFullCharset", ")", ";", "}", "var", "priorities", "=", "provided", ".", "map", "(", "function", "getPriority", "(", "type", ",", "index", ")", "{", "return", "getCharsetPriority", "(", "type", ",", "accepts", ",", "index", ")", ";", "}", ")", ";", "// sorted list of accepted charsets", "return", "priorities", ".", "filter", "(", "isQuality", ")", ".", "sort", "(", "compareSpecs", ")", ".", "map", "(", "function", "getCharset", "(", "priority", ")", "{", "return", "provided", "[", "priorities", ".", "indexOf", "(", "priority", ")", "]", ";", "}", ")", ";", "}"], "docstring": "Get the preferred charsets from an Accept-Charset header.\n@public", "docstring_tokens": ["Get", "the", "preferred", "charsets", "from", "an", "Accept", "-", "Charset", "header", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/charset.js#L122-L142", "partition": "test"}
{"repo": "sportngin/ngin_client_node", "path": "src/sports/division.js", "func_name": "scopeUrl", "original_string": "function scopeUrl(options, inst) {\n    options = _.extend({}, inst, options)\n    if (!options.season_id)\n      throw new Error('season_id required to make division instance api calls')\n\n    return ngin.Season.urlRoot() + '/' + options.season_id + Division.urlRoot()\n  }", "language": "javascript", "code": "function scopeUrl(options, inst) {\n    options = _.extend({}, inst, options)\n    if (!options.season_id)\n      throw new Error('season_id required to make division instance api calls')\n\n    return ngin.Season.urlRoot() + '/' + options.season_id + Division.urlRoot()\n  }", "code_tokens": ["function", "scopeUrl", "(", "options", ",", "inst", ")", "{", "options", "=", "_", ".", "extend", "(", "{", "}", ",", "inst", ",", "options", ")", "if", "(", "!", "options", ".", "season_id", ")", "throw", "new", "Error", "(", "'season_id required to make division instance api calls'", ")", "return", "ngin", ".", "Season", ".", "urlRoot", "(", ")", "+", "'/'", "+", "options", ".", "season_id", "+", "Division", ".", "urlRoot", "(", ")", "}"], "docstring": "Scopes the url to the season\n\n@param {Object} options\n@returns {String}\n@api public", "docstring_tokens": ["Scopes", "the", "url", "to", "the", "season"], "sha": "dafed7f3b86e86b01f7d5fd707d4a8d608258fe9", "url": "https://github.com/sportngin/ngin_client_node/blob/dafed7f3b86e86b01f7d5fd707d4a8d608258fe9/src/sports/division.js#L18-L24", "partition": "test"}
{"repo": "formio/angular-formio", "path": "tools/gulp/inline-resources.js", "func_name": "buildSass", "original_string": "function buildSass(content, sourceFile) {\n  try {\n    const result = sass.renderSync({\n      data: content,\n      file: sourceFile,\n      importer: tildeImporter\n    });\n    return result.css.toString()\n  } catch (e) {\n    console.error('\\x1b[41m');\n    console.error('at ' + sourceFile + ':' + e.line + \":\" + e.column);\n    console.error(e.formatted);\n    console.error('\\x1b[0m');\n    return \"\";\n  }\n}", "language": "javascript", "code": "function buildSass(content, sourceFile) {\n  try {\n    const result = sass.renderSync({\n      data: content,\n      file: sourceFile,\n      importer: tildeImporter\n    });\n    return result.css.toString()\n  } catch (e) {\n    console.error('\\x1b[41m');\n    console.error('at ' + sourceFile + ':' + e.line + \":\" + e.column);\n    console.error(e.formatted);\n    console.error('\\x1b[0m');\n    return \"\";\n  }\n}", "code_tokens": ["function", "buildSass", "(", "content", ",", "sourceFile", ")", "{", "try", "{", "const", "result", "=", "sass", ".", "renderSync", "(", "{", "data", ":", "content", ",", "file", ":", "sourceFile", ",", "importer", ":", "tildeImporter", "}", ")", ";", "return", "result", ".", "css", ".", "toString", "(", ")", "}", "catch", "(", "e", ")", "{", "console", ".", "error", "(", "'\\x1b[41m'", ")", ";", "console", ".", "error", "(", "'at '", "+", "sourceFile", "+", "':'", "+", "e", ".", "line", "+", "\":\"", "+", "e", ".", "column", ")", ";", "console", ".", "error", "(", "e", ".", "formatted", ")", ";", "console", ".", "error", "(", "'\\x1b[0m'", ")", ";", "return", "\"\"", ";", "}", "}"], "docstring": "build sass content to css\n@param content {string} the css content\n@param sourceFile {string} the scss file sourceFile\n@return {string} the generated css, empty string if error occured", "docstring_tokens": ["build", "sass", "content", "to", "css"], "sha": "127eb556cb8fa810cdf06b3d7b80901f9ac055f9", "url": "https://github.com/formio/angular-formio/blob/127eb556cb8fa810cdf06b3d7b80901f9ac055f9/tools/gulp/inline-resources.js#L123-L138", "partition": "test"}
{"repo": "jsantell/GhostTrain", "path": "lib/sendRequest.js", "func_name": "render", "original_string": "function render (req, res, body) {\n  var response = {};\n  var parsedURL = parseURL(req.url);\n\n  // Append URL properties\n  for (var prop in parsedURL)\n    response[prop] = parsedURL[prop];\n\n  // Append select `req` properties\n  ['method', 'url'].forEach(function (prop) {\n    response[prop] = req[prop];\n  });\n\n  // Append select `res` properties\n  ['headers', 'statusCode'].forEach(function (prop) {\n    response[prop] = res[prop];\n  });\n\n  response.body = body;\n\n  return response;\n}", "language": "javascript", "code": "function render (req, res, body) {\n  var response = {};\n  var parsedURL = parseURL(req.url);\n\n  // Append URL properties\n  for (var prop in parsedURL)\n    response[prop] = parsedURL[prop];\n\n  // Append select `req` properties\n  ['method', 'url'].forEach(function (prop) {\n    response[prop] = req[prop];\n  });\n\n  // Append select `res` properties\n  ['headers', 'statusCode'].forEach(function (prop) {\n    response[prop] = res[prop];\n  });\n\n  response.body = body;\n\n  return response;\n}", "code_tokens": ["function", "render", "(", "req", ",", "res", ",", "body", ")", "{", "var", "response", "=", "{", "}", ";", "var", "parsedURL", "=", "parseURL", "(", "req", ".", "url", ")", ";", "// Append URL properties", "for", "(", "var", "prop", "in", "parsedURL", ")", "response", "[", "prop", "]", "=", "parsedURL", "[", "prop", "]", ";", "// Append select `req` properties", "[", "'method'", ",", "'url'", "]", ".", "forEach", "(", "function", "(", "prop", ")", "{", "response", "[", "prop", "]", "=", "req", "[", "prop", "]", ";", "}", ")", ";", "// Append select `res` properties", "[", "'headers'", ",", "'statusCode'", "]", ".", "forEach", "(", "function", "(", "prop", ")", "{", "response", "[", "prop", "]", "=", "res", "[", "prop", "]", ";", "}", ")", ";", "response", ".", "body", "=", "body", ";", "return", "response", ";", "}"], "docstring": "Takes a request, response and body object and return a response object\nfor the `send` callback.\n\n@param {Request} req\n@param {Response} res\n@param {Object|String} body\n@return {Object}", "docstring_tokens": ["Takes", "a", "request", "response", "and", "body", "object", "and", "return", "a", "response", "object", "for", "the", "send", "callback", "."], "sha": "e69b6cc33669035c1d571bff3805e1b6d8a50ccb", "url": "https://github.com/jsantell/GhostTrain/blob/e69b6cc33669035c1d571bff3805e1b6d8a50ccb/lib/sendRequest.js#L85-L106", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "writeableDir", "original_string": "function writeableDir(dir) {\n      if (!dir || !fs.existsSync(dir))\n        return false;\n    \n      if (!fs.statSync(dir).isDirectory())\n        return false;\n    \n      var testFile = dir+'/'+common.randomFileName();\n      try {\n        fs.writeFileSync(testFile, ' ');\n        common.unlinkSync(testFile);\n        return dir;\n      } catch (e) {\n        return false;\n      }\n    }", "language": "javascript", "code": "function writeableDir(dir) {\n      if (!dir || !fs.existsSync(dir))\n        return false;\n    \n      if (!fs.statSync(dir).isDirectory())\n        return false;\n    \n      var testFile = dir+'/'+common.randomFileName();\n      try {\n        fs.writeFileSync(testFile, ' ');\n        common.unlinkSync(testFile);\n        return dir;\n      } catch (e) {\n        return false;\n      }\n    }", "code_tokens": ["function", "writeableDir", "(", "dir", ")", "{", "if", "(", "!", "dir", "||", "!", "fs", ".", "existsSync", "(", "dir", ")", ")", "return", "false", ";", "if", "(", "!", "fs", ".", "statSync", "(", "dir", ")", ".", "isDirectory", "(", ")", ")", "return", "false", ";", "var", "testFile", "=", "dir", "+", "'/'", "+", "common", ".", "randomFileName", "(", ")", ";", "try", "{", "fs", ".", "writeFileSync", "(", "testFile", ",", "' '", ")", ";", "common", ".", "unlinkSync", "(", "testFile", ")", ";", "return", "dir", ";", "}", "catch", "(", "e", ")", "{", "return", "false", ";", "}", "}"], "docstring": "Returns false if 'dir' is not a writeable directory, 'dir' otherwise", "docstring_tokens": ["Returns", "false", "if", "dir", "is", "not", "a", "writeable", "directory", "dir", "otherwise"], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L49226-L49241", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/device/purchases/Sencha.js", "func_name": "", "original_string": "function(config) {\n            var me = this;\n\n            if (!config.success) {\n                Ext.Logger.error('You must specify a `success` callback for `#complete` to work.');\n                return false;\n            }\n\n            if (!config.failure) {\n                Ext.Logger.error('You must specify a `failure` callback for `#complete` to work.');\n                return false;\n            }\n\n            if (this.get('state') != 'charged') {\n                config.failure.call(config.scope || this, 'purchase is not charged');\n            }\n\n            Ext.device.Communicator.send({\n                command: 'Purchase#complete',\n                identifier: me.get('transactionIdentifier'),\n                callbacks: {\n                    success: function() {\n                        me.set('state', 'completed');\n                        config.success.call(config.scope || this);\n                    },\n                    failure: function() {\n                        me.set('state', 'charged');\n                        config.failure.call(config.scope || this);\n                    }\n                },\n                scope: config.scope || this\n            });\n        }", "language": "javascript", "code": "function(config) {\n            var me = this;\n\n            if (!config.success) {\n                Ext.Logger.error('You must specify a `success` callback for `#complete` to work.');\n                return false;\n            }\n\n            if (!config.failure) {\n                Ext.Logger.error('You must specify a `failure` callback for `#complete` to work.');\n                return false;\n            }\n\n            if (this.get('state') != 'charged') {\n                config.failure.call(config.scope || this, 'purchase is not charged');\n            }\n\n            Ext.device.Communicator.send({\n                command: 'Purchase#complete',\n                identifier: me.get('transactionIdentifier'),\n                callbacks: {\n                    success: function() {\n                        me.set('state', 'completed');\n                        config.success.call(config.scope || this);\n                    },\n                    failure: function() {\n                        me.set('state', 'charged');\n                        config.failure.call(config.scope || this);\n                    }\n                },\n                scope: config.scope || this\n            });\n        }", "code_tokens": ["function", "(", "config", ")", "{", "var", "me", "=", "this", ";", "if", "(", "!", "config", ".", "success", ")", "{", "Ext", ".", "Logger", ".", "error", "(", "'You must specify a `success` callback for `#complete` to work.'", ")", ";", "return", "false", ";", "}", "if", "(", "!", "config", ".", "failure", ")", "{", "Ext", ".", "Logger", ".", "error", "(", "'You must specify a `failure` callback for `#complete` to work.'", ")", ";", "return", "false", ";", "}", "if", "(", "this", ".", "get", "(", "'state'", ")", "!=", "'charged'", ")", "{", "config", ".", "failure", ".", "call", "(", "config", ".", "scope", "||", "this", ",", "'purchase is not charged'", ")", ";", "}", "Ext", ".", "device", ".", "Communicator", ".", "send", "(", "{", "command", ":", "'Purchase#complete'", ",", "identifier", ":", "me", ".", "get", "(", "'transactionIdentifier'", ")", ",", "callbacks", ":", "{", "success", ":", "function", "(", ")", "{", "me", ".", "set", "(", "'state'", ",", "'completed'", ")", ";", "config", ".", "success", ".", "call", "(", "config", ".", "scope", "||", "this", ")", ";", "}", ",", "failure", ":", "function", "(", ")", "{", "me", ".", "set", "(", "'state'", ",", "'charged'", ")", ";", "config", ".", "failure", ".", "call", "(", "config", ".", "scope", "||", "this", ")", ";", "}", "}", ",", "scope", ":", "config", ".", "scope", "||", "this", "}", ")", ";", "}"], "docstring": "Attempts to mark this purchase as complete\n@param {Object} config\n@param {Function} config.success\n@param {Function} config.failure\n@param {Object} config.scope", "docstring_tokens": ["Attempts", "to", "mark", "this", "purchase", "as", "complete"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/purchases/Sencha.js#L244-L276", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/file.js", "func_name": "remove", "original_string": "function remove(repoState, filepath) {\n    if (!exists(repoState, filepath)) {\n        throw error.fileNotFound(filepath);\n    }\n\n    const change = Change.createRemove();\n    return ChangeUtils.setChange(repoState, filepath, change);\n}", "language": "javascript", "code": "function remove(repoState, filepath) {\n    if (!exists(repoState, filepath)) {\n        throw error.fileNotFound(filepath);\n    }\n\n    const change = Change.createRemove();\n    return ChangeUtils.setChange(repoState, filepath, change);\n}", "code_tokens": ["function", "remove", "(", "repoState", ",", "filepath", ")", "{", "if", "(", "!", "exists", "(", "repoState", ",", "filepath", ")", ")", "{", "throw", "error", ".", "fileNotFound", "(", "filepath", ")", ";", "}", "const", "change", "=", "Change", ".", "createRemove", "(", ")", ";", "return", "ChangeUtils", ".", "setChange", "(", "repoState", ",", "filepath", ",", "change", ")", ";", "}"], "docstring": "Remove a file\n@return {RepositoryState}", "docstring_tokens": ["Remove", "a", "file"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/file.js#L159-L166", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "", "original_string": "function(type) {\n    this.sets[type] = this.sets[type] || [];\n    this.count--;\n    this.stack.pop();\n    return this.sets[type].pop();\n  }", "language": "javascript", "code": "function(type) {\n    this.sets[type] = this.sets[type] || [];\n    this.count--;\n    this.stack.pop();\n    return this.sets[type].pop();\n  }", "code_tokens": ["function", "(", "type", ")", "{", "this", ".", "sets", "[", "type", "]", "=", "this", ".", "sets", "[", "type", "]", "||", "[", "]", ";", "this", ".", "count", "--", ";", "this", ".", "stack", ".", "pop", "(", ")", ";", "return", "this", ".", "sets", "[", "type", "]", ".", "pop", "(", ")", ";", "}"], "docstring": "Pop a token off of the `type` stack\n@param {String} `type`\n@returns {Object} Returns a token\n@api public", "docstring_tokens": ["Pop", "a", "token", "off", "of", "the", "type", "stack"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L64807-L64812", "partition": "test"}
{"repo": "sendanor/nor-api", "path": "src/index.js", "func_name": "do_failure", "original_string": "function do_failure(req, res, opts) {\n\topts = opts || {};\n\tvar obj = {\n\t\t'type': opts.type || 'error',\n\t\t'code': opts.code || 501,\n\t\t'desc': opts.desc || (''+opts)\n\t};\n\n\tres.writeHead(obj.code, {'Content-Type': 'application/json'});\n\tres.end(helpers.stringify(obj) + '\\n');\n}", "language": "javascript", "code": "function do_failure(req, res, opts) {\n\topts = opts || {};\n\tvar obj = {\n\t\t'type': opts.type || 'error',\n\t\t'code': opts.code || 501,\n\t\t'desc': opts.desc || (''+opts)\n\t};\n\n\tres.writeHead(obj.code, {'Content-Type': 'application/json'});\n\tres.end(helpers.stringify(obj) + '\\n');\n}", "code_tokens": ["function", "do_failure", "(", "req", ",", "res", ",", "opts", ")", "{", "opts", "=", "opts", "||", "{", "}", ";", "var", "obj", "=", "{", "'type'", ":", "opts", ".", "type", "||", "'error'", ",", "'code'", ":", "opts", ".", "code", "||", "501", ",", "'desc'", ":", "opts", ".", "desc", "||", "(", "''", "+", "opts", ")", "}", ";", "res", ".", "writeHead", "(", "obj", ".", "code", ",", "{", "'Content-Type'", ":", "'application/json'", "}", ")", ";", "res", ".", "end", "(", "helpers", ".", "stringify", "(", "obj", ")", "+", "'\\n'", ")", ";", "}"], "docstring": "Sends failed HTTP reply", "docstring_tokens": ["Sends", "failed", "HTTP", "reply"], "sha": "50c88c6a606443e89f978a75057902a65d8312bd", "url": "https://github.com/sendanor/nor-api/blob/50c88c6a606443e89f978a75057902a65d8312bd/src/index.js#L24-L34", "partition": "test"}
{"repo": "rrrene/inchjs", "path": "lib/docs/retriever.js", "func_name": "getDefaultArgs", "original_string": "function getDefaultArgs() {\n  var results = [];\n  DEFAULT_PATHS.forEach(function(dir) {\n    if( fs.existsSync(dir) ) results.push(dir);\n  });\n  return results.length == 0 ? null : results;\n}", "language": "javascript", "code": "function getDefaultArgs() {\n  var results = [];\n  DEFAULT_PATHS.forEach(function(dir) {\n    if( fs.existsSync(dir) ) results.push(dir);\n  });\n  return results.length == 0 ? null : results;\n}", "code_tokens": ["function", "getDefaultArgs", "(", ")", "{", "var", "results", "=", "[", "]", ";", "DEFAULT_PATHS", ".", "forEach", "(", "function", "(", "dir", ")", "{", "if", "(", "fs", ".", "existsSync", "(", "dir", ")", ")", "results", ".", "push", "(", "dir", ")", ";", "}", ")", ";", "return", "results", ".", "length", "==", "0", "?", "null", ":", "results", ";", "}"], "docstring": "Returns an Array of default paths.", "docstring_tokens": ["Returns", "an", "Array", "of", "default", "paths", "."], "sha": "453b4dac7a75707afc217fbacdea501179e0e5a4", "url": "https://github.com/rrrene/inchjs/blob/453b4dac7a75707afc217fbacdea501179e0e5a4/lib/docs/retriever.js#L29-L35", "partition": "test"}
{"repo": "benkeen/d3pie", "path": "website/core/pageHelper.js", "func_name": "", "original_string": "function() {\n\t\t$(document).on(\"click\", \".selectPage\", function(e) {\n\t\t\te.preventDefault();\n\t\t\t_selectPage(this.hash);\n\t\t});\n\n\t\t$(window).on(\"resize\", function() {\n\t\t\tvar width = $(window).width();\n\t\t\tvar height = $(window).height();\n\t\t\tvar breakPoint = _updateBodySizeClass(width);\n\t\t\tmediator.publish(_MODULE_ID, C.EVENT.PAGE.RESIZE, {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tbreakPoint: breakPoint\n\t\t\t});\n\t\t});\n\t}", "language": "javascript", "code": "function() {\n\t\t$(document).on(\"click\", \".selectPage\", function(e) {\n\t\t\te.preventDefault();\n\t\t\t_selectPage(this.hash);\n\t\t});\n\n\t\t$(window).on(\"resize\", function() {\n\t\t\tvar width = $(window).width();\n\t\t\tvar height = $(window).height();\n\t\t\tvar breakPoint = _updateBodySizeClass(width);\n\t\t\tmediator.publish(_MODULE_ID, C.EVENT.PAGE.RESIZE, {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tbreakPoint: breakPoint\n\t\t\t});\n\t\t});\n\t}", "code_tokens": ["function", "(", ")", "{", "$", "(", "document", ")", ".", "on", "(", "\"click\"", ",", "\".selectPage\"", ",", "function", "(", "e", ")", "{", "e", ".", "preventDefault", "(", ")", ";", "_selectPage", "(", "this", ".", "hash", ")", ";", "}", ")", ";", "$", "(", "window", ")", ".", "on", "(", "\"resize\"", ",", "function", "(", ")", "{", "var", "width", "=", "$", "(", "window", ")", ".", "width", "(", ")", ";", "var", "height", "=", "$", "(", "window", ")", ".", "height", "(", ")", ";", "var", "breakPoint", "=", "_updateBodySizeClass", "(", "width", ")", ";", "mediator", ".", "publish", "(", "_MODULE_ID", ",", "C", ".", "EVENT", ".", "PAGE", ".", "RESIZE", ",", "{", "width", ":", "width", ",", "height", ":", "height", ",", "breakPoint", ":", "breakPoint", "}", ")", ";", "}", ")", ";", "}"], "docstring": "this catches ALL nav clicks, not just in the main navbar", "docstring_tokens": ["this", "catches", "ALL", "nav", "clicks", "not", "just", "in", "the", "main", "navbar"], "sha": "24b488a4f44226c407186c007365ab775f92a426", "url": "https://github.com/benkeen/d3pie/blob/24b488a4f44226c407186c007365ab775f92a426/website/core/pageHelper.js#L28-L44", "partition": "test"}
{"repo": "apache/cordova-plugin-media", "path": "src/windows/MediaProxy.js", "func_name": "", "original_string": "function(win, lose, args) {\n        var id = args[0];\n\n        var srcUri = processUri(args[1]);\n\n        var createAudioNode = !!args[2];\n        var thisM = Media.get(id);\n\n        Media.prototype.node = null;\n\n        var prefix = args[1].split(':').shift();\n        var extension = srcUri.extension;\n        if (thisM.node === null) {\n            if (SUPPORTED_EXTENSIONS.indexOf(extension) === -1 && SUPPORTED_PREFIXES.indexOf(prefix) === -1) {\n                if (lose) {\n                    lose({ code: MediaError.MEDIA_ERR_ABORTED });\n                }\n                return false; // unable to create\n            }\n\n            // Don't create Audio object in case of record mode\n            if (createAudioNode === true) {\n                thisM.node = new Audio();\n                thisM.node.msAudioCategory = \"BackgroundCapableMedia\";\n                thisM.node.src = srcUri.absoluteCanonicalUri;\n\n                thisM.node.onloadstart = function () {\n                    Media.onStatus(id, Media.MEDIA_STATE, Media.MEDIA_STARTING);\n                };\n\n                thisM.node.ontimeupdate = function (e) {\n                    Media.onStatus(id, Media.MEDIA_POSITION, e.target.currentTime);\n                };\n\n                thisM.node.onplaying = function () {\n                    Media.onStatus(id, Media.MEDIA_STATE, Media.MEDIA_RUNNING);\n                };\n\n                thisM.node.ondurationchange = function (e) {\n                    Media.onStatus(id, Media.MEDIA_DURATION, e.target.duration || -1);\n                };\n\n                thisM.node.onerror = function (e) {\n                    // Due to media.spec.15 It should return MediaError for bad filename\n                    var err = e.target.error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED ?\n                        { code: MediaError.MEDIA_ERR_ABORTED } :\n                        e.target.error;\n\n                    Media.onStatus(id, Media.MEDIA_ERROR, err);\n                };\n\n                thisM.node.onended = function () {\n                    Media.onStatus(id, Media.MEDIA_STATE, Media.MEDIA_STOPPED);\n                };\n            }\n        }\n\n        return true; // successfully created\n    }", "language": "javascript", "code": "function(win, lose, args) {\n        var id = args[0];\n\n        var srcUri = processUri(args[1]);\n\n        var createAudioNode = !!args[2];\n        var thisM = Media.get(id);\n\n        Media.prototype.node = null;\n\n        var prefix = args[1].split(':').shift();\n        var extension = srcUri.extension;\n        if (thisM.node === null) {\n            if (SUPPORTED_EXTENSIONS.indexOf(extension) === -1 && SUPPORTED_PREFIXES.indexOf(prefix) === -1) {\n                if (lose) {\n                    lose({ code: MediaError.MEDIA_ERR_ABORTED });\n                }\n                return false; // unable to create\n            }\n\n            // Don't create Audio object in case of record mode\n            if (createAudioNode === true) {\n                thisM.node = new Audio();\n                thisM.node.msAudioCategory = \"BackgroundCapableMedia\";\n                thisM.node.src = srcUri.absoluteCanonicalUri;\n\n                thisM.node.onloadstart = function () {\n                    Media.onStatus(id, Media.MEDIA_STATE, Media.MEDIA_STARTING);\n                };\n\n                thisM.node.ontimeupdate = function (e) {\n                    Media.onStatus(id, Media.MEDIA_POSITION, e.target.currentTime);\n                };\n\n                thisM.node.onplaying = function () {\n                    Media.onStatus(id, Media.MEDIA_STATE, Media.MEDIA_RUNNING);\n                };\n\n                thisM.node.ondurationchange = function (e) {\n                    Media.onStatus(id, Media.MEDIA_DURATION, e.target.duration || -1);\n                };\n\n                thisM.node.onerror = function (e) {\n                    // Due to media.spec.15 It should return MediaError for bad filename\n                    var err = e.target.error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED ?\n                        { code: MediaError.MEDIA_ERR_ABORTED } :\n                        e.target.error;\n\n                    Media.onStatus(id, Media.MEDIA_ERROR, err);\n                };\n\n                thisM.node.onended = function () {\n                    Media.onStatus(id, Media.MEDIA_STATE, Media.MEDIA_STOPPED);\n                };\n            }\n        }\n\n        return true; // successfully created\n    }", "code_tokens": ["function", "(", "win", ",", "lose", ",", "args", ")", "{", "var", "id", "=", "args", "[", "0", "]", ";", "var", "srcUri", "=", "processUri", "(", "args", "[", "1", "]", ")", ";", "var", "createAudioNode", "=", "!", "!", "args", "[", "2", "]", ";", "var", "thisM", "=", "Media", ".", "get", "(", "id", ")", ";", "Media", ".", "prototype", ".", "node", "=", "null", ";", "var", "prefix", "=", "args", "[", "1", "]", ".", "split", "(", "':'", ")", ".", "shift", "(", ")", ";", "var", "extension", "=", "srcUri", ".", "extension", ";", "if", "(", "thisM", ".", "node", "===", "null", ")", "{", "if", "(", "SUPPORTED_EXTENSIONS", ".", "indexOf", "(", "extension", ")", "===", "-", "1", "&&", "SUPPORTED_PREFIXES", ".", "indexOf", "(", "prefix", ")", "===", "-", "1", ")", "{", "if", "(", "lose", ")", "{", "lose", "(", "{", "code", ":", "MediaError", ".", "MEDIA_ERR_ABORTED", "}", ")", ";", "}", "return", "false", ";", "// unable to create", "}", "// Don't create Audio object in case of record mode", "if", "(", "createAudioNode", "===", "true", ")", "{", "thisM", ".", "node", "=", "new", "Audio", "(", ")", ";", "thisM", ".", "node", ".", "msAudioCategory", "=", "\"BackgroundCapableMedia\"", ";", "thisM", ".", "node", ".", "src", "=", "srcUri", ".", "absoluteCanonicalUri", ";", "thisM", ".", "node", ".", "onloadstart", "=", "function", "(", ")", "{", "Media", ".", "onStatus", "(", "id", ",", "Media", ".", "MEDIA_STATE", ",", "Media", ".", "MEDIA_STARTING", ")", ";", "}", ";", "thisM", ".", "node", ".", "ontimeupdate", "=", "function", "(", "e", ")", "{", "Media", ".", "onStatus", "(", "id", ",", "Media", ".", "MEDIA_POSITION", ",", "e", ".", "target", ".", "currentTime", ")", ";", "}", ";", "thisM", ".", "node", ".", "onplaying", "=", "function", "(", ")", "{", "Media", ".", "onStatus", "(", "id", ",", "Media", ".", "MEDIA_STATE", ",", "Media", ".", "MEDIA_RUNNING", ")", ";", "}", ";", "thisM", ".", "node", ".", "ondurationchange", "=", "function", "(", "e", ")", "{", "Media", ".", "onStatus", "(", "id", ",", "Media", ".", "MEDIA_DURATION", ",", "e", ".", "target", ".", "duration", "||", "-", "1", ")", ";", "}", ";", "thisM", ".", "node", ".", "onerror", "=", "function", "(", "e", ")", "{", "// Due to media.spec.15 It should return MediaError for bad filename", "var", "err", "=", "e", ".", "target", ".", "error", ".", "code", "===", "MediaError", ".", "MEDIA_ERR_SRC_NOT_SUPPORTED", "?", "{", "code", ":", "MediaError", ".", "MEDIA_ERR_ABORTED", "}", ":", "e", ".", "target", ".", "error", ";", "Media", ".", "onStatus", "(", "id", ",", "Media", ".", "MEDIA_ERROR", ",", "err", ")", ";", "}", ";", "thisM", ".", "node", ".", "onended", "=", "function", "(", ")", "{", "Media", ".", "onStatus", "(", "id", ",", "Media", ".", "MEDIA_STATE", ",", "Media", ".", "MEDIA_STOPPED", ")", ";", "}", ";", "}", "}", "return", "true", ";", "// successfully created", "}"], "docstring": "Initiates the audio file", "docstring_tokens": ["Initiates", "the", "audio", "file"], "sha": "b1c135342619f773fee3e8693a46992a133efd56", "url": "https://github.com/apache/cordova-plugin-media/blob/b1c135342619f773fee3e8693a46992a133efd56/src/windows/MediaProxy.js#L46-L104", "partition": "test"}
{"repo": "duaraghav8/Ethlint", "path": "lib/rules/double-quotes.js", "func_name": "isHex", "original_string": "function isHex(literal) {\n    let reg = /^[0-9a-f]+$/i;\n\n    //test for '0x' separately because hex notation should not be a part of the standard RegExp\n    if (literal.slice(0, 2) !== \"0x\") {\n        return false;\n    }\n\n    return reg.test(literal.slice(2));\n}", "language": "javascript", "code": "function isHex(literal) {\n    let reg = /^[0-9a-f]+$/i;\n\n    //test for '0x' separately because hex notation should not be a part of the standard RegExp\n    if (literal.slice(0, 2) !== \"0x\") {\n        return false;\n    }\n\n    return reg.test(literal.slice(2));\n}", "code_tokens": ["function", "isHex", "(", "literal", ")", "{", "let", "reg", "=", "/", "^[0-9a-f]+$", "/", "i", ";", "//test for '0x' separately because hex notation should not be a part of the standard RegExp", "if", "(", "literal", ".", "slice", "(", "0", ",", "2", ")", "!==", "\"0x\"", ")", "{", "return", "false", ";", "}", "return", "reg", ".", "test", "(", "literal", ".", "slice", "(", "2", ")", ")", ";", "}"], "docstring": "Determine whether the provided literal is in Hex Notation\n@param {String} literal The literal to test for Hex Notation\n@returns {Boolean}", "docstring_tokens": ["Determine", "whether", "the", "provided", "literal", "is", "in", "Hex", "Notation"], "sha": "7d264373709561148c7166601ac39370e78f74b1", "url": "https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/rules/double-quotes.js#L13-L22", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/metadata/schema-parser.js", "func_name": "getByVersion", "original_string": "function getByVersion(options, cc, udtResolver, version, currentInstance) {\n  let parserConstructor = SchemaParserV1;\n  if (version && version[0] === 3) {\n    parserConstructor = SchemaParserV2;\n  } else if (version && version[0] >= 4) {\n    parserConstructor = SchemaParserV3;\n  }\n  if (!currentInstance || !(currentInstance instanceof parserConstructor)){\n    return new parserConstructor(options, cc, udtResolver);\n  }\n  return currentInstance;\n}", "language": "javascript", "code": "function getByVersion(options, cc, udtResolver, version, currentInstance) {\n  let parserConstructor = SchemaParserV1;\n  if (version && version[0] === 3) {\n    parserConstructor = SchemaParserV2;\n  } else if (version && version[0] >= 4) {\n    parserConstructor = SchemaParserV3;\n  }\n  if (!currentInstance || !(currentInstance instanceof parserConstructor)){\n    return new parserConstructor(options, cc, udtResolver);\n  }\n  return currentInstance;\n}", "code_tokens": ["function", "getByVersion", "(", "options", ",", "cc", ",", "udtResolver", ",", "version", ",", "currentInstance", ")", "{", "let", "parserConstructor", "=", "SchemaParserV1", ";", "if", "(", "version", "&&", "version", "[", "0", "]", "===", "3", ")", "{", "parserConstructor", "=", "SchemaParserV2", ";", "}", "else", "if", "(", "version", "&&", "version", "[", "0", "]", ">=", "4", ")", "{", "parserConstructor", "=", "SchemaParserV3", ";", "}", "if", "(", "!", "currentInstance", "||", "!", "(", "currentInstance", "instanceof", "parserConstructor", ")", ")", "{", "return", "new", "parserConstructor", "(", "options", ",", "cc", ",", "udtResolver", ")", ";", "}", "return", "currentInstance", ";", "}"], "docstring": "Creates a new instance if the currentInstance is not valid for the\nprovided Cassandra version\n@param {ClientOptions} options The client options\n@param {ControlConnection} cc The control connection to be used\n@param {Function} udtResolver The function to be used to retrieve the udts.\n@param {Array.<Number>} [version] The cassandra version\n@param {SchemaParser} [currentInstance] The current instance\n@returns {SchemaParser}", "docstring_tokens": ["Creates", "a", "new", "instance", "if", "the", "currentInstance", "is", "not", "valid", "for", "the", "provided", "Cassandra", "version"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/metadata/schema-parser.js#L1371-L1382", "partition": "test"}
{"repo": "apentle/redux-reducers-hub", "path": "index.js", "func_name": "replace", "original_string": "function replace(reducers, scope, defaultState) {\n  remove(scope);\n  add(reducers, scope, defaultState);\n}", "language": "javascript", "code": "function replace(reducers, scope, defaultState) {\n  remove(scope);\n  add(reducers, scope, defaultState);\n}", "code_tokens": ["function", "replace", "(", "reducers", ",", "scope", ",", "defaultState", ")", "{", "remove", "(", "scope", ")", ";", "add", "(", "reducers", ",", "scope", ",", "defaultState", ")", ";", "}"], "docstring": "replace - replace with new reducers\n\n@param  {object} reducers     reducer functions\n@param  {string} scope        state data scope\n@param  {mixed} defaultState  default state of scope\n@returns {undefined}", "docstring_tokens": ["replace", "-", "replace", "with", "new", "reducers"], "sha": "2720045f1ea635affae2cdb307a6d27562b65fc1", "url": "https://github.com/apentle/redux-reducers-hub/blob/2720045f1ea635affae2cdb307a6d27562b65fc1/index.js#L109-L112", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(type, id) {\n    type = this.modelFor(type);\n\n    id = coerceId(id);\n\n    var record = this.typeMapFor(type).idToRecord[id];\n\n    if (!record) {\n      record = this.buildRecord(type, id);\n    }\n\n    return record;\n  }", "language": "javascript", "code": "function(type, id) {\n    type = this.modelFor(type);\n\n    id = coerceId(id);\n\n    var record = this.typeMapFor(type).idToRecord[id];\n\n    if (!record) {\n      record = this.buildRecord(type, id);\n    }\n\n    return record;\n  }", "code_tokens": ["function", "(", "type", ",", "id", ")", "{", "type", "=", "this", ".", "modelFor", "(", "type", ")", ";", "id", "=", "coerceId", "(", "id", ")", ";", "var", "record", "=", "this", ".", "typeMapFor", "(", "type", ")", ".", "idToRecord", "[", "id", "]", ";", "if", "(", "!", "record", ")", "{", "record", "=", "this", ".", "buildRecord", "(", "type", ",", "id", ")", ";", "}", "return", "record", ";", "}"], "docstring": "Returns id record for a given type and ID. If one isn't already loaded,\nit builds a new record and leaves it in the `empty` state.\n\n@method recordForId\n@private\n@param {String or subclass of DS.Model} type\n@param {String|Integer} id\n@returns {DS.Model} record", "docstring_tokens": ["Returns", "id", "record", "for", "a", "given", "type", "and", "ID", ".", "If", "one", "isn", "t", "already", "loaded", "it", "builds", "a", "new", "record", "and", "leaves", "it", "in", "the", "empty", "state", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L2436-L2448", "partition": "test"}
{"repo": "prtksxna/jsdoc-class-hierarchy", "path": "index.js", "func_name": "makeChildrenList", "original_string": "function makeChildrenList( classes ) {\n\tvar list = '<ul>';\n\tclasses.forEach( function ( className ) {\n\t\tlist += '<li>' + linkTo( className ) + '</li>';\n\t})\n\tlist += '</ul>';\n\treturn list;\n}", "language": "javascript", "code": "function makeChildrenList( classes ) {\n\tvar list = '<ul>';\n\tclasses.forEach( function ( className ) {\n\t\tlist += '<li>' + linkTo( className ) + '</li>';\n\t})\n\tlist += '</ul>';\n\treturn list;\n}", "code_tokens": ["function", "makeChildrenList", "(", "classes", ")", "{", "var", "list", "=", "'<ul>'", ";", "classes", ".", "forEach", "(", "function", "(", "className", ")", "{", "list", "+=", "'<li>'", "+", "linkTo", "(", "className", ")", "+", "'</li>'", ";", "}", ")", "list", "+=", "'</ul>'", ";", "return", "list", ";", "}"], "docstring": "Creates a list of child classes.\n\n@param {string[]} classes Array of all the child classes' names.\n@returns {string} HTML string of a `<ul>`", "docstring_tokens": ["Creates", "a", "list", "of", "child", "classes", "."], "sha": "5a3ec689a85aea83ac4b8f1623ea4a79f8676ccc", "url": "https://github.com/prtksxna/jsdoc-class-hierarchy/blob/5a3ec689a85aea83ac4b8f1623ea4a79f8676ccc/index.js#L79-L86", "partition": "test"}
{"repo": "azavea/tilejson-validator", "path": "index.js", "func_name": "validate", "original_string": "function validate(str) {\n    let tj;\n\n    if (typeof str === 'object') {\n        tj = str;\n    } else if (typeof str === 'string') {\n        try {\n            tj = jsonlint.parse(str);\n        } catch (err) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    return tilejsonValidateObject.validate(tj);\n}", "language": "javascript", "code": "function validate(str) {\n    let tj;\n\n    if (typeof str === 'object') {\n        tj = str;\n    } else if (typeof str === 'string') {\n        try {\n            tj = jsonlint.parse(str);\n        } catch (err) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    return tilejsonValidateObject.validate(tj);\n}", "code_tokens": ["function", "validate", "(", "str", ")", "{", "let", "tj", ";", "if", "(", "typeof", "str", "===", "'object'", ")", "{", "tj", "=", "str", ";", "}", "else", "if", "(", "typeof", "str", "===", "'string'", ")", "{", "try", "{", "tj", "=", "jsonlint", ".", "parse", "(", "str", ")", ";", "}", "catch", "(", "err", ")", "{", "return", "false", ";", "}", "}", "else", "{", "return", "false", ";", "}", "return", "tilejsonValidateObject", ".", "validate", "(", "tj", ")", ";", "}"], "docstring": "Validates a TileJSON\n@param {(string|object)} TileJSON as string or object\n@returns {boolean} true if the validation is successful, false otherwise", "docstring_tokens": ["Validates", "a", "TileJSON"], "sha": "069b0f6182c0b57b563a6e67f57bd06c1630f534", "url": "https://github.com/azavea/tilejson-validator/blob/069b0f6182c0b57b563a6e67f57bd06c1630f534/index.js#L9-L25", "partition": "test"}
{"repo": "lpinca/stopcock", "path": "index.js", "func_name": "stopcock", "original_string": "function stopcock(fn, options) {\n  options = Object.assign(\n    {\n      queueSize: Math.pow(2, 32) - 1,\n      bucketSize: 40,\n      interval: 1000,\n      limit: 2\n    },\n    options\n  );\n\n  const bucket = new TokenBucket(options);\n  const queue = [];\n  let timer = null;\n\n  function shift() {\n    clearTimeout(timer);\n    while (queue.length) {\n      const delay = bucket.consume();\n\n      if (delay > 0) {\n        timer = setTimeout(shift, delay);\n        break;\n      }\n\n      const data = queue.shift();\n      data[2](fn.apply(data[0], data[1]));\n    }\n  }\n\n  function limiter() {\n    const args = arguments;\n\n    return new Promise((resolve, reject) => {\n      if (queue.length === options.queueSize) {\n        return reject(new Error('Queue is full'));\n      }\n\n      queue.push([this, args, resolve]);\n      shift();\n    });\n  }\n\n  Object.defineProperty(limiter, 'size', { get: () => queue.length });\n\n  return limiter;\n}", "language": "javascript", "code": "function stopcock(fn, options) {\n  options = Object.assign(\n    {\n      queueSize: Math.pow(2, 32) - 1,\n      bucketSize: 40,\n      interval: 1000,\n      limit: 2\n    },\n    options\n  );\n\n  const bucket = new TokenBucket(options);\n  const queue = [];\n  let timer = null;\n\n  function shift() {\n    clearTimeout(timer);\n    while (queue.length) {\n      const delay = bucket.consume();\n\n      if (delay > 0) {\n        timer = setTimeout(shift, delay);\n        break;\n      }\n\n      const data = queue.shift();\n      data[2](fn.apply(data[0], data[1]));\n    }\n  }\n\n  function limiter() {\n    const args = arguments;\n\n    return new Promise((resolve, reject) => {\n      if (queue.length === options.queueSize) {\n        return reject(new Error('Queue is full'));\n      }\n\n      queue.push([this, args, resolve]);\n      shift();\n    });\n  }\n\n  Object.defineProperty(limiter, 'size', { get: () => queue.length });\n\n  return limiter;\n}", "code_tokens": ["function", "stopcock", "(", "fn", ",", "options", ")", "{", "options", "=", "Object", ".", "assign", "(", "{", "queueSize", ":", "Math", ".", "pow", "(", "2", ",", "32", ")", "-", "1", ",", "bucketSize", ":", "40", ",", "interval", ":", "1000", ",", "limit", ":", "2", "}", ",", "options", ")", ";", "const", "bucket", "=", "new", "TokenBucket", "(", "options", ")", ";", "const", "queue", "=", "[", "]", ";", "let", "timer", "=", "null", ";", "function", "shift", "(", ")", "{", "clearTimeout", "(", "timer", ")", ";", "while", "(", "queue", ".", "length", ")", "{", "const", "delay", "=", "bucket", ".", "consume", "(", ")", ";", "if", "(", "delay", ">", "0", ")", "{", "timer", "=", "setTimeout", "(", "shift", ",", "delay", ")", ";", "break", ";", "}", "const", "data", "=", "queue", ".", "shift", "(", ")", ";", "data", "[", "2", "]", "(", "fn", ".", "apply", "(", "data", "[", "0", "]", ",", "data", "[", "1", "]", ")", ")", ";", "}", "}", "function", "limiter", "(", ")", "{", "const", "args", "=", "arguments", ";", "return", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "if", "(", "queue", ".", "length", "===", "options", ".", "queueSize", ")", "{", "return", "reject", "(", "new", "Error", "(", "'Queue is full'", ")", ")", ";", "}", "queue", ".", "push", "(", "[", "this", ",", "args", ",", "resolve", "]", ")", ";", "shift", "(", ")", ";", "}", ")", ";", "}", "Object", ".", "defineProperty", "(", "limiter", ",", "'size'", ",", "{", "get", ":", "(", ")", "=>", "queue", ".", "length", "}", ")", ";", "return", "limiter", ";", "}"], "docstring": "Limit the execution rate of a function using a leaky bucket algorithm.\n\n@param {Function} fn The function to rate limit calls to\n@param {Object} options Options object\n@param {Number} options.limit The number of allowed calls per `interval`\n@param {Number} options.interval The timespan where `limit` is calculated\n@param {Number} options.queueSize The maximum size of the queue\n@param {Number} options.bucketSize The capacity of the bucket\n@return {Function}\n@public", "docstring_tokens": ["Limit", "the", "execution", "rate", "of", "a", "function", "using", "a", "leaky", "bucket", "algorithm", "."], "sha": "6937f4bd9318cc2298590a1aa5cff33517297d13", "url": "https://github.com/lpinca/stopcock/blob/6937f4bd9318cc2298590a1aa5cff33517297d13/index.js#L72-L118", "partition": "test"}
{"repo": "vanruesc/postprocessing", "path": "build/postprocessing.esm.js", "func_name": "deltaRight", "original_string": "function deltaRight(left, top) {\n\n\tlet d = 0;\n\n\t// If there is an edge, and no crossing edges, continue.\n\tif(top[3] === 1 && left[1] !== 1 && left[3] !== 1) {\n\n\t\td += 1;\n\n\t}\n\n\t/* If an edge was previously found, there is another edge and there are no\n\tcrossing edges, continue. */\n\tif(d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {\n\n\t\td += 1;\n\n\t}\n\n\treturn d;\n\n}", "language": "javascript", "code": "function deltaRight(left, top) {\n\n\tlet d = 0;\n\n\t// If there is an edge, and no crossing edges, continue.\n\tif(top[3] === 1 && left[1] !== 1 && left[3] !== 1) {\n\n\t\td += 1;\n\n\t}\n\n\t/* If an edge was previously found, there is another edge and there are no\n\tcrossing edges, continue. */\n\tif(d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {\n\n\t\td += 1;\n\n\t}\n\n\treturn d;\n\n}", "code_tokens": ["function", "deltaRight", "(", "left", ",", "top", ")", "{", "let", "d", "=", "0", ";", "// If there is an edge, and no crossing edges, continue.", "if", "(", "top", "[", "3", "]", "===", "1", "&&", "left", "[", "1", "]", "!==", "1", "&&", "left", "[", "3", "]", "!==", "1", ")", "{", "d", "+=", "1", ";", "}", "/* If an edge was previously found, there is another edge and there are no\n\tcrossing edges, continue. */", "if", "(", "d", "===", "1", "&&", "top", "[", "2", "]", "===", "1", "&&", "left", "[", "0", "]", "!==", "1", "&&", "left", "[", "2", "]", "!==", "1", ")", "{", "d", "+=", "1", ";", "}", "return", "d", ";", "}"], "docstring": "Computes the delta distance to add in the last step of searches to the right.\n\n@private\n@param {Number[]} left - The left edge combination.\n@param {Number[]} top - The top edge combination.\n@return {Number} The right delta distance.", "docstring_tokens": ["Computes", "the", "delta", "distance", "to", "add", "in", "the", "last", "step", "of", "searches", "to", "the", "right", "."], "sha": "43a6776c2a391ddd3539262e078b0f35b5563004", "url": "https://github.com/vanruesc/postprocessing/blob/43a6776c2a391ddd3539262e078b0f35b5563004/build/postprocessing.esm.js#L9380-L9401", "partition": "test"}
{"repo": "mcdcorp/opentest", "path": "server/src/public/js/ng/root-ctrl.js", "func_name": "checkVersion", "original_string": "function checkVersion() {\n\t\tvar nextVersionCheckTimestamp = parseInt(Cookies.get('nextVersionCheckTimestamp')) || 0;\n\n\t\tif (!nextVersionCheckTimestamp || (Date.now() >= nextVersionCheckTimestamp)) {\n\t\t\t$http.get('/api/build-info')\n\t\t\t\t.then(function success(res) {\n\t\t\t\t\tvar currentVersion = parseVersion(res.data && res.data.version);\n\n\t\t\t\t\t$http.get('https://api.github.com/repos/mcdcorp/opentest/releases')\n\t\t\t\t\t\t.then(\n\t\t\t\t\t\t\tfunction success(res) {\n\t\t\t\t\t\t\t\tvar eightDaysLater = Date.now() + (8 * 24 * 60 * 60 * 1000);\n\t\t\t\t\t\t\t\tCookies.set('nextVersionCheckTimestamp', eightDaysLater);\n\n\t\t\t\t\t\t\t\tvar latestVersionStr = res.data && res.data[0] && res.data[0].tag_name;\n\t\t\t\t\t\t\t\tvar latestVersionUrl = res.data && res.data[0] && res.data[0].html_url;\n\t\t\t\t\t\t\t\tvar latestVersion = parseVersion(latestVersionStr);\n\t\t\t\t\t\t\t\tif (latestVersion && (compareVersions(latestVersion, currentVersion) === 1)) {\n\t\t\t\t\t\t\t\t\t$.notify(\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t\t\t\t\t\t'A new OpenTest version is now available: <a href=\"' + latestVersionUrl + '\" target=\"_blank\">' + latestVersionStr + '</a>. ' +\n\t\t\t\t\t\t\t\t\t\t\t\t'You should always stay on the latest version to benefit from new features and security updates.'\n\t\t\t\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\t\t\t\ttype: 'info',\n\t\t\t\t\t\t\t\t\t\t\tdelay: 0,\n\t\t\t\t\t\t\t\t\t\t\tplacement: { from: 'bottom' }\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction error(res) {\n\t\t\t\t\t\t\t\tvar oneHourLater = Date.now() + (60 * 60 * 1000);\n\t\t\t\t\t\t\t\tCookies.set('nextVersionCheckTimestamp', oneHourLater);\n\t\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t}\n\t}", "language": "javascript", "code": "function checkVersion() {\n\t\tvar nextVersionCheckTimestamp = parseInt(Cookies.get('nextVersionCheckTimestamp')) || 0;\n\n\t\tif (!nextVersionCheckTimestamp || (Date.now() >= nextVersionCheckTimestamp)) {\n\t\t\t$http.get('/api/build-info')\n\t\t\t\t.then(function success(res) {\n\t\t\t\t\tvar currentVersion = parseVersion(res.data && res.data.version);\n\n\t\t\t\t\t$http.get('https://api.github.com/repos/mcdcorp/opentest/releases')\n\t\t\t\t\t\t.then(\n\t\t\t\t\t\t\tfunction success(res) {\n\t\t\t\t\t\t\t\tvar eightDaysLater = Date.now() + (8 * 24 * 60 * 60 * 1000);\n\t\t\t\t\t\t\t\tCookies.set('nextVersionCheckTimestamp', eightDaysLater);\n\n\t\t\t\t\t\t\t\tvar latestVersionStr = res.data && res.data[0] && res.data[0].tag_name;\n\t\t\t\t\t\t\t\tvar latestVersionUrl = res.data && res.data[0] && res.data[0].html_url;\n\t\t\t\t\t\t\t\tvar latestVersion = parseVersion(latestVersionStr);\n\t\t\t\t\t\t\t\tif (latestVersion && (compareVersions(latestVersion, currentVersion) === 1)) {\n\t\t\t\t\t\t\t\t\t$.notify(\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t\t\t\t\t\t'A new OpenTest version is now available: <a href=\"' + latestVersionUrl + '\" target=\"_blank\">' + latestVersionStr + '</a>. ' +\n\t\t\t\t\t\t\t\t\t\t\t\t'You should always stay on the latest version to benefit from new features and security updates.'\n\t\t\t\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\t\t\t\ttype: 'info',\n\t\t\t\t\t\t\t\t\t\t\tdelay: 0,\n\t\t\t\t\t\t\t\t\t\t\tplacement: { from: 'bottom' }\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction error(res) {\n\t\t\t\t\t\t\t\tvar oneHourLater = Date.now() + (60 * 60 * 1000);\n\t\t\t\t\t\t\t\tCookies.set('nextVersionCheckTimestamp', oneHourLater);\n\t\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t}\n\t}", "code_tokens": ["function", "checkVersion", "(", ")", "{", "var", "nextVersionCheckTimestamp", "=", "parseInt", "(", "Cookies", ".", "get", "(", "'nextVersionCheckTimestamp'", ")", ")", "||", "0", ";", "if", "(", "!", "nextVersionCheckTimestamp", "||", "(", "Date", ".", "now", "(", ")", ">=", "nextVersionCheckTimestamp", ")", ")", "{", "$http", ".", "get", "(", "'/api/build-info'", ")", ".", "then", "(", "function", "success", "(", "res", ")", "{", "var", "currentVersion", "=", "parseVersion", "(", "res", ".", "data", "&&", "res", ".", "data", ".", "version", ")", ";", "$http", ".", "get", "(", "'https://api.github.com/repos/mcdcorp/opentest/releases'", ")", ".", "then", "(", "function", "success", "(", "res", ")", "{", "var", "eightDaysLater", "=", "Date", ".", "now", "(", ")", "+", "(", "8", "*", "24", "*", "60", "*", "60", "*", "1000", ")", ";", "Cookies", ".", "set", "(", "'nextVersionCheckTimestamp'", ",", "eightDaysLater", ")", ";", "var", "latestVersionStr", "=", "res", ".", "data", "&&", "res", ".", "data", "[", "0", "]", "&&", "res", ".", "data", "[", "0", "]", ".", "tag_name", ";", "var", "latestVersionUrl", "=", "res", ".", "data", "&&", "res", ".", "data", "[", "0", "]", "&&", "res", ".", "data", "[", "0", "]", ".", "html_url", ";", "var", "latestVersion", "=", "parseVersion", "(", "latestVersionStr", ")", ";", "if", "(", "latestVersion", "&&", "(", "compareVersions", "(", "latestVersion", ",", "currentVersion", ")", "===", "1", ")", ")", "{", "$", ".", "notify", "(", "{", "message", ":", "'A new OpenTest version is now available: <a href=\"'", "+", "latestVersionUrl", "+", "'\" target=\"_blank\">'", "+", "latestVersionStr", "+", "'</a>. '", "+", "'You should always stay on the latest version to benefit from new features and security updates.'", "}", ",", "{", "type", ":", "'info'", ",", "delay", ":", "0", ",", "placement", ":", "{", "from", ":", "'bottom'", "}", "}", ")", "}", "}", ",", "function", "error", "(", "res", ")", "{", "var", "oneHourLater", "=", "Date", ".", "now", "(", ")", "+", "(", "60", "*", "60", "*", "1000", ")", ";", "Cookies", ".", "set", "(", "'nextVersionCheckTimestamp'", ",", "oneHourLater", ")", ";", "}", ")", ";", "}", ")", ";", "}", "}"], "docstring": "Check the release version in GitHub, compare it with the installed\nversion and notify the user if a new version is available.", "docstring_tokens": ["Check", "the", "release", "version", "in", "GitHub", "compare", "it", "with", "the", "installed", "version", "and", "notify", "the", "user", "if", "a", "new", "version", "is", "available", "."], "sha": "302967ae09f3d92cd1438f04ed701b2a3006e598", "url": "https://github.com/mcdcorp/opentest/blob/302967ae09f3d92cd1438f04ed701b2a3006e598/server/src/public/js/ng/root-ctrl.js#L33-L69", "partition": "test"}
{"repo": "steve-jansen/json-proxy", "path": "spec/shared/setup.js", "func_name": "configureExpress", "original_string": "function configureExpress(config, done) {\n  var portfinder = require('portfinder');\n\n  tmp.dir(function(err, filepath){\n    handles.filepath = filepath;\n\n    portfinder.getPort(function (err, port) {\n      if (err) throw(err);\n\n      handles.port = port;\n\n      fs.writeFileSync(path.join(handles.filepath, 'index.txt'), 'hello, world');\n\n      app.use(proxy.initialize(config));\n      app.use(express.static(handles.filepath));\n\n      handles.server = require('http').createServer(app);\n      handles.server.listen(handles.port, function() {\n        done(null, handles.port);\n      });\n    });\n  });\n}", "language": "javascript", "code": "function configureExpress(config, done) {\n  var portfinder = require('portfinder');\n\n  tmp.dir(function(err, filepath){\n    handles.filepath = filepath;\n\n    portfinder.getPort(function (err, port) {\n      if (err) throw(err);\n\n      handles.port = port;\n\n      fs.writeFileSync(path.join(handles.filepath, 'index.txt'), 'hello, world');\n\n      app.use(proxy.initialize(config));\n      app.use(express.static(handles.filepath));\n\n      handles.server = require('http').createServer(app);\n      handles.server.listen(handles.port, function() {\n        done(null, handles.port);\n      });\n    });\n  });\n}", "code_tokens": ["function", "configureExpress", "(", "config", ",", "done", ")", "{", "var", "portfinder", "=", "require", "(", "'portfinder'", ")", ";", "tmp", ".", "dir", "(", "function", "(", "err", ",", "filepath", ")", "{", "handles", ".", "filepath", "=", "filepath", ";", "portfinder", ".", "getPort", "(", "function", "(", "err", ",", "port", ")", "{", "if", "(", "err", ")", "throw", "(", "err", ")", ";", "handles", ".", "port", "=", "port", ";", "fs", ".", "writeFileSync", "(", "path", ".", "join", "(", "handles", ".", "filepath", ",", "'index.txt'", ")", ",", "'hello, world'", ")", ";", "app", ".", "use", "(", "proxy", ".", "initialize", "(", "config", ")", ")", ";", "app", ".", "use", "(", "express", ".", "static", "(", "handles", ".", "filepath", ")", ")", ";", "handles", ".", "server", "=", "require", "(", "'http'", ")", ".", "createServer", "(", "app", ")", ";", "handles", ".", "server", ".", "listen", "(", "handles", ".", "port", ",", "function", "(", ")", "{", "done", "(", "null", ",", "handles", ".", "port", ")", ";", "}", ")", ";", "}", ")", ";", "}", ")", ";", "}"], "docstring": "Configures an express instance on a dynamically assigned port\nfor serving static files and proxying requests based on the config.\n\n@param  {Object.<string, string>} config   the config of the json-proxy for\nthis test suite\n@param  {Function} done callback", "docstring_tokens": ["Configures", "an", "express", "instance", "on", "a", "dynamically", "assigned", "port", "for", "serving", "static", "files", "and", "proxying", "requests", "based", "on", "the", "config", "."], "sha": "b996609b627690774367d8d887f2e8baf102f6bf", "url": "https://github.com/steve-jansen/json-proxy/blob/b996609b627690774367d8d887f2e8baf102f6bf/spec/shared/setup.js#L184-L206", "partition": "test"}
{"repo": "localvoid/karma-snapshot", "path": "lib/format/markdown.js", "func_name": "suiteHeader", "original_string": "function suiteHeader(name, depth) {\n  if (depth === -1) {\n    return \"# \" + serializeName(name) + \"\\n\\n\";\n  }\n  return \"## \" + indent(depth) + serializeName(name) + \"\\n\\n\";\n}", "language": "javascript", "code": "function suiteHeader(name, depth) {\n  if (depth === -1) {\n    return \"# \" + serializeName(name) + \"\\n\\n\";\n  }\n  return \"## \" + indent(depth) + serializeName(name) + \"\\n\\n\";\n}", "code_tokens": ["function", "suiteHeader", "(", "name", ",", "depth", ")", "{", "if", "(", "depth", "===", "-", "1", ")", "{", "return", "\"# \"", "+", "serializeName", "(", "name", ")", "+", "\"\\n\\n\"", ";", "}", "return", "\"## \"", "+", "indent", "(", "depth", ")", "+", "serializeName", "(", "name", ")", "+", "\"\\n\\n\"", ";", "}"], "docstring": "suiteHeader serializes suite header.\n\n@param {string} name Suite name.\n@param {number} depth Suite depth.\n@returns Serialized suite header.", "docstring_tokens": ["suiteHeader", "serializes", "suite", "header", "."], "sha": "ec3f41bab775b5be6d3aa236f55ee12881b25662", "url": "https://github.com/localvoid/karma-snapshot/blob/ec3f41bab775b5be6d3aa236f55ee12881b25662/lib/format/markdown.js#L266-L271", "partition": "test"}
{"repo": "chrisbateman/impetus", "path": "dist/impetus.js", "func_name": "cleanUpRuntimeEvents", "original_string": "function cleanUpRuntimeEvents() {\n            // Remove all touch events added during 'onDown' as well.\n            document.removeEventListener('touchmove', onMove, getPassiveSupported() ? { passive: false } : false);\n            document.removeEventListener('touchend', onUp);\n            document.removeEventListener('touchcancel', stopTracking);\n            document.removeEventListener('mousemove', onMove, getPassiveSupported() ? { passive: false } : false);\n            document.removeEventListener('mouseup', onUp);\n        }", "language": "javascript", "code": "function cleanUpRuntimeEvents() {\n            // Remove all touch events added during 'onDown' as well.\n            document.removeEventListener('touchmove', onMove, getPassiveSupported() ? { passive: false } : false);\n            document.removeEventListener('touchend', onUp);\n            document.removeEventListener('touchcancel', stopTracking);\n            document.removeEventListener('mousemove', onMove, getPassiveSupported() ? { passive: false } : false);\n            document.removeEventListener('mouseup', onUp);\n        }", "code_tokens": ["function", "cleanUpRuntimeEvents", "(", ")", "{", "// Remove all touch events added during 'onDown' as well.", "document", ".", "removeEventListener", "(", "'touchmove'", ",", "onMove", ",", "getPassiveSupported", "(", ")", "?", "{", "passive", ":", "false", "}", ":", "false", ")", ";", "document", ".", "removeEventListener", "(", "'touchend'", ",", "onUp", ")", ";", "document", ".", "removeEventListener", "(", "'touchcancel'", ",", "stopTracking", ")", ";", "document", ".", "removeEventListener", "(", "'mousemove'", ",", "onMove", ",", "getPassiveSupported", "(", ")", "?", "{", "passive", ":", "false", "}", ":", "false", ")", ";", "document", ".", "removeEventListener", "(", "'mouseup'", ",", "onUp", ")", ";", "}"], "docstring": "Removes all events set by this instance during runtime", "docstring_tokens": ["Removes", "all", "events", "set", "by", "this", "instance", "during", "runtime"], "sha": "ef9fefec150655c06e2aec9e628422909fd5f4ce", "url": "https://github.com/chrisbateman/impetus/blob/ef9fefec150655c06e2aec9e628422909fd5f4ce/dist/impetus.js#L174-L181", "partition": "test"}
{"repo": "frapontillo/angular-bootstrap-switch", "path": "dist/angular-bootstrap-switch.js", "func_name": "", "original_string": "function() {\n          // if it's the first initialization\n          if (!isInit) {\n            var viewValue = (controller.$modelValue === getTrueValue());\n            isInit = !isInit;\n            // Bootstrap the switch plugin\n            element.bootstrapSwitch({\n              radioAllOff: getSwitchAttrValue('switchRadioOff'),\n              disabled: getSwitchAttrValue('switchActive'),\n              state: viewValue,\n              onText: getSwitchAttrValue('switchOnText'),\n              offText: getSwitchAttrValue('switchOffText'),\n              onColor: getSwitchAttrValue('switchOnColor'),\n              offColor: getSwitchAttrValue('switchOffColor'),\n              animate: getSwitchAttrValue('switchAnimate'),\n              size: getSwitchAttrValue('switchSize'),\n              labelText: attrs.switchLabel ? getSwitchAttrValue('switchLabel') : getSwitchAttrValue('switchIcon'),\n              wrapperClass: getSwitchAttrValue('switchWrapper'),\n              handleWidth: getSwitchAttrValue('switchHandleWidth'),\n              labelWidth: getSwitchAttrValue('switchLabelWidth'),\n              inverse: getSwitchAttrValue('switchInverse'),\n              readonly: getSwitchAttrValue('switchReadonly')\n            });\n            if (attrs.type === 'radio') {\n              controller.$setViewValue(controller.$modelValue);\n            } else {\n              controller.$setViewValue(viewValue);\n            }\n          }\n        }", "language": "javascript", "code": "function() {\n          // if it's the first initialization\n          if (!isInit) {\n            var viewValue = (controller.$modelValue === getTrueValue());\n            isInit = !isInit;\n            // Bootstrap the switch plugin\n            element.bootstrapSwitch({\n              radioAllOff: getSwitchAttrValue('switchRadioOff'),\n              disabled: getSwitchAttrValue('switchActive'),\n              state: viewValue,\n              onText: getSwitchAttrValue('switchOnText'),\n              offText: getSwitchAttrValue('switchOffText'),\n              onColor: getSwitchAttrValue('switchOnColor'),\n              offColor: getSwitchAttrValue('switchOffColor'),\n              animate: getSwitchAttrValue('switchAnimate'),\n              size: getSwitchAttrValue('switchSize'),\n              labelText: attrs.switchLabel ? getSwitchAttrValue('switchLabel') : getSwitchAttrValue('switchIcon'),\n              wrapperClass: getSwitchAttrValue('switchWrapper'),\n              handleWidth: getSwitchAttrValue('switchHandleWidth'),\n              labelWidth: getSwitchAttrValue('switchLabelWidth'),\n              inverse: getSwitchAttrValue('switchInverse'),\n              readonly: getSwitchAttrValue('switchReadonly')\n            });\n            if (attrs.type === 'radio') {\n              controller.$setViewValue(controller.$modelValue);\n            } else {\n              controller.$setViewValue(viewValue);\n            }\n          }\n        }", "code_tokens": ["function", "(", ")", "{", "// if it's the first initialization", "if", "(", "!", "isInit", ")", "{", "var", "viewValue", "=", "(", "controller", ".", "$modelValue", "===", "getTrueValue", "(", ")", ")", ";", "isInit", "=", "!", "isInit", ";", "// Bootstrap the switch plugin", "element", ".", "bootstrapSwitch", "(", "{", "radioAllOff", ":", "getSwitchAttrValue", "(", "'switchRadioOff'", ")", ",", "disabled", ":", "getSwitchAttrValue", "(", "'switchActive'", ")", ",", "state", ":", "viewValue", ",", "onText", ":", "getSwitchAttrValue", "(", "'switchOnText'", ")", ",", "offText", ":", "getSwitchAttrValue", "(", "'switchOffText'", ")", ",", "onColor", ":", "getSwitchAttrValue", "(", "'switchOnColor'", ")", ",", "offColor", ":", "getSwitchAttrValue", "(", "'switchOffColor'", ")", ",", "animate", ":", "getSwitchAttrValue", "(", "'switchAnimate'", ")", ",", "size", ":", "getSwitchAttrValue", "(", "'switchSize'", ")", ",", "labelText", ":", "attrs", ".", "switchLabel", "?", "getSwitchAttrValue", "(", "'switchLabel'", ")", ":", "getSwitchAttrValue", "(", "'switchIcon'", ")", ",", "wrapperClass", ":", "getSwitchAttrValue", "(", "'switchWrapper'", ")", ",", "handleWidth", ":", "getSwitchAttrValue", "(", "'switchHandleWidth'", ")", ",", "labelWidth", ":", "getSwitchAttrValue", "(", "'switchLabelWidth'", ")", ",", "inverse", ":", "getSwitchAttrValue", "(", "'switchInverse'", ")", ",", "readonly", ":", "getSwitchAttrValue", "(", "'switchReadonly'", ")", "}", ")", ";", "if", "(", "attrs", ".", "type", "===", "'radio'", ")", "{", "controller", ".", "$setViewValue", "(", "controller", ".", "$modelValue", ")", ";", "}", "else", "{", "controller", ".", "$setViewValue", "(", "viewValue", ")", ";", "}", "}", "}"], "docstring": "If the directive has not been initialized yet, do so.", "docstring_tokens": ["If", "the", "directive", "has", "not", "been", "initialized", "yet", "do", "so", "."], "sha": "e9616e34524ae48dbab730d553438b6657948692", "url": "https://github.com/frapontillo/angular-bootstrap-switch/blob/e9616e34524ae48dbab730d553438b6657948692/dist/angular-bootstrap-switch.js#L139-L168", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "webAPIFileRead", "original_string": "function webAPIFileRead(fileObj, startByte, endByte, fileType, chunk) {\n    var function_name = 'slice';\n\n    if (fileObj.file.slice)\n      function_name =  'slice';\n    else if (fileObj.file.mozSlice)\n      function_name = 'mozSlice';\n    else if (fileObj.file.webkitSlice)\n      function_name = 'webkitSlice';\n\n    chunk.readFinished(fileObj.file[function_name](startByte, endByte, fileType));\n  }", "language": "javascript", "code": "function webAPIFileRead(fileObj, startByte, endByte, fileType, chunk) {\n    var function_name = 'slice';\n\n    if (fileObj.file.slice)\n      function_name =  'slice';\n    else if (fileObj.file.mozSlice)\n      function_name = 'mozSlice';\n    else if (fileObj.file.webkitSlice)\n      function_name = 'webkitSlice';\n\n    chunk.readFinished(fileObj.file[function_name](startByte, endByte, fileType));\n  }", "code_tokens": ["function", "webAPIFileRead", "(", "fileObj", ",", "startByte", ",", "endByte", ",", "fileType", ",", "chunk", ")", "{", "var", "function_name", "=", "'slice'", ";", "if", "(", "fileObj", ".", "file", ".", "slice", ")", "function_name", "=", "'slice'", ";", "else", "if", "(", "fileObj", ".", "file", ".", "mozSlice", ")", "function_name", "=", "'mozSlice'", ";", "else", "if", "(", "fileObj", ".", "file", ".", "webkitSlice", ")", "function_name", "=", "'webkitSlice'", ";", "chunk", ".", "readFinished", "(", "fileObj", ".", "file", "[", "function_name", "]", "(", "startByte", ",", "endByte", ",", "fileType", ")", ")", ";", "}"], "docstring": "Default read function using the webAPI\n\n@function webAPIFileRead(fileObj, startByte, endByte, fileType, chunk)", "docstring_tokens": ["Default", "read", "function", "using", "the", "webAPI"], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L1066-L1077", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "addFacetRefinement", "original_string": "function addFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    if (RefinementList.isRefined(this.facetsRefinements, facet, value)) return this;\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.addRefinement(this.facetsRefinements, facet, value)\n    });\n  }", "language": "javascript", "code": "function addFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    if (RefinementList.isRefined(this.facetsRefinements, facet, value)) return this;\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.addRefinement(this.facetsRefinements, facet, value)\n    });\n  }", "code_tokens": ["function", "addFacetRefinement", "(", "facet", ",", "value", ")", "{", "if", "(", "!", "this", ".", "isConjunctiveFacet", "(", "facet", ")", ")", "{", "throw", "new", "Error", "(", "facet", "+", "' is not defined in the facets attribute of the helper configuration'", ")", ";", "}", "if", "(", "RefinementList", ".", "isRefined", "(", "this", ".", "facetsRefinements", ",", "facet", ",", "value", ")", ")", "return", "this", ";", "return", "this", ".", "setQueryParameters", "(", "{", "facetsRefinements", ":", "RefinementList", ".", "addRefinement", "(", "this", ".", "facetsRefinements", ",", "facet", ",", "value", ")", "}", ")", ";", "}"], "docstring": "Add a refinement on a \"normal\" facet\n@method\n@param {string} facet attribute to apply the faceting on\n@param {string} value value of the attribute (will be converted to string)\n@return {SearchParameters}", "docstring_tokens": ["Add", "a", "refinement", "on", "a", "normal", "facet"], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L988-L997", "partition": "test"}
{"repo": "tjworks/angoose", "path": "lib/util/toolbox.js", "func_name": "matroshka", "original_string": "function matroshka(fn) {\n      var babushka = fn;\n      Object.keys(process.namespaces).forEach(function (name) {\n        babushka = process.namespaces[name].bind(babushka);\n      });\n    \n      return babushka;\n    }", "language": "javascript", "code": "function matroshka(fn) {\n      var babushka = fn;\n      Object.keys(process.namespaces).forEach(function (name) {\n        babushka = process.namespaces[name].bind(babushka);\n      });\n    \n      return babushka;\n    }", "code_tokens": ["function", "matroshka", "(", "fn", ")", "{", "var", "babushka", "=", "fn", ";", "Object", ".", "keys", "(", "process", ".", "namespaces", ")", ".", "forEach", "(", "function", "(", "name", ")", "{", "babushka", "=", "process", ".", "namespaces", "[", "name", "]", ".", "bind", "(", "babushka", ")", ";", "}", ")", ";", "return", "babushka", ";", "}"], "docstring": "Workaround for Q module with CLS", "docstring_tokens": ["Workaround", "for", "Q", "module", "with", "CLS"], "sha": "2172f7a9f44d1337156792bf4dc382805b47e121", "url": "https://github.com/tjworks/angoose/blob/2172f7a9f44d1337156792bf4dc382805b47e121/lib/util/toolbox.js#L80-L87", "partition": "test"}
{"repo": "bholloway/browserify-nginject", "path": "lib/get-updater.js", "func_name": "updater", "original_string": "function updater(file, ast) {\n    if (ast.comments) {\n      ast.comments\n        .filter(testDocTag)\n        .map(getAnnotatedNode)\n        .concat(inferAngular(ast))    // find the items that are not explicitly annotated\n        .filter(testFirstOccurrence)  // ensure unique values\n        .forEach(processNode);\n    } else {\n      errorFn('Esprima AST is required to have top-level comments array');\n    }\n    return ast;\n  }", "language": "javascript", "code": "function updater(file, ast) {\n    if (ast.comments) {\n      ast.comments\n        .filter(testDocTag)\n        .map(getAnnotatedNode)\n        .concat(inferAngular(ast))    // find the items that are not explicitly annotated\n        .filter(testFirstOccurrence)  // ensure unique values\n        .forEach(processNode);\n    } else {\n      errorFn('Esprima AST is required to have top-level comments array');\n    }\n    return ast;\n  }", "code_tokens": ["function", "updater", "(", "file", ",", "ast", ")", "{", "if", "(", "ast", ".", "comments", ")", "{", "ast", ".", "comments", ".", "filter", "(", "testDocTag", ")", ".", "map", "(", "getAnnotatedNode", ")", ".", "concat", "(", "inferAngular", "(", "ast", ")", ")", "// find the items that are not explicitly annotated", ".", "filter", "(", "testFirstOccurrence", ")", "// ensure unique values", ".", "forEach", "(", "processNode", ")", ";", "}", "else", "{", "errorFn", "(", "'Esprima AST is required to have top-level comments array'", ")", ";", "}", "return", "ast", ";", "}"], "docstring": "The updater function for the esprima transform\n@param {string} file The filename for the Browserify transform\n@param {object} ast The esprima syntax tree\n@returns {object} The transformed esprima syntax tree", "docstring_tokens": ["The", "updater", "function", "for", "the", "esprima", "transform"], "sha": "42cff52081b66d77e4e7fac923d4d824de13cfd3", "url": "https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/get-updater.js#L24-L36", "partition": "test"}
{"repo": "acarl005/join-monster", "path": "src/query-ast-to-sql-ast/index.js", "func_name": "spreadFragments", "original_string": "function spreadFragments(selections, fragments, typeName) {\n  return flatMap(selections, selection => {\n    switch (selection.kind) {\n    case 'FragmentSpread':\n      const fragmentName = selection.name.value\n      const fragment = fragments[fragmentName]\n      return spreadFragments(fragment.selectionSet.selections, fragments, typeName)\n    case 'InlineFragment':\n      if (selection.typeCondition.name.value === typeName) {\n        return spreadFragments(selection.selectionSet.selections, fragments, typeName)\n      }\n      return []\n\n    default:\n      return selection\n    }\n  })\n}", "language": "javascript", "code": "function spreadFragments(selections, fragments, typeName) {\n  return flatMap(selections, selection => {\n    switch (selection.kind) {\n    case 'FragmentSpread':\n      const fragmentName = selection.name.value\n      const fragment = fragments[fragmentName]\n      return spreadFragments(fragment.selectionSet.selections, fragments, typeName)\n    case 'InlineFragment':\n      if (selection.typeCondition.name.value === typeName) {\n        return spreadFragments(selection.selectionSet.selections, fragments, typeName)\n      }\n      return []\n\n    default:\n      return selection\n    }\n  })\n}", "code_tokens": ["function", "spreadFragments", "(", "selections", ",", "fragments", ",", "typeName", ")", "{", "return", "flatMap", "(", "selections", ",", "selection", "=>", "{", "switch", "(", "selection", ".", "kind", ")", "{", "case", "'FragmentSpread'", ":", "const", "fragmentName", "=", "selection", ".", "name", ".", "value", "const", "fragment", "=", "fragments", "[", "fragmentName", "]", "return", "spreadFragments", "(", "fragment", ".", "selectionSet", ".", "selections", ",", "fragments", ",", "typeName", ")", "case", "'InlineFragment'", ":", "if", "(", "selection", ".", "typeCondition", ".", "name", ".", "value", "===", "typeName", ")", "{", "return", "spreadFragments", "(", "selection", ".", "selectionSet", ".", "selections", ",", "fragments", ",", "typeName", ")", "}", "return", "[", "]", "default", ":", "return", "selection", "}", "}", ")", "}"], "docstring": "instead of fields, selections can be fragments, which is another group of selections fragments can be arbitrarily nested this function recurses through and gets the relevant fields", "docstring_tokens": ["instead", "of", "fields", "selections", "can", "be", "fragments", "which", "is", "another", "group", "of", "selections", "fragments", "can", "be", "arbitrarily", "nested", "this", "function", "recurses", "through", "and", "gets", "the", "relevant", "fields"], "sha": "8db8b54aaefd2fd975d63e2ab3ec05922e25118c", "url": "https://github.com/acarl005/join-monster/blob/8db8b54aaefd2fd975d63e2ab3ec05922e25118c/src/query-ast-to-sql-ast/index.js#L653-L670", "partition": "test"}
{"repo": "makeomatic/ms-users-restify", "path": "docs/main.js", "func_name": "addArticleSettings", "original_string": "function addArticleSettings(fields, entry) {\n        // add unique id\n        // TODO: replace all group-name-version in template with id.\n        fields.id = fields.article.group + '-' + fields.article.name + '-' + fields.article.version;\n        fields.id = fields.id.replace(/\\./g, '_');\n\n        if (entry.header && entry.header.fields)\n            fields._hasTypeInHeaderFields = _hasTypeInFields(entry.header.fields);\n\n        if (entry.parameter && entry.parameter.fields)\n            fields._hasTypeInParameterFields = _hasTypeInFields(entry.parameter.fields);\n\n        if (entry.error && entry.error.fields)\n            fields._hasTypeInErrorFields = _hasTypeInFields(entry.error.fields);\n\n        if (entry.success && entry.success.fields)\n            fields._hasTypeInSuccessFields = _hasTypeInFields(entry.success.fields);\n\n        if (entry.info && entry.info.fields)\n            fields._hasTypeInInfoFields = _hasTypeInFields(entry.info.fields);\n\n        // add template settings\n        fields.template = apiProject.template;\n    }", "language": "javascript", "code": "function addArticleSettings(fields, entry) {\n        // add unique id\n        // TODO: replace all group-name-version in template with id.\n        fields.id = fields.article.group + '-' + fields.article.name + '-' + fields.article.version;\n        fields.id = fields.id.replace(/\\./g, '_');\n\n        if (entry.header && entry.header.fields)\n            fields._hasTypeInHeaderFields = _hasTypeInFields(entry.header.fields);\n\n        if (entry.parameter && entry.parameter.fields)\n            fields._hasTypeInParameterFields = _hasTypeInFields(entry.parameter.fields);\n\n        if (entry.error && entry.error.fields)\n            fields._hasTypeInErrorFields = _hasTypeInFields(entry.error.fields);\n\n        if (entry.success && entry.success.fields)\n            fields._hasTypeInSuccessFields = _hasTypeInFields(entry.success.fields);\n\n        if (entry.info && entry.info.fields)\n            fields._hasTypeInInfoFields = _hasTypeInFields(entry.info.fields);\n\n        // add template settings\n        fields.template = apiProject.template;\n    }", "code_tokens": ["function", "addArticleSettings", "(", "fields", ",", "entry", ")", "{", "// add unique id", "// TODO: replace all group-name-version in template with id.", "fields", ".", "id", "=", "fields", ".", "article", ".", "group", "+", "'-'", "+", "fields", ".", "article", ".", "name", "+", "'-'", "+", "fields", ".", "article", ".", "version", ";", "fields", ".", "id", "=", "fields", ".", "id", ".", "replace", "(", "/", "\\.", "/", "g", ",", "'_'", ")", ";", "if", "(", "entry", ".", "header", "&&", "entry", ".", "header", ".", "fields", ")", "fields", ".", "_hasTypeInHeaderFields", "=", "_hasTypeInFields", "(", "entry", ".", "header", ".", "fields", ")", ";", "if", "(", "entry", ".", "parameter", "&&", "entry", ".", "parameter", ".", "fields", ")", "fields", ".", "_hasTypeInParameterFields", "=", "_hasTypeInFields", "(", "entry", ".", "parameter", ".", "fields", ")", ";", "if", "(", "entry", ".", "error", "&&", "entry", ".", "error", ".", "fields", ")", "fields", ".", "_hasTypeInErrorFields", "=", "_hasTypeInFields", "(", "entry", ".", "error", ".", "fields", ")", ";", "if", "(", "entry", ".", "success", "&&", "entry", ".", "success", ".", "fields", ")", "fields", ".", "_hasTypeInSuccessFields", "=", "_hasTypeInFields", "(", "entry", ".", "success", ".", "fields", ")", ";", "if", "(", "entry", ".", "info", "&&", "entry", ".", "info", ".", "fields", ")", "fields", ".", "_hasTypeInInfoFields", "=", "_hasTypeInFields", "(", "entry", ".", "info", ".", "fields", ")", ";", "// add template settings", "fields", ".", "template", "=", "apiProject", ".", "template", ";", "}"], "docstring": "Add article settings.", "docstring_tokens": ["Add", "article", "settings", "."], "sha": "f6c1e464458eb35c1dd62ce0bf648a560d6759e0", "url": "https://github.com/makeomatic/ms-users-restify/blob/f6c1e464458eb35c1dd62ce0bf648a560d6759e0/docs/main.js#L580-L603", "partition": "test"}
{"repo": "StarryInternet/eslint-plugin-starry", "path": "lib/rules/computed-property-spacing.js", "func_name": "reportRequiredBeginningSpace", "original_string": "function reportRequiredBeginningSpace( node, token ) {\n    context.report({\n      node: node,\n      loc: token.loc.start,\n      message: 'A space is required after \\'' + token.value + '\\'',\n      fix: function( fixer ) {\n        return fixer.insertTextAfter( token, ' ' );\n      }\n    });\n  }", "language": "javascript", "code": "function reportRequiredBeginningSpace( node, token ) {\n    context.report({\n      node: node,\n      loc: token.loc.start,\n      message: 'A space is required after \\'' + token.value + '\\'',\n      fix: function( fixer ) {\n        return fixer.insertTextAfter( token, ' ' );\n      }\n    });\n  }", "code_tokens": ["function", "reportRequiredBeginningSpace", "(", "node", ",", "token", ")", "{", "context", ".", "report", "(", "{", "node", ":", "node", ",", "loc", ":", "token", ".", "loc", ".", "start", ",", "message", ":", "'A space is required after \\''", "+", "token", ".", "value", "+", "'\\''", ",", "fix", ":", "function", "(", "fixer", ")", "{", "return", "fixer", ".", "insertTextAfter", "(", "token", ",", "' '", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Reports that there should be a space after the first token\n@param {ASTNode} node - The node to report in the event of an error.\n@param {Token} token - The token to use for the report.\n@returns {void}", "docstring_tokens": ["Reports", "that", "there", "should", "be", "a", "space", "after", "the", "first", "token"], "sha": "6b0a55c4d0263c549e88f80001b8cca417fca5ca", "url": "https://github.com/StarryInternet/eslint-plugin-starry/blob/6b0a55c4d0263c549e88f80001b8cca417fca5ca/lib/rules/computed-property-spacing.js#L70-L79", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "memoize", "original_string": "function memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + ':' + pattern, options);\n  var disabled = options && options.cache === false;\n  if (disabled) {\n    braces.clearCache();\n    return fn(pattern, options);\n  }\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  var res = fn(pattern, options);\n  cache[key] = res;\n  return res;\n}", "language": "javascript", "code": "function memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + ':' + pattern, options);\n  var disabled = options && options.cache === false;\n  if (disabled) {\n    braces.clearCache();\n    return fn(pattern, options);\n  }\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  var res = fn(pattern, options);\n  cache[key] = res;\n  return res;\n}", "code_tokens": ["function", "memoize", "(", "type", ",", "pattern", ",", "options", ",", "fn", ")", "{", "var", "key", "=", "utils", ".", "createKey", "(", "type", "+", "':'", "+", "pattern", ",", "options", ")", ";", "var", "disabled", "=", "options", "&&", "options", ".", "cache", "===", "false", ";", "if", "(", "disabled", ")", "{", "braces", ".", "clearCache", "(", ")", ";", "return", "fn", "(", "pattern", ",", "options", ")", ";", "}", "if", "(", "cache", ".", "hasOwnProperty", "(", "key", ")", ")", "{", "return", "cache", "[", "key", "]", ";", "}", "var", "res", "=", "fn", "(", "pattern", ",", "options", ")", ";", "cache", "[", "key", "]", "=", "res", ";", "return", "res", ";", "}"], "docstring": "Memoize a generated regex or function. A unique key is generated\nfrom the method name, pattern, and user-defined options. Set\noptions.memoize to false to disable.", "docstring_tokens": ["Memoize", "a", "generated", "regex", "or", "function", ".", "A", "unique", "key", "is", "generated", "from", "the", "method", "name", "pattern", "and", "user", "-", "defined", "options", ".", "Set", "options", ".", "memoize", "to", "false", "to", "disable", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L3841-L3856", "partition": "test"}
{"repo": "mysticatea/eslint-utils", "path": "src/pattern-matcher.js", "func_name": "isEscaped", "original_string": "function isEscaped(str, index) {\n    let escaped = false\n    for (let i = index - 1; i >= 0 && str.charCodeAt(i) === 0x5c; --i) {\n        escaped = !escaped\n    }\n    return escaped\n}", "language": "javascript", "code": "function isEscaped(str, index) {\n    let escaped = false\n    for (let i = index - 1; i >= 0 && str.charCodeAt(i) === 0x5c; --i) {\n        escaped = !escaped\n    }\n    return escaped\n}", "code_tokens": ["function", "isEscaped", "(", "str", ",", "index", ")", "{", "let", "escaped", "=", "false", "for", "(", "let", "i", "=", "index", "-", "1", ";", "i", ">=", "0", "&&", "str", ".", "charCodeAt", "(", "i", ")", "===", "0x5c", ";", "--", "i", ")", "{", "escaped", "=", "!", "escaped", "}", "return", "escaped", "}"], "docstring": "Check whether a given character is escaped or not.\n@param {string} str The string to check.\n@param {number} index The location of the character to check.\n@returns {boolean} `true` if the character is escaped.", "docstring_tokens": ["Check", "whether", "a", "given", "character", "is", "escaped", "or", "not", "."], "sha": "b2041e47f3c74e00ef7b746c4b0c43fc3f4732f0", "url": "https://github.com/mysticatea/eslint-utils/blob/b2041e47f3c74e00ef7b746c4b0c43fc3f4732f0/src/pattern-matcher.js#L17-L23", "partition": "test"}
{"repo": "johntitus/node-horseman", "path": "lib/actions.js", "func_name": "waitForPage", "original_string": "function waitForPage(page, optsOrFn) {\n\tvar self = this;\n\tvar args, value, fname, timeout = self.options.timeout, fn;\n\n\tif(typeof optsOrFn === \"function\"){\n\t\t\tfn = optsOrFn;\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t\tvalue = args.pop();\n\t\t\tfname = fn.name || '<anonymous>';\n\t} else if(typeof optsOrFn === \"object\"){\n\t\t\tfn = optsOrFn.fn;\n\t\t\targs = [page, fn].concat(optsOrFn.args || []);\n\t\t\tvalue = optsOrFn.value;\n\t\t\tfname = fn.name || '<anonymous>';\n\t\t\tif(optsOrFn.timeout){\n\t\t\t\ttimeout = optsOrFn.timeout;\n\t\t\t}\n\t}\n\n\tdebug.apply(debug, ['.waitFor()', fname].concat(args.slice(2)));\n\treturn this.ready.then(function() {\n\t\treturn new HorsemanPromise(function(resolve, reject) {\n\t\t\tvar start = Date.now();\n\t\t\tvar checkInterval = setInterval(function waitForCheck() {\n\t\t\t\tvar _page = page || self.page;\n\t\t\t\tvar diff = Date.now() - start;\n\t\t\t\tif (diff > timeout) {\n\t\t\t\t\tclearInterval(checkInterval);\n\t\t\t\t\tdebug('.waitFor() timed out');\n\t\t\t\t\tif (typeof _page.onTimeout === 'function') {\n\t\t\t\t\t\t_page.onTimeout('waitFor');\n\t\t\t\t\t}\n\t\t\t\t\treject(new TimeoutError(\n\t\t\t\t\t\t\t'timeout during .waitFor() after ' + diff + ' ms'));\n\t\t\t\t} else {\n\t\t\t\t\treturn evaluatePage.apply(self, args)\n\t\t\t\t\t\t.tap(function(res) {\n\t\t\t\t\t\t\tdebugv('.waitFor() iteration',\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t\t\t\t\t\t\tres,\n\t\t\t\t\t\t\t\t\tdiff,\n\t\t\t\t\t\t\t\t\tself.id\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(function(res) {\n\t\t\t\t\t\t\tif (res === value) {\n\t\t\t\t\t\t\t\tdebug('.waitFor() completed successfully');\n\t\t\t\t\t\t\t\tclearInterval(checkInterval);\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(function(err) {\n\t\t\t\t\t\t\tclearInterval(checkInterval);\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, self.options.interval);\n\t\t});\n\t});\n}", "language": "javascript", "code": "function waitForPage(page, optsOrFn) {\n\tvar self = this;\n\tvar args, value, fname, timeout = self.options.timeout, fn;\n\n\tif(typeof optsOrFn === \"function\"){\n\t\t\tfn = optsOrFn;\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t\tvalue = args.pop();\n\t\t\tfname = fn.name || '<anonymous>';\n\t} else if(typeof optsOrFn === \"object\"){\n\t\t\tfn = optsOrFn.fn;\n\t\t\targs = [page, fn].concat(optsOrFn.args || []);\n\t\t\tvalue = optsOrFn.value;\n\t\t\tfname = fn.name || '<anonymous>';\n\t\t\tif(optsOrFn.timeout){\n\t\t\t\ttimeout = optsOrFn.timeout;\n\t\t\t}\n\t}\n\n\tdebug.apply(debug, ['.waitFor()', fname].concat(args.slice(2)));\n\treturn this.ready.then(function() {\n\t\treturn new HorsemanPromise(function(resolve, reject) {\n\t\t\tvar start = Date.now();\n\t\t\tvar checkInterval = setInterval(function waitForCheck() {\n\t\t\t\tvar _page = page || self.page;\n\t\t\t\tvar diff = Date.now() - start;\n\t\t\t\tif (diff > timeout) {\n\t\t\t\t\tclearInterval(checkInterval);\n\t\t\t\t\tdebug('.waitFor() timed out');\n\t\t\t\t\tif (typeof _page.onTimeout === 'function') {\n\t\t\t\t\t\t_page.onTimeout('waitFor');\n\t\t\t\t\t}\n\t\t\t\t\treject(new TimeoutError(\n\t\t\t\t\t\t\t'timeout during .waitFor() after ' + diff + ' ms'));\n\t\t\t\t} else {\n\t\t\t\t\treturn evaluatePage.apply(self, args)\n\t\t\t\t\t\t.tap(function(res) {\n\t\t\t\t\t\t\tdebugv('.waitFor() iteration',\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t\t\t\t\t\t\tres,\n\t\t\t\t\t\t\t\t\tdiff,\n\t\t\t\t\t\t\t\t\tself.id\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(function(res) {\n\t\t\t\t\t\t\tif (res === value) {\n\t\t\t\t\t\t\t\tdebug('.waitFor() completed successfully');\n\t\t\t\t\t\t\t\tclearInterval(checkInterval);\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(function(err) {\n\t\t\t\t\t\t\tclearInterval(checkInterval);\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, self.options.interval);\n\t\t});\n\t});\n}", "code_tokens": ["function", "waitForPage", "(", "page", ",", "optsOrFn", ")", "{", "var", "self", "=", "this", ";", "var", "args", ",", "value", ",", "fname", ",", "timeout", "=", "self", ".", "options", ".", "timeout", ",", "fn", ";", "if", "(", "typeof", "optsOrFn", "===", "\"function\"", ")", "{", "fn", "=", "optsOrFn", ";", "args", "=", "Array", ".", "prototype", ".", "slice", ".", "call", "(", "arguments", ")", ";", "value", "=", "args", ".", "pop", "(", ")", ";", "fname", "=", "fn", ".", "name", "||", "'<anonymous>'", ";", "}", "else", "if", "(", "typeof", "optsOrFn", "===", "\"object\"", ")", "{", "fn", "=", "optsOrFn", ".", "fn", ";", "args", "=", "[", "page", ",", "fn", "]", ".", "concat", "(", "optsOrFn", ".", "args", "||", "[", "]", ")", ";", "value", "=", "optsOrFn", ".", "value", ";", "fname", "=", "fn", ".", "name", "||", "'<anonymous>'", ";", "if", "(", "optsOrFn", ".", "timeout", ")", "{", "timeout", "=", "optsOrFn", ".", "timeout", ";", "}", "}", "debug", ".", "apply", "(", "debug", ",", "[", "'.waitFor()'", ",", "fname", "]", ".", "concat", "(", "args", ".", "slice", "(", "2", ")", ")", ")", ";", "return", "this", ".", "ready", ".", "then", "(", "function", "(", ")", "{", "return", "new", "HorsemanPromise", "(", "function", "(", "resolve", ",", "reject", ")", "{", "var", "start", "=", "Date", ".", "now", "(", ")", ";", "var", "checkInterval", "=", "setInterval", "(", "function", "waitForCheck", "(", ")", "{", "var", "_page", "=", "page", "||", "self", ".", "page", ";", "var", "diff", "=", "Date", ".", "now", "(", ")", "-", "start", ";", "if", "(", "diff", ">", "timeout", ")", "{", "clearInterval", "(", "checkInterval", ")", ";", "debug", "(", "'.waitFor() timed out'", ")", ";", "if", "(", "typeof", "_page", ".", "onTimeout", "===", "'function'", ")", "{", "_page", ".", "onTimeout", "(", "'waitFor'", ")", ";", "}", "reject", "(", "new", "TimeoutError", "(", "'timeout during .waitFor() after '", "+", "diff", "+", "' ms'", ")", ")", ";", "}", "else", "{", "return", "evaluatePage", ".", "apply", "(", "self", ",", "args", ")", ".", "tap", "(", "function", "(", "res", ")", "{", "debugv", "(", "'.waitFor() iteration'", ",", "fname", ",", "res", ",", "diff", ",", "self", ".", "id", ")", ";", "}", ")", ".", "then", "(", "function", "(", "res", ")", "{", "if", "(", "res", "===", "value", ")", "{", "debug", "(", "'.waitFor() completed successfully'", ")", ";", "clearInterval", "(", "checkInterval", ")", ";", "resolve", "(", ")", ";", "}", "}", ")", ".", "catch", "(", "function", "(", "err", ")", "{", "clearInterval", "(", "checkInterval", ")", ";", "reject", "(", "err", ")", ";", "}", ")", ";", "}", "}", ",", "self", ".", "options", ".", "interval", ")", ";", "}", ")", ";", "}", ")", ";", "}"], "docstring": "Waits for a function to evaluate to a given value on the given page\n@param {Page | undefined} page\n@param {function | object} optsOrFn - If optsOrFn is a function, use the classic signature waitForPage(page, fn, arg1, arg2, value), If arg is an object, use waitForPage(page, options)\n@param {array} optsOrFn.args - arguments of fn\n@param {function} optsOrFn.fn - function to evaluate\n@param {*} optsOrFn.value - expected value of function\n@param {number} [optsOrFn.timeout=null] - timeout in ms\n@param {...*} [arguments]\n@param {*} value\n@emits Horseman#TimeoutError", "docstring_tokens": ["Waits", "for", "a", "function", "to", "evaluate", "to", "a", "given", "value", "on", "the", "given", "page"], "sha": "831699df1708d96c91d8010a8ee975c4d022fe0e", "url": "https://github.com/johntitus/node-horseman/blob/831699df1708d96c91d8010a8ee975c4d022fe0e/lib/actions.js#L1656-L1715", "partition": "test"}
{"repo": "JAAulde/cookies", "path": "lib/jaaulde-cookies.js", "func_name": "", "original_string": "function (n, v, o) {\n                if (typeof o !== 'object' || o === null) {\n                    o = {};\n                }\n\n                if (v === undef || v === null) {\n                    v = '';\n                    o.expires = new Date();\n                    o.expires.setFullYear(1978);\n                } else {\n                    /* Logic borrowed from http://jquery.com/ dataAttr method and reversed */\n                    v = (v === true)\n                        ? 'true' : (v === false)\n                            ? 'false' : !isNaN(v)\n                                ? String(v) : v;\n\n                    if (typeof v !== 'string') {\n                        if (typeof JSON === 'object' && JSON !== null && typeof JSON.stringify === 'function') {\n                            v = JSON.stringify(v);\n                        } else {\n                            throw new Error('cookies.set() could not be serialize the value');\n                        }\n                    }\n                }\n\n                document.cookie = n + '=' + encodeURIComponent(v) + cookieOptions(o);\n            }", "language": "javascript", "code": "function (n, v, o) {\n                if (typeof o !== 'object' || o === null) {\n                    o = {};\n                }\n\n                if (v === undef || v === null) {\n                    v = '';\n                    o.expires = new Date();\n                    o.expires.setFullYear(1978);\n                } else {\n                    /* Logic borrowed from http://jquery.com/ dataAttr method and reversed */\n                    v = (v === true)\n                        ? 'true' : (v === false)\n                            ? 'false' : !isNaN(v)\n                                ? String(v) : v;\n\n                    if (typeof v !== 'string') {\n                        if (typeof JSON === 'object' && JSON !== null && typeof JSON.stringify === 'function') {\n                            v = JSON.stringify(v);\n                        } else {\n                            throw new Error('cookies.set() could not be serialize the value');\n                        }\n                    }\n                }\n\n                document.cookie = n + '=' + encodeURIComponent(v) + cookieOptions(o);\n            }", "code_tokens": ["function", "(", "n", ",", "v", ",", "o", ")", "{", "if", "(", "typeof", "o", "!==", "'object'", "||", "o", "===", "null", ")", "{", "o", "=", "{", "}", ";", "}", "if", "(", "v", "===", "undef", "||", "v", "===", "null", ")", "{", "v", "=", "''", ";", "o", ".", "expires", "=", "new", "Date", "(", ")", ";", "o", ".", "expires", ".", "setFullYear", "(", "1978", ")", ";", "}", "else", "{", "/* Logic borrowed from http://jquery.com/ dataAttr method and reversed */", "v", "=", "(", "v", "===", "true", ")", "?", "'true'", ":", "(", "v", "===", "false", ")", "?", "'false'", ":", "!", "isNaN", "(", "v", ")", "?", "String", "(", "v", ")", ":", "v", ";", "if", "(", "typeof", "v", "!==", "'string'", ")", "{", "if", "(", "typeof", "JSON", "===", "'object'", "&&", "JSON", "!==", "null", "&&", "typeof", "JSON", ".", "stringify", "===", "'function'", ")", "{", "v", "=", "JSON", ".", "stringify", "(", "v", ")", ";", "}", "else", "{", "throw", "new", "Error", "(", "'cookies.set() could not be serialize the value'", ")", ";", "}", "}", "}", "document", ".", "cookie", "=", "n", "+", "'='", "+", "encodeURIComponent", "(", "v", ")", "+", "cookieOptions", "(", "o", ")", ";", "}"], "docstring": "set - set or delete a cookie with desired options\n\n@access public\n@static\n@param {string} n name of cookie to set\n@param {mixed} v Any JS value. If not a string, will be JSON encoded (http://code.google.com/p/cookies/wiki/JSON)\n{null} to delete\n@param {object} o optional list of cookie options to specify\n@return {void}", "docstring_tokens": ["set", "-", "set", "or", "delete", "a", "cookie", "with", "desired", "options"], "sha": "63e74a48a7245cd88202f825c01bfe69fc5e4559", "url": "https://github.com/JAAulde/cookies/blob/63e74a48a7245cd88202f825c01bfe69fc5e4559/lib/jaaulde-cookies.js#L324-L350", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/utils.js", "func_name": "iteratorToArray", "original_string": "function iteratorToArray(iterator) {\n  const values = [];\n  let item = iterator.next();\n  while (!item.done) {\n    values.push(item.value);\n    item = iterator.next();\n  }\n  return values;\n}", "language": "javascript", "code": "function iteratorToArray(iterator) {\n  const values = [];\n  let item = iterator.next();\n  while (!item.done) {\n    values.push(item.value);\n    item = iterator.next();\n  }\n  return values;\n}", "code_tokens": ["function", "iteratorToArray", "(", "iterator", ")", "{", "const", "values", "=", "[", "]", ";", "let", "item", "=", "iterator", ".", "next", "(", ")", ";", "while", "(", "!", "item", ".", "done", ")", "{", "values", ".", "push", "(", "item", ".", "value", ")", ";", "item", "=", "iterator", ".", "next", "(", ")", ";", "}", "return", "values", ";", "}"], "docstring": "Convert the iterator values into an array\n@param iterator\n@returns {Array}", "docstring_tokens": ["Convert", "the", "iterator", "values", "into", "an", "array"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/utils.js#L238-L246", "partition": "test"}
{"repo": "brython-dev/brython", "path": "www/src/py_string.js", "func_name": "", "original_string": "function(val, flags){\n    number_check(val)\n    if(! flags.precision){\n        if(! flags.decimal_point){\n            flags.precision = 6\n        }else{\n            flags.precision = 0\n        }\n    }else{\n        flags.precision = parseInt(flags.precision, 10)\n        validate_precision(flags.precision)\n    }\n    return parseFloat(val)\n}", "language": "javascript", "code": "function(val, flags){\n    number_check(val)\n    if(! flags.precision){\n        if(! flags.decimal_point){\n            flags.precision = 6\n        }else{\n            flags.precision = 0\n        }\n    }else{\n        flags.precision = parseInt(flags.precision, 10)\n        validate_precision(flags.precision)\n    }\n    return parseFloat(val)\n}", "code_tokens": ["function", "(", "val", ",", "flags", ")", "{", "number_check", "(", "val", ")", "if", "(", "!", "flags", ".", "precision", ")", "{", "if", "(", "!", "flags", ".", "decimal_point", ")", "{", "flags", ".", "precision", "=", "6", "}", "else", "{", "flags", ".", "precision", "=", "0", "}", "}", "else", "{", "flags", ".", "precision", "=", "parseInt", "(", "flags", ".", "precision", ",", "10", ")", "validate_precision", "(", "flags", ".", "precision", ")", "}", "return", "parseFloat", "(", "val", ")", "}"], "docstring": "converts val to float and sets precision if missing", "docstring_tokens": ["converts", "val", "to", "float", "and", "sets", "precision", "if", "missing"], "sha": "e437d320fce3c649c3028f2f7a8533eeae906440", "url": "https://github.com/brython-dev/brython/blob/e437d320fce3c649c3028f2f7a8533eeae906440/www/src/py_string.js#L366-L379", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/Container.js", "func_name": "", "original_string": "function(item, destroy) {\n        var me = this,\n            index = me.indexOf(item),\n            innerItems = me.getInnerItems();\n\n        if (destroy === undefined) {\n            destroy = me.getAutoDestroy();\n        }\n\n        if (index !== -1) {\n            if (!me.removingAll && innerItems.length > 1 && item === me.getActiveItem()) {\n                me.on({\n                    activeitemchange: 'doRemove',\n                    scope: me,\n                    single: true,\n                    order: 'after',\n                    args: [item, index, destroy]\n                });\n\n                me.doResetActiveItem(innerItems.indexOf(item));\n            }\n            else {\n                me.doRemove(item, index, destroy);\n                if (innerItems.length === 0) {\n                    me.setActiveItem(null);\n                }\n            }\n        }\n\n        return me;\n    }", "language": "javascript", "code": "function(item, destroy) {\n        var me = this,\n            index = me.indexOf(item),\n            innerItems = me.getInnerItems();\n\n        if (destroy === undefined) {\n            destroy = me.getAutoDestroy();\n        }\n\n        if (index !== -1) {\n            if (!me.removingAll && innerItems.length > 1 && item === me.getActiveItem()) {\n                me.on({\n                    activeitemchange: 'doRemove',\n                    scope: me,\n                    single: true,\n                    order: 'after',\n                    args: [item, index, destroy]\n                });\n\n                me.doResetActiveItem(innerItems.indexOf(item));\n            }\n            else {\n                me.doRemove(item, index, destroy);\n                if (innerItems.length === 0) {\n                    me.setActiveItem(null);\n                }\n            }\n        }\n\n        return me;\n    }", "code_tokens": ["function", "(", "item", ",", "destroy", ")", "{", "var", "me", "=", "this", ",", "index", "=", "me", ".", "indexOf", "(", "item", ")", ",", "innerItems", "=", "me", ".", "getInnerItems", "(", ")", ";", "if", "(", "destroy", "===", "undefined", ")", "{", "destroy", "=", "me", ".", "getAutoDestroy", "(", ")", ";", "}", "if", "(", "index", "!==", "-", "1", ")", "{", "if", "(", "!", "me", ".", "removingAll", "&&", "innerItems", ".", "length", ">", "1", "&&", "item", "===", "me", ".", "getActiveItem", "(", ")", ")", "{", "me", ".", "on", "(", "{", "activeitemchange", ":", "'doRemove'", ",", "scope", ":", "me", ",", "single", ":", "true", ",", "order", ":", "'after'", ",", "args", ":", "[", "item", ",", "index", ",", "destroy", "]", "}", ")", ";", "me", ".", "doResetActiveItem", "(", "innerItems", ".", "indexOf", "(", "item", ")", ")", ";", "}", "else", "{", "me", ".", "doRemove", "(", "item", ",", "index", ",", "destroy", ")", ";", "if", "(", "innerItems", ".", "length", "===", "0", ")", "{", "me", ".", "setActiveItem", "(", "null", ")", ";", "}", "}", "}", "return", "me", ";", "}"], "docstring": "Removes an item from this Container, optionally destroying it.\n@param {Object} item The item to remove.\n@param {Boolean} [destroy] Calls the Component's {@link Ext.Component#method-destroy destroy}\nmethod if `true`.\n@return {Ext.Component} this", "docstring_tokens": ["Removes", "an", "item", "from", "this", "Container", "optionally", "destroying", "it", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/Container.js#L728-L758", "partition": "test"}
{"repo": "probot/probot-config", "path": "lib/index.js", "func_name": "getBaseParams", "original_string": "function getBaseParams(params, base) {\n  if (typeof base !== 'string') {\n    throw new Error(`Invalid repository name in key \"${BASE_KEY}\"`);\n  }\n\n  const match = base.match(BASE_REGEX);\n  if (match == null) {\n    throw new Error(`Invalid repository name in key \"${BASE_KEY}\": ${base}`);\n  }\n\n  return {\n    owner: match[1] || params.owner,\n    repo: match[2],\n    path: match[3] || params.path,\n  };\n}", "language": "javascript", "code": "function getBaseParams(params, base) {\n  if (typeof base !== 'string') {\n    throw new Error(`Invalid repository name in key \"${BASE_KEY}\"`);\n  }\n\n  const match = base.match(BASE_REGEX);\n  if (match == null) {\n    throw new Error(`Invalid repository name in key \"${BASE_KEY}\": ${base}`);\n  }\n\n  return {\n    owner: match[1] || params.owner,\n    repo: match[2],\n    path: match[3] || params.path,\n  };\n}", "code_tokens": ["function", "getBaseParams", "(", "params", ",", "base", ")", "{", "if", "(", "typeof", "base", "!==", "'string'", ")", "{", "throw", "new", "Error", "(", "`", "${", "BASE_KEY", "}", "`", ")", ";", "}", "const", "match", "=", "base", ".", "match", "(", "BASE_REGEX", ")", ";", "if", "(", "match", "==", "null", ")", "{", "throw", "new", "Error", "(", "`", "${", "BASE_KEY", "}", "${", "base", "}", "`", ")", ";", "}", "return", "{", "owner", ":", "match", "[", "1", "]", "||", "params", ".", "owner", ",", "repo", ":", "match", "[", "2", "]", ",", "path", ":", "match", "[", "3", "]", "||", "params", ".", "path", ",", "}", ";", "}"], "docstring": "Computes parameters for the repository specified in base\n\nBase can either be the name of a repository in the same organization or\na full slug \"organization/repo\".\n\n@param {object} params An object containing owner, repo and path\n@param {string} base A string specifying the base repository\n@returns {object} The params of the base configuration", "docstring_tokens": ["Computes", "parameters", "for", "the", "repository", "specified", "in", "base"], "sha": "dbdbc8b2d421997797a6e229f2e01c189c1696db", "url": "https://github.com/probot/probot-config/blob/dbdbc8b2d421997797a6e229f2e01c189c1696db/lib/index.js#L69-L84", "partition": "test"}
{"repo": "alexisvincent/systemjs-hot-reloader", "path": "dist/index.js", "func_name": "encode$1", "original_string": "function encode$1(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}", "language": "javascript", "code": "function encode$1(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}", "code_tokens": ["function", "encode$1", "(", "num", ")", "{", "var", "encoded", "=", "''", ";", "do", "{", "encoded", "=", "alphabet", "[", "num", "%", "length", "]", "+", "encoded", ";", "num", "=", "Math", ".", "floor", "(", "num", "/", "length", ")", ";", "}", "while", "(", "num", ">", "0", ")", ";", "return", "encoded", ";", "}"], "docstring": "Return a string representing the specified number.\n\n@param {Number} num The number to convert.\n@returns {String} The string representation of the number.\n@api public", "docstring_tokens": ["Return", "a", "string", "representing", "the", "specified", "number", "."], "sha": "e3cca45a50e69cba4c1988a251ef07f460c27619", "url": "https://github.com/alexisvincent/systemjs-hot-reloader/blob/e3cca45a50e69cba4c1988a251ef07f460c27619/dist/index.js#L4397-L4406", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "createBasicPlugin", "original_string": "function createBasicPlugin(name, plugin) {\n  var basicPluginWrapper = function basicPluginWrapper() {\n\n    // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n    // regardless, but we want the hash to be consistent with the hash provided\n    // for advanced plugins.\n    //\n    // The only potentially counter-intuitive thing here is the `instance` in\n    // the \"pluginsetup\" event is the value returned by the `plugin` function.\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);\n\n    var instance = plugin.apply(this, arguments);\n\n    markPluginAsActive(this, name);\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });\n\n    return instance;\n  };\n\n  Object.keys(plugin).forEach(function (prop) {\n    basicPluginWrapper[prop] = plugin[prop];\n  });\n\n  return basicPluginWrapper;\n}", "language": "javascript", "code": "function createBasicPlugin(name, plugin) {\n  var basicPluginWrapper = function basicPluginWrapper() {\n\n    // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n    // regardless, but we want the hash to be consistent with the hash provided\n    // for advanced plugins.\n    //\n    // The only potentially counter-intuitive thing here is the `instance` in\n    // the \"pluginsetup\" event is the value returned by the `plugin` function.\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);\n\n    var instance = plugin.apply(this, arguments);\n\n    markPluginAsActive(this, name);\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });\n\n    return instance;\n  };\n\n  Object.keys(plugin).forEach(function (prop) {\n    basicPluginWrapper[prop] = plugin[prop];\n  });\n\n  return basicPluginWrapper;\n}", "code_tokens": ["function", "createBasicPlugin", "(", "name", ",", "plugin", ")", "{", "var", "basicPluginWrapper", "=", "function", "basicPluginWrapper", "(", ")", "{", "// We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player", "// regardless, but we want the hash to be consistent with the hash provided", "// for advanced plugins.", "//", "// The only potentially counter-intuitive thing here is the `instance` in", "// the \"pluginsetup\" event is the value returned by the `plugin` function.", "triggerSetupEvent", "(", "this", ",", "{", "name", ":", "name", ",", "plugin", ":", "plugin", ",", "instance", ":", "null", "}", ",", "true", ")", ";", "var", "instance", "=", "plugin", ".", "apply", "(", "this", ",", "arguments", ")", ";", "markPluginAsActive", "(", "this", ",", "name", ")", ";", "triggerSetupEvent", "(", "this", ",", "{", "name", ":", "name", ",", "plugin", ":", "plugin", ",", "instance", ":", "instance", "}", ")", ";", "return", "instance", ";", "}", ";", "Object", ".", "keys", "(", "plugin", ")", ".", "forEach", "(", "function", "(", "prop", ")", "{", "basicPluginWrapper", "[", "prop", "]", "=", "plugin", "[", "prop", "]", ";", "}", ")", ";", "return", "basicPluginWrapper", ";", "}"], "docstring": "Takes a basic plugin function and returns a wrapper function which marks\non the player that the plugin has been activated.\n\n@private\n@param   {string} name\nThe name of the plugin.\n\n@param   {Function} plugin\nThe basic plugin.\n\n@returns {Function}\nA wrapper function for the given plugin.", "docstring_tokens": ["Takes", "a", "basic", "plugin", "function", "and", "returns", "a", "wrapper", "function", "which", "marks", "on", "the", "player", "that", "the", "plugin", "has", "been", "activated", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L21288-L21312", "partition": "test"}
{"repo": "es-analysis/plato", "path": "lib/assets/scripts/vendor/codemirror/codemirror.js", "func_name": "updateDoc", "original_string": "function updateDoc(cm, from, to, newText, selUpdate, origin) {\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans &&\n      removeReadOnlyRanges(cm.view.doc, from, to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        updateDocInner(cm, split[i].from, split[i].to, [\"\"], origin);\n      if (split.length)\n        return updateDocInner(cm, split[0].from, split[0].to, newText, selUpdate, origin);\n    } else {\n      return updateDocInner(cm, from, to, newText, selUpdate, origin);\n    }\n  }", "language": "javascript", "code": "function updateDoc(cm, from, to, newText, selUpdate, origin) {\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans &&\n      removeReadOnlyRanges(cm.view.doc, from, to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        updateDocInner(cm, split[i].from, split[i].to, [\"\"], origin);\n      if (split.length)\n        return updateDocInner(cm, split[0].from, split[0].to, newText, selUpdate, origin);\n    } else {\n      return updateDocInner(cm, from, to, newText, selUpdate, origin);\n    }\n  }", "code_tokens": ["function", "updateDoc", "(", "cm", ",", "from", ",", "to", ",", "newText", ",", "selUpdate", ",", "origin", ")", "{", "// Possibly split or suppress the update based on the presence", "// of read-only spans in its range.", "var", "split", "=", "sawReadOnlySpans", "&&", "removeReadOnlyRanges", "(", "cm", ".", "view", ".", "doc", ",", "from", ",", "to", ")", ";", "if", "(", "split", ")", "{", "for", "(", "var", "i", "=", "split", ".", "length", "-", "1", ";", "i", ">=", "1", ";", "--", "i", ")", "updateDocInner", "(", "cm", ",", "split", "[", "i", "]", ".", "from", ",", "split", "[", "i", "]", ".", "to", ",", "[", "\"\"", "]", ",", "origin", ")", ";", "if", "(", "split", ".", "length", ")", "return", "updateDocInner", "(", "cm", ",", "split", "[", "0", "]", ".", "from", ",", "split", "[", "0", "]", ".", "to", ",", "newText", ",", "selUpdate", ",", "origin", ")", ";", "}", "else", "{", "return", "updateDocInner", "(", "cm", ",", "from", ",", "to", ",", "newText", ",", "selUpdate", ",", "origin", ")", ";", "}", "}"], "docstring": "Replace the range from from to to by the strings in newText. Afterwards, set the selection to selFrom, selTo.", "docstring_tokens": ["Replace", "the", "range", "from", "from", "to", "to", "by", "the", "strings", "in", "newText", ".", "Afterwards", "set", "the", "selection", "to", "selFrom", "selTo", "."], "sha": "a944bb9313785bcc47fb27b257bb2518c86174bd", "url": "https://github.com/es-analysis/plato/blob/a944bb9313785bcc47fb27b257bb2518c86174bd/lib/assets/scripts/vendor/codemirror/codemirror.js#L1849-L1862", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(obj, elements) {\n    return elements === undefined ? [] : utils.map(elements, function(item) {\n      return utils.indexOf(obj, item);\n    });\n  }", "language": "javascript", "code": "function(obj, elements) {\n    return elements === undefined ? [] : utils.map(elements, function(item) {\n      return utils.indexOf(obj, item);\n    });\n  }", "code_tokens": ["function", "(", "obj", ",", "elements", ")", "{", "return", "elements", "===", "undefined", "?", "[", "]", ":", "utils", ".", "map", "(", "elements", ",", "function", "(", "item", ")", "{", "return", "utils", ".", "indexOf", "(", "obj", ",", "item", ")", ";", "}", ")", ";", "}"], "docstring": "Returns an array of indexes of the first occurrences of the passed elements\non the passed object.\n\n```javascript\nvar array = [1, 2, 3, 4, 5];\nEmber.EnumerableUtils.indexesOf(array, [2, 5]); // [1, 4]\n\nvar fubar = \"Fubarr\";\nEmber.EnumerableUtils.indexesOf(fubar, ['b', 'r']); // [2, 4]\n```\n\n@method indexesOf\n@param {Object} obj The object to check for element indexes\n@param {Array} elements The elements to search for on *obj*\n\n@return {Array} An array of indexes.", "docstring_tokens": ["Returns", "an", "array", "of", "indexes", "of", "the", "first", "occurrences", "of", "the", "passed", "elements", "on", "the", "passed", "object", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L1983-L1987", "partition": "test"}
{"repo": "jsdom/jsdom", "path": "lib/jsdom/living/events/EventTarget-impl.js", "func_name": "normalizeEventHandlerOptions", "original_string": "function normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}", "language": "javascript", "code": "function normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}", "code_tokens": ["function", "normalizeEventHandlerOptions", "(", "options", ",", "defaultBoolKeys", ")", "{", "const", "returnValue", "=", "{", "}", ";", "// no need to go further here", "if", "(", "typeof", "options", "===", "\"boolean\"", "||", "options", "===", "null", "||", "typeof", "options", "===", "\"undefined\"", ")", "{", "returnValue", ".", "capture", "=", "Boolean", "(", "options", ")", ";", "return", "returnValue", ";", "}", "// non objects options so we typecast its value as \"capture\" value", "if", "(", "typeof", "options", "!==", "\"object\"", ")", "{", "returnValue", ".", "capture", "=", "Boolean", "(", "options", ")", ";", "// at this point we don't need to loop the \"capture\" key anymore", "defaultBoolKeys", "=", "defaultBoolKeys", ".", "filter", "(", "k", "=>", "k", "!==", "\"capture\"", ")", ";", "}", "for", "(", "const", "key", "of", "defaultBoolKeys", ")", "{", "returnValue", "[", "key", "]", "=", "Boolean", "(", "options", "[", "key", "]", ")", ";", "}", "return", "returnValue", ";", "}"], "docstring": "Normalize the event listeners options argument in order to get always a valid options object\n@param   {Object} options         - user defined options\n@param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n@returns {Object} object containing at least the \"defaultBoolKeys\"", "docstring_tokens": ["Normalize", "the", "event", "listeners", "options", "argument", "in", "order", "to", "get", "always", "a", "valid", "options", "object"], "sha": "43f2089142f57cddc3983e6429c34351699625f2", "url": "https://github.com/jsdom/jsdom/blob/43f2089142f57cddc3983e6429c34351699625f2/lib/jsdom/living/events/EventTarget-impl.js#L352-L373", "partition": "test"}
{"repo": "broccolijs/broccoli", "path": "lib/load_brocfile.js", "func_name": "requireBrocfile", "original_string": "function requireBrocfile(brocfilePath) {\n  let brocfile;\n\n  if (brocfilePath.match(/\\.ts$/)) {\n    try {\n      require.resolve('ts-node');\n    } catch (e) {\n      throw new Error(`Cannot find module 'ts-node', please install`);\n    }\n\n    try {\n      require.resolve('typescript');\n    } catch (e) {\n      throw new Error(`Cannot find module 'typescript', please install`);\n    }\n\n    // Register ts-node typescript compiler\n    require('ts-node').register(); // eslint-disable-line node/no-unpublished-require\n\n    // Load brocfile via ts-node\n    brocfile = require(brocfilePath);\n  } else {\n    // Load brocfile via esm shim\n    brocfile = esmRequire(brocfilePath);\n  }\n\n  // ESM `export default X` is represented as module.exports = { default: X }\n  if (brocfile !== null && typeof brocfile === 'object' && brocfile.hasOwnProperty('default')) {\n    brocfile = brocfile.default;\n  }\n\n  return brocfile;\n}", "language": "javascript", "code": "function requireBrocfile(brocfilePath) {\n  let brocfile;\n\n  if (brocfilePath.match(/\\.ts$/)) {\n    try {\n      require.resolve('ts-node');\n    } catch (e) {\n      throw new Error(`Cannot find module 'ts-node', please install`);\n    }\n\n    try {\n      require.resolve('typescript');\n    } catch (e) {\n      throw new Error(`Cannot find module 'typescript', please install`);\n    }\n\n    // Register ts-node typescript compiler\n    require('ts-node').register(); // eslint-disable-line node/no-unpublished-require\n\n    // Load brocfile via ts-node\n    brocfile = require(brocfilePath);\n  } else {\n    // Load brocfile via esm shim\n    brocfile = esmRequire(brocfilePath);\n  }\n\n  // ESM `export default X` is represented as module.exports = { default: X }\n  if (brocfile !== null && typeof brocfile === 'object' && brocfile.hasOwnProperty('default')) {\n    brocfile = brocfile.default;\n  }\n\n  return brocfile;\n}", "code_tokens": ["function", "requireBrocfile", "(", "brocfilePath", ")", "{", "let", "brocfile", ";", "if", "(", "brocfilePath", ".", "match", "(", "/", "\\.ts$", "/", ")", ")", "{", "try", "{", "require", ".", "resolve", "(", "'ts-node'", ")", ";", "}", "catch", "(", "e", ")", "{", "throw", "new", "Error", "(", "`", "`", ")", ";", "}", "try", "{", "require", ".", "resolve", "(", "'typescript'", ")", ";", "}", "catch", "(", "e", ")", "{", "throw", "new", "Error", "(", "`", "`", ")", ";", "}", "// Register ts-node typescript compiler", "require", "(", "'ts-node'", ")", ".", "register", "(", ")", ";", "// eslint-disable-line node/no-unpublished-require", "// Load brocfile via ts-node", "brocfile", "=", "require", "(", "brocfilePath", ")", ";", "}", "else", "{", "// Load brocfile via esm shim", "brocfile", "=", "esmRequire", "(", "brocfilePath", ")", ";", "}", "// ESM `export default X` is represented as module.exports = { default: X }", "if", "(", "brocfile", "!==", "null", "&&", "typeof", "brocfile", "===", "'object'", "&&", "brocfile", ".", "hasOwnProperty", "(", "'default'", ")", ")", "{", "brocfile", "=", "brocfile", ".", "default", ";", "}", "return", "brocfile", ";", "}"], "docstring": "Require a brocfile via either ESM or TypeScript\n\n@param {String} brocfilePath The path to the brocfile\n@returns {*}", "docstring_tokens": ["Require", "a", "brocfile", "via", "either", "ESM", "or", "TypeScript"], "sha": "55152adc4f7de802dea5758415c9c45653ecd4c5", "url": "https://github.com/broccolijs/broccoli/blob/55152adc4f7de802dea5758415c9c45653ecd4c5/lib/load_brocfile.js#L13-L45", "partition": "test"}
{"repo": "arizonatribe/utilitarian", "path": "src/string.util.js", "func_name": "randomString", "original_string": "function randomString(length, charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') {\n    let str = '',\n        isAllNumeric = false,\n        isNegative = false,\n        useCharSet = charSet;\n\n    if (+length) {\n        if (!isString(charSet)) {\n            if (isNumber(charSet)) {\n                if (+charSet) {\n                    isAllNumeric = true;\n                    isNegative = +charSet < 0;\n                    useCharSet = `${Math.abs(+charSet)}`;\n                } else {\n                    useCharSet = ALPHANUMERIC_CHARS;\n                }\n            } else {\n                useCharSet = ALPHANUMERIC_CHARS;\n            }\n        }\n      \n        const generateChar = function gc(len) {\n            return Math.round(Math.random() * (len - 1));\n        }.bind(null, useCharSet.length);\n      \n        str = Array(+length).fill().map((v, index) => {\n            const newChar = generateChar();\n            /* If we are generating a random number, make sure the first digit is not zero */\n            if (!index && isAllNumeric && !newChar) {\n                return useCharSet.charAt(newChar + 1);\n            }\n\n            return useCharSet.charAt(newChar);\n        }).join('');\n    }\n\n    if (isAllNumeric) {\n        return isNegative ? -+str : +str;\n    }\n\n    return str;\n}", "language": "javascript", "code": "function randomString(length, charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') {\n    let str = '',\n        isAllNumeric = false,\n        isNegative = false,\n        useCharSet = charSet;\n\n    if (+length) {\n        if (!isString(charSet)) {\n            if (isNumber(charSet)) {\n                if (+charSet) {\n                    isAllNumeric = true;\n                    isNegative = +charSet < 0;\n                    useCharSet = `${Math.abs(+charSet)}`;\n                } else {\n                    useCharSet = ALPHANUMERIC_CHARS;\n                }\n            } else {\n                useCharSet = ALPHANUMERIC_CHARS;\n            }\n        }\n      \n        const generateChar = function gc(len) {\n            return Math.round(Math.random() * (len - 1));\n        }.bind(null, useCharSet.length);\n      \n        str = Array(+length).fill().map((v, index) => {\n            const newChar = generateChar();\n            /* If we are generating a random number, make sure the first digit is not zero */\n            if (!index && isAllNumeric && !newChar) {\n                return useCharSet.charAt(newChar + 1);\n            }\n\n            return useCharSet.charAt(newChar);\n        }).join('');\n    }\n\n    if (isAllNumeric) {\n        return isNegative ? -+str : +str;\n    }\n\n    return str;\n}", "code_tokens": ["function", "randomString", "(", "length", ",", "charSet", "=", "'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'", ")", "{", "let", "str", "=", "''", ",", "isAllNumeric", "=", "false", ",", "isNegative", "=", "false", ",", "useCharSet", "=", "charSet", ";", "if", "(", "+", "length", ")", "{", "if", "(", "!", "isString", "(", "charSet", ")", ")", "{", "if", "(", "isNumber", "(", "charSet", ")", ")", "{", "if", "(", "+", "charSet", ")", "{", "isAllNumeric", "=", "true", ";", "isNegative", "=", "+", "charSet", "<", "0", ";", "useCharSet", "=", "`", "${", "Math", ".", "abs", "(", "+", "charSet", ")", "}", "`", ";", "}", "else", "{", "useCharSet", "=", "ALPHANUMERIC_CHARS", ";", "}", "}", "else", "{", "useCharSet", "=", "ALPHANUMERIC_CHARS", ";", "}", "}", "const", "generateChar", "=", "function", "gc", "(", "len", ")", "{", "return", "Math", ".", "round", "(", "Math", ".", "random", "(", ")", "*", "(", "len", "-", "1", ")", ")", ";", "}", ".", "bind", "(", "null", ",", "useCharSet", ".", "length", ")", ";", "str", "=", "Array", "(", "+", "length", ")", ".", "fill", "(", ")", ".", "map", "(", "(", "v", ",", "index", ")", "=>", "{", "const", "newChar", "=", "generateChar", "(", ")", ";", "/* If we are generating a random number, make sure the first digit is not zero */", "if", "(", "!", "index", "&&", "isAllNumeric", "&&", "!", "newChar", ")", "{", "return", "useCharSet", ".", "charAt", "(", "newChar", "+", "1", ")", ";", "}", "return", "useCharSet", ".", "charAt", "(", "newChar", ")", ";", "}", ")", ".", "join", "(", "''", ")", ";", "}", "if", "(", "isAllNumeric", ")", "{", "return", "isNegative", "?", "-", "+", "str", ":", "+", "str", ";", "}", "return", "str", ";", "}"], "docstring": "Generates a random string of text of a given length.\nWill generate an alpha-numeric string unless you specify a different character set as the second argument\n@method utilitarian.string.util#randomString\n@param {number} length The length of the string to generate\n@param {string|number} [charSet] optional set of characters to use when generating a random string\n(defaults to full alpha-numeric set)\n@returns {string|number} A randomly generated string or number", "docstring_tokens": ["Generates", "a", "random", "string", "of", "text", "of", "a", "given", "length", ".", "Will", "generate", "an", "alpha", "-", "numeric", "string", "unless", "you", "specify", "a", "different", "character", "set", "as", "the", "second", "argument"], "sha": "3472a16265d0810eb2873e80211199a83825d230", "url": "https://github.com/arizonatribe/utilitarian/blob/3472a16265d0810eb2873e80211199a83825d230/src/string.util.js#L79-L120", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/data/NodeInterface.js", "func_name": "", "original_string": "function(node) {\n                    if (Ext.isObject(node) && !node.isModel) {\n                        node = Ext.data.ModelManager.create(node, this.modelName);\n                    }\n                    // Make sure the node implements the node interface\n                    return Ext.data.NodeInterface.decorate(node);\n                }", "language": "javascript", "code": "function(node) {\n                    if (Ext.isObject(node) && !node.isModel) {\n                        node = Ext.data.ModelManager.create(node, this.modelName);\n                    }\n                    // Make sure the node implements the node interface\n                    return Ext.data.NodeInterface.decorate(node);\n                }", "code_tokens": ["function", "(", "node", ")", "{", "if", "(", "Ext", ".", "isObject", "(", "node", ")", "&&", "!", "node", ".", "isModel", ")", "{", "node", "=", "Ext", ".", "data", ".", "ModelManager", ".", "create", "(", "node", ",", "this", ".", "modelName", ")", ";", "}", "// Make sure the node implements the node interface", "return", "Ext", ".", "data", ".", "NodeInterface", ".", "decorate", "(", "node", ")", ";", "}"], "docstring": "Ensures that the passed object is an instance of a Record with the NodeInterface applied\n@return {Boolean}\n@private", "docstring_tokens": ["Ensures", "that", "the", "passed", "object", "is", "an", "instance", "of", "a", "Record", "with", "the", "NodeInterface", "applied"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/data/NodeInterface.js#L280-L286", "partition": "test"}
{"repo": "accurat/accurapp", "path": "packages/webpack-preset-accurapp/customBlocks.js", "func_name": "imageLoader", "original_string": "function imageLoader() {\n  return (context, { addLoader }) =>\n    addLoader({\n      test: /\\.(gif|ico|jpg|jpeg|png|webp)$/,\n      loader: 'url-loader',\n      options: {\n        limit: 10000,\n        name: fileNameTemplate,\n      },\n    })\n}", "language": "javascript", "code": "function imageLoader() {\n  return (context, { addLoader }) =>\n    addLoader({\n      test: /\\.(gif|ico|jpg|jpeg|png|webp)$/,\n      loader: 'url-loader',\n      options: {\n        limit: 10000,\n        name: fileNameTemplate,\n      },\n    })\n}", "code_tokens": ["function", "imageLoader", "(", ")", "{", "return", "(", "context", ",", "{", "addLoader", "}", ")", "=>", "addLoader", "(", "{", "test", ":", "/", "\\.(gif|ico|jpg|jpeg|png|webp)$", "/", ",", "loader", ":", "'url-loader'", ",", "options", ":", "{", "limit", ":", "10000", ",", "name", ":", "fileNameTemplate", ",", "}", ",", "}", ")", "}"], "docstring": "Images smaller than 10kb are loaded as a base64 encoded url instead of file url", "docstring_tokens": ["Images", "smaller", "than", "10kb", "are", "loaded", "as", "a", "base64", "encoded", "url", "instead", "of", "file", "url"], "sha": "4658397daa4a983830b4f881287c880e66efaaae", "url": "https://github.com/accurat/accurapp/blob/4658397daa4a983830b4f881287c880e66efaaae/packages/webpack-preset-accurapp/customBlocks.js#L58-L68", "partition": "test"}
{"repo": "wavesoft/gulp-jbb-profile", "path": "index.js", "func_name": "bufferMode", "original_string": "function bufferMode( contents, options, callback ) {\n\tProfileCompiler( contents.toString('utf-8'), options, function(err, encBuf, decBuf){\n\t\tif (err) {\n\t\t\tcallback(err);\n\t\t\treturn;\n\t\t}\n\n\t\t// Callback buffers\n\t\tcallback(null, new Buffer(encBuf,'utf8'), \n\t\t\t\t\t   new Buffer(decBuf,'utf8') );\n\t});\n}", "language": "javascript", "code": "function bufferMode( contents, options, callback ) {\n\tProfileCompiler( contents.toString('utf-8'), options, function(err, encBuf, decBuf){\n\t\tif (err) {\n\t\t\tcallback(err);\n\t\t\treturn;\n\t\t}\n\n\t\t// Callback buffers\n\t\tcallback(null, new Buffer(encBuf,'utf8'), \n\t\t\t\t\t   new Buffer(decBuf,'utf8') );\n\t});\n}", "code_tokens": ["function", "bufferMode", "(", "contents", ",", "options", ",", "callback", ")", "{", "ProfileCompiler", "(", "contents", ".", "toString", "(", "'utf-8'", ")", ",", "options", ",", "function", "(", "err", ",", "encBuf", ",", "decBuf", ")", "{", "if", "(", "err", ")", "{", "callback", "(", "err", ")", ";", "return", ";", "}", "// Callback buffers", "callback", "(", "null", ",", "new", "Buffer", "(", "encBuf", ",", "'utf8'", ")", ",", "new", "Buffer", "(", "decBuf", ",", "'utf8'", ")", ")", ";", "}", ")", ";", "}"], "docstring": "Read entire buffer and compile", "docstring_tokens": ["Read", "entire", "buffer", "and", "compile"], "sha": "3e9bc0ca733ae0325a09a461f504fc847e256f7a", "url": "https://github.com/wavesoft/gulp-jbb-profile/blob/3e9bc0ca733ae0325a09a461f504fc847e256f7a/index.js#L34-L45", "partition": "test"}
{"repo": "olegpolyakov/sendpulse", "path": "index.js", "func_name": "campaignStatByReferrals", "original_string": "function campaignStatByReferrals(callback,id){\n    if (id===undefined) {\n        return callback(returnError('Empty book id'));\n    }\n    sendRequest( 'campaigns/' + id + '/referrals', 'GET', {}, true, callback );\n}", "language": "javascript", "code": "function campaignStatByReferrals(callback,id){\n    if (id===undefined) {\n        return callback(returnError('Empty book id'));\n    }\n    sendRequest( 'campaigns/' + id + '/referrals', 'GET', {}, true, callback );\n}", "code_tokens": ["function", "campaignStatByReferrals", "(", "callback", ",", "id", ")", "{", "if", "(", "id", "===", "undefined", ")", "{", "return", "callback", "(", "returnError", "(", "'Empty book id'", ")", ")", ";", "}", "sendRequest", "(", "'campaigns/'", "+", "id", "+", "'/referrals'", ",", "'GET'", ",", "{", "}", ",", "true", ",", "callback", ")", ";", "}"], "docstring": "Get campaign statistic by referrals\n\n@param callback\n@param id", "docstring_tokens": ["Get", "campaign", "statistic", "by", "referrals"], "sha": "7c8230e75c918a8a110f641ddb241006a1f86ac1", "url": "https://github.com/olegpolyakov/sendpulse/blob/7c8230e75c918a8a110f641ddb241006a1f86ac1/index.js#L467-L472", "partition": "test"}
{"repo": "zuren/catdown-scrollsync", "path": "index.js", "func_name": "", "original_string": "function(element, ev, fn){\n\tif(element.addEventListener) \n\t\telement.addEventListener(ev, fn, false);\n\telse element.attachEvent(\"on\" + ev, fn);\n}", "language": "javascript", "code": "function(element, ev, fn){\n\tif(element.addEventListener) \n\t\telement.addEventListener(ev, fn, false);\n\telse element.attachEvent(\"on\" + ev, fn);\n}", "code_tokens": ["function", "(", "element", ",", "ev", ",", "fn", ")", "{", "if", "(", "element", ".", "addEventListener", ")", "element", ".", "addEventListener", "(", "ev", ",", "fn", ",", "false", ")", ";", "else", "element", ".", "attachEvent", "(", "\"on\"", "+", "ev", ",", "fn", ")", ";", "}"], "docstring": "Cross-browser event listener", "docstring_tokens": ["Cross", "-", "browser", "event", "listener"], "sha": "1becc36002c2636ecc3823691405d2cd8842073a", "url": "https://github.com/zuren/catdown-scrollsync/blob/1becc36002c2636ecc3823691405d2cd8842073a/index.js#L2-L6", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "findTokenOnLeftOfPosition", "original_string": "function findTokenOnLeftOfPosition(file, position) {\n        // Ideally, getTokenAtPosition should return a token. However, it is currently\n        // broken, so we do a check to make sure the result was indeed a token.\n        var tokenAtPosition = getTokenAtPosition(file, position);\n        if (isToken(tokenAtPosition) && position > tokenAtPosition.getStart(file) && position < tokenAtPosition.getEnd()) {\n            return tokenAtPosition;\n        }\n        return findPrecedingToken(position, file);\n    }", "language": "javascript", "code": "function findTokenOnLeftOfPosition(file, position) {\n        // Ideally, getTokenAtPosition should return a token. However, it is currently\n        // broken, so we do a check to make sure the result was indeed a token.\n        var tokenAtPosition = getTokenAtPosition(file, position);\n        if (isToken(tokenAtPosition) && position > tokenAtPosition.getStart(file) && position < tokenAtPosition.getEnd()) {\n            return tokenAtPosition;\n        }\n        return findPrecedingToken(position, file);\n    }", "code_tokens": ["function", "findTokenOnLeftOfPosition", "(", "file", ",", "position", ")", "{", "// Ideally, getTokenAtPosition should return a token. However, it is currently", "// broken, so we do a check to make sure the result was indeed a token.", "var", "tokenAtPosition", "=", "getTokenAtPosition", "(", "file", ",", "position", ")", ";", "if", "(", "isToken", "(", "tokenAtPosition", ")", "&&", "position", ">", "tokenAtPosition", ".", "getStart", "(", "file", ")", "&&", "position", "<", "tokenAtPosition", ".", "getEnd", "(", ")", ")", "{", "return", "tokenAtPosition", ";", "}", "return", "findPrecedingToken", "(", "position", ",", "file", ")", ";", "}"], "docstring": "The token on the left of the position is the token that strictly includes the position\nor sits to the left of the cursor if it is on a boundary. For example\n\nfo|o               -> will return foo\nfoo <comment> |bar -> will return foo", "docstring_tokens": ["The", "token", "on", "the", "left", "of", "the", "position", "is", "the", "token", "that", "strictly", "includes", "the", "position", "or", "sits", "to", "the", "left", "of", "the", "cursor", "if", "it", "is", "on", "a", "boundary", ".", "For", "example"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L39580-L39588", "partition": "test"}
{"repo": "carbon-design-system/carbon-components", "path": "packages/components/src/components/date-picker/date-picker.js", "func_name": "flattenOptions", "original_string": "function flattenOptions(options) {\n  const o = {};\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const key in options) {\n    o[key] = options[key];\n  }\n  return o;\n}", "language": "javascript", "code": "function flattenOptions(options) {\n  const o = {};\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const key in options) {\n    o[key] = options[key];\n  }\n  return o;\n}", "code_tokens": ["function", "flattenOptions", "(", "options", ")", "{", "const", "o", "=", "{", "}", ";", "// eslint-disable-next-line guard-for-in, no-restricted-syntax", "for", "(", "const", "key", "in", "options", ")", "{", "o", "[", "key", "]", "=", "options", "[", "key", "]", ";", "}", "return", "o", ";", "}"], "docstring": "`this.options` create-component mix-in creates prototype chain so that `options` given in constructor argument wins over the one defined in static `options` property 'Flatpickr' wants flat structure of object instead", "docstring_tokens": ["this", ".", "options", "create", "-", "component", "mix", "-", "in", "creates", "prototype", "chain", "so", "that", "options", "given", "in", "constructor", "argument", "wins", "over", "the", "one", "defined", "in", "static", "options", "property", "Flatpickr", "wants", "flat", "structure", "of", "object", "instead"], "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302", "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/components/src/components/date-picker/date-picker.js#L22-L29", "partition": "test"}
{"repo": "viridia/certainty", "path": "lib/format/formatArray.js", "func_name": "formatArray", "original_string": "function formatArray(value, options) {\n  var opts = options || {};\n  var innerOpts = Object.assign({}, opts, { clip: false });\n  var parts = ['['];\n  var length = 2; // Include both open and close bracket.\n  for (var i = 0; i < value.length; ++i) {\n    var sep = i > 0 ? ', ' : '';\n    var s = registry.format(value[i], innerOpts);\n    length += sep.length + s.length;\n    if (opts.clip && opts.clip < length) {\n      parts.push(', ...');\n      break;\n    }\n    parts.push(sep);\n    parts.push(s);\n  }\n  parts.push(']');\n  return parts.join('');\n}", "language": "javascript", "code": "function formatArray(value, options) {\n  var opts = options || {};\n  var innerOpts = Object.assign({}, opts, { clip: false });\n  var parts = ['['];\n  var length = 2; // Include both open and close bracket.\n  for (var i = 0; i < value.length; ++i) {\n    var sep = i > 0 ? ', ' : '';\n    var s = registry.format(value[i], innerOpts);\n    length += sep.length + s.length;\n    if (opts.clip && opts.clip < length) {\n      parts.push(', ...');\n      break;\n    }\n    parts.push(sep);\n    parts.push(s);\n  }\n  parts.push(']');\n  return parts.join('');\n}", "code_tokens": ["function", "formatArray", "(", "value", ",", "options", ")", "{", "var", "opts", "=", "options", "||", "{", "}", ";", "var", "innerOpts", "=", "Object", ".", "assign", "(", "{", "}", ",", "opts", ",", "{", "clip", ":", "false", "}", ")", ";", "var", "parts", "=", "[", "'['", "]", ";", "var", "length", "=", "2", ";", "// Include both open and close bracket.", "for", "(", "var", "i", "=", "0", ";", "i", "<", "value", ".", "length", ";", "++", "i", ")", "{", "var", "sep", "=", "i", ">", "0", "?", "', '", ":", "''", ";", "var", "s", "=", "registry", ".", "format", "(", "value", "[", "i", "]", ",", "innerOpts", ")", ";", "length", "+=", "sep", ".", "length", "+", "s", ".", "length", ";", "if", "(", "opts", ".", "clip", "&&", "opts", ".", "clip", "<", "length", ")", "{", "parts", ".", "push", "(", "', ...'", ")", ";", "break", ";", "}", "parts", ".", "push", "(", "sep", ")", ";", "parts", ".", "push", "(", "s", ")", ";", "}", "parts", ".", "push", "(", "']'", ")", ";", "return", "parts", ".", "join", "(", "''", ")", ";", "}"], "docstring": "Convert an array value to a printable string representation.\n@param {Array} value The value to format.\n@param {Object} options Formatting options.\n@protected", "docstring_tokens": ["Convert", "an", "array", "value", "to", "a", "printable", "string", "representation", "."], "sha": "ab4294df65dfda324ef0713a3a22657959958f80", "url": "https://github.com/viridia/certainty/blob/ab4294df65dfda324ef0713a3a22657959958f80/lib/format/formatArray.js#L8-L26", "partition": "test"}
{"repo": "greenkeeperio/greenkeeper", "path": "utils/utils.js", "func_name": "", "original_string": "function (travisYML, newVersion, newCodeName, existingVersions) {\n  // Should only remove the old version if it is actually present in any form\n  if (existingVersions.versions.length === 0) return travisYML\n  const nodeVersionIndex = getNodeVersionIndex(existingVersions.versions, newVersion, newCodeName, true)\n  let travisYMLLines = travisYML.split('\\n')\n  // We only need to do something if the old version is present\n  if (nodeVersionIndex !== -1) {\n    // If it\u2019s the only version we don\u2019t want to remove it\n    if (existingVersions.versions.length !== 1) {\n      // Multiple node versions were defined in array format\n      // set lines we want to remove to undefined in existingVersion.versions and filter them out afterwards\n      const updatedVersionsArray = _.filter(existingVersions.versions.map((version) => {\n        return hasNodeVersion(version, newVersion, newCodeName, true) ? undefined : version\n      }), Boolean)\n      // splice the updated existingversions into travisymllines\n      travisYMLLines.splice(existingVersions.startIndex + 1, existingVersions.endIndex - existingVersions.startIndex, updatedVersionsArray)\n      // has an array in an array, needs to be flattened\n      travisYMLLines = _.flatten(travisYMLLines)\n    }\n  }\n  return travisYMLLines.join('\\n')\n}", "language": "javascript", "code": "function (travisYML, newVersion, newCodeName, existingVersions) {\n  // Should only remove the old version if it is actually present in any form\n  if (existingVersions.versions.length === 0) return travisYML\n  const nodeVersionIndex = getNodeVersionIndex(existingVersions.versions, newVersion, newCodeName, true)\n  let travisYMLLines = travisYML.split('\\n')\n  // We only need to do something if the old version is present\n  if (nodeVersionIndex !== -1) {\n    // If it\u2019s the only version we don\u2019t want to remove it\n    if (existingVersions.versions.length !== 1) {\n      // Multiple node versions were defined in array format\n      // set lines we want to remove to undefined in existingVersion.versions and filter them out afterwards\n      const updatedVersionsArray = _.filter(existingVersions.versions.map((version) => {\n        return hasNodeVersion(version, newVersion, newCodeName, true) ? undefined : version\n      }), Boolean)\n      // splice the updated existingversions into travisymllines\n      travisYMLLines.splice(existingVersions.startIndex + 1, existingVersions.endIndex - existingVersions.startIndex, updatedVersionsArray)\n      // has an array in an array, needs to be flattened\n      travisYMLLines = _.flatten(travisYMLLines)\n    }\n  }\n  return travisYMLLines.join('\\n')\n}", "code_tokens": ["function", "(", "travisYML", ",", "newVersion", ",", "newCodeName", ",", "existingVersions", ")", "{", "// Should only remove the old version if it is actually present in any form", "if", "(", "existingVersions", ".", "versions", ".", "length", "===", "0", ")", "return", "travisYML", "const", "nodeVersionIndex", "=", "getNodeVersionIndex", "(", "existingVersions", ".", "versions", ",", "newVersion", ",", "newCodeName", ",", "true", ")", "let", "travisYMLLines", "=", "travisYML", ".", "split", "(", "'\\n'", ")", "// We only need to do something if the old version is present", "if", "(", "nodeVersionIndex", "!==", "-", "1", ")", "{", "// If it\u2019s the only version we don\u2019t want to remove it", "if", "(", "existingVersions", ".", "versions", ".", "length", "!==", "1", ")", "{", "// Multiple node versions were defined in array format", "// set lines we want to remove to undefined in existingVersion.versions and filter them out afterwards", "const", "updatedVersionsArray", "=", "_", ".", "filter", "(", "existingVersions", ".", "versions", ".", "map", "(", "(", "version", ")", "=>", "{", "return", "hasNodeVersion", "(", "version", ",", "newVersion", ",", "newCodeName", ",", "true", ")", "?", "undefined", ":", "version", "}", ")", ",", "Boolean", ")", "// splice the updated existingversions into travisymllines", "travisYMLLines", ".", "splice", "(", "existingVersions", ".", "startIndex", "+", "1", ",", "existingVersions", ".", "endIndex", "-", "existingVersions", ".", "startIndex", ",", "updatedVersionsArray", ")", "// has an array in an array, needs to be flattened", "travisYMLLines", "=", "_", ".", "flatten", "(", "travisYMLLines", ")", "}", "}", "return", "travisYMLLines", ".", "join", "(", "'\\n'", ")", "}"], "docstring": "existingVersions is the output of getNodeVersionsFromTravisYML", "docstring_tokens": ["existingVersions", "is", "the", "output", "of", "getNodeVersionsFromTravisYML"], "sha": "7ff179ce7b3381f8be7d52003e2741a700964284", "url": "https://github.com/greenkeeperio/greenkeeper/blob/7ff179ce7b3381f8be7d52003e2741a700964284/utils/utils.js#L278-L299", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/Component.js", "func_name": "", "original_string": "function(width, height) {\n        if (width != undefined) {\n            this.setWidth(width);\n        }\n        if (height != undefined) {\n            this.setHeight(height);\n        }\n    }", "language": "javascript", "code": "function(width, height) {\n        if (width != undefined) {\n            this.setWidth(width);\n        }\n        if (height != undefined) {\n            this.setHeight(height);\n        }\n    }", "code_tokens": ["function", "(", "width", ",", "height", ")", "{", "if", "(", "width", "!=", "undefined", ")", "{", "this", ".", "setWidth", "(", "width", ")", ";", "}", "if", "(", "height", "!=", "undefined", ")", "{", "this", ".", "setHeight", "(", "height", ")", ";", "}", "}"], "docstring": "Sets the size of the Component.\n@param {Number} width The new width for the Component.\n@param {Number} height The new height for the Component.", "docstring_tokens": ["Sets", "the", "size", "of", "the", "Component", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/Component.js#L2327-L2334", "partition": "test"}
{"repo": "AssemblyScript/binaryen.js", "path": "scripts/build.js", "func_name": "compileWasm", "original_string": "function compileWasm(options) {\n  run(\"python\", [\n    path.join(emscriptenDirectory, \"em++\"),\n    \"shared.bc\"\n  ].concat(commonOptions).concat([\n    \"--post-js\", options.post,\n    \"--closure\", \"1\",\n    \"-s\", \"EXPORTED_FUNCTIONS=[\" + exportedFunctionsArg + \"]\",\n    \"-s\", \"ALLOW_MEMORY_GROWTH=1\",\n    \"-s\", \"BINARYEN=1\",\n    \"-s\", \"BINARYEN_METHOD=\\\"native-wasm\\\"\",\n    \"-s\", \"MODULARIZE_INSTANCE=1\",\n    \"-s\", \"EXPORT_NAME=\\\"Binaryen\\\"\",\n    \"-o\", options.out,\n    \"-Oz\"\n  ]));\n}", "language": "javascript", "code": "function compileWasm(options) {\n  run(\"python\", [\n    path.join(emscriptenDirectory, \"em++\"),\n    \"shared.bc\"\n  ].concat(commonOptions).concat([\n    \"--post-js\", options.post,\n    \"--closure\", \"1\",\n    \"-s\", \"EXPORTED_FUNCTIONS=[\" + exportedFunctionsArg + \"]\",\n    \"-s\", \"ALLOW_MEMORY_GROWTH=1\",\n    \"-s\", \"BINARYEN=1\",\n    \"-s\", \"BINARYEN_METHOD=\\\"native-wasm\\\"\",\n    \"-s\", \"MODULARIZE_INSTANCE=1\",\n    \"-s\", \"EXPORT_NAME=\\\"Binaryen\\\"\",\n    \"-o\", options.out,\n    \"-Oz\"\n  ]));\n}", "code_tokens": ["function", "compileWasm", "(", "options", ")", "{", "run", "(", "\"python\"", ",", "[", "path", ".", "join", "(", "emscriptenDirectory", ",", "\"em++\"", ")", ",", "\"shared.bc\"", "]", ".", "concat", "(", "commonOptions", ")", ".", "concat", "(", "[", "\"--post-js\"", ",", "options", ".", "post", ",", "\"--closure\"", ",", "\"1\"", ",", "\"-s\"", ",", "\"EXPORTED_FUNCTIONS=[\"", "+", "exportedFunctionsArg", "+", "\"]\"", ",", "\"-s\"", ",", "\"ALLOW_MEMORY_GROWTH=1\"", ",", "\"-s\"", ",", "\"BINARYEN=1\"", ",", "\"-s\"", ",", "\"BINARYEN_METHOD=\\\"native-wasm\\\"\"", ",", "\"-s\"", ",", "\"MODULARIZE_INSTANCE=1\"", ",", "\"-s\"", ",", "\"EXPORT_NAME=\\\"Binaryen\\\"\"", ",", "\"-o\"", ",", "options", ".", "out", ",", "\"-Oz\"", "]", ")", ")", ";", "}"], "docstring": "Compiles the WebAssembly target.", "docstring_tokens": ["Compiles", "the", "WebAssembly", "target", "."], "sha": "43effe71e5bf6488752a468e295b94ba6ecbf571", "url": "https://github.com/AssemblyScript/binaryen.js/blob/43effe71e5bf6488752a468e295b94ba6ecbf571/scripts/build.js#L110-L126", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/plain-precompiled-build.js", "func_name": "acceptKey", "original_string": "function acceptKey(node, name) {\n\t    var value = this.accept(node[name]);\n\t    if (this.mutating) {\n\t      // Hacky sanity check: This may have a few false positives for type for the helper\n\t      // methods but will generally do the right thing without a lot of overhead.\n\t      if (value && !Visitor.prototype[value.type]) {\n\t        throw new _exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n\t      }\n\t      node[name] = value;\n\t    }\n\t  }", "language": "javascript", "code": "function acceptKey(node, name) {\n\t    var value = this.accept(node[name]);\n\t    if (this.mutating) {\n\t      // Hacky sanity check: This may have a few false positives for type for the helper\n\t      // methods but will generally do the right thing without a lot of overhead.\n\t      if (value && !Visitor.prototype[value.type]) {\n\t        throw new _exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n\t      }\n\t      node[name] = value;\n\t    }\n\t  }", "code_tokens": ["function", "acceptKey", "(", "node", ",", "name", ")", "{", "var", "value", "=", "this", ".", "accept", "(", "node", "[", "name", "]", ")", ";", "if", "(", "this", ".", "mutating", ")", "{", "// Hacky sanity check: This may have a few false positives for type for the helper", "// methods but will generally do the right thing without a lot of overhead.", "if", "(", "value", "&&", "!", "Visitor", ".", "prototype", "[", "value", ".", "type", "]", ")", "{", "throw", "new", "_exception2", "[", "'default'", "]", "(", "'Unexpected node type \"'", "+", "value", ".", "type", "+", "'\" found when accepting '", "+", "name", "+", "' on '", "+", "node", ".", "type", ")", ";", "}", "node", "[", "name", "]", "=", "value", ";", "}", "}"], "docstring": "Visits a given value. If mutating, will replace the value if necessary.", "docstring_tokens": ["Visits", "a", "given", "value", ".", "If", "mutating", "will", "replace", "the", "value", "if", "necessary", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/plain-precompiled-build.js#L18561-L18571", "partition": "test"}
{"repo": "bytespider/OAuthRequest", "path": "lib/Request.js", "func_name": "encode", "original_string": "function encode(string) {\n    function hex(code) {\n        var hex_code = code.toString(16).toUpperCase();\n        if (hex_code.length < 2) {\n            hex_code = 0 + hex_code;\n        }\n        return '%' + hex_code;\n    }\n\n    string = string + '';\n    var reserved_chars = /[ :\\/?#\\[\\]@!$&'()*+,;=<>\"{}|\\\\`\\^%\\r\\n\\u0080-\\uffff]/;\n    var str_len = string.length;\n    var i;\n    var string_arr = string.split('');\n    var c;\n\n    for (i = 0; i < str_len; i += 1) {\n        if (c = string_arr[i].match(reserved_chars)) {\n            c = c[0].charCodeAt(0);\n\n            if (c < 128) {\n                string_arr[i] = hex(c);\n            } else if (c < 2048) {\n                string_arr[i] = hex(192 + (c >> 6)) + hex(128 + (c & 63));\n            } else if (c < 65536) {\n                string_arr[i] = hex(224 + (c >> 12)) + hex(128 + ((c >> 6) & 63)) + hex(128 + (c & 63));\n            } else if (c < 2097152) {\n                string_arr[i] = hex(240 + (c >> 18)) + hex(128 + ((c >> 12) & 63)) + hex(128 + ((c >> 6) & 63)) + hex(128 + (c & 63));\n            }\n        }\n    }\n\n    return string_arr.join('');\n}", "language": "javascript", "code": "function encode(string) {\n    function hex(code) {\n        var hex_code = code.toString(16).toUpperCase();\n        if (hex_code.length < 2) {\n            hex_code = 0 + hex_code;\n        }\n        return '%' + hex_code;\n    }\n\n    string = string + '';\n    var reserved_chars = /[ :\\/?#\\[\\]@!$&'()*+,;=<>\"{}|\\\\`\\^%\\r\\n\\u0080-\\uffff]/;\n    var str_len = string.length;\n    var i;\n    var string_arr = string.split('');\n    var c;\n\n    for (i = 0; i < str_len; i += 1) {\n        if (c = string_arr[i].match(reserved_chars)) {\n            c = c[0].charCodeAt(0);\n\n            if (c < 128) {\n                string_arr[i] = hex(c);\n            } else if (c < 2048) {\n                string_arr[i] = hex(192 + (c >> 6)) + hex(128 + (c & 63));\n            } else if (c < 65536) {\n                string_arr[i] = hex(224 + (c >> 12)) + hex(128 + ((c >> 6) & 63)) + hex(128 + (c & 63));\n            } else if (c < 2097152) {\n                string_arr[i] = hex(240 + (c >> 18)) + hex(128 + ((c >> 12) & 63)) + hex(128 + ((c >> 6) & 63)) + hex(128 + (c & 63));\n            }\n        }\n    }\n\n    return string_arr.join('');\n}", "code_tokens": ["function", "encode", "(", "string", ")", "{", "function", "hex", "(", "code", ")", "{", "var", "hex_code", "=", "code", ".", "toString", "(", "16", ")", ".", "toUpperCase", "(", ")", ";", "if", "(", "hex_code", ".", "length", "<", "2", ")", "{", "hex_code", "=", "0", "+", "hex_code", ";", "}", "return", "'%'", "+", "hex_code", ";", "}", "string", "=", "string", "+", "''", ";", "var", "reserved_chars", "=", "/", "[ :\\/?#\\[\\]@!$&'()*+,;=<>\"{}|\\\\`\\^%\\r\\n\\u0080-\\uffff]", "/", ";", "var", "str_len", "=", "string", ".", "length", ";", "var", "i", ";", "var", "string_arr", "=", "string", ".", "split", "(", "''", ")", ";", "var", "c", ";", "for", "(", "i", "=", "0", ";", "i", "<", "str_len", ";", "i", "+=", "1", ")", "{", "if", "(", "c", "=", "string_arr", "[", "i", "]", ".", "match", "(", "reserved_chars", ")", ")", "{", "c", "=", "c", "[", "0", "]", ".", "charCodeAt", "(", "0", ")", ";", "if", "(", "c", "<", "128", ")", "{", "string_arr", "[", "i", "]", "=", "hex", "(", "c", ")", ";", "}", "else", "if", "(", "c", "<", "2048", ")", "{", "string_arr", "[", "i", "]", "=", "hex", "(", "192", "+", "(", "c", ">>", "6", ")", ")", "+", "hex", "(", "128", "+", "(", "c", "&", "63", ")", ")", ";", "}", "else", "if", "(", "c", "<", "65536", ")", "{", "string_arr", "[", "i", "]", "=", "hex", "(", "224", "+", "(", "c", ">>", "12", ")", ")", "+", "hex", "(", "128", "+", "(", "(", "c", ">>", "6", ")", "&", "63", ")", ")", "+", "hex", "(", "128", "+", "(", "c", "&", "63", ")", ")", ";", "}", "else", "if", "(", "c", "<", "2097152", ")", "{", "string_arr", "[", "i", "]", "=", "hex", "(", "240", "+", "(", "c", ">>", "18", ")", ")", "+", "hex", "(", "128", "+", "(", "(", "c", ">>", "12", ")", "&", "63", ")", ")", "+", "hex", "(", "128", "+", "(", "(", "c", ">>", "6", ")", "&", "63", ")", ")", "+", "hex", "(", "128", "+", "(", "c", "&", "63", ")", ")", ";", "}", "}", "}", "return", "string_arr", ".", "join", "(", "''", ")", ";", "}"], "docstring": "rfc3986 compatable encode of a string\n\n@param {String} string", "docstring_tokens": ["rfc3986", "compatable", "encode", "of", "a", "string"], "sha": "0968d1d0a5702ba21feee52a959bfaceb5fa2ad0", "url": "https://github.com/bytespider/OAuthRequest/blob/0968d1d0a5702ba21feee52a959bfaceb5fa2ad0/lib/Request.js#L20-L53", "partition": "test"}
{"repo": "Raynos/graphics", "path": "lib/json-format.js", "func_name": "", "original_string": "function(error, data, uri) {\n        // var output = '<div id=\"error\">' +\n        //    this.stringbundle.GetStringFromName('errorParsing') + '</div>';\n        // output += '<h1>' +\n        //    this.stringbundle.GetStringFromName('docContents') + ':</h1>';\n        var output = '<div id=\"error\">Error parsing JSON: ' +\n        error.message+'</div>'\n        output += '<h1>'+error.stack+':</h1>';\n        output += '<div id=\"jsonview\">' + this.htmlEncode(data) + '</div>';\n        return this.toHTML(output, uri + ' - Error');\n    }", "language": "javascript", "code": "function(error, data, uri) {\n        // var output = '<div id=\"error\">' +\n        //    this.stringbundle.GetStringFromName('errorParsing') + '</div>';\n        // output += '<h1>' +\n        //    this.stringbundle.GetStringFromName('docContents') + ':</h1>';\n        var output = '<div id=\"error\">Error parsing JSON: ' +\n        error.message+'</div>'\n        output += '<h1>'+error.stack+':</h1>';\n        output += '<div id=\"jsonview\">' + this.htmlEncode(data) + '</div>';\n        return this.toHTML(output, uri + ' - Error');\n    }", "code_tokens": ["function", "(", "error", ",", "data", ",", "uri", ")", "{", "// var output = '<div id=\"error\">' +", "//    this.stringbundle.GetStringFromName('errorParsing') + '</div>';", "// output += '<h1>' +", "//    this.stringbundle.GetStringFromName('docContents') + ':</h1>';", "var", "output", "=", "'<div id=\"error\">Error parsing JSON: '", "+", "error", ".", "message", "+", "'</div>'", "output", "+=", "'<h1>'", "+", "error", ".", "stack", "+", "':</h1>'", ";", "output", "+=", "'<div id=\"jsonview\">'", "+", "this", ".", "htmlEncode", "(", "data", ")", "+", "'</div>'", ";", "return", "this", ".", "toHTML", "(", "output", ",", "uri", "+", "' - Error'", ")", ";", "}"], "docstring": "Produce an error document for when parsing fails.", "docstring_tokens": ["Produce", "an", "error", "document", "for", "when", "parsing", "fails", "."], "sha": "6c156db7419c9f02b22d277c0579432c7f261e68", "url": "https://github.com/Raynos/graphics/blob/6c156db7419c9f02b22d277c0579432c7f261e68/lib/json-format.js#L106-L116", "partition": "test"}
{"repo": "dataminr/react-components", "path": "src/js/table/TableActions.js", "func_name": "", "original_string": "function(id, definition, dataFormatter, filters) {\n        AppDispatcher.dispatchAction({\n            actionType: this.actionTypes.REQUEST_DATA,\n            component: 'Table',\n            id: id,\n            data: {\n                definition: definition,\n                dataFormatter: dataFormatter,\n                filters: filters\n            }\n        });\n    }", "language": "javascript", "code": "function(id, definition, dataFormatter, filters) {\n        AppDispatcher.dispatchAction({\n            actionType: this.actionTypes.REQUEST_DATA,\n            component: 'Table',\n            id: id,\n            data: {\n                definition: definition,\n                dataFormatter: dataFormatter,\n                filters: filters\n            }\n        });\n    }", "code_tokens": ["function", "(", "id", ",", "definition", ",", "dataFormatter", ",", "filters", ")", "{", "AppDispatcher", ".", "dispatchAction", "(", "{", "actionType", ":", "this", ".", "actionTypes", ".", "REQUEST_DATA", ",", "component", ":", "'Table'", ",", "id", ":", "id", ",", "data", ":", "{", "definition", ":", "definition", ",", "dataFormatter", ":", "dataFormatter", ",", "filters", ":", "filters", "}", "}", ")", ";", "}"], "docstring": "Action for populating table data. Used both for initial and subsequent loads.\n@param {String} id - Unique identifier for the Table component.\n@param {Object} definition - A configuration object for the Table.\n@param {Function} dataFormatter - A function that will allow for post processing of data from the server.\n@param {Object} filters - The query string params to be sent with any data requests to the server.", "docstring_tokens": ["Action", "for", "populating", "table", "data", ".", "Used", "both", "for", "initial", "and", "subsequent", "loads", "."], "sha": "0aa29ed8562ee35fd8e682a5052ac979cd409de7", "url": "https://github.com/dataminr/react-components/blob/0aa29ed8562ee35fd8e682a5052ac979cd409de7/src/js/table/TableActions.js#L22-L33", "partition": "test"}
{"repo": "intelligo-systems/intelligo.js", "path": "dist/multilabel/Homer.js", "func_name": "", "original_string": "function(sample, splitLabels, treeNode) {\n\t\tvar superlabels = {}; // the first parts of each of the splitLabels\n\t\tvar mapSuperlabelToRest = {};   // each value is a list of continuations of the key. \n\t\tfor (var i in splitLabels) {\n\t\t\tvar splitLabel = splitLabels[i];\n\t\t\tvar superlabel = splitLabel[0];\n\t\t\tsuperlabels[superlabel] = true;\n\t\t\tif (splitLabel.length>1) {\n\t\t\t\tif (!mapSuperlabelToRest[superlabel]) \n\t\t\t\t\tmapSuperlabelToRest[superlabel] = [];\n\t\t\t\tmapSuperlabelToRest[superlabel].push(splitLabel.slice(1));\n\t\t\t}\n\t\t}\n\n\t\ttreeNode.superlabelClassifier.trainOnline(sample, Object.keys(superlabels));\n\t\tfor (var superlabel in mapSuperlabelToRest) {\n\t\t\tif (!(superlabel in treeNode.mapSuperlabelToBranch)) {\n\t\t\t\ttreeNode.mapSuperlabelToBranch[superlabel] = {\n\t\t\t\t\tsuperlabelClassifier: this.newMultilabelClassifier(),\n\t\t\t\t\tmapSuperlabelToBranch: {}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.trainOnlineRecursive(sample, mapSuperlabelToRest[superlabel], treeNode.mapSuperlabelToBranch[superlabel]);\n\t\t}\n\t}", "language": "javascript", "code": "function(sample, splitLabels, treeNode) {\n\t\tvar superlabels = {}; // the first parts of each of the splitLabels\n\t\tvar mapSuperlabelToRest = {};   // each value is a list of continuations of the key. \n\t\tfor (var i in splitLabels) {\n\t\t\tvar splitLabel = splitLabels[i];\n\t\t\tvar superlabel = splitLabel[0];\n\t\t\tsuperlabels[superlabel] = true;\n\t\t\tif (splitLabel.length>1) {\n\t\t\t\tif (!mapSuperlabelToRest[superlabel]) \n\t\t\t\t\tmapSuperlabelToRest[superlabel] = [];\n\t\t\t\tmapSuperlabelToRest[superlabel].push(splitLabel.slice(1));\n\t\t\t}\n\t\t}\n\n\t\ttreeNode.superlabelClassifier.trainOnline(sample, Object.keys(superlabels));\n\t\tfor (var superlabel in mapSuperlabelToRest) {\n\t\t\tif (!(superlabel in treeNode.mapSuperlabelToBranch)) {\n\t\t\t\ttreeNode.mapSuperlabelToBranch[superlabel] = {\n\t\t\t\t\tsuperlabelClassifier: this.newMultilabelClassifier(),\n\t\t\t\t\tmapSuperlabelToBranch: {}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.trainOnlineRecursive(sample, mapSuperlabelToRest[superlabel], treeNode.mapSuperlabelToBranch[superlabel]);\n\t\t}\n\t}", "code_tokens": ["function", "(", "sample", ",", "splitLabels", ",", "treeNode", ")", "{", "var", "superlabels", "=", "{", "}", ";", "// the first parts of each of the splitLabels", "var", "mapSuperlabelToRest", "=", "{", "}", ";", "// each value is a list of continuations of the key. ", "for", "(", "var", "i", "in", "splitLabels", ")", "{", "var", "splitLabel", "=", "splitLabels", "[", "i", "]", ";", "var", "superlabel", "=", "splitLabel", "[", "0", "]", ";", "superlabels", "[", "superlabel", "]", "=", "true", ";", "if", "(", "splitLabel", ".", "length", ">", "1", ")", "{", "if", "(", "!", "mapSuperlabelToRest", "[", "superlabel", "]", ")", "mapSuperlabelToRest", "[", "superlabel", "]", "=", "[", "]", ";", "mapSuperlabelToRest", "[", "superlabel", "]", ".", "push", "(", "splitLabel", ".", "slice", "(", "1", ")", ")", ";", "}", "}", "treeNode", ".", "superlabelClassifier", ".", "trainOnline", "(", "sample", ",", "Object", ".", "keys", "(", "superlabels", ")", ")", ";", "for", "(", "var", "superlabel", "in", "mapSuperlabelToRest", ")", "{", "if", "(", "!", "(", "superlabel", "in", "treeNode", ".", "mapSuperlabelToBranch", ")", ")", "{", "treeNode", ".", "mapSuperlabelToBranch", "[", "superlabel", "]", "=", "{", "superlabelClassifier", ":", "this", ".", "newMultilabelClassifier", "(", ")", ",", "mapSuperlabelToBranch", ":", "{", "}", "}", "}", "this", ".", "trainOnlineRecursive", "(", "sample", ",", "mapSuperlabelToRest", "[", "superlabel", "]", ",", "treeNode", ".", "mapSuperlabelToBranch", "[", "superlabel", "]", ")", ";", "}", "}"], "docstring": "Recursive internal subroutine of trainOnline.\n@param splitLabels an array of arrays: each internal array represents the parts of a single label.", "docstring_tokens": ["Recursive", "internal", "subroutine", "of", "trainOnline", "."], "sha": "9e75d48214fb41d346462f5d886bd92cc9956df6", "url": "https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/multilabel/Homer.js#L69-L93", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(type, id) {\n    var url = [],\n        host = get(this, 'host'),\n        prefix = this.urlPrefix();\n\n    if (type) { url.push(this.pathForType(type)); }\n    if (id) { url.push(id); }\n\n    if (prefix) { url.unshift(prefix); }\n\n    url = url.join('/');\n    if (!host && url) { url = '/' + url; }\n\n    return url;\n  }", "language": "javascript", "code": "function(type, id) {\n    var url = [],\n        host = get(this, 'host'),\n        prefix = this.urlPrefix();\n\n    if (type) { url.push(this.pathForType(type)); }\n    if (id) { url.push(id); }\n\n    if (prefix) { url.unshift(prefix); }\n\n    url = url.join('/');\n    if (!host && url) { url = '/' + url; }\n\n    return url;\n  }", "code_tokens": ["function", "(", "type", ",", "id", ")", "{", "var", "url", "=", "[", "]", ",", "host", "=", "get", "(", "this", ",", "'host'", ")", ",", "prefix", "=", "this", ".", "urlPrefix", "(", ")", ";", "if", "(", "type", ")", "{", "url", ".", "push", "(", "this", ".", "pathForType", "(", "type", ")", ")", ";", "}", "if", "(", "id", ")", "{", "url", ".", "push", "(", "id", ")", ";", "}", "if", "(", "prefix", ")", "{", "url", ".", "unshift", "(", "prefix", ")", ";", "}", "url", "=", "url", ".", "join", "(", "'/'", ")", ";", "if", "(", "!", "host", "&&", "url", ")", "{", "url", "=", "'/'", "+", "url", ";", "}", "return", "url", ";", "}"], "docstring": "Builds a URL for a given type and optional ID.\n\nBy default, it pluralizes the type's name (for example, 'post'\nbecomes 'posts' and 'person' becomes 'people'). To override the\npluralization see [pathForType](#method_pathForType).\n\nIf an ID is specified, it adds the ID to the path generated\nfor the type, separated by a `/`.\n\n@method buildURL\n@param {String} type\n@param {String} id\n@returns {String} url", "docstring_tokens": ["Builds", "a", "URL", "for", "a", "given", "type", "and", "optional", "ID", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L9429-L9443", "partition": "test"}
{"repo": "evanmoran/oj", "path": "oj.js", "func_name": "_jqGetValue", "original_string": "function _jqGetValue($el, args){\n    var el = $el[0],\n      child = el.firstChild\n\n    // Return the instance if the element has an oj instance\n    if (oj.isOJInstance(_getInstanceOnElement(el)))\n      return _getInstanceOnElement(el)\n\n    // Parse the text to turn it into bool, number, or string\n    else if (oj.isDOMText(child))\n      return oj.parse(child.nodeValue)\n\n    // Return the first child otherwise as an oj instance or child element\n    else if (oj.isDOMElement(child))\n      return _d(_getInstanceOnElement(child), child)\n  }", "language": "javascript", "code": "function _jqGetValue($el, args){\n    var el = $el[0],\n      child = el.firstChild\n\n    // Return the instance if the element has an oj instance\n    if (oj.isOJInstance(_getInstanceOnElement(el)))\n      return _getInstanceOnElement(el)\n\n    // Parse the text to turn it into bool, number, or string\n    else if (oj.isDOMText(child))\n      return oj.parse(child.nodeValue)\n\n    // Return the first child otherwise as an oj instance or child element\n    else if (oj.isDOMElement(child))\n      return _d(_getInstanceOnElement(child), child)\n  }", "code_tokens": ["function", "_jqGetValue", "(", "$el", ",", "args", ")", "{", "var", "el", "=", "$el", "[", "0", "]", ",", "child", "=", "el", ".", "firstChild", "// Return the instance if the element has an oj instance", "if", "(", "oj", ".", "isOJInstance", "(", "_getInstanceOnElement", "(", "el", ")", ")", ")", "return", "_getInstanceOnElement", "(", "el", ")", "// Parse the text to turn it into bool, number, or string", "else", "if", "(", "oj", ".", "isDOMText", "(", "child", ")", ")", "return", "oj", ".", "parse", "(", "child", ".", "nodeValue", ")", "// Return the first child otherwise as an oj instance or child element", "else", "if", "(", "oj", ".", "isDOMElement", "(", "child", ")", ")", "return", "_d", "(", "_getInstanceOnElement", "(", "child", ")", ",", "child", ")", "}"], "docstring": "Helper method that abstracts getting oj values", "docstring_tokens": ["Helper", "method", "that", "abstracts", "getting", "oj", "values"], "sha": "7f05880e4a4572fd67ffb0f55223f66d8ea4e68d", "url": "https://github.com/evanmoran/oj/blob/7f05880e4a4572fd67ffb0f55223f66d8ea4e68d/oj.js#L3027-L3042", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "ArrayOperationMatch", "original_string": "function ArrayOperationMatch(operation, index, split, rangeStart) {\n  this.operation = operation;\n  this.index = index;\n  this.split = split;\n  this.rangeStart = rangeStart;\n}", "language": "javascript", "code": "function ArrayOperationMatch(operation, index, split, rangeStart) {\n  this.operation = operation;\n  this.index = index;\n  this.split = split;\n  this.rangeStart = rangeStart;\n}", "code_tokens": ["function", "ArrayOperationMatch", "(", "operation", ",", "index", ",", "split", ",", "rangeStart", ")", "{", "this", ".", "operation", "=", "operation", ";", "this", ".", "index", "=", "index", ";", "this", ".", "split", "=", "split", ";", "this", ".", "rangeStart", "=", "rangeStart", ";", "}"], "docstring": "Internal data structure used to include information when looking up operations\nby item index.\n\n@method ArrayOperationMatch\n@private\n@param {ArrayOperation} operation\n@param {number} index The index of `operation` in the array of operations.\n@param {boolean} split Whether or not the item index searched for would\nrequire a split for a new operation type.\n@param {number} rangeStart The index of the first item in the operation,\nwith respect to the tracked array.  The index of the last item can be computed\nfrom `rangeStart` and `operation.count`.", "docstring_tokens": ["Internal", "data", "structure", "used", "to", "include", "information", "when", "looking", "up", "operations", "by", "item", "index", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L19232-L19237", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "", "original_string": "function () {\n      var timeSpan = Date.now() - this._lastProgressCallback;\n      if (!timeSpan) {\n        return ;\n      }\n      var smoothingFactor = this.flowObj.opts.speedSmoothingFactor;\n      var uploaded = this.sizeUploaded();\n      // Prevent negative upload speed after file upload resume\n      this.currentSpeed = Math.max((uploaded - this._prevUploadedSize) / timeSpan * 1000, 0);\n      this.averageSpeed = smoothingFactor * this.currentSpeed + (1 - smoothingFactor) * this.averageSpeed;\n      this._prevUploadedSize = uploaded;\n    }", "language": "javascript", "code": "function () {\n      var timeSpan = Date.now() - this._lastProgressCallback;\n      if (!timeSpan) {\n        return ;\n      }\n      var smoothingFactor = this.flowObj.opts.speedSmoothingFactor;\n      var uploaded = this.sizeUploaded();\n      // Prevent negative upload speed after file upload resume\n      this.currentSpeed = Math.max((uploaded - this._prevUploadedSize) / timeSpan * 1000, 0);\n      this.averageSpeed = smoothingFactor * this.currentSpeed + (1 - smoothingFactor) * this.averageSpeed;\n      this._prevUploadedSize = uploaded;\n    }", "code_tokens": ["function", "(", ")", "{", "var", "timeSpan", "=", "Date", ".", "now", "(", ")", "-", "this", ".", "_lastProgressCallback", ";", "if", "(", "!", "timeSpan", ")", "{", "return", ";", "}", "var", "smoothingFactor", "=", "this", ".", "flowObj", ".", "opts", ".", "speedSmoothingFactor", ";", "var", "uploaded", "=", "this", ".", "sizeUploaded", "(", ")", ";", "// Prevent negative upload speed after file upload resume", "this", ".", "currentSpeed", "=", "Math", ".", "max", "(", "(", "uploaded", "-", "this", ".", "_prevUploadedSize", ")", "/", "timeSpan", "*", "1000", ",", "0", ")", ";", "this", ".", "averageSpeed", "=", "smoothingFactor", "*", "this", ".", "currentSpeed", "+", "(", "1", "-", "smoothingFactor", ")", "*", "this", ".", "averageSpeed", ";", "this", ".", "_prevUploadedSize", "=", "uploaded", ";", "}"], "docstring": "Update speed parameters\n@link http://stackoverflow.com/questions/2779600/how-to-estimate-download-time-remaining-accurately\n@function", "docstring_tokens": ["Update", "speed", "parameters"], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L813-L824", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "", "original_string": "function () {\n      var preprocess = this.flowObj.opts.preprocess;\n      var read = this.flowObj.opts.readFileFn;\n      if (typeof preprocess === 'function') {\n        switch (this.preprocessState) {\n          case 0:\n            this.preprocessState = 1;\n            preprocess(this);\n            return;\n          case 1:\n            return;\n        }\n      }\n      switch (this.readState) {\n        case 0:\n          this.readState = 1;\n          read(this.fileObj, this.startByte, this.endByte, this.fileObj.file.type, this);\n          return;\n        case 1:\n          return;\n      }\n      if (this.flowObj.opts.testChunks && !this.tested) {\n        this.test();\n        return;\n      }\n\n      this.loaded = 0;\n      this.total = 0;\n      this.pendingRetry = false;\n\n      // Set up request and listen for event\n      this.xhr = new XMLHttpRequest();\n      this.xhr.upload.addEventListener('progress', this.progressHandler, false);\n      this.xhr.addEventListener(\"load\", this.doneHandler, false);\n      this.xhr.addEventListener(\"error\", this.doneHandler, false);\n\n      var uploadMethod = evalOpts(this.flowObj.opts.uploadMethod, this.fileObj, this);\n      var data = this.prepareXhrRequest(uploadMethod, false, this.flowObj.opts.method, this.bytes);\n      this.xhr.send(data);\n    }", "language": "javascript", "code": "function () {\n      var preprocess = this.flowObj.opts.preprocess;\n      var read = this.flowObj.opts.readFileFn;\n      if (typeof preprocess === 'function') {\n        switch (this.preprocessState) {\n          case 0:\n            this.preprocessState = 1;\n            preprocess(this);\n            return;\n          case 1:\n            return;\n        }\n      }\n      switch (this.readState) {\n        case 0:\n          this.readState = 1;\n          read(this.fileObj, this.startByte, this.endByte, this.fileObj.file.type, this);\n          return;\n        case 1:\n          return;\n      }\n      if (this.flowObj.opts.testChunks && !this.tested) {\n        this.test();\n        return;\n      }\n\n      this.loaded = 0;\n      this.total = 0;\n      this.pendingRetry = false;\n\n      // Set up request and listen for event\n      this.xhr = new XMLHttpRequest();\n      this.xhr.upload.addEventListener('progress', this.progressHandler, false);\n      this.xhr.addEventListener(\"load\", this.doneHandler, false);\n      this.xhr.addEventListener(\"error\", this.doneHandler, false);\n\n      var uploadMethod = evalOpts(this.flowObj.opts.uploadMethod, this.fileObj, this);\n      var data = this.prepareXhrRequest(uploadMethod, false, this.flowObj.opts.method, this.bytes);\n      this.xhr.send(data);\n    }", "code_tokens": ["function", "(", ")", "{", "var", "preprocess", "=", "this", ".", "flowObj", ".", "opts", ".", "preprocess", ";", "var", "read", "=", "this", ".", "flowObj", ".", "opts", ".", "readFileFn", ";", "if", "(", "typeof", "preprocess", "===", "'function'", ")", "{", "switch", "(", "this", ".", "preprocessState", ")", "{", "case", "0", ":", "this", ".", "preprocessState", "=", "1", ";", "preprocess", "(", "this", ")", ";", "return", ";", "case", "1", ":", "return", ";", "}", "}", "switch", "(", "this", ".", "readState", ")", "{", "case", "0", ":", "this", ".", "readState", "=", "1", ";", "read", "(", "this", ".", "fileObj", ",", "this", ".", "startByte", ",", "this", ".", "endByte", ",", "this", ".", "fileObj", ".", "file", ".", "type", ",", "this", ")", ";", "return", ";", "case", "1", ":", "return", ";", "}", "if", "(", "this", ".", "flowObj", ".", "opts", ".", "testChunks", "&&", "!", "this", ".", "tested", ")", "{", "this", ".", "test", "(", ")", ";", "return", ";", "}", "this", ".", "loaded", "=", "0", ";", "this", ".", "total", "=", "0", ";", "this", ".", "pendingRetry", "=", "false", ";", "// Set up request and listen for event", "this", ".", "xhr", "=", "new", "XMLHttpRequest", "(", ")", ";", "this", ".", "xhr", ".", "upload", ".", "addEventListener", "(", "'progress'", ",", "this", ".", "progressHandler", ",", "false", ")", ";", "this", ".", "xhr", ".", "addEventListener", "(", "\"load\"", ",", "this", ".", "doneHandler", ",", "false", ")", ";", "this", ".", "xhr", ".", "addEventListener", "(", "\"error\"", ",", "this", ".", "doneHandler", ",", "false", ")", ";", "var", "uploadMethod", "=", "evalOpts", "(", "this", ".", "flowObj", ".", "opts", ".", "uploadMethod", ",", "this", ".", "fileObj", ",", "this", ")", ";", "var", "data", "=", "this", ".", "prepareXhrRequest", "(", "uploadMethod", ",", "false", ",", "this", ".", "flowObj", ".", "opts", ".", "method", ",", "this", ".", "bytes", ")", ";", "this", ".", "xhr", ".", "send", "(", "data", ")", ";", "}"], "docstring": "Uploads the actual data in a POST call\n@function", "docstring_tokens": ["Uploads", "the", "actual", "data", "in", "a", "POST", "call"], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L1337-L1376", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "ReduceComputedProperty", "original_string": "function ReduceComputedProperty(options) {\n  var cp = this;\n\n  this.options = options;\n\n  this._dependentKeys = null;\n  // A map of dependentKey -> [itemProperty, ...] that tracks what properties of\n  // items in the array we must track to update this property.\n  this._itemPropertyKeys = {};\n  this._previousItemPropertyKeys = {};\n\n  this.readOnly();\n  this.cacheable();\n\n  this.recomputeOnce = function(propertyName) {\n    // What we really want to do is coalesce by <cp, propertyName>.\n    // We need a form of `scheduleOnce` that accepts an arbitrary token to\n    // coalesce by, in addition to the target and method.\n    Ember.run.once(this, recompute, propertyName);\n  };\n  var recompute = function(propertyName) {\n    var dependentKeys = cp._dependentKeys,\n        meta = cp._instanceMeta(this, propertyName),\n        callbacks = cp._callbacks();\n\n    reset.call(this, cp, propertyName);\n\n    meta.dependentArraysObserver.suspendArrayObservers(function () {\n      forEach(cp._dependentKeys, function (dependentKey) {\n        Ember.assert(\n          \"dependent array \" + dependentKey + \" must be an `Ember.Array`.  \" +\n          \"If you are not extending arrays, you will need to wrap native arrays with `Ember.A`\",\n          !(Ember.isArray(get(this, dependentKey)) && !Ember.Array.detect(get(this, dependentKey))));\n\n        if (!partiallyRecomputeFor(this, dependentKey)) { return; }\n\n        var dependentArray = get(this, dependentKey),\n            previousDependentArray = meta.dependentArrays[dependentKey];\n\n        if (dependentArray === previousDependentArray) {\n          // The array may be the same, but our item property keys may have\n          // changed, so we set them up again.  We can't easily tell if they've\n          // changed: the array may be the same object, but with different\n          // contents.\n          if (cp._previousItemPropertyKeys[dependentKey]) {\n            delete cp._previousItemPropertyKeys[dependentKey];\n            meta.dependentArraysObserver.setupPropertyObservers(dependentKey, cp._itemPropertyKeys[dependentKey]);\n          }\n        } else {\n          meta.dependentArrays[dependentKey] = dependentArray;\n\n          if (previousDependentArray) {\n            meta.dependentArraysObserver.teardownObservers(previousDependentArray, dependentKey);\n          }\n\n          if (dependentArray) {\n            meta.dependentArraysObserver.setupObservers(dependentArray, dependentKey);\n          }\n        }\n      }, this);\n    }, this);\n\n    forEach(cp._dependentKeys, function(dependentKey) {\n      if (!partiallyRecomputeFor(this, dependentKey)) { return; }\n\n      var dependentArray = get(this, dependentKey);\n      if (dependentArray) {\n        addItems.call(this, dependentArray, callbacks, cp, propertyName, meta);\n      }\n    }, this);\n  };\n\n\n  this.func = function (propertyName) {\n    Ember.assert(\"Computed reduce values require at least one dependent key\", cp._dependentKeys);\n\n    recompute.call(this, propertyName);\n\n    return cp._instanceMeta(this, propertyName).getValue();\n  };\n}", "language": "javascript", "code": "function ReduceComputedProperty(options) {\n  var cp = this;\n\n  this.options = options;\n\n  this._dependentKeys = null;\n  // A map of dependentKey -> [itemProperty, ...] that tracks what properties of\n  // items in the array we must track to update this property.\n  this._itemPropertyKeys = {};\n  this._previousItemPropertyKeys = {};\n\n  this.readOnly();\n  this.cacheable();\n\n  this.recomputeOnce = function(propertyName) {\n    // What we really want to do is coalesce by <cp, propertyName>.\n    // We need a form of `scheduleOnce` that accepts an arbitrary token to\n    // coalesce by, in addition to the target and method.\n    Ember.run.once(this, recompute, propertyName);\n  };\n  var recompute = function(propertyName) {\n    var dependentKeys = cp._dependentKeys,\n        meta = cp._instanceMeta(this, propertyName),\n        callbacks = cp._callbacks();\n\n    reset.call(this, cp, propertyName);\n\n    meta.dependentArraysObserver.suspendArrayObservers(function () {\n      forEach(cp._dependentKeys, function (dependentKey) {\n        Ember.assert(\n          \"dependent array \" + dependentKey + \" must be an `Ember.Array`.  \" +\n          \"If you are not extending arrays, you will need to wrap native arrays with `Ember.A`\",\n          !(Ember.isArray(get(this, dependentKey)) && !Ember.Array.detect(get(this, dependentKey))));\n\n        if (!partiallyRecomputeFor(this, dependentKey)) { return; }\n\n        var dependentArray = get(this, dependentKey),\n            previousDependentArray = meta.dependentArrays[dependentKey];\n\n        if (dependentArray === previousDependentArray) {\n          // The array may be the same, but our item property keys may have\n          // changed, so we set them up again.  We can't easily tell if they've\n          // changed: the array may be the same object, but with different\n          // contents.\n          if (cp._previousItemPropertyKeys[dependentKey]) {\n            delete cp._previousItemPropertyKeys[dependentKey];\n            meta.dependentArraysObserver.setupPropertyObservers(dependentKey, cp._itemPropertyKeys[dependentKey]);\n          }\n        } else {\n          meta.dependentArrays[dependentKey] = dependentArray;\n\n          if (previousDependentArray) {\n            meta.dependentArraysObserver.teardownObservers(previousDependentArray, dependentKey);\n          }\n\n          if (dependentArray) {\n            meta.dependentArraysObserver.setupObservers(dependentArray, dependentKey);\n          }\n        }\n      }, this);\n    }, this);\n\n    forEach(cp._dependentKeys, function(dependentKey) {\n      if (!partiallyRecomputeFor(this, dependentKey)) { return; }\n\n      var dependentArray = get(this, dependentKey);\n      if (dependentArray) {\n        addItems.call(this, dependentArray, callbacks, cp, propertyName, meta);\n      }\n    }, this);\n  };\n\n\n  this.func = function (propertyName) {\n    Ember.assert(\"Computed reduce values require at least one dependent key\", cp._dependentKeys);\n\n    recompute.call(this, propertyName);\n\n    return cp._instanceMeta(this, propertyName).getValue();\n  };\n}", "code_tokens": ["function", "ReduceComputedProperty", "(", "options", ")", "{", "var", "cp", "=", "this", ";", "this", ".", "options", "=", "options", ";", "this", ".", "_dependentKeys", "=", "null", ";", "// A map of dependentKey -> [itemProperty, ...] that tracks what properties of", "// items in the array we must track to update this property.", "this", ".", "_itemPropertyKeys", "=", "{", "}", ";", "this", ".", "_previousItemPropertyKeys", "=", "{", "}", ";", "this", ".", "readOnly", "(", ")", ";", "this", ".", "cacheable", "(", ")", ";", "this", ".", "recomputeOnce", "=", "function", "(", "propertyName", ")", "{", "// What we really want to do is coalesce by <cp, propertyName>.", "// We need a form of `scheduleOnce` that accepts an arbitrary token to", "// coalesce by, in addition to the target and method.", "Ember", ".", "run", ".", "once", "(", "this", ",", "recompute", ",", "propertyName", ")", ";", "}", ";", "var", "recompute", "=", "function", "(", "propertyName", ")", "{", "var", "dependentKeys", "=", "cp", ".", "_dependentKeys", ",", "meta", "=", "cp", ".", "_instanceMeta", "(", "this", ",", "propertyName", ")", ",", "callbacks", "=", "cp", ".", "_callbacks", "(", ")", ";", "reset", ".", "call", "(", "this", ",", "cp", ",", "propertyName", ")", ";", "meta", ".", "dependentArraysObserver", ".", "suspendArrayObservers", "(", "function", "(", ")", "{", "forEach", "(", "cp", ".", "_dependentKeys", ",", "function", "(", "dependentKey", ")", "{", "Ember", ".", "assert", "(", "\"dependent array \"", "+", "dependentKey", "+", "\" must be an `Ember.Array`.  \"", "+", "\"If you are not extending arrays, you will need to wrap native arrays with `Ember.A`\"", ",", "!", "(", "Ember", ".", "isArray", "(", "get", "(", "this", ",", "dependentKey", ")", ")", "&&", "!", "Ember", ".", "Array", ".", "detect", "(", "get", "(", "this", ",", "dependentKey", ")", ")", ")", ")", ";", "if", "(", "!", "partiallyRecomputeFor", "(", "this", ",", "dependentKey", ")", ")", "{", "return", ";", "}", "var", "dependentArray", "=", "get", "(", "this", ",", "dependentKey", ")", ",", "previousDependentArray", "=", "meta", ".", "dependentArrays", "[", "dependentKey", "]", ";", "if", "(", "dependentArray", "===", "previousDependentArray", ")", "{", "// The array may be the same, but our item property keys may have", "// changed, so we set them up again.  We can't easily tell if they've", "// changed: the array may be the same object, but with different", "// contents.", "if", "(", "cp", ".", "_previousItemPropertyKeys", "[", "dependentKey", "]", ")", "{", "delete", "cp", ".", "_previousItemPropertyKeys", "[", "dependentKey", "]", ";", "meta", ".", "dependentArraysObserver", ".", "setupPropertyObservers", "(", "dependentKey", ",", "cp", ".", "_itemPropertyKeys", "[", "dependentKey", "]", ")", ";", "}", "}", "else", "{", "meta", ".", "dependentArrays", "[", "dependentKey", "]", "=", "dependentArray", ";", "if", "(", "previousDependentArray", ")", "{", "meta", ".", "dependentArraysObserver", ".", "teardownObservers", "(", "previousDependentArray", ",", "dependentKey", ")", ";", "}", "if", "(", "dependentArray", ")", "{", "meta", ".", "dependentArraysObserver", ".", "setupObservers", "(", "dependentArray", ",", "dependentKey", ")", ";", "}", "}", "}", ",", "this", ")", ";", "}", ",", "this", ")", ";", "forEach", "(", "cp", ".", "_dependentKeys", ",", "function", "(", "dependentKey", ")", "{", "if", "(", "!", "partiallyRecomputeFor", "(", "this", ",", "dependentKey", ")", ")", "{", "return", ";", "}", "var", "dependentArray", "=", "get", "(", "this", ",", "dependentKey", ")", ";", "if", "(", "dependentArray", ")", "{", "addItems", ".", "call", "(", "this", ",", "dependentArray", ",", "callbacks", ",", "cp", ",", "propertyName", ",", "meta", ")", ";", "}", "}", ",", "this", ")", ";", "}", ";", "this", ".", "func", "=", "function", "(", "propertyName", ")", "{", "Ember", ".", "assert", "(", "\"Computed reduce values require at least one dependent key\"", ",", "cp", ".", "_dependentKeys", ")", ";", "recompute", ".", "call", "(", "this", ",", "propertyName", ")", ";", "return", "cp", ".", "_instanceMeta", "(", "this", ",", "propertyName", ")", ".", "getValue", "(", ")", ";", "}", ";", "}"], "docstring": "A computed property whose dependent keys are arrays and which is updated with\n\"one at a time\" semantics.\n\n@class ReduceComputedProperty\n@namespace Ember\n@extends Ember.ComputedProperty\n@constructor", "docstring_tokens": ["A", "computed", "property", "whose", "dependent", "keys", "are", "arrays", "and", "which", "is", "updated", "with", "one", "at", "a", "time", "semantics", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L15860-L15940", "partition": "test"}
{"repo": "kinchanmaemo/standalone-html", "path": "bin/standalone-html.js", "func_name": "writeFile", "original_string": "function writeFile(resHtml, outputPath) {\n\tfs.writeFile(outputPath, resHtml, function (err) {\n\t\tif (err) {\n\t\t\tconsole.log('');\n\t\t\tconsole.log('File error: ' + err + '. Exit.');\n\t\t} else {\n\t\t\tconsole.log('');\n\t\t\tconsole.log('All done. Exit.'.green);\n\t\t}\n\t});\n}", "language": "javascript", "code": "function writeFile(resHtml, outputPath) {\n\tfs.writeFile(outputPath, resHtml, function (err) {\n\t\tif (err) {\n\t\t\tconsole.log('');\n\t\t\tconsole.log('File error: ' + err + '. Exit.');\n\t\t} else {\n\t\t\tconsole.log('');\n\t\t\tconsole.log('All done. Exit.'.green);\n\t\t}\n\t});\n}", "code_tokens": ["function", "writeFile", "(", "resHtml", ",", "outputPath", ")", "{", "fs", ".", "writeFile", "(", "outputPath", ",", "resHtml", ",", "function", "(", "err", ")", "{", "if", "(", "err", ")", "{", "console", ".", "log", "(", "''", ")", ";", "console", ".", "log", "(", "'File error: '", "+", "err", "+", "'. Exit.'", ")", ";", "}", "else", "{", "console", ".", "log", "(", "''", ")", ";", "console", ".", "log", "(", "'All done. Exit.'", ".", "green", ")", ";", "}", "}", ")", ";", "}"], "docstring": "write result to file", "docstring_tokens": ["write", "result", "to", "file"], "sha": "44826566c100c691c371abafae88df2ae67a7abb", "url": "https://github.com/kinchanmaemo/standalone-html/blob/44826566c100c691c371abafae88df2ae67a7abb/bin/standalone-html.js#L103-L113", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(views, start, removed) {\n    this.propertyWillChange('childViews');\n\n    if (removed > 0) {\n      var changedViews = views.slice(start, start+removed);\n      // transition to preRender before clearing parentView\n      this.currentState.childViewsWillChange(this, views, start, removed);\n      this.initializeViews(changedViews, null, null);\n    }\n  }", "language": "javascript", "code": "function(views, start, removed) {\n    this.propertyWillChange('childViews');\n\n    if (removed > 0) {\n      var changedViews = views.slice(start, start+removed);\n      // transition to preRender before clearing parentView\n      this.currentState.childViewsWillChange(this, views, start, removed);\n      this.initializeViews(changedViews, null, null);\n    }\n  }", "code_tokens": ["function", "(", "views", ",", "start", ",", "removed", ")", "{", "this", ".", "propertyWillChange", "(", "'childViews'", ")", ";", "if", "(", "removed", ">", "0", ")", "{", "var", "changedViews", "=", "views", ".", "slice", "(", "start", ",", "start", "+", "removed", ")", ";", "// transition to preRender before clearing parentView", "this", ".", "currentState", ".", "childViewsWillChange", "(", "this", ",", "views", ",", "start", ",", "removed", ")", ";", "this", ".", "initializeViews", "(", "changedViews", ",", "null", ",", "null", ")", ";", "}", "}"], "docstring": "When a child view is removed, destroy its element so that\nit is removed from the DOM.\n\nThe array observer that triggers this action is set up in the\n`renderToBuffer` method.\n\n@private\n@method childViewsWillChange\n@param {Ember.Array} views the child views array before mutation\n@param {Number} start the start position of the mutation\n@param {Number} removed the number of child views removed", "docstring_tokens": ["When", "a", "child", "view", "is", "removed", "destroy", "its", "element", "so", "that", "it", "is", "removed", "from", "the", "DOM", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L25514-L25523", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "addHierarchicalFacet", "original_string": "function addHierarchicalFacet(hierarchicalFacet) {\n    if (this.isHierarchicalFacet(hierarchicalFacet.name)) {\n      throw new Error(\n        'Cannot declare two hierarchical facets with the same name: `' + hierarchicalFacet.name + '`');\n    }\n\n    return this.setQueryParameters({\n      hierarchicalFacets: this.hierarchicalFacets.concat([hierarchicalFacet])\n    });\n  }", "language": "javascript", "code": "function addHierarchicalFacet(hierarchicalFacet) {\n    if (this.isHierarchicalFacet(hierarchicalFacet.name)) {\n      throw new Error(\n        'Cannot declare two hierarchical facets with the same name: `' + hierarchicalFacet.name + '`');\n    }\n\n    return this.setQueryParameters({\n      hierarchicalFacets: this.hierarchicalFacets.concat([hierarchicalFacet])\n    });\n  }", "code_tokens": ["function", "addHierarchicalFacet", "(", "hierarchicalFacet", ")", "{", "if", "(", "this", ".", "isHierarchicalFacet", "(", "hierarchicalFacet", ".", "name", ")", ")", "{", "throw", "new", "Error", "(", "'Cannot declare two hierarchical facets with the same name: `'", "+", "hierarchicalFacet", ".", "name", "+", "'`'", ")", ";", "}", "return", "this", ".", "setQueryParameters", "(", "{", "hierarchicalFacets", ":", "this", ".", "hierarchicalFacets", ".", "concat", "(", "[", "hierarchicalFacet", "]", ")", "}", ")", ";", "}"], "docstring": "Add a hierarchical facet to the hierarchicalFacets attribute of the helper\nconfiguration.\n@method\n@param {object} hierarchicalFacet hierarchical facet to add\n@return {SearchParameters}\n@throws will throw an error if a hierarchical facet with the same name was already declared", "docstring_tokens": ["Add", "a", "hierarchical", "facet", "to", "the", "hierarchicalFacets", "attribute", "of", "the", "helper", "configuration", "."], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L971-L980", "partition": "test"}
{"repo": "jsdom/webidl-conversions", "path": "lib/index.js", "func_name": "evenRound", "original_string": "function evenRound(x) {\n    // There are four cases for numbers with fractional part being .5:\n    //\n    // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example\n    //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0\n    //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2\n    //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0\n    //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2\n    // (where n is a non-negative integer)\n    //\n    // Branch here for cases 1 and 4\n    if ((x > 0 && (x % 1) === +0.5 && (x & 1) === 0) ||\n        (x < 0 && (x % 1) === -0.5 && (x & 1) === 1)) {\n        return censorNegativeZero(Math.floor(x));\n    }\n\n    return censorNegativeZero(Math.round(x));\n}", "language": "javascript", "code": "function evenRound(x) {\n    // There are four cases for numbers with fractional part being .5:\n    //\n    // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example\n    //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0\n    //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2\n    //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0\n    //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2\n    // (where n is a non-negative integer)\n    //\n    // Branch here for cases 1 and 4\n    if ((x > 0 && (x % 1) === +0.5 && (x & 1) === 0) ||\n        (x < 0 && (x % 1) === -0.5 && (x & 1) === 1)) {\n        return censorNegativeZero(Math.floor(x));\n    }\n\n    return censorNegativeZero(Math.round(x));\n}", "code_tokens": ["function", "evenRound", "(", "x", ")", "{", "// There are four cases for numbers with fractional part being .5:", "//", "// case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example", "//   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0", "//   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2", "//   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0", "//   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2", "// (where n is a non-negative integer)", "//", "// Branch here for cases 1 and 4", "if", "(", "(", "x", ">", "0", "&&", "(", "x", "%", "1", ")", "===", "+", "0.5", "&&", "(", "x", "&", "1", ")", "===", "0", ")", "||", "(", "x", "<", "0", "&&", "(", "x", "%", "1", ")", "===", "-", "0.5", "&&", "(", "x", "&", "1", ")", "===", "1", ")", ")", "{", "return", "censorNegativeZero", "(", "Math", ".", "floor", "(", "x", ")", ")", ";", "}", "return", "censorNegativeZero", "(", "Math", ".", "round", "(", "x", ")", ")", ";", "}"], "docstring": "Round x to the nearest integer, choosing the even integer if it lies halfway between two.", "docstring_tokens": ["Round", "x", "to", "the", "nearest", "integer", "choosing", "the", "even", "integer", "if", "it", "lies", "halfway", "between", "two", "."], "sha": "074b6ec5371edb7f0275625702eda6aecf1c24af", "url": "https://github.com/jsdom/webidl-conversions/blob/074b6ec5371edb7f0275625702eda6aecf1c24af/lib/index.js#L35-L52", "partition": "test"}
{"repo": "GeoXForm/GeoXForm", "path": "src/lib/ogr-cmd.js", "func_name": "create", "original_string": "function create (format, options) {\n  const ogrFormat = ogrFormats[format]\n  // shapefiles cannot be streamed out of ogr2ogr\n  const output = format === 'zip' ? `${options.path || '.'}/${options.name}` : '/vsistdout/'\n  const input = options.input || 'layer.vrt'\n\n  let cmd = ['--config', 'SHAPE_ENCODING', 'UTF-8', '-f', ogrFormat, output, input]\n\n  options.geometry = options.geometry && options.geometry.toUpperCase() || 'NONE'\n  if (format === 'csv') cmd = csvParams(cmd, options)\n  if (format === 'zip') cmd = shapefileParams(cmd, options)\n  if (format === 'georss') cmd = georssParams(cmd, options)\n  return finishOgrParams(cmd)\n}", "language": "javascript", "code": "function create (format, options) {\n  const ogrFormat = ogrFormats[format]\n  // shapefiles cannot be streamed out of ogr2ogr\n  const output = format === 'zip' ? `${options.path || '.'}/${options.name}` : '/vsistdout/'\n  const input = options.input || 'layer.vrt'\n\n  let cmd = ['--config', 'SHAPE_ENCODING', 'UTF-8', '-f', ogrFormat, output, input]\n\n  options.geometry = options.geometry && options.geometry.toUpperCase() || 'NONE'\n  if (format === 'csv') cmd = csvParams(cmd, options)\n  if (format === 'zip') cmd = shapefileParams(cmd, options)\n  if (format === 'georss') cmd = georssParams(cmd, options)\n  return finishOgrParams(cmd)\n}", "code_tokens": ["function", "create", "(", "format", ",", "options", ")", "{", "const", "ogrFormat", "=", "ogrFormats", "[", "format", "]", "// shapefiles cannot be streamed out of ogr2ogr", "const", "output", "=", "format", "===", "'zip'", "?", "`", "${", "options", ".", "path", "||", "'.'", "}", "${", "options", ".", "name", "}", "`", ":", "'/vsistdout/'", "const", "input", "=", "options", ".", "input", "||", "'layer.vrt'", "let", "cmd", "=", "[", "'--config'", ",", "'SHAPE_ENCODING'", ",", "'UTF-8'", ",", "'-f'", ",", "ogrFormat", ",", "output", ",", "input", "]", "options", ".", "geometry", "=", "options", ".", "geometry", "&&", "options", ".", "geometry", ".", "toUpperCase", "(", ")", "||", "'NONE'", "if", "(", "format", "===", "'csv'", ")", "cmd", "=", "csvParams", "(", "cmd", ",", "options", ")", "if", "(", "format", "===", "'zip'", ")", "cmd", "=", "shapefileParams", "(", "cmd", ",", "options", ")", "if", "(", "format", "===", "'georss'", ")", "cmd", "=", "georssParams", "(", "cmd", ",", "options", ")", "return", "finishOgrParams", "(", "cmd", ")", "}"], "docstring": "Gets a set of OGR Parameters for an export\n\n@param {object} options - potentially contains a fields object", "docstring_tokens": ["Gets", "a", "set", "of", "OGR", "Parameters", "for", "an", "export"], "sha": "f5c6274514d432e12ca768309b4108dca911c1dc", "url": "https://github.com/GeoXForm/GeoXForm/blob/f5c6274514d432e12ca768309b4108dca911c1dc/src/lib/ogr-cmd.js#L8-L21", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getSignatureHelpItems", "original_string": "function getSignatureHelpItems(fileName, position) {\n            synchronizeHostData();\n            var sourceFile = getValidSourceFile(fileName);\n            return ts.SignatureHelp.getSignatureHelpItems(program, sourceFile, position, cancellationToken);\n        }", "language": "javascript", "code": "function getSignatureHelpItems(fileName, position) {\n            synchronizeHostData();\n            var sourceFile = getValidSourceFile(fileName);\n            return ts.SignatureHelp.getSignatureHelpItems(program, sourceFile, position, cancellationToken);\n        }", "code_tokens": ["function", "getSignatureHelpItems", "(", "fileName", ",", "position", ")", "{", "synchronizeHostData", "(", ")", ";", "var", "sourceFile", "=", "getValidSourceFile", "(", "fileName", ")", ";", "return", "ts", ".", "SignatureHelp", ".", "getSignatureHelpItems", "(", "program", ",", "sourceFile", ",", "position", ",", "cancellationToken", ")", ";", "}"], "docstring": "Signature help \nThis is a semantic operation.", "docstring_tokens": ["Signature", "help", "This", "is", "a", "semantic", "operation", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L47746-L47750", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( relation ) {\n\t\t\tvar exists = _.any( this._reverseRelations, function( rel ) {\n\t\t\t\treturn _.all( relation || [], function( val, key ) {\n\t\t\t\t\treturn val === rel[ key ];\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif ( !exists && relation.model && relation.type ) {\n\t\t\t\tthis._reverseRelations.push( relation );\n\t\t\t\tthis._addRelation( relation.model, relation );\n\t\t\t\tthis.retroFitRelation( relation );\n\t\t\t}\n\t\t}", "language": "javascript", "code": "function( relation ) {\n\t\t\tvar exists = _.any( this._reverseRelations, function( rel ) {\n\t\t\t\treturn _.all( relation || [], function( val, key ) {\n\t\t\t\t\treturn val === rel[ key ];\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif ( !exists && relation.model && relation.type ) {\n\t\t\t\tthis._reverseRelations.push( relation );\n\t\t\t\tthis._addRelation( relation.model, relation );\n\t\t\t\tthis.retroFitRelation( relation );\n\t\t\t}\n\t\t}", "code_tokens": ["function", "(", "relation", ")", "{", "var", "exists", "=", "_", ".", "any", "(", "this", ".", "_reverseRelations", ",", "function", "(", "rel", ")", "{", "return", "_", ".", "all", "(", "relation", "||", "[", "]", ",", "function", "(", "val", ",", "key", ")", "{", "return", "val", "===", "rel", "[", "key", "]", ";", "}", ")", ";", "}", ")", ";", "if", "(", "!", "exists", "&&", "relation", ".", "model", "&&", "relation", ".", "type", ")", "{", "this", ".", "_reverseRelations", ".", "push", "(", "relation", ")", ";", "this", ".", "_addRelation", "(", "relation", ".", "model", ",", "relation", ")", ";", "this", ".", "retroFitRelation", "(", "relation", ")", ";", "}", "}"], "docstring": "Add a reverse relation. Is added to the 'relations' property on model's prototype, and to\nexisting instances of 'model' in the store as well.\n@param {Object} relation\n@param {Backbone.RelationalModel} relation.model\n@param {String} relation.type\n@param {String} relation.key\n@param {String|Object} relation.relatedModel", "docstring_tokens": ["Add", "a", "reverse", "relation", ".", "Is", "added", "to", "the", "relations", "property", "on", "model", "s", "prototype", "and", "to", "existing", "instances", "of", "model", "in", "the", "store", "as", "well", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L221-L233", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "checkCallExpression", "original_string": "function checkCallExpression(node) {\n            // Grammar checking; stop grammar-checking if checkGrammarTypeArguments return true\n            checkGrammarTypeArguments(node, node.typeArguments) || checkGrammarArguments(node, node.arguments);\n            var signature = getResolvedSignature(node);\n            if (node.expression.kind === 95 /* SuperKeyword */) {\n                return voidType;\n            }\n            if (node.kind === 169 /* NewExpression */) {\n                var declaration = signature.declaration;\n                if (declaration &&\n                    declaration.kind !== 144 /* Constructor */ &&\n                    declaration.kind !== 148 /* ConstructSignature */ &&\n                    declaration.kind !== 153 /* ConstructorType */) {\n                    // When resolved signature is a call signature (and not a construct signature) the result type is any\n                    if (compilerOptions.noImplicitAny) {\n                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);\n                    }\n                    return anyType;\n                }\n            }\n            return getReturnTypeOfSignature(signature);\n        }", "language": "javascript", "code": "function checkCallExpression(node) {\n            // Grammar checking; stop grammar-checking if checkGrammarTypeArguments return true\n            checkGrammarTypeArguments(node, node.typeArguments) || checkGrammarArguments(node, node.arguments);\n            var signature = getResolvedSignature(node);\n            if (node.expression.kind === 95 /* SuperKeyword */) {\n                return voidType;\n            }\n            if (node.kind === 169 /* NewExpression */) {\n                var declaration = signature.declaration;\n                if (declaration &&\n                    declaration.kind !== 144 /* Constructor */ &&\n                    declaration.kind !== 148 /* ConstructSignature */ &&\n                    declaration.kind !== 153 /* ConstructorType */) {\n                    // When resolved signature is a call signature (and not a construct signature) the result type is any\n                    if (compilerOptions.noImplicitAny) {\n                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);\n                    }\n                    return anyType;\n                }\n            }\n            return getReturnTypeOfSignature(signature);\n        }", "code_tokens": ["function", "checkCallExpression", "(", "node", ")", "{", "// Grammar checking; stop grammar-checking if checkGrammarTypeArguments return true", "checkGrammarTypeArguments", "(", "node", ",", "node", ".", "typeArguments", ")", "||", "checkGrammarArguments", "(", "node", ",", "node", ".", "arguments", ")", ";", "var", "signature", "=", "getResolvedSignature", "(", "node", ")", ";", "if", "(", "node", ".", "expression", ".", "kind", "===", "95", "/* SuperKeyword */", ")", "{", "return", "voidType", ";", "}", "if", "(", "node", ".", "kind", "===", "169", "/* NewExpression */", ")", "{", "var", "declaration", "=", "signature", ".", "declaration", ";", "if", "(", "declaration", "&&", "declaration", ".", "kind", "!==", "144", "/* Constructor */", "&&", "declaration", ".", "kind", "!==", "148", "/* ConstructSignature */", "&&", "declaration", ".", "kind", "!==", "153", "/* ConstructorType */", ")", "{", "// When resolved signature is a call signature (and not a construct signature) the result type is any", "if", "(", "compilerOptions", ".", "noImplicitAny", ")", "{", "error", "(", "node", ",", "ts", ".", "Diagnostics", ".", "new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type", ")", ";", "}", "return", "anyType", ";", "}", "}", "return", "getReturnTypeOfSignature", "(", "signature", ")", ";", "}"], "docstring": "Syntactically and semantically checks a call or new expression.\n@param node The call/new expression to be checked.\n@returns On success, the expression's signature's return type. On failure, anyType.", "docstring_tokens": ["Syntactically", "and", "semantically", "checks", "a", "call", "or", "new", "expression", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L21752-L21773", "partition": "test"}
{"repo": "duaraghav8/Ethlint", "path": "lib/rules/visibility-first.js", "func_name": "inspectFD", "original_string": "function inspectFD(emitted) {\n            const { node } = emitted,\n                visibilityModifiers = [\"public\", \"external\", \"internal\", \"private\"];\n            const modifiers = (node.modifiers || []),\n                firstVisibilityModifierIndex = modifiers.findIndex(m => visibilityModifiers.includes(m.name));\n\n            // If no visibility modifiers exist in function declaration, exit now\n            if (emitted.exit || firstVisibilityModifierIndex === -1) {\n                return;\n            }\n\n            const firstNonVisModifBeforeFirstVisModif = modifiers.slice(0, firstVisibilityModifierIndex).find(m => !visibilityModifiers.includes(m.name));\n\n            // TODO: Add fix() for this rule\n            if (firstNonVisModifBeforeFirstVisModif) {\n                const issue = {\n                    node: modifiers[firstVisibilityModifierIndex],\n                    message: `Visibility modifier \"${modifiers[firstVisibilityModifierIndex].name}\" should come before other modifiers.`\n                };\n                context.report(issue);\n            }\n        }", "language": "javascript", "code": "function inspectFD(emitted) {\n            const { node } = emitted,\n                visibilityModifiers = [\"public\", \"external\", \"internal\", \"private\"];\n            const modifiers = (node.modifiers || []),\n                firstVisibilityModifierIndex = modifiers.findIndex(m => visibilityModifiers.includes(m.name));\n\n            // If no visibility modifiers exist in function declaration, exit now\n            if (emitted.exit || firstVisibilityModifierIndex === -1) {\n                return;\n            }\n\n            const firstNonVisModifBeforeFirstVisModif = modifiers.slice(0, firstVisibilityModifierIndex).find(m => !visibilityModifiers.includes(m.name));\n\n            // TODO: Add fix() for this rule\n            if (firstNonVisModifBeforeFirstVisModif) {\n                const issue = {\n                    node: modifiers[firstVisibilityModifierIndex],\n                    message: `Visibility modifier \"${modifiers[firstVisibilityModifierIndex].name}\" should come before other modifiers.`\n                };\n                context.report(issue);\n            }\n        }", "code_tokens": ["function", "inspectFD", "(", "emitted", ")", "{", "const", "{", "node", "}", "=", "emitted", ",", "visibilityModifiers", "=", "[", "\"public\"", ",", "\"external\"", ",", "\"internal\"", ",", "\"private\"", "]", ";", "const", "modifiers", "=", "(", "node", ".", "modifiers", "||", "[", "]", ")", ",", "firstVisibilityModifierIndex", "=", "modifiers", ".", "findIndex", "(", "m", "=>", "visibilityModifiers", ".", "includes", "(", "m", ".", "name", ")", ")", ";", "// If no visibility modifiers exist in function declaration, exit now", "if", "(", "emitted", ".", "exit", "||", "firstVisibilityModifierIndex", "===", "-", "1", ")", "{", "return", ";", "}", "const", "firstNonVisModifBeforeFirstVisModif", "=", "modifiers", ".", "slice", "(", "0", ",", "firstVisibilityModifierIndex", ")", ".", "find", "(", "m", "=>", "!", "visibilityModifiers", ".", "includes", "(", "m", ".", "name", ")", ")", ";", "// TODO: Add fix() for this rule", "if", "(", "firstNonVisModifBeforeFirstVisModif", ")", "{", "const", "issue", "=", "{", "node", ":", "modifiers", "[", "firstVisibilityModifierIndex", "]", ",", "message", ":", "`", "${", "modifiers", "[", "firstVisibilityModifierIndex", "]", ".", "name", "}", "`", "}", ";", "context", ".", "report", "(", "issue", ")", ";", "}", "}"], "docstring": "Find index of the first visibility modifier in declaration. Find the first non-VM before this first VM found above. If non-VM found, report the VM.", "docstring_tokens": ["Find", "index", "of", "the", "first", "visibility", "modifier", "in", "declaration", ".", "Find", "the", "first", "non", "-", "VM", "before", "this", "first", "VM", "found", "above", ".", "If", "non", "-", "VM", "found", "report", "the", "VM", "."], "sha": "7d264373709561148c7166601ac39370e78f74b1", "url": "https://github.com/duaraghav8/Ethlint/blob/7d264373709561148c7166601ac39370e78f74b1/lib/rules/visibility-first.js#L23-L44", "partition": "test"}
{"repo": "vikassarkar/fs-generator", "path": "index.js", "func_name": "", "original_string": "function (parsedPath, fls) {\n        // parsedPath.dir, parsedPath.base, parsedPath.ext, parsedPath.name\n        var newName = \"\";\n        var fileConfigs = \"\";\n        var folderDirArray = getNestedFolderName(parsedPath);\n        parsedPath['folderName'] = utils.getBaseFolderName(parsedPath.dir) != tempFolderName ? utils.getBaseFolderName(parsedPath.dir) : \"\";\n        //fileConfigs = parsedPath.folderName ? fls.replaceFileName[parsedPath.folderName][parsedPath.base] : fls.replaceFileName[parsedPath.base];\n        if (folderDirArray == \"base\" && fls.replaceFileName[parsedPath.base]) {\n            fileConfigs = fls.replaceFileName[parsedPath.base];\n        } else if (Array.isArray(folderDirArray)) {\n            var replaceFileNameArray = fls.replaceFileName;\n            for (var i in folderDirArray) {\n                if (replaceFileNameArray[folderDirArray[i]] && Object.keys(replaceFileNameArray[folderDirArray[i]]).length > 0) {\n                    replaceFileNameArray = replaceFileNameArray[folderDirArray[i]];\n                } else {\n                    replaceFileNameArray = [];\n                    break;\n                }\n            }\n            if (replaceFileNameArray && replaceFileNameArray[parsedPath.base]) {\n                fileConfigs = replaceFileNameArray[parsedPath.base];\n            } else {\n                fileConfigs = [];\n            }\n        } else {\n            fileConfigs = []\n        }\n        console.log(\":::~~Configurations from replaceFileName~~:::\" +fileConfigs);\n        newName = utils.getupdatedFileName(parsedPath.name, fileConfigs, fls.input);\n        parsedPath.base = newName + parsedPath.ext;\n        parsedPath.name = newName;\n        return parsedPath;\n    }", "language": "javascript", "code": "function (parsedPath, fls) {\n        // parsedPath.dir, parsedPath.base, parsedPath.ext, parsedPath.name\n        var newName = \"\";\n        var fileConfigs = \"\";\n        var folderDirArray = getNestedFolderName(parsedPath);\n        parsedPath['folderName'] = utils.getBaseFolderName(parsedPath.dir) != tempFolderName ? utils.getBaseFolderName(parsedPath.dir) : \"\";\n        //fileConfigs = parsedPath.folderName ? fls.replaceFileName[parsedPath.folderName][parsedPath.base] : fls.replaceFileName[parsedPath.base];\n        if (folderDirArray == \"base\" && fls.replaceFileName[parsedPath.base]) {\n            fileConfigs = fls.replaceFileName[parsedPath.base];\n        } else if (Array.isArray(folderDirArray)) {\n            var replaceFileNameArray = fls.replaceFileName;\n            for (var i in folderDirArray) {\n                if (replaceFileNameArray[folderDirArray[i]] && Object.keys(replaceFileNameArray[folderDirArray[i]]).length > 0) {\n                    replaceFileNameArray = replaceFileNameArray[folderDirArray[i]];\n                } else {\n                    replaceFileNameArray = [];\n                    break;\n                }\n            }\n            if (replaceFileNameArray && replaceFileNameArray[parsedPath.base]) {\n                fileConfigs = replaceFileNameArray[parsedPath.base];\n            } else {\n                fileConfigs = [];\n            }\n        } else {\n            fileConfigs = []\n        }\n        console.log(\":::~~Configurations from replaceFileName~~:::\" +fileConfigs);\n        newName = utils.getupdatedFileName(parsedPath.name, fileConfigs, fls.input);\n        parsedPath.base = newName + parsedPath.ext;\n        parsedPath.name = newName;\n        return parsedPath;\n    }", "code_tokens": ["function", "(", "parsedPath", ",", "fls", ")", "{", "// parsedPath.dir, parsedPath.base, parsedPath.ext, parsedPath.name", "var", "newName", "=", "\"\"", ";", "var", "fileConfigs", "=", "\"\"", ";", "var", "folderDirArray", "=", "getNestedFolderName", "(", "parsedPath", ")", ";", "parsedPath", "[", "'folderName'", "]", "=", "utils", ".", "getBaseFolderName", "(", "parsedPath", ".", "dir", ")", "!=", "tempFolderName", "?", "utils", ".", "getBaseFolderName", "(", "parsedPath", ".", "dir", ")", ":", "\"\"", ";", "//fileConfigs = parsedPath.folderName ? fls.replaceFileName[parsedPath.folderName][parsedPath.base] : fls.replaceFileName[parsedPath.base];", "if", "(", "folderDirArray", "==", "\"base\"", "&&", "fls", ".", "replaceFileName", "[", "parsedPath", ".", "base", "]", ")", "{", "fileConfigs", "=", "fls", ".", "replaceFileName", "[", "parsedPath", ".", "base", "]", ";", "}", "else", "if", "(", "Array", ".", "isArray", "(", "folderDirArray", ")", ")", "{", "var", "replaceFileNameArray", "=", "fls", ".", "replaceFileName", ";", "for", "(", "var", "i", "in", "folderDirArray", ")", "{", "if", "(", "replaceFileNameArray", "[", "folderDirArray", "[", "i", "]", "]", "&&", "Object", ".", "keys", "(", "replaceFileNameArray", "[", "folderDirArray", "[", "i", "]", "]", ")", ".", "length", ">", "0", ")", "{", "replaceFileNameArray", "=", "replaceFileNameArray", "[", "folderDirArray", "[", "i", "]", "]", ";", "}", "else", "{", "replaceFileNameArray", "=", "[", "]", ";", "break", ";", "}", "}", "if", "(", "replaceFileNameArray", "&&", "replaceFileNameArray", "[", "parsedPath", ".", "base", "]", ")", "{", "fileConfigs", "=", "replaceFileNameArray", "[", "parsedPath", ".", "base", "]", ";", "}", "else", "{", "fileConfigs", "=", "[", "]", ";", "}", "}", "else", "{", "fileConfigs", "=", "[", "]", "}", "console", ".", "log", "(", "\":::~~Configurations from replaceFileName~~:::\"", "+", "fileConfigs", ")", ";", "newName", "=", "utils", ".", "getupdatedFileName", "(", "parsedPath", ".", "name", ",", "fileConfigs", ",", "fls", ".", "input", ")", ";", "parsedPath", ".", "base", "=", "newName", "+", "parsedPath", ".", "ext", ";", "parsedPath", ".", "name", "=", "newName", ";", "return", "parsedPath", ";", "}"], "docstring": "update refrence directory files names as per config provided by replaceFileName key\n@param {*} parsedPath\n@param {*} fls", "docstring_tokens": ["update", "refrence", "directory", "files", "names", "as", "per", "config", "provided", "by", "replaceFileName", "key"], "sha": "8a102ba308e79c0fa428dcf34fae0ba7200618dc", "url": "https://github.com/vikassarkar/fs-generator/blob/8a102ba308e79c0fa428dcf34fae0ba7200618dc/index.js#L153-L185", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/device/filesystem/HTML5.js", "func_name": "", "original_string": "function(config) {\n                var me = this;\n                var callback = config.success;\n\n                if ((config.options && config.options.create) && this.path) {\n                    var folders = this.path.split(\"/\");\n                    if (folders[0] == '.' || folders[0] == '') {\n                        folders = folders.slice(1);\n                    }\n\n                    var recursiveCreation = function(dirEntry) {\n                        if (folders.length) {\n                            dirEntry.getDirectory(folders.shift(), config.options, recursiveCreation, config.failure);\n                        } else {\n                            callback(dirEntry);\n                        }\n                    };\n\n                    recursiveCreation(this.fileSystem.fs.root);\n                } else {\n                    this.fileSystem.fs.root.getDirectory(this.path, config.options,\n                        function(directory) {\n                            config.success.call(config.scope || me, directory);\n                        },\n                        config.failure\n                    );\n                }\n            }", "language": "javascript", "code": "function(config) {\n                var me = this;\n                var callback = config.success;\n\n                if ((config.options && config.options.create) && this.path) {\n                    var folders = this.path.split(\"/\");\n                    if (folders[0] == '.' || folders[0] == '') {\n                        folders = folders.slice(1);\n                    }\n\n                    var recursiveCreation = function(dirEntry) {\n                        if (folders.length) {\n                            dirEntry.getDirectory(folders.shift(), config.options, recursiveCreation, config.failure);\n                        } else {\n                            callback(dirEntry);\n                        }\n                    };\n\n                    recursiveCreation(this.fileSystem.fs.root);\n                } else {\n                    this.fileSystem.fs.root.getDirectory(this.path, config.options,\n                        function(directory) {\n                            config.success.call(config.scope || me, directory);\n                        },\n                        config.failure\n                    );\n                }\n            }", "code_tokens": ["function", "(", "config", ")", "{", "var", "me", "=", "this", ";", "var", "callback", "=", "config", ".", "success", ";", "if", "(", "(", "config", ".", "options", "&&", "config", ".", "options", ".", "create", ")", "&&", "this", ".", "path", ")", "{", "var", "folders", "=", "this", ".", "path", ".", "split", "(", "\"/\"", ")", ";", "if", "(", "folders", "[", "0", "]", "==", "'.'", "||", "folders", "[", "0", "]", "==", "''", ")", "{", "folders", "=", "folders", ".", "slice", "(", "1", ")", ";", "}", "var", "recursiveCreation", "=", "function", "(", "dirEntry", ")", "{", "if", "(", "folders", ".", "length", ")", "{", "dirEntry", ".", "getDirectory", "(", "folders", ".", "shift", "(", ")", ",", "config", ".", "options", ",", "recursiveCreation", ",", "config", ".", "failure", ")", ";", "}", "else", "{", "callback", "(", "dirEntry", ")", ";", "}", "}", ";", "recursiveCreation", "(", "this", ".", "fileSystem", ".", "fs", ".", "root", ")", ";", "}", "else", "{", "this", ".", "fileSystem", ".", "fs", ".", "root", ".", "getDirectory", "(", "this", ".", "path", ",", "config", ".", "options", ",", "function", "(", "directory", ")", "{", "config", ".", "success", ".", "call", "(", "config", ".", "scope", "||", "me", ",", "directory", ")", ";", "}", ",", "config", ".", "failure", ")", ";", "}", "}"], "docstring": "Requests a Directory from the Local File System\n\n@param {Object} config\n\n@param {Object} config.options\nFile creation options {create:true, exclusive:false}\n\n@param {Boolean} config.options.create\nIndicates if the directory should be created if it doesn't exist\n\n@param {Boolean} config.options.exclusive\nUsed with the create option only indicates whether a creation causes an error if the directory already exists\n\n@param {Function} config.success\nThe function called when the Directory is returned successfully\n\n@param {Ext.device.filesystem.DirectoryEntry} config.success.directory\nDirectoryEntry Object\n\n@param {Function} config.failure\nThe function called when the Directory request causes an error\n\n@param {FileError} config.failure.error", "docstring_tokens": ["Requests", "a", "Directory", "from", "the", "Local", "File", "System"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/filesystem/HTML5.js#L368-L395", "partition": "test"}
{"repo": "nearform/nscale-kernel", "path": "lib/api.js", "func_name": "", "original_string": "function(identifier, cb) {\n    logger.info('list revisions: ' + identifier);\n    if (!identifier) {\n      return cb(new Error('no identifier'));\n    }\n    var systemId = _sr.findSystem(identifier);\n\n    if (!systemId) {\n      return cb(new Error('system not found'));\n    }\n\n    _sr.listRevisions(systemId, function(err, revisions) {\n      cb(err, _.first(revisions, 20));\n      //cb(err, revisions);\n    });\n  }", "language": "javascript", "code": "function(identifier, cb) {\n    logger.info('list revisions: ' + identifier);\n    if (!identifier) {\n      return cb(new Error('no identifier'));\n    }\n    var systemId = _sr.findSystem(identifier);\n\n    if (!systemId) {\n      return cb(new Error('system not found'));\n    }\n\n    _sr.listRevisions(systemId, function(err, revisions) {\n      cb(err, _.first(revisions, 20));\n      //cb(err, revisions);\n    });\n  }", "code_tokens": ["function", "(", "identifier", ",", "cb", ")", "{", "logger", ".", "info", "(", "'list revisions: '", "+", "identifier", ")", ";", "if", "(", "!", "identifier", ")", "{", "return", "cb", "(", "new", "Error", "(", "'no identifier'", ")", ")", ";", "}", "var", "systemId", "=", "_sr", ".", "findSystem", "(", "identifier", ")", ";", "if", "(", "!", "systemId", ")", "{", "return", "cb", "(", "new", "Error", "(", "'system not found'", ")", ")", ";", "}", "_sr", ".", "listRevisions", "(", "systemId", ",", "function", "(", "err", ",", "revisions", ")", "{", "cb", "(", "err", ",", "_", ".", "first", "(", "revisions", ",", "20", ")", ")", ";", "//cb(err, revisions);", "}", ")", ";", "}"], "docstring": "get the revision history for a system", "docstring_tokens": ["get", "the", "revision", "history", "for", "a", "system"], "sha": "5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3", "url": "https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/api.js#L406-L421", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "triggerSetupEvent", "original_string": "function triggerSetupEvent(player, hash, before) {\n  var eventName = (before ? 'before' : '') + 'pluginsetup';\n\n  player.trigger(eventName, hash);\n  player.trigger(eventName + ':' + hash.name, hash);\n}", "language": "javascript", "code": "function triggerSetupEvent(player, hash, before) {\n  var eventName = (before ? 'before' : '') + 'pluginsetup';\n\n  player.trigger(eventName, hash);\n  player.trigger(eventName + ':' + hash.name, hash);\n}", "code_tokens": ["function", "triggerSetupEvent", "(", "player", ",", "hash", ",", "before", ")", "{", "var", "eventName", "=", "(", "before", "?", "'before'", ":", "''", ")", "+", "'pluginsetup'", ";", "player", ".", "trigger", "(", "eventName", ",", "hash", ")", ";", "player", ".", "trigger", "(", "eventName", "+", "':'", "+", "hash", ".", "name", ",", "hash", ")", ";", "}"], "docstring": "Triggers a pair of plugin setup events.\n\n@private\n@param  {Player} player\nA Video.js player instance.\n\n@param  {Plugin~PluginEventHash} hash\nA plugin event hash.\n\n@param  {Boolean} [before]\nIf true, prefixes the event name with \"before\". In other words,\nuse this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".", "docstring_tokens": ["Triggers", "a", "pair", "of", "plugin", "setup", "events", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L21267-L21272", "partition": "test"}
{"repo": "snapptop/ninjs-lodash", "path": "lib/path.js", "func_name": "rebase", "original_string": "function rebase(root, src, dest) {\n  let relp = rel(root, src)\n  return relp ? path.join(dest, relp) : ''\n}", "language": "javascript", "code": "function rebase(root, src, dest) {\n  let relp = rel(root, src)\n  return relp ? path.join(dest, relp) : ''\n}", "code_tokens": ["function", "rebase", "(", "root", ",", "src", ",", "dest", ")", "{", "let", "relp", "=", "rel", "(", "root", ",", "src", ")", "return", "relp", "?", "path", ".", "join", "(", "dest", ",", "relp", ")", ":", "''", "}"], "docstring": "returns rel appended to dest root", "docstring_tokens": ["returns", "rel", "appended", "to", "dest", "root"], "sha": "fab253b7d96cc9bb3f2a1057efff2684c200bcee", "url": "https://github.com/snapptop/ninjs-lodash/blob/fab253b7d96cc9bb3f2a1057efff2684c200bcee/lib/path.js#L179-L182", "partition": "test"}
{"repo": "bootprint/customize-engine-uglify", "path": "lib/orderFiles.js", "func_name": "addWithDependencies", "original_string": "function addWithDependencies (allFiles, newFile, dependencies, currentFiles, cycleCheck) {\n  if (cycleCheck.indexOf(newFile) >= 0) {\n    throw new Error('Dependency cycle found ' + JSON.stringify(cycleCheck))\n  }\n  cycleCheck.push(newFile)\n  try {\n    // Add dependencies first\n    if (dependencies[newFile]) {\n      dependencies[newFile].forEach(function (dependency) {\n        if (allFiles.indexOf(dependency) < 0) {\n          throw new Error('Dependency \"' + dependency + '\" of file \"' + newFile + '\" is not part of ' + JSON.stringify(allFiles))\n        }\n        addWithDependencies(allFiles, dependency, dependencies, currentFiles, cycleCheck)\n      })\n    }\n    if (currentFiles.indexOf(newFile) < 0) {\n      currentFiles.push(newFile)\n    }\n  } finally {\n    cycleCheck.pop()\n  }\n  return currentFiles\n}", "language": "javascript", "code": "function addWithDependencies (allFiles, newFile, dependencies, currentFiles, cycleCheck) {\n  if (cycleCheck.indexOf(newFile) >= 0) {\n    throw new Error('Dependency cycle found ' + JSON.stringify(cycleCheck))\n  }\n  cycleCheck.push(newFile)\n  try {\n    // Add dependencies first\n    if (dependencies[newFile]) {\n      dependencies[newFile].forEach(function (dependency) {\n        if (allFiles.indexOf(dependency) < 0) {\n          throw new Error('Dependency \"' + dependency + '\" of file \"' + newFile + '\" is not part of ' + JSON.stringify(allFiles))\n        }\n        addWithDependencies(allFiles, dependency, dependencies, currentFiles, cycleCheck)\n      })\n    }\n    if (currentFiles.indexOf(newFile) < 0) {\n      currentFiles.push(newFile)\n    }\n  } finally {\n    cycleCheck.pop()\n  }\n  return currentFiles\n}", "code_tokens": ["function", "addWithDependencies", "(", "allFiles", ",", "newFile", ",", "dependencies", ",", "currentFiles", ",", "cycleCheck", ")", "{", "if", "(", "cycleCheck", ".", "indexOf", "(", "newFile", ")", ">=", "0", ")", "{", "throw", "new", "Error", "(", "'Dependency cycle found '", "+", "JSON", ".", "stringify", "(", "cycleCheck", ")", ")", "}", "cycleCheck", ".", "push", "(", "newFile", ")", "try", "{", "// Add dependencies first", "if", "(", "dependencies", "[", "newFile", "]", ")", "{", "dependencies", "[", "newFile", "]", ".", "forEach", "(", "function", "(", "dependency", ")", "{", "if", "(", "allFiles", ".", "indexOf", "(", "dependency", ")", "<", "0", ")", "{", "throw", "new", "Error", "(", "'Dependency \"'", "+", "dependency", "+", "'\" of file \"'", "+", "newFile", "+", "'\" is not part of '", "+", "JSON", ".", "stringify", "(", "allFiles", ")", ")", "}", "addWithDependencies", "(", "allFiles", ",", "dependency", ",", "dependencies", ",", "currentFiles", ",", "cycleCheck", ")", "}", ")", "}", "if", "(", "currentFiles", ".", "indexOf", "(", "newFile", ")", "<", "0", ")", "{", "currentFiles", ".", "push", "(", "newFile", ")", "}", "}", "finally", "{", "cycleCheck", ".", "pop", "(", ")", "}", "return", "currentFiles", "}"], "docstring": "Add a filename to the list with its dependencies first\n@param {string[]} allFiles all filenames, for consistency checks\n@param {string} newFile the new file\n@param {object<string[]>} dependencies each property contains the dependencies for the file named like the key\n@param {string[]} currentFiles the file that have already been added. This array is modified\n@param {string[]} cycleCheck an internal stack of visited files", "docstring_tokens": ["Add", "a", "filename", "to", "the", "list", "with", "its", "dependencies", "first"], "sha": "835931f2fc527af1514e04c7c14e3efbe0c59ec7", "url": "https://github.com/bootprint/customize-engine-uglify/blob/835931f2fc527af1514e04c7c14e3efbe0c59ec7/lib/orderFiles.js#L9-L31", "partition": "test"}
{"repo": "bholloway/browserify-nginject", "path": "lib/get-updater.js", "func_name": "getAnnotatedNode", "original_string": "function getAnnotatedNode(comment) {\n\n    // find the first function declaration or expression following the annotation\n    var result;\n    if (comment.annotates) {\n      var candidateTrees;\n\n      // consider the context the block is in (i.e. what is its parent)\n      var parent = comment.annotates.parent;\n\n      // consider nodes from the annotated node forward\n      //  include the first non-generated node and all generated nodes preceding it\n      if (testNode.isBlockOrProgram(parent)) {\n        var body = parent.body;\n        var index = body.indexOf(comment.annotates);\n        var candidates = body.slice(index);\n        var length = candidates.map(testNode.isGeneratedCode).indexOf(false) + 1;\n        candidateTrees = candidates.slice(0, length || candidates.length);\n      }\n      // otherwise we can only consider the given node\n      else {\n        candidateTrees = [comment.annotates];\n      }\n\n      // try the nodes\n      while (!result && candidateTrees.length) {\n        result = esprimaTools\n          .orderNodes(candidateTrees.shift())\n          .filter(testNode.isFunctionNotIFFE)\n          .shift();\n      }\n    }\n\n    // throw where not valid\n    if (result) {\n      return result;\n    } else {\n      errorFn('Doc-tag @ngInject does not annotate anything');\n    }\n  }", "language": "javascript", "code": "function getAnnotatedNode(comment) {\n\n    // find the first function declaration or expression following the annotation\n    var result;\n    if (comment.annotates) {\n      var candidateTrees;\n\n      // consider the context the block is in (i.e. what is its parent)\n      var parent = comment.annotates.parent;\n\n      // consider nodes from the annotated node forward\n      //  include the first non-generated node and all generated nodes preceding it\n      if (testNode.isBlockOrProgram(parent)) {\n        var body = parent.body;\n        var index = body.indexOf(comment.annotates);\n        var candidates = body.slice(index);\n        var length = candidates.map(testNode.isGeneratedCode).indexOf(false) + 1;\n        candidateTrees = candidates.slice(0, length || candidates.length);\n      }\n      // otherwise we can only consider the given node\n      else {\n        candidateTrees = [comment.annotates];\n      }\n\n      // try the nodes\n      while (!result && candidateTrees.length) {\n        result = esprimaTools\n          .orderNodes(candidateTrees.shift())\n          .filter(testNode.isFunctionNotIFFE)\n          .shift();\n      }\n    }\n\n    // throw where not valid\n    if (result) {\n      return result;\n    } else {\n      errorFn('Doc-tag @ngInject does not annotate anything');\n    }\n  }", "code_tokens": ["function", "getAnnotatedNode", "(", "comment", ")", "{", "// find the first function declaration or expression following the annotation", "var", "result", ";", "if", "(", "comment", ".", "annotates", ")", "{", "var", "candidateTrees", ";", "// consider the context the block is in (i.e. what is its parent)", "var", "parent", "=", "comment", ".", "annotates", ".", "parent", ";", "// consider nodes from the annotated node forward", "//  include the first non-generated node and all generated nodes preceding it", "if", "(", "testNode", ".", "isBlockOrProgram", "(", "parent", ")", ")", "{", "var", "body", "=", "parent", ".", "body", ";", "var", "index", "=", "body", ".", "indexOf", "(", "comment", ".", "annotates", ")", ";", "var", "candidates", "=", "body", ".", "slice", "(", "index", ")", ";", "var", "length", "=", "candidates", ".", "map", "(", "testNode", ".", "isGeneratedCode", ")", ".", "indexOf", "(", "false", ")", "+", "1", ";", "candidateTrees", "=", "candidates", ".", "slice", "(", "0", ",", "length", "||", "candidates", ".", "length", ")", ";", "}", "// otherwise we can only consider the given node", "else", "{", "candidateTrees", "=", "[", "comment", ".", "annotates", "]", ";", "}", "// try the nodes", "while", "(", "!", "result", "&&", "candidateTrees", ".", "length", ")", "{", "result", "=", "esprimaTools", ".", "orderNodes", "(", "candidateTrees", ".", "shift", "(", ")", ")", ".", "filter", "(", "testNode", ".", "isFunctionNotIFFE", ")", ".", "shift", "(", ")", ";", "}", "}", "// throw where not valid", "if", "(", "result", ")", "{", "return", "result", ";", "}", "else", "{", "errorFn", "(", "'Doc-tag @ngInject does not annotate anything'", ")", ";", "}", "}"], "docstring": "Get the node that is annotated by the comment or throw if not present.\n@throws {Error} Where comment does not annotate a node\n@param {object} comment The comment node", "docstring_tokens": ["Get", "the", "node", "that", "is", "annotated", "by", "the", "comment", "or", "throw", "if", "not", "present", "."], "sha": "42cff52081b66d77e4e7fac923d4d824de13cfd3", "url": "https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/get-updater.js#L43-L82", "partition": "test"}
{"repo": "mobilehero-archive/aplus-node", "path": "resolver/resolve-fix.js", "func_name": "findFiles", "original_string": "function findFiles(rootpath, patterns) {\n\t\tlogger.trace(\"inside findFiles()\");\n\t\tvar patterns = patterns || ['**'];\n\t\tif(_.isString(patterns)) {\n\t\t\tpatterns = [patterns];\n\t\t}\n\t\tvar files = _.map(wrench.readdirSyncRecursive(rootpath), function(filename) {\n\t\t\treturn path.posix.sep + replaceBackSlashes(filename);\n\t\t});\n\t\tvar matchedFiles = match(files, patterns, {\n\t\t\tnocase: true,\n\t\t\tmatchBase: true,\n\t\t\tdot: true,\n\t\t});\n\t\treturn _.filter(matchedFiles, function(file) {\n\t\t\treturn !fs.statSync(path.join(rootpath, file)).isDirectory();\n\t\t}) || [];\n\n\t}", "language": "javascript", "code": "function findFiles(rootpath, patterns) {\n\t\tlogger.trace(\"inside findFiles()\");\n\t\tvar patterns = patterns || ['**'];\n\t\tif(_.isString(patterns)) {\n\t\t\tpatterns = [patterns];\n\t\t}\n\t\tvar files = _.map(wrench.readdirSyncRecursive(rootpath), function(filename) {\n\t\t\treturn path.posix.sep + replaceBackSlashes(filename);\n\t\t});\n\t\tvar matchedFiles = match(files, patterns, {\n\t\t\tnocase: true,\n\t\t\tmatchBase: true,\n\t\t\tdot: true,\n\t\t});\n\t\treturn _.filter(matchedFiles, function(file) {\n\t\t\treturn !fs.statSync(path.join(rootpath, file)).isDirectory();\n\t\t}) || [];\n\n\t}", "code_tokens": ["function", "findFiles", "(", "rootpath", ",", "patterns", ")", "{", "logger", ".", "trace", "(", "\"inside findFiles()\"", ")", ";", "var", "patterns", "=", "patterns", "||", "[", "'**'", "]", ";", "if", "(", "_", ".", "isString", "(", "patterns", ")", ")", "{", "patterns", "=", "[", "patterns", "]", ";", "}", "var", "files", "=", "_", ".", "map", "(", "wrench", ".", "readdirSyncRecursive", "(", "rootpath", ")", ",", "function", "(", "filename", ")", "{", "return", "path", ".", "posix", ".", "sep", "+", "replaceBackSlashes", "(", "filename", ")", ";", "}", ")", ";", "var", "matchedFiles", "=", "match", "(", "files", ",", "patterns", ",", "{", "nocase", ":", "true", ",", "matchBase", ":", "true", ",", "dot", ":", "true", ",", "}", ")", ";", "return", "_", ".", "filter", "(", "matchedFiles", ",", "function", "(", "file", ")", "{", "return", "!", "fs", ".", "statSync", "(", "path", ".", "join", "(", "rootpath", ",", "file", ")", ")", ".", "isDirectory", "(", ")", ";", "}", ")", "||", "[", "]", ";", "}"], "docstring": "Find all files that match extension criteria\n\n@param {string} rootpath - Absolute path of the directory from which file search will begin\n@param {string[]|string} [patterns=\"**\"] - Pattern(s) to be used when attempting to match files found\n@returns {string[]} - Matched file paths", "docstring_tokens": ["Find", "all", "files", "that", "match", "extension", "criteria"], "sha": "a16e11722406eb42f7b9e182c1301ffe2b706b67", "url": "https://github.com/mobilehero-archive/aplus-node/blob/a16e11722406eb42f7b9e182c1301ffe2b706b67/resolver/resolve-fix.js#L132-L150", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/AppxManifest.js", "func_name": "ensureUniqueCapabilities", "original_string": "function ensureUniqueCapabilities(capabilities) {\n    var uniqueCapabilities = [];\n    capabilities.getchildren()\n    .forEach(function(el) {\n        var name = el.attrib.Name;\n        if (uniqueCapabilities.indexOf(name) !== -1) {\n            capabilities.remove(el);\n        } else {\n            uniqueCapabilities.push(name);\n        }\n    });\n}", "language": "javascript", "code": "function ensureUniqueCapabilities(capabilities) {\n    var uniqueCapabilities = [];\n    capabilities.getchildren()\n    .forEach(function(el) {\n        var name = el.attrib.Name;\n        if (uniqueCapabilities.indexOf(name) !== -1) {\n            capabilities.remove(el);\n        } else {\n            uniqueCapabilities.push(name);\n        }\n    });\n}", "code_tokens": ["function", "ensureUniqueCapabilities", "(", "capabilities", ")", "{", "var", "uniqueCapabilities", "=", "[", "]", ";", "capabilities", ".", "getchildren", "(", ")", ".", "forEach", "(", "function", "(", "el", ")", "{", "var", "name", "=", "el", ".", "attrib", ".", "Name", ";", "if", "(", "uniqueCapabilities", ".", "indexOf", "(", "name", ")", "!==", "-", "1", ")", "{", "capabilities", ".", "remove", "(", "el", ")", ";", "}", "else", "{", "uniqueCapabilities", ".", "push", "(", "name", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Cleans up duplicate capability declarations that were generated during the prepare process\n@param capabilities {ElementTree.Element} The appx manifest element for <capabilities>", "docstring_tokens": ["Cleans", "up", "duplicate", "capability", "declarations", "that", "were", "generated", "during", "the", "prepare", "process"], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/spec/cordova/fixtures/projects/platformApi/platforms/windows/cordova/lib/AppxManifest.js#L720-L731", "partition": "test"}
{"repo": "Quartz/Chartbuilder", "path": "src/js/util/helper.js", "func_name": "merge_or_apply", "original_string": "function merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}", "language": "javascript", "code": "function merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}", "code_tokens": ["function", "merge_or_apply", "(", "defaults", ",", "source", ")", "{", "var", "defaultKeys", "=", "keys", "(", "defaults", ")", ";", "var", "sourceKeys", "=", "keys", "(", "source", ")", ";", "return", "reduce", "(", "defaultKeys", ",", "function", "(", "result", ",", "key", ")", "{", "if", "(", "sourceKeys", ".", "indexOf", "(", "key", ")", ">", "-", "1", ")", "{", "result", "[", "key", "]", "=", "source", "[", "key", "]", ";", "return", "result", ";", "}", "else", "{", "result", "[", "key", "]", "=", "defaults", "[", "key", "]", ";", "return", "result", ";", "}", "}", ",", "{", "}", ")", ";", "}"], "docstring": "Given a defaults object and a source object, copy the value from the source\nif it contains the same key, otherwise return the default. Skip keys that\nonly exist in the source object.\n@param {object} defaults - Default schema\n@param {object} source - Source object to copy properties from\n@returns {object} - Result has identical keys to defaults\n@static\n@memberof helper", "docstring_tokens": ["Given", "a", "defaults", "object", "and", "a", "source", "object", "copy", "the", "value", "from", "the", "source", "if", "it", "contains", "the", "same", "key", "otherwise", "return", "the", "default", ".", "Skip", "keys", "that", "only", "exist", "in", "the", "source", "object", "."], "sha": "fc6ce64e73b9ef378223afcab7057020f6dce260", "url": "https://github.com/Quartz/Chartbuilder/blob/fc6ce64e73b9ef378223afcab7057020f6dce260/src/js/util/helper.js#L202-L214", "partition": "test"}
{"repo": "noahehall/node-globals", "path": "src/lib/thirdparty/sorttable.js", "func_name": "forEach", "original_string": "function forEach (object, block, context) {\n\tif (object) {\n\t\tlet resolve = Object; // default\n\t\tif (object instanceof Function) {\n\t\t\t// functions have a \"length\" property\n\t\t\tresolve = Function;\n\t\t} else if (object.forEach instanceof Function) {\n\t\t\t// the object implements a custom forEach method so use that\n\t\t\tobject.forEach(block, context);\n\t\t\treturn;\n\t\t} else if (typeof object === \"string\") {\n\t\t\t// the object is a string\n\t\t\tresolve = String;\n\t\t} else if (typeof object.length === \"number\") {\n\t\t\t// the object is array-like\n\t\t\tresolve = Array;\n\t\t}\n\t\tresolve.forEach(object, block, context);\n\t}\n}", "language": "javascript", "code": "function forEach (object, block, context) {\n\tif (object) {\n\t\tlet resolve = Object; // default\n\t\tif (object instanceof Function) {\n\t\t\t// functions have a \"length\" property\n\t\t\tresolve = Function;\n\t\t} else if (object.forEach instanceof Function) {\n\t\t\t// the object implements a custom forEach method so use that\n\t\t\tobject.forEach(block, context);\n\t\t\treturn;\n\t\t} else if (typeof object === \"string\") {\n\t\t\t// the object is a string\n\t\t\tresolve = String;\n\t\t} else if (typeof object.length === \"number\") {\n\t\t\t// the object is array-like\n\t\t\tresolve = Array;\n\t\t}\n\t\tresolve.forEach(object, block, context);\n\t}\n}", "code_tokens": ["function", "forEach", "(", "object", ",", "block", ",", "context", ")", "{", "if", "(", "object", ")", "{", "let", "resolve", "=", "Object", ";", "// default", "if", "(", "object", "instanceof", "Function", ")", "{", "// functions have a \"length\" property", "resolve", "=", "Function", ";", "}", "else", "if", "(", "object", ".", "forEach", "instanceof", "Function", ")", "{", "// the object implements a custom forEach method so use that", "object", ".", "forEach", "(", "block", ",", "context", ")", ";", "return", ";", "}", "else", "if", "(", "typeof", "object", "===", "\"string\"", ")", "{", "// the object is a string", "resolve", "=", "String", ";", "}", "else", "if", "(", "typeof", "object", ".", "length", "===", "\"number\"", ")", "{", "// the object is array-like", "resolve", "=", "Array", ";", "}", "resolve", ".", "forEach", "(", "object", ",", "block", ",", "context", ")", ";", "}", "}"], "docstring": "globally resolve forEach enumeration", "docstring_tokens": ["globally", "resolve", "forEach", "enumeration"], "sha": "23240649a6226dcabdd963ff3c4e7e3e7df9a9ba", "url": "https://github.com/noahehall/node-globals/blob/23240649a6226dcabdd963ff3c4e7e3e7df9a9ba/src/lib/thirdparty/sorttable.js#L467-L486", "partition": "test"}
{"repo": "saymedia/angularjs-server", "path": "examples/weather/angular.js", "func_name": "isSameOrigin", "original_string": "function isSameOrigin(requestUrl) {\n        var parsed = (typeof requestUrl === 'string') ? resolve(requestUrl, true) : requestUrl;\n        return (parsed.protocol === originUrl.protocol &&\n                parsed.host === originUrl.host);\n      }", "language": "javascript", "code": "function isSameOrigin(requestUrl) {\n        var parsed = (typeof requestUrl === 'string') ? resolve(requestUrl, true) : requestUrl;\n        return (parsed.protocol === originUrl.protocol &&\n                parsed.host === originUrl.host);\n      }", "code_tokens": ["function", "isSameOrigin", "(", "requestUrl", ")", "{", "var", "parsed", "=", "(", "typeof", "requestUrl", "===", "'string'", ")", "?", "resolve", "(", "requestUrl", ",", "true", ")", ":", "requestUrl", ";", "return", "(", "parsed", ".", "protocol", "===", "originUrl", ".", "protocol", "&&", "parsed", ".", "host", "===", "originUrl", ".", "host", ")", ";", "}"], "docstring": "Parse a request URL and determine whether this is a same-origin request as the application document.\n\n@param {string|object} requestUrl The url of the request as a string that will be resolved\nor a parsed URL object.\n@returns {boolean} Whether the request is for the same origin as the application document.", "docstring_tokens": ["Parse", "a", "request", "URL", "and", "determine", "whether", "this", "is", "a", "same", "-", "origin", "request", "as", "the", "application", "document", "."], "sha": "db61e9cfd9d6634ebf66c8320b823ebf7eab1a6b", "url": "https://github.com/saymedia/angularjs-server/blob/db61e9cfd9d6634ebf66c8320b823ebf7eab1a6b/examples/weather/angular.js#L11785-L11789", "partition": "test"}
{"repo": "emmetio/html-matcher", "path": "index.js", "func_name": "getName", "original_string": "function getName(tag) {\n\treturn tag.name ? tag.name.value.toLowerCase() : `#${tag.type}`;\n}", "language": "javascript", "code": "function getName(tag) {\n\treturn tag.name ? tag.name.value.toLowerCase() : `#${tag.type}`;\n}", "code_tokens": ["function", "getName", "(", "tag", ")", "{", "return", "tag", ".", "name", "?", "tag", ".", "name", ".", "value", ".", "toLowerCase", "(", ")", ":", "`", "${", "tag", ".", "type", "}", "`", ";", "}"], "docstring": "Returns name of given matched token\n@param  {Token} tag\n@return {String}", "docstring_tokens": ["Returns", "name", "of", "given", "matched", "token"], "sha": "55b01d2a157a482db5a538e39f7c6129a6fce011", "url": "https://github.com/emmetio/html-matcher/blob/55b01d2a157a482db5a538e39f7c6129a6fce011/index.js#L121-L123", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/blob.js", "func_name": "fetch", "original_string": "function fetch(repoState, driver, sha) {\n    if (isFetched(repoState, sha)) {\n        // No op if already fetched\n        return Q(repoState);\n    }\n\n    const cache = repoState.getCache();\n    // Fetch the blob\n    return driver.fetchBlob(sha)\n    // Then store it in the cache\n    .then((blob) => {\n        const newCache = CacheUtils.addBlob(cache, sha, blob);\n        return repoState.set('cache', newCache);\n    });\n}", "language": "javascript", "code": "function fetch(repoState, driver, sha) {\n    if (isFetched(repoState, sha)) {\n        // No op if already fetched\n        return Q(repoState);\n    }\n\n    const cache = repoState.getCache();\n    // Fetch the blob\n    return driver.fetchBlob(sha)\n    // Then store it in the cache\n    .then((blob) => {\n        const newCache = CacheUtils.addBlob(cache, sha, blob);\n        return repoState.set('cache', newCache);\n    });\n}", "code_tokens": ["function", "fetch", "(", "repoState", ",", "driver", ",", "sha", ")", "{", "if", "(", "isFetched", "(", "repoState", ",", "sha", ")", ")", "{", "// No op if already fetched", "return", "Q", "(", "repoState", ")", ";", "}", "const", "cache", "=", "repoState", ".", "getCache", "(", ")", ";", "// Fetch the blob", "return", "driver", ".", "fetchBlob", "(", "sha", ")", "// Then store it in the cache", ".", "then", "(", "(", "blob", ")", "=>", "{", "const", "newCache", "=", "CacheUtils", ".", "addBlob", "(", "cache", ",", "sha", ",", "blob", ")", ";", "return", "repoState", ".", "set", "(", "'cache'", ",", "newCache", ")", ";", "}", ")", ";", "}"], "docstring": "Fetch a blob from SHA.\n@param {RepositoryState} repoState\n@param {Driver} driver\n@param {SHA} sha\n@return {Promise<RepositoryState>}", "docstring_tokens": ["Fetch", "a", "blob", "from", "SHA", "."], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/blob.js#L21-L35", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "Extglob", "original_string": "function Extglob(options) {\n  this.options = extend({source: 'extglob'}, options);\n  this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);\n  this.snapdragon.patterns = this.snapdragon.patterns || {};\n  this.compiler = this.snapdragon.compiler;\n  this.parser = this.snapdragon.parser;\n\n  compilers(this.snapdragon);\n  parsers(this.snapdragon);\n\n  /**\n   * Override Snapdragon `.parse` method\n   */\n\n  define(this.snapdragon, 'parse', function(str, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last && this.options.strict !== true) {\n      var node = last.nodes[0];\n      node.val = '\\\\' + node.val;\n      var sibling = node.parent.nodes[1];\n      if (sibling.type === 'star') {\n        sibling.loose = true;\n      }\n    }\n\n    // add non-enumerable parser reference\n    define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n\n  /**\n   * Decorate `.parse` method\n   */\n\n  define(this, 'parse', function(ast, options) {\n    return this.snapdragon.parse.apply(this.snapdragon, arguments);\n  });\n\n  /**\n   * Decorate `.compile` method\n   */\n\n  define(this, 'compile', function(ast, options) {\n    return this.snapdragon.compile.apply(this.snapdragon, arguments);\n  });\n\n}", "language": "javascript", "code": "function Extglob(options) {\n  this.options = extend({source: 'extglob'}, options);\n  this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);\n  this.snapdragon.patterns = this.snapdragon.patterns || {};\n  this.compiler = this.snapdragon.compiler;\n  this.parser = this.snapdragon.parser;\n\n  compilers(this.snapdragon);\n  parsers(this.snapdragon);\n\n  /**\n   * Override Snapdragon `.parse` method\n   */\n\n  define(this.snapdragon, 'parse', function(str, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last && this.options.strict !== true) {\n      var node = last.nodes[0];\n      node.val = '\\\\' + node.val;\n      var sibling = node.parent.nodes[1];\n      if (sibling.type === 'star') {\n        sibling.loose = true;\n      }\n    }\n\n    // add non-enumerable parser reference\n    define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n\n  /**\n   * Decorate `.parse` method\n   */\n\n  define(this, 'parse', function(ast, options) {\n    return this.snapdragon.parse.apply(this.snapdragon, arguments);\n  });\n\n  /**\n   * Decorate `.compile` method\n   */\n\n  define(this, 'compile', function(ast, options) {\n    return this.snapdragon.compile.apply(this.snapdragon, arguments);\n  });\n\n}", "code_tokens": ["function", "Extglob", "(", "options", ")", "{", "this", ".", "options", "=", "extend", "(", "{", "source", ":", "'extglob'", "}", ",", "options", ")", ";", "this", ".", "snapdragon", "=", "this", ".", "options", ".", "snapdragon", "||", "new", "Snapdragon", "(", "this", ".", "options", ")", ";", "this", ".", "snapdragon", ".", "patterns", "=", "this", ".", "snapdragon", ".", "patterns", "||", "{", "}", ";", "this", ".", "compiler", "=", "this", ".", "snapdragon", ".", "compiler", ";", "this", ".", "parser", "=", "this", ".", "snapdragon", ".", "parser", ";", "compilers", "(", "this", ".", "snapdragon", ")", ";", "parsers", "(", "this", ".", "snapdragon", ")", ";", "/**\n   * Override Snapdragon `.parse` method\n   */", "define", "(", "this", ".", "snapdragon", ",", "'parse'", ",", "function", "(", "str", ",", "options", ")", "{", "var", "parsed", "=", "Snapdragon", ".", "prototype", ".", "parse", ".", "apply", "(", "this", ",", "arguments", ")", ";", "parsed", ".", "input", "=", "str", ";", "// escape unmatched brace/bracket/parens", "var", "last", "=", "this", ".", "parser", ".", "stack", ".", "pop", "(", ")", ";", "if", "(", "last", "&&", "this", ".", "options", ".", "strict", "!==", "true", ")", "{", "var", "node", "=", "last", ".", "nodes", "[", "0", "]", ";", "node", ".", "val", "=", "'\\\\'", "+", "node", ".", "val", ";", "var", "sibling", "=", "node", ".", "parent", ".", "nodes", "[", "1", "]", ";", "if", "(", "sibling", ".", "type", "===", "'star'", ")", "{", "sibling", ".", "loose", "=", "true", ";", "}", "}", "// add non-enumerable parser reference", "define", "(", "parsed", ",", "'parser'", ",", "this", ".", "parser", ")", ";", "return", "parsed", ";", "}", ")", ";", "/**\n   * Decorate `.parse` method\n   */", "define", "(", "this", ",", "'parse'", ",", "function", "(", "ast", ",", "options", ")", "{", "return", "this", ".", "snapdragon", ".", "parse", ".", "apply", "(", "this", ".", "snapdragon", ",", "arguments", ")", ";", "}", ")", ";", "/**\n   * Decorate `.compile` method\n   */", "define", "(", "this", ",", "'compile'", ",", "function", "(", "ast", ",", "options", ")", "{", "return", "this", ".", "snapdragon", ".", "compile", ".", "apply", "(", "this", ".", "snapdragon", ",", "arguments", ")", ";", "}", ")", ";", "}"], "docstring": "Customize Snapdragon parser and renderer", "docstring_tokens": ["Customize", "Snapdragon", "parser", "and", "renderer"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L12131-L12181", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/dataview/List.js", "func_name": "", "original_string": "function() {\n        var me = this,\n            container = me.container,\n            baseCls = me.getBaseCls(),\n            scrollable, scrollViewElement, pinnedHeader;\n\n        Ext.apply(me, {\n            listItems: [],\n            headerItems: [],\n            updatedItems: [],\n            headerMap: [],\n            scrollDockItems: {\n                top: [],\n                bottom: []\n            }\n        });\n\n        // We determine the translation methods for headers and items within this List based\n        // on the best strategy for the device\n        this.translationMethod = Ext.browser.is.AndroidStock2 ? 'cssposition' : 'csstransform';\n\n        // Create the inner container that will actually hold all the list items\n        if (!container) {\n            container = me.container = Ext.factory({\n                xtype: 'container',\n                scrollable: {\n                    scroller: {\n                        autoRefresh: !me.getInfinite(),\n                        direction: 'vertical'\n                    }\n                }\n            });\n        }\n\n        // We add the container after creating it manually because when you add the container,\n        // the items config is initialized. When this happens, any scrollDock items will be added,\n        // which in turn tries to add these items to the container\n        me.add(container);\n\n        // We make this List's scrollable the inner containers scrollable\n        scrollable = container.getScrollable();\n        scrollViewElement = me.scrollViewElement = scrollable.getElement();\n        me.scrollElement = scrollable.getScroller().getElement();\n\n        me.setScrollable(scrollable);\n        me.scrollableBehavior = container.getScrollableBehavior();\n\n        // Create the pinnedHeader instance thats being used when grouping is enabled\n        // and insert it into the scrollElement\n        pinnedHeader = me.pinnedHeader = Ext.factory({\n            xtype: 'listitemheader',\n            html: '&nbsp;',\n            translatable: {\n                translationMethod: this.translationMethod\n            },\n            cls: [baseCls + '-header', baseCls + '-header-swap']\n        });\n        pinnedHeader.translate(0, -10000);\n        pinnedHeader.$position = -10000;\n        scrollViewElement.insertFirst(pinnedHeader.renderElement);\n\n        // We want to intercept any translate calls made on the scroller to perform specific list logic\n        me.bind(scrollable.getScroller().getTranslatable(), 'doTranslate', 'onTranslate');\n    }", "language": "javascript", "code": "function() {\n        var me = this,\n            container = me.container,\n            baseCls = me.getBaseCls(),\n            scrollable, scrollViewElement, pinnedHeader;\n\n        Ext.apply(me, {\n            listItems: [],\n            headerItems: [],\n            updatedItems: [],\n            headerMap: [],\n            scrollDockItems: {\n                top: [],\n                bottom: []\n            }\n        });\n\n        // We determine the translation methods for headers and items within this List based\n        // on the best strategy for the device\n        this.translationMethod = Ext.browser.is.AndroidStock2 ? 'cssposition' : 'csstransform';\n\n        // Create the inner container that will actually hold all the list items\n        if (!container) {\n            container = me.container = Ext.factory({\n                xtype: 'container',\n                scrollable: {\n                    scroller: {\n                        autoRefresh: !me.getInfinite(),\n                        direction: 'vertical'\n                    }\n                }\n            });\n        }\n\n        // We add the container after creating it manually because when you add the container,\n        // the items config is initialized. When this happens, any scrollDock items will be added,\n        // which in turn tries to add these items to the container\n        me.add(container);\n\n        // We make this List's scrollable the inner containers scrollable\n        scrollable = container.getScrollable();\n        scrollViewElement = me.scrollViewElement = scrollable.getElement();\n        me.scrollElement = scrollable.getScroller().getElement();\n\n        me.setScrollable(scrollable);\n        me.scrollableBehavior = container.getScrollableBehavior();\n\n        // Create the pinnedHeader instance thats being used when grouping is enabled\n        // and insert it into the scrollElement\n        pinnedHeader = me.pinnedHeader = Ext.factory({\n            xtype: 'listitemheader',\n            html: '&nbsp;',\n            translatable: {\n                translationMethod: this.translationMethod\n            },\n            cls: [baseCls + '-header', baseCls + '-header-swap']\n        });\n        pinnedHeader.translate(0, -10000);\n        pinnedHeader.$position = -10000;\n        scrollViewElement.insertFirst(pinnedHeader.renderElement);\n\n        // We want to intercept any translate calls made on the scroller to perform specific list logic\n        me.bind(scrollable.getScroller().getTranslatable(), 'doTranslate', 'onTranslate');\n    }", "code_tokens": ["function", "(", ")", "{", "var", "me", "=", "this", ",", "container", "=", "me", ".", "container", ",", "baseCls", "=", "me", ".", "getBaseCls", "(", ")", ",", "scrollable", ",", "scrollViewElement", ",", "pinnedHeader", ";", "Ext", ".", "apply", "(", "me", ",", "{", "listItems", ":", "[", "]", ",", "headerItems", ":", "[", "]", ",", "updatedItems", ":", "[", "]", ",", "headerMap", ":", "[", "]", ",", "scrollDockItems", ":", "{", "top", ":", "[", "]", ",", "bottom", ":", "[", "]", "}", "}", ")", ";", "// We determine the translation methods for headers and items within this List based", "// on the best strategy for the device", "this", ".", "translationMethod", "=", "Ext", ".", "browser", ".", "is", ".", "AndroidStock2", "?", "'cssposition'", ":", "'csstransform'", ";", "// Create the inner container that will actually hold all the list items", "if", "(", "!", "container", ")", "{", "container", "=", "me", ".", "container", "=", "Ext", ".", "factory", "(", "{", "xtype", ":", "'container'", ",", "scrollable", ":", "{", "scroller", ":", "{", "autoRefresh", ":", "!", "me", ".", "getInfinite", "(", ")", ",", "direction", ":", "'vertical'", "}", "}", "}", ")", ";", "}", "// We add the container after creating it manually because when you add the container,", "// the items config is initialized. When this happens, any scrollDock items will be added,", "// which in turn tries to add these items to the container", "me", ".", "add", "(", "container", ")", ";", "// We make this List's scrollable the inner containers scrollable", "scrollable", "=", "container", ".", "getScrollable", "(", ")", ";", "scrollViewElement", "=", "me", ".", "scrollViewElement", "=", "scrollable", ".", "getElement", "(", ")", ";", "me", ".", "scrollElement", "=", "scrollable", ".", "getScroller", "(", ")", ".", "getElement", "(", ")", ";", "me", ".", "setScrollable", "(", "scrollable", ")", ";", "me", ".", "scrollableBehavior", "=", "container", ".", "getScrollableBehavior", "(", ")", ";", "// Create the pinnedHeader instance thats being used when grouping is enabled", "// and insert it into the scrollElement", "pinnedHeader", "=", "me", ".", "pinnedHeader", "=", "Ext", ".", "factory", "(", "{", "xtype", ":", "'listitemheader'", ",", "html", ":", "'&nbsp;'", ",", "translatable", ":", "{", "translationMethod", ":", "this", ".", "translationMethod", "}", ",", "cls", ":", "[", "baseCls", "+", "'-header'", ",", "baseCls", "+", "'-header-swap'", "]", "}", ")", ";", "pinnedHeader", ".", "translate", "(", "0", ",", "-", "10000", ")", ";", "pinnedHeader", ".", "$position", "=", "-", "10000", ";", "scrollViewElement", ".", "insertFirst", "(", "pinnedHeader", ".", "renderElement", ")", ";", "// We want to intercept any translate calls made on the scroller to perform specific list logic", "me", ".", "bind", "(", "scrollable", ".", "getScroller", "(", ")", ".", "getTranslatable", "(", ")", ",", "'doTranslate'", ",", "'onTranslate'", ")", ";", "}"], "docstring": "We create complex instance arrays and objects in beforeInitialize so that we can use these inside of the initConfig process.", "docstring_tokens": ["We", "create", "complex", "instance", "arrays", "and", "objects", "in", "beforeInitialize", "so", "that", "we", "can", "use", "these", "inside", "of", "the", "initConfig", "process", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/dataview/List.js#L350-L413", "partition": "test"}
{"repo": "mitro-co/keyczarjs", "path": "keyczar.js", "func_name": "_exportPublicKey", "original_string": "function _exportPublicKey(key) {\n    var t = key.metadata.type;\n    var p = key.metadata.purpose;\n    if (!(t == keyczar.TYPE_RSA_PRIVATE && (p == keyczar.PURPOSE_DECRYPT_ENCRYPT || p == keyczar.PURPOSE_SIGN_VERIFY))) {\n        throw new Error('Unsupported key type/purpose:' + t + '/' + p);\n    }\n\n    var publicPurpose = keyczar.PURPOSE_ENCRYPT;\n    if (p == keyczar.PURPOSE_SIGN_VERIFY) {\n        publicPurpose = keyczar.PURPOSE_VERIFY;\n    }\n\n    var metadata = {\n        name: key.metadata.name,\n        purpose: publicPurpose,\n        type: keyczar.TYPE_RSA_PUBLIC,\n        encrypted: false,\n        // TODO: Probably should do a deep copy\n        versions: key.metadata.versions\n    };\n\n    if (key.metadata.versions.length != 1) {\n        throw new Error('TODO: Support key sets with multiple keys');\n    }\n\n    var primaryVersion = _getPrimaryVersion(key.metadata);\n\n    var data = {\n        meta: JSON.stringify(metadata)\n    };\n    data[String(primaryVersion)] = key.primary.exportPublicKeyJson();\n    return _makeKeyczar(data);\n}", "language": "javascript", "code": "function _exportPublicKey(key) {\n    var t = key.metadata.type;\n    var p = key.metadata.purpose;\n    if (!(t == keyczar.TYPE_RSA_PRIVATE && (p == keyczar.PURPOSE_DECRYPT_ENCRYPT || p == keyczar.PURPOSE_SIGN_VERIFY))) {\n        throw new Error('Unsupported key type/purpose:' + t + '/' + p);\n    }\n\n    var publicPurpose = keyczar.PURPOSE_ENCRYPT;\n    if (p == keyczar.PURPOSE_SIGN_VERIFY) {\n        publicPurpose = keyczar.PURPOSE_VERIFY;\n    }\n\n    var metadata = {\n        name: key.metadata.name,\n        purpose: publicPurpose,\n        type: keyczar.TYPE_RSA_PUBLIC,\n        encrypted: false,\n        // TODO: Probably should do a deep copy\n        versions: key.metadata.versions\n    };\n\n    if (key.metadata.versions.length != 1) {\n        throw new Error('TODO: Support key sets with multiple keys');\n    }\n\n    var primaryVersion = _getPrimaryVersion(key.metadata);\n\n    var data = {\n        meta: JSON.stringify(metadata)\n    };\n    data[String(primaryVersion)] = key.primary.exportPublicKeyJson();\n    return _makeKeyczar(data);\n}", "code_tokens": ["function", "_exportPublicKey", "(", "key", ")", "{", "var", "t", "=", "key", ".", "metadata", ".", "type", ";", "var", "p", "=", "key", ".", "metadata", ".", "purpose", ";", "if", "(", "!", "(", "t", "==", "keyczar", ".", "TYPE_RSA_PRIVATE", "&&", "(", "p", "==", "keyczar", ".", "PURPOSE_DECRYPT_ENCRYPT", "||", "p", "==", "keyczar", ".", "PURPOSE_SIGN_VERIFY", ")", ")", ")", "{", "throw", "new", "Error", "(", "'Unsupported key type/purpose:'", "+", "t", "+", "'/'", "+", "p", ")", ";", "}", "var", "publicPurpose", "=", "keyczar", ".", "PURPOSE_ENCRYPT", ";", "if", "(", "p", "==", "keyczar", ".", "PURPOSE_SIGN_VERIFY", ")", "{", "publicPurpose", "=", "keyczar", ".", "PURPOSE_VERIFY", ";", "}", "var", "metadata", "=", "{", "name", ":", "key", ".", "metadata", ".", "name", ",", "purpose", ":", "publicPurpose", ",", "type", ":", "keyczar", ".", "TYPE_RSA_PUBLIC", ",", "encrypted", ":", "false", ",", "// TODO: Probably should do a deep copy", "versions", ":", "key", ".", "metadata", ".", "versions", "}", ";", "if", "(", "key", ".", "metadata", ".", "versions", ".", "length", "!=", "1", ")", "{", "throw", "new", "Error", "(", "'TODO: Support key sets with multiple keys'", ")", ";", "}", "var", "primaryVersion", "=", "_getPrimaryVersion", "(", "key", ".", "metadata", ")", ";", "var", "data", "=", "{", "meta", ":", "JSON", ".", "stringify", "(", "metadata", ")", "}", ";", "data", "[", "String", "(", "primaryVersion", ")", "]", "=", "key", ".", "primary", ".", "exportPublicKeyJson", "(", ")", ";", "return", "_makeKeyczar", "(", "data", ")", ";", "}"], "docstring": "Return a new keyczar containing the public part of key, which must be an asymmetric key.", "docstring_tokens": ["Return", "a", "new", "keyczar", "containing", "the", "public", "part", "of", "key", "which", "must", "be", "an", "asymmetric", "key", "."], "sha": "40087bf66bc9ded0d9d4a20b4d7875eb50516710", "url": "https://github.com/mitro-co/keyczarjs/blob/40087bf66bc9ded0d9d4a20b4d7875eb50516710/keyczar.js#L117-L149", "partition": "test"}
{"repo": "hbouvier/node-tts", "path": "swagger-ui/lib/shred.bundle.js", "func_name": "", "original_string": "function(constructor) {\n    constructor.prototype._setHeader = function(key,value) { return setHeader(this,key,value); };\n    constructor.prototype._setHeaders = function(hash) { return setHeaders(this,hash); };\n  }", "language": "javascript", "code": "function(constructor) {\n    constructor.prototype._setHeader = function(key,value) { return setHeader(this,key,value); };\n    constructor.prototype._setHeaders = function(hash) { return setHeaders(this,hash); };\n  }", "code_tokens": ["function", "(", "constructor", ")", "{", "constructor", ".", "prototype", ".", "_setHeader", "=", "function", "(", "key", ",", "value", ")", "{", "return", "setHeader", "(", "this", ",", "key", ",", "value", ")", ";", "}", ";", "constructor", ".", "prototype", ".", "_setHeaders", "=", "function", "(", "hash", ")", "{", "return", "setHeaders", "(", "this", ",", "hash", ")", ";", "}", ";", "}"], "docstring": "Add setters but as \"private\" methods.", "docstring_tokens": ["Add", "setters", "but", "as", "private", "methods", "."], "sha": "6b49053bb7f667681d526dc21d5d6b71f3bf644d", "url": "https://github.com/hbouvier/node-tts/blob/6b49053bb7f667681d526dc21d5d6b71f3bf644d/swagger-ui/lib/shred.bundle.js#L2195-L2198", "partition": "test"}
{"repo": "b44rd/gulp-extract-css", "path": "index.js", "func_name": "detectTakeout", "original_string": "function detectTakeout(selectors){\n    var properties = {\n      takeout: false\n    };\n\n    options.takeout.forEach(function (takeout) {\n      selectors.forEach(function (selector) {\n        if (selector.indexOf(takeout.ruleprefix) === 0) {\n          properties.takeout = true;\n          properties.filename = takeout.filename;\n        }\n      });\n    });\n\n    return properties;\n  }", "language": "javascript", "code": "function detectTakeout(selectors){\n    var properties = {\n      takeout: false\n    };\n\n    options.takeout.forEach(function (takeout) {\n      selectors.forEach(function (selector) {\n        if (selector.indexOf(takeout.ruleprefix) === 0) {\n          properties.takeout = true;\n          properties.filename = takeout.filename;\n        }\n      });\n    });\n\n    return properties;\n  }", "code_tokens": ["function", "detectTakeout", "(", "selectors", ")", "{", "var", "properties", "=", "{", "takeout", ":", "false", "}", ";", "options", ".", "takeout", ".", "forEach", "(", "function", "(", "takeout", ")", "{", "selectors", ".", "forEach", "(", "function", "(", "selector", ")", "{", "if", "(", "selector", ".", "indexOf", "(", "takeout", ".", "ruleprefix", ")", "===", "0", ")", "{", "properties", ".", "takeout", "=", "true", ";", "properties", ".", "filename", "=", "takeout", ".", "filename", ";", "}", "}", ")", ";", "}", ")", ";", "return", "properties", ";", "}"], "docstring": "Detect weather a selector should be extracted or not", "docstring_tokens": ["Detect", "weather", "a", "selector", "should", "be", "extracted", "or", "not"], "sha": "56f4d221e9aadbeaefe3c91dedcf694f7ec89413", "url": "https://github.com/b44rd/gulp-extract-css/blob/56f4d221e9aadbeaefe3c91dedcf694f7ec89413/index.js#L48-L63", "partition": "test"}
{"repo": "olegpolyakov/sendpulse", "path": "index.js", "func_name": "sendRequest", "original_string": "function sendRequest(path, method, data, useToken, callback){\n    var headers = {}\n    headers['Content-Type'] = 'application/json';\n    headers['Content-Length'] =  Buffer.byteLength(JSON.stringify(data));\n\n    if (useToken && TOKEN.length) {\n        headers['Authorization'] = 'Bearer '+TOKEN;\n    }\n    if (method === undefined) {\n        method = 'POST';\n    }\n    if (useToken === undefined) {\n        useToken = false;\n    }\n\n    var options = {\n        //uri: API_URL,\n        path: '/'+path,\n        port: 443,\n        hostname: API_URL,\n        method: method,\n        headers: headers,\n    };\n\n    var req = https.request(\n        options,\n        function(response) {\n            var str = '';\n            response.on('data', function (chunk) {\n                if (response.statusCode==401) {\n                    getToken();\n                    sendRequest(path, method, data, true, callback);\n                } else {\n                    str += chunk;\n                }\n            });\n\n            response.on('end', function () {\n                if (response.statusCode != 401) {\n                    try {\n                        var answer = JSON.parse(str);\n                    } catch (ex) {\n                        var answer = returnError();\n                    }\n                    callback(answer);\n                }\n            });\n        }\n    );\n    req.write(JSON.stringify(data));\n    req.end();\n}", "language": "javascript", "code": "function sendRequest(path, method, data, useToken, callback){\n    var headers = {}\n    headers['Content-Type'] = 'application/json';\n    headers['Content-Length'] =  Buffer.byteLength(JSON.stringify(data));\n\n    if (useToken && TOKEN.length) {\n        headers['Authorization'] = 'Bearer '+TOKEN;\n    }\n    if (method === undefined) {\n        method = 'POST';\n    }\n    if (useToken === undefined) {\n        useToken = false;\n    }\n\n    var options = {\n        //uri: API_URL,\n        path: '/'+path,\n        port: 443,\n        hostname: API_URL,\n        method: method,\n        headers: headers,\n    };\n\n    var req = https.request(\n        options,\n        function(response) {\n            var str = '';\n            response.on('data', function (chunk) {\n                if (response.statusCode==401) {\n                    getToken();\n                    sendRequest(path, method, data, true, callback);\n                } else {\n                    str += chunk;\n                }\n            });\n\n            response.on('end', function () {\n                if (response.statusCode != 401) {\n                    try {\n                        var answer = JSON.parse(str);\n                    } catch (ex) {\n                        var answer = returnError();\n                    }\n                    callback(answer);\n                }\n            });\n        }\n    );\n    req.write(JSON.stringify(data));\n    req.end();\n}", "code_tokens": ["function", "sendRequest", "(", "path", ",", "method", ",", "data", ",", "useToken", ",", "callback", ")", "{", "var", "headers", "=", "{", "}", "headers", "[", "'Content-Type'", "]", "=", "'application/json'", ";", "headers", "[", "'Content-Length'", "]", "=", "Buffer", ".", "byteLength", "(", "JSON", ".", "stringify", "(", "data", ")", ")", ";", "if", "(", "useToken", "&&", "TOKEN", ".", "length", ")", "{", "headers", "[", "'Authorization'", "]", "=", "'Bearer '", "+", "TOKEN", ";", "}", "if", "(", "method", "===", "undefined", ")", "{", "method", "=", "'POST'", ";", "}", "if", "(", "useToken", "===", "undefined", ")", "{", "useToken", "=", "false", ";", "}", "var", "options", "=", "{", "//uri: API_URL,", "path", ":", "'/'", "+", "path", ",", "port", ":", "443", ",", "hostname", ":", "API_URL", ",", "method", ":", "method", ",", "headers", ":", "headers", ",", "}", ";", "var", "req", "=", "https", ".", "request", "(", "options", ",", "function", "(", "response", ")", "{", "var", "str", "=", "''", ";", "response", ".", "on", "(", "'data'", ",", "function", "(", "chunk", ")", "{", "if", "(", "response", ".", "statusCode", "==", "401", ")", "{", "getToken", "(", ")", ";", "sendRequest", "(", "path", ",", "method", ",", "data", ",", "true", ",", "callback", ")", ";", "}", "else", "{", "str", "+=", "chunk", ";", "}", "}", ")", ";", "response", ".", "on", "(", "'end'", ",", "function", "(", ")", "{", "if", "(", "response", ".", "statusCode", "!=", "401", ")", "{", "try", "{", "var", "answer", "=", "JSON", ".", "parse", "(", "str", ")", ";", "}", "catch", "(", "ex", ")", "{", "var", "answer", "=", "returnError", "(", ")", ";", "}", "callback", "(", "answer", ")", ";", "}", "}", ")", ";", "}", ")", ";", "req", ".", "write", "(", "JSON", ".", "stringify", "(", "data", ")", ")", ";", "req", ".", "end", "(", ")", ";", "}"], "docstring": "Form and send request to API service\n\n@param path\n@param method\n@param data\n@param useToken\n@param callback\nDefine the function  that will be called\nwhen a response is received.", "docstring_tokens": ["Form", "and", "send", "request", "to", "API", "service"], "sha": "7c8230e75c918a8a110f641ddb241006a1f86ac1", "url": "https://github.com/olegpolyakov/sendpulse/blob/7c8230e75c918a8a110f641ddb241006a1f86ac1/index.js#L79-L130", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "", "original_string": "function (chunk, event, message) {\n      switch (event) {\n        case 'progress':\n          if (Date.now() - this._lastProgressCallback <\n            this.flowObj.opts.progressCallbacksInterval) {\n            break;\n          }\n          this.measureSpeed();\n          this.flowObj.fire('fileProgress', this, chunk);\n          this.flowObj.fire('progress');\n          this._lastProgressCallback = Date.now();\n          break;\n        case 'error':\n          this.error = true;\n          this.abort(true);\n          this.flowObj.fire('fileError', this, message, chunk);\n          this.flowObj.fire('error', message, this, chunk);\n          break;\n        case 'success':\n          if (this.error) {\n            return;\n          }\n          this.measureSpeed();\n          this.flowObj.fire('fileProgress', this, chunk);\n          this.flowObj.fire('progress');\n          this._lastProgressCallback = Date.now();\n          if (this.isComplete()) {\n            this.currentSpeed = 0;\n            this.averageSpeed = 0;\n            this.flowObj.fire('fileSuccess', this, message, chunk);\n          }\n          break;\n        case 'retry':\n          this.flowObj.fire('fileRetry', this, chunk);\n          break;\n      }\n    }", "language": "javascript", "code": "function (chunk, event, message) {\n      switch (event) {\n        case 'progress':\n          if (Date.now() - this._lastProgressCallback <\n            this.flowObj.opts.progressCallbacksInterval) {\n            break;\n          }\n          this.measureSpeed();\n          this.flowObj.fire('fileProgress', this, chunk);\n          this.flowObj.fire('progress');\n          this._lastProgressCallback = Date.now();\n          break;\n        case 'error':\n          this.error = true;\n          this.abort(true);\n          this.flowObj.fire('fileError', this, message, chunk);\n          this.flowObj.fire('error', message, this, chunk);\n          break;\n        case 'success':\n          if (this.error) {\n            return;\n          }\n          this.measureSpeed();\n          this.flowObj.fire('fileProgress', this, chunk);\n          this.flowObj.fire('progress');\n          this._lastProgressCallback = Date.now();\n          if (this.isComplete()) {\n            this.currentSpeed = 0;\n            this.averageSpeed = 0;\n            this.flowObj.fire('fileSuccess', this, message, chunk);\n          }\n          break;\n        case 'retry':\n          this.flowObj.fire('fileRetry', this, chunk);\n          break;\n      }\n    }", "code_tokens": ["function", "(", "chunk", ",", "event", ",", "message", ")", "{", "switch", "(", "event", ")", "{", "case", "'progress'", ":", "if", "(", "Date", ".", "now", "(", ")", "-", "this", ".", "_lastProgressCallback", "<", "this", ".", "flowObj", ".", "opts", ".", "progressCallbacksInterval", ")", "{", "break", ";", "}", "this", ".", "measureSpeed", "(", ")", ";", "this", ".", "flowObj", ".", "fire", "(", "'fileProgress'", ",", "this", ",", "chunk", ")", ";", "this", ".", "flowObj", ".", "fire", "(", "'progress'", ")", ";", "this", ".", "_lastProgressCallback", "=", "Date", ".", "now", "(", ")", ";", "break", ";", "case", "'error'", ":", "this", ".", "error", "=", "true", ";", "this", ".", "abort", "(", "true", ")", ";", "this", ".", "flowObj", ".", "fire", "(", "'fileError'", ",", "this", ",", "message", ",", "chunk", ")", ";", "this", ".", "flowObj", ".", "fire", "(", "'error'", ",", "message", ",", "this", ",", "chunk", ")", ";", "break", ";", "case", "'success'", ":", "if", "(", "this", ".", "error", ")", "{", "return", ";", "}", "this", ".", "measureSpeed", "(", ")", ";", "this", ".", "flowObj", ".", "fire", "(", "'fileProgress'", ",", "this", ",", "chunk", ")", ";", "this", ".", "flowObj", ".", "fire", "(", "'progress'", ")", ";", "this", ".", "_lastProgressCallback", "=", "Date", ".", "now", "(", ")", ";", "if", "(", "this", ".", "isComplete", "(", ")", ")", "{", "this", ".", "currentSpeed", "=", "0", ";", "this", ".", "averageSpeed", "=", "0", ";", "this", ".", "flowObj", ".", "fire", "(", "'fileSuccess'", ",", "this", ",", "message", ",", "chunk", ")", ";", "}", "break", ";", "case", "'retry'", ":", "this", ".", "flowObj", ".", "fire", "(", "'fileRetry'", ",", "this", ",", "chunk", ")", ";", "break", ";", "}", "}"], "docstring": "For internal usage only.\nCallback when something happens within the chunk.\n@function\n@param {FlowChunk} chunk\n@param {string} event can be 'progress', 'success', 'error' or 'retry'\n@param {string} [message]", "docstring_tokens": ["For", "internal", "usage", "only", ".", "Callback", "when", "something", "happens", "within", "the", "chunk", "."], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L834-L870", "partition": "test"}
{"repo": "bigpipe/fabricator", "path": "index.js", "func_name": "js", "original_string": "function js(file) {\n  var type = is(file);\n\n  return 'function' === type\n  || 'string' === type && path.extname(file) === '.js';\n}", "language": "javascript", "code": "function js(file) {\n  var type = is(file);\n\n  return 'function' === type\n  || 'string' === type && path.extname(file) === '.js';\n}", "code_tokens": ["function", "js", "(", "file", ")", "{", "var", "type", "=", "is", "(", "file", ")", ";", "return", "'function'", "===", "type", "||", "'string'", "===", "type", "&&", "path", ".", "extname", "(", "file", ")", "===", "'.js'", ";", "}"], "docstring": "Make sure only valid JavaScript files are used as source. Ignore other files,\nlike .log files. Also allow constructors.\n\n@param {String|Function} file Path or constructor function.\n@returns {Boolean} allow entity to be used or not.\n@api private", "docstring_tokens": ["Make", "sure", "only", "valid", "JavaScript", "files", "are", "used", "as", "source", ".", "Ignore", "other", "files", "like", ".", "log", "files", ".", "Also", "allow", "constructors", "."], "sha": "b480885caf5f2367385e981e1a915dda18de2806", "url": "https://github.com/bigpipe/fabricator/blob/b480885caf5f2367385e981e1a915dda18de2806/index.js#L151-L156", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "spec/cordova/fixtures/platforms/cordova-browser/cordova-js-src/platform.js", "func_name": "", "original_string": "function() {\n\n        var modulemapper = require('cordova/modulemapper');\n        var channel = require('cordova/channel');\n\n        modulemapper.clobbers('cordova/exec/proxy', 'cordova.commandProxy');\n\n        channel.onNativeReady.fire();\n\n        document.addEventListener(\"visibilitychange\", function(){\n            if(document.hidden) {\n                channel.onPause.fire();\n            }\n            else {\n                channel.onResume.fire();\n            }\n        });\n\n    // End of bootstrap\n    }", "language": "javascript", "code": "function() {\n\n        var modulemapper = require('cordova/modulemapper');\n        var channel = require('cordova/channel');\n\n        modulemapper.clobbers('cordova/exec/proxy', 'cordova.commandProxy');\n\n        channel.onNativeReady.fire();\n\n        document.addEventListener(\"visibilitychange\", function(){\n            if(document.hidden) {\n                channel.onPause.fire();\n            }\n            else {\n                channel.onResume.fire();\n            }\n        });\n\n    // End of bootstrap\n    }", "code_tokens": ["function", "(", ")", "{", "var", "modulemapper", "=", "require", "(", "'cordova/modulemapper'", ")", ";", "var", "channel", "=", "require", "(", "'cordova/channel'", ")", ";", "modulemapper", ".", "clobbers", "(", "'cordova/exec/proxy'", ",", "'cordova.commandProxy'", ")", ";", "channel", ".", "onNativeReady", ".", "fire", "(", ")", ";", "document", ".", "addEventListener", "(", "\"visibilitychange\"", ",", "function", "(", ")", "{", "if", "(", "document", ".", "hidden", ")", "{", "channel", ".", "onPause", ".", "fire", "(", ")", ";", "}", "else", "{", "channel", ".", "onResume", ".", "fire", "(", ")", ";", "}", "}", ")", ";", "// End of bootstrap", "}"], "docstring": "cordova-js", "docstring_tokens": ["cordova", "-", "js"], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/spec/cordova/fixtures/platforms/cordova-browser/cordova-js-src/platform.js#L26-L45", "partition": "test"}
{"repo": "JedWatson/asyncdi", "path": "index.js", "func_name": "each", "original_string": "function each(arr, callback) {\n\t\tvar wrapper = this;\n\t\tif (this.isAsync) {\n\t\t\treturn async.each(arr, function(item, cb) {\n\t\t\t\twrapper.call(item, cb);\n\t\t\t}, callback);\n\t\t} else {\n\t\t\tarr.each(function(item) {\n\t\t\t\twrapper.call(item);\n\t\t\t});\n\t\t\tif (callback) { callback(); }\n\t\t}\n\t}", "language": "javascript", "code": "function each(arr, callback) {\n\t\tvar wrapper = this;\n\t\tif (this.isAsync) {\n\t\t\treturn async.each(arr, function(item, cb) {\n\t\t\t\twrapper.call(item, cb);\n\t\t\t}, callback);\n\t\t} else {\n\t\t\tarr.each(function(item) {\n\t\t\t\twrapper.call(item);\n\t\t\t});\n\t\t\tif (callback) { callback(); }\n\t\t}\n\t}", "code_tokens": ["function", "each", "(", "arr", ",", "callback", ")", "{", "var", "wrapper", "=", "this", ";", "if", "(", "this", ".", "isAsync", ")", "{", "return", "async", ".", "each", "(", "arr", ",", "function", "(", "item", ",", "cb", ")", "{", "wrapper", ".", "call", "(", "item", ",", "cb", ")", ";", "}", ",", "callback", ")", ";", "}", "else", "{", "arr", ".", "each", "(", "function", "(", "item", ")", "{", "wrapper", ".", "call", "(", "item", ")", ";", "}", ")", ";", "if", "(", "callback", ")", "{", "callback", "(", ")", ";", "}", "}", "}"], "docstring": "Applies the function iterator to each item in arr, in parallel.\n\nThe context of the function will be the current item in the array.\n\n@param  {Array} arr\n@param  {Function} callback", "docstring_tokens": ["Applies", "the", "function", "iterator", "to", "each", "item", "in", "arr", "in", "parallel", "."], "sha": "4e9dd53ded83b65fc96f07fd9347931a1c82b302", "url": "https://github.com/JedWatson/asyncdi/blob/4e9dd53ded83b65fc96f07fd9347931a1c82b302/index.js#L161-L173", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/core/utils/Url.js", "func_name": "", "original_string": "function(url) {\n\t\tfunction origin(url) {\n\t\t\treturn [url.scheme, url.host, url.port].join('/');\n\t\t}\n\n\t\tif (typeof url === 'string') {\n\t\t\turl = parseUrl(url);\n\t\t}\n\n\t\treturn origin(parseUrl()) === origin(url);\n\t}", "language": "javascript", "code": "function(url) {\n\t\tfunction origin(url) {\n\t\t\treturn [url.scheme, url.host, url.port].join('/');\n\t\t}\n\n\t\tif (typeof url === 'string') {\n\t\t\turl = parseUrl(url);\n\t\t}\n\n\t\treturn origin(parseUrl()) === origin(url);\n\t}", "code_tokens": ["function", "(", "url", ")", "{", "function", "origin", "(", "url", ")", "{", "return", "[", "url", ".", "scheme", ",", "url", ".", "host", ",", "url", ".", "port", "]", ".", "join", "(", "'/'", ")", ";", "}", "if", "(", "typeof", "url", "===", "'string'", ")", "{", "url", "=", "parseUrl", "(", "url", ")", ";", "}", "return", "origin", "(", "parseUrl", "(", ")", ")", "===", "origin", "(", "url", ")", ";", "}"], "docstring": "Check if specified url has the same origin as the current document\n\n@method hasSameOrigin\n@static\n@param {String|Object} url\n@return {Boolean}", "docstring_tokens": ["Check", "if", "specified", "url", "has", "the", "same", "origin", "as", "the", "current", "document"], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Url.js#L127-L137", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(hash, type, record, options) {\n    hash[type.typeKey] = this.serialize(record, options);\n  }", "language": "javascript", "code": "function(hash, type, record, options) {\n    hash[type.typeKey] = this.serialize(record, options);\n  }", "code_tokens": ["function", "(", "hash", ",", "type", ",", "record", ",", "options", ")", "{", "hash", "[", "type", ".", "typeKey", "]", "=", "this", ".", "serialize", "(", "record", ",", "options", ")", ";", "}"], "docstring": "You can use this method to customize the root keys serialized into the JSON.\nBy default the REST Serializer sends camelized root keys.\nFor example, your server may expect underscored root objects.\n\n```js\nApp.ApplicationSerializer = DS.RESTSerializer.extend({\nserializeIntoHash: function(data, type, record, options) {\nvar root = Ember.String.decamelize(type.typeKey);\ndata[root] = this.serialize(record, options);\n}\n});\n```\n\n@method serializeIntoHash\n@param {Object} hash\n@param {subclass of DS.Model} type\n@param {DS.Model} record\n@param {Object} options", "docstring_tokens": ["You", "can", "use", "this", "method", "to", "customize", "the", "root", "keys", "serialized", "into", "the", "JSON", ".", "By", "default", "the", "REST", "Serializer", "sends", "camelized", "root", "keys", ".", "For", "example", "your", "server", "may", "expect", "underscored", "root", "objects", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L8984-L8986", "partition": "test"}
{"repo": "codemanki/cloudscraper", "path": "index.js", "func_name": "performRequest", "original_string": "function performRequest (options, isFirstRequest) {\n  // This should be the default export of either request or request-promise.\n  const requester = options.requester;\n\n  // Note that request is always an instanceof ReadableStream, EventEmitter\n  // If the requester is request-promise, it is also thenable.\n  const request = requester(options);\n\n  // We must define the host header ourselves to preserve case and order.\n  if (request.getHeader('host') === HOST) {\n    request.setHeader('host', request.uri.host);\n  }\n\n  // If the requester is not request-promise, ensure we get a callback.\n  if (typeof request.callback !== 'function') {\n    throw new TypeError('Expected a callback function, got ' +\n        typeof (request.callback) + ' instead.');\n  }\n\n  // We only need the callback from the first request.\n  // The other callbacks can be safely ignored.\n  if (isFirstRequest) {\n    // This should be a user supplied callback or request-promise's callback.\n    // The callback is always wrapped/bound to the request instance.\n    options.callback = request.callback;\n  }\n\n  request.removeAllListeners('error')\n    .once('error', function (error) {\n      onRequestResponse(options, error);\n    });\n\n  request.removeAllListeners('complete')\n    .once('complete', function (response, body) {\n      onRequestResponse(options, null, response, body);\n    });\n\n  // Indicate that this is a cloudscraper request\n  request.cloudscraper = true;\n  return request;\n}", "language": "javascript", "code": "function performRequest (options, isFirstRequest) {\n  // This should be the default export of either request or request-promise.\n  const requester = options.requester;\n\n  // Note that request is always an instanceof ReadableStream, EventEmitter\n  // If the requester is request-promise, it is also thenable.\n  const request = requester(options);\n\n  // We must define the host header ourselves to preserve case and order.\n  if (request.getHeader('host') === HOST) {\n    request.setHeader('host', request.uri.host);\n  }\n\n  // If the requester is not request-promise, ensure we get a callback.\n  if (typeof request.callback !== 'function') {\n    throw new TypeError('Expected a callback function, got ' +\n        typeof (request.callback) + ' instead.');\n  }\n\n  // We only need the callback from the first request.\n  // The other callbacks can be safely ignored.\n  if (isFirstRequest) {\n    // This should be a user supplied callback or request-promise's callback.\n    // The callback is always wrapped/bound to the request instance.\n    options.callback = request.callback;\n  }\n\n  request.removeAllListeners('error')\n    .once('error', function (error) {\n      onRequestResponse(options, error);\n    });\n\n  request.removeAllListeners('complete')\n    .once('complete', function (response, body) {\n      onRequestResponse(options, null, response, body);\n    });\n\n  // Indicate that this is a cloudscraper request\n  request.cloudscraper = true;\n  return request;\n}", "code_tokens": ["function", "performRequest", "(", "options", ",", "isFirstRequest", ")", "{", "// This should be the default export of either request or request-promise.", "const", "requester", "=", "options", ".", "requester", ";", "// Note that request is always an instanceof ReadableStream, EventEmitter", "// If the requester is request-promise, it is also thenable.", "const", "request", "=", "requester", "(", "options", ")", ";", "// We must define the host header ourselves to preserve case and order.", "if", "(", "request", ".", "getHeader", "(", "'host'", ")", "===", "HOST", ")", "{", "request", ".", "setHeader", "(", "'host'", ",", "request", ".", "uri", ".", "host", ")", ";", "}", "// If the requester is not request-promise, ensure we get a callback.", "if", "(", "typeof", "request", ".", "callback", "!==", "'function'", ")", "{", "throw", "new", "TypeError", "(", "'Expected a callback function, got '", "+", "typeof", "(", "request", ".", "callback", ")", "+", "' instead.'", ")", ";", "}", "// We only need the callback from the first request.", "// The other callbacks can be safely ignored.", "if", "(", "isFirstRequest", ")", "{", "// This should be a user supplied callback or request-promise's callback.", "// The callback is always wrapped/bound to the request instance.", "options", ".", "callback", "=", "request", ".", "callback", ";", "}", "request", ".", "removeAllListeners", "(", "'error'", ")", ".", "once", "(", "'error'", ",", "function", "(", "error", ")", "{", "onRequestResponse", "(", "options", ",", "error", ")", ";", "}", ")", ";", "request", ".", "removeAllListeners", "(", "'complete'", ")", ".", "once", "(", "'complete'", ",", "function", "(", "response", ",", "body", ")", "{", "onRequestResponse", "(", "options", ",", "null", ",", "response", ",", "body", ")", ";", "}", ")", ";", "// Indicate that this is a cloudscraper request", "request", ".", "cloudscraper", "=", "true", ";", "return", "request", ";", "}"], "docstring": "This function is wrapped to ensure that we get new options on first call. The options object is reused in subsequent calls when calling it directly.", "docstring_tokens": ["This", "function", "is", "wrapped", "to", "ensure", "that", "we", "get", "new", "options", "on", "first", "call", ".", "The", "options", "object", "is", "reused", "in", "subsequent", "calls", "when", "calling", "it", "directly", "."], "sha": "c5b576af9f918d990d6ccedea07a7e4f837dc88f", "url": "https://github.com/codemanki/cloudscraper/blob/c5b576af9f918d990d6ccedea07a7e4f837dc88f/index.js#L101-L141", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/picker/Date.js", "func_name": "", "original_string": "function(newMonthText, oldMonthText) {\n        var innerItems = this.getInnerItems,\n            ln = innerItems.length,\n            item, i;\n\n        //loop through each of the current items and set the title on the correct slice\n        if (this.initialized) {\n            for (i = 0; i < ln; i++) {\n                item = innerItems[i];\n\n                if ((typeof item.title == \"string\" && item.title == oldMonthText) || (item.title.html == oldMonthText)) {\n                    item.setTitle(newMonthText);\n                }\n            }\n        }\n    }", "language": "javascript", "code": "function(newMonthText, oldMonthText) {\n        var innerItems = this.getInnerItems,\n            ln = innerItems.length,\n            item, i;\n\n        //loop through each of the current items and set the title on the correct slice\n        if (this.initialized) {\n            for (i = 0; i < ln; i++) {\n                item = innerItems[i];\n\n                if ((typeof item.title == \"string\" && item.title == oldMonthText) || (item.title.html == oldMonthText)) {\n                    item.setTitle(newMonthText);\n                }\n            }\n        }\n    }", "code_tokens": ["function", "(", "newMonthText", ",", "oldMonthText", ")", "{", "var", "innerItems", "=", "this", ".", "getInnerItems", ",", "ln", "=", "innerItems", ".", "length", ",", "item", ",", "i", ";", "//loop through each of the current items and set the title on the correct slice", "if", "(", "this", ".", "initialized", ")", "{", "for", "(", "i", "=", "0", ";", "i", "<", "ln", ";", "i", "++", ")", "{", "item", "=", "innerItems", "[", "i", "]", ";", "if", "(", "(", "typeof", "item", ".", "title", "==", "\"string\"", "&&", "item", ".", "title", "==", "oldMonthText", ")", "||", "(", "item", ".", "title", ".", "html", "==", "oldMonthText", ")", ")", "{", "item", ".", "setTitle", "(", "newMonthText", ")", ";", "}", "}", "}", "}"], "docstring": "Updates the monthText configuration", "docstring_tokens": ["Updates", "the", "monthText", "configuration"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/picker/Date.js#L218-L233", "partition": "test"}
{"repo": "McLeopold/JavascriptHtmlr", "path": "bin/htmlr-cli.js", "func_name": "", "original_string": "function (fn, rate) {\n  var allowed = true;\n  return function () {\n    if (allowed) {\n      allowed = false;\n      fn.apply(null, [].slice.call(arguments, 0));\n      setTimeout(function () {\n        allowed = true;\n      }, rate);\n    }\n  }\n}", "language": "javascript", "code": "function (fn, rate) {\n  var allowed = true;\n  return function () {\n    if (allowed) {\n      allowed = false;\n      fn.apply(null, [].slice.call(arguments, 0));\n      setTimeout(function () {\n        allowed = true;\n      }, rate);\n    }\n  }\n}", "code_tokens": ["function", "(", "fn", ",", "rate", ")", "{", "var", "allowed", "=", "true", ";", "return", "function", "(", ")", "{", "if", "(", "allowed", ")", "{", "allowed", "=", "false", ";", "fn", ".", "apply", "(", "null", ",", "[", "]", ".", "slice", ".", "call", "(", "arguments", ",", "0", ")", ")", ";", "setTimeout", "(", "function", "(", ")", "{", "allowed", "=", "true", ";", "}", ",", "rate", ")", ";", "}", "}", "}"], "docstring": "used to fix fs.watch on windows triggering cascading events the function fn can only be called once per rate", "docstring_tokens": ["used", "to", "fix", "fs", ".", "watch", "on", "windows", "triggering", "cascading", "events", "the", "function", "fn", "can", "only", "be", "called", "once", "per", "rate"], "sha": "2ebf10ef34ba57dc102a7055ce56ceefe2a6a67a", "url": "https://github.com/McLeopold/JavascriptHtmlr/blob/2ebf10ef34ba57dc102a7055ce56ceefe2a6a67a/bin/htmlr-cli.js#L20-L31", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "findEnclosingNode", "original_string": "function findEnclosingNode(range, sourceFile) {\n            return find(sourceFile);\n            function find(n) {\n                var candidate = ts.forEachChild(n, function (c) { return ts.startEndContainsRange(c.getStart(sourceFile), c.end, range) && c; });\n                if (candidate) {\n                    var result = find(candidate);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return n;\n            }\n        }", "language": "javascript", "code": "function findEnclosingNode(range, sourceFile) {\n            return find(sourceFile);\n            function find(n) {\n                var candidate = ts.forEachChild(n, function (c) { return ts.startEndContainsRange(c.getStart(sourceFile), c.end, range) && c; });\n                if (candidate) {\n                    var result = find(candidate);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return n;\n            }\n        }", "code_tokens": ["function", "findEnclosingNode", "(", "range", ",", "sourceFile", ")", "{", "return", "find", "(", "sourceFile", ")", ";", "function", "find", "(", "n", ")", "{", "var", "candidate", "=", "ts", ".", "forEachChild", "(", "n", ",", "function", "(", "c", ")", "{", "return", "ts", ".", "startEndContainsRange", "(", "c", ".", "getStart", "(", "sourceFile", ")", ",", "c", ".", "end", ",", "range", ")", "&&", "c", ";", "}", ")", ";", "if", "(", "candidate", ")", "{", "var", "result", "=", "find", "(", "candidate", ")", ";", "if", "(", "result", ")", "{", "return", "result", ";", "}", "}", "return", "n", ";", "}", "}"], "docstring": "find node that fully contains given text range", "docstring_tokens": ["find", "node", "that", "fully", "contains", "given", "text", "range"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L41529-L41541", "partition": "test"}
{"repo": "nfroidure/swagger-http-router", "path": "src/server.js", "func_name": "initHTTPServer", "original_string": "async function initHTTPServer({\n  ENV = {},\n  HOST = '127.0.0.1',\n  PORT = 8080,\n  MAX_HEADERS_COUNT = 800,\n  KEEP_ALIVE_TIMEOUT = ms('5m'),\n  TIMEOUT = ms('2m'),\n  MAX_CONNECTIONS,\n  httpRouter,\n  log = noop,\n}) {\n  const sockets = ENV.DESTROY_SOCKETS ? new Set() : {}.undef;\n  const httpServer = http.createServer(httpRouter);\n  const listenPromise = new Promise(resolve => {\n    httpServer.listen(PORT, HOST, () => {\n      log('info', `HTTP Server listening at \"http://${HOST}:${PORT}\".`);\n      resolve(httpServer);\n    });\n  });\n  const errorPromise = new Promise((resolve, reject) => {\n    httpServer.once('error', reject);\n  });\n\n  httpServer.timeout = TIMEOUT;\n  httpServer.keepAliveTimeout = KEEP_ALIVE_TIMEOUT;\n  httpServer.maxHeadersCount = MAX_HEADERS_COUNT;\n  httpServer.maxConnections = MAX_CONNECTIONS;\n\n  if ('undefined' !== typeof MAX_CONNECTIONS) {\n    httpServer.maxConnections = MAX_CONNECTIONS;\n  }\n\n  if (ENV.DESTROY_SOCKETS) {\n    httpServer.on('connection', socket => {\n      sockets.add(socket);\n      socket.on('close', () => {\n        sockets.delete(socket);\n      });\n    });\n  }\n\n  return Promise.race([listenPromise, errorPromise]).then(() => ({\n    service: httpServer,\n    errorPromise,\n    dispose: () =>\n      new Promise((resolve, reject) => {\n        log('debug', 'Closing HTTP server.');\n        // Avoid to keepalive connections on shutdown\n        httpServer.timeout = 1;\n        httpServer.keepAliveTimeout = 1;\n        httpServer.close(err => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          log('debug', 'HTTP server closed');\n          resolve();\n        });\n        if (ENV.DESTROY_SOCKETS) {\n          for (const socket of sockets.values()) {\n            socket.destroy();\n          }\n        }\n      }),\n  }));\n}", "language": "javascript", "code": "async function initHTTPServer({\n  ENV = {},\n  HOST = '127.0.0.1',\n  PORT = 8080,\n  MAX_HEADERS_COUNT = 800,\n  KEEP_ALIVE_TIMEOUT = ms('5m'),\n  TIMEOUT = ms('2m'),\n  MAX_CONNECTIONS,\n  httpRouter,\n  log = noop,\n}) {\n  const sockets = ENV.DESTROY_SOCKETS ? new Set() : {}.undef;\n  const httpServer = http.createServer(httpRouter);\n  const listenPromise = new Promise(resolve => {\n    httpServer.listen(PORT, HOST, () => {\n      log('info', `HTTP Server listening at \"http://${HOST}:${PORT}\".`);\n      resolve(httpServer);\n    });\n  });\n  const errorPromise = new Promise((resolve, reject) => {\n    httpServer.once('error', reject);\n  });\n\n  httpServer.timeout = TIMEOUT;\n  httpServer.keepAliveTimeout = KEEP_ALIVE_TIMEOUT;\n  httpServer.maxHeadersCount = MAX_HEADERS_COUNT;\n  httpServer.maxConnections = MAX_CONNECTIONS;\n\n  if ('undefined' !== typeof MAX_CONNECTIONS) {\n    httpServer.maxConnections = MAX_CONNECTIONS;\n  }\n\n  if (ENV.DESTROY_SOCKETS) {\n    httpServer.on('connection', socket => {\n      sockets.add(socket);\n      socket.on('close', () => {\n        sockets.delete(socket);\n      });\n    });\n  }\n\n  return Promise.race([listenPromise, errorPromise]).then(() => ({\n    service: httpServer,\n    errorPromise,\n    dispose: () =>\n      new Promise((resolve, reject) => {\n        log('debug', 'Closing HTTP server.');\n        // Avoid to keepalive connections on shutdown\n        httpServer.timeout = 1;\n        httpServer.keepAliveTimeout = 1;\n        httpServer.close(err => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          log('debug', 'HTTP server closed');\n          resolve();\n        });\n        if (ENV.DESTROY_SOCKETS) {\n          for (const socket of sockets.values()) {\n            socket.destroy();\n          }\n        }\n      }),\n  }));\n}", "code_tokens": ["async", "function", "initHTTPServer", "(", "{", "ENV", "=", "{", "}", ",", "HOST", "=", "'127.0.0.1'", ",", "PORT", "=", "8080", ",", "MAX_HEADERS_COUNT", "=", "800", ",", "KEEP_ALIVE_TIMEOUT", "=", "ms", "(", "'5m'", ")", ",", "TIMEOUT", "=", "ms", "(", "'2m'", ")", ",", "MAX_CONNECTIONS", ",", "httpRouter", ",", "log", "=", "noop", ",", "}", ")", "{", "const", "sockets", "=", "ENV", ".", "DESTROY_SOCKETS", "?", "new", "Set", "(", ")", ":", "{", "}", ".", "undef", ";", "const", "httpServer", "=", "http", ".", "createServer", "(", "httpRouter", ")", ";", "const", "listenPromise", "=", "new", "Promise", "(", "resolve", "=>", "{", "httpServer", ".", "listen", "(", "PORT", ",", "HOST", ",", "(", ")", "=>", "{", "log", "(", "'info'", ",", "`", "${", "HOST", "}", "${", "PORT", "}", "`", ")", ";", "resolve", "(", "httpServer", ")", ";", "}", ")", ";", "}", ")", ";", "const", "errorPromise", "=", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "httpServer", ".", "once", "(", "'error'", ",", "reject", ")", ";", "}", ")", ";", "httpServer", ".", "timeout", "=", "TIMEOUT", ";", "httpServer", ".", "keepAliveTimeout", "=", "KEEP_ALIVE_TIMEOUT", ";", "httpServer", ".", "maxHeadersCount", "=", "MAX_HEADERS_COUNT", ";", "httpServer", ".", "maxConnections", "=", "MAX_CONNECTIONS", ";", "if", "(", "'undefined'", "!==", "typeof", "MAX_CONNECTIONS", ")", "{", "httpServer", ".", "maxConnections", "=", "MAX_CONNECTIONS", ";", "}", "if", "(", "ENV", ".", "DESTROY_SOCKETS", ")", "{", "httpServer", ".", "on", "(", "'connection'", ",", "socket", "=>", "{", "sockets", ".", "add", "(", "socket", ")", ";", "socket", ".", "on", "(", "'close'", ",", "(", ")", "=>", "{", "sockets", ".", "delete", "(", "socket", ")", ";", "}", ")", ";", "}", ")", ";", "}", "return", "Promise", ".", "race", "(", "[", "listenPromise", ",", "errorPromise", "]", ")", ".", "then", "(", "(", ")", "=>", "(", "{", "service", ":", "httpServer", ",", "errorPromise", ",", "dispose", ":", "(", ")", "=>", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "log", "(", "'debug'", ",", "'Closing HTTP server.'", ")", ";", "// Avoid to keepalive connections on shutdown", "httpServer", ".", "timeout", "=", "1", ";", "httpServer", ".", "keepAliveTimeout", "=", "1", ";", "httpServer", ".", "close", "(", "err", "=>", "{", "if", "(", "err", ")", "{", "reject", "(", "err", ")", ";", "return", ";", "}", "log", "(", "'debug'", ",", "'HTTP server closed'", ")", ";", "resolve", "(", ")", ";", "}", ")", ";", "if", "(", "ENV", ".", "DESTROY_SOCKETS", ")", "{", "for", "(", "const", "socket", "of", "sockets", ".", "values", "(", ")", ")", "{", "socket", ".", "destroy", "(", ")", ";", "}", "}", "}", ")", ",", "}", ")", ")", ";", "}"], "docstring": "Initialize an HTTP server\n@param  {Object}   services\nThe services the server depends on\n@param  {Object}   services.ENV\nThe process environment variables\n@param  {Object}   services.HOST\nThe server host\n@param  {Object}   services.PORT\nThe server port\n@param  {Object}   services.MAX_HEADERS_COUNT\nThe https://nodejs.org/api/http.html#http_server_maxheaderscount\n@param  {Object}   services.KEEP_ALIVE_TIMEOUT\nSee https://nodejs.org/api/http.html#http_server_keepalivetimeout\n@param  {Object}   services.MAX_CONNECTIONS\nSee https://nodejs.org/api/net.html#net_server_maxconnections\n@param  {Object}   services.TIMEOUT\nSee https://nodejs.org/api/http.html#http_server_timeout\n@param  {Function} services.httpRouter\nThe function to run with the req/res tuple\n@param  {Function} [services.log=noop]\nA logging function\n@return {Promise}\nA promise of an object with a NodeJS HTTP server\nin its `service` property.", "docstring_tokens": ["Initialize", "an", "HTTP", "server"], "sha": "298e38c99170dc50c229cf922ebc801d19b03144", "url": "https://github.com/nfroidure/swagger-http-router/blob/298e38c99170dc50c229cf922ebc801d19b03144/src/server.js#L56-L121", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/field/DatePicker.js", "func_name": "", "original_string": "function(newDateFormat, oldDateFormat) {\n        var value = this.getValue();\n        if (newDateFormat != oldDateFormat && Ext.isDate(value)) {\n            this.getComponent().setValue(Ext.Date.format(value, newDateFormat || Ext.util.Format.defaultDateFormat));\n        }\n    }", "language": "javascript", "code": "function(newDateFormat, oldDateFormat) {\n        var value = this.getValue();\n        if (newDateFormat != oldDateFormat && Ext.isDate(value)) {\n            this.getComponent().setValue(Ext.Date.format(value, newDateFormat || Ext.util.Format.defaultDateFormat));\n        }\n    }", "code_tokens": ["function", "(", "newDateFormat", ",", "oldDateFormat", ")", "{", "var", "value", "=", "this", ".", "getValue", "(", ")", ";", "if", "(", "newDateFormat", "!=", "oldDateFormat", "&&", "Ext", ".", "isDate", "(", "value", ")", ")", "{", "this", ".", "getComponent", "(", ")", ".", "setValue", "(", "Ext", ".", "Date", ".", "format", "(", "value", ",", "newDateFormat", "||", "Ext", ".", "util", ".", "Format", ".", "defaultDateFormat", ")", ")", ";", "}", "}"], "docstring": "Updates the date format in the field.\n@private", "docstring_tokens": ["Updates", "the", "date", "format", "in", "the", "field", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/field/DatePicker.js#L230-L235", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/pannellum.js", "func_name": "renderHotSpot", "original_string": "function renderHotSpot(hs) {\n    var hsPitchSin = Math.sin(hs.pitch * Math.PI / 180),\n        hsPitchCos = Math.cos(hs.pitch * Math.PI / 180),\n        configPitchSin = Math.sin(config.pitch * Math.PI / 180),\n        configPitchCos = Math.cos(config.pitch * Math.PI / 180),\n        yawCos = Math.cos((-hs.yaw + config.yaw) * Math.PI / 180);\n    var z = hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos;\n    if ((hs.yaw <= 90 && hs.yaw > -90 && z <= 0) ||\n      ((hs.yaw > 90 || hs.yaw <= -90) && z <= 0)) {\n        hs.div.style.visibility = 'hidden';\n    } else {\n        var yawSin = Math.sin((-hs.yaw + config.yaw) * Math.PI / 180),\n            hfovTan = Math.tan(config.hfov * Math.PI / 360);\n        hs.div.style.visibility = 'visible';\n        // Subpixel rendering doesn't work in Firefox\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=739176\n        var canvas = renderer.getCanvas(),\n            canvasWidth = canvas.clientWidth,\n            canvasHeight = canvas.clientHeight;\n        var coord = [-canvasWidth / hfovTan * yawSin * hsPitchCos / z / 2,\n            -canvasWidth / hfovTan * (hsPitchSin * configPitchCos -\n            hsPitchCos * yawCos * configPitchSin) / z / 2];\n        // Apply roll\n        var rollSin = Math.sin(config.roll * Math.PI / 180),\n            rollCos = Math.cos(config.roll * Math.PI / 180);\n        coord = [coord[0] * rollCos - coord[1] * rollSin,\n                 coord[0] * rollSin + coord[1] * rollCos];\n        // Apply transform\n        coord[0] += (canvasWidth - hs.div.offsetWidth) / 2;\n        coord[1] += (canvasHeight - hs.div.offsetHeight) / 2;\n        var transform = 'translate(' + coord[0] + 'px, ' + coord[1] +\n            'px) translateZ(9999px) rotate(' + config.roll + 'deg)';\n        hs.div.style.webkitTransform = transform;\n        hs.div.style.MozTransform = transform;\n        hs.div.style.transform = transform;\n    }\n}", "language": "javascript", "code": "function renderHotSpot(hs) {\n    var hsPitchSin = Math.sin(hs.pitch * Math.PI / 180),\n        hsPitchCos = Math.cos(hs.pitch * Math.PI / 180),\n        configPitchSin = Math.sin(config.pitch * Math.PI / 180),\n        configPitchCos = Math.cos(config.pitch * Math.PI / 180),\n        yawCos = Math.cos((-hs.yaw + config.yaw) * Math.PI / 180);\n    var z = hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos;\n    if ((hs.yaw <= 90 && hs.yaw > -90 && z <= 0) ||\n      ((hs.yaw > 90 || hs.yaw <= -90) && z <= 0)) {\n        hs.div.style.visibility = 'hidden';\n    } else {\n        var yawSin = Math.sin((-hs.yaw + config.yaw) * Math.PI / 180),\n            hfovTan = Math.tan(config.hfov * Math.PI / 360);\n        hs.div.style.visibility = 'visible';\n        // Subpixel rendering doesn't work in Firefox\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=739176\n        var canvas = renderer.getCanvas(),\n            canvasWidth = canvas.clientWidth,\n            canvasHeight = canvas.clientHeight;\n        var coord = [-canvasWidth / hfovTan * yawSin * hsPitchCos / z / 2,\n            -canvasWidth / hfovTan * (hsPitchSin * configPitchCos -\n            hsPitchCos * yawCos * configPitchSin) / z / 2];\n        // Apply roll\n        var rollSin = Math.sin(config.roll * Math.PI / 180),\n            rollCos = Math.cos(config.roll * Math.PI / 180);\n        coord = [coord[0] * rollCos - coord[1] * rollSin,\n                 coord[0] * rollSin + coord[1] * rollCos];\n        // Apply transform\n        coord[0] += (canvasWidth - hs.div.offsetWidth) / 2;\n        coord[1] += (canvasHeight - hs.div.offsetHeight) / 2;\n        var transform = 'translate(' + coord[0] + 'px, ' + coord[1] +\n            'px) translateZ(9999px) rotate(' + config.roll + 'deg)';\n        hs.div.style.webkitTransform = transform;\n        hs.div.style.MozTransform = transform;\n        hs.div.style.transform = transform;\n    }\n}", "code_tokens": ["function", "renderHotSpot", "(", "hs", ")", "{", "var", "hsPitchSin", "=", "Math", ".", "sin", "(", "hs", ".", "pitch", "*", "Math", ".", "PI", "/", "180", ")", ",", "hsPitchCos", "=", "Math", ".", "cos", "(", "hs", ".", "pitch", "*", "Math", ".", "PI", "/", "180", ")", ",", "configPitchSin", "=", "Math", ".", "sin", "(", "config", ".", "pitch", "*", "Math", ".", "PI", "/", "180", ")", ",", "configPitchCos", "=", "Math", ".", "cos", "(", "config", ".", "pitch", "*", "Math", ".", "PI", "/", "180", ")", ",", "yawCos", "=", "Math", ".", "cos", "(", "(", "-", "hs", ".", "yaw", "+", "config", ".", "yaw", ")", "*", "Math", ".", "PI", "/", "180", ")", ";", "var", "z", "=", "hsPitchSin", "*", "configPitchSin", "+", "hsPitchCos", "*", "yawCos", "*", "configPitchCos", ";", "if", "(", "(", "hs", ".", "yaw", "<=", "90", "&&", "hs", ".", "yaw", ">", "-", "90", "&&", "z", "<=", "0", ")", "||", "(", "(", "hs", ".", "yaw", ">", "90", "||", "hs", ".", "yaw", "<=", "-", "90", ")", "&&", "z", "<=", "0", ")", ")", "{", "hs", ".", "div", ".", "style", ".", "visibility", "=", "'hidden'", ";", "}", "else", "{", "var", "yawSin", "=", "Math", ".", "sin", "(", "(", "-", "hs", ".", "yaw", "+", "config", ".", "yaw", ")", "*", "Math", ".", "PI", "/", "180", ")", ",", "hfovTan", "=", "Math", ".", "tan", "(", "config", ".", "hfov", "*", "Math", ".", "PI", "/", "360", ")", ";", "hs", ".", "div", ".", "style", ".", "visibility", "=", "'visible'", ";", "// Subpixel rendering doesn't work in Firefox", "// https://bugzilla.mozilla.org/show_bug.cgi?id=739176", "var", "canvas", "=", "renderer", ".", "getCanvas", "(", ")", ",", "canvasWidth", "=", "canvas", ".", "clientWidth", ",", "canvasHeight", "=", "canvas", ".", "clientHeight", ";", "var", "coord", "=", "[", "-", "canvasWidth", "/", "hfovTan", "*", "yawSin", "*", "hsPitchCos", "/", "z", "/", "2", ",", "-", "canvasWidth", "/", "hfovTan", "*", "(", "hsPitchSin", "*", "configPitchCos", "-", "hsPitchCos", "*", "yawCos", "*", "configPitchSin", ")", "/", "z", "/", "2", "]", ";", "// Apply roll", "var", "rollSin", "=", "Math", ".", "sin", "(", "config", ".", "roll", "*", "Math", ".", "PI", "/", "180", ")", ",", "rollCos", "=", "Math", ".", "cos", "(", "config", ".", "roll", "*", "Math", ".", "PI", "/", "180", ")", ";", "coord", "=", "[", "coord", "[", "0", "]", "*", "rollCos", "-", "coord", "[", "1", "]", "*", "rollSin", ",", "coord", "[", "0", "]", "*", "rollSin", "+", "coord", "[", "1", "]", "*", "rollCos", "]", ";", "// Apply transform", "coord", "[", "0", "]", "+=", "(", "canvasWidth", "-", "hs", ".", "div", ".", "offsetWidth", ")", "/", "2", ";", "coord", "[", "1", "]", "+=", "(", "canvasHeight", "-", "hs", ".", "div", ".", "offsetHeight", ")", "/", "2", ";", "var", "transform", "=", "'translate('", "+", "coord", "[", "0", "]", "+", "'px, '", "+", "coord", "[", "1", "]", "+", "'px) translateZ(9999px) rotate('", "+", "config", ".", "roll", "+", "'deg)'", ";", "hs", ".", "div", ".", "style", ".", "webkitTransform", "=", "transform", ";", "hs", ".", "div", ".", "style", ".", "MozTransform", "=", "transform", ";", "hs", ".", "div", ".", "style", ".", "transform", "=", "transform", ";", "}", "}"], "docstring": "Renders hot spot, updating its position and visibility.\n@private", "docstring_tokens": ["Renders", "hot", "spot", "updating", "its", "position", "and", "visibility", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/pannellum.js#L1802-L1838", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "onResize", "original_string": "function onResize()\n   {\n      // Update graph parameters.\n      graphWidth = window.innerWidth;\n      graphHeight = window.innerHeight;\n\n      graph.attr('width', graphWidth).attr('height', graphHeight);\n\n      layout.size([graphWidth, graphHeight]).resume();\n\n      updateMenuUI();\n\n      updateTableUIExtent();\n\n      // Hides any existing node context menu.\n      hideNodeContextMenu();\n\n      centerGraph(zoomFit, 1000, data.allNodesFixed ? 0 : 2000);\n   }", "language": "javascript", "code": "function onResize()\n   {\n      // Update graph parameters.\n      graphWidth = window.innerWidth;\n      graphHeight = window.innerHeight;\n\n      graph.attr('width', graphWidth).attr('height', graphHeight);\n\n      layout.size([graphWidth, graphHeight]).resume();\n\n      updateMenuUI();\n\n      updateTableUIExtent();\n\n      // Hides any existing node context menu.\n      hideNodeContextMenu();\n\n      centerGraph(zoomFit, 1000, data.allNodesFixed ? 0 : 2000);\n   }", "code_tokens": ["function", "onResize", "(", ")", "{", "// Update graph parameters.", "graphWidth", "=", "window", ".", "innerWidth", ";", "graphHeight", "=", "window", ".", "innerHeight", ";", "graph", ".", "attr", "(", "'width'", ",", "graphWidth", ")", ".", "attr", "(", "'height'", ",", "graphHeight", ")", ";", "layout", ".", "size", "(", "[", "graphWidth", ",", "graphHeight", "]", ")", ".", "resume", "(", ")", ";", "updateMenuUI", "(", ")", ";", "updateTableUIExtent", "(", ")", ";", "// Hides any existing node context menu.", "hideNodeContextMenu", "(", ")", ";", "centerGraph", "(", "zoomFit", ",", "1000", ",", "data", ".", "allNodesFixed", "?", "0", ":", "2000", ")", ";", "}"], "docstring": "Handles the window resize event.", "docstring_tokens": ["Handles", "the", "window", "resize", "event", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L774-L792", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "", "original_string": "function() {\n    var parsed = this.parsed;\n    var len = this.types.length;\n    var idx = -1;\n    var tok;\n\n    while (++idx < len) {\n      if ((tok = this.parsers[this.types[idx]].call(this))) {\n        define(tok, 'rest', this.input);\n        define(tok, 'parsed', parsed);\n        this.last = tok;\n        return tok;\n      }\n    }\n  }", "language": "javascript", "code": "function() {\n    var parsed = this.parsed;\n    var len = this.types.length;\n    var idx = -1;\n    var tok;\n\n    while (++idx < len) {\n      if ((tok = this.parsers[this.types[idx]].call(this))) {\n        define(tok, 'rest', this.input);\n        define(tok, 'parsed', parsed);\n        this.last = tok;\n        return tok;\n      }\n    }\n  }", "code_tokens": ["function", "(", ")", "{", "var", "parsed", "=", "this", ".", "parsed", ";", "var", "len", "=", "this", ".", "types", ".", "length", ";", "var", "idx", "=", "-", "1", ";", "var", "tok", ";", "while", "(", "++", "idx", "<", "len", ")", "{", "if", "(", "(", "tok", "=", "this", ".", "parsers", "[", "this", ".", "types", "[", "idx", "]", "]", ".", "call", "(", "this", ")", ")", ")", "{", "define", "(", "tok", ",", "'rest'", ",", "this", ".", "input", ")", ";", "define", "(", "tok", ",", "'parsed'", ",", "parsed", ")", ";", "this", ".", "last", "=", "tok", ";", "return", "tok", ";", "}", "}", "}"], "docstring": "Run parsers to advance the cursor position", "docstring_tokens": ["Run", "parsers", "to", "advance", "the", "cursor", "position"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L65059-L65073", "partition": "test"}
{"repo": "akshaylive/live.io", "path": "example/ChatExample/public/modules/core/services/menus.client.service.js", "func_name": "", "original_string": "function(user) {\n\t\t\tif (user) {\n\t\t\t\tif (!!~this.roles.indexOf('*')) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tfor (var userRoleIndex in user.roles) {\n\t\t\t\t\t\tfor (var roleIndex in this.roles) {\n\t\t\t\t\t\t\tif (this.roles[roleIndex] === user.roles[userRoleIndex]) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this.isPublic;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}", "language": "javascript", "code": "function(user) {\n\t\t\tif (user) {\n\t\t\t\tif (!!~this.roles.indexOf('*')) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tfor (var userRoleIndex in user.roles) {\n\t\t\t\t\t\tfor (var roleIndex in this.roles) {\n\t\t\t\t\t\t\tif (this.roles[roleIndex] === user.roles[userRoleIndex]) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this.isPublic;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}", "code_tokens": ["function", "(", "user", ")", "{", "if", "(", "user", ")", "{", "if", "(", "!", "!", "~", "this", ".", "roles", ".", "indexOf", "(", "'*'", ")", ")", "{", "return", "true", ";", "}", "else", "{", "for", "(", "var", "userRoleIndex", "in", "user", ".", "roles", ")", "{", "for", "(", "var", "roleIndex", "in", "this", ".", "roles", ")", "{", "if", "(", "this", ".", "roles", "[", "roleIndex", "]", "===", "user", ".", "roles", "[", "userRoleIndex", "]", ")", "{", "return", "true", ";", "}", "}", "}", "}", "}", "else", "{", "return", "this", ".", "isPublic", ";", "}", "return", "false", ";", "}"], "docstring": "A private function for rendering decision", "docstring_tokens": ["A", "private", "function", "for", "rendering", "decision"], "sha": "44f68d61eb47d06cef1e2b7bb7d026cd204b72d2", "url": "https://github.com/akshaylive/live.io/blob/44f68d61eb47d06cef1e2b7bb7d026cd204b72d2/example/ChatExample/public/modules/core/services/menus.client.service.js#L14-L32", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "autoSetup", "original_string": "function autoSetup() {\n\n  // Protect against breakage in non-browser environments.\n  if (!isReal()) {\n    return;\n  }\n\n  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*\n  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n  // var mediaEls = vids.concat(audios);\n\n  // Because IE8 doesn't support calling slice on a node list, we need to loop\n  // through each list of elements to build up a new, combined list of elements.\n  var vids = document.getElementsByTagName('video');\n  var audios = document.getElementsByTagName('audio');\n  var mediaEls = [];\n\n  if (vids && vids.length > 0) {\n    for (var i = 0, e = vids.length; i < e; i++) {\n      mediaEls.push(vids[i]);\n    }\n  }\n\n  if (audios && audios.length > 0) {\n    for (var _i = 0, _e = audios.length; _i < _e; _i++) {\n      mediaEls.push(audios[_i]);\n    }\n  }\n\n  // Check if any media elements exist\n  if (mediaEls && mediaEls.length > 0) {\n\n    for (var _i2 = 0, _e2 = mediaEls.length; _i2 < _e2; _i2++) {\n      var mediaEl = mediaEls[_i2];\n\n      // Check if element exists, has getAttribute func.\n      // IE seems to consider typeof el.getAttribute == 'object' instead of\n      // 'function' like expected, at least when loading the player immediately.\n      if (mediaEl && mediaEl.getAttribute) {\n\n        // Make sure this player hasn't already been set up.\n        if (mediaEl.player === undefined) {\n          var options = mediaEl.getAttribute('data-setup');\n\n          // Check if data-setup attr exists.\n          // We only auto-setup if they've added the data-setup attr.\n          if (options !== null) {\n            // Create new video.js instance.\n            videojs$2(mediaEl);\n          }\n        }\n\n        // If getAttribute isn't defined, we need to wait for the DOM.\n      } else {\n        autoSetupTimeout(1);\n        break;\n      }\n    }\n\n    // No videos were found, so keep looping unless page is finished loading.\n  } else if (!_windowLoaded) {\n    autoSetupTimeout(1);\n  }\n}", "language": "javascript", "code": "function autoSetup() {\n\n  // Protect against breakage in non-browser environments.\n  if (!isReal()) {\n    return;\n  }\n\n  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*\n  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n  // var mediaEls = vids.concat(audios);\n\n  // Because IE8 doesn't support calling slice on a node list, we need to loop\n  // through each list of elements to build up a new, combined list of elements.\n  var vids = document.getElementsByTagName('video');\n  var audios = document.getElementsByTagName('audio');\n  var mediaEls = [];\n\n  if (vids && vids.length > 0) {\n    for (var i = 0, e = vids.length; i < e; i++) {\n      mediaEls.push(vids[i]);\n    }\n  }\n\n  if (audios && audios.length > 0) {\n    for (var _i = 0, _e = audios.length; _i < _e; _i++) {\n      mediaEls.push(audios[_i]);\n    }\n  }\n\n  // Check if any media elements exist\n  if (mediaEls && mediaEls.length > 0) {\n\n    for (var _i2 = 0, _e2 = mediaEls.length; _i2 < _e2; _i2++) {\n      var mediaEl = mediaEls[_i2];\n\n      // Check if element exists, has getAttribute func.\n      // IE seems to consider typeof el.getAttribute == 'object' instead of\n      // 'function' like expected, at least when loading the player immediately.\n      if (mediaEl && mediaEl.getAttribute) {\n\n        // Make sure this player hasn't already been set up.\n        if (mediaEl.player === undefined) {\n          var options = mediaEl.getAttribute('data-setup');\n\n          // Check if data-setup attr exists.\n          // We only auto-setup if they've added the data-setup attr.\n          if (options !== null) {\n            // Create new video.js instance.\n            videojs$2(mediaEl);\n          }\n        }\n\n        // If getAttribute isn't defined, we need to wait for the DOM.\n      } else {\n        autoSetupTimeout(1);\n        break;\n      }\n    }\n\n    // No videos were found, so keep looping unless page is finished loading.\n  } else if (!_windowLoaded) {\n    autoSetupTimeout(1);\n  }\n}", "code_tokens": ["function", "autoSetup", "(", ")", "{", "// Protect against breakage in non-browser environments.", "if", "(", "!", "isReal", "(", ")", ")", "{", "return", ";", "}", "// One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*", "// var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));", "// var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));", "// var mediaEls = vids.concat(audios);", "// Because IE8 doesn't support calling slice on a node list, we need to loop", "// through each list of elements to build up a new, combined list of elements.", "var", "vids", "=", "document", ".", "getElementsByTagName", "(", "'video'", ")", ";", "var", "audios", "=", "document", ".", "getElementsByTagName", "(", "'audio'", ")", ";", "var", "mediaEls", "=", "[", "]", ";", "if", "(", "vids", "&&", "vids", ".", "length", ">", "0", ")", "{", "for", "(", "var", "i", "=", "0", ",", "e", "=", "vids", ".", "length", ";", "i", "<", "e", ";", "i", "++", ")", "{", "mediaEls", ".", "push", "(", "vids", "[", "i", "]", ")", ";", "}", "}", "if", "(", "audios", "&&", "audios", ".", "length", ">", "0", ")", "{", "for", "(", "var", "_i", "=", "0", ",", "_e", "=", "audios", ".", "length", ";", "_i", "<", "_e", ";", "_i", "++", ")", "{", "mediaEls", ".", "push", "(", "audios", "[", "_i", "]", ")", ";", "}", "}", "// Check if any media elements exist", "if", "(", "mediaEls", "&&", "mediaEls", ".", "length", ">", "0", ")", "{", "for", "(", "var", "_i2", "=", "0", ",", "_e2", "=", "mediaEls", ".", "length", ";", "_i2", "<", "_e2", ";", "_i2", "++", ")", "{", "var", "mediaEl", "=", "mediaEls", "[", "_i2", "]", ";", "// Check if element exists, has getAttribute func.", "// IE seems to consider typeof el.getAttribute == 'object' instead of", "// 'function' like expected, at least when loading the player immediately.", "if", "(", "mediaEl", "&&", "mediaEl", ".", "getAttribute", ")", "{", "// Make sure this player hasn't already been set up.", "if", "(", "mediaEl", ".", "player", "===", "undefined", ")", "{", "var", "options", "=", "mediaEl", ".", "getAttribute", "(", "'data-setup'", ")", ";", "// Check if data-setup attr exists.", "// We only auto-setup if they've added the data-setup attr.", "if", "(", "options", "!==", "null", ")", "{", "// Create new video.js instance.", "videojs$2", "(", "mediaEl", ")", ";", "}", "}", "// If getAttribute isn't defined, we need to wait for the DOM.", "}", "else", "{", "autoSetupTimeout", "(", "1", ")", ";", "break", ";", "}", "}", "// No videos were found, so keep looping unless page is finished loading.", "}", "else", "if", "(", "!", "_windowLoaded", ")", "{", "autoSetupTimeout", "(", "1", ")", ";", "}", "}"], "docstring": "Set up any tags that have a data-setup `attribute` when the player is started.", "docstring_tokens": ["Set", "up", "any", "tags", "that", "have", "a", "data", "-", "setup", "attribute", "when", "the", "player", "is", "started", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L2004-L2068", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getPropertyOfObjectType", "original_string": "function getPropertyOfObjectType(type, name) {\n            if (type.flags & 80896 /* ObjectType */) {\n                var resolved = resolveStructuredTypeMembers(type);\n                if (ts.hasProperty(resolved.members, name)) {\n                    var symbol = resolved.members[name];\n                    if (symbolIsValue(symbol)) {\n                        return symbol;\n                    }\n                }\n            }\n        }", "language": "javascript", "code": "function getPropertyOfObjectType(type, name) {\n            if (type.flags & 80896 /* ObjectType */) {\n                var resolved = resolveStructuredTypeMembers(type);\n                if (ts.hasProperty(resolved.members, name)) {\n                    var symbol = resolved.members[name];\n                    if (symbolIsValue(symbol)) {\n                        return symbol;\n                    }\n                }\n            }\n        }", "code_tokens": ["function", "getPropertyOfObjectType", "(", "type", ",", "name", ")", "{", "if", "(", "type", ".", "flags", "&", "80896", "/* ObjectType */", ")", "{", "var", "resolved", "=", "resolveStructuredTypeMembers", "(", "type", ")", ";", "if", "(", "ts", ".", "hasProperty", "(", "resolved", ".", "members", ",", "name", ")", ")", "{", "var", "symbol", "=", "resolved", ".", "members", "[", "name", "]", ";", "if", "(", "symbolIsValue", "(", "symbol", ")", ")", "{", "return", "symbol", ";", "}", "}", "}", "}"], "docstring": "If the given type is an object type and that type has a property by the given name, return the symbol for that property.Otherwise return undefined.", "docstring_tokens": ["If", "the", "given", "type", "is", "an", "object", "type", "and", "that", "type", "has", "a", "property", "by", "the", "given", "name", "return", "the", "symbol", "for", "that", "property", ".", "Otherwise", "return", "undefined", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L16449-L16459", "partition": "test"}
{"repo": "localvoid/karma-snapshot", "path": "lib/format/markdown.js", "func_name": "transformSnapshotList", "original_string": "function transformSnapshotList(name, snapshotList, depth, indentCodeBlocks) {\n  let result = snapshotHeader(name, depth);\n\n  for (let i = 0; i < snapshotList.length; i++) {\n    if (i > 0 && indentCodeBlocks) {\n      result += '---\\n\\n';\n    }\n    const snapshot = snapshotList[i];\n    const lang = snapshot.lang;\n    const code = snapshot.code;\n    const delimiter = safeDelimiter(code);\n\n    if (indentCodeBlocks) {\n      const lines = code.split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        result += '    ' + lines[i] + '\\n';\n      }\n    } else {\n      result += delimiter;\n      if (lang) {\n        result += lang;\n      }\n      result += '\\n' + code + '\\n' + delimiter + '\\n';\n    }\n\n    result += '\\n';\n  }\n\n  return result;\n}", "language": "javascript", "code": "function transformSnapshotList(name, snapshotList, depth, indentCodeBlocks) {\n  let result = snapshotHeader(name, depth);\n\n  for (let i = 0; i < snapshotList.length; i++) {\n    if (i > 0 && indentCodeBlocks) {\n      result += '---\\n\\n';\n    }\n    const snapshot = snapshotList[i];\n    const lang = snapshot.lang;\n    const code = snapshot.code;\n    const delimiter = safeDelimiter(code);\n\n    if (indentCodeBlocks) {\n      const lines = code.split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        result += '    ' + lines[i] + '\\n';\n      }\n    } else {\n      result += delimiter;\n      if (lang) {\n        result += lang;\n      }\n      result += '\\n' + code + '\\n' + delimiter + '\\n';\n    }\n\n    result += '\\n';\n  }\n\n  return result;\n}", "code_tokens": ["function", "transformSnapshotList", "(", "name", ",", "snapshotList", ",", "depth", ",", "indentCodeBlocks", ")", "{", "let", "result", "=", "snapshotHeader", "(", "name", ",", "depth", ")", ";", "for", "(", "let", "i", "=", "0", ";", "i", "<", "snapshotList", ".", "length", ";", "i", "++", ")", "{", "if", "(", "i", ">", "0", "&&", "indentCodeBlocks", ")", "{", "result", "+=", "'---\\n\\n'", ";", "}", "const", "snapshot", "=", "snapshotList", "[", "i", "]", ";", "const", "lang", "=", "snapshot", ".", "lang", ";", "const", "code", "=", "snapshot", ".", "code", ";", "const", "delimiter", "=", "safeDelimiter", "(", "code", ")", ";", "if", "(", "indentCodeBlocks", ")", "{", "const", "lines", "=", "code", ".", "split", "(", "'\\n'", ")", ";", "for", "(", "let", "i", "=", "0", ";", "i", "<", "lines", ".", "length", ";", "i", "++", ")", "{", "result", "+=", "'    '", "+", "lines", "[", "i", "]", "+", "'\\n'", ";", "}", "}", "else", "{", "result", "+=", "delimiter", ";", "if", "(", "lang", ")", "{", "result", "+=", "lang", ";", "}", "result", "+=", "'\\n'", "+", "code", "+", "'\\n'", "+", "delimiter", "+", "'\\n'", ";", "}", "result", "+=", "'\\n'", ";", "}", "return", "result", ";", "}"], "docstring": "transformSnapshotList converts snapshot list from native into markdown format.\n\n@param {number} name Snapshot name.\n@param {*} snapshotList Snapshot list.\n@param {number} depth Snapshot depth.\n@param {boolean} indentCodeBlocks  Use indentation for code blocks.\n@returns Snapshot in a markdown format.", "docstring_tokens": ["transformSnapshotList", "converts", "snapshot", "list", "from", "native", "into", "markdown", "format", "."], "sha": "ec3f41bab775b5be6d3aa236f55ee12881b25662", "url": "https://github.com/localvoid/karma-snapshot/blob/ec3f41bab775b5be6d3aa236f55ee12881b25662/lib/format/markdown.js#L228-L257", "partition": "test"}
{"repo": "jordifreek/Backbone-Special-K", "path": "src/specialk.js", "func_name": "", "original_string": "function() {\n            if (!this.currentView) return false;\n\n            $(SpecialK.container).hide();\n            this.currentView.unbind();\n            this.currentView.remove();\n            this.currentView = null;\n            return true;\n        }", "language": "javascript", "code": "function() {\n            if (!this.currentView) return false;\n\n            $(SpecialK.container).hide();\n            this.currentView.unbind();\n            this.currentView.remove();\n            this.currentView = null;\n            return true;\n        }", "code_tokens": ["function", "(", ")", "{", "if", "(", "!", "this", ".", "currentView", ")", "return", "false", ";", "$", "(", "SpecialK", ".", "container", ")", ".", "hide", "(", ")", ";", "this", ".", "currentView", ".", "unbind", "(", ")", ";", "this", ".", "currentView", ".", "remove", "(", ")", ";", "this", ".", "currentView", "=", "null", ";", "return", "true", ";", "}"], "docstring": "Elimina la vista actual y sus eventos en DOM.\n@return {bool} True si exit\u00eda alguna vista y ha sido eliminada.", "docstring_tokens": ["Elimina", "la", "vista", "actual", "y", "sus", "eventos", "en", "DOM", "."], "sha": "c22fcc3c398d30379c6d4625072f642ed376639b", "url": "https://github.com/jordifreek/Backbone-Special-K/blob/c22fcc3c398d30379c6d4625072f642ed376639b/src/specialk.js#L39-L47", "partition": "test"}
{"repo": "TxHawks/bidi-css-js", "path": "src/index.js", "func_name": "getPropertyDoppelganger", "original_string": "function getPropertyDoppelganger(property, isRtl) {\n  const convertedProperty = isRtl\n    ? propertiesToConvert.rtl[property]\n    : propertiesToConvert.ltr[property]\n\n  return convertedProperty || property\n}", "language": "javascript", "code": "function getPropertyDoppelganger(property, isRtl) {\n  const convertedProperty = isRtl\n    ? propertiesToConvert.rtl[property]\n    : propertiesToConvert.ltr[property]\n\n  return convertedProperty || property\n}", "code_tokens": ["function", "getPropertyDoppelganger", "(", "property", ",", "isRtl", ")", "{", "const", "convertedProperty", "=", "isRtl", "?", "propertiesToConvert", ".", "rtl", "[", "property", "]", ":", "propertiesToConvert", ".", "ltr", "[", "property", "]", "return", "convertedProperty", "||", "property", "}"], "docstring": "Logically gets the direction of the given property based on the flow direction context\n@param {String} property the name of the property\n@param {Boolean} isRtl Should conversion happen in RTL context?\n@return {String} the name of the RTL property", "docstring_tokens": ["Logically", "gets", "the", "direction", "of", "the", "given", "property", "based", "on", "the", "flow", "direction", "context"], "sha": "de6c9612ef9b1eb20de12ac751baf65241e4f477", "url": "https://github.com/TxHawks/bidi-css-js/blob/de6c9612ef9b1eb20de12ac751baf65241e4f477/src/index.js#L197-L203", "partition": "test"}
{"repo": "moxiecode/moxie", "path": "src/javascript/core/utils/Dom.js", "func_name": "", "original_string": "function(obj, name) {\n\t\tif (!obj.className) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar regExp = new RegExp(\"(^|\\\\s+)\"+name+\"(\\\\s+|$)\");\n\t\treturn regExp.test(obj.className);\n\t}", "language": "javascript", "code": "function(obj, name) {\n\t\tif (!obj.className) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar regExp = new RegExp(\"(^|\\\\s+)\"+name+\"(\\\\s+|$)\");\n\t\treturn regExp.test(obj.className);\n\t}", "code_tokens": ["function", "(", "obj", ",", "name", ")", "{", "if", "(", "!", "obj", ".", "className", ")", "{", "return", "false", ";", "}", "var", "regExp", "=", "new", "RegExp", "(", "\"(^|\\\\s+)\"", "+", "name", "+", "\"(\\\\s+|$)\"", ")", ";", "return", "regExp", ".", "test", "(", "obj", ".", "className", ")", ";", "}"], "docstring": "Checks if specified DOM element has specified class.\n\n@method hasClass\n@static\n@param {Object} obj DOM element like object to add handler to.\n@param {String} name Class name", "docstring_tokens": ["Checks", "if", "specified", "DOM", "element", "has", "specified", "class", "."], "sha": "09eaf578f38480dc4b8e2017c473c496883b6168", "url": "https://github.com/moxiecode/moxie/blob/09eaf578f38480dc4b8e2017c473c496883b6168/src/javascript/core/utils/Dom.js#L41-L48", "partition": "test"}
{"repo": "tstachl/desk.js", "path": "lib/mixins/search.js", "func_name": "search", "original_string": "function search(parent, baseUrl, callback) {\n  var resource = new (getResource('page'))(parent, {\n    _links: { self: { href: baseUrl, 'class': 'page' } }\n  });\n  \n  if (typeof callback == 'function') return resource.exec(callback);\n  return resource;\n}", "language": "javascript", "code": "function search(parent, baseUrl, callback) {\n  var resource = new (getResource('page'))(parent, {\n    _links: { self: { href: baseUrl, 'class': 'page' } }\n  });\n  \n  if (typeof callback == 'function') return resource.exec(callback);\n  return resource;\n}", "code_tokens": ["function", "search", "(", "parent", ",", "baseUrl", ",", "callback", ")", "{", "var", "resource", "=", "new", "(", "getResource", "(", "'page'", ")", ")", "(", "parent", ",", "{", "_links", ":", "{", "self", ":", "{", "href", ":", "baseUrl", ",", "'class'", ":", "'page'", "}", "}", "}", ")", ";", "if", "(", "typeof", "callback", "==", "'function'", ")", "return", "resource", ".", "exec", "(", "callback", ")", ";", "return", "resource", ";", "}"], "docstring": "Searches a resource.\n\n@param {Function} parent The parent this resource should be attached to.\n@param {String} baseUrl That's needed for sub resources (/api/v2/customers/1/cases).\n@param {Function} callback The callback called with the new resource or error.\n@api public", "docstring_tokens": ["Searches", "a", "resource", "."], "sha": "b339196cce68dbbc79d3075f2ebe82372972f4f5", "url": "https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/mixins/search.js#L20-L27", "partition": "test"}
{"repo": "monarkee/postcss-beard-spacing", "path": "index.js", "func_name": "", "original_string": "function(breakpoints, spacingScale) {\n    return _.map(breakpoints, function(breakpointValue, breakpointKey) {\n        let mediaQuery = postcss.atRule({\n            name: 'media',\n            params: breakpointValue,\n        })\n\n        let rules = _.flatMap(spacingScale, function(scaleValue, scaleKey) {\n            return _.map(helpers, function(helperValues, helperKey) {\n                return makeFunctionalRule(\n                    `.${breakpointKey}-${helperKey}${scaleKey}`,\n                    helperValues,\n                    scaleValue\n                )\n            })\n        })\n\n        return mediaQuery.append(rules)\n    })\n}", "language": "javascript", "code": "function(breakpoints, spacingScale) {\n    return _.map(breakpoints, function(breakpointValue, breakpointKey) {\n        let mediaQuery = postcss.atRule({\n            name: 'media',\n            params: breakpointValue,\n        })\n\n        let rules = _.flatMap(spacingScale, function(scaleValue, scaleKey) {\n            return _.map(helpers, function(helperValues, helperKey) {\n                return makeFunctionalRule(\n                    `.${breakpointKey}-${helperKey}${scaleKey}`,\n                    helperValues,\n                    scaleValue\n                )\n            })\n        })\n\n        return mediaQuery.append(rules)\n    })\n}", "code_tokens": ["function", "(", "breakpoints", ",", "spacingScale", ")", "{", "return", "_", ".", "map", "(", "breakpoints", ",", "function", "(", "breakpointValue", ",", "breakpointKey", ")", "{", "let", "mediaQuery", "=", "postcss", ".", "atRule", "(", "{", "name", ":", "'media'", ",", "params", ":", "breakpointValue", ",", "}", ")", "let", "rules", "=", "_", ".", "flatMap", "(", "spacingScale", ",", "function", "(", "scaleValue", ",", "scaleKey", ")", "{", "return", "_", ".", "map", "(", "helpers", ",", "function", "(", "helperValues", ",", "helperKey", ")", "{", "return", "makeFunctionalRule", "(", "`", "${", "breakpointKey", "}", "${", "helperKey", "}", "${", "scaleKey", "}", "`", ",", "helperValues", ",", "scaleValue", ")", "}", ")", "}", ")", "return", "mediaQuery", ".", "append", "(", "rules", ")", "}", ")", "}"], "docstring": "Generate a complete set of responsive spacing helpers\n@param  {object} breakpoints A set of breakpoints to generate the spacer for\n@param  {object} spacingScale The spacing scale to use\n@return {array}             Rules", "docstring_tokens": ["Generate", "a", "complete", "set", "of", "responsive", "spacing", "helpers"], "sha": "0679a00ea08e775e7c4a2a59f06c9749164a1c8e", "url": "https://github.com/monarkee/postcss-beard-spacing/blob/0679a00ea08e775e7c4a2a59f06c9749164a1c8e/index.js#L71-L90", "partition": "test"}
{"repo": "genify/toolkit2", "path": "lib/meta/html.js", "func_name": "", "original_string": "function(uri,config){\n        uri = uri.replace(\n            config.srcRoot,\n            config.outHtmlRoot\n        );\n        return this._formatURI(uri,{\n            pathRoot:config.output,\n            webRoot:config.webRoot,\n            domain:config.mdlRoot\n        });\n    }", "language": "javascript", "code": "function(uri,config){\n        uri = uri.replace(\n            config.srcRoot,\n            config.outHtmlRoot\n        );\n        return this._formatURI(uri,{\n            pathRoot:config.output,\n            webRoot:config.webRoot,\n            domain:config.mdlRoot\n        });\n    }", "code_tokens": ["function", "(", "uri", ",", "config", ")", "{", "uri", "=", "uri", ".", "replace", "(", "config", ".", "srcRoot", ",", "config", ".", "outHtmlRoot", ")", ";", "return", "this", ".", "_formatURI", "(", "uri", ",", "{", "pathRoot", ":", "config", ".", "output", ",", "webRoot", ":", "config", ".", "webRoot", ",", "domain", ":", "config", ".", "mdlRoot", "}", ")", ";", "}"], "docstring": "nej module root", "docstring_tokens": ["nej", "module", "root"], "sha": "bb40480731f363327e055f7120d3fd6de6336cda", "url": "https://github.com/genify/toolkit2/blob/bb40480731f363327e055f7120d3fd6de6336cda/lib/meta/html.js#L127-L137", "partition": "test"}
{"repo": "genify/toolkit2", "path": "lib/util/klass.js", "func_name": "", "original_string": "function(method,klass){\n    while(!!klass){\n        var key = null,\n            pro = klass.prototype;\n        // find method in current klass\n        Object.keys(pro).some(function(name){\n            if (method===pro[name]){\n                key = name;\n                return !0;\n            }\n        });\n        // method finded in klass\n        if (key!=null){\n            return {\n                name:key,\n                klass:klass\n            };\n        }\n        klass = klass.supor;\n    }\n}", "language": "javascript", "code": "function(method,klass){\n    while(!!klass){\n        var key = null,\n            pro = klass.prototype;\n        // find method in current klass\n        Object.keys(pro).some(function(name){\n            if (method===pro[name]){\n                key = name;\n                return !0;\n            }\n        });\n        // method finded in klass\n        if (key!=null){\n            return {\n                name:key,\n                klass:klass\n            };\n        }\n        klass = klass.supor;\n    }\n}", "code_tokens": ["function", "(", "method", ",", "klass", ")", "{", "while", "(", "!", "!", "klass", ")", "{", "var", "key", "=", "null", ",", "pro", "=", "klass", ".", "prototype", ";", "// find method in current klass", "Object", ".", "keys", "(", "pro", ")", ".", "some", "(", "function", "(", "name", ")", "{", "if", "(", "method", "===", "pro", "[", "name", "]", ")", "{", "key", "=", "name", ";", "return", "!", "0", ";", "}", "}", ")", ";", "// method finded in klass", "if", "(", "key", "!=", "null", ")", "{", "return", "{", "name", ":", "key", ",", "klass", ":", "klass", "}", ";", "}", "klass", "=", "klass", ".", "supor", ";", "}", "}"], "docstring": "find method in klass prototype chain", "docstring_tokens": ["find", "method", "in", "klass", "prototype", "chain"], "sha": "bb40480731f363327e055f7120d3fd6de6336cda", "url": "https://github.com/genify/toolkit2/blob/bb40480731f363327e055f7120d3fd6de6336cda/lib/util/klass.js#L8-L28", "partition": "test"}
{"repo": "hyurl/sfn", "path": "src/assets/js/javascript.js", "func_name": "parse", "original_string": "function parse(query) {\n        if (query[0] == \"?\") query = query.slice(1);\n        var pairs = query.split(\"&\"),\n            obj = {};\n\n        for (var i in pairs) {\n            var pair = pairs[i].split(\"=\"),\n                key = decodeURIComponent(pair[0]),\n                value = pair[1] ? decodeURIComponent(pair[1]) : \"\";\n\n            obj[key] = value;\n        }\n\n        return obj;\n    }", "language": "javascript", "code": "function parse(query) {\n        if (query[0] == \"?\") query = query.slice(1);\n        var pairs = query.split(\"&\"),\n            obj = {};\n\n        for (var i in pairs) {\n            var pair = pairs[i].split(\"=\"),\n                key = decodeURIComponent(pair[0]),\n                value = pair[1] ? decodeURIComponent(pair[1]) : \"\";\n\n            obj[key] = value;\n        }\n\n        return obj;\n    }", "code_tokens": ["function", "parse", "(", "query", ")", "{", "if", "(", "query", "[", "0", "]", "==", "\"?\"", ")", "query", "=", "query", ".", "slice", "(", "1", ")", ";", "var", "pairs", "=", "query", ".", "split", "(", "\"&\"", ")", ",", "obj", "=", "{", "}", ";", "for", "(", "var", "i", "in", "pairs", ")", "{", "var", "pair", "=", "pairs", "[", "i", "]", ".", "split", "(", "\"=\"", ")", ",", "key", "=", "decodeURIComponent", "(", "pair", "[", "0", "]", ")", ",", "value", "=", "pair", "[", "1", "]", "?", "decodeURIComponent", "(", "pair", "[", "1", "]", ")", ":", "\"\"", ";", "obj", "[", "key", "]", "=", "value", ";", "}", "return", "obj", ";", "}"], "docstring": "Parses URL query string.\n@param {string} query\n@returns {object}", "docstring_tokens": ["Parses", "URL", "query", "string", "."], "sha": "c4a7a39a14983fe8e62f46280c75f386e09ff618", "url": "https://github.com/hyurl/sfn/blob/c4a7a39a14983fe8e62f46280c75f386e09ff618/src/assets/js/javascript.js#L12-L26", "partition": "test"}
{"repo": "particle-iot/binary-version-reader", "path": "lib/HalDependencyResolver.js", "func_name": "", "original_string": "function(describe) {\n\t\tif (!Array.isArray(describe.m)) {\n\t\t\treturn when.reject('no modules in describe message');\n\t\t}\n\n\t\tvar allDeps = [];\n\t\tvar modules = describe.m;\n\n\t\tfor(var i=0;i<modules.length;i++) {\n\t\t\tvar checkModule = modules[i];\n\n\t\t\t// don't look for dependencies of things that don't have dependencies.\n\t\t\t// they'll never cause safe mode as a result of their requirements,\n\t\t\t// and they're probably referenced by other things\n\n\t\t\tfor(var d = 0; d < checkModule.d.length; d++) {\n\t\t\t\tvar moduleNeeds = checkModule.d[d];\n\n\t\t\t\t// what things do we need that we don't have?\n\t\t\t\tvar deps = this._walkChain(modules, moduleNeeds);\n\t\t\t\tif (deps && (deps.length > 0)) {\n\t\t\t\t\tallDeps = allDeps.concat(deps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar keyFn = function(dep) {\n\t\t\t// todo - location should also be taken into account\n\t\t\treturn [dep.f, dep.n, dep.v].join('_');\n\t\t};\n\t\treturn utilities.dedupArray(allDeps, keyFn);\n\t}", "language": "javascript", "code": "function(describe) {\n\t\tif (!Array.isArray(describe.m)) {\n\t\t\treturn when.reject('no modules in describe message');\n\t\t}\n\n\t\tvar allDeps = [];\n\t\tvar modules = describe.m;\n\n\t\tfor(var i=0;i<modules.length;i++) {\n\t\t\tvar checkModule = modules[i];\n\n\t\t\t// don't look for dependencies of things that don't have dependencies.\n\t\t\t// they'll never cause safe mode as a result of their requirements,\n\t\t\t// and they're probably referenced by other things\n\n\t\t\tfor(var d = 0; d < checkModule.d.length; d++) {\n\t\t\t\tvar moduleNeeds = checkModule.d[d];\n\n\t\t\t\t// what things do we need that we don't have?\n\t\t\t\tvar deps = this._walkChain(modules, moduleNeeds);\n\t\t\t\tif (deps && (deps.length > 0)) {\n\t\t\t\t\tallDeps = allDeps.concat(deps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar keyFn = function(dep) {\n\t\t\t// todo - location should also be taken into account\n\t\t\treturn [dep.f, dep.n, dep.v].join('_');\n\t\t};\n\t\treturn utilities.dedupArray(allDeps, keyFn);\n\t}", "code_tokens": ["function", "(", "describe", ")", "{", "if", "(", "!", "Array", ".", "isArray", "(", "describe", ".", "m", ")", ")", "{", "return", "when", ".", "reject", "(", "'no modules in describe message'", ")", ";", "}", "var", "allDeps", "=", "[", "]", ";", "var", "modules", "=", "describe", ".", "m", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "modules", ".", "length", ";", "i", "++", ")", "{", "var", "checkModule", "=", "modules", "[", "i", "]", ";", "// don't look for dependencies of things that don't have dependencies.", "// they'll never cause safe mode as a result of their requirements,", "// and they're probably referenced by other things", "for", "(", "var", "d", "=", "0", ";", "d", "<", "checkModule", ".", "d", ".", "length", ";", "d", "++", ")", "{", "var", "moduleNeeds", "=", "checkModule", ".", "d", "[", "d", "]", ";", "// what things do we need that we don't have?", "var", "deps", "=", "this", ".", "_walkChain", "(", "modules", ",", "moduleNeeds", ")", ";", "if", "(", "deps", "&&", "(", "deps", ".", "length", ">", "0", ")", ")", "{", "allDeps", "=", "allDeps", ".", "concat", "(", "deps", ")", ";", "}", "}", "}", "var", "keyFn", "=", "function", "(", "dep", ")", "{", "// todo - location should also be taken into account", "return", "[", "dep", ".", "f", ",", "dep", ".", "n", ",", "dep", ".", "v", "]", ".", "join", "(", "'_'", ")", ";", "}", ";", "return", "utilities", ".", "dedupArray", "(", "allDeps", ",", "keyFn", ")", ";", "}"], "docstring": "tell us if anything with dependencies is missing something\n\n(this covers scenarios where user app needs something else, or user app has no deps, and part 1 is old, but\npart2 is current, etc.)  Built this because I hit this during testing.\n\nin what order should we apply updates?\nis it possible for us to get conflicting / out of order update recommendations?!\n\n@param describe", "docstring_tokens": ["tell", "us", "if", "anything", "with", "dependencies", "is", "missing", "something"], "sha": "0157a0d77121f19929a2d5cdb1760ba53d1a6870", "url": "https://github.com/particle-iot/binary-version-reader/blob/0157a0d77121f19929a2d5cdb1760ba53d1a6870/lib/HalDependencyResolver.js#L354-L385", "partition": "test"}
{"repo": "algolia/algoliasearch-helper-js", "path": "src/SearchParameters/index.js", "func_name": "", "original_string": "function(facet, path) {\n    if (this.isHierarchicalFacetRefined(facet)) {\n      throw new Error(facet + ' is already refined.');\n    }\n    var mod = {};\n    mod[facet] = [path];\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaults({}, mod, this.hierarchicalFacetsRefinements)\n    });\n  }", "language": "javascript", "code": "function(facet, path) {\n    if (this.isHierarchicalFacetRefined(facet)) {\n      throw new Error(facet + ' is already refined.');\n    }\n    var mod = {};\n    mod[facet] = [path];\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaults({}, mod, this.hierarchicalFacetsRefinements)\n    });\n  }", "code_tokens": ["function", "(", "facet", ",", "path", ")", "{", "if", "(", "this", ".", "isHierarchicalFacetRefined", "(", "facet", ")", ")", "{", "throw", "new", "Error", "(", "facet", "+", "' is already refined.'", ")", ";", "}", "var", "mod", "=", "{", "}", ";", "mod", "[", "facet", "]", "=", "[", "path", "]", ";", "return", "this", ".", "setQueryParameters", "(", "{", "hierarchicalFacetsRefinements", ":", "defaults", "(", "{", "}", ",", "mod", ",", "this", ".", "hierarchicalFacetsRefinements", ")", "}", ")", ";", "}"], "docstring": "Adds a refinement on a hierarchical facet.\n@param {string} facet the facet name\n@param {string} path the hierarchical facet path\n@return {SearchParameter} the new state\n@throws Error if the facet is not defined or if the facet is refined", "docstring_tokens": ["Adds", "a", "refinement", "on", "a", "hierarchical", "facet", "."], "sha": "9ebdd34ab98a3298a7687f81dfef24b01e798c53", "url": "https://github.com/algolia/algoliasearch-helper-js/blob/9ebdd34ab98a3298a7687f81dfef24b01e798c53/src/SearchParameters/index.js#L1307-L1316", "partition": "test"}
{"repo": "unfoldingWord-dev/node-gogs-client", "path": "lib/request.js", "func_name": "encodeUserAuth", "original_string": "function encodeUserAuth(user) {\n  if (!user) {\n    return null;\n  }\n\n  var token = user.token;\n  if (token) {\n    var sha1 = typeof token === 'object' ? token.sha1 : token;\n    return 'token ' + sha1;\n  }\n\n  return 'Basic ' + base64.encode(user.username + ':' + user.password)\n}", "language": "javascript", "code": "function encodeUserAuth(user) {\n  if (!user) {\n    return null;\n  }\n\n  var token = user.token;\n  if (token) {\n    var sha1 = typeof token === 'object' ? token.sha1 : token;\n    return 'token ' + sha1;\n  }\n\n  return 'Basic ' + base64.encode(user.username + ':' + user.password)\n}", "code_tokens": ["function", "encodeUserAuth", "(", "user", ")", "{", "if", "(", "!", "user", ")", "{", "return", "null", ";", "}", "var", "token", "=", "user", ".", "token", ";", "if", "(", "token", ")", "{", "var", "sha1", "=", "typeof", "token", "===", "'object'", "?", "token", ".", "sha1", ":", "token", ";", "return", "'token '", "+", "sha1", ";", "}", "return", "'Basic '", "+", "base64", ".", "encode", "(", "user", ".", "username", "+", "':'", "+", "user", ".", "password", ")", "}"], "docstring": "Generates the authentication parameter for the user\nPreference will be given to the token if it exists\n@param user the use used for authentication. Requires token or username and password\n@return {string|null} the properly formatted authentication string", "docstring_tokens": ["Generates", "the", "authentication", "parameter", "for", "the", "user", "Preference", "will", "be", "given", "to", "the", "token", "if", "it", "exists"], "sha": "6b16291e1a1e05882cc2d0628128a6ab6d3047a5", "url": "https://github.com/unfoldingWord-dev/node-gogs-client/blob/6b16291e1a1e05882cc2d0628128a6ab6d3047a5/lib/request.js#L12-L24", "partition": "test"}
{"repo": "10xLaCroixDrinker/grunt-node-version", "path": "tasks/node_version.js", "func_name": "", "original_string": "function() {\n      // Make sure a node version is intalled that satisfies\n      // the projects required engine. If not, prompt to install.\n      nvmLs('local', function() {\n        var matches = semver.maxSatisfying(locals, expected);\n\n        if (matches) {\n          bestMatch = matches;\n          nvmUse = nvmInit + 'nvm use ' + bestMatch;\n\n          childProcess.exec(nvmUse, cmdOpts,function(err, stdout, stderr) {\n            printVersion(stdout.split(' ')[3]);\n            extendExec();\n            checkPackages(options.globals);\n          });\n        } else {\n          if (options.alwaysInstall) {\n            nvmInstall();\n          } else {\n            askInstall();\n          }\n        }\n      });\n    }", "language": "javascript", "code": "function() {\n      // Make sure a node version is intalled that satisfies\n      // the projects required engine. If not, prompt to install.\n      nvmLs('local', function() {\n        var matches = semver.maxSatisfying(locals, expected);\n\n        if (matches) {\n          bestMatch = matches;\n          nvmUse = nvmInit + 'nvm use ' + bestMatch;\n\n          childProcess.exec(nvmUse, cmdOpts,function(err, stdout, stderr) {\n            printVersion(stdout.split(' ')[3]);\n            extendExec();\n            checkPackages(options.globals);\n          });\n        } else {\n          if (options.alwaysInstall) {\n            nvmInstall();\n          } else {\n            askInstall();\n          }\n        }\n      });\n    }", "code_tokens": ["function", "(", ")", "{", "// Make sure a node version is intalled that satisfies", "// the projects required engine. If not, prompt to install.", "nvmLs", "(", "'local'", ",", "function", "(", ")", "{", "var", "matches", "=", "semver", ".", "maxSatisfying", "(", "locals", ",", "expected", ")", ";", "if", "(", "matches", ")", "{", "bestMatch", "=", "matches", ";", "nvmUse", "=", "nvmInit", "+", "'nvm use '", "+", "bestMatch", ";", "childProcess", ".", "exec", "(", "nvmUse", ",", "cmdOpts", ",", "function", "(", "err", ",", "stdout", ",", "stderr", ")", "{", "printVersion", "(", "stdout", ".", "split", "(", "' '", ")", "[", "3", "]", ")", ";", "extendExec", "(", ")", ";", "checkPackages", "(", "options", ".", "globals", ")", ";", "}", ")", ";", "}", "else", "{", "if", "(", "options", ".", "alwaysInstall", ")", "{", "nvmInstall", "(", ")", ";", "}", "else", "{", "askInstall", "(", ")", ";", "}", "}", "}", ")", ";", "}"], "docstring": "Check for compatible node version", "docstring_tokens": ["Check", "for", "compatible", "node", "version"], "sha": "d16beba04f6a6325d2fa8202750165d3fc69b35b", "url": "https://github.com/10xLaCroixDrinker/grunt-node-version/blob/d16beba04f6a6325d2fa8202750165d3fc69b35b/tasks/node_version.js#L211-L234", "partition": "test"}
{"repo": "vedmalex/fte2", "path": "grammar/raw.pegjs.js", "func_name": "node", "original_string": "function node(content, type, name, indent){\n      this.type = type;\n      if(name) this.name = name;\n      this.content = content;\n      if(indent) {\n        this.indent = indent;// to use same indentation as source code\n        if(~eol.indexOf(indent[0])){\n          delete this.indent;\n        }\n      }\n      var loc = location();\n      var bol = loc.start.column == 1;\n      if(bol) this.bol = true;\n      this.line = loc.start.line;\n      this.column = loc.start.column;\n    }", "language": "javascript", "code": "function node(content, type, name, indent){\n      this.type = type;\n      if(name) this.name = name;\n      this.content = content;\n      if(indent) {\n        this.indent = indent;// to use same indentation as source code\n        if(~eol.indexOf(indent[0])){\n          delete this.indent;\n        }\n      }\n      var loc = location();\n      var bol = loc.start.column == 1;\n      if(bol) this.bol = true;\n      this.line = loc.start.line;\n      this.column = loc.start.column;\n    }", "code_tokens": ["function", "node", "(", "content", ",", "type", ",", "name", ",", "indent", ")", "{", "this", ".", "type", "=", "type", ";", "if", "(", "name", ")", "this", ".", "name", "=", "name", ";", "this", ".", "content", "=", "content", ";", "if", "(", "indent", ")", "{", "this", ".", "indent", "=", "indent", ";", "// to use same indentation as source code", "if", "(", "~", "eol", ".", "indexOf", "(", "indent", "[", "0", "]", ")", ")", "{", "delete", "this", ".", "indent", ";", "}", "}", "var", "loc", "=", "location", "(", ")", ";", "var", "bol", "=", "loc", ".", "start", ".", "column", "==", "1", ";", "if", "(", "bol", ")", "this", ".", "bol", "=", "true", ";", "this", ".", "line", "=", "loc", ".", "start", ".", "line", ";", "this", ".", "column", "=", "loc", ".", "start", ".", "column", ";", "}"], "docstring": "join an array", "docstring_tokens": ["join", "an", "array"], "sha": "5a516114deb8c4fa37936d83cebf6e8cc1825cd8", "url": "https://github.com/vedmalex/fte2/blob/5a516114deb8c4fa37936d83cebf6e8cc1825cd8/grammar/raw.pegjs.js#L2317-L2332", "partition": "test"}
{"repo": "silverwind/cidr-tools", "path": "index.js", "func_name": "exclude", "original_string": "function exclude(a, b, v) {\n  const aStart = a.start({type: \"bigInteger\"});\n  const bStart = b.start({type: \"bigInteger\"});\n  const aEnd = a.end({type: \"bigInteger\"});\n  const bEnd = b.end({type: \"bigInteger\"});\n  const parts = [];\n\n  // compareTo returns negative if left is less than right\n\n  //       aaa\n  //   bbb\n  //   aaa\n  //       bbb\n  if (aStart.compareTo(bEnd) > 0 || aEnd.compareTo(bStart) < 0) {\n    return [a.cidr];\n  }\n\n  //   aaa\n  //   bbb\n  if (aStart.compareTo(bStart) === 0 && aEnd.compareTo(bEnd) === 0) {\n    return [];\n  }\n\n  //   aa\n  //  bbbb\n  if (aStart.compareTo(bStart) > 0 && aEnd.compareTo(bEnd) < 0) {\n    return [];\n  }\n\n  // aaaa\n  //   bbbb\n  // aaaa\n  //   bb\n  if (aStart.compareTo(bStart) < 0 && aEnd.compareTo(bEnd) <= 0) {\n    parts.push({\n      start: aStart,\n      end: bStart.subtract(one),\n    });\n  }\n\n  //    aaa\n  //   bbb\n  //   aaaa\n  //   bbb\n  if (aStart.compareTo(bStart) >= 0 && aEnd.compareTo(bEnd) > 0) {\n    parts.push({\n      start: bEnd.add(one),\n      end: aEnd,\n    });\n  }\n\n  //  aaaa\n  //   bb\n  if (aStart.compareTo(bStart) < 0 && aEnd.compareTo(bEnd) > 0) {\n    parts.push({\n      start: aStart,\n      end: bStart.subtract(one),\n    });\n    parts.push({\n      start: bEnd.add(one),\n      end: aEnd,\n    });\n  }\n\n  const remaining = [];\n  for (const part of parts) {\n    for (const subpart of subparts(part, v)) {\n      remaining.push(formatPart(subpart, v));\n    }\n  }\n\n  return cidrTools.merge(remaining);\n}", "language": "javascript", "code": "function exclude(a, b, v) {\n  const aStart = a.start({type: \"bigInteger\"});\n  const bStart = b.start({type: \"bigInteger\"});\n  const aEnd = a.end({type: \"bigInteger\"});\n  const bEnd = b.end({type: \"bigInteger\"});\n  const parts = [];\n\n  // compareTo returns negative if left is less than right\n\n  //       aaa\n  //   bbb\n  //   aaa\n  //       bbb\n  if (aStart.compareTo(bEnd) > 0 || aEnd.compareTo(bStart) < 0) {\n    return [a.cidr];\n  }\n\n  //   aaa\n  //   bbb\n  if (aStart.compareTo(bStart) === 0 && aEnd.compareTo(bEnd) === 0) {\n    return [];\n  }\n\n  //   aa\n  //  bbbb\n  if (aStart.compareTo(bStart) > 0 && aEnd.compareTo(bEnd) < 0) {\n    return [];\n  }\n\n  // aaaa\n  //   bbbb\n  // aaaa\n  //   bb\n  if (aStart.compareTo(bStart) < 0 && aEnd.compareTo(bEnd) <= 0) {\n    parts.push({\n      start: aStart,\n      end: bStart.subtract(one),\n    });\n  }\n\n  //    aaa\n  //   bbb\n  //   aaaa\n  //   bbb\n  if (aStart.compareTo(bStart) >= 0 && aEnd.compareTo(bEnd) > 0) {\n    parts.push({\n      start: bEnd.add(one),\n      end: aEnd,\n    });\n  }\n\n  //  aaaa\n  //   bb\n  if (aStart.compareTo(bStart) < 0 && aEnd.compareTo(bEnd) > 0) {\n    parts.push({\n      start: aStart,\n      end: bStart.subtract(one),\n    });\n    parts.push({\n      start: bEnd.add(one),\n      end: aEnd,\n    });\n  }\n\n  const remaining = [];\n  for (const part of parts) {\n    for (const subpart of subparts(part, v)) {\n      remaining.push(formatPart(subpart, v));\n    }\n  }\n\n  return cidrTools.merge(remaining);\n}", "code_tokens": ["function", "exclude", "(", "a", ",", "b", ",", "v", ")", "{", "const", "aStart", "=", "a", ".", "start", "(", "{", "type", ":", "\"bigInteger\"", "}", ")", ";", "const", "bStart", "=", "b", ".", "start", "(", "{", "type", ":", "\"bigInteger\"", "}", ")", ";", "const", "aEnd", "=", "a", ".", "end", "(", "{", "type", ":", "\"bigInteger\"", "}", ")", ";", "const", "bEnd", "=", "b", ".", "end", "(", "{", "type", ":", "\"bigInteger\"", "}", ")", ";", "const", "parts", "=", "[", "]", ";", "// compareTo returns negative if left is less than right", "//       aaa", "//   bbb", "//   aaa", "//       bbb", "if", "(", "aStart", ".", "compareTo", "(", "bEnd", ")", ">", "0", "||", "aEnd", ".", "compareTo", "(", "bStart", ")", "<", "0", ")", "{", "return", "[", "a", ".", "cidr", "]", ";", "}", "//   aaa", "//   bbb", "if", "(", "aStart", ".", "compareTo", "(", "bStart", ")", "===", "0", "&&", "aEnd", ".", "compareTo", "(", "bEnd", ")", "===", "0", ")", "{", "return", "[", "]", ";", "}", "//   aa", "//  bbbb", "if", "(", "aStart", ".", "compareTo", "(", "bStart", ")", ">", "0", "&&", "aEnd", ".", "compareTo", "(", "bEnd", ")", "<", "0", ")", "{", "return", "[", "]", ";", "}", "// aaaa", "//   bbbb", "// aaaa", "//   bb", "if", "(", "aStart", ".", "compareTo", "(", "bStart", ")", "<", "0", "&&", "aEnd", ".", "compareTo", "(", "bEnd", ")", "<=", "0", ")", "{", "parts", ".", "push", "(", "{", "start", ":", "aStart", ",", "end", ":", "bStart", ".", "subtract", "(", "one", ")", ",", "}", ")", ";", "}", "//    aaa", "//   bbb", "//   aaaa", "//   bbb", "if", "(", "aStart", ".", "compareTo", "(", "bStart", ")", ">=", "0", "&&", "aEnd", ".", "compareTo", "(", "bEnd", ")", ">", "0", ")", "{", "parts", ".", "push", "(", "{", "start", ":", "bEnd", ".", "add", "(", "one", ")", ",", "end", ":", "aEnd", ",", "}", ")", ";", "}", "//  aaaa", "//   bb", "if", "(", "aStart", ".", "compareTo", "(", "bStart", ")", "<", "0", "&&", "aEnd", ".", "compareTo", "(", "bEnd", ")", ">", "0", ")", "{", "parts", ".", "push", "(", "{", "start", ":", "aStart", ",", "end", ":", "bStart", ".", "subtract", "(", "one", ")", ",", "}", ")", ";", "parts", ".", "push", "(", "{", "start", ":", "bEnd", ".", "add", "(", "one", ")", ",", "end", ":", "aEnd", ",", "}", ")", ";", "}", "const", "remaining", "=", "[", "]", ";", "for", "(", "const", "part", "of", "parts", ")", "{", "for", "(", "const", "subpart", "of", "subparts", "(", "part", ",", "v", ")", ")", "{", "remaining", ".", "push", "(", "formatPart", "(", "subpart", ",", "v", ")", ")", ";", "}", "}", "return", "cidrTools", ".", "merge", "(", "remaining", ")", ";", "}"], "docstring": "exclude b from a and return remainder cidrs", "docstring_tokens": ["exclude", "b", "from", "a", "and", "return", "remainder", "cidrs"], "sha": "6b6f18c0090ff2d8f5fc7cf3a1a622a546b6a328", "url": "https://github.com/silverwind/cidr-tools/blob/6b6f18c0090ff2d8f5fc7cf3a1a622a546b6a328/index.js#L64-L136", "partition": "test"}
{"repo": "wrote/read-dir-structure", "path": "build/index.js", "func_name": "readDirStructure", "original_string": "async function readDirStructure(dirPath) {\n  if (!dirPath) {\n    throw new Error('Please specify a path to the directory')\n  }\n  const ls = await makePromise(lstat, dirPath)\n  if (!ls.isDirectory()) {\n    const err = new Error('Path is not a directory')\n    err.code = 'ENOTDIR'\n    throw err\n  }\n  const dir = /** @type {!Array<string>} */ (await makePromise(readdir, dirPath))\n  const lsr = await lstatFiles(dirPath, dir)\n\n  const directories = lsr.filter(isDirectory) // reduce at once\n  const notDirectories = lsr.filter(isNotDirectory)\n\n  const files = notDirectories.reduce((acc, current) => {\n    const type = getType(current)\n    return {\n      ...acc,\n      [current.relativePath]: {\n        type,\n      },\n    }\n  }, {})\n\n  const dirs = await directories.reduce(async (acc, { path, relativePath }) => {\n    const res = await acc\n    const structure = await readDirStructure(path)\n    return {\n      ...res,\n      [relativePath]: structure,\n    }\n  }, {})\n\n  const content = {\n    ...files,\n    ...dirs,\n  }\n  return {\n    content,\n    type: 'Directory',\n  }\n}", "language": "javascript", "code": "async function readDirStructure(dirPath) {\n  if (!dirPath) {\n    throw new Error('Please specify a path to the directory')\n  }\n  const ls = await makePromise(lstat, dirPath)\n  if (!ls.isDirectory()) {\n    const err = new Error('Path is not a directory')\n    err.code = 'ENOTDIR'\n    throw err\n  }\n  const dir = /** @type {!Array<string>} */ (await makePromise(readdir, dirPath))\n  const lsr = await lstatFiles(dirPath, dir)\n\n  const directories = lsr.filter(isDirectory) // reduce at once\n  const notDirectories = lsr.filter(isNotDirectory)\n\n  const files = notDirectories.reduce((acc, current) => {\n    const type = getType(current)\n    return {\n      ...acc,\n      [current.relativePath]: {\n        type,\n      },\n    }\n  }, {})\n\n  const dirs = await directories.reduce(async (acc, { path, relativePath }) => {\n    const res = await acc\n    const structure = await readDirStructure(path)\n    return {\n      ...res,\n      [relativePath]: structure,\n    }\n  }, {})\n\n  const content = {\n    ...files,\n    ...dirs,\n  }\n  return {\n    content,\n    type: 'Directory',\n  }\n}", "code_tokens": ["async", "function", "readDirStructure", "(", "dirPath", ")", "{", "if", "(", "!", "dirPath", ")", "{", "throw", "new", "Error", "(", "'Please specify a path to the directory'", ")", "}", "const", "ls", "=", "await", "makePromise", "(", "lstat", ",", "dirPath", ")", "if", "(", "!", "ls", ".", "isDirectory", "(", ")", ")", "{", "const", "err", "=", "new", "Error", "(", "'Path is not a directory'", ")", "err", ".", "code", "=", "'ENOTDIR'", "throw", "err", "}", "const", "dir", "=", "/** @type {!Array<string>} */", "(", "await", "makePromise", "(", "readdir", ",", "dirPath", ")", ")", "const", "lsr", "=", "await", "lstatFiles", "(", "dirPath", ",", "dir", ")", "const", "directories", "=", "lsr", ".", "filter", "(", "isDirectory", ")", "// reduce at once", "const", "notDirectories", "=", "lsr", ".", "filter", "(", "isNotDirectory", ")", "const", "files", "=", "notDirectories", ".", "reduce", "(", "(", "acc", ",", "current", ")", "=>", "{", "const", "type", "=", "getType", "(", "current", ")", "return", "{", "...", "acc", ",", "[", "current", ".", "relativePath", "]", ":", "{", "type", ",", "}", ",", "}", "}", ",", "{", "}", ")", "const", "dirs", "=", "await", "directories", ".", "reduce", "(", "async", "(", "acc", ",", "{", "path", ",", "relativePath", "}", ")", "=>", "{", "const", "res", "=", "await", "acc", "const", "structure", "=", "await", "readDirStructure", "(", "path", ")", "return", "{", "...", "res", ",", "[", "relativePath", "]", ":", "structure", ",", "}", "}", ",", "{", "}", ")", "const", "content", "=", "{", "...", "files", ",", "...", "dirs", ",", "}", "return", "{", "content", ",", "type", ":", "'Directory'", ",", "}", "}"], "docstring": "Read a directory, and return its structure as an object. Only `Files`, `Directories` and `Symlinks` are included!\n@param {string} dirPath Path to the directory.\n@returns {Promise<_readDirStructure.DirectoryStructure>} An object reflecting the directory structure.\n@example\n```js\nconst res = await readDirStructure('dir')\nresult:\n{\ntype: 'Directory',\ncontent: {\n'data.txt': {\ntype: 'File'\n},\nsubdir: {\ntype: 'Directory',\ncontent: {\n'data-ln.txt': {\ntype: 'SymbolicLink'\n},\n}\n}\n}\n}\n```", "docstring_tokens": ["Read", "a", "directory", "and", "return", "its", "structure", "as", "an", "object", ".", "Only", "Files", "Directories", "and", "Symlinks", "are", "included!"], "sha": "b3fcd367d122ad96c8123f5cf2783ac164205c2a", "url": "https://github.com/wrote/read-dir-structure/blob/b3fcd367d122ad96c8123f5cf2783ac164205c2a/build/index.js#L82-L125", "partition": "test"}
{"repo": "daliwali/simulacra", "path": "lib/bind_keys.js", "func_name": "getNextNode", "original_string": "function getNextNode (index, activeNodes) {\n  var i, j, nextNode\n\n  for (i = index, j = activeNodes.length; i < j; i++)\n    if (activeNodes[i]) {\n      nextNode = activeNodes[i]\n      break\n    }\n\n  return nextNode\n}", "language": "javascript", "code": "function getNextNode (index, activeNodes) {\n  var i, j, nextNode\n\n  for (i = index, j = activeNodes.length; i < j; i++)\n    if (activeNodes[i]) {\n      nextNode = activeNodes[i]\n      break\n    }\n\n  return nextNode\n}", "code_tokens": ["function", "getNextNode", "(", "index", ",", "activeNodes", ")", "{", "var", "i", ",", "j", ",", "nextNode", "for", "(", "i", "=", "index", ",", "j", "=", "activeNodes", ".", "length", ";", "i", "<", "j", ";", "i", "++", ")", "if", "(", "activeNodes", "[", "i", "]", ")", "{", "nextNode", "=", "activeNodes", "[", "i", "]", "break", "}", "return", "nextNode", "}"], "docstring": "Find next node in a potentially sparse array.", "docstring_tokens": ["Find", "next", "node", "in", "a", "potentially", "sparse", "array", "."], "sha": "b6bb7e2486f7722101f9e416ec345d49f3afa901", "url": "https://github.com/daliwali/simulacra/blob/b6bb7e2486f7722101f9e416ec345d49f3afa901/lib/bind_keys.js#L452-L462", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/collections/Message/MessageList.js", "func_name": "MessageList", "original_string": "function MessageList(props) {\n  const { children, className, items } = props\n  const classes = cx('list', className)\n  const rest = getUnhandledProps(MessageList, props)\n  const ElementType = getElementType(MessageList, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? _.map(items, MessageItem.create) : children}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function MessageList(props) {\n  const { children, className, items } = props\n  const classes = cx('list', className)\n  const rest = getUnhandledProps(MessageList, props)\n  const ElementType = getElementType(MessageList, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? _.map(items, MessageItem.create) : children}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "MessageList", "(", "props", ")", "{", "const", "{", "children", ",", "className", ",", "items", "}", "=", "props", "const", "classes", "=", "cx", "(", "'list'", ",", "className", ")", "const", "rest", "=", "getUnhandledProps", "(", "MessageList", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "MessageList", ",", "props", ")", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "childrenUtils", ".", "isNil", "(", "children", ")", "?", "_", ".", "map", "(", "items", ",", "MessageItem", ".", "create", ")", ":", "children", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A message can contain a list of items.", "docstring_tokens": ["A", "message", "can", "contain", "a", "list", "of", "items", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Message/MessageList.js#L18-L29", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/Component.js", "func_name": "", "original_string": "function(animation) {\n        if(this.activeAnimation) {\n            this.activeAnimation.on({\n                animationend: function(){\n                    this.show(animation);\n                },\n                scope: this,\n                single: true\n            });\n            return this;\n        }\n\n        var hidden = this.getHidden();\n        if (hidden || hidden === null) {\n            if (animation === true) {\n                animation = 'fadeIn';\n            }\n            else if (animation === undefined || (animation && animation.isComponent)) {\n                animation = this.getShowAnimation();\n            }\n\n            if (animation) {\n                this.beforeShowAnimation();\n                this.onBefore({\n                    hiddenchange: 'animateFn',\n                    scope: this,\n                    single: true,\n                    args: [animation]\n                });\n            }\n\n            this.setHidden(false);\n        }\n\n        return this;\n    }", "language": "javascript", "code": "function(animation) {\n        if(this.activeAnimation) {\n            this.activeAnimation.on({\n                animationend: function(){\n                    this.show(animation);\n                },\n                scope: this,\n                single: true\n            });\n            return this;\n        }\n\n        var hidden = this.getHidden();\n        if (hidden || hidden === null) {\n            if (animation === true) {\n                animation = 'fadeIn';\n            }\n            else if (animation === undefined || (animation && animation.isComponent)) {\n                animation = this.getShowAnimation();\n            }\n\n            if (animation) {\n                this.beforeShowAnimation();\n                this.onBefore({\n                    hiddenchange: 'animateFn',\n                    scope: this,\n                    single: true,\n                    args: [animation]\n                });\n            }\n\n            this.setHidden(false);\n        }\n\n        return this;\n    }", "code_tokens": ["function", "(", "animation", ")", "{", "if", "(", "this", ".", "activeAnimation", ")", "{", "this", ".", "activeAnimation", ".", "on", "(", "{", "animationend", ":", "function", "(", ")", "{", "this", ".", "show", "(", "animation", ")", ";", "}", ",", "scope", ":", "this", ",", "single", ":", "true", "}", ")", ";", "return", "this", ";", "}", "var", "hidden", "=", "this", ".", "getHidden", "(", ")", ";", "if", "(", "hidden", "||", "hidden", "===", "null", ")", "{", "if", "(", "animation", "===", "true", ")", "{", "animation", "=", "'fadeIn'", ";", "}", "else", "if", "(", "animation", "===", "undefined", "||", "(", "animation", "&&", "animation", ".", "isComponent", ")", ")", "{", "animation", "=", "this", ".", "getShowAnimation", "(", ")", ";", "}", "if", "(", "animation", ")", "{", "this", ".", "beforeShowAnimation", "(", ")", ";", "this", ".", "onBefore", "(", "{", "hiddenchange", ":", "'animateFn'", ",", "scope", ":", "this", ",", "single", ":", "true", ",", "args", ":", "[", "animation", "]", "}", ")", ";", "}", "this", ".", "setHidden", "(", "false", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Shows this component optionally using an animation.\n@param {Object/Boolean} [animation] You can specify an animation here or a bool to use the {@link #showAnimation} config.\n@return {Ext.Component}\n@chainable", "docstring_tokens": ["Shows", "this", "component", "optionally", "using", "an", "animation", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/Component.js#L2038-L2073", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/elements/Button/ButtonOr.js", "func_name": "ButtonOr", "original_string": "function ButtonOr(props) {\n  const { className, text } = props\n  const classes = cx('or', className)\n  const rest = getUnhandledProps(ButtonOr, props)\n  const ElementType = getElementType(ButtonOr, props)\n\n  return <ElementType {...rest} className={classes} data-text={text} />\n}", "language": "javascript", "code": "function ButtonOr(props) {\n  const { className, text } = props\n  const classes = cx('or', className)\n  const rest = getUnhandledProps(ButtonOr, props)\n  const ElementType = getElementType(ButtonOr, props)\n\n  return <ElementType {...rest} className={classes} data-text={text} />\n}", "code_tokens": ["function", "ButtonOr", "(", "props", ")", "{", "const", "{", "className", ",", "text", "}", "=", "props", "const", "classes", "=", "cx", "(", "'or'", ",", "className", ")", "const", "rest", "=", "getUnhandledProps", "(", "ButtonOr", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "ButtonOr", ",", "props", ")", "return", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", "data-text", "=", "{", "text", "}", "/", ">", "}"], "docstring": "Button groups can contain conditionals.", "docstring_tokens": ["Button", "groups", "can", "contain", "conditionals", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Button/ButtonOr.js#L10-L17", "partition": "test"}
{"repo": "algolia/gatsby-plugin-algolia", "path": "gatsby-node.js", "func_name": "moveIndex", "original_string": "async function moveIndex(client, sourceIndex, targetIndex) {\n  const { taskID } = await client.moveIndex(\n    sourceIndex.indexName,\n    targetIndex.indexName\n  );\n  return targetIndex.waitTask(taskID);\n}", "language": "javascript", "code": "async function moveIndex(client, sourceIndex, targetIndex) {\n  const { taskID } = await client.moveIndex(\n    sourceIndex.indexName,\n    targetIndex.indexName\n  );\n  return targetIndex.waitTask(taskID);\n}", "code_tokens": ["async", "function", "moveIndex", "(", "client", ",", "sourceIndex", ",", "targetIndex", ")", "{", "const", "{", "taskID", "}", "=", "await", "client", ".", "moveIndex", "(", "sourceIndex", ".", "indexName", ",", "targetIndex", ".", "indexName", ")", ";", "return", "targetIndex", ".", "waitTask", "(", "taskID", ")", ";", "}"], "docstring": "moves the source index to the target index\n@param client\n@param sourceIndex\n@param targetIndex\n@return {Promise}", "docstring_tokens": ["moves", "the", "source", "index", "to", "the", "target", "index"], "sha": "8bc3959f6d23fc683fa9b7041391faaa8d831f5d", "url": "https://github.com/algolia/gatsby-plugin-algolia/blob/8bc3959f6d23fc683fa9b7041391faaa8d831f5d/gatsby-node.js#L99-L105", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/plain-precompiled-build.js", "func_name": "log", "original_string": "function log(level) {\n\t    level = logger.lookupLevel(level);\n\n\t    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {\n\t      var method = logger.methodMap[level];\n\t      if (!console[method]) {\n\t        // eslint-disable-line no-console\n\t        method = 'log';\n\t      }\n\n\t      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        message[_key - 1] = arguments[_key];\n\t      }\n\n\t      console[method].apply(console, message); // eslint-disable-line no-console\n\t    }\n\t  }", "language": "javascript", "code": "function log(level) {\n\t    level = logger.lookupLevel(level);\n\n\t    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {\n\t      var method = logger.methodMap[level];\n\t      if (!console[method]) {\n\t        // eslint-disable-line no-console\n\t        method = 'log';\n\t      }\n\n\t      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        message[_key - 1] = arguments[_key];\n\t      }\n\n\t      console[method].apply(console, message); // eslint-disable-line no-console\n\t    }\n\t  }", "code_tokens": ["function", "log", "(", "level", ")", "{", "level", "=", "logger", ".", "lookupLevel", "(", "level", ")", ";", "if", "(", "typeof", "console", "!==", "'undefined'", "&&", "logger", ".", "lookupLevel", "(", "logger", ".", "level", ")", "<=", "level", ")", "{", "var", "method", "=", "logger", ".", "methodMap", "[", "level", "]", ";", "if", "(", "!", "console", "[", "method", "]", ")", "{", "// eslint-disable-line no-console", "method", "=", "'log'", ";", "}", "for", "(", "var", "_len", "=", "arguments", ".", "length", ",", "message", "=", "Array", "(", "_len", ">", "1", "?", "_len", "-", "1", ":", "0", ")", ",", "_key", "=", "1", ";", "_key", "<", "_len", ";", "_key", "++", ")", "{", "message", "[", "_key", "-", "1", "]", "=", "arguments", "[", "_key", "]", ";", "}", "console", "[", "method", "]", ".", "apply", "(", "console", ",", "message", ")", ";", "// eslint-disable-line no-console", "}", "}"], "docstring": "Can be overridden in the host environment", "docstring_tokens": ["Can", "be", "overridden", "in", "the", "host", "environment"], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/plain-precompiled-build.js#L17129-L17145", "partition": "test"}
{"repo": "GeoSensorWebLab/polarmap.js", "path": "js/leaflet.markercluster.js", "func_name": "", "original_string": "function (storageArray) {\n    storageArray = storageArray || [];\n\n    for (var i = this._childClusters.length - 1; i >= 0; i--) {\n      this._childClusters[i].getAllChildMarkers(storageArray);\n    }\n\n    for (var j = this._markers.length - 1; j >= 0; j--) {\n      storageArray.push(this._markers[j]);\n    }\n\n    return storageArray;\n  }", "language": "javascript", "code": "function (storageArray) {\n    storageArray = storageArray || [];\n\n    for (var i = this._childClusters.length - 1; i >= 0; i--) {\n      this._childClusters[i].getAllChildMarkers(storageArray);\n    }\n\n    for (var j = this._markers.length - 1; j >= 0; j--) {\n      storageArray.push(this._markers[j]);\n    }\n\n    return storageArray;\n  }", "code_tokens": ["function", "(", "storageArray", ")", "{", "storageArray", "=", "storageArray", "||", "[", "]", ";", "for", "(", "var", "i", "=", "this", ".", "_childClusters", ".", "length", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "this", ".", "_childClusters", "[", "i", "]", ".", "getAllChildMarkers", "(", "storageArray", ")", ";", "}", "for", "(", "var", "j", "=", "this", ".", "_markers", ".", "length", "-", "1", ";", "j", ">=", "0", ";", "j", "--", ")", "{", "storageArray", ".", "push", "(", "this", ".", "_markers", "[", "j", "]", ")", ";", "}", "return", "storageArray", ";", "}"], "docstring": "Recursively retrieve all child markers of this cluster", "docstring_tokens": ["Recursively", "retrieve", "all", "child", "markers", "of", "this", "cluster"], "sha": "fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b", "url": "https://github.com/GeoSensorWebLab/polarmap.js/blob/fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b/js/leaflet.markercluster.js#L1121-L1133", "partition": "test"}
{"repo": "everitoken/evtjs", "path": "src/evtLink.js", "func_name": "__calcKeyProvider", "original_string": "async function __calcKeyProvider(keyProvider) {\n    if (!keyProvider) { return []; }\n\n    // if keyProvider is function\n    if (keyProvider.apply && keyProvider.call) {\n        keyProvider = keyProvider();\n    }\n\n    // resolve for Promise\n    keyProvider = await Promise.resolve(keyProvider);\n\n    if (!Array.isArray(keyProvider)) {\n        keyProvider = [ keyProvider ];\n    }\n\n    for (let key of keyProvider) {\n        if (!EvtKey.isValidPrivateKey(key)) {\n            throw new Error(\"Invalid private key\");\n        }\n    }\n\n    return keyProvider;\n}", "language": "javascript", "code": "async function __calcKeyProvider(keyProvider) {\n    if (!keyProvider) { return []; }\n\n    // if keyProvider is function\n    if (keyProvider.apply && keyProvider.call) {\n        keyProvider = keyProvider();\n    }\n\n    // resolve for Promise\n    keyProvider = await Promise.resolve(keyProvider);\n\n    if (!Array.isArray(keyProvider)) {\n        keyProvider = [ keyProvider ];\n    }\n\n    for (let key of keyProvider) {\n        if (!EvtKey.isValidPrivateKey(key)) {\n            throw new Error(\"Invalid private key\");\n        }\n    }\n\n    return keyProvider;\n}", "code_tokens": ["async", "function", "__calcKeyProvider", "(", "keyProvider", ")", "{", "if", "(", "!", "keyProvider", ")", "{", "return", "[", "]", ";", "}", "// if keyProvider is function", "if", "(", "keyProvider", ".", "apply", "&&", "keyProvider", ".", "call", ")", "{", "keyProvider", "=", "keyProvider", "(", ")", ";", "}", "// resolve for Promise", "keyProvider", "=", "await", "Promise", ".", "resolve", "(", "keyProvider", ")", ";", "if", "(", "!", "Array", ".", "isArray", "(", "keyProvider", ")", ")", "{", "keyProvider", "=", "[", "keyProvider", "]", ";", "}", "for", "(", "let", "key", "of", "keyProvider", ")", "{", "if", "(", "!", "EvtKey", ".", "isValidPrivateKey", "(", "key", ")", ")", "{", "throw", "new", "Error", "(", "\"Invalid private key\"", ")", ";", "}", "}", "return", "keyProvider", ";", "}"], "docstring": "Calculate the value of keyProvider\n@param {string | string[] | function} keyProvider\n@returns {string[]}", "docstring_tokens": ["Calculate", "the", "value", "of", "keyProvider"], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L270-L292", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "", "original_string": "function ( pathToFile ) {\n    var me = this;\n    var dir = path.dirname( pathToFile );\n    var fName = path.basename( pathToFile );\n\n    me.load( fName, dir );\n  }", "language": "javascript", "code": "function ( pathToFile ) {\n    var me = this;\n    var dir = path.dirname( pathToFile );\n    var fName = path.basename( pathToFile );\n\n    me.load( fName, dir );\n  }", "code_tokens": ["function", "(", "pathToFile", ")", "{", "var", "me", "=", "this", ";", "var", "dir", "=", "path", ".", "dirname", "(", "pathToFile", ")", ";", "var", "fName", "=", "path", ".", "basename", "(", "pathToFile", ")", ";", "me", ".", "load", "(", "fName", ",", "dir", ")", ";", "}"], "docstring": "Load the cache from the provided file\n@method loadFile\n@param  {String} pathToFile the path to the file containing the info for the cache", "docstring_tokens": ["Load", "the", "cache", "from", "the", "provided", "file"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L15317-L15323", "partition": "test"}
{"repo": "expressjs/generator", "path": "bin/express-cli.js", "func_name": "main", "original_string": "function main () {\n  // Path\n  var destinationPath = program.args.shift() || '.'\n\n  // App name\n  var appName = createAppName(path.resolve(destinationPath)) || 'hello-world'\n\n  // View engine\n  if (program.view === true) {\n    if (program.ejs) program.view = 'ejs'\n    if (program.hbs) program.view = 'hbs'\n    if (program.hogan) program.view = 'hjs'\n    if (program.pug) program.view = 'pug'\n  }\n\n  // Default view engine\n  if (program.view === true) {\n    warning('the default view engine will not be jade in future releases\\n' +\n      \"use `--view=jade' or `--help' for additional options\")\n    program.view = 'jade'\n  }\n\n  // Generate application\n  emptyDirectory(destinationPath, function (empty) {\n    if (empty || program.force) {\n      createApplication(appName, destinationPath)\n    } else {\n      confirm('destination is not empty, continue? [y/N] ', function (ok) {\n        if (ok) {\n          process.stdin.destroy()\n          createApplication(appName, destinationPath)\n        } else {\n          console.error('aborting')\n          exit(1)\n        }\n      })\n    }\n  })\n}", "language": "javascript", "code": "function main () {\n  // Path\n  var destinationPath = program.args.shift() || '.'\n\n  // App name\n  var appName = createAppName(path.resolve(destinationPath)) || 'hello-world'\n\n  // View engine\n  if (program.view === true) {\n    if (program.ejs) program.view = 'ejs'\n    if (program.hbs) program.view = 'hbs'\n    if (program.hogan) program.view = 'hjs'\n    if (program.pug) program.view = 'pug'\n  }\n\n  // Default view engine\n  if (program.view === true) {\n    warning('the default view engine will not be jade in future releases\\n' +\n      \"use `--view=jade' or `--help' for additional options\")\n    program.view = 'jade'\n  }\n\n  // Generate application\n  emptyDirectory(destinationPath, function (empty) {\n    if (empty || program.force) {\n      createApplication(appName, destinationPath)\n    } else {\n      confirm('destination is not empty, continue? [y/N] ', function (ok) {\n        if (ok) {\n          process.stdin.destroy()\n          createApplication(appName, destinationPath)\n        } else {\n          console.error('aborting')\n          exit(1)\n        }\n      })\n    }\n  })\n}", "code_tokens": ["function", "main", "(", ")", "{", "// Path", "var", "destinationPath", "=", "program", ".", "args", ".", "shift", "(", ")", "||", "'.'", "// App name", "var", "appName", "=", "createAppName", "(", "path", ".", "resolve", "(", "destinationPath", ")", ")", "||", "'hello-world'", "// View engine", "if", "(", "program", ".", "view", "===", "true", ")", "{", "if", "(", "program", ".", "ejs", ")", "program", ".", "view", "=", "'ejs'", "if", "(", "program", ".", "hbs", ")", "program", ".", "view", "=", "'hbs'", "if", "(", "program", ".", "hogan", ")", "program", ".", "view", "=", "'hjs'", "if", "(", "program", ".", "pug", ")", "program", ".", "view", "=", "'pug'", "}", "// Default view engine", "if", "(", "program", ".", "view", "===", "true", ")", "{", "warning", "(", "'the default view engine will not be jade in future releases\\n'", "+", "\"use `--view=jade' or `--help' for additional options\"", ")", "program", ".", "view", "=", "'jade'", "}", "// Generate application", "emptyDirectory", "(", "destinationPath", ",", "function", "(", "empty", ")", "{", "if", "(", "empty", "||", "program", ".", "force", ")", "{", "createApplication", "(", "appName", ",", "destinationPath", ")", "}", "else", "{", "confirm", "(", "'destination is not empty, continue? [y/N] '", ",", "function", "(", "ok", ")", "{", "if", "(", "ok", ")", "{", "process", ".", "stdin", ".", "destroy", "(", ")", "createApplication", "(", "appName", ",", "destinationPath", ")", "}", "else", "{", "console", ".", "error", "(", "'aborting'", ")", "exit", "(", "1", ")", "}", "}", ")", "}", "}", ")", "}"], "docstring": "Main program.", "docstring_tokens": ["Main", "program", "."], "sha": "d1f3fcc6ccc7ab8986fb3438c82ab1a1f20dc50d", "url": "https://github.com/expressjs/generator/blob/d1f3fcc6ccc7ab8986fb3438c82ab1a1f20dc50d/bin/express-cli.js#L447-L485", "partition": "test"}
{"repo": "carbon-design-system/carbon-components", "path": "packages/icons/src/tools.js", "func_name": "flatMapAsync", "original_string": "async function flatMapAsync(source, mapFn) {\n  const results = await Promise.all(source.map(mapFn));\n  return results.reduce((acc, result) => acc.concat(result), []);\n}", "language": "javascript", "code": "async function flatMapAsync(source, mapFn) {\n  const results = await Promise.all(source.map(mapFn));\n  return results.reduce((acc, result) => acc.concat(result), []);\n}", "code_tokens": ["async", "function", "flatMapAsync", "(", "source", ",", "mapFn", ")", "{", "const", "results", "=", "await", "Promise", ".", "all", "(", "source", ".", "map", "(", "mapFn", ")", ")", ";", "return", "results", ".", "reduce", "(", "(", "acc", ",", "result", ")", "=>", "acc", ".", "concat", "(", "result", ")", ",", "[", "]", ")", ";", "}"], "docstring": "Copyright IBM Corp. 2018, 2018\n\nThis source code is licensed under the Apache-2.0 license found in the\nLICENSE file in the root directory of this source tree.", "docstring_tokens": ["Copyright", "IBM", "Corp", ".", "2018", "2018"], "sha": "e5ae58647d32aaae687e811d3f61e988cab1c302", "url": "https://github.com/carbon-design-system/carbon-components/blob/e5ae58647d32aaae687e811d3f61e988cab1c302/packages/icons/src/tools.js#L8-L11", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/ComponentQuery.js", "func_name": "", "original_string": "function(selector, root) {\n            var selectors = selector.split(','),\n                length = selectors.length,\n                i = 0,\n                results = [],\n                noDupResults = [],\n                dupMatcher = {},\n                query, resultsLn, cmp;\n\n            for (; i < length; i++) {\n                selector = Ext.String.trim(selectors[i]);\n                query = this.parse(selector);\n//                query = this.cache[selector];\n//                if (!query) {\n//                    this.cache[selector] = query = this.parse(selector);\n//                }\n                results = results.concat(query.execute(root));\n            }\n\n            // multiple selectors, potential to find duplicates\n            // lets filter them out.\n            if (length > 1) {\n                resultsLn = results.length;\n                for (i = 0; i < resultsLn; i++) {\n                    cmp = results[i];\n                    if (!dupMatcher[cmp.id]) {\n                        noDupResults.push(cmp);\n                        dupMatcher[cmp.id] = true;\n                    }\n                }\n                results = noDupResults;\n            }\n            return results;\n        }", "language": "javascript", "code": "function(selector, root) {\n            var selectors = selector.split(','),\n                length = selectors.length,\n                i = 0,\n                results = [],\n                noDupResults = [],\n                dupMatcher = {},\n                query, resultsLn, cmp;\n\n            for (; i < length; i++) {\n                selector = Ext.String.trim(selectors[i]);\n                query = this.parse(selector);\n//                query = this.cache[selector];\n//                if (!query) {\n//                    this.cache[selector] = query = this.parse(selector);\n//                }\n                results = results.concat(query.execute(root));\n            }\n\n            // multiple selectors, potential to find duplicates\n            // lets filter them out.\n            if (length > 1) {\n                resultsLn = results.length;\n                for (i = 0; i < resultsLn; i++) {\n                    cmp = results[i];\n                    if (!dupMatcher[cmp.id]) {\n                        noDupResults.push(cmp);\n                        dupMatcher[cmp.id] = true;\n                    }\n                }\n                results = noDupResults;\n            }\n            return results;\n        }", "code_tokens": ["function", "(", "selector", ",", "root", ")", "{", "var", "selectors", "=", "selector", ".", "split", "(", "','", ")", ",", "length", "=", "selectors", ".", "length", ",", "i", "=", "0", ",", "results", "=", "[", "]", ",", "noDupResults", "=", "[", "]", ",", "dupMatcher", "=", "{", "}", ",", "query", ",", "resultsLn", ",", "cmp", ";", "for", "(", ";", "i", "<", "length", ";", "i", "++", ")", "{", "selector", "=", "Ext", ".", "String", ".", "trim", "(", "selectors", "[", "i", "]", ")", ";", "query", "=", "this", ".", "parse", "(", "selector", ")", ";", "//                query = this.cache[selector];", "//                if (!query) {", "//                    this.cache[selector] = query = this.parse(selector);", "//                }", "results", "=", "results", ".", "concat", "(", "query", ".", "execute", "(", "root", ")", ")", ";", "}", "// multiple selectors, potential to find duplicates", "// lets filter them out.", "if", "(", "length", ">", "1", ")", "{", "resultsLn", "=", "results", ".", "length", ";", "for", "(", "i", "=", "0", ";", "i", "<", "resultsLn", ";", "i", "++", ")", "{", "cmp", "=", "results", "[", "i", "]", ";", "if", "(", "!", "dupMatcher", "[", "cmp", ".", "id", "]", ")", "{", "noDupResults", ".", "push", "(", "cmp", ")", ";", "dupMatcher", "[", "cmp", ".", "id", "]", "=", "true", ";", "}", "}", "results", "=", "noDupResults", ";", "}", "return", "results", ";", "}"], "docstring": "Returns an array of matched Components from within the passed root object.\n\nThis method filters returned Components in a similar way to how CSS selector based DOM\nqueries work using a textual selector string.\n\nSee class summary for details.\n\n@param {String} selector The selector string to filter returned Components\n@param {Ext.Container} root The Container within which to perform the query.\nIf omitted, all Components within the document are included in the search.\n\nThis parameter may also be an array of Components to filter according to the selector.\n@return {Ext.Component[]} The matched Components.\n\n@member Ext.ComponentQuery", "docstring_tokens": ["Returns", "an", "array", "of", "matched", "Components", "from", "within", "the", "passed", "root", "object", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/ComponentQuery.js#L433-L466", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "updateMenuUI", "original_string": "function updateMenuUI()\n   {\n      if (data)\n      {\n         $('.control-menu li[data-action=toggleFreezeAllNodes]').html(data.allNodesFixed ?\n          'Unfreeze nodes' : 'Freeze nodes');\n      }\n\n      appMenuToggleOptions.forEach(function(key)\n      {\n         var icon = appOptions[key] ? 'check_box' : 'check_box_outline_blank';\n         $('.control-menu li[data-action=' + key + '] i').html(icon);\n      });\n   }", "language": "javascript", "code": "function updateMenuUI()\n   {\n      if (data)\n      {\n         $('.control-menu li[data-action=toggleFreezeAllNodes]').html(data.allNodesFixed ?\n          'Unfreeze nodes' : 'Freeze nodes');\n      }\n\n      appMenuToggleOptions.forEach(function(key)\n      {\n         var icon = appOptions[key] ? 'check_box' : 'check_box_outline_blank';\n         $('.control-menu li[data-action=' + key + '] i').html(icon);\n      });\n   }", "code_tokens": ["function", "updateMenuUI", "(", ")", "{", "if", "(", "data", ")", "{", "$", "(", "'.control-menu li[data-action=toggleFreezeAllNodes]'", ")", ".", "html", "(", "data", ".", "allNodesFixed", "?", "'Unfreeze nodes'", ":", "'Freeze nodes'", ")", ";", "}", "appMenuToggleOptions", ".", "forEach", "(", "function", "(", "key", ")", "{", "var", "icon", "=", "appOptions", "[", "key", "]", "?", "'check_box'", ":", "'check_box_outline_blank'", ";", "$", "(", "'.control-menu li[data-action='", "+", "key", "+", "'] i'", ")", ".", "html", "(", "icon", ")", ";", "}", ")", ";", "}"], "docstring": "Provides handling of changing menu text & material icons based on current state.", "docstring_tokens": ["Provides", "handling", "of", "changing", "menu", "text", "&", "material", "icons", "based", "on", "current", "state", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L1073-L1086", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "", "original_string": "function(str, len) {\n    var lines = str.match(/\\n/g);\n    if (lines) this.line += lines.length;\n    var i = str.lastIndexOf('\\n');\n    this.column = ~i ? len - i : this.column + len;\n    this.parsed += str;\n    this.consume(len);\n  }", "language": "javascript", "code": "function(str, len) {\n    var lines = str.match(/\\n/g);\n    if (lines) this.line += lines.length;\n    var i = str.lastIndexOf('\\n');\n    this.column = ~i ? len - i : this.column + len;\n    this.parsed += str;\n    this.consume(len);\n  }", "code_tokens": ["function", "(", "str", ",", "len", ")", "{", "var", "lines", "=", "str", ".", "match", "(", "/", "\\n", "/", "g", ")", ";", "if", "(", "lines", ")", "this", ".", "line", "+=", "lines", ".", "length", ";", "var", "i", "=", "str", ".", "lastIndexOf", "(", "'\\n'", ")", ";", "this", ".", "column", "=", "~", "i", "?", "len", "-", "i", ":", "this", ".", "column", "+", "len", ";", "this", ".", "parsed", "+=", "str", ";", "this", ".", "consume", "(", "len", ")", ";", "}"], "docstring": "Update column based on `str`.", "docstring_tokens": ["Update", "column", "based", "on", "str", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L64866-L64873", "partition": "test"}
{"repo": "ralt/tartempion", "path": "cli/project.js", "func_name": "", "original_string": "function( project ) {\n        var current = process.cwd();\n\n        console.log( '\\nCreating folder \"' + project + '\"...' );\n\n        // First, create the directory\n        fs.mkdirSync( path.join( current, project ) );\n\n        console.log( '\\nCopying the files in \"' + project + '\"...' );\n\n        // Then, copy the files into it\n        wrench.copyDirSyncRecursive(\n            path.join( __dirname, 'default', 'project' ),\n            path.join( current, project )\n        );\n\n        console.log( '\\nCreating the package.json file...' );\n\n        // Open the package.json file and fill it in\n        // with the correct datas.\n\n        var packagePath = path.join( current, project, 'package.json' );\n\n        // First, get the datas\n        var pack = JSON.parse( fs.readFileSync( packagePath ));\n\n        // Add the properties in the object\n        pack.name = project;\n        pack.version = '0.0.1';\n        pack.dependencies = {\n            'tartempion': '0.0.x'\n        };\n\n        // And write the object to the package.json file\n        // by overriding everything in it.\n        fs.writeFileSync( packagePath, JSON.stringify( pack, null, 4 ) );\n\n        console.log( '\\nProject \"' + project + '\" created.\\n' );\n    }", "language": "javascript", "code": "function( project ) {\n        var current = process.cwd();\n\n        console.log( '\\nCreating folder \"' + project + '\"...' );\n\n        // First, create the directory\n        fs.mkdirSync( path.join( current, project ) );\n\n        console.log( '\\nCopying the files in \"' + project + '\"...' );\n\n        // Then, copy the files into it\n        wrench.copyDirSyncRecursive(\n            path.join( __dirname, 'default', 'project' ),\n            path.join( current, project )\n        );\n\n        console.log( '\\nCreating the package.json file...' );\n\n        // Open the package.json file and fill it in\n        // with the correct datas.\n\n        var packagePath = path.join( current, project, 'package.json' );\n\n        // First, get the datas\n        var pack = JSON.parse( fs.readFileSync( packagePath ));\n\n        // Add the properties in the object\n        pack.name = project;\n        pack.version = '0.0.1';\n        pack.dependencies = {\n            'tartempion': '0.0.x'\n        };\n\n        // And write the object to the package.json file\n        // by overriding everything in it.\n        fs.writeFileSync( packagePath, JSON.stringify( pack, null, 4 ) );\n\n        console.log( '\\nProject \"' + project + '\" created.\\n' );\n    }", "code_tokens": ["function", "(", "project", ")", "{", "var", "current", "=", "process", ".", "cwd", "(", ")", ";", "console", ".", "log", "(", "'\\nCreating folder \"'", "+", "project", "+", "'\"...'", ")", ";", "// First, create the directory", "fs", ".", "mkdirSync", "(", "path", ".", "join", "(", "current", ",", "project", ")", ")", ";", "console", ".", "log", "(", "'\\nCopying the files in \"'", "+", "project", "+", "'\"...'", ")", ";", "// Then, copy the files into it", "wrench", ".", "copyDirSyncRecursive", "(", "path", ".", "join", "(", "__dirname", ",", "'default'", ",", "'project'", ")", ",", "path", ".", "join", "(", "current", ",", "project", ")", ")", ";", "console", ".", "log", "(", "'\\nCreating the package.json file...'", ")", ";", "// Open the package.json file and fill it in", "// with the correct datas.", "var", "packagePath", "=", "path", ".", "join", "(", "current", ",", "project", ",", "'package.json'", ")", ";", "// First, get the datas", "var", "pack", "=", "JSON", ".", "parse", "(", "fs", ".", "readFileSync", "(", "packagePath", ")", ")", ";", "// Add the properties in the object", "pack", ".", "name", "=", "project", ";", "pack", ".", "version", "=", "'0.0.1'", ";", "pack", ".", "dependencies", "=", "{", "'tartempion'", ":", "'0.0.x'", "}", ";", "// And write the object to the package.json file", "// by overriding everything in it.", "fs", ".", "writeFileSync", "(", "packagePath", ",", "JSON", ".", "stringify", "(", "pack", ",", "null", ",", "4", ")", ")", ";", "console", ".", "log", "(", "'\\nProject \"'", "+", "project", "+", "'\" created.\\n'", ")", ";", "}"], "docstring": "Create a project with the default files and folders.\n\nThe default hierarchy can be found in the folder cli/default/\nof the tartempion module.\n\nThe only thing to dynamically create is the package.json file.", "docstring_tokens": ["Create", "a", "project", "with", "the", "default", "files", "and", "folders", "."], "sha": "0de497437261229575d40f49f20f9630bf6053e2", "url": "https://github.com/ralt/tartempion/blob/0de497437261229575d40f49f20f9630bf6053e2/cli/project.js#L16-L54", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "contextualTypeHasIndexSignature", "original_string": "function contextualTypeHasIndexSignature(type, kind) {\n            return !!(type.flags & 16384 /* Union */ ? ts.forEach(type.types, function (t) { return getIndexTypeOfStructuredType(t, kind); }) : getIndexTypeOfStructuredType(type, kind));\n        }", "language": "javascript", "code": "function contextualTypeHasIndexSignature(type, kind) {\n            return !!(type.flags & 16384 /* Union */ ? ts.forEach(type.types, function (t) { return getIndexTypeOfStructuredType(t, kind); }) : getIndexTypeOfStructuredType(type, kind));\n        }", "code_tokens": ["function", "contextualTypeHasIndexSignature", "(", "type", ",", "kind", ")", "{", "return", "!", "!", "(", "type", ".", "flags", "&", "16384", "/* Union */", "?", "ts", ".", "forEach", "(", "type", ".", "types", ",", "function", "(", "t", ")", "{", "return", "getIndexTypeOfStructuredType", "(", "t", ",", "kind", ")", ";", "}", ")", ":", "getIndexTypeOfStructuredType", "(", "type", ",", "kind", ")", ")", ";", "}"], "docstring": "Return true if the given contextual type provides an index signature of the given kind", "docstring_tokens": ["Return", "true", "if", "the", "given", "contextual", "type", "provides", "an", "index", "signature", "of", "the", "given", "kind"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L19655-L19657", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( keyContents ) {\n\t\t\tthis.keyContents = keyContents;\n\t\t\tthis.keyId = Backbone.Relational.store.resolveIdForItem( this.relatedModel, this.keyContents );\n\t\t}", "language": "javascript", "code": "function( keyContents ) {\n\t\t\tthis.keyContents = keyContents;\n\t\t\tthis.keyId = Backbone.Relational.store.resolveIdForItem( this.relatedModel, this.keyContents );\n\t\t}", "code_tokens": ["function", "(", "keyContents", ")", "{", "this", ".", "keyContents", "=", "keyContents", ";", "this", ".", "keyId", "=", "Backbone", ".", "Relational", ".", "store", ".", "resolveIdForItem", "(", "this", ".", "relatedModel", ",", "this", ".", "keyContents", ")", ";", "}"], "docstring": "Normalize and reduce `keyContents` to an `id`, for easier comparison\n@param {String|Number|Backbone.Model} keyContents", "docstring_tokens": ["Normalize", "and", "reduce", "keyContents", "to", "an", "id", "for", "easier", "comparison"], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L747-L750", "partition": "test"}
{"repo": "AustP/jwt-express", "path": "jwt-express.js", "func_name": "JWT", "original_string": "function JWT(secret, options) {\n    this.token = '';\n    this.payload = {};\n    this.secret = secret;\n    this.options = options;\n    this.valid = false;\n    this.expired = false;\n    this.stale = true;\n}", "language": "javascript", "code": "function JWT(secret, options) {\n    this.token = '';\n    this.payload = {};\n    this.secret = secret;\n    this.options = options;\n    this.valid = false;\n    this.expired = false;\n    this.stale = true;\n}", "code_tokens": ["function", "JWT", "(", "secret", ",", "options", ")", "{", "this", ".", "token", "=", "''", ";", "this", ".", "payload", "=", "{", "}", ";", "this", ".", "secret", "=", "secret", ";", "this", ".", "options", "=", "options", ";", "this", ".", "valid", "=", "false", ";", "this", ".", "expired", "=", "false", ";", "this", ".", "stale", "=", "true", ";", "}"], "docstring": "JWT - Class representing a JSON Web Token, it's payload, and it's status\n@param string secret The secret to sign / verify with\n@param object options The jwt-express options", "docstring_tokens": ["JWT", "-", "Class", "representing", "a", "JSON", "Web", "Token", "it", "s", "payload", "and", "it", "s", "status"], "sha": "f33e5c858e19826b7d767939a7048e3c5ff66387", "url": "https://github.com/AustP/jwt-express/blob/f33e5c858e19826b7d767939a7048e3c5ff66387/jwt-express.js#L9-L17", "partition": "test"}
{"repo": "chrisbateman/impetus", "path": "src/Impetus.js", "func_name": "checkBounds", "original_string": "function checkBounds(restrict) {\n            var xDiff = 0;\n            var yDiff = 0;\n\n            if (boundXmin !== undefined && targetX < boundXmin) {\n                xDiff = boundXmin - targetX;\n            } else if (boundXmax !== undefined && targetX > boundXmax) {\n                xDiff = boundXmax - targetX;\n            }\n\n            if (boundYmin !== undefined && targetY < boundYmin) {\n                yDiff = boundYmin - targetY;\n            } else if (boundYmax !== undefined && targetY > boundYmax) {\n                yDiff = boundYmax - targetY;\n            }\n\n            if (restrict) {\n                if (xDiff !== 0) {\n                    targetX = (xDiff > 0) ? boundXmin : boundXmax;\n                }\n                if (yDiff !== 0) {\n                    targetY = (yDiff > 0) ? boundYmin : boundYmax;\n                }\n            }\n\n            return {\n                x: xDiff,\n                y: yDiff,\n                inBounds: xDiff === 0 && yDiff === 0\n            };\n        }", "language": "javascript", "code": "function checkBounds(restrict) {\n            var xDiff = 0;\n            var yDiff = 0;\n\n            if (boundXmin !== undefined && targetX < boundXmin) {\n                xDiff = boundXmin - targetX;\n            } else if (boundXmax !== undefined && targetX > boundXmax) {\n                xDiff = boundXmax - targetX;\n            }\n\n            if (boundYmin !== undefined && targetY < boundYmin) {\n                yDiff = boundYmin - targetY;\n            } else if (boundYmax !== undefined && targetY > boundYmax) {\n                yDiff = boundYmax - targetY;\n            }\n\n            if (restrict) {\n                if (xDiff !== 0) {\n                    targetX = (xDiff > 0) ? boundXmin : boundXmax;\n                }\n                if (yDiff !== 0) {\n                    targetY = (yDiff > 0) ? boundYmin : boundYmax;\n                }\n            }\n\n            return {\n                x: xDiff,\n                y: yDiff,\n                inBounds: xDiff === 0 && yDiff === 0\n            };\n        }", "code_tokens": ["function", "checkBounds", "(", "restrict", ")", "{", "var", "xDiff", "=", "0", ";", "var", "yDiff", "=", "0", ";", "if", "(", "boundXmin", "!==", "undefined", "&&", "targetX", "<", "boundXmin", ")", "{", "xDiff", "=", "boundXmin", "-", "targetX", ";", "}", "else", "if", "(", "boundXmax", "!==", "undefined", "&&", "targetX", ">", "boundXmax", ")", "{", "xDiff", "=", "boundXmax", "-", "targetX", ";", "}", "if", "(", "boundYmin", "!==", "undefined", "&&", "targetY", "<", "boundYmin", ")", "{", "yDiff", "=", "boundYmin", "-", "targetY", ";", "}", "else", "if", "(", "boundYmax", "!==", "undefined", "&&", "targetY", ">", "boundYmax", ")", "{", "yDiff", "=", "boundYmax", "-", "targetY", ";", "}", "if", "(", "restrict", ")", "{", "if", "(", "xDiff", "!==", "0", ")", "{", "targetX", "=", "(", "xDiff", ">", "0", ")", "?", "boundXmin", ":", "boundXmax", ";", "}", "if", "(", "yDiff", "!==", "0", ")", "{", "targetY", "=", "(", "yDiff", ">", "0", ")", "?", "boundYmin", ":", "boundYmax", ";", "}", "}", "return", "{", "x", ":", "xDiff", ",", "y", ":", "yDiff", ",", "inBounds", ":", "xDiff", "===", "0", "&&", "yDiff", "===", "0", "}", ";", "}"], "docstring": "Determine position relative to bounds\n@param {Boolean} restrict Whether to restrict target to bounds", "docstring_tokens": ["Determine", "position", "relative", "to", "bounds"], "sha": "ef9fefec150655c06e2aec9e628422909fd5f4ce", "url": "https://github.com/chrisbateman/impetus/blob/ef9fefec150655c06e2aec9e628422909fd5f4ce/src/Impetus.js#L338-L368", "partition": "test"}
{"repo": "AmpersandJS/ampersand-state", "path": "ampersand-state.js", "func_name": "", "original_string": "function (property) {\n        var def = this._definition[property];\n        if (def.type === 'boolean') {\n            // if it's a bool, just flip it\n            this[property] = !this[property];\n        } else if (def && def.values) {\n            // If it's a property with an array of values\n            // skip to the next one looping back if at end.\n            this[property] = arrayNext(def.values, this[property]);\n        } else {\n            throw new TypeError('Can only toggle properties that are type `boolean` or have `values` array.');\n        }\n        return this;\n    }", "language": "javascript", "code": "function (property) {\n        var def = this._definition[property];\n        if (def.type === 'boolean') {\n            // if it's a bool, just flip it\n            this[property] = !this[property];\n        } else if (def && def.values) {\n            // If it's a property with an array of values\n            // skip to the next one looping back if at end.\n            this[property] = arrayNext(def.values, this[property]);\n        } else {\n            throw new TypeError('Can only toggle properties that are type `boolean` or have `values` array.');\n        }\n        return this;\n    }", "code_tokens": ["function", "(", "property", ")", "{", "var", "def", "=", "this", ".", "_definition", "[", "property", "]", ";", "if", "(", "def", ".", "type", "===", "'boolean'", ")", "{", "// if it's a bool, just flip it", "this", "[", "property", "]", "=", "!", "this", "[", "property", "]", ";", "}", "else", "if", "(", "def", "&&", "def", ".", "values", ")", "{", "// If it's a property with an array of values", "// skip to the next one looping back if at end.", "this", "[", "property", "]", "=", "arrayNext", "(", "def", ".", "values", ",", "this", "[", "property", "]", ")", ";", "}", "else", "{", "throw", "new", "TypeError", "(", "'Can only toggle properties that are type `boolean` or have `values` array.'", ")", ";", "}", "return", "this", ";", "}"], "docstring": "Toggle boolean properties or properties that have a `values` array in its definition.", "docstring_tokens": ["Toggle", "boolean", "properties", "or", "properties", "that", "have", "a", "values", "array", "in", "its", "definition", "."], "sha": "a85945b250e6db475b02ca53ae0ef8f7afaba935", "url": "https://github.com/AmpersandJS/ampersand-state/blob/a85945b250e6db475b02ca53ae0ef8f7afaba935/ampersand-state.js#L289-L302", "partition": "test"}
{"repo": "snapptop/ninjs-lodash", "path": "lib/files/js.js", "func_name": "_sigName", "original_string": "function _sigName(src) {\n  if (!_.isFunction(src)) return ''\n  let ret = _.trim(_.replace(src.toString(), 'function', ''))\n  ret = ret.substr(0, ret.indexOf('('))\n  return ret || ''\n}", "language": "javascript", "code": "function _sigName(src) {\n  if (!_.isFunction(src)) return ''\n  let ret = _.trim(_.replace(src.toString(), 'function', ''))\n  ret = ret.substr(0, ret.indexOf('('))\n  return ret || ''\n}", "code_tokens": ["function", "_sigName", "(", "src", ")", "{", "if", "(", "!", "_", ".", "isFunction", "(", "src", ")", ")", "return", "''", "let", "ret", "=", "_", ".", "trim", "(", "_", ".", "replace", "(", "src", ".", "toString", "(", ")", ",", "'function'", ",", "''", ")", ")", "ret", "=", "ret", ".", "substr", "(", "0", ",", "ret", ".", "indexOf", "(", "'('", ")", ")", "return", "ret", "||", "''", "}"], "docstring": "returns function signature name", "docstring_tokens": ["returns", "function", "signature", "name"], "sha": "fab253b7d96cc9bb3f2a1057efff2684c200bcee", "url": "https://github.com/snapptop/ninjs-lodash/blob/fab253b7d96cc9bb3f2a1057efff2684c200bcee/lib/files/js.js#L54-L59", "partition": "test"}
{"repo": "louisbl/cordova-plugin-locationservices", "path": "www/LocationServices.js", "func_name": "parseParameters", "original_string": "function parseParameters(options) {\n  var opt = {\n    maximumAge: 0,\n    enableHighAccuracy: true,\n    timeout: Infinity,\n    interval: 6000,\n    fastInterval: 1000,\n    priority: PRIORITY_HIGH_ACCURACY\n  };\n\n  if (options) {\n    if (options.maximumAge !== undefined && !isNaN(options.maximumAge) && options.maximumAge > 0) {\n      opt.maximumAge = options.maximumAge;\n    }\n    if (options.enableHighAccuracy !== undefined) {\n      opt.enableHighAccuracy = options.enableHighAccuracy;\n    }\n    if (options.timeout !== undefined && !isNaN(options.timeout)) {\n      if (options.timeout < 0) {\n        opt.timeout = 0;\n      } else {\n        opt.timeout = options.timeout;\n      }\n    }\n    if (options.interval !== undefined && !isNaN(options.interval) && options.interval > 0) {\n      opt.interval = options.interval;\n    }\n    if (options.fastInterval !== undefined && !isNaN(options.fastInterval) && options.fastInterval > 0) {\n      opt.fastInterval = options.fastInterval;\n    }\n    if (options.priority !== undefined && !isNaN(options.priority) && options.priority >= PRIORITY_NO_POWER && options.priority <= PRIORITY_HIGH_ACCURACY) {\n      if (options.priority === PRIORITY_NO_POWER) {\n        opt.priority = PRIORITY_NO_POWER;\n      }\n      if (options.priority === PRIORITY_LOW_POWER) {\n        opt.priority = PRIORITY_LOW_POWER;\n      }\n      if (options.priority === PRIORITY_BALANCED_POWER_ACCURACY) {\n        opt.priority = PRIORITY_BALANCED_POWER_ACCURACY;\n      }\n      if (options.priority === PRIORITY_HIGH_ACCURACY) {\n        opt.priority = PRIORITY_HIGH_ACCURACY;\n      }\n    }\n  }\n\n  return opt;\n}", "language": "javascript", "code": "function parseParameters(options) {\n  var opt = {\n    maximumAge: 0,\n    enableHighAccuracy: true,\n    timeout: Infinity,\n    interval: 6000,\n    fastInterval: 1000,\n    priority: PRIORITY_HIGH_ACCURACY\n  };\n\n  if (options) {\n    if (options.maximumAge !== undefined && !isNaN(options.maximumAge) && options.maximumAge > 0) {\n      opt.maximumAge = options.maximumAge;\n    }\n    if (options.enableHighAccuracy !== undefined) {\n      opt.enableHighAccuracy = options.enableHighAccuracy;\n    }\n    if (options.timeout !== undefined && !isNaN(options.timeout)) {\n      if (options.timeout < 0) {\n        opt.timeout = 0;\n      } else {\n        opt.timeout = options.timeout;\n      }\n    }\n    if (options.interval !== undefined && !isNaN(options.interval) && options.interval > 0) {\n      opt.interval = options.interval;\n    }\n    if (options.fastInterval !== undefined && !isNaN(options.fastInterval) && options.fastInterval > 0) {\n      opt.fastInterval = options.fastInterval;\n    }\n    if (options.priority !== undefined && !isNaN(options.priority) && options.priority >= PRIORITY_NO_POWER && options.priority <= PRIORITY_HIGH_ACCURACY) {\n      if (options.priority === PRIORITY_NO_POWER) {\n        opt.priority = PRIORITY_NO_POWER;\n      }\n      if (options.priority === PRIORITY_LOW_POWER) {\n        opt.priority = PRIORITY_LOW_POWER;\n      }\n      if (options.priority === PRIORITY_BALANCED_POWER_ACCURACY) {\n        opt.priority = PRIORITY_BALANCED_POWER_ACCURACY;\n      }\n      if (options.priority === PRIORITY_HIGH_ACCURACY) {\n        opt.priority = PRIORITY_HIGH_ACCURACY;\n      }\n    }\n  }\n\n  return opt;\n}", "code_tokens": ["function", "parseParameters", "(", "options", ")", "{", "var", "opt", "=", "{", "maximumAge", ":", "0", ",", "enableHighAccuracy", ":", "true", ",", "timeout", ":", "Infinity", ",", "interval", ":", "6000", ",", "fastInterval", ":", "1000", ",", "priority", ":", "PRIORITY_HIGH_ACCURACY", "}", ";", "if", "(", "options", ")", "{", "if", "(", "options", ".", "maximumAge", "!==", "undefined", "&&", "!", "isNaN", "(", "options", ".", "maximumAge", ")", "&&", "options", ".", "maximumAge", ">", "0", ")", "{", "opt", ".", "maximumAge", "=", "options", ".", "maximumAge", ";", "}", "if", "(", "options", ".", "enableHighAccuracy", "!==", "undefined", ")", "{", "opt", ".", "enableHighAccuracy", "=", "options", ".", "enableHighAccuracy", ";", "}", "if", "(", "options", ".", "timeout", "!==", "undefined", "&&", "!", "isNaN", "(", "options", ".", "timeout", ")", ")", "{", "if", "(", "options", ".", "timeout", "<", "0", ")", "{", "opt", ".", "timeout", "=", "0", ";", "}", "else", "{", "opt", ".", "timeout", "=", "options", ".", "timeout", ";", "}", "}", "if", "(", "options", ".", "interval", "!==", "undefined", "&&", "!", "isNaN", "(", "options", ".", "interval", ")", "&&", "options", ".", "interval", ">", "0", ")", "{", "opt", ".", "interval", "=", "options", ".", "interval", ";", "}", "if", "(", "options", ".", "fastInterval", "!==", "undefined", "&&", "!", "isNaN", "(", "options", ".", "fastInterval", ")", "&&", "options", ".", "fastInterval", ">", "0", ")", "{", "opt", ".", "fastInterval", "=", "options", ".", "fastInterval", ";", "}", "if", "(", "options", ".", "priority", "!==", "undefined", "&&", "!", "isNaN", "(", "options", ".", "priority", ")", "&&", "options", ".", "priority", ">=", "PRIORITY_NO_POWER", "&&", "options", ".", "priority", "<=", "PRIORITY_HIGH_ACCURACY", ")", "{", "if", "(", "options", ".", "priority", "===", "PRIORITY_NO_POWER", ")", "{", "opt", ".", "priority", "=", "PRIORITY_NO_POWER", ";", "}", "if", "(", "options", ".", "priority", "===", "PRIORITY_LOW_POWER", ")", "{", "opt", ".", "priority", "=", "PRIORITY_LOW_POWER", ";", "}", "if", "(", "options", ".", "priority", "===", "PRIORITY_BALANCED_POWER_ACCURACY", ")", "{", "opt", ".", "priority", "=", "PRIORITY_BALANCED_POWER_ACCURACY", ";", "}", "if", "(", "options", ".", "priority", "===", "PRIORITY_HIGH_ACCURACY", ")", "{", "opt", ".", "priority", "=", "PRIORITY_HIGH_ACCURACY", ";", "}", "}", "}", "return", "opt", ";", "}"], "docstring": "Returns default params, overrides if provided with values", "docstring_tokens": ["Returns", "default", "params", "overrides", "if", "provided", "with", "values"], "sha": "9a605c439f6685a6ecb77ceeaffa257c97132e3a", "url": "https://github.com/louisbl/cordova-plugin-locationservices/blob/9a605c439f6685a6ecb77ceeaffa257c97132e3a/www/LocationServices.js#L36-L83", "partition": "test"}
{"repo": "napolitano/cordova-plugin-intent", "path": "example/app/platforms/android/cordova/lib/retry.js", "func_name": "onRejected", "original_string": "function onRejected(error) {\n\n            attemts_left -= 1;\n\n            if (attemts_left < 1) {\n                throw error;\n            }\n\n            console.log(\"A retried call failed. Retrying \" + attemts_left + \" more time(s).\");\n\n            // retry call self again with the same arguments, except attemts_left is now lower\n            var fullArguments = [attemts_left, promiseFunction].concat(promiseFunctionArguments);\n            return module.exports.retryPromise.apply(undefined, fullArguments);\n        }", "language": "javascript", "code": "function onRejected(error) {\n\n            attemts_left -= 1;\n\n            if (attemts_left < 1) {\n                throw error;\n            }\n\n            console.log(\"A retried call failed. Retrying \" + attemts_left + \" more time(s).\");\n\n            // retry call self again with the same arguments, except attemts_left is now lower\n            var fullArguments = [attemts_left, promiseFunction].concat(promiseFunctionArguments);\n            return module.exports.retryPromise.apply(undefined, fullArguments);\n        }", "code_tokens": ["function", "onRejected", "(", "error", ")", "{", "attemts_left", "-=", "1", ";", "if", "(", "attemts_left", "<", "1", ")", "{", "throw", "error", ";", "}", "console", ".", "log", "(", "\"A retried call failed. Retrying \"", "+", "attemts_left", "+", "\" more time(s).\"", ")", ";", "// retry call self again with the same arguments, except attemts_left is now lower", "var", "fullArguments", "=", "[", "attemts_left", ",", "promiseFunction", "]", ".", "concat", "(", "promiseFunctionArguments", ")", ";", "return", "module", ".", "exports", ".", "retryPromise", ".", "apply", "(", "undefined", ",", "fullArguments", ")", ";", "}"], "docstring": "on rejection either retry, or throw the error", "docstring_tokens": ["on", "rejection", "either", "retry", "or", "throw", "the", "error"], "sha": "0a47226e64da1e349e2ab2f5e9e0cc2a4e1c5555", "url": "https://github.com/napolitano/cordova-plugin-intent/blob/0a47226e64da1e349e2ab2f5e9e0cc2a4e1c5555/example/app/platforms/android/cordova/lib/retry.js#L51-L64", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/plugman/install.js", "func_name": "callEngineScripts", "original_string": "function callEngineScripts (engines, project_dir) {\n\n    return Promise.all(\n        engines.map(function (engine) {\n            // CB-5192; on Windows scriptSrc doesn't have file extension so we shouldn't check whether the script exists\n            var scriptPath = engine.scriptSrc || null;\n            if (scriptPath && (isWindows || fs.existsSync(engine.scriptSrc))) {\n\n                if (!isWindows) { // not required on Windows\n                    fs.chmodSync(engine.scriptSrc, '755');\n                }\n                return superspawn.spawn(scriptPath)\n                    .then(stdout => {\n                        engine.currentVersion = cleanVersionOutput(stdout, engine.name);\n                        if (engine.currentVersion === '') {\n                            events.emit('warn', engine.name + ' version check returned nothing (' + scriptPath + '), continuing anyways.');\n                            engine.currentVersion = null;\n                        }\n                    }, () => {\n                        events.emit('warn', engine.name + ' version check failed (' + scriptPath + '), continuing anyways.');\n                        engine.currentVersion = null;\n                    })\n                    .then(_ => engine);\n            } else {\n\n                if (engine.currentVersion) {\n                    engine.currentVersion = cleanVersionOutput(engine.currentVersion, engine.name);\n                } else {\n                    events.emit('warn', engine.name + ' version not detected (lacks script ' + scriptPath + ' ), continuing.');\n                }\n\n                return Promise.resolve(engine);\n            }\n        })\n    );\n}", "language": "javascript", "code": "function callEngineScripts (engines, project_dir) {\n\n    return Promise.all(\n        engines.map(function (engine) {\n            // CB-5192; on Windows scriptSrc doesn't have file extension so we shouldn't check whether the script exists\n            var scriptPath = engine.scriptSrc || null;\n            if (scriptPath && (isWindows || fs.existsSync(engine.scriptSrc))) {\n\n                if (!isWindows) { // not required on Windows\n                    fs.chmodSync(engine.scriptSrc, '755');\n                }\n                return superspawn.spawn(scriptPath)\n                    .then(stdout => {\n                        engine.currentVersion = cleanVersionOutput(stdout, engine.name);\n                        if (engine.currentVersion === '') {\n                            events.emit('warn', engine.name + ' version check returned nothing (' + scriptPath + '), continuing anyways.');\n                            engine.currentVersion = null;\n                        }\n                    }, () => {\n                        events.emit('warn', engine.name + ' version check failed (' + scriptPath + '), continuing anyways.');\n                        engine.currentVersion = null;\n                    })\n                    .then(_ => engine);\n            } else {\n\n                if (engine.currentVersion) {\n                    engine.currentVersion = cleanVersionOutput(engine.currentVersion, engine.name);\n                } else {\n                    events.emit('warn', engine.name + ' version not detected (lacks script ' + scriptPath + ' ), continuing.');\n                }\n\n                return Promise.resolve(engine);\n            }\n        })\n    );\n}", "code_tokens": ["function", "callEngineScripts", "(", "engines", ",", "project_dir", ")", "{", "return", "Promise", ".", "all", "(", "engines", ".", "map", "(", "function", "(", "engine", ")", "{", "// CB-5192; on Windows scriptSrc doesn't have file extension so we shouldn't check whether the script exists", "var", "scriptPath", "=", "engine", ".", "scriptSrc", "||", "null", ";", "if", "(", "scriptPath", "&&", "(", "isWindows", "||", "fs", ".", "existsSync", "(", "engine", ".", "scriptSrc", ")", ")", ")", "{", "if", "(", "!", "isWindows", ")", "{", "// not required on Windows", "fs", ".", "chmodSync", "(", "engine", ".", "scriptSrc", ",", "'755'", ")", ";", "}", "return", "superspawn", ".", "spawn", "(", "scriptPath", ")", ".", "then", "(", "stdout", "=>", "{", "engine", ".", "currentVersion", "=", "cleanVersionOutput", "(", "stdout", ",", "engine", ".", "name", ")", ";", "if", "(", "engine", ".", "currentVersion", "===", "''", ")", "{", "events", ".", "emit", "(", "'warn'", ",", "engine", ".", "name", "+", "' version check returned nothing ('", "+", "scriptPath", "+", "'), continuing anyways.'", ")", ";", "engine", ".", "currentVersion", "=", "null", ";", "}", "}", ",", "(", ")", "=>", "{", "events", ".", "emit", "(", "'warn'", ",", "engine", ".", "name", "+", "' version check failed ('", "+", "scriptPath", "+", "'), continuing anyways.'", ")", ";", "engine", ".", "currentVersion", "=", "null", ";", "}", ")", ".", "then", "(", "_", "=>", "engine", ")", ";", "}", "else", "{", "if", "(", "engine", ".", "currentVersion", ")", "{", "engine", ".", "currentVersion", "=", "cleanVersionOutput", "(", "engine", ".", "currentVersion", ",", "engine", ".", "name", ")", ";", "}", "else", "{", "events", ".", "emit", "(", "'warn'", ",", "engine", ".", "name", "+", "' version not detected (lacks script '", "+", "scriptPath", "+", "' ), continuing.'", ")", ";", "}", "return", "Promise", ".", "resolve", "(", "engine", ")", ";", "}", "}", ")", ")", ";", "}"], "docstring": "exec engine scripts in order to get the current engine version Returns a promise for the array of engines.", "docstring_tokens": ["exec", "engine", "scripts", "in", "order", "to", "get", "the", "current", "engine", "version", "Returns", "a", "promise", "for", "the", "array", "of", "engines", "."], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/plugman/install.js#L163-L198", "partition": "test"}
{"repo": "tjworks/angoose", "path": "lib/client/angoose-client.js", "func_name": "compile", "original_string": "function compile(modelName, schema, dependencies) {\n        logger.trace(\"Compiling schema \", modelName)\n        var model = function AngooseModule(data) {\n            //@todo proper clone\n            for (var i in data) {\n                this[i] = data[i];\n            }\n        };\n\r\n        model.toString = function() {\r\n            return \"PROXY: function \" + modelName + \"()\";\r\n        }\n        // static methods\n        for (var name in schema.statics) {\r\n            model[name] = createProxy(model, name, schema.statics[name], 'static');\r\n        }\r\n        for (var name in schema.methods) {\r\n            model.prototype[name] = createProxy(model, name, schema.methods[name], 'instance');\r\n        }\n\n        //model.angoose$ = staticInvoker;\n        model.dependencies$ = dependencies;\n        model.schema = schema;\n        //model.prototype.angoose$ = instanceInvoker;\n        //model.prototype.classname$ = modelName;\n        //model.prototype.schema$ = schema;\n        model.prototype.get = getter;\r\n        model.prototype.set = setter;\n        model.modelName = modelName; // this is to be compatible with backend mongoose\r\n        model.name = modelName; \n\n        // merge data into this instance\n        model.prototype.mergeData = function(source) {\n            if ( typeof source != \"object\")\n                throw \"Invalid source object, must be an model instance\";\r\n            //@todo: proper implementation\n            for (var i in source) {\n                this[i] = source[i];\n            }\n        }\n        AngooseClient.models = AngooseClient.models || {};\n        AngooseClient.models[modelName] = model;\n        return model;\n    }", "language": "javascript", "code": "function compile(modelName, schema, dependencies) {\n        logger.trace(\"Compiling schema \", modelName)\n        var model = function AngooseModule(data) {\n            //@todo proper clone\n            for (var i in data) {\n                this[i] = data[i];\n            }\n        };\n\r\n        model.toString = function() {\r\n            return \"PROXY: function \" + modelName + \"()\";\r\n        }\n        // static methods\n        for (var name in schema.statics) {\r\n            model[name] = createProxy(model, name, schema.statics[name], 'static');\r\n        }\r\n        for (var name in schema.methods) {\r\n            model.prototype[name] = createProxy(model, name, schema.methods[name], 'instance');\r\n        }\n\n        //model.angoose$ = staticInvoker;\n        model.dependencies$ = dependencies;\n        model.schema = schema;\n        //model.prototype.angoose$ = instanceInvoker;\n        //model.prototype.classname$ = modelName;\n        //model.prototype.schema$ = schema;\n        model.prototype.get = getter;\r\n        model.prototype.set = setter;\n        model.modelName = modelName; // this is to be compatible with backend mongoose\r\n        model.name = modelName; \n\n        // merge data into this instance\n        model.prototype.mergeData = function(source) {\n            if ( typeof source != \"object\")\n                throw \"Invalid source object, must be an model instance\";\r\n            //@todo: proper implementation\n            for (var i in source) {\n                this[i] = source[i];\n            }\n        }\n        AngooseClient.models = AngooseClient.models || {};\n        AngooseClient.models[modelName] = model;\n        return model;\n    }", "code_tokens": ["function", "compile", "(", "modelName", ",", "schema", ",", "dependencies", ")", "{", "logger", ".", "trace", "(", "\"Compiling schema \"", ",", "modelName", ")", "var", "model", "=", "function", "AngooseModule", "(", "data", ")", "{", "//@todo proper clone", "for", "(", "var", "i", "in", "data", ")", "{", "this", "[", "i", "]", "=", "data", "[", "i", "]", ";", "}", "}", ";", "model", ".", "toString", "=", "function", "(", ")", "{", "return", "\"PROXY: function \"", "+", "modelName", "+", "\"()\"", ";", "}", "// static methods", "for", "(", "var", "name", "in", "schema", ".", "statics", ")", "{", "model", "[", "name", "]", "=", "createProxy", "(", "model", ",", "name", ",", "schema", ".", "statics", "[", "name", "]", ",", "'static'", ")", ";", "}", "for", "(", "var", "name", "in", "schema", ".", "methods", ")", "{", "model", ".", "prototype", "[", "name", "]", "=", "createProxy", "(", "model", ",", "name", ",", "schema", ".", "methods", "[", "name", "]", ",", "'instance'", ")", ";", "}", "//model.angoose$ = staticInvoker;", "model", ".", "dependencies$", "=", "dependencies", ";", "model", ".", "schema", "=", "schema", ";", "//model.prototype.angoose$ = instanceInvoker;", "//model.prototype.classname$ = modelName;", "//model.prototype.schema$ = schema;", "model", ".", "prototype", ".", "get", "=", "getter", ";", "model", ".", "prototype", ".", "set", "=", "setter", ";", "model", ".", "modelName", "=", "modelName", ";", "// this is to be compatible with backend mongoose\r", "model", ".", "name", "=", "modelName", ";", "// merge data into this instance", "model", ".", "prototype", ".", "mergeData", "=", "function", "(", "source", ")", "{", "if", "(", "typeof", "source", "!=", "\"object\"", ")", "throw", "\"Invalid source object, must be an model instance\"", ";", "//@todo: proper implementation", "for", "(", "var", "i", "in", "source", ")", "{", "this", "[", "i", "]", "=", "source", "[", "i", "]", ";", "}", "}", "AngooseClient", ".", "models", "=", "AngooseClient", ".", "models", "||", "{", "}", ";", "AngooseClient", ".", "models", "[", "modelName", "]", "=", "model", ";", "return", "model", ";", "}"], "docstring": "compile the model based on the server side schema", "docstring_tokens": ["compile", "the", "model", "based", "on", "the", "server", "side", "schema"], "sha": "2172f7a9f44d1337156792bf4dc382805b47e121", "url": "https://github.com/tjworks/angoose/blob/2172f7a9f44d1337156792bf4dc382805b47e121/lib/client/angoose-client.js#L249-L292", "partition": "test"}
{"repo": "enhancv/popup-tools", "path": "src/PopupTools.js", "func_name": "popupWithPost", "original_string": "function popupWithPost(url, postData, name, options, callback) {\n    function openWithPostData(popupUrl, popupName, optionsString) {\n        return openPopupWithPost(popupUrl, postData, popupName, optionsString);\n    }\n\n    return popupExecute(openWithPostData, url, name, options, callback);\n}", "language": "javascript", "code": "function popupWithPost(url, postData, name, options, callback) {\n    function openWithPostData(popupUrl, popupName, optionsString) {\n        return openPopupWithPost(popupUrl, postData, popupName, optionsString);\n    }\n\n    return popupExecute(openWithPostData, url, name, options, callback);\n}", "code_tokens": ["function", "popupWithPost", "(", "url", ",", "postData", ",", "name", ",", "options", ",", "callback", ")", "{", "function", "openWithPostData", "(", "popupUrl", ",", "popupName", ",", "optionsString", ")", "{", "return", "openPopupWithPost", "(", "popupUrl", ",", "postData", ",", "popupName", ",", "optionsString", ")", ";", "}", "return", "popupExecute", "(", "openWithPostData", ",", "url", ",", "name", ",", "options", ",", "callback", ")", ";", "}"], "docstring": "Open a popup using the first argument.\nPost the data into the open popup.\nWait for it to close and call the callback.\nSet the options string using the options object\nReturns the window object\n\n@param  {String} url\n@param  {Object} postData\n@param  {String} name\n@param  {Object} options\n@param  {Function} callback\n@return {Object}", "docstring_tokens": ["Open", "a", "popup", "using", "the", "first", "argument", ".", "Post", "the", "data", "into", "the", "open", "popup", ".", "Wait", "for", "it", "to", "close", "and", "call", "the", "callback", ".", "Set", "the", "options", "string", "using", "the", "options", "object", "Returns", "the", "window", "object"], "sha": "772b192920929112164f261c632d6d201a79f15a", "url": "https://github.com/enhancv/popup-tools/blob/772b192920929112164f261c632d6d201a79f15a/src/PopupTools.js#L200-L206", "partition": "test"}
{"repo": "Katochimoto/xblocks-core", "path": "src/xblocks/block.js", "func_name": "blockInit", "original_string": "function blockInit(node) {\n    if (!node[ Constants.TAGNAME ]) {\n        node[ Constants.INSERTED ] = false;\n        node[ Constants.TAGNAME ] = node.tagName.toLowerCase();\n        node[ Constants.TMPL ] = {};\n        node[ Constants.UID ] = uniqueId();\n\n        return true;\n    }\n\n    return false;\n}", "language": "javascript", "code": "function blockInit(node) {\n    if (!node[ Constants.TAGNAME ]) {\n        node[ Constants.INSERTED ] = false;\n        node[ Constants.TAGNAME ] = node.tagName.toLowerCase();\n        node[ Constants.TMPL ] = {};\n        node[ Constants.UID ] = uniqueId();\n\n        return true;\n    }\n\n    return false;\n}", "code_tokens": ["function", "blockInit", "(", "node", ")", "{", "if", "(", "!", "node", "[", "Constants", ".", "TAGNAME", "]", ")", "{", "node", "[", "Constants", ".", "INSERTED", "]", "=", "false", ";", "node", "[", "Constants", ".", "TAGNAME", "]", "=", "node", ".", "tagName", ".", "toLowerCase", "(", ")", ";", "node", "[", "Constants", ".", "TMPL", "]", "=", "{", "}", ";", "node", "[", "Constants", ".", "UID", "]", "=", "uniqueId", "(", ")", ";", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Initialization of the element.\n@example\nblockInit(node);\n@param {HTMLElement} node\n@returns {boolean}\n@private", "docstring_tokens": ["Initialization", "of", "the", "element", "."], "sha": "714102b7c2adb4ae197403df252e967a1b967bb1", "url": "https://github.com/Katochimoto/xblocks-core/blob/714102b7c2adb4ae197403df252e967a1b967bb1/src/xblocks/block.js#L195-L206", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "Command", "original_string": "function Command(name) {\n      this.commands = [];\n      this.options = [];\n      this._execs = [];\n      this._allowUnknownOption = false;\n      this._args = [];\n      this._name = name;\n    }", "language": "javascript", "code": "function Command(name) {\n      this.commands = [];\n      this.options = [];\n      this._execs = [];\n      this._allowUnknownOption = false;\n      this._args = [];\n      this._name = name;\n    }", "code_tokens": ["function", "Command", "(", "name", ")", "{", "this", ".", "commands", "=", "[", "]", ";", "this", ".", "options", "=", "[", "]", ";", "this", ".", "_execs", "=", "[", "]", ";", "this", ".", "_allowUnknownOption", "=", "false", ";", "this", ".", "_args", "=", "[", "]", ";", "this", ".", "_name", "=", "name", ";", "}"], "docstring": "Initialize a new `Command`.\n\n@param {String} name\n@api public", "docstring_tokens": ["Initialize", "a", "new", "Command", "."], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L53387-L53394", "partition": "test"}
{"repo": "chrisbateman/impetus", "path": "dist/impetus.js", "func_name": "onDown", "original_string": "function onDown(ev) {\n            var event = normalizeEvent(ev);\n            if (!pointerActive && !paused) {\n                pointerActive = true;\n                decelerating = false;\n                pointerId = event.id;\n\n                pointerLastX = pointerCurrentX = event.x;\n                pointerLastY = pointerCurrentY = event.y;\n                trackingPoints = [];\n                addTrackingPoint(pointerLastX, pointerLastY);\n\n                addRuntimeEvents();\n            }\n        }", "language": "javascript", "code": "function onDown(ev) {\n            var event = normalizeEvent(ev);\n            if (!pointerActive && !paused) {\n                pointerActive = true;\n                decelerating = false;\n                pointerId = event.id;\n\n                pointerLastX = pointerCurrentX = event.x;\n                pointerLastY = pointerCurrentY = event.y;\n                trackingPoints = [];\n                addTrackingPoint(pointerLastX, pointerLastY);\n\n                addRuntimeEvents();\n            }\n        }", "code_tokens": ["function", "onDown", "(", "ev", ")", "{", "var", "event", "=", "normalizeEvent", "(", "ev", ")", ";", "if", "(", "!", "pointerActive", "&&", "!", "paused", ")", "{", "pointerActive", "=", "true", ";", "decelerating", "=", "false", ";", "pointerId", "=", "event", ".", "id", ";", "pointerLastX", "=", "pointerCurrentX", "=", "event", ".", "x", ";", "pointerLastY", "=", "pointerCurrentY", "=", "event", ".", "y", ";", "trackingPoints", "=", "[", "]", ";", "addTrackingPoint", "(", "pointerLastX", ",", "pointerLastY", ")", ";", "addRuntimeEvents", "(", ")", ";", "}", "}"], "docstring": "Initializes movement tracking\n@param  {Object} ev Normalized event", "docstring_tokens": ["Initializes", "movement", "tracking"], "sha": "ef9fefec150655c06e2aec9e628422909fd5f4ce", "url": "https://github.com/chrisbateman/impetus/blob/ef9fefec150655c06e2aec9e628422909fd5f4ce/dist/impetus.js#L231-L245", "partition": "test"}
{"repo": "martinic/ember-cli-deploy-build-plus", "path": "index.js", "func_name": "", "original_string": "function() {\n    var appEnv = this.app.env;\n    if (process.env.DEPLOY_TARGET) {\n      appEnv = process.env.DEPLOY_TARGET;\n    }\n    var publicFiles = new Funnel(this.app.trees.public);\n\n    this._requireBuildPackages();\n\n    fs.stat(\n      path.join(this.project.root, 'public', 'robots.txt'),\n      function(err, stats) {\n        if (stats && stats.isFile()) {\n          console.log(chalk.yellow('There is a robots.txt in /public and ENV specific robots.txt are ignored!'));\n        }\n      }\n    );\n\n    publicFiles = stew.rename(\n      publicFiles,\n      'robots-' + appEnv + '.txt',\n      'robots.txt'\n    );\n\n    return new Funnel(publicFiles, {\n      srcDir: '/',\n      destDir: '/'\n    });\n  }", "language": "javascript", "code": "function() {\n    var appEnv = this.app.env;\n    if (process.env.DEPLOY_TARGET) {\n      appEnv = process.env.DEPLOY_TARGET;\n    }\n    var publicFiles = new Funnel(this.app.trees.public);\n\n    this._requireBuildPackages();\n\n    fs.stat(\n      path.join(this.project.root, 'public', 'robots.txt'),\n      function(err, stats) {\n        if (stats && stats.isFile()) {\n          console.log(chalk.yellow('There is a robots.txt in /public and ENV specific robots.txt are ignored!'));\n        }\n      }\n    );\n\n    publicFiles = stew.rename(\n      publicFiles,\n      'robots-' + appEnv + '.txt',\n      'robots.txt'\n    );\n\n    return new Funnel(publicFiles, {\n      srcDir: '/',\n      destDir: '/'\n    });\n  }", "code_tokens": ["function", "(", ")", "{", "var", "appEnv", "=", "this", ".", "app", ".", "env", ";", "if", "(", "process", ".", "env", ".", "DEPLOY_TARGET", ")", "{", "appEnv", "=", "process", ".", "env", ".", "DEPLOY_TARGET", ";", "}", "var", "publicFiles", "=", "new", "Funnel", "(", "this", ".", "app", ".", "trees", ".", "public", ")", ";", "this", ".", "_requireBuildPackages", "(", ")", ";", "fs", ".", "stat", "(", "path", ".", "join", "(", "this", ".", "project", ".", "root", ",", "'public'", ",", "'robots.txt'", ")", ",", "function", "(", "err", ",", "stats", ")", "{", "if", "(", "stats", "&&", "stats", ".", "isFile", "(", ")", ")", "{", "console", ".", "log", "(", "chalk", ".", "yellow", "(", "'There is a robots.txt in /public and ENV specific robots.txt are ignored!'", ")", ")", ";", "}", "}", ")", ";", "publicFiles", "=", "stew", ".", "rename", "(", "publicFiles", ",", "'robots-'", "+", "appEnv", "+", "'.txt'", ",", "'robots.txt'", ")", ";", "return", "new", "Funnel", "(", "publicFiles", ",", "{", "srcDir", ":", "'/'", ",", "destDir", ":", "'/'", "}", ")", ";", "}"], "docstring": "Pick env specific robots.txt", "docstring_tokens": ["Pick", "env", "specific", "robots", ".", "txt"], "sha": "38bdf32a8b72c9bca40c948e94a4a647c0ddf388", "url": "https://github.com/martinic/ember-cli-deploy-build-plus/blob/38bdf32a8b72c9bca40c948e94a4a647c0ddf388/index.js#L31-L59", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(key) {\n        var dict = this.dict;\n\n        if (dict.hasOwnProperty(key)) {\n          return dict[key];\n        }\n\n        if (this.parent) {\n          return this.parent.get(key);\n        }\n      }", "language": "javascript", "code": "function(key) {\n        var dict = this.dict;\n\n        if (dict.hasOwnProperty(key)) {\n          return dict[key];\n        }\n\n        if (this.parent) {\n          return this.parent.get(key);\n        }\n      }", "code_tokens": ["function", "(", "key", ")", "{", "var", "dict", "=", "this", ".", "dict", ";", "if", "(", "dict", ".", "hasOwnProperty", "(", "key", ")", ")", "{", "return", "dict", "[", "key", "]", ";", "}", "if", "(", "this", ".", "parent", ")", "{", "return", "this", ".", "parent", ".", "get", "(", "key", ")", ";", "}", "}"], "docstring": "Retrieve the value given a key, if the value is present at the current\nlevel use it, otherwise walk up the parent hierarchy and try again. If\nno matching key is found, return undefined.\n\n@method get\n@param {String} key\n@return {any}", "docstring_tokens": ["Retrieve", "the", "value", "given", "a", "key", "if", "the", "value", "is", "present", "at", "the", "current", "level", "use", "it", "otherwise", "walk", "up", "the", "parent", "hierarchy", "and", "try", "again", ".", "If", "no", "matching", "key", "is", "found", "return", "undefined", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L11557-L11567", "partition": "test"}
{"repo": "jurca/indexed-db.es6", "path": "es2015/migration/RecordFetcher.js", "func_name": "fetchAllRecords", "original_string": "function fetchAllRecords(transaction, objectStores) {\n  return PromiseSync.all(objectStores.map((descriptor) => {\n    return fetchRecords(\n      transaction.getObjectStore(descriptor.objectStore),\n      descriptor.preprocessor\n    )\n  })).then((fetchedRecords) => {\n    let recordsMap = {}\n    \n    for (let i = 0; i < objectStores.length; i++) {\n      recordsMap[objectStores[i].objectStore] = fetchedRecords[i]\n    }\n    \n    return recordsMap\n  })\n}", "language": "javascript", "code": "function fetchAllRecords(transaction, objectStores) {\n  return PromiseSync.all(objectStores.map((descriptor) => {\n    return fetchRecords(\n      transaction.getObjectStore(descriptor.objectStore),\n      descriptor.preprocessor\n    )\n  })).then((fetchedRecords) => {\n    let recordsMap = {}\n    \n    for (let i = 0; i < objectStores.length; i++) {\n      recordsMap[objectStores[i].objectStore] = fetchedRecords[i]\n    }\n    \n    return recordsMap\n  })\n}", "code_tokens": ["function", "fetchAllRecords", "(", "transaction", ",", "objectStores", ")", "{", "return", "PromiseSync", ".", "all", "(", "objectStores", ".", "map", "(", "(", "descriptor", ")", "=>", "{", "return", "fetchRecords", "(", "transaction", ".", "getObjectStore", "(", "descriptor", ".", "objectStore", ")", ",", "descriptor", ".", "preprocessor", ")", "}", ")", ")", ".", "then", "(", "(", "fetchedRecords", ")", "=>", "{", "let", "recordsMap", "=", "{", "}", "for", "(", "let", "i", "=", "0", ";", "i", "<", "objectStores", ".", "length", ";", "i", "++", ")", "{", "recordsMap", "[", "objectStores", "[", "i", "]", ".", "objectStore", "]", "=", "fetchedRecords", "[", "i", "]", "}", "return", "recordsMap", "}", ")", "}"], "docstring": "Fetches all records from the specified object stores using the provided\nread-write transaction.\n\n@param {Transaction} transaction The read-write transaction to use to access\nthe object stores.\n@param {(string|{objectStore: string, preprocessor: function(*, (number|string|Date|Array)): (*|UpgradedDatabaseSchema.SKIP_RECORD|UpgradedDatabaseSchema.DELETE_RECORD)=})[]} objectStores\nThe names of object stores that should have their records fetch or\n(possibly partially filled) object store fetch descriptors, mixed in\nan array.\n@return {PromiseSync<Object<string, {key: (number|string|Date|Array), record: *}[]>>}\nA promise that resolves once all the records have been fetched and\nthe records marked for deletion were deleted.\nThe promise resolves to a map of object store names to the records\nfetched from the object store, except for the records marked for\nskipping or deletion.", "docstring_tokens": ["Fetches", "all", "records", "from", "the", "specified", "object", "stores", "using", "the", "provided", "read", "-", "write", "transaction", "."], "sha": "abc22dc63b2159c253b60c5dc396d22fd72c2177", "url": "https://github.com/jurca/indexed-db.es6/blob/abc22dc63b2159c253b60c5dc396d22fd72c2177/es2015/migration/RecordFetcher.js#L67-L82", "partition": "test"}
{"repo": "socialally/browser-cookie", "path": "lib/cookie.js", "func_name": "set", "original_string": "function set(key, value, options) {\n  options = options || this.options;\n  var days = parseInt(options.expires || -1);\n  if(value !== undefined && typeof value !== 'function') {\n    var t = new Date();\n    t.setDate((t.getDate() + days));\n    var res = (document.cookie = [\n      this.encode(key), '=', this.stringify(value),\n      // use expires attribute, max-age is not supported by IE\n      options.expires ? '; expires=' + t.toUTCString() : '',\n      options.path ? '; path=' + options.path : '',\n      options.domain ? '; domain=' + options.domain : '',\n      options.secure ? '; secure' : ''\n    ].join(''));\n    return res;\n  }\n}", "language": "javascript", "code": "function set(key, value, options) {\n  options = options || this.options;\n  var days = parseInt(options.expires || -1);\n  if(value !== undefined && typeof value !== 'function') {\n    var t = new Date();\n    t.setDate((t.getDate() + days));\n    var res = (document.cookie = [\n      this.encode(key), '=', this.stringify(value),\n      // use expires attribute, max-age is not supported by IE\n      options.expires ? '; expires=' + t.toUTCString() : '',\n      options.path ? '; path=' + options.path : '',\n      options.domain ? '; domain=' + options.domain : '',\n      options.secure ? '; secure' : ''\n    ].join(''));\n    return res;\n  }\n}", "code_tokens": ["function", "set", "(", "key", ",", "value", ",", "options", ")", "{", "options", "=", "options", "||", "this", ".", "options", ";", "var", "days", "=", "parseInt", "(", "options", ".", "expires", "||", "-", "1", ")", ";", "if", "(", "value", "!==", "undefined", "&&", "typeof", "value", "!==", "'function'", ")", "{", "var", "t", "=", "new", "Date", "(", ")", ";", "t", ".", "setDate", "(", "(", "t", ".", "getDate", "(", ")", "+", "days", ")", ")", ";", "var", "res", "=", "(", "document", ".", "cookie", "=", "[", "this", ".", "encode", "(", "key", ")", ",", "'='", ",", "this", ".", "stringify", "(", "value", ")", ",", "// use expires attribute, max-age is not supported by IE", "options", ".", "expires", "?", "'; expires='", "+", "t", ".", "toUTCString", "(", ")", ":", "''", ",", "options", ".", "path", "?", "'; path='", "+", "options", ".", "path", ":", "''", ",", "options", ".", "domain", "?", "'; domain='", "+", "options", ".", "domain", ":", "''", ",", "options", ".", "secure", "?", "'; secure'", ":", "''", "]", ".", "join", "(", "''", ")", ")", ";", "return", "res", ";", "}", "}"], "docstring": "Set a cookie value.\n\n@param key The cookie key name.\n@param value The value for the cookie.\n@param options Options to use when setting the cookie.", "docstring_tokens": ["Set", "a", "cookie", "value", "."], "sha": "c64f8abf894bd0d66248d2a6310013783c86dddf", "url": "https://github.com/socialally/browser-cookie/blob/c64f8abf894bd0d66248d2a6310013783c86dddf/lib/cookie.js#L40-L56", "partition": "test"}
{"repo": "LuccaSA/lui-build", "path": "index.js", "func_name": "init", "original_string": "function init(_options) {\n\t// Build global options\n\tvar options = _.merge(defaults, _options);\n\t// Store paths\n\tbase = options.base;\n\tcustom = options.custom;\n\t// Retrieve build definition\n\tbuild = options.build = (typeof options.build === 'object') ? options.build : require(options.build);\n\t// Create YAML schema (create custom types)\n\tyamlSchema = createYamlSchema(options.customTypes);\n\n\treturn options;\n}", "language": "javascript", "code": "function init(_options) {\n\t// Build global options\n\tvar options = _.merge(defaults, _options);\n\t// Store paths\n\tbase = options.base;\n\tcustom = options.custom;\n\t// Retrieve build definition\n\tbuild = options.build = (typeof options.build === 'object') ? options.build : require(options.build);\n\t// Create YAML schema (create custom types)\n\tyamlSchema = createYamlSchema(options.customTypes);\n\n\treturn options;\n}", "code_tokens": ["function", "init", "(", "_options", ")", "{", "// Build global options", "var", "options", "=", "_", ".", "merge", "(", "defaults", ",", "_options", ")", ";", "// Store paths", "base", "=", "options", ".", "base", ";", "custom", "=", "options", ".", "custom", ";", "// Retrieve build definition", "build", "=", "options", ".", "build", "=", "(", "typeof", "options", ".", "build", "===", "'object'", ")", "?", "options", ".", "build", ":", "require", "(", "options", ".", "build", ")", ";", "// Create YAML schema (create custom types)", "yamlSchema", "=", "createYamlSchema", "(", "options", ".", "customTypes", ")", ";", "return", "options", ";", "}"], "docstring": "Initializes global variables. In particular, merges defaults and custom options.\n\n@param {Object} custom options\n@return {Object} merged options", "docstring_tokens": ["Initializes", "global", "variables", ".", "In", "particular", "merges", "defaults", "and", "custom", "options", "."], "sha": "916343e0ba3c36c4e9f97761e402783ca68df44d", "url": "https://github.com/LuccaSA/lui-build/blob/916343e0ba3c36c4e9f97761e402783ca68df44d/index.js#L213-L225", "partition": "test"}
{"repo": "AbbottPlatform/abbott-framework", "path": "lib/controllers/facebook/botkit/index.js", "func_name": "verifyRequest", "original_string": "function verifyRequest(req, res, buf, encoding) {\n    var expected = req.headers['x-hub-signature'];\n    var calculated = getSignature(buf);\n    if (expected !== calculated) {\n      throw new Error('Invalid signature on incoming request');\n    } else {\n      // facebook_botkit.logger.debug('** X-Hub Verification successful!')\n    }\n  }", "language": "javascript", "code": "function verifyRequest(req, res, buf, encoding) {\n    var expected = req.headers['x-hub-signature'];\n    var calculated = getSignature(buf);\n    if (expected !== calculated) {\n      throw new Error('Invalid signature on incoming request');\n    } else {\n      // facebook_botkit.logger.debug('** X-Hub Verification successful!')\n    }\n  }", "code_tokens": ["function", "verifyRequest", "(", "req", ",", "res", ",", "buf", ",", "encoding", ")", "{", "var", "expected", "=", "req", ".", "headers", "[", "'x-hub-signature'", "]", ";", "var", "calculated", "=", "getSignature", "(", "buf", ")", ";", "if", "(", "expected", "!==", "calculated", ")", "{", "throw", "new", "Error", "(", "'Invalid signature on incoming request'", ")", ";", "}", "else", "{", "// facebook_botkit.logger.debug('** X-Hub Verification successful!')", "}", "}"], "docstring": "Verifies the SHA1 signature of the raw request payload before bodyParser parses it Will abort parsing if signature is invalid, and pass a generic error to response", "docstring_tokens": ["Verifies", "the", "SHA1", "signature", "of", "the", "raw", "request", "payload", "before", "bodyParser", "parses", "it", "Will", "abort", "parsing", "if", "signature", "is", "invalid", "and", "pass", "a", "generic", "error", "to", "response"], "sha": "24ae64070c9dfe8407eb2ba0cead2cb277e38704", "url": "https://github.com/AbbottPlatform/abbott-framework/blob/24ae64070c9dfe8407eb2ba0cead2cb277e38704/lib/controllers/facebook/botkit/index.js#L846-L854", "partition": "test"}
{"repo": "nearform/nscale-kernel", "path": "lib/sysrev/sysrevMeta.js", "func_name": "", "original_string": "function(user, namespace, name, repoName, repoPath, systemId, cb) {\n    if (!_systems[systemId]) {\n      _systems[systemId] = { name: name, namespace: namespace, repoName: repoName, repoPath: repoPath };\n      fse.writeFileSync(systemsJsonPath, JSON.stringify(_systems, null, 2), 'utf8');\n      git.commit(sysRepoPath, 'registered system: ' + repoPath, user.name, user.email, cb);\n    }\n    else {\n      cb(null);\n    }\n  }", "language": "javascript", "code": "function(user, namespace, name, repoName, repoPath, systemId, cb) {\n    if (!_systems[systemId]) {\n      _systems[systemId] = { name: name, namespace: namespace, repoName: repoName, repoPath: repoPath };\n      fse.writeFileSync(systemsJsonPath, JSON.stringify(_systems, null, 2), 'utf8');\n      git.commit(sysRepoPath, 'registered system: ' + repoPath, user.name, user.email, cb);\n    }\n    else {\n      cb(null);\n    }\n  }", "code_tokens": ["function", "(", "user", ",", "namespace", ",", "name", ",", "repoName", ",", "repoPath", ",", "systemId", ",", "cb", ")", "{", "if", "(", "!", "_systems", "[", "systemId", "]", ")", "{", "_systems", "[", "systemId", "]", "=", "{", "name", ":", "name", ",", "namespace", ":", "namespace", ",", "repoName", ":", "repoName", ",", "repoPath", ":", "repoPath", "}", ";", "fse", ".", "writeFileSync", "(", "systemsJsonPath", ",", "JSON", ".", "stringify", "(", "_systems", ",", "null", ",", "2", ")", ",", "'utf8'", ")", ";", "git", ".", "commit", "(", "sysRepoPath", ",", "'registered system: '", "+", "repoPath", ",", "user", ".", "name", ",", "user", ".", "email", ",", "cb", ")", ";", "}", "else", "{", "cb", "(", "null", ")", ";", "}", "}"], "docstring": "register a system", "docstring_tokens": ["register", "a", "system"], "sha": "5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3", "url": "https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/sysrev/sysrevMeta.js#L65-L74", "partition": "test"}
{"repo": "GraFiddle/angular-chart", "path": "angular-chart.js", "func_name": "setupDataSmallWatcher", "original_string": "function setupDataSmallWatcher(watcher) {\n      return watcher.scope.$watch('options.data', function () {\n        if (angular.isFunction(watcher.dataCallback)) {\n          watcher.dataCallback();\n        }\n        setupDataWatcher(watcher);\n      }, true);\n    }", "language": "javascript", "code": "function setupDataSmallWatcher(watcher) {\n      return watcher.scope.$watch('options.data', function () {\n        if (angular.isFunction(watcher.dataCallback)) {\n          watcher.dataCallback();\n        }\n        setupDataWatcher(watcher);\n      }, true);\n    }", "code_tokens": ["function", "setupDataSmallWatcher", "(", "watcher", ")", "{", "return", "watcher", ".", "scope", ".", "$watch", "(", "'options.data'", ",", "function", "(", ")", "{", "if", "(", "angular", ".", "isFunction", "(", "watcher", ".", "dataCallback", ")", ")", "{", "watcher", ".", "dataCallback", "(", ")", ";", "}", "setupDataWatcher", "(", "watcher", ")", ";", "}", ",", "true", ")", ";", "}"], "docstring": "start watcher changes in small datasets, compares whole object", "docstring_tokens": ["start", "watcher", "changes", "in", "small", "datasets", "compares", "whole", "object"], "sha": "76620974f0547b5a9c86d2860b6b401af8aee5fc", "url": "https://github.com/GraFiddle/angular-chart/blob/76620974f0547b5a9c86d2860b6b401af8aee5fc/angular-chart.js#L179-L186", "partition": "test"}
{"repo": "stackcss/css-extract", "path": "index.js", "func_name": "cssExtract", "original_string": "function cssExtract (bundle, opts) {\n  opts = opts || {}\n\n  var outFile = opts.out || opts.o || 'bundle.css'\n  var sourceMap = d(opts.sourceMap, bundle && bundle._options && bundle._options.debug, false)\n\n  assert.equal(typeof bundle, 'object', 'bundle should be an object')\n  assert.equal(typeof opts, 'object', 'opts should be an object')\n\n  // every time .bundle is called, attach hook\n  bundle.on('reset', addHooks)\n  addHooks()\n\n  function addHooks () {\n    const extractStream = through.obj(write, flush)\n    const writeStream = (typeof outFile === 'function')\n      ? outFile()\n      : bl(writeComplete)\n\n    // run before the \"label\" step in browserify pipeline\n    bundle.pipeline.get('label').unshift(extractStream)\n\n    function write (chunk, enc, cb) {\n      // Performance boost: don't do ast parsing unless we know it's needed\n      if (!/(insert-css|sheetify\\/insert)/.test(chunk.source)) {\n        return cb(null, chunk)\n      }\n\n      var source = from2(chunk.source)\n      var sm = staticModule({\n        'insert-css': function (src) {\n          writeStream.write(String(src) + '\\n')\n          return from2('null')\n        },\n        'sheetify/insert': function (src) {\n          writeStream.write(String(src) + '\\n')\n          return from2('null')\n        }\n      }, { sourceMap: sourceMap })\n\n      source.pipe(sm).pipe(bl(complete))\n\n      function complete (err, source) {\n        if (err) return extractStream.emit('error', err)\n        chunk.source = String(source)\n        cb(null, chunk)\n      }\n    }\n\n    // close stream and signal end\n    function flush (cb) {\n      writeStream.end()\n      cb()\n    }\n\n    function writeComplete (err, buffer) {\n      if (err) return extractStream.emit('error', err)\n      fs.writeFileSync(outFile, buffer)\n    }\n  }\n}", "language": "javascript", "code": "function cssExtract (bundle, opts) {\n  opts = opts || {}\n\n  var outFile = opts.out || opts.o || 'bundle.css'\n  var sourceMap = d(opts.sourceMap, bundle && bundle._options && bundle._options.debug, false)\n\n  assert.equal(typeof bundle, 'object', 'bundle should be an object')\n  assert.equal(typeof opts, 'object', 'opts should be an object')\n\n  // every time .bundle is called, attach hook\n  bundle.on('reset', addHooks)\n  addHooks()\n\n  function addHooks () {\n    const extractStream = through.obj(write, flush)\n    const writeStream = (typeof outFile === 'function')\n      ? outFile()\n      : bl(writeComplete)\n\n    // run before the \"label\" step in browserify pipeline\n    bundle.pipeline.get('label').unshift(extractStream)\n\n    function write (chunk, enc, cb) {\n      // Performance boost: don't do ast parsing unless we know it's needed\n      if (!/(insert-css|sheetify\\/insert)/.test(chunk.source)) {\n        return cb(null, chunk)\n      }\n\n      var source = from2(chunk.source)\n      var sm = staticModule({\n        'insert-css': function (src) {\n          writeStream.write(String(src) + '\\n')\n          return from2('null')\n        },\n        'sheetify/insert': function (src) {\n          writeStream.write(String(src) + '\\n')\n          return from2('null')\n        }\n      }, { sourceMap: sourceMap })\n\n      source.pipe(sm).pipe(bl(complete))\n\n      function complete (err, source) {\n        if (err) return extractStream.emit('error', err)\n        chunk.source = String(source)\n        cb(null, chunk)\n      }\n    }\n\n    // close stream and signal end\n    function flush (cb) {\n      writeStream.end()\n      cb()\n    }\n\n    function writeComplete (err, buffer) {\n      if (err) return extractStream.emit('error', err)\n      fs.writeFileSync(outFile, buffer)\n    }\n  }\n}", "code_tokens": ["function", "cssExtract", "(", "bundle", ",", "opts", ")", "{", "opts", "=", "opts", "||", "{", "}", "var", "outFile", "=", "opts", ".", "out", "||", "opts", ".", "o", "||", "'bundle.css'", "var", "sourceMap", "=", "d", "(", "opts", ".", "sourceMap", ",", "bundle", "&&", "bundle", ".", "_options", "&&", "bundle", ".", "_options", ".", "debug", ",", "false", ")", "assert", ".", "equal", "(", "typeof", "bundle", ",", "'object'", ",", "'bundle should be an object'", ")", "assert", ".", "equal", "(", "typeof", "opts", ",", "'object'", ",", "'opts should be an object'", ")", "// every time .bundle is called, attach hook", "bundle", ".", "on", "(", "'reset'", ",", "addHooks", ")", "addHooks", "(", ")", "function", "addHooks", "(", ")", "{", "const", "extractStream", "=", "through", ".", "obj", "(", "write", ",", "flush", ")", "const", "writeStream", "=", "(", "typeof", "outFile", "===", "'function'", ")", "?", "outFile", "(", ")", ":", "bl", "(", "writeComplete", ")", "// run before the \"label\" step in browserify pipeline", "bundle", ".", "pipeline", ".", "get", "(", "'label'", ")", ".", "unshift", "(", "extractStream", ")", "function", "write", "(", "chunk", ",", "enc", ",", "cb", ")", "{", "// Performance boost: don't do ast parsing unless we know it's needed", "if", "(", "!", "/", "(insert-css|sheetify\\/insert)", "/", ".", "test", "(", "chunk", ".", "source", ")", ")", "{", "return", "cb", "(", "null", ",", "chunk", ")", "}", "var", "source", "=", "from2", "(", "chunk", ".", "source", ")", "var", "sm", "=", "staticModule", "(", "{", "'insert-css'", ":", "function", "(", "src", ")", "{", "writeStream", ".", "write", "(", "String", "(", "src", ")", "+", "'\\n'", ")", "return", "from2", "(", "'null'", ")", "}", ",", "'sheetify/insert'", ":", "function", "(", "src", ")", "{", "writeStream", ".", "write", "(", "String", "(", "src", ")", "+", "'\\n'", ")", "return", "from2", "(", "'null'", ")", "}", "}", ",", "{", "sourceMap", ":", "sourceMap", "}", ")", "source", ".", "pipe", "(", "sm", ")", ".", "pipe", "(", "bl", "(", "complete", ")", ")", "function", "complete", "(", "err", ",", "source", ")", "{", "if", "(", "err", ")", "return", "extractStream", ".", "emit", "(", "'error'", ",", "err", ")", "chunk", ".", "source", "=", "String", "(", "source", ")", "cb", "(", "null", ",", "chunk", ")", "}", "}", "// close stream and signal end", "function", "flush", "(", "cb", ")", "{", "writeStream", ".", "end", "(", ")", "cb", "(", ")", "}", "function", "writeComplete", "(", "err", ",", "buffer", ")", "{", "if", "(", "err", ")", "return", "extractStream", ".", "emit", "(", "'error'", ",", "err", ")", "fs", ".", "writeFileSync", "(", "outFile", ",", "buffer", ")", "}", "}", "}"], "docstring": "Extract CSS from a browserify bundle obj -> null", "docstring_tokens": ["Extract", "CSS", "from", "a", "browserify", "bundle", "obj", "-", ">", "null"], "sha": "5cfbe9e34473d82599997e4bcec3a86ac7d52b61", "url": "https://github.com/stackcss/css-extract/blob/5cfbe9e34473d82599997e4bcec3a86ac7d52b61/index.js#L13-L73", "partition": "test"}
{"repo": "willconant/flow-js", "path": "flow.js", "func_name": "", "original_string": "function() {\n\t\t\t\tif (flowState.__frozen) return;\n\t\t\t\t\n\t\t\t\tif (flowState.__timeoutId) {\n\t\t\t\t\tclearTimeout(flowState.__timeoutId);\n\t\t\t\t\tdelete flowState.__timeoutId;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar blockIdx = flowState.__nextBlockIdx ++;\n\t\t\t\tvar block = thisFlow.blocks[blockIdx];\n\t\t\t\t\n\t\t\t\tif (block === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tapplyArgs(block, flowState, arguments);\n\t\t\t\t}\n\t\t\t}", "language": "javascript", "code": "function() {\n\t\t\t\tif (flowState.__frozen) return;\n\t\t\t\t\n\t\t\t\tif (flowState.__timeoutId) {\n\t\t\t\t\tclearTimeout(flowState.__timeoutId);\n\t\t\t\t\tdelete flowState.__timeoutId;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar blockIdx = flowState.__nextBlockIdx ++;\n\t\t\t\tvar block = thisFlow.blocks[blockIdx];\n\t\t\t\t\n\t\t\t\tif (block === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tapplyArgs(block, flowState, arguments);\n\t\t\t\t}\n\t\t\t}", "code_tokens": ["function", "(", ")", "{", "if", "(", "flowState", ".", "__frozen", ")", "return", ";", "if", "(", "flowState", ".", "__timeoutId", ")", "{", "clearTimeout", "(", "flowState", ".", "__timeoutId", ")", ";", "delete", "flowState", ".", "__timeoutId", ";", "}", "var", "blockIdx", "=", "flowState", ".", "__nextBlockIdx", "++", ";", "var", "block", "=", "thisFlow", ".", "blocks", "[", "blockIdx", "]", ";", "if", "(", "block", "===", "undefined", ")", "{", "return", ";", "}", "else", "{", "applyArgs", "(", "block", ",", "flowState", ",", "arguments", ")", ";", "}", "}"], "docstring": "The flowState is the actual object each step in the flow is applied to. It acts as a callback to the next function. It also maintains the internal state of each execution and acts as a place for users to save values between steps of the flow.", "docstring_tokens": ["The", "flowState", "is", "the", "actual", "object", "each", "step", "in", "the", "flow", "is", "applied", "to", ".", "It", "acts", "as", "a", "callback", "to", "the", "next", "function", ".", "It", "also", "maintains", "the", "internal", "state", "of", "each", "execution", "and", "acts", "as", "a", "place", "for", "users", "to", "save", "values", "between", "steps", "of", "the", "flow", "."], "sha": "8336df1741a663b458cd96ba12ad2c3e13f89b84", "url": "https://github.com/willconant/flow-js/blob/8336df1741a663b458cd96ba12ad2c3e13f89b84/flow.js#L24-L41", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/field/Checkbox.js", "func_name": "", "original_string": "function() {\n        var values = [];\n\n        this.getSameGroupFields().forEach(function(field) {\n            if (field.getChecked()) {\n                values.push(field.getValue());\n            }\n        });\n\n        return values;\n    }", "language": "javascript", "code": "function() {\n        var values = [];\n\n        this.getSameGroupFields().forEach(function(field) {\n            if (field.getChecked()) {\n                values.push(field.getValue());\n            }\n        });\n\n        return values;\n    }", "code_tokens": ["function", "(", ")", "{", "var", "values", "=", "[", "]", ";", "this", ".", "getSameGroupFields", "(", ")", ".", "forEach", "(", "function", "(", "field", ")", "{", "if", "(", "field", ".", "getChecked", "(", ")", ")", "{", "values", ".", "push", "(", "field", ".", "getValue", "(", ")", ")", ";", "}", "}", ")", ";", "return", "values", ";", "}"], "docstring": "Returns an array of values from the checkboxes in the group that are checked.\n@return {Array}", "docstring_tokens": ["Returns", "an", "array", "of", "values", "from", "the", "checkboxes", "in", "the", "group", "that", "are", "checked", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/field/Checkbox.js#L337-L347", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "checkTypeAnnotationAsExpression", "original_string": "function checkTypeAnnotationAsExpression(node) {\n            switch (node.kind) {\n                case 141 /* PropertyDeclaration */:\n                    checkTypeNodeAsExpression(node.type);\n                    break;\n                case 138 /* Parameter */:\n                    checkTypeNodeAsExpression(node.type);\n                    break;\n                case 143 /* MethodDeclaration */:\n                    checkTypeNodeAsExpression(node.type);\n                    break;\n                case 145 /* GetAccessor */:\n                    checkTypeNodeAsExpression(node.type);\n                    break;\n                case 146 /* SetAccessor */:\n                    checkTypeNodeAsExpression(ts.getSetAccessorTypeAnnotationNode(node));\n                    break;\n            }\n        }", "language": "javascript", "code": "function checkTypeAnnotationAsExpression(node) {\n            switch (node.kind) {\n                case 141 /* PropertyDeclaration */:\n                    checkTypeNodeAsExpression(node.type);\n                    break;\n                case 138 /* Parameter */:\n                    checkTypeNodeAsExpression(node.type);\n                    break;\n                case 143 /* MethodDeclaration */:\n                    checkTypeNodeAsExpression(node.type);\n                    break;\n                case 145 /* GetAccessor */:\n                    checkTypeNodeAsExpression(node.type);\n                    break;\n                case 146 /* SetAccessor */:\n                    checkTypeNodeAsExpression(ts.getSetAccessorTypeAnnotationNode(node));\n                    break;\n            }\n        }", "code_tokens": ["function", "checkTypeAnnotationAsExpression", "(", "node", ")", "{", "switch", "(", "node", ".", "kind", ")", "{", "case", "141", "/* PropertyDeclaration */", ":", "checkTypeNodeAsExpression", "(", "node", ".", "type", ")", ";", "break", ";", "case", "138", "/* Parameter */", ":", "checkTypeNodeAsExpression", "(", "node", ".", "type", ")", ";", "break", ";", "case", "143", "/* MethodDeclaration */", ":", "checkTypeNodeAsExpression", "(", "node", ".", "type", ")", ";", "break", ";", "case", "145", "/* GetAccessor */", ":", "checkTypeNodeAsExpression", "(", "node", ".", "type", ")", ";", "break", ";", "case", "146", "/* SetAccessor */", ":", "checkTypeNodeAsExpression", "(", "ts", ".", "getSetAccessorTypeAnnotationNode", "(", "node", ")", ")", ";", "break", ";", "}", "}"], "docstring": "Checks the type annotation of an accessor declaration or property declaration as\nan expression if it is a type reference to a type with a value declaration.", "docstring_tokens": ["Checks", "the", "type", "annotation", "of", "an", "accessor", "declaration", "or", "property", "declaration", "as", "an", "expression", "if", "it", "is", "a", "type", "reference", "to", "a", "type", "with", "a", "value", "declaration", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L23886-L23904", "partition": "test"}
{"repo": "hashchange/backbone.declarative.views", "path": "demo/amd/rjs/output/unified/marionette-build.js", "func_name": "_createTemplateCache", "original_string": "function _createTemplateCache( templateProp, view, viewOptions ) {\n        var $template, data, html,\n\n            customLoader = Backbone.DeclarativeViews.custom.loadTemplate,\n            defaultLoader = Backbone.DeclarativeViews.defaults.loadTemplate,\n            modifiedDefaultLoader = defaultLoader !== loadTemplate,\n\n            cacheId = templateProp;\n\n        // Load the template\n        try {\n            $template = customLoader ? customLoader( templateProp, view, viewOptions ) : defaultLoader( templateProp, view, viewOptions );\n        } catch ( err ) {\n            // Rethrow and exit if the alarm has been raised deliberately, using an error type of Backbone.DeclarativeViews.\n            if( _isDeclarativeViewsErrorType( err ) ) throw err;\n            // Otherwise, continue without having fetched a template.\n            $template = \"\";\n        }\n\n        if ( ( customLoader || modifiedDefaultLoader ) && $template !== \"\" && ! ( $template instanceof Backbone.$ ) ) {\n            throw new CustomizationError( \"Invalid return value. The \" + ( customLoader ? \"custom\" : \"default\" ) + \" loadTemplate function must return a jQuery instance, but it hasn't\" );\n        }\n\n        // Create cache entry\n        if ( $template.length ) {\n\n            // Read the el-related data attributes of the template.\n            data = _getDataAttributes( $template ) ;\n\n            html = $template.html();\n\n            templateCache[cacheId] = {\n                html: html,\n                compiled: _tryCompileTemplate( html, $template ),\n\n                tagName: data.tagName,\n                className: data.className,\n                id: data.id,\n                attributes: data.attributes,\n\n                // Data store for plugins. Plugins should create their own namespace in the store, with the plugin name\n                // as key.\n                _pluginData: {}\n            };\n\n            events.trigger( \"cacheEntry:create\", templateCache[cacheId], templateProp, view, viewOptions );\n\n        } else {\n            templateCache[cacheId] = { invalid: true };\n        }\n\n        return templateCache[cacheId];\n    }", "language": "javascript", "code": "function _createTemplateCache( templateProp, view, viewOptions ) {\n        var $template, data, html,\n\n            customLoader = Backbone.DeclarativeViews.custom.loadTemplate,\n            defaultLoader = Backbone.DeclarativeViews.defaults.loadTemplate,\n            modifiedDefaultLoader = defaultLoader !== loadTemplate,\n\n            cacheId = templateProp;\n\n        // Load the template\n        try {\n            $template = customLoader ? customLoader( templateProp, view, viewOptions ) : defaultLoader( templateProp, view, viewOptions );\n        } catch ( err ) {\n            // Rethrow and exit if the alarm has been raised deliberately, using an error type of Backbone.DeclarativeViews.\n            if( _isDeclarativeViewsErrorType( err ) ) throw err;\n            // Otherwise, continue without having fetched a template.\n            $template = \"\";\n        }\n\n        if ( ( customLoader || modifiedDefaultLoader ) && $template !== \"\" && ! ( $template instanceof Backbone.$ ) ) {\n            throw new CustomizationError( \"Invalid return value. The \" + ( customLoader ? \"custom\" : \"default\" ) + \" loadTemplate function must return a jQuery instance, but it hasn't\" );\n        }\n\n        // Create cache entry\n        if ( $template.length ) {\n\n            // Read the el-related data attributes of the template.\n            data = _getDataAttributes( $template ) ;\n\n            html = $template.html();\n\n            templateCache[cacheId] = {\n                html: html,\n                compiled: _tryCompileTemplate( html, $template ),\n\n                tagName: data.tagName,\n                className: data.className,\n                id: data.id,\n                attributes: data.attributes,\n\n                // Data store for plugins. Plugins should create their own namespace in the store, with the plugin name\n                // as key.\n                _pluginData: {}\n            };\n\n            events.trigger( \"cacheEntry:create\", templateCache[cacheId], templateProp, view, viewOptions );\n\n        } else {\n            templateCache[cacheId] = { invalid: true };\n        }\n\n        return templateCache[cacheId];\n    }", "code_tokens": ["function", "_createTemplateCache", "(", "templateProp", ",", "view", ",", "viewOptions", ")", "{", "var", "$template", ",", "data", ",", "html", ",", "customLoader", "=", "Backbone", ".", "DeclarativeViews", ".", "custom", ".", "loadTemplate", ",", "defaultLoader", "=", "Backbone", ".", "DeclarativeViews", ".", "defaults", ".", "loadTemplate", ",", "modifiedDefaultLoader", "=", "defaultLoader", "!==", "loadTemplate", ",", "cacheId", "=", "templateProp", ";", "// Load the template", "try", "{", "$template", "=", "customLoader", "?", "customLoader", "(", "templateProp", ",", "view", ",", "viewOptions", ")", ":", "defaultLoader", "(", "templateProp", ",", "view", ",", "viewOptions", ")", ";", "}", "catch", "(", "err", ")", "{", "// Rethrow and exit if the alarm has been raised deliberately, using an error type of Backbone.DeclarativeViews.", "if", "(", "_isDeclarativeViewsErrorType", "(", "err", ")", ")", "throw", "err", ";", "// Otherwise, continue without having fetched a template.", "$template", "=", "\"\"", ";", "}", "if", "(", "(", "customLoader", "||", "modifiedDefaultLoader", ")", "&&", "$template", "!==", "\"\"", "&&", "!", "(", "$template", "instanceof", "Backbone", ".", "$", ")", ")", "{", "throw", "new", "CustomizationError", "(", "\"Invalid return value. The \"", "+", "(", "customLoader", "?", "\"custom\"", ":", "\"default\"", ")", "+", "\" loadTemplate function must return a jQuery instance, but it hasn't\"", ")", ";", "}", "// Create cache entry", "if", "(", "$template", ".", "length", ")", "{", "// Read the el-related data attributes of the template.", "data", "=", "_getDataAttributes", "(", "$template", ")", ";", "html", "=", "$template", ".", "html", "(", ")", ";", "templateCache", "[", "cacheId", "]", "=", "{", "html", ":", "html", ",", "compiled", ":", "_tryCompileTemplate", "(", "html", ",", "$template", ")", ",", "tagName", ":", "data", ".", "tagName", ",", "className", ":", "data", ".", "className", ",", "id", ":", "data", ".", "id", ",", "attributes", ":", "data", ".", "attributes", ",", "// Data store for plugins. Plugins should create their own namespace in the store, with the plugin name", "// as key.", "_pluginData", ":", "{", "}", "}", ";", "events", ".", "trigger", "(", "\"cacheEntry:create\"", ",", "templateCache", "[", "cacheId", "]", ",", "templateProp", ",", "view", ",", "viewOptions", ")", ";", "}", "else", "{", "templateCache", "[", "cacheId", "]", "=", "{", "invalid", ":", "true", "}", ";", "}", "return", "templateCache", "[", "cacheId", "]", ";", "}"], "docstring": "Creates a cache entry for a given template property.\n\nReturns the cached entry if creating it has succeeded. In case of failure, it returns the hash { invalid: true }.\nIt signals that the template has been processed, but that the returned hash, as well as the cache itself, does\nnot contain valid data for the template property.\n\nThe creation of a cache entry can fail if the template property is an empty string, or a selector which doesn't\nmatch anything, or a string which jQuery can't process.\n\nUses a custom loader if specified, instead of loading the template with jQuery (default).\n\nEvents\n------\n\nThe method fires the following event:\n\n- cacheEntry:create\n\nFires only once per cache entry, when a valid cache entry is created. That may happen in the context of a view,\nor with a global query.\n\nThe event handler receives the original cache entry. If the handler modifies the data, the modifications show\nup in the returned result **and** alter the content in the cache.\n\nIf a valid cache entry can't be created (flagged as invalid), the event does NOT fire.\n\n@param   {string}        templateProp   template selector, or raw template HTML, identifying the cache entry\n@param   {Backbone.View} [view]         the view which requested the template\n@param   {Object}        [viewOptions]  the options passed to the view during instantiation. For availability,\nsee getViewTemplateData()\n@returns {CachedTemplateData|Uncacheable}", "docstring_tokens": ["Creates", "a", "cache", "entry", "for", "a", "given", "template", "property", "."], "sha": "612ceb080fb3101d766f31be1ed3eee5d8e80a9d", "url": "https://github.com/hashchange/backbone.declarative.views/blob/612ceb080fb3101d766f31be1ed3eee5d8e80a9d/demo/amd/rjs/output/unified/marionette-build.js#L15546-L15598", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "Component", "original_string": "function Component(player, options, ready) {\n    classCallCheck(this, Component);\n\n\n    // The component might be the player itself and we can't pass `this` to super\n    if (!player && this.play) {\n      this.player_ = player = this; // eslint-disable-line\n    } else {\n      this.player_ = player;\n    }\n\n    // Make a copy of prototype.options_ to protect against overriding defaults\n    this.options_ = mergeOptions({}, this.options_);\n\n    // Updated options with supplied options\n    options = this.options_ = mergeOptions(this.options_, options);\n\n    // Get ID from options or options element if one is supplied\n    this.id_ = options.id || options.el && options.el.id;\n\n    // If there was no ID from the options, generate one\n    if (!this.id_) {\n      // Don't require the player ID function in the case of mock players\n      var id = player && player.id && player.id() || 'no_player';\n\n      this.id_ = id + '_component_' + newGUID();\n    }\n\n    this.name_ = options.name || null;\n\n    // Create element if one wasn't provided in options\n    if (options.el) {\n      this.el_ = options.el;\n    } else if (options.createEl !== false) {\n      this.el_ = this.createEl();\n    }\n\n    // Make this an evented object and use `el_`, if available, as its event bus\n    evented(this, { eventBusKey: this.el_ ? 'el_' : null });\n    stateful(this, this.constructor.defaultState);\n\n    this.children_ = [];\n    this.childIndex_ = {};\n    this.childNameIndex_ = {};\n\n    // Add any child components in options\n    if (options.initChildren !== false) {\n      this.initChildren();\n    }\n\n    this.ready(ready);\n    // Don't want to trigger ready here or it will before init is actually\n    // finished for all children that run this constructor\n\n    if (options.reportTouchActivity !== false) {\n      this.enableTouchActivity();\n    }\n  }", "language": "javascript", "code": "function Component(player, options, ready) {\n    classCallCheck(this, Component);\n\n\n    // The component might be the player itself and we can't pass `this` to super\n    if (!player && this.play) {\n      this.player_ = player = this; // eslint-disable-line\n    } else {\n      this.player_ = player;\n    }\n\n    // Make a copy of prototype.options_ to protect against overriding defaults\n    this.options_ = mergeOptions({}, this.options_);\n\n    // Updated options with supplied options\n    options = this.options_ = mergeOptions(this.options_, options);\n\n    // Get ID from options or options element if one is supplied\n    this.id_ = options.id || options.el && options.el.id;\n\n    // If there was no ID from the options, generate one\n    if (!this.id_) {\n      // Don't require the player ID function in the case of mock players\n      var id = player && player.id && player.id() || 'no_player';\n\n      this.id_ = id + '_component_' + newGUID();\n    }\n\n    this.name_ = options.name || null;\n\n    // Create element if one wasn't provided in options\n    if (options.el) {\n      this.el_ = options.el;\n    } else if (options.createEl !== false) {\n      this.el_ = this.createEl();\n    }\n\n    // Make this an evented object and use `el_`, if available, as its event bus\n    evented(this, { eventBusKey: this.el_ ? 'el_' : null });\n    stateful(this, this.constructor.defaultState);\n\n    this.children_ = [];\n    this.childIndex_ = {};\n    this.childNameIndex_ = {};\n\n    // Add any child components in options\n    if (options.initChildren !== false) {\n      this.initChildren();\n    }\n\n    this.ready(ready);\n    // Don't want to trigger ready here or it will before init is actually\n    // finished for all children that run this constructor\n\n    if (options.reportTouchActivity !== false) {\n      this.enableTouchActivity();\n    }\n  }", "code_tokens": ["function", "Component", "(", "player", ",", "options", ",", "ready", ")", "{", "classCallCheck", "(", "this", ",", "Component", ")", ";", "// The component might be the player itself and we can't pass `this` to super", "if", "(", "!", "player", "&&", "this", ".", "play", ")", "{", "this", ".", "player_", "=", "player", "=", "this", ";", "// eslint-disable-line", "}", "else", "{", "this", ".", "player_", "=", "player", ";", "}", "// Make a copy of prototype.options_ to protect against overriding defaults", "this", ".", "options_", "=", "mergeOptions", "(", "{", "}", ",", "this", ".", "options_", ")", ";", "// Updated options with supplied options", "options", "=", "this", ".", "options_", "=", "mergeOptions", "(", "this", ".", "options_", ",", "options", ")", ";", "// Get ID from options or options element if one is supplied", "this", ".", "id_", "=", "options", ".", "id", "||", "options", ".", "el", "&&", "options", ".", "el", ".", "id", ";", "// If there was no ID from the options, generate one", "if", "(", "!", "this", ".", "id_", ")", "{", "// Don't require the player ID function in the case of mock players", "var", "id", "=", "player", "&&", "player", ".", "id", "&&", "player", ".", "id", "(", ")", "||", "'no_player'", ";", "this", ".", "id_", "=", "id", "+", "'_component_'", "+", "newGUID", "(", ")", ";", "}", "this", ".", "name_", "=", "options", ".", "name", "||", "null", ";", "// Create element if one wasn't provided in options", "if", "(", "options", ".", "el", ")", "{", "this", ".", "el_", "=", "options", ".", "el", ";", "}", "else", "if", "(", "options", ".", "createEl", "!==", "false", ")", "{", "this", ".", "el_", "=", "this", ".", "createEl", "(", ")", ";", "}", "// Make this an evented object and use `el_`, if available, as its event bus", "evented", "(", "this", ",", "{", "eventBusKey", ":", "this", ".", "el_", "?", "'el_'", ":", "null", "}", ")", ";", "stateful", "(", "this", ",", "this", ".", "constructor", ".", "defaultState", ")", ";", "this", ".", "children_", "=", "[", "]", ";", "this", ".", "childIndex_", "=", "{", "}", ";", "this", ".", "childNameIndex_", "=", "{", "}", ";", "// Add any child components in options", "if", "(", "options", ".", "initChildren", "!==", "false", ")", "{", "this", ".", "initChildren", "(", ")", ";", "}", "this", ".", "ready", "(", "ready", ")", ";", "// Don't want to trigger ready here or it will before init is actually", "// finished for all children that run this constructor", "if", "(", "options", ".", "reportTouchActivity", "!==", "false", ")", "{", "this", ".", "enableTouchActivity", "(", ")", ";", "}", "}"], "docstring": "A callback that is called when a component is ready. Does not have any\nparamters and any callback value will be ignored.\n\n@callback Component~ReadyCallback\n@this Component\n \nCreates an instance of this class.\n\n@param {Player} player\nThe `Player` that this class should be attached to.\n\n@param {Object} [options]\nThe key/value store of player options.\n\n@param {Object[]} [options.children]\nAn array of children objects to intialize this component with. Children objects have\na name property that will be used if more than one component of the same type needs to be\nadded.\n\n@param {Component~ReadyCallback} [ready]\nFunction that gets called when the `Component` is ready.", "docstring_tokens": ["A", "callback", "that", "is", "called", "when", "a", "component", "is", "ready", ".", "Does", "not", "have", "any", "paramters", "and", "any", "callback", "value", "will", "be", "ignored", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L3015-L3072", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(type, query) {\n    type = this.modelFor(type);\n\n    var array = this.recordArrayManager\n      .createAdapterPopulatedRecordArray(type, query);\n\n    var adapter = this.adapterFor(type),\n        promiseLabel = \"DS: Store#findQuery \" + type,\n        resolver = Ember.RSVP.defer(promiseLabel);\n\n    Ember.assert(\"You tried to load a query but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load a query but your adapter does not implement `findQuery`\", adapter.findQuery);\n\n    resolver.resolve(_findQuery(adapter, this, type, query, array));\n\n    return promiseArray(resolver.promise);\n  }", "language": "javascript", "code": "function(type, query) {\n    type = this.modelFor(type);\n\n    var array = this.recordArrayManager\n      .createAdapterPopulatedRecordArray(type, query);\n\n    var adapter = this.adapterFor(type),\n        promiseLabel = \"DS: Store#findQuery \" + type,\n        resolver = Ember.RSVP.defer(promiseLabel);\n\n    Ember.assert(\"You tried to load a query but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load a query but your adapter does not implement `findQuery`\", adapter.findQuery);\n\n    resolver.resolve(_findQuery(adapter, this, type, query, array));\n\n    return promiseArray(resolver.promise);\n  }", "code_tokens": ["function", "(", "type", ",", "query", ")", "{", "type", "=", "this", ".", "modelFor", "(", "type", ")", ";", "var", "array", "=", "this", ".", "recordArrayManager", ".", "createAdapterPopulatedRecordArray", "(", "type", ",", "query", ")", ";", "var", "adapter", "=", "this", ".", "adapterFor", "(", "type", ")", ",", "promiseLabel", "=", "\"DS: Store#findQuery \"", "+", "type", ",", "resolver", "=", "Ember", ".", "RSVP", ".", "defer", "(", "promiseLabel", ")", ";", "Ember", ".", "assert", "(", "\"You tried to load a query but you have no adapter (for \"", "+", "type", "+", "\")\"", ",", "adapter", ")", ";", "Ember", ".", "assert", "(", "\"You tried to load a query but your adapter does not implement `findQuery`\"", ",", "adapter", ".", "findQuery", ")", ";", "resolver", ".", "resolve", "(", "_findQuery", "(", "adapter", ",", "this", ",", "type", ",", "query", ",", "array", ")", ")", ";", "return", "promiseArray", "(", "resolver", ".", "promise", ")", ";", "}"], "docstring": "This method delegates a query to the adapter. This is the one place where\nadapter-level semantics are exposed to the application.\n\nExposing queries this way seems preferable to creating an abstract query\nlanguage for all server-side queries, and then require all adapters to\nimplement them.\n\nThis method returns a promise, which is resolved with a `RecordArray`\nonce the server returns.\n\n@method findQuery\n@private\n@param {String or subclass of DS.Model} type\n@param {any} query an opaque query to be used by the adapter\n@return {Promise} promise", "docstring_tokens": ["This", "method", "delegates", "a", "query", "to", "the", "adapter", ".", "This", "is", "the", "one", "place", "where", "adapter", "-", "level", "semantics", "are", "exposed", "to", "the", "application", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L2552-L2568", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/direct/Manager.js", "func_name": "", "original_string": "function(provider) {\n        var me = this,\n            args = Ext.toArray(arguments),\n            i = 0, ln;\n\n        if (args.length > 1) {\n            for (ln = args.length; i < ln; ++i) {\n                me.addProvider(args[i]);\n            }\n            return;\n        }\n\n        // if provider has not already been instantiated\n        if (!provider.isProvider) {\n            provider = Ext.create('direct.' + provider.type + 'provider', provider);\n        }\n        me.providers.add(provider);\n        provider.on('data', me.onProviderData, me);\n\n        if (!provider.isConnected()) {\n            provider.connect();\n        }\n\n        return provider;\n    }", "language": "javascript", "code": "function(provider) {\n        var me = this,\n            args = Ext.toArray(arguments),\n            i = 0, ln;\n\n        if (args.length > 1) {\n            for (ln = args.length; i < ln; ++i) {\n                me.addProvider(args[i]);\n            }\n            return;\n        }\n\n        // if provider has not already been instantiated\n        if (!provider.isProvider) {\n            provider = Ext.create('direct.' + provider.type + 'provider', provider);\n        }\n        me.providers.add(provider);\n        provider.on('data', me.onProviderData, me);\n\n        if (!provider.isConnected()) {\n            provider.connect();\n        }\n\n        return provider;\n    }", "code_tokens": ["function", "(", "provider", ")", "{", "var", "me", "=", "this", ",", "args", "=", "Ext", ".", "toArray", "(", "arguments", ")", ",", "i", "=", "0", ",", "ln", ";", "if", "(", "args", ".", "length", ">", "1", ")", "{", "for", "(", "ln", "=", "args", ".", "length", ";", "i", "<", "ln", ";", "++", "i", ")", "{", "me", ".", "addProvider", "(", "args", "[", "i", "]", ")", ";", "}", "return", ";", "}", "// if provider has not already been instantiated", "if", "(", "!", "provider", ".", "isProvider", ")", "{", "provider", "=", "Ext", ".", "create", "(", "'direct.'", "+", "provider", ".", "type", "+", "'provider'", ",", "provider", ")", ";", "}", "me", ".", "providers", ".", "add", "(", "provider", ")", ";", "provider", ".", "on", "(", "'data'", ",", "me", ".", "onProviderData", ",", "me", ")", ";", "if", "(", "!", "provider", ".", "isConnected", "(", ")", ")", "{", "provider", ".", "connect", "(", ")", ";", "}", "return", "provider", ";", "}"], "docstring": "Adds an Ext.Direct Provider and creates the proxy or stub methods to execute server-side methods. If the provider\nis not already connected, it will auto-connect.\n\nExt.direct.Manager.addProvider({\ntype: \"remoting\",       // create a {@link Ext.direct.RemotingProvider}\nurl: \"php/router.php\", // url to connect to the Ext.Direct server-side router.\nactions: {              // each property within the actions object represents a Class\nTestAction: [       // array of methods within each server side Class\n{\nname: \"doEcho\", // name of method\nlen: 1\n},{\nname: \"multiply\",\nlen: 1\n},{\nname: \"doForm\",\nformHandler: true,  // handle form on server with Ext.Direct.Transaction\nlen: 1\n}]\n},\nnamespace: \"myApplication\" // namespace to create the Remoting Provider in\n});\n\n@param {Ext.direct.Provider/Object...} provider\nAccepts any number of Provider descriptions (an instance or config object for\na Provider). Each Provider description instructs Ext.Direct how to create\nclient-side stub methods.\n@return {Object}", "docstring_tokens": ["Adds", "an", "Ext", ".", "Direct", "Provider", "and", "creates", "the", "proxy", "or", "stub", "methods", "to", "execute", "server", "-", "side", "methods", ".", "If", "the", "provider", "is", "not", "already", "connected", "it", "will", "auto", "-", "connect", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/direct/Manager.js#L117-L141", "partition": "test"}
{"repo": "standardhealth/shr-json-schema-export", "path": "lib/export.js", "func_name": "supportsCodeConstraint", "original_string": "function supportsCodeConstraint(identifier, dataElementSpecs) {\n  if (CODE.equals(identifier) || checkHasBaseType(identifier, new Identifier('shr.core', 'Coding'), dataElementSpecs)\n      || checkHasBaseType(identifier, new Identifier('shr.core', 'CodeableConcept'), dataElementSpecs)) {\n    return true;\n  }\n  const element = dataElementSpecs.findByIdentifier(identifier);\n  if (element.value) {\n    if (element.value instanceof IdentifiableValue) {\n      return CODE.equals(element.value.identifier) || checkHasBaseType(element.value.identifier, new Identifier('shr.core', 'Coding'), dataElementSpecs)\n          || checkHasBaseType(element.value.identifier, new Identifier('shr.core', 'CodeableConcept'), dataElementSpecs);\n    } else if (element.value instanceof ChoiceValue) {\n      for (const value of element.value.aggregateOptions) {\n        if (value instanceof IdentifiableValue) {\n          if (CODE.equals(value.identifier) || checkHasBaseType(value.identifier, new Identifier('shr.core', 'Coding'), dataElementSpecs)\n              || checkHasBaseType(value.identifier, new Identifier('shr.core', 'CodeableConcept'), dataElementSpecs)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}", "language": "javascript", "code": "function supportsCodeConstraint(identifier, dataElementSpecs) {\n  if (CODE.equals(identifier) || checkHasBaseType(identifier, new Identifier('shr.core', 'Coding'), dataElementSpecs)\n      || checkHasBaseType(identifier, new Identifier('shr.core', 'CodeableConcept'), dataElementSpecs)) {\n    return true;\n  }\n  const element = dataElementSpecs.findByIdentifier(identifier);\n  if (element.value) {\n    if (element.value instanceof IdentifiableValue) {\n      return CODE.equals(element.value.identifier) || checkHasBaseType(element.value.identifier, new Identifier('shr.core', 'Coding'), dataElementSpecs)\n          || checkHasBaseType(element.value.identifier, new Identifier('shr.core', 'CodeableConcept'), dataElementSpecs);\n    } else if (element.value instanceof ChoiceValue) {\n      for (const value of element.value.aggregateOptions) {\n        if (value instanceof IdentifiableValue) {\n          if (CODE.equals(value.identifier) || checkHasBaseType(value.identifier, new Identifier('shr.core', 'Coding'), dataElementSpecs)\n              || checkHasBaseType(value.identifier, new Identifier('shr.core', 'CodeableConcept'), dataElementSpecs)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}", "code_tokens": ["function", "supportsCodeConstraint", "(", "identifier", ",", "dataElementSpecs", ")", "{", "if", "(", "CODE", ".", "equals", "(", "identifier", ")", "||", "checkHasBaseType", "(", "identifier", ",", "new", "Identifier", "(", "'shr.core'", ",", "'Coding'", ")", ",", "dataElementSpecs", ")", "||", "checkHasBaseType", "(", "identifier", ",", "new", "Identifier", "(", "'shr.core'", ",", "'CodeableConcept'", ")", ",", "dataElementSpecs", ")", ")", "{", "return", "true", ";", "}", "const", "element", "=", "dataElementSpecs", ".", "findByIdentifier", "(", "identifier", ")", ";", "if", "(", "element", ".", "value", ")", "{", "if", "(", "element", ".", "value", "instanceof", "IdentifiableValue", ")", "{", "return", "CODE", ".", "equals", "(", "element", ".", "value", ".", "identifier", ")", "||", "checkHasBaseType", "(", "element", ".", "value", ".", "identifier", ",", "new", "Identifier", "(", "'shr.core'", ",", "'Coding'", ")", ",", "dataElementSpecs", ")", "||", "checkHasBaseType", "(", "element", ".", "value", ".", "identifier", ",", "new", "Identifier", "(", "'shr.core'", ",", "'CodeableConcept'", ")", ",", "dataElementSpecs", ")", ";", "}", "else", "if", "(", "element", ".", "value", "instanceof", "ChoiceValue", ")", "{", "for", "(", "const", "value", "of", "element", ".", "value", ".", "aggregateOptions", ")", "{", "if", "(", "value", "instanceof", "IdentifiableValue", ")", "{", "if", "(", "CODE", ".", "equals", "(", "value", ".", "identifier", ")", "||", "checkHasBaseType", "(", "value", ".", "identifier", ",", "new", "Identifier", "(", "'shr.core'", ",", "'Coding'", ")", ",", "dataElementSpecs", ")", "||", "checkHasBaseType", "(", "value", ".", "identifier", ",", "new", "Identifier", "(", "'shr.core'", ",", "'CodeableConcept'", ")", ",", "dataElementSpecs", ")", ")", "{", "return", "true", ";", "}", "}", "}", "}", "}", "return", "false", ";", "}"], "docstring": "stealing from shr-expand \nDetermine if a type supports a code constraint.\n\n@param {Identifier} identifier - The identifier of the type to check.\n@param {DataElementSpecifications} dataElementSpecs - The available DataElement specs.\n@return {boolean} Whether or not the given type supports a code constraint.", "docstring_tokens": ["stealing", "from", "shr", "-", "expand", "Determine", "if", "a", "type", "supports", "a", "code", "constraint", "."], "sha": "7f6d0994185028edc3cf930e233592f5fd54c57d", "url": "https://github.com/standardhealth/shr-json-schema-export/blob/7f6d0994185028edc3cf930e233592f5fd54c57d/lib/export.js#L1101-L1123", "partition": "test"}
{"repo": "ParksProjets/C-Preprocessor", "path": "bin/argv-parser.js", "func_name": "call", "original_string": "function call(name, isLong) {\n\n\tvar obj = isLong ? long[name] : short[name];\n\tif (!obj)\n\t\treturn error(`Unknown argument '${name}'`);\n\n\tif (n + obj.length > count)\n\t\treturn error(`Too few arguments after '${name}'`);\n\n\tvar arr = process.argv.slice(n, n + obj.length);\n\tn += obj.length;\n\n\tobj.callback(arr);\n}", "language": "javascript", "code": "function call(name, isLong) {\n\n\tvar obj = isLong ? long[name] : short[name];\n\tif (!obj)\n\t\treturn error(`Unknown argument '${name}'`);\n\n\tif (n + obj.length > count)\n\t\treturn error(`Too few arguments after '${name}'`);\n\n\tvar arr = process.argv.slice(n, n + obj.length);\n\tn += obj.length;\n\n\tobj.callback(arr);\n}", "code_tokens": ["function", "call", "(", "name", ",", "isLong", ")", "{", "var", "obj", "=", "isLong", "?", "long", "[", "name", "]", ":", "short", "[", "name", "]", ";", "if", "(", "!", "obj", ")", "return", "error", "(", "`", "${", "name", "}", "`", ")", ";", "if", "(", "n", "+", "obj", ".", "length", ">", "count", ")", "return", "error", "(", "`", "${", "name", "}", "`", ")", ";", "var", "arr", "=", "process", ".", "argv", ".", "slice", "(", "n", ",", "n", "+", "obj", ".", "length", ")", ";", "n", "+=", "obj", ".", "length", ";", "obj", ".", "callback", "(", "arr", ")", ";", "}"], "docstring": "Call a command", "docstring_tokens": ["Call", "a", "command"], "sha": "9c9ea8901b801cc42c69192bacd39814c415cd3b", "url": "https://github.com/ParksProjets/C-Preprocessor/blob/9c9ea8901b801cc42c69192bacd39814c415cd3b/bin/argv-parser.js#L66-L79", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "protoWrap", "original_string": "function protoWrap(proto, name, callback, isAsync) {\n  proto[name] = function() {\n    var args = arguments;\n    if (isAsync) {\n      return callback.apply(this, args);\n    } else {\n      return this.then(function() {\n        return callback.apply(this, args);\n      });\n    }\n  };\n}", "language": "javascript", "code": "function protoWrap(proto, name, callback, isAsync) {\n  proto[name] = function() {\n    var args = arguments;\n    if (isAsync) {\n      return callback.apply(this, args);\n    } else {\n      return this.then(function() {\n        return callback.apply(this, args);\n      });\n    }\n  };\n}", "code_tokens": ["function", "protoWrap", "(", "proto", ",", "name", ",", "callback", ",", "isAsync", ")", "{", "proto", "[", "name", "]", "=", "function", "(", ")", "{", "var", "args", "=", "arguments", ";", "if", "(", "isAsync", ")", "{", "return", "callback", ".", "apply", "(", "this", ",", "args", ")", ";", "}", "else", "{", "return", "this", ".", "then", "(", "function", "(", ")", "{", "return", "callback", ".", "apply", "(", "this", ",", "args", ")", ";", "}", ")", ";", "}", "}", ";", "}"], "docstring": "This method is no longer needed But still here for backwards compatibility of helper chaining", "docstring_tokens": ["This", "method", "is", "no", "longer", "needed", "But", "still", "here", "for", "backwards", "compatibility", "of", "helper", "chaining"], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L43552-L43563", "partition": "test"}
{"repo": "emmetio/html-matcher", "path": "lib/attributes.js", "func_name": "eatAttributeValue", "original_string": "function eatAttributeValue(stream) {\n\tconst start = stream.pos;\n\tif (eatQuoted(stream)) {\n\t\t// Should return token that points to unquoted value.\n\t\t// Use stream readers\u2019 public API to traverse instead of direct\n\t\t// manipulation\n\t\tconst current = stream.pos;\n\t\tlet valueStart, valueEnd;\n\n\t\tstream.pos = start;\n\t\tstream.next();\n\t\tvalueStart = stream.start = stream.pos;\n\n\t\tstream.pos = current;\n\t\tstream.backUp(1);\n\t\tvalueEnd = stream.pos;\n\n\t\tconst result = token(stream, valueStart, valueEnd);\n\t\tstream.pos = current;\n\t\treturn result;\n\t}\n\n\treturn eatPaired(stream) || eatUnquoted(stream);\n}", "language": "javascript", "code": "function eatAttributeValue(stream) {\n\tconst start = stream.pos;\n\tif (eatQuoted(stream)) {\n\t\t// Should return token that points to unquoted value.\n\t\t// Use stream readers\u2019 public API to traverse instead of direct\n\t\t// manipulation\n\t\tconst current = stream.pos;\n\t\tlet valueStart, valueEnd;\n\n\t\tstream.pos = start;\n\t\tstream.next();\n\t\tvalueStart = stream.start = stream.pos;\n\n\t\tstream.pos = current;\n\t\tstream.backUp(1);\n\t\tvalueEnd = stream.pos;\n\n\t\tconst result = token(stream, valueStart, valueEnd);\n\t\tstream.pos = current;\n\t\treturn result;\n\t}\n\n\treturn eatPaired(stream) || eatUnquoted(stream);\n}", "code_tokens": ["function", "eatAttributeValue", "(", "stream", ")", "{", "const", "start", "=", "stream", ".", "pos", ";", "if", "(", "eatQuoted", "(", "stream", ")", ")", "{", "// Should return token that points to unquoted value.", "// Use stream readers\u2019 public API to traverse instead of direct", "// manipulation", "const", "current", "=", "stream", ".", "pos", ";", "let", "valueStart", ",", "valueEnd", ";", "stream", ".", "pos", "=", "start", ";", "stream", ".", "next", "(", ")", ";", "valueStart", "=", "stream", ".", "start", "=", "stream", ".", "pos", ";", "stream", ".", "pos", "=", "current", ";", "stream", ".", "backUp", "(", "1", ")", ";", "valueEnd", "=", "stream", ".", "pos", ";", "const", "result", "=", "token", "(", "stream", ",", "valueStart", ",", "valueEnd", ")", ";", "stream", ".", "pos", "=", "current", ";", "return", "result", ";", "}", "return", "eatPaired", "(", "stream", ")", "||", "eatUnquoted", "(", "stream", ")", ";", "}"], "docstring": "Consumes attribute value from given location\n@param  {StreamReader} stream\n@return {Token}", "docstring_tokens": ["Consumes", "attribute", "value", "from", "given", "location"], "sha": "55b01d2a157a482db5a538e39f7c6129a6fce011", "url": "https://github.com/emmetio/html-matcher/blob/55b01d2a157a482db5a538e39f7c6129a6fce011/lib/attributes.js#L63-L86", "partition": "test"}
{"repo": "bahrus/xtal-salt", "path": "dist/xtal-salt.iife.js", "func_name": "XtallatX", "original_string": "function XtallatX(superClass) {\n    return class extends superClass {\n        constructor() {\n            super(...arguments);\n            this._evCount = {};\n        }\n        static get observedAttributes() {\n            return [disabled];\n        }\n        /**\n         * Any component that emits events should not do so if it is disabled.\n         * Note that this is not enforced, but the disabled property is made available.\n         * Users of this mix-in should ensure not to call \"de\" if this property is set to true.\n         */\n        get disabled() {\n            return this._disabled;\n        }\n        set disabled(val) {\n            this.attr(disabled, val, '');\n        }\n        /**\n         * Set attribute value.\n         * @param name\n         * @param val\n         * @param trueVal String to set attribute if true.\n         */\n        attr(name, val, trueVal) {\n            const v = val ? 'set' : 'remove'; //verb\n            this[v + 'Attribute'](name, trueVal || val);\n        }\n        /**\n         * Turn number into string with even and odd values easy to query via css.\n         * @param n\n         */\n        to$(n) {\n            const mod = n % 2;\n            return (n - mod) / 2 + '-' + mod;\n        }\n        /**\n         * Increment event count\n         * @param name\n         */\n        incAttr(name) {\n            const ec = this._evCount;\n            if (name in ec) {\n                ec[name]++;\n            }\n            else {\n                ec[name] = 0;\n            }\n            this.attr('data-' + name, this.to$(ec[name]));\n        }\n        attributeChangedCallback(name, oldVal, newVal) {\n            switch (name) {\n                case disabled:\n                    this._disabled = newVal !== null;\n                    break;\n            }\n        }\n        /**\n         * Dispatch Custom Event\n         * @param name Name of event to dispatch (\"-changed\" will be appended if asIs is false)\n         * @param detail Information to be passed with the event\n         * @param asIs If true, don't append event name with '-changed'\n         */\n        de(name, detail, asIs = false) {\n            const eventName = name + (asIs ? '' : '-changed');\n            const newEvent = new CustomEvent(eventName, {\n                detail: detail,\n                bubbles: true,\n                composed: false,\n            });\n            this.dispatchEvent(newEvent);\n            this.incAttr(eventName);\n            return newEvent;\n        }\n        /**\n         * Needed for asynchronous loading\n         * @param props Array of property names to \"upgrade\", without losing value set while element was Unknown\n         */\n        _upgradeProperties(props) {\n            props.forEach(prop => {\n                if (this.hasOwnProperty(prop)) {\n                    let value = this[prop];\n                    delete this[prop];\n                    this[prop] = value;\n                }\n            });\n        }\n    };\n}", "language": "javascript", "code": "function XtallatX(superClass) {\n    return class extends superClass {\n        constructor() {\n            super(...arguments);\n            this._evCount = {};\n        }\n        static get observedAttributes() {\n            return [disabled];\n        }\n        /**\n         * Any component that emits events should not do so if it is disabled.\n         * Note that this is not enforced, but the disabled property is made available.\n         * Users of this mix-in should ensure not to call \"de\" if this property is set to true.\n         */\n        get disabled() {\n            return this._disabled;\n        }\n        set disabled(val) {\n            this.attr(disabled, val, '');\n        }\n        /**\n         * Set attribute value.\n         * @param name\n         * @param val\n         * @param trueVal String to set attribute if true.\n         */\n        attr(name, val, trueVal) {\n            const v = val ? 'set' : 'remove'; //verb\n            this[v + 'Attribute'](name, trueVal || val);\n        }\n        /**\n         * Turn number into string with even and odd values easy to query via css.\n         * @param n\n         */\n        to$(n) {\n            const mod = n % 2;\n            return (n - mod) / 2 + '-' + mod;\n        }\n        /**\n         * Increment event count\n         * @param name\n         */\n        incAttr(name) {\n            const ec = this._evCount;\n            if (name in ec) {\n                ec[name]++;\n            }\n            else {\n                ec[name] = 0;\n            }\n            this.attr('data-' + name, this.to$(ec[name]));\n        }\n        attributeChangedCallback(name, oldVal, newVal) {\n            switch (name) {\n                case disabled:\n                    this._disabled = newVal !== null;\n                    break;\n            }\n        }\n        /**\n         * Dispatch Custom Event\n         * @param name Name of event to dispatch (\"-changed\" will be appended if asIs is false)\n         * @param detail Information to be passed with the event\n         * @param asIs If true, don't append event name with '-changed'\n         */\n        de(name, detail, asIs = false) {\n            const eventName = name + (asIs ? '' : '-changed');\n            const newEvent = new CustomEvent(eventName, {\n                detail: detail,\n                bubbles: true,\n                composed: false,\n            });\n            this.dispatchEvent(newEvent);\n            this.incAttr(eventName);\n            return newEvent;\n        }\n        /**\n         * Needed for asynchronous loading\n         * @param props Array of property names to \"upgrade\", without losing value set while element was Unknown\n         */\n        _upgradeProperties(props) {\n            props.forEach(prop => {\n                if (this.hasOwnProperty(prop)) {\n                    let value = this[prop];\n                    delete this[prop];\n                    this[prop] = value;\n                }\n            });\n        }\n    };\n}", "code_tokens": ["function", "XtallatX", "(", "superClass", ")", "{", "return", "class", "extends", "superClass", "{", "constructor", "(", ")", "{", "super", "(", "...", "arguments", ")", ";", "this", ".", "_evCount", "=", "{", "}", ";", "}", "static", "get", "observedAttributes", "(", ")", "{", "return", "[", "disabled", "]", ";", "}", "/**\n         * Any component that emits events should not do so if it is disabled.\n         * Note that this is not enforced, but the disabled property is made available.\n         * Users of this mix-in should ensure not to call \"de\" if this property is set to true.\n         */", "get", "disabled", "(", ")", "{", "return", "this", ".", "_disabled", ";", "}", "set", "disabled", "(", "val", ")", "{", "this", ".", "attr", "(", "disabled", ",", "val", ",", "''", ")", ";", "}", "/**\n         * Set attribute value.\n         * @param name\n         * @param val\n         * @param trueVal String to set attribute if true.\n         */", "attr", "(", "name", ",", "val", ",", "trueVal", ")", "{", "const", "v", "=", "val", "?", "'set'", ":", "'remove'", ";", "//verb", "this", "[", "v", "+", "'Attribute'", "]", "(", "name", ",", "trueVal", "||", "val", ")", ";", "}", "/**\n         * Turn number into string with even and odd values easy to query via css.\n         * @param n\n         */", "to$", "(", "n", ")", "{", "const", "mod", "=", "n", "%", "2", ";", "return", "(", "n", "-", "mod", ")", "/", "2", "+", "'-'", "+", "mod", ";", "}", "/**\n         * Increment event count\n         * @param name\n         */", "incAttr", "(", "name", ")", "{", "const", "ec", "=", "this", ".", "_evCount", ";", "if", "(", "name", "in", "ec", ")", "{", "ec", "[", "name", "]", "++", ";", "}", "else", "{", "ec", "[", "name", "]", "=", "0", ";", "}", "this", ".", "attr", "(", "'data-'", "+", "name", ",", "this", ".", "to$", "(", "ec", "[", "name", "]", ")", ")", ";", "}", "attributeChangedCallback", "(", "name", ",", "oldVal", ",", "newVal", ")", "{", "switch", "(", "name", ")", "{", "case", "disabled", ":", "this", ".", "_disabled", "=", "newVal", "!==", "null", ";", "break", ";", "}", "}", "/**\n         * Dispatch Custom Event\n         * @param name Name of event to dispatch (\"-changed\" will be appended if asIs is false)\n         * @param detail Information to be passed with the event\n         * @param asIs If true, don't append event name with '-changed'\n         */", "de", "(", "name", ",", "detail", ",", "asIs", "=", "false", ")", "{", "const", "eventName", "=", "name", "+", "(", "asIs", "?", "''", ":", "'-changed'", ")", ";", "const", "newEvent", "=", "new", "CustomEvent", "(", "eventName", ",", "{", "detail", ":", "detail", ",", "bubbles", ":", "true", ",", "composed", ":", "false", ",", "}", ")", ";", "this", ".", "dispatchEvent", "(", "newEvent", ")", ";", "this", ".", "incAttr", "(", "eventName", ")", ";", "return", "newEvent", ";", "}", "/**\n         * Needed for asynchronous loading\n         * @param props Array of property names to \"upgrade\", without losing value set while element was Unknown\n         */", "_upgradeProperties", "(", "props", ")", "{", "props", ".", "forEach", "(", "prop", "=>", "{", "if", "(", "this", ".", "hasOwnProperty", "(", "prop", ")", ")", "{", "let", "value", "=", "this", "[", "prop", "]", ";", "delete", "this", "[", "prop", "]", ";", "this", "[", "prop", "]", "=", "value", ";", "}", "}", ")", ";", "}", "}", ";", "}"], "docstring": "Base class for many xtal- components\n@param superClass", "docstring_tokens": ["Base", "class", "for", "many", "xtal", "-", "components"], "sha": "5321b9f60bf5659634376db13162aab0f8716230", "url": "https://github.com/bahrus/xtal-salt/blob/5321b9f60bf5659634376db13162aab0f8716230/dist/xtal-salt.iife.js#L17-L107", "partition": "test"}
{"repo": "alexisvincent/systemjs-hot-reloader", "path": "dist/index.js", "func_name": "onupgrade", "original_string": "function onupgrade (to) {\n    if (transport$$1 && to.name !== transport$$1.name) {\n      debug$2('\"%s\" works - aborting \"%s\"', to.name, transport$$1.name);\n      freezeTransport();\n    }\n  }", "language": "javascript", "code": "function onupgrade (to) {\n    if (transport$$1 && to.name !== transport$$1.name) {\n      debug$2('\"%s\" works - aborting \"%s\"', to.name, transport$$1.name);\n      freezeTransport();\n    }\n  }", "code_tokens": ["function", "onupgrade", "(", "to", ")", "{", "if", "(", "transport$$1", "&&", "to", ".", "name", "!==", "transport$$1", ".", "name", ")", "{", "debug$2", "(", "'\"%s\" works - aborting \"%s\"'", ",", "to", ".", "name", ",", "transport$$1", ".", "name", ")", ";", "freezeTransport", "(", ")", ";", "}", "}"], "docstring": "When the socket is upgraded while we're probing", "docstring_tokens": ["When", "the", "socket", "is", "upgraded", "while", "we", "re", "probing"], "sha": "e3cca45a50e69cba4c1988a251ef07f460c27619", "url": "https://github.com/alexisvincent/systemjs-hot-reloader/blob/e3cca45a50e69cba4c1988a251ef07f460c27619/dist/index.js#L6650-L6655", "partition": "test"}
{"repo": "colinskow/superlogin", "path": "lib/oauth.js", "func_name": "oauthErrorHandler", "original_string": "function oauthErrorHandler(err,req,res,next) {\n    var template;\n    if(config.getItem('testMode.oauthTest')) {\n      template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback-test.ejs'), 'utf8');\n    } else {\n      template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback.ejs'), 'utf8');\n    }\n    var html = ejs.render(template, {error: err.message, session: null, link: null});\n    console.error(err);\n    if(err.stack) {\n      console.error(err.stack);\n    }\n    res.status(400).send(html);\n  }", "language": "javascript", "code": "function oauthErrorHandler(err,req,res,next) {\n    var template;\n    if(config.getItem('testMode.oauthTest')) {\n      template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback-test.ejs'), 'utf8');\n    } else {\n      template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback.ejs'), 'utf8');\n    }\n    var html = ejs.render(template, {error: err.message, session: null, link: null});\n    console.error(err);\n    if(err.stack) {\n      console.error(err.stack);\n    }\n    res.status(400).send(html);\n  }", "code_tokens": ["function", "oauthErrorHandler", "(", "err", ",", "req", ",", "res", ",", "next", ")", "{", "var", "template", ";", "if", "(", "config", ".", "getItem", "(", "'testMode.oauthTest'", ")", ")", "{", "template", "=", "fs", ".", "readFileSync", "(", "path", ".", "join", "(", "__dirname", ",", "'../templates/oauth/auth-callback-test.ejs'", ")", ",", "'utf8'", ")", ";", "}", "else", "{", "template", "=", "fs", ".", "readFileSync", "(", "path", ".", "join", "(", "__dirname", ",", "'../templates/oauth/auth-callback.ejs'", ")", ",", "'utf8'", ")", ";", "}", "var", "html", "=", "ejs", ".", "render", "(", "template", ",", "{", "error", ":", "err", ".", "message", ",", "session", ":", "null", ",", "link", ":", "null", "}", ")", ";", "console", ".", "error", "(", "err", ")", ";", "if", "(", "err", ".", "stack", ")", "{", "console", ".", "error", "(", "err", ".", "stack", ")", ";", "}", "res", ".", "status", "(", "400", ")", ".", "send", "(", "html", ")", ";", "}"], "docstring": "Handles errors if authentication fails", "docstring_tokens": ["Handles", "errors", "if", "authentication", "fails"], "sha": "8e7c7c1a77c1f5303b74f941208349e3a6e0c9ad", "url": "https://github.com/colinskow/superlogin/blob/8e7c7c1a77c1f5303b74f941208349e3a6e0c9ad/lib/oauth.js#L81-L94", "partition": "test"}
{"repo": "olegpolyakov/sendpulse", "path": "index.js", "func_name": "returnError", "original_string": "function returnError(message){\n    var data = {is_error:1};\n    if (message !== undefined && message.length) {\n        data['message'] = message\n    }\n    return data;\n}", "language": "javascript", "code": "function returnError(message){\n    var data = {is_error:1};\n    if (message !== undefined && message.length) {\n        data['message'] = message\n    }\n    return data;\n}", "code_tokens": ["function", "returnError", "(", "message", ")", "{", "var", "data", "=", "{", "is_error", ":", "1", "}", ";", "if", "(", "message", "!==", "undefined", "&&", "message", ".", "length", ")", "{", "data", "[", "'message'", "]", "=", "message", "}", "return", "data", ";", "}"], "docstring": "Form error object\n\n@return array", "docstring_tokens": ["Form", "error", "object"], "sha": "7c8230e75c918a8a110f641ddb241006a1f86ac1", "url": "https://github.com/olegpolyakov/sendpulse/blob/7c8230e75c918a8a110f641ddb241006a1f86ac1/index.js#L155-L161", "partition": "test"}
{"repo": "avwo/whistle", "path": "docs/script/docify.js", "func_name": "sammary", "original_string": "function sammary() {\n  const nodeFn = function ({ parentPaths, lang, item, isDir, result }) {\n    const navTitle = generateNavTitle({ parentPaths, item, sign: isDir ? '-' : '*', lang });\n    result.push(navTitle);\n  };\n\n  langs.forEach(dir => {\n    const SUMMARY = 'SUMMARY.md';\n    const targetFile = path.join(docsDir, `${dir}/${SUMMARY}`);\n\n    const result = walk({\n      catalog: docConfig.catalog,\n      lang: dir,\n      result: [],\n      parentPaths: [],\n      fn: nodeFn\n    });\n\n    if (result && result.length) {\n      result.unshift('# whistle\\n');\n      fs.writeFileSync(targetFile, result.join('\\n'));\n    }\n  });\n}", "language": "javascript", "code": "function sammary() {\n  const nodeFn = function ({ parentPaths, lang, item, isDir, result }) {\n    const navTitle = generateNavTitle({ parentPaths, item, sign: isDir ? '-' : '*', lang });\n    result.push(navTitle);\n  };\n\n  langs.forEach(dir => {\n    const SUMMARY = 'SUMMARY.md';\n    const targetFile = path.join(docsDir, `${dir}/${SUMMARY}`);\n\n    const result = walk({\n      catalog: docConfig.catalog,\n      lang: dir,\n      result: [],\n      parentPaths: [],\n      fn: nodeFn\n    });\n\n    if (result && result.length) {\n      result.unshift('# whistle\\n');\n      fs.writeFileSync(targetFile, result.join('\\n'));\n    }\n  });\n}", "code_tokens": ["function", "sammary", "(", ")", "{", "const", "nodeFn", "=", "function", "(", "{", "parentPaths", ",", "lang", ",", "item", ",", "isDir", ",", "result", "}", ")", "{", "const", "navTitle", "=", "generateNavTitle", "(", "{", "parentPaths", ",", "item", ",", "sign", ":", "isDir", "?", "'-'", ":", "'*'", ",", "lang", "}", ")", ";", "result", ".", "push", "(", "navTitle", ")", ";", "}", ";", "langs", ".", "forEach", "(", "dir", "=>", "{", "const", "SUMMARY", "=", "'SUMMARY.md'", ";", "const", "targetFile", "=", "path", ".", "join", "(", "docsDir", ",", "`", "${", "dir", "}", "${", "SUMMARY", "}", "`", ")", ";", "const", "result", "=", "walk", "(", "{", "catalog", ":", "docConfig", ".", "catalog", ",", "lang", ":", "dir", ",", "result", ":", "[", "]", ",", "parentPaths", ":", "[", "]", ",", "fn", ":", "nodeFn", "}", ")", ";", "if", "(", "result", "&&", "result", ".", "length", ")", "{", "result", ".", "unshift", "(", "'# whistle\\n'", ")", ";", "fs", ".", "writeFileSync", "(", "targetFile", ",", "result", ".", "join", "(", "'\\n'", ")", ")", ";", "}", "}", ")", ";", "}"], "docstring": "generate `SUMMARY.md` by `config.json`", "docstring_tokens": ["generate", "SUMMARY", ".", "md", "by", "config", ".", "json"], "sha": "b419da1d6185a006327f2ce267667f11c0d4109e", "url": "https://github.com/avwo/whistle/blob/b419da1d6185a006327f2ce267667f11c0d4109e/docs/script/docify.js#L136-L159", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/device/filesystem/HTML5.js", "func_name": "", "original_string": "function(config) {\n                if (config.parent == null) {\n                    Ext.Logger.error('Ext.device.filesystem.Entry#moveTo: You must specify a new `parent` of the entry.');\n                    return null;\n                }\n\n                var me = this;\n\n                this.getEntry(\n                    {\n                        options: config.options || {},\n                        success: function(sourceEntry) {\n                            config.parent.getEntry(\n                                {\n                                    options: config.options || {},\n                                    success: function(destinationEntry) {\n                                        if (config.copy) {\n                                            sourceEntry.copyTo(destinationEntry, config.newName, function(entry) {\n                                                config.success.call(\n                                                    config.scope || me,\n                                                    entry.isDirectory ? Ext.create('Ext.device.filesystem.DirectoryEntry', entry.fullPath, me.fileSystem) : Ext.create('Ext.device.filesystem.FileEntry', entry.fullPath, me.fileSystem)\n                                                );\n                                            }, config.failure);\n                                        } else {\n                                            sourceEntry.moveTo(destinationEntry, config.newName, function(entry) {\n                                                config.success.call(\n                                                    config.scope || me,\n                                                    entry.isDirectory ? Ext.create('Ext.device.filesystem.DirectoryEntry', entry.fullPath, me.fileSystem) : Ext.create('Ext.device.filesystem.FileEntry', entry.fullPath, me.fileSystem)\n                                                );\n                                            }, config.failure);\n                                        }\n                                    },\n                                    failure: config.failure\n                                }\n                            );\n                        },\n                        failure: config.failure\n                    }\n                );\n            }", "language": "javascript", "code": "function(config) {\n                if (config.parent == null) {\n                    Ext.Logger.error('Ext.device.filesystem.Entry#moveTo: You must specify a new `parent` of the entry.');\n                    return null;\n                }\n\n                var me = this;\n\n                this.getEntry(\n                    {\n                        options: config.options || {},\n                        success: function(sourceEntry) {\n                            config.parent.getEntry(\n                                {\n                                    options: config.options || {},\n                                    success: function(destinationEntry) {\n                                        if (config.copy) {\n                                            sourceEntry.copyTo(destinationEntry, config.newName, function(entry) {\n                                                config.success.call(\n                                                    config.scope || me,\n                                                    entry.isDirectory ? Ext.create('Ext.device.filesystem.DirectoryEntry', entry.fullPath, me.fileSystem) : Ext.create('Ext.device.filesystem.FileEntry', entry.fullPath, me.fileSystem)\n                                                );\n                                            }, config.failure);\n                                        } else {\n                                            sourceEntry.moveTo(destinationEntry, config.newName, function(entry) {\n                                                config.success.call(\n                                                    config.scope || me,\n                                                    entry.isDirectory ? Ext.create('Ext.device.filesystem.DirectoryEntry', entry.fullPath, me.fileSystem) : Ext.create('Ext.device.filesystem.FileEntry', entry.fullPath, me.fileSystem)\n                                                );\n                                            }, config.failure);\n                                        }\n                                    },\n                                    failure: config.failure\n                                }\n                            );\n                        },\n                        failure: config.failure\n                    }\n                );\n            }", "code_tokens": ["function", "(", "config", ")", "{", "if", "(", "config", ".", "parent", "==", "null", ")", "{", "Ext", ".", "Logger", ".", "error", "(", "'Ext.device.filesystem.Entry#moveTo: You must specify a new `parent` of the entry.'", ")", ";", "return", "null", ";", "}", "var", "me", "=", "this", ";", "this", ".", "getEntry", "(", "{", "options", ":", "config", ".", "options", "||", "{", "}", ",", "success", ":", "function", "(", "sourceEntry", ")", "{", "config", ".", "parent", ".", "getEntry", "(", "{", "options", ":", "config", ".", "options", "||", "{", "}", ",", "success", ":", "function", "(", "destinationEntry", ")", "{", "if", "(", "config", ".", "copy", ")", "{", "sourceEntry", ".", "copyTo", "(", "destinationEntry", ",", "config", ".", "newName", ",", "function", "(", "entry", ")", "{", "config", ".", "success", ".", "call", "(", "config", ".", "scope", "||", "me", ",", "entry", ".", "isDirectory", "?", "Ext", ".", "create", "(", "'Ext.device.filesystem.DirectoryEntry'", ",", "entry", ".", "fullPath", ",", "me", ".", "fileSystem", ")", ":", "Ext", ".", "create", "(", "'Ext.device.filesystem.FileEntry'", ",", "entry", ".", "fullPath", ",", "me", ".", "fileSystem", ")", ")", ";", "}", ",", "config", ".", "failure", ")", ";", "}", "else", "{", "sourceEntry", ".", "moveTo", "(", "destinationEntry", ",", "config", ".", "newName", ",", "function", "(", "entry", ")", "{", "config", ".", "success", ".", "call", "(", "config", ".", "scope", "||", "me", ",", "entry", ".", "isDirectory", "?", "Ext", ".", "create", "(", "'Ext.device.filesystem.DirectoryEntry'", ",", "entry", ".", "fullPath", ",", "me", ".", "fileSystem", ")", ":", "Ext", ".", "create", "(", "'Ext.device.filesystem.FileEntry'", ",", "entry", ".", "fullPath", ",", "me", ".", "fileSystem", ")", ")", ";", "}", ",", "config", ".", "failure", ")", ";", "}", "}", ",", "failure", ":", "config", ".", "failure", "}", ")", ";", "}", ",", "failure", ":", "config", ".", "failure", "}", ")", ";", "}"], "docstring": "Moves the entry to a different location on the file system.\n\n@param {Object} config\nThe object which contains the following config options:\n\n@param {Ext.device.filesystem.DirectoryEntry} config.parent This is required.\nThe directory to which to move the entry.\n\n@param {String} config.newName This is optional.\nThe new name of the entry to move. Defaults to the entry's current name if unspecified.\n\n@param {Function} config.success This is optional.\nThe callback to be called when the entry has been successfully moved.\n\n@param {Ext.device.filesystem.Entry} config.success.entry\nThe entry for the new location.\n\n@param {Function} config.failure This is optional.\nThe callback to be called when an error occurred.\n\n@param {Object} config.failure.error\nThe occurred error.\n\n@param {Object} config.scope\nThe scope object", "docstring_tokens": ["Moves", "the", "entry", "to", "a", "different", "location", "on", "the", "file", "system", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/filesystem/HTML5.js#L195-L234", "partition": "test"}
{"repo": "alvarotrigo/react-fullpage", "path": "example/dist/bundle.js", "func_name": "", "original_string": "function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n    }\n  }", "language": "javascript", "code": "function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n    }\n  }", "code_tokens": ["function", "(", ")", "{", "var", "Interface", "=", "this", ".", "constructor", ".", "Interface", ";", "for", "(", "var", "propName", "in", "Interface", ")", "{", "{", "Object", ".", "defineProperty", "(", "this", ",", "propName", ",", "getPooledWarningPropertyDefinition", "(", "propName", ",", "Interface", "[", "propName", "]", ")", ")", ";", "}", "}", "this", ".", "dispatchConfig", "=", "null", ";", "this", ".", "_targetInst", "=", "null", ";", "this", ".", "nativeEvent", "=", "null", ";", "this", ".", "isDefaultPrevented", "=", "functionThatReturnsFalse", ";", "this", ".", "isPropagationStopped", "=", "functionThatReturnsFalse", ";", "this", ".", "_dispatchListeners", "=", "null", ";", "this", ".", "_dispatchInstances", "=", "null", ";", "{", "Object", ".", "defineProperty", "(", "this", ",", "'nativeEvent'", ",", "getPooledWarningPropertyDefinition", "(", "'nativeEvent'", ",", "null", ")", ")", ";", "Object", ".", "defineProperty", "(", "this", ",", "'isDefaultPrevented'", ",", "getPooledWarningPropertyDefinition", "(", "'isDefaultPrevented'", ",", "functionThatReturnsFalse", ")", ")", ";", "Object", ".", "defineProperty", "(", "this", ",", "'isPropagationStopped'", ",", "getPooledWarningPropertyDefinition", "(", "'isPropagationStopped'", ",", "functionThatReturnsFalse", ")", ")", ";", "Object", ".", "defineProperty", "(", "this", ",", "'preventDefault'", ",", "getPooledWarningPropertyDefinition", "(", "'preventDefault'", ",", "function", "(", ")", "{", "}", ")", ")", ";", "Object", ".", "defineProperty", "(", "this", ",", "'stopPropagation'", ",", "getPooledWarningPropertyDefinition", "(", "'stopPropagation'", ",", "function", "(", ")", "{", "}", ")", ")", ";", "}", "}"], "docstring": "`PooledClass` looks for `destructor` on each instance it releases.", "docstring_tokens": ["PooledClass", "looks", "for", "destructor", "on", "each", "instance", "it", "releases", "."], "sha": "5a11fb5211e5706da81f2874516f023dc6e5aa88", "url": "https://github.com/alvarotrigo/react-fullpage/blob/5a11fb5211e5706da81f2874516f023dc6e5aa88/example/dist/bundle.js#L3958-L3979", "partition": "test"}
{"repo": "developmentseed/kes", "path": "src/utils.js", "func_name": "fileToString", "original_string": "function fileToString(file) {\n  try {\n    const stat = fs.lstatSync(file);\n\n    if (stat.isFile()) {\n      const content = fs.readFileSync(file, 'utf8');\n      return content.toString();\n    }\n  }\n  catch (e) {\n    if (!e.message.includes('ENOENT') && !e.message.includes('name too long, lstat')) {\n      throw e;\n    }\n  }\n  return file;\n}", "language": "javascript", "code": "function fileToString(file) {\n  try {\n    const stat = fs.lstatSync(file);\n\n    if (stat.isFile()) {\n      const content = fs.readFileSync(file, 'utf8');\n      return content.toString();\n    }\n  }\n  catch (e) {\n    if (!e.message.includes('ENOENT') && !e.message.includes('name too long, lstat')) {\n      throw e;\n    }\n  }\n  return file;\n}", "code_tokens": ["function", "fileToString", "(", "file", ")", "{", "try", "{", "const", "stat", "=", "fs", ".", "lstatSync", "(", "file", ")", ";", "if", "(", "stat", ".", "isFile", "(", ")", ")", "{", "const", "content", "=", "fs", ".", "readFileSync", "(", "file", ",", "'utf8'", ")", ";", "return", "content", ".", "toString", "(", ")", ";", "}", "}", "catch", "(", "e", ")", "{", "if", "(", "!", "e", ".", "message", ".", "includes", "(", "'ENOENT'", ")", "&&", "!", "e", ".", "message", ".", "includes", "(", "'name too long, lstat'", ")", ")", "{", "throw", "e", ";", "}", "}", "return", "file", ";", "}"], "docstring": "Checks if the input is a file, if it is a file,\nit reads it and return the content, otherwise just pass\nthe input as an output\n\n@param {String} file A file path or a string\n@returns {String} String content of a given file", "docstring_tokens": ["Checks", "if", "the", "input", "is", "a", "file", "if", "it", "is", "a", "file", "it", "reads", "it", "and", "return", "the", "content", "otherwise", "just", "pass", "the", "input", "as", "an", "output"], "sha": "c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6", "url": "https://github.com/developmentseed/kes/blob/c92aaaf84c6ad5f75e03bdd0f0e4328c784854e6/src/utils.js#L139-L154", "partition": "test"}
{"repo": "HydraJS/HydraJS", "path": "src/libs/Bus.js", "func_name": "subscribe", "original_string": "function subscribe(oSubscriber) {\n  const oEventsCallbacks = oSubscriber.events;\n  if (!oSubscriber || oEventsCallbacks === und) {\n    return false;\n  }\n  iterateObject(oEventsCallbacks, function (oItem, sChannelId) {\n    if (oChannels[sChannelId] === und) {\n      oChannels[sChannelId] = {};\n    }\n    _addSubscribers(oItem, sChannelId, oSubscriber);\n  });\n\n  return true;\n}", "language": "javascript", "code": "function subscribe(oSubscriber) {\n  const oEventsCallbacks = oSubscriber.events;\n  if (!oSubscriber || oEventsCallbacks === und) {\n    return false;\n  }\n  iterateObject(oEventsCallbacks, function (oItem, sChannelId) {\n    if (oChannels[sChannelId] === und) {\n      oChannels[sChannelId] = {};\n    }\n    _addSubscribers(oItem, sChannelId, oSubscriber);\n  });\n\n  return true;\n}", "code_tokens": ["function", "subscribe", "(", "oSubscriber", ")", "{", "const", "oEventsCallbacks", "=", "oSubscriber", ".", "events", ";", "if", "(", "!", "oSubscriber", "||", "oEventsCallbacks", "===", "und", ")", "{", "return", "false", ";", "}", "iterateObject", "(", "oEventsCallbacks", ",", "function", "(", "oItem", ",", "sChannelId", ")", "{", "if", "(", "oChannels", "[", "sChannelId", "]", "===", "und", ")", "{", "oChannels", "[", "sChannelId", "]", "=", "{", "}", ";", "}", "_addSubscribers", "(", "oItem", ",", "sChannelId", ",", "oSubscriber", ")", ";", "}", ")", ";", "return", "true", ";", "}"], "docstring": "subscribe method gets the oEventsCallbacks object with all the handlers and add these handlers to the channel.\n@param {Object} oSubscriber\n@return {Boolean}", "docstring_tokens": ["subscribe", "method", "gets", "the", "oEventsCallbacks", "object", "with", "all", "the", "handlers", "and", "add", "these", "handlers", "to", "the", "channel", "."], "sha": "ef3ede4aebd29081fe960eb86a37a1a4bf571b2d", "url": "https://github.com/HydraJS/HydraJS/blob/ef3ede4aebd29081fe960eb86a37a1a4bf571b2d/src/libs/Bus.js#L161-L174", "partition": "test"}
{"repo": "gavinhungry/pingy", "path": "pingy.js", "func_name": "", "original_string": "function() {\n    return {\n      r: Math.floor(Math.random() * 256),\n      g: Math.floor(Math.random() * 256),\n      b: Math.floor(Math.random() * 256),\n      a: 255\n    };\n  }", "language": "javascript", "code": "function() {\n    return {\n      r: Math.floor(Math.random() * 256),\n      g: Math.floor(Math.random() * 256),\n      b: Math.floor(Math.random() * 256),\n      a: 255\n    };\n  }", "code_tokens": ["function", "(", ")", "{", "return", "{", "r", ":", "Math", ".", "floor", "(", "Math", ".", "random", "(", ")", "*", "256", ")", ",", "g", ":", "Math", ".", "floor", "(", "Math", ".", "random", "(", ")", "*", "256", ")", ",", "b", ":", "Math", ".", "floor", "(", "Math", ".", "random", "(", ")", "*", "256", ")", ",", "a", ":", "255", "}", ";", "}"], "docstring": "Get a random color\n\n@return {Object} RGBA value", "docstring_tokens": ["Get", "a", "random", "color"], "sha": "6043347be9c05a2adb8a853f9face425a97799b4", "url": "https://github.com/gavinhungry/pingy/blob/6043347be9c05a2adb8a853f9face425a97799b4/pingy.js#L54-L61", "partition": "test"}
{"repo": "snapptop/ninjs-lodash", "path": "lib/path.js", "func_name": "rel", "original_string": "function rel(root, src, sep) {\n  if(!root || !_.isString(root) || !src || !_.isString(src)) return\n  let root_split = root.split(path.sep),\n    src_split = src.split(path.sep)\n  return _.join(_.difference(src_split, root_split), sep || '/')\n}", "language": "javascript", "code": "function rel(root, src, sep) {\n  if(!root || !_.isString(root) || !src || !_.isString(src)) return\n  let root_split = root.split(path.sep),\n    src_split = src.split(path.sep)\n  return _.join(_.difference(src_split, root_split), sep || '/')\n}", "code_tokens": ["function", "rel", "(", "root", ",", "src", ",", "sep", ")", "{", "if", "(", "!", "root", "||", "!", "_", ".", "isString", "(", "root", ")", "||", "!", "src", "||", "!", "_", ".", "isString", "(", "src", ")", ")", "return", "let", "root_split", "=", "root", ".", "split", "(", "path", ".", "sep", ")", ",", "src_split", "=", "src", ".", "split", "(", "path", ".", "sep", ")", "return", "_", ".", "join", "(", "_", ".", "difference", "(", "src_split", ",", "root_split", ")", ",", "sep", "||", "'/'", ")", "}"], "docstring": "returns rel path of src from root", "docstring_tokens": ["returns", "rel", "path", "of", "src", "from", "root"], "sha": "fab253b7d96cc9bb3f2a1057efff2684c200bcee", "url": "https://github.com/snapptop/ninjs-lodash/blob/fab253b7d96cc9bb3f2a1057efff2684c200bcee/lib/path.js#L171-L176", "partition": "test"}
{"repo": "rootsdev/gedcomx-fs-js", "path": "src/SearchInfo.js", "func_name": "", "original_string": "function(json){\n    \n    // Protect against forgetting the new keyword when calling the constructor\n    if(!(this instanceof SearchInfo)){\n      return new SearchInfo(json);\n    }\n    \n    // If the given object is already an instance then just return it. DON'T copy it.\n    if(SearchInfo.isInstance(json)){\n      return json;\n    }\n    \n    this.init(json);\n  }", "language": "javascript", "code": "function(json){\n    \n    // Protect against forgetting the new keyword when calling the constructor\n    if(!(this instanceof SearchInfo)){\n      return new SearchInfo(json);\n    }\n    \n    // If the given object is already an instance then just return it. DON'T copy it.\n    if(SearchInfo.isInstance(json)){\n      return json;\n    }\n    \n    this.init(json);\n  }", "code_tokens": ["function", "(", "json", ")", "{", "// Protect against forgetting the new keyword when calling the constructor", "if", "(", "!", "(", "this", "instanceof", "SearchInfo", ")", ")", "{", "return", "new", "SearchInfo", "(", "json", ")", ";", "}", "// If the given object is already an instance then just return it. DON'T copy it.", "if", "(", "SearchInfo", ".", "isInstance", "(", "json", ")", ")", "{", "return", "json", ";", "}", "this", ".", "init", "(", "json", ")", ";", "}"], "docstring": "Information about a search.\n\n@class SearchInfo\n@extends Base\n@param {Object} [json]", "docstring_tokens": ["Information", "about", "a", "search", "."], "sha": "47b6c6c9a609e163d80673d08fc83073f730d9d8", "url": "https://github.com/rootsdev/gedcomx-fs-js/blob/47b6c6c9a609e163d80673d08fc83073f730d9d8/src/SearchInfo.js#L10-L23", "partition": "test"}
{"repo": "weikinhuang/closedinterval-git-hooks", "path": "lib/pre-commit/pre-commit-base.js", "func_name": "extractStyles", "original_string": "function extractStyles(src) {\n\tvar isInBlock = false,\n\t\tlines = [];\n\n\tsrc.replace(/\\r/g, \"\").split(\"\\n\").forEach(function(l) {\n\t\t// we're at the end of the style tag\n\t\tif (l.indexOf(\"</style\") > -1) {\n\t\t\tlines[lines.length] = \"\";\n\t\t\tisInBlock = false;\n\t\t\treturn;\n\t\t}\n\t\tif (isInBlock) {\n\t\t\tlines[lines.length] = l;\n\t\t} else {\n\t\t\tlines[lines.length] = \"\";\n\t\t}\n\t\tif (l.indexOf(\"<style\") > -1) {\n\t\t\tisInBlock = true;\n\t\t}\n\t});\n\treturn lines.join(\"\\n\").replace(/\\{\\$(\\w+\\.)*\\w+\\}/g, \"{}\");\n}", "language": "javascript", "code": "function extractStyles(src) {\n\tvar isInBlock = false,\n\t\tlines = [];\n\n\tsrc.replace(/\\r/g, \"\").split(\"\\n\").forEach(function(l) {\n\t\t// we're at the end of the style tag\n\t\tif (l.indexOf(\"</style\") > -1) {\n\t\t\tlines[lines.length] = \"\";\n\t\t\tisInBlock = false;\n\t\t\treturn;\n\t\t}\n\t\tif (isInBlock) {\n\t\t\tlines[lines.length] = l;\n\t\t} else {\n\t\t\tlines[lines.length] = \"\";\n\t\t}\n\t\tif (l.indexOf(\"<style\") > -1) {\n\t\t\tisInBlock = true;\n\t\t}\n\t});\n\treturn lines.join(\"\\n\").replace(/\\{\\$(\\w+\\.)*\\w+\\}/g, \"{}\");\n}", "code_tokens": ["function", "extractStyles", "(", "src", ")", "{", "var", "isInBlock", "=", "false", ",", "lines", "=", "[", "]", ";", "src", ".", "replace", "(", "/", "\\r", "/", "g", ",", "\"\"", ")", ".", "split", "(", "\"\\n\"", ")", ".", "forEach", "(", "function", "(", "l", ")", "{", "// we're at the end of the style tag", "if", "(", "l", ".", "indexOf", "(", "\"</style\"", ")", ">", "-", "1", ")", "{", "lines", "[", "lines", ".", "length", "]", "=", "\"\"", ";", "isInBlock", "=", "false", ";", "return", ";", "}", "if", "(", "isInBlock", ")", "{", "lines", "[", "lines", ".", "length", "]", "=", "l", ";", "}", "else", "{", "lines", "[", "lines", ".", "length", "]", "=", "\"\"", ";", "}", "if", "(", "l", ".", "indexOf", "(", "\"<style\"", ")", ">", "-", "1", ")", "{", "isInBlock", "=", "true", ";", "}", "}", ")", ";", "return", "lines", ".", "join", "(", "\"\\n\"", ")", ".", "replace", "(", "/", "\\{\\$(\\w+\\.)*\\w+\\}", "/", "g", ",", "\"{}\"", ")", ";", "}"], "docstring": "Replace non css content in a html file with empty lines\n@param {String} src\n@returns {String}", "docstring_tokens": ["Replace", "non", "css", "content", "in", "a", "html", "file", "with", "empty", "lines"], "sha": "42d7e6874a4500bc3d6f9aaadf03324748930e44", "url": "https://github.com/weikinhuang/closedinterval-git-hooks/blob/42d7e6874a4500bc3d6f9aaadf03324748930e44/lib/pre-commit/pre-commit-base.js#L155-L176", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/dom/Element.style.js", "func_name": "", "original_string": "function() {\n        //<debug warn>\n        Ext.Logger.deprecate(\"Ext.dom.Element.getViewSize() is deprecated\", this);\n        //</debug>\n\n        var doc = document,\n            dom = this.dom;\n\n        if (dom == doc || dom == doc.body) {\n            return {\n                width: Element.getViewportWidth(),\n                height: Element.getViewportHeight()\n            };\n        }\n        else {\n            return {\n                width: dom.clientWidth,\n                height: dom.clientHeight\n            };\n        }\n    }", "language": "javascript", "code": "function() {\n        //<debug warn>\n        Ext.Logger.deprecate(\"Ext.dom.Element.getViewSize() is deprecated\", this);\n        //</debug>\n\n        var doc = document,\n            dom = this.dom;\n\n        if (dom == doc || dom == doc.body) {\n            return {\n                width: Element.getViewportWidth(),\n                height: Element.getViewportHeight()\n            };\n        }\n        else {\n            return {\n                width: dom.clientWidth,\n                height: dom.clientHeight\n            };\n        }\n    }", "code_tokens": ["function", "(", ")", "{", "//<debug warn>", "Ext", ".", "Logger", ".", "deprecate", "(", "\"Ext.dom.Element.getViewSize() is deprecated\"", ",", "this", ")", ";", "//</debug>", "var", "doc", "=", "document", ",", "dom", "=", "this", ".", "dom", ";", "if", "(", "dom", "==", "doc", "||", "dom", "==", "doc", ".", "body", ")", "{", "return", "{", "width", ":", "Element", ".", "getViewportWidth", "(", ")", ",", "height", ":", "Element", ".", "getViewportHeight", "(", ")", "}", ";", "}", "else", "{", "return", "{", "width", ":", "dom", ".", "clientWidth", ",", "height", ":", "dom", ".", "clientHeight", "}", ";", "}", "}"], "docstring": "Returns the dimensions of the element available to lay content out in.\n\nIf the element (or any ancestor element) has CSS style `display: none`, the dimensions will be zero.\n\nExample:\n\nvar vpSize = Ext.getBody().getViewSize();\n\n// all Windows created afterwards will have a default value of 90% height and 95% width\nExt.Window.override({\nwidth: vpSize.width * 0.9,\nheight: vpSize.height * 0.95\n});\n// To handle window resizing you would have to hook onto onWindowResize.\n\n@deprecated 2.0.0\n@return {Object} Object describing `width` and `height`:\n@return {Number} return.width\n@return {Number} return.height", "docstring_tokens": ["Returns", "the", "dimensions", "of", "the", "element", "available", "to", "lay", "content", "out", "in", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/dom/Element.style.js#L885-L905", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "clearBuffer", "original_string": "function clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}", "language": "javascript", "code": "function clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}", "code_tokens": ["function", "clearBuffer", "(", "stream", ",", "state", ")", "{", "state", ".", "bufferProcessing", "=", "true", ";", "var", "entry", "=", "state", ".", "bufferedRequest", ";", "if", "(", "stream", ".", "_writev", "&&", "entry", "&&", "entry", ".", "next", ")", "{", "// Fast case, write everything using _writev()", "var", "l", "=", "state", ".", "bufferedRequestCount", ";", "var", "buffer", "=", "new", "Array", "(", "l", ")", ";", "var", "holder", "=", "state", ".", "corkedRequestsFree", ";", "holder", ".", "entry", "=", "entry", ";", "var", "count", "=", "0", ";", "var", "allBuffers", "=", "true", ";", "while", "(", "entry", ")", "{", "buffer", "[", "count", "]", "=", "entry", ";", "if", "(", "!", "entry", ".", "isBuf", ")", "allBuffers", "=", "false", ";", "entry", "=", "entry", ".", "next", ";", "count", "+=", "1", ";", "}", "buffer", ".", "allBuffers", "=", "allBuffers", ";", "doWrite", "(", "stream", ",", "state", ",", "true", ",", "state", ".", "length", ",", "buffer", ",", "''", ",", "holder", ".", "finish", ")", ";", "// doWrite is almost always async, defer these to save a bit of time", "// as the hot path ends with doWrite", "state", ".", "pendingcb", "++", ";", "state", ".", "lastBufferedRequest", "=", "null", ";", "if", "(", "holder", ".", "next", ")", "{", "state", ".", "corkedRequestsFree", "=", "holder", ".", "next", ";", "holder", ".", "next", "=", "null", ";", "}", "else", "{", "state", ".", "corkedRequestsFree", "=", "new", "CorkedRequest", "(", "state", ")", ";", "}", "state", ".", "bufferedRequestCount", "=", "0", ";", "}", "else", "{", "// Slow case, write chunks one-by-one", "while", "(", "entry", ")", "{", "var", "chunk", "=", "entry", ".", "chunk", ";", "var", "encoding", "=", "entry", ".", "encoding", ";", "var", "cb", "=", "entry", ".", "callback", ";", "var", "len", "=", "state", ".", "objectMode", "?", "1", ":", "chunk", ".", "length", ";", "doWrite", "(", "stream", ",", "state", ",", "false", ",", "len", ",", "chunk", ",", "encoding", ",", "cb", ")", ";", "entry", "=", "entry", ".", "next", ";", "state", ".", "bufferedRequestCount", "--", ";", "// if we didn't call the onwrite immediately, then", "// it means that we need to wait until it does.", "// also, that means that the chunk and cb are currently", "// being processed, so move the buffer counter past them.", "if", "(", "state", ".", "writing", ")", "{", "break", ";", "}", "}", "if", "(", "entry", "===", "null", ")", "state", ".", "lastBufferedRequest", "=", "null", ";", "}", "state", ".", "bufferedRequest", "=", "entry", ";", "state", ".", "bufferProcessing", "=", "false", ";", "}"], "docstring": "if there's something in the buffer waiting, then process it", "docstring_tokens": ["if", "there", "s", "something", "in", "the", "buffer", "waiting", "then", "process", "it"], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L60767-L60826", "partition": "test"}
{"repo": "yola/gulp-static-i18n", "path": "index.js", "func_name": "gulpStaticI18n", "original_string": "function gulpStaticI18n(options) {\n  return through.obj(function(target, encoding, cb) {\n    var stream = this;\n    var build = new StaticI18n(target, options, stream);\n    build.translate(cb);\n  });\n}", "language": "javascript", "code": "function gulpStaticI18n(options) {\n  return through.obj(function(target, encoding, cb) {\n    var stream = this;\n    var build = new StaticI18n(target, options, stream);\n    build.translate(cb);\n  });\n}", "code_tokens": ["function", "gulpStaticI18n", "(", "options", ")", "{", "return", "through", ".", "obj", "(", "function", "(", "target", ",", "encoding", ",", "cb", ")", "{", "var", "stream", "=", "this", ";", "var", "build", "=", "new", "StaticI18n", "(", "target", ",", "options", ",", "stream", ")", ";", "build", ".", "translate", "(", "cb", ")", ";", "}", ")", ";", "}"], "docstring": "plugin wrapper so streams can pipe to it.", "docstring_tokens": ["plugin", "wrapper", "so", "streams", "can", "pipe", "to", "it", "."], "sha": "a8d1d654047152a56690f5eb0b536177ec000517", "url": "https://github.com/yola/gulp-static-i18n/blob/a8d1d654047152a56690f5eb0b536177ec000517/index.js#L90-L96", "partition": "test"}
{"repo": "carrot/roots-cms-client", "path": "assets/js/vendor/backbone-relational.js", "func_name": "", "original_string": "function( collection ) {\n\t\t\tif ( this.related ) {\n\t\t\t\tthis.stopListening( this.related );\n\t\t\t}\n\n\t\t\tif ( !collection || !( collection instanceof Backbone.Collection ) ) {\n\t\t\t\tvar options = _.isFunction( this.options.collectionOptions ) ?\n\t\t\t\t\tthis.options.collectionOptions( this.instance ) : this.options.collectionOptions;\n\n\t\t\t\tcollection = new this.collectionType( null, options );\n\t\t\t}\n\n\t\t\tcollection.model = this.relatedModel;\n\n\t\t\tif ( this.options.collectionKey ) {\n\t\t\t\tvar key = this.options.collectionKey === true ? this.options.reverseRelation.key : this.options.collectionKey;\n\n\t\t\t\tif ( collection[ key ] && collection[ key ] !== this.instance ) {\n\t\t\t\t\tif ( Backbone.Relational.showWarnings && typeof console !== 'undefined' ) {\n\t\t\t\t\t\tconsole.warn( 'Relation=%o; collectionKey=%s already exists on collection=%o', this, key, this.options.collectionKey );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( key ) {\n\t\t\t\t\tcollection[ key ] = this.instance;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.listenTo( collection, 'relational:add', this.handleAddition )\n\t\t\t\t.listenTo( collection, 'relational:remove', this.handleRemoval )\n\t\t\t\t.listenTo( collection, 'relational:reset', this.handleReset );\n\n\t\t\treturn collection;\n\t\t}", "language": "javascript", "code": "function( collection ) {\n\t\t\tif ( this.related ) {\n\t\t\t\tthis.stopListening( this.related );\n\t\t\t}\n\n\t\t\tif ( !collection || !( collection instanceof Backbone.Collection ) ) {\n\t\t\t\tvar options = _.isFunction( this.options.collectionOptions ) ?\n\t\t\t\t\tthis.options.collectionOptions( this.instance ) : this.options.collectionOptions;\n\n\t\t\t\tcollection = new this.collectionType( null, options );\n\t\t\t}\n\n\t\t\tcollection.model = this.relatedModel;\n\n\t\t\tif ( this.options.collectionKey ) {\n\t\t\t\tvar key = this.options.collectionKey === true ? this.options.reverseRelation.key : this.options.collectionKey;\n\n\t\t\t\tif ( collection[ key ] && collection[ key ] !== this.instance ) {\n\t\t\t\t\tif ( Backbone.Relational.showWarnings && typeof console !== 'undefined' ) {\n\t\t\t\t\t\tconsole.warn( 'Relation=%o; collectionKey=%s already exists on collection=%o', this, key, this.options.collectionKey );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( key ) {\n\t\t\t\t\tcollection[ key ] = this.instance;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.listenTo( collection, 'relational:add', this.handleAddition )\n\t\t\t\t.listenTo( collection, 'relational:remove', this.handleRemoval )\n\t\t\t\t.listenTo( collection, 'relational:reset', this.handleReset );\n\n\t\t\treturn collection;\n\t\t}", "code_tokens": ["function", "(", "collection", ")", "{", "if", "(", "this", ".", "related", ")", "{", "this", ".", "stopListening", "(", "this", ".", "related", ")", ";", "}", "if", "(", "!", "collection", "||", "!", "(", "collection", "instanceof", "Backbone", ".", "Collection", ")", ")", "{", "var", "options", "=", "_", ".", "isFunction", "(", "this", ".", "options", ".", "collectionOptions", ")", "?", "this", ".", "options", ".", "collectionOptions", "(", "this", ".", "instance", ")", ":", "this", ".", "options", ".", "collectionOptions", ";", "collection", "=", "new", "this", ".", "collectionType", "(", "null", ",", "options", ")", ";", "}", "collection", ".", "model", "=", "this", ".", "relatedModel", ";", "if", "(", "this", ".", "options", ".", "collectionKey", ")", "{", "var", "key", "=", "this", ".", "options", ".", "collectionKey", "===", "true", "?", "this", ".", "options", ".", "reverseRelation", ".", "key", ":", "this", ".", "options", ".", "collectionKey", ";", "if", "(", "collection", "[", "key", "]", "&&", "collection", "[", "key", "]", "!==", "this", ".", "instance", ")", "{", "if", "(", "Backbone", ".", "Relational", ".", "showWarnings", "&&", "typeof", "console", "!==", "'undefined'", ")", "{", "console", ".", "warn", "(", "'Relation=%o; collectionKey=%s already exists on collection=%o'", ",", "this", ",", "key", ",", "this", ".", "options", ".", "collectionKey", ")", ";", "}", "}", "else", "if", "(", "key", ")", "{", "collection", "[", "key", "]", "=", "this", ".", "instance", ";", "}", "}", "this", ".", "listenTo", "(", "collection", ",", "'relational:add'", ",", "this", ".", "handleAddition", ")", ".", "listenTo", "(", "collection", ",", "'relational:remove'", ",", "this", ".", "handleRemoval", ")", ".", "listenTo", "(", "collection", ",", "'relational:reset'", ",", "this", ".", "handleReset", ")", ";", "return", "collection", ";", "}"], "docstring": "Bind events and setup collectionKeys for a collection that is to be used as the backing store for a HasMany.\nIf no 'collection' is supplied, a new collection will be created of the specified 'collectionType' option.\n@param {Backbone.Collection} [collection]\n@return {Backbone.Collection}", "docstring_tokens": ["Bind", "events", "and", "setup", "collectionKeys", "for", "a", "collection", "that", "is", "to", "be", "used", "as", "the", "backing", "store", "for", "a", "HasMany", ".", "If", "no", "collection", "is", "supplied", "a", "new", "collection", "will", "be", "created", "of", "the", "specified", "collectionType", "option", "."], "sha": "57d5281eb03b9f8377d9478da3742f5a74653c17", "url": "https://github.com/carrot/roots-cms-client/blob/57d5281eb03b9f8377d9478da3742f5a74653c17/assets/js/vendor/backbone-relational.js#L873-L905", "partition": "test"}
{"repo": "mpetroff/pannellum", "path": "src/js/libpannellum.js", "func_name": "checkInView", "original_string": "function checkInView(m, v) {\n        var vpp = applyRotPerspToVec(m, v);\n        var winX = vpp[0]*vpp[3];\n        var winY = vpp[1]*vpp[3];\n        var winZ = vpp[2]*vpp[3];\n        var ret = [0, 0, 0];\n        \n        if ( winX < -1 )\n            ret[0] = -1;\n        if ( winX > 1 )\n            ret[0] = 1;\n        if ( winY < -1 )\n            ret[1] = -1;\n        if ( winY > 1 )\n            ret[1] = 1;\n        if ( winZ < -1 || winZ > 1 )\n            ret[2] = 1;\n        return ret;\n    }", "language": "javascript", "code": "function checkInView(m, v) {\n        var vpp = applyRotPerspToVec(m, v);\n        var winX = vpp[0]*vpp[3];\n        var winY = vpp[1]*vpp[3];\n        var winZ = vpp[2]*vpp[3];\n        var ret = [0, 0, 0];\n        \n        if ( winX < -1 )\n            ret[0] = -1;\n        if ( winX > 1 )\n            ret[0] = 1;\n        if ( winY < -1 )\n            ret[1] = -1;\n        if ( winY > 1 )\n            ret[1] = 1;\n        if ( winZ < -1 || winZ > 1 )\n            ret[2] = 1;\n        return ret;\n    }", "code_tokens": ["function", "checkInView", "(", "m", ",", "v", ")", "{", "var", "vpp", "=", "applyRotPerspToVec", "(", "m", ",", "v", ")", ";", "var", "winX", "=", "vpp", "[", "0", "]", "*", "vpp", "[", "3", "]", ";", "var", "winY", "=", "vpp", "[", "1", "]", "*", "vpp", "[", "3", "]", ";", "var", "winZ", "=", "vpp", "[", "2", "]", "*", "vpp", "[", "3", "]", ";", "var", "ret", "=", "[", "0", ",", "0", ",", "0", "]", ";", "if", "(", "winX", "<", "-", "1", ")", "ret", "[", "0", "]", "=", "-", "1", ";", "if", "(", "winX", ">", "1", ")", "ret", "[", "0", "]", "=", "1", ";", "if", "(", "winY", "<", "-", "1", ")", "ret", "[", "1", "]", "=", "-", "1", ";", "if", "(", "winY", ">", "1", ")", "ret", "[", "1", "]", "=", "1", ";", "if", "(", "winZ", "<", "-", "1", "||", "winZ", ">", "1", ")", "ret", "[", "2", "]", "=", "1", ";", "return", "ret", ";", "}"], "docstring": "Checks if a vertex is visible.\n@private\n@param {number[]} m - Rotated perspective matrix.\n@param {number[]} v - Input vertex.\n@returns {number} 1 or -1 if the vertex is or is not visible,\nrespectively.", "docstring_tokens": ["Checks", "if", "a", "vertex", "is", "visible", "."], "sha": "59893bcea4629be059ad3e59c3fa5bde438d292b", "url": "https://github.com/mpetroff/pannellum/blob/59893bcea4629be059ad3e59c3fa5bde438d292b/src/js/libpannellum.js#L1264-L1282", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/collections/Table/TableHeaderCell.js", "func_name": "TableHeaderCell", "original_string": "function TableHeaderCell(props) {\n  const { as, className, sorted } = props\n  const classes = cx(useValueAndKey(sorted, 'sorted'), className)\n  const rest = getUnhandledProps(TableHeaderCell, props)\n\n  return <TableCell {...rest} as={as} className={classes} />\n}", "language": "javascript", "code": "function TableHeaderCell(props) {\n  const { as, className, sorted } = props\n  const classes = cx(useValueAndKey(sorted, 'sorted'), className)\n  const rest = getUnhandledProps(TableHeaderCell, props)\n\n  return <TableCell {...rest} as={as} className={classes} />\n}", "code_tokens": ["function", "TableHeaderCell", "(", "props", ")", "{", "const", "{", "as", ",", "className", ",", "sorted", "}", "=", "props", "const", "classes", "=", "cx", "(", "useValueAndKey", "(", "sorted", ",", "'sorted'", ")", ",", "className", ")", "const", "rest", "=", "getUnhandledProps", "(", "TableHeaderCell", ",", "props", ")", "return", "<", "TableCell", "{", "...", "rest", "}", "as", "=", "{", "as", "}", "className", "=", "{", "classes", "}", "/", ">", "}"], "docstring": "A table can have a header cell.", "docstring_tokens": ["A", "table", "can", "have", "a", "header", "cell", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/collections/Table/TableHeaderCell.js#L11-L17", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "reinterpretAsAssignmentBindingPattern", "original_string": "function reinterpretAsAssignmentBindingPattern(expr) {\n            var i, len, property, element;\n    \n            if (expr.type === Syntax.ObjectExpression) {\n                expr.type = Syntax.ObjectPattern;\n                for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                    property = expr.properties[i];\n                    if (property.type === Syntax.SpreadProperty) {\n                        if (i < len - 1) {\n                            throwError({}, Messages.PropertyAfterSpreadProperty);\n                        }\n                        reinterpretAsAssignmentBindingPattern(property.argument);\n                    } else {\n                        if (property.kind !== 'init') {\n                            throwError({}, Messages.InvalidLHSInAssignment);\n                        }\n                        reinterpretAsAssignmentBindingPattern(property.value);\n                    }\n                }\n            } else if (expr.type === Syntax.ArrayExpression) {\n                expr.type = Syntax.ArrayPattern;\n                for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                    element = expr.elements[i];\n                    /* istanbul ignore else */\n                    if (element) {\n                        reinterpretAsAssignmentBindingPattern(element);\n                    }\n                }\n            } else if (expr.type === Syntax.Identifier) {\n                if (isRestrictedWord(expr.name)) {\n                    throwError({}, Messages.InvalidLHSInAssignment);\n                }\n            } else if (expr.type === Syntax.SpreadElement) {\n                reinterpretAsAssignmentBindingPattern(expr.argument);\n                if (expr.argument.type === Syntax.ObjectPattern) {\n                    throwError({}, Messages.ObjectPatternAsSpread);\n                }\n            } else {\n                /* istanbul ignore else */\n                if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {\n                    throwError({}, Messages.InvalidLHSInAssignment);\n                }\n            }\n        }", "language": "javascript", "code": "function reinterpretAsAssignmentBindingPattern(expr) {\n            var i, len, property, element;\n    \n            if (expr.type === Syntax.ObjectExpression) {\n                expr.type = Syntax.ObjectPattern;\n                for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                    property = expr.properties[i];\n                    if (property.type === Syntax.SpreadProperty) {\n                        if (i < len - 1) {\n                            throwError({}, Messages.PropertyAfterSpreadProperty);\n                        }\n                        reinterpretAsAssignmentBindingPattern(property.argument);\n                    } else {\n                        if (property.kind !== 'init') {\n                            throwError({}, Messages.InvalidLHSInAssignment);\n                        }\n                        reinterpretAsAssignmentBindingPattern(property.value);\n                    }\n                }\n            } else if (expr.type === Syntax.ArrayExpression) {\n                expr.type = Syntax.ArrayPattern;\n                for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                    element = expr.elements[i];\n                    /* istanbul ignore else */\n                    if (element) {\n                        reinterpretAsAssignmentBindingPattern(element);\n                    }\n                }\n            } else if (expr.type === Syntax.Identifier) {\n                if (isRestrictedWord(expr.name)) {\n                    throwError({}, Messages.InvalidLHSInAssignment);\n                }\n            } else if (expr.type === Syntax.SpreadElement) {\n                reinterpretAsAssignmentBindingPattern(expr.argument);\n                if (expr.argument.type === Syntax.ObjectPattern) {\n                    throwError({}, Messages.ObjectPatternAsSpread);\n                }\n            } else {\n                /* istanbul ignore else */\n                if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {\n                    throwError({}, Messages.InvalidLHSInAssignment);\n                }\n            }\n        }", "code_tokens": ["function", "reinterpretAsAssignmentBindingPattern", "(", "expr", ")", "{", "var", "i", ",", "len", ",", "property", ",", "element", ";", "if", "(", "expr", ".", "type", "===", "Syntax", ".", "ObjectExpression", ")", "{", "expr", ".", "type", "=", "Syntax", ".", "ObjectPattern", ";", "for", "(", "i", "=", "0", ",", "len", "=", "expr", ".", "properties", ".", "length", ";", "i", "<", "len", ";", "i", "+=", "1", ")", "{", "property", "=", "expr", ".", "properties", "[", "i", "]", ";", "if", "(", "property", ".", "type", "===", "Syntax", ".", "SpreadProperty", ")", "{", "if", "(", "i", "<", "len", "-", "1", ")", "{", "throwError", "(", "{", "}", ",", "Messages", ".", "PropertyAfterSpreadProperty", ")", ";", "}", "reinterpretAsAssignmentBindingPattern", "(", "property", ".", "argument", ")", ";", "}", "else", "{", "if", "(", "property", ".", "kind", "!==", "'init'", ")", "{", "throwError", "(", "{", "}", ",", "Messages", ".", "InvalidLHSInAssignment", ")", ";", "}", "reinterpretAsAssignmentBindingPattern", "(", "property", ".", "value", ")", ";", "}", "}", "}", "else", "if", "(", "expr", ".", "type", "===", "Syntax", ".", "ArrayExpression", ")", "{", "expr", ".", "type", "=", "Syntax", ".", "ArrayPattern", ";", "for", "(", "i", "=", "0", ",", "len", "=", "expr", ".", "elements", ".", "length", ";", "i", "<", "len", ";", "i", "+=", "1", ")", "{", "element", "=", "expr", ".", "elements", "[", "i", "]", ";", "/* istanbul ignore else */", "if", "(", "element", ")", "{", "reinterpretAsAssignmentBindingPattern", "(", "element", ")", ";", "}", "}", "}", "else", "if", "(", "expr", ".", "type", "===", "Syntax", ".", "Identifier", ")", "{", "if", "(", "isRestrictedWord", "(", "expr", ".", "name", ")", ")", "{", "throwError", "(", "{", "}", ",", "Messages", ".", "InvalidLHSInAssignment", ")", ";", "}", "}", "else", "if", "(", "expr", ".", "type", "===", "Syntax", ".", "SpreadElement", ")", "{", "reinterpretAsAssignmentBindingPattern", "(", "expr", ".", "argument", ")", ";", "if", "(", "expr", ".", "argument", ".", "type", "===", "Syntax", ".", "ObjectPattern", ")", "{", "throwError", "(", "{", "}", ",", "Messages", ".", "ObjectPatternAsSpread", ")", ";", "}", "}", "else", "{", "/* istanbul ignore else */", "if", "(", "expr", ".", "type", "!==", "Syntax", ".", "MemberExpression", "&&", "expr", ".", "type", "!==", "Syntax", ".", "CallExpression", "&&", "expr", ".", "type", "!==", "Syntax", ".", "NewExpression", ")", "{", "throwError", "(", "{", "}", ",", "Messages", ".", "InvalidLHSInAssignment", ")", ";", "}", "}", "}"], "docstring": "11.13 Assignment Operators 12.14.5 AssignmentPattern", "docstring_tokens": ["11", ".", "13", "Assignment", "Operators", "12", ".", "14", ".", "5", "AssignmentPattern"], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L10791-L10834", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(data){\n    if (data.links) {\n      var links = data.links;\n\n      for (var link in links) {\n        var camelizedLink = Ember.String.camelize(link);\n\n        if (camelizedLink !== link) {\n          links[camelizedLink] = links[link];\n          delete links[link];\n        }\n      }\n    }\n  }", "language": "javascript", "code": "function(data){\n    if (data.links) {\n      var links = data.links;\n\n      for (var link in links) {\n        var camelizedLink = Ember.String.camelize(link);\n\n        if (camelizedLink !== link) {\n          links[camelizedLink] = links[link];\n          delete links[link];\n        }\n      }\n    }\n  }", "code_tokens": ["function", "(", "data", ")", "{", "if", "(", "data", ".", "links", ")", "{", "var", "links", "=", "data", ".", "links", ";", "for", "(", "var", "link", "in", "links", ")", "{", "var", "camelizedLink", "=", "Ember", ".", "String", ".", "camelize", "(", "link", ")", ";", "if", "(", "camelizedLink", "!==", "link", ")", "{", "links", "[", "camelizedLink", "]", "=", "links", "[", "link", "]", ";", "delete", "links", "[", "link", "]", ";", "}", "}", "}", "}"], "docstring": "Convert `snake_cased` links  to `camelCase`\n\n@method normalizeLinks\n@param {Object} hash", "docstring_tokens": ["Convert", "snake_cased", "links", "to", "camelCase"], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L10208-L10221", "partition": "test"}
{"repo": "localnerve/html-snapshots", "path": "lib/async/exists.js", "func_name": "pathExists", "original_string": "function pathExists (path, options) {\n  options = options || {\n    returnFile: false\n  };\n\n  // Defaults to F_OK\n  return nodeCall(fs.access, path)\n    .then(function () {\n      return options.returnFile ? path : true;\n    })\n    .catch(function () {\n      if (fs.existsSync(path)) {\n        return options.returnFile ? path : true;\n      }\n      return false;\n    });\n}", "language": "javascript", "code": "function pathExists (path, options) {\n  options = options || {\n    returnFile: false\n  };\n\n  // Defaults to F_OK\n  return nodeCall(fs.access, path)\n    .then(function () {\n      return options.returnFile ? path : true;\n    })\n    .catch(function () {\n      if (fs.existsSync(path)) {\n        return options.returnFile ? path : true;\n      }\n      return false;\n    });\n}", "code_tokens": ["function", "pathExists", "(", "path", ",", "options", ")", "{", "options", "=", "options", "||", "{", "returnFile", ":", "false", "}", ";", "// Defaults to F_OK", "return", "nodeCall", "(", "fs", ".", "access", ",", "path", ")", ".", "then", "(", "function", "(", ")", "{", "return", "options", ".", "returnFile", "?", "path", ":", "true", ";", "}", ")", ".", "catch", "(", "function", "(", ")", "{", "if", "(", "fs", ".", "existsSync", "(", "path", ")", ")", "{", "return", "options", ".", "returnFile", "?", "path", ":", "true", ";", "}", "return", "false", ";", "}", ")", ";", "}"], "docstring": "Check if a path exists.\n\n@param {String} path - The full path to the file to check.\n@param {Object} [options] - fileExists options.\n@param {Boolean} [options.returnFile] - If true, resolve to input filename on\nsuccess. Otherwise, resolve to boolean. Defaults to false (boolean).\n@returns {Promise} Resolves to true (or file) if exists, false otherwise.", "docstring_tokens": ["Check", "if", "a", "path", "exists", "."], "sha": "63e829b234a8fa1399da1f7347a7fb3463e862a8", "url": "https://github.com/localnerve/html-snapshots/blob/63e829b234a8fa1399da1f7347a7fb3463e862a8/lib/async/exists.js#L24-L40", "partition": "test"}
{"repo": "standardhealth/shr-json-schema-export", "path": "lib/export.js", "func_name": "makeRef", "original_string": "function makeRef(id, enclosingNamespace, baseSchemaURL) {\n  if (id.namespace === enclosingNamespace.namespace) {\n    return '#/definitions/' + id.name;\n  } else {\n    return makeShrDefinitionURL(id, baseSchemaURL);\n  }\n}", "language": "javascript", "code": "function makeRef(id, enclosingNamespace, baseSchemaURL) {\n  if (id.namespace === enclosingNamespace.namespace) {\n    return '#/definitions/' + id.name;\n  } else {\n    return makeShrDefinitionURL(id, baseSchemaURL);\n  }\n}", "code_tokens": ["function", "makeRef", "(", "id", ",", "enclosingNamespace", ",", "baseSchemaURL", ")", "{", "if", "(", "id", ".", "namespace", "===", "enclosingNamespace", ".", "namespace", ")", "{", "return", "'#/definitions/'", "+", "id", ".", "name", ";", "}", "else", "{", "return", "makeShrDefinitionURL", "(", "id", ",", "baseSchemaURL", ")", ";", "}", "}"], "docstring": "Create a JSON Schema reference to the specified type.\n\n@param {Identifier} id - the target type.\n@param {Namespace} enclosingNamespace - the current namespace that is being evaluated.\n@param {string} baseSchemaURL - the root URL for the schema identifier\n@returns {string} - a JSON Schema reference to the target type.", "docstring_tokens": ["Create", "a", "JSON", "Schema", "reference", "to", "the", "specified", "type", "."], "sha": "7f6d0994185028edc3cf930e233592f5fd54c57d", "url": "https://github.com/standardhealth/shr-json-schema-export/blob/7f6d0994185028edc3cf930e233592f5fd54c57d/lib/export.js#L770-L776", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "lib/reflect.js", "func_name": "", "original_string": "function(trapName) {\n    var trap = this.handler[trapName];\n    if (trap === undefined) {\n      // the trap was not defined,\n      // perform the default forwarding behavior\n      return undefined;\n    }\n\n    if (typeof trap !== \"function\") {\n      throw new TypeError(trapName + \" trap is not callable: \"+trap);\n    }\n\n    return trap;\n  }", "language": "javascript", "code": "function(trapName) {\n    var trap = this.handler[trapName];\n    if (trap === undefined) {\n      // the trap was not defined,\n      // perform the default forwarding behavior\n      return undefined;\n    }\n\n    if (typeof trap !== \"function\") {\n      throw new TypeError(trapName + \" trap is not callable: \"+trap);\n    }\n\n    return trap;\n  }", "code_tokens": ["function", "(", "trapName", ")", "{", "var", "trap", "=", "this", ".", "handler", "[", "trapName", "]", ";", "if", "(", "trap", "===", "undefined", ")", "{", "// the trap was not defined,", "// perform the default forwarding behavior", "return", "undefined", ";", "}", "if", "(", "typeof", "trap", "!==", "\"function\"", ")", "{", "throw", "new", "TypeError", "(", "trapName", "+", "\" trap is not callable: \"", "+", "trap", ")", ";", "}", "return", "trap", ";", "}"], "docstring": "If getTrap returns undefined, the caller should perform the\ndefault forwarding behavior.\nIf getTrap returns normally otherwise, the return value\nwill be a callable trap function. When calling the trap function,\nthe caller is responsible for binding its |this| to |this.handler|.", "docstring_tokens": ["If", "getTrap", "returns", "undefined", "the", "caller", "should", "perform", "the", "default", "forwarding", "behavior", ".", "If", "getTrap", "returns", "normally", "otherwise", "the", "return", "value", "will", "be", "a", "callable", "trap", "function", ".", "When", "calling", "the", "trap", "function", "the", "caller", "is", "responsible", "for", "binding", "its", "|this|", "to", "|this", ".", "handler|", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/lib/reflect.js#L471-L484", "partition": "test"}
{"repo": "phphe/vue-draggable-nested-tree", "path": "dist/vue-draggable-nested-tree.es.js", "func_name": "pure", "original_string": "function pure(node, withChildren, after) {\n      var _this2 = this;\n\n      var t = assign$1({}, node);\n\n      delete t._id;\n      delete t.parent;\n      delete t.children;\n      delete t.open;\n      delete t.active;\n      delete t.style;\n      delete t.class;\n      delete t.innerStyle;\n      delete t.innerClass;\n      delete t.innerBackStyle;\n      delete t.innerBackClass;\n\n      var _arr = keys$1(t);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n\n        if (key[0] === '_') {\n          delete t[key];\n        }\n      }\n\n      if (withChildren && node.children) {\n        t.children = node.children.slice();\n        t.children.forEach(function (v, k) {\n          t.children[k] = _this2.pure(v, withChildren);\n        });\n      }\n\n      if (after) {\n        return after(t, node) || t;\n      }\n\n      return t;\n    }", "language": "javascript", "code": "function pure(node, withChildren, after) {\n      var _this2 = this;\n\n      var t = assign$1({}, node);\n\n      delete t._id;\n      delete t.parent;\n      delete t.children;\n      delete t.open;\n      delete t.active;\n      delete t.style;\n      delete t.class;\n      delete t.innerStyle;\n      delete t.innerClass;\n      delete t.innerBackStyle;\n      delete t.innerBackClass;\n\n      var _arr = keys$1(t);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n\n        if (key[0] === '_') {\n          delete t[key];\n        }\n      }\n\n      if (withChildren && node.children) {\n        t.children = node.children.slice();\n        t.children.forEach(function (v, k) {\n          t.children[k] = _this2.pure(v, withChildren);\n        });\n      }\n\n      if (after) {\n        return after(t, node) || t;\n      }\n\n      return t;\n    }", "code_tokens": ["function", "pure", "(", "node", ",", "withChildren", ",", "after", ")", "{", "var", "_this2", "=", "this", ";", "var", "t", "=", "assign$1", "(", "{", "}", ",", "node", ")", ";", "delete", "t", ".", "_id", ";", "delete", "t", ".", "parent", ";", "delete", "t", ".", "children", ";", "delete", "t", ".", "open", ";", "delete", "t", ".", "active", ";", "delete", "t", ".", "style", ";", "delete", "t", ".", "class", ";", "delete", "t", ".", "innerStyle", ";", "delete", "t", ".", "innerClass", ";", "delete", "t", ".", "innerBackStyle", ";", "delete", "t", ".", "innerBackClass", ";", "var", "_arr", "=", "keys$1", "(", "t", ")", ";", "for", "(", "var", "_i", "=", "0", ";", "_i", "<", "_arr", ".", "length", ";", "_i", "++", ")", "{", "var", "key", "=", "_arr", "[", "_i", "]", ";", "if", "(", "key", "[", "0", "]", "===", "'_'", ")", "{", "delete", "t", "[", "key", "]", ";", "}", "}", "if", "(", "withChildren", "&&", "node", ".", "children", ")", "{", "t", ".", "children", "=", "node", ".", "children", ".", "slice", "(", ")", ";", "t", ".", "children", ".", "forEach", "(", "function", "(", "v", ",", "k", ")", "{", "t", ".", "children", "[", "k", "]", "=", "_this2", ".", "pure", "(", "v", ",", "withChildren", ")", ";", "}", ")", ";", "}", "if", "(", "after", ")", "{", "return", "after", "(", "t", ",", "node", ")", "||", "t", ";", "}", "return", "t", ";", "}"], "docstring": "pure node self", "docstring_tokens": ["pure", "node", "self"], "sha": "094b12954d55d449cdebbcbc00c6456fed3c99ce", "url": "https://github.com/phphe/vue-draggable-nested-tree/blob/094b12954d55d449cdebbcbc00c6456fed3c99ce/dist/vue-draggable-nested-tree.es.js#L225-L264", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/device/sqlite/Sencha.js", "func_name": "", "original_string": "function(index) {\n                        if (index < this.getLength()) {\n                            var item = {};\n                            var row = this.rows[index];\n                            this.names.forEach(function(name, index) {\n                                item[name] = row[index];\n                            });\n\n                            return item;\n                        }\n\n                        return null;\n                    }", "language": "javascript", "code": "function(index) {\n                        if (index < this.getLength()) {\n                            var item = {};\n                            var row = this.rows[index];\n                            this.names.forEach(function(name, index) {\n                                item[name] = row[index];\n                            });\n\n                            return item;\n                        }\n\n                        return null;\n                    }", "code_tokens": ["function", "(", "index", ")", "{", "if", "(", "index", "<", "this", ".", "getLength", "(", ")", ")", "{", "var", "item", "=", "{", "}", ";", "var", "row", "=", "this", ".", "rows", "[", "index", "]", ";", "this", ".", "names", ".", "forEach", "(", "function", "(", "name", ",", "index", ")", "{", "item", "[", "name", "]", "=", "row", "[", "index", "]", ";", "}", ")", ";", "return", "item", ";", "}", "return", "null", ";", "}"], "docstring": "Returns a row at specified index returned by the SQL statement.\nIf there is no such row, returns null.\n\n@param {Number} index This is required.\nThe index of a row.\n\n@return {Object}\nThe row.", "docstring_tokens": ["Returns", "a", "row", "at", "specified", "index", "returned", "by", "the", "SQL", "statement", ".", "If", "there", "is", "no", "such", "row", "returns", "null", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/device/sqlite/Sencha.js#L490-L502", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "hasData", "original_string": "function hasData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return false;\n  }\n\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}", "language": "javascript", "code": "function hasData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return false;\n  }\n\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}", "code_tokens": ["function", "hasData", "(", "el", ")", "{", "var", "id", "=", "el", "[", "elIdAttr", "]", ";", "if", "(", "!", "id", ")", "{", "return", "false", ";", "}", "return", "!", "!", "Object", ".", "getOwnPropertyNames", "(", "elData", "[", "id", "]", ")", ".", "length", ";", "}"], "docstring": "Returns whether or not an element has cached data\n\n@param {Element} el\nCheck if this element has cached data.\n\n@return {boolean}\n- True if the DOM element has cached data.\n- False otherwise.", "docstring_tokens": ["Returns", "whether", "or", "not", "an", "element", "has", "cached", "data"], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L1491-L1499", "partition": "test"}
{"repo": "unfoldingWord-dev/node-resource-container", "path": "lib/main.js", "func_name": "", "original_string": "function () {\n            let dir = path.join(container_directory, content_dir);\n            return fs.readdirSync(dir).filter(function(file) {\n                try {\n                    return fs.statSync(file).isDirectory();\n                } catch (err) {\n                    console.log(err);\n                    return false;\n                }\n            });\n        }", "language": "javascript", "code": "function () {\n            let dir = path.join(container_directory, content_dir);\n            return fs.readdirSync(dir).filter(function(file) {\n                try {\n                    return fs.statSync(file).isDirectory();\n                } catch (err) {\n                    console.log(err);\n                    return false;\n                }\n            });\n        }", "code_tokens": ["function", "(", ")", "{", "let", "dir", "=", "path", ".", "join", "(", "container_directory", ",", "content_dir", ")", ";", "return", "fs", ".", "readdirSync", "(", "dir", ")", ".", "filter", "(", "function", "(", "file", ")", "{", "try", "{", "return", "fs", ".", "statSync", "(", "file", ")", ".", "isDirectory", "(", ")", ";", "}", "catch", "(", "err", ")", "{", "console", ".", "log", "(", "err", ")", ";", "return", "false", ";", "}", "}", ")", ";", "}"], "docstring": "Returns an array of chapters in this resource container", "docstring_tokens": ["Returns", "an", "array", "of", "chapters", "in", "this", "resource", "container"], "sha": "20c4b7bfd2fa3f397ee7e0e743567822912c305b", "url": "https://github.com/unfoldingWord-dev/node-resource-container/blob/20c4b7bfd2fa3f397ee7e0e743567822912c305b/lib/main.js#L90-L100", "partition": "test"}
{"repo": "daliwali/simulacra", "path": "lib/process_nodes.js", "func_name": "matchNodes", "original_string": "function matchNodes (scope, node, def) {\n  var document = scope ? scope.document : window.document\n  var treeWalker = document.createTreeWalker(\n    node, showAll, acceptNode, false)\n  var nodes = []\n  var i, j, key, currentNode, childWalker\n  var nodeIndex = 0\n\n  // This offset is a bit tricky, it's used to determine the index of the\n  // marker in the processed node, which depends on whether comment nodes\n  // are used and the count of child nodes.\n  var offset = processNodes.useCommentNode ? 1 : 0\n\n  for (key in def) nodes.push(def[key][0])\n\n  while (treeWalker.nextNode() && nodes.length) {\n    for (i = 0, j = nodes.length; i < j; i++) {\n      currentNode = nodes[i]\n      if (treeWalker.currentNode.isEqualNode(currentNode)) {\n        Object.defineProperty(currentNode, matchedNodeKey, {\n          value: {\n            index: nodeIndex + offset,\n            node: treeWalker.currentNode\n          }\n        })\n        if (processNodes.useCommentNode) offset++\n        childWalker = document.createTreeWalker(\n          currentNode, showAll, acceptNode, false)\n        while (childWalker.nextNode()) offset--\n        nodes.splice(i, 1)\n        break\n      }\n    }\n\n    nodeIndex++\n  }\n}", "language": "javascript", "code": "function matchNodes (scope, node, def) {\n  var document = scope ? scope.document : window.document\n  var treeWalker = document.createTreeWalker(\n    node, showAll, acceptNode, false)\n  var nodes = []\n  var i, j, key, currentNode, childWalker\n  var nodeIndex = 0\n\n  // This offset is a bit tricky, it's used to determine the index of the\n  // marker in the processed node, which depends on whether comment nodes\n  // are used and the count of child nodes.\n  var offset = processNodes.useCommentNode ? 1 : 0\n\n  for (key in def) nodes.push(def[key][0])\n\n  while (treeWalker.nextNode() && nodes.length) {\n    for (i = 0, j = nodes.length; i < j; i++) {\n      currentNode = nodes[i]\n      if (treeWalker.currentNode.isEqualNode(currentNode)) {\n        Object.defineProperty(currentNode, matchedNodeKey, {\n          value: {\n            index: nodeIndex + offset,\n            node: treeWalker.currentNode\n          }\n        })\n        if (processNodes.useCommentNode) offset++\n        childWalker = document.createTreeWalker(\n          currentNode, showAll, acceptNode, false)\n        while (childWalker.nextNode()) offset--\n        nodes.splice(i, 1)\n        break\n      }\n    }\n\n    nodeIndex++\n  }\n}", "code_tokens": ["function", "matchNodes", "(", "scope", ",", "node", ",", "def", ")", "{", "var", "document", "=", "scope", "?", "scope", ".", "document", ":", "window", ".", "document", "var", "treeWalker", "=", "document", ".", "createTreeWalker", "(", "node", ",", "showAll", ",", "acceptNode", ",", "false", ")", "var", "nodes", "=", "[", "]", "var", "i", ",", "j", ",", "key", ",", "currentNode", ",", "childWalker", "var", "nodeIndex", "=", "0", "// This offset is a bit tricky, it's used to determine the index of the", "// marker in the processed node, which depends on whether comment nodes", "// are used and the count of child nodes.", "var", "offset", "=", "processNodes", ".", "useCommentNode", "?", "1", ":", "0", "for", "(", "key", "in", "def", ")", "nodes", ".", "push", "(", "def", "[", "key", "]", "[", "0", "]", ")", "while", "(", "treeWalker", ".", "nextNode", "(", ")", "&&", "nodes", ".", "length", ")", "{", "for", "(", "i", "=", "0", ",", "j", "=", "nodes", ".", "length", ";", "i", "<", "j", ";", "i", "++", ")", "{", "currentNode", "=", "nodes", "[", "i", "]", "if", "(", "treeWalker", ".", "currentNode", ".", "isEqualNode", "(", "currentNode", ")", ")", "{", "Object", ".", "defineProperty", "(", "currentNode", ",", "matchedNodeKey", ",", "{", "value", ":", "{", "index", ":", "nodeIndex", "+", "offset", ",", "node", ":", "treeWalker", ".", "currentNode", "}", "}", ")", "if", "(", "processNodes", ".", "useCommentNode", ")", "offset", "++", "childWalker", "=", "document", ".", "createTreeWalker", "(", "currentNode", ",", "showAll", ",", "acceptNode", ",", "false", ")", "while", "(", "childWalker", ".", "nextNode", "(", ")", ")", "offset", "--", "nodes", ".", "splice", "(", "i", ",", "1", ")", "break", "}", "}", "nodeIndex", "++", "}", "}"], "docstring": "Internal function to find and set matching DOM nodes on cloned nodes.\n\n@param {*} [scope]\n@param {Node} node\n@param {Object} def", "docstring_tokens": ["Internal", "function", "to", "find", "and", "set", "matching", "DOM", "nodes", "on", "cloned", "nodes", "."], "sha": "b6bb7e2486f7722101f9e416ec345d49f3afa901", "url": "https://github.com/daliwali/simulacra/blob/b6bb7e2486f7722101f9e416ec345d49f3afa901/lib/process_nodes.js#L128-L164", "partition": "test"}
{"repo": "nodkz/babel-plugin-transform-relay-hot", "path": "index.js", "func_name": "watcherFn", "original_string": "function watcherFn(schemaFilepath, watchInterval, reinitBabelRelayPlugin, prevMtime) {\n  try {\n    let stats;\n    try {\n      stats = fs.statSync(schemaFilepath);\n    } catch (e) {\n      // no problem\n    }\n    if (stats) {\n      if (!prevMtime) prevMtime = stats.mtime;\n      if (stats.mtime.getTime() !== prevMtime.getTime()) {\n        prevMtime = stats.mtime;\n        reinitBabelRelayPlugin();\n      }\n    }\n    setTimeout(\n      () => {\n        watcherFn(schemaFilepath, watchInterval, reinitBabelRelayPlugin, prevMtime);\n      },\n      watchInterval\n    ).unref(); // fs.watch blocks babel from exit, so using `setTimeout` with `unref`\n  } catch (e) {\n    log(e);\n  }\n}", "language": "javascript", "code": "function watcherFn(schemaFilepath, watchInterval, reinitBabelRelayPlugin, prevMtime) {\n  try {\n    let stats;\n    try {\n      stats = fs.statSync(schemaFilepath);\n    } catch (e) {\n      // no problem\n    }\n    if (stats) {\n      if (!prevMtime) prevMtime = stats.mtime;\n      if (stats.mtime.getTime() !== prevMtime.getTime()) {\n        prevMtime = stats.mtime;\n        reinitBabelRelayPlugin();\n      }\n    }\n    setTimeout(\n      () => {\n        watcherFn(schemaFilepath, watchInterval, reinitBabelRelayPlugin, prevMtime);\n      },\n      watchInterval\n    ).unref(); // fs.watch blocks babel from exit, so using `setTimeout` with `unref`\n  } catch (e) {\n    log(e);\n  }\n}", "code_tokens": ["function", "watcherFn", "(", "schemaFilepath", ",", "watchInterval", ",", "reinitBabelRelayPlugin", ",", "prevMtime", ")", "{", "try", "{", "let", "stats", ";", "try", "{", "stats", "=", "fs", ".", "statSync", "(", "schemaFilepath", ")", ";", "}", "catch", "(", "e", ")", "{", "// no problem", "}", "if", "(", "stats", ")", "{", "if", "(", "!", "prevMtime", ")", "prevMtime", "=", "stats", ".", "mtime", ";", "if", "(", "stats", ".", "mtime", ".", "getTime", "(", ")", "!==", "prevMtime", ".", "getTime", "(", ")", ")", "{", "prevMtime", "=", "stats", ".", "mtime", ";", "reinitBabelRelayPlugin", "(", ")", ";", "}", "}", "setTimeout", "(", "(", ")", "=>", "{", "watcherFn", "(", "schemaFilepath", ",", "watchInterval", ",", "reinitBabelRelayPlugin", ",", "prevMtime", ")", ";", "}", ",", "watchInterval", ")", ".", "unref", "(", ")", ";", "// fs.watch blocks babel from exit, so using `setTimeout` with `unref`", "}", "catch", "(", "e", ")", "{", "log", "(", "e", ")", ";", "}", "}"], "docstring": "file changes watcher", "docstring_tokens": ["file", "changes", "watcher"], "sha": "493bbfac6a29bb63e18c91147a8eb7fc4e318b3f", "url": "https://github.com/nodkz/babel-plugin-transform-relay-hot/blob/493bbfac6a29bb63e18c91147a8eb7fc4e318b3f/index.js#L14-L38", "partition": "test"}
{"repo": "electerious/fsify", "path": "src/index.js", "func_name": "", "original_string": "function(structure = []) {\n\n\t\treturn new Promise((resolve, reject) => {\n\n\t\t\tif (Array.isArray(structure) === false) {\n\t\t\t\tthrow new Error(`'structure' must be an array`)\n\t\t\t}\n\n\t\t\tparseStructure(structure, opts.cwd)\n\t\t\t\t.then((parsedStructure) => writeStructure(parsedStructure))\n\t\t\t\t.then((parsedStructure) => binStructure(parsedStructure, bin, opts.persistent))\n\t\t\t\t.then(resolve, reject)\n\n\t\t})\n\n\t}", "language": "javascript", "code": "function(structure = []) {\n\n\t\treturn new Promise((resolve, reject) => {\n\n\t\t\tif (Array.isArray(structure) === false) {\n\t\t\t\tthrow new Error(`'structure' must be an array`)\n\t\t\t}\n\n\t\t\tparseStructure(structure, opts.cwd)\n\t\t\t\t.then((parsedStructure) => writeStructure(parsedStructure))\n\t\t\t\t.then((parsedStructure) => binStructure(parsedStructure, bin, opts.persistent))\n\t\t\t\t.then(resolve, reject)\n\n\t\t})\n\n\t}", "code_tokens": ["function", "(", "structure", "=", "[", "]", ")", "{", "return", "new", "Promise", "(", "(", "resolve", ",", "reject", ")", "=>", "{", "if", "(", "Array", ".", "isArray", "(", "structure", ")", "===", "false", ")", "{", "throw", "new", "Error", "(", "`", "`", ")", "}", "parseStructure", "(", "structure", ",", "opts", ".", "cwd", ")", ".", "then", "(", "(", "parsedStructure", ")", "=>", "writeStructure", "(", "parsedStructure", ")", ")", ".", "then", "(", "(", "parsedStructure", ")", "=>", "binStructure", "(", "parsedStructure", ",", "bin", ",", "opts", ".", "persistent", ")", ")", ".", "then", "(", "resolve", ",", "reject", ")", "}", ")", "}"], "docstring": "Converts an object into a persistent or temporary directory structure.\n@param {?Array} structure - Array of objects containing information about a directory or file.\n@returns {Promise<Array>} Parsed structure.", "docstring_tokens": ["Converts", "an", "object", "into", "a", "persistent", "or", "temporary", "directory", "structure", "."], "sha": "0990bbfaaa07abf82697f140432161304bd21336", "url": "https://github.com/electerious/fsify/blob/0990bbfaaa07abf82697f140432161304bd21336/src/index.js#L25-L40", "partition": "test"}
{"repo": "wjbryant/taboverride", "path": "build/output/taboverride.js", "func_name": "overrideKeyPress", "original_string": "function overrideKeyPress(e) {\n        e = e || event;\n\n        var key = e.keyCode;\n\n        if (tabKeyComboPressed(key, e) || untabKeyComboPressed(key, e) ||\n                (key === 13 && autoIndent && !inWhitespace)) {\n\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n                return false;\n            }\n        }\n    }", "language": "javascript", "code": "function overrideKeyPress(e) {\n        e = e || event;\n\n        var key = e.keyCode;\n\n        if (tabKeyComboPressed(key, e) || untabKeyComboPressed(key, e) ||\n                (key === 13 && autoIndent && !inWhitespace)) {\n\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n                return false;\n            }\n        }\n    }", "code_tokens": ["function", "overrideKeyPress", "(", "e", ")", "{", "e", "=", "e", "||", "event", ";", "var", "key", "=", "e", ".", "keyCode", ";", "if", "(", "tabKeyComboPressed", "(", "key", ",", "e", ")", "||", "untabKeyComboPressed", "(", "key", ",", "e", ")", "||", "(", "key", "===", "13", "&&", "autoIndent", "&&", "!", "inWhitespace", ")", ")", "{", "if", "(", "e", ".", "preventDefault", ")", "{", "e", ".", "preventDefault", "(", ")", ";", "}", "else", "{", "e", ".", "returnValue", "=", "false", ";", "return", "false", ";", "}", "}", "}"], "docstring": "Event handler to prevent the default action for the keypress event when\ntab or enter is pressed. Opera and Firefox also fire a keypress event\nwhen the tab or enter key is pressed. Opera requires that the default\naction be prevented on this event or the textarea will lose focus.\n\n@param {Event} e  the event object\n\n@method tabOverride.handlers.keypress", "docstring_tokens": ["Event", "handler", "to", "prevent", "the", "default", "action", "for", "the", "keypress", "event", "when", "tab", "or", "enter", "is", "pressed", ".", "Opera", "and", "Firefox", "also", "fire", "a", "keypress", "event", "when", "the", "tab", "or", "enter", "key", "is", "pressed", ".", "Opera", "requires", "that", "the", "default", "action", "be", "prevented", "on", "this", "event", "or", "the", "textarea", "will", "lose", "focus", "."], "sha": "02238ec1ab098cb998dcb3c1c38d39316e2ac03d", "url": "https://github.com/wjbryant/taboverride/blob/02238ec1ab098cb998dcb3c1c38d39316e2ac03d/build/output/taboverride.js#L469-L484", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(array1, array2) {\n    var intersection = [];\n\n    utils.forEach(array1, function(element) {\n      if (utils.indexOf(array2, element) >= 0) {\n        intersection.push(element);\n      }\n    });\n\n    return intersection;\n  }", "language": "javascript", "code": "function(array1, array2) {\n    var intersection = [];\n\n    utils.forEach(array1, function(element) {\n      if (utils.indexOf(array2, element) >= 0) {\n        intersection.push(element);\n      }\n    });\n\n    return intersection;\n  }", "code_tokens": ["function", "(", "array1", ",", "array2", ")", "{", "var", "intersection", "=", "[", "]", ";", "utils", ".", "forEach", "(", "array1", ",", "function", "(", "element", ")", "{", "if", "(", "utils", ".", "indexOf", "(", "array2", ",", "element", ")", ">=", "0", ")", "{", "intersection", ".", "push", "(", "element", ")", ";", "}", "}", ")", ";", "return", "intersection", ";", "}"], "docstring": "Calculates the intersection of two arrays. This method returns a new array\nfilled with the records that the two passed arrays share with each other.\nIf there is no intersection, an empty array will be returned.\n\n```javascript\nvar array1 = [1, 2, 3, 4, 5];\nvar array2 = [1, 3, 5, 6, 7];\n\nEmber.EnumerableUtils.intersection(array1, array2); // [1, 3, 5]\n\nvar array1 = [1, 2, 3];\nvar array2 = [4, 5, 6];\n\nEmber.EnumerableUtils.intersection(array1, array2); // []\n```\n\n@method intersection\n@param {Array} array1 The first array\n@param {Array} array2 The second array\n\n@return {Array} The intersection of the two passed arrays.", "docstring_tokens": ["Calculates", "the", "intersection", "of", "two", "arrays", ".", "This", "method", "returns", "a", "new", "array", "filled", "with", "the", "records", "that", "the", "two", "passed", "arrays", "share", "with", "each", "other", ".", "If", "there", "is", "no", "intersection", "an", "empty", "array", "will", "be", "returned", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L2095-L2105", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/path.js", "func_name": "normPath", "original_string": "function normPath(p) {\n    p = path.normalize(p);\n    if (p[0] == '/') p = p.slice(1);\n    if (p[p.length - 1] == '/') p = p.slice(0, -1);\n    if (p == '.') p = '';\n    return p;\n}", "language": "javascript", "code": "function normPath(p) {\n    p = path.normalize(p);\n    if (p[0] == '/') p = p.slice(1);\n    if (p[p.length - 1] == '/') p = p.slice(0, -1);\n    if (p == '.') p = '';\n    return p;\n}", "code_tokens": ["function", "normPath", "(", "p", ")", "{", "p", "=", "path", ".", "normalize", "(", "p", ")", ";", "if", "(", "p", "[", "0", "]", "==", "'/'", ")", "p", "=", "p", ".", "slice", "(", "1", ")", ";", "if", "(", "p", "[", "p", ".", "length", "-", "1", "]", "==", "'/'", ")", "p", "=", "p", ".", "slice", "(", "0", ",", "-", "1", ")", ";", "if", "(", "p", "==", "'.'", ")", "p", "=", "''", ";", "return", "p", ";", "}"], "docstring": "Normalize a path", "docstring_tokens": ["Normalize", "a", "path"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/path.js#L6-L12", "partition": "test"}
{"repo": "azproduction/lmd", "path": "stats_server/views/statics/vendors/3d/d3.layout.js", "func_name": "position", "original_string": "function position(row, u, rect, flush) {\n    var i = -1,\n        n = row.length,\n        x = rect.x,\n        y = rect.y,\n        v = u ? round(row.area / u) : 0,\n        o;\n    if (u == rect.dx) { // horizontal subdivision\n      if (flush || v > rect.dy) v = v ? rect.dy : 0; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dy = v;\n        x += o.dx = v ? round(o.area / v) : 0;\n      }\n      o.z = true;\n      o.dx += rect.x + rect.dx - x; // rounding error\n      rect.y += v;\n      rect.dy -= v;\n    } else { // vertical subdivision\n      if (flush || v > rect.dx) v = v ? rect.dx : 0; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dx = v;\n        y += o.dy = v ? round(o.area / v) : 0;\n      }\n      o.z = false;\n      o.dy += rect.y + rect.dy - y; // rounding error\n      rect.x += v;\n      rect.dx -= v;\n    }\n  }", "language": "javascript", "code": "function position(row, u, rect, flush) {\n    var i = -1,\n        n = row.length,\n        x = rect.x,\n        y = rect.y,\n        v = u ? round(row.area / u) : 0,\n        o;\n    if (u == rect.dx) { // horizontal subdivision\n      if (flush || v > rect.dy) v = v ? rect.dy : 0; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dy = v;\n        x += o.dx = v ? round(o.area / v) : 0;\n      }\n      o.z = true;\n      o.dx += rect.x + rect.dx - x; // rounding error\n      rect.y += v;\n      rect.dy -= v;\n    } else { // vertical subdivision\n      if (flush || v > rect.dx) v = v ? rect.dx : 0; // over+underflow\n      while (++i < n) {\n        o = row[i];\n        o.x = x;\n        o.y = y;\n        o.dx = v;\n        y += o.dy = v ? round(o.area / v) : 0;\n      }\n      o.z = false;\n      o.dy += rect.y + rect.dy - y; // rounding error\n      rect.x += v;\n      rect.dx -= v;\n    }\n  }", "code_tokens": ["function", "position", "(", "row", ",", "u", ",", "rect", ",", "flush", ")", "{", "var", "i", "=", "-", "1", ",", "n", "=", "row", ".", "length", ",", "x", "=", "rect", ".", "x", ",", "y", "=", "rect", ".", "y", ",", "v", "=", "u", "?", "round", "(", "row", ".", "area", "/", "u", ")", ":", "0", ",", "o", ";", "if", "(", "u", "==", "rect", ".", "dx", ")", "{", "// horizontal subdivision", "if", "(", "flush", "||", "v", ">", "rect", ".", "dy", ")", "v", "=", "v", "?", "rect", ".", "dy", ":", "0", ";", "// over+underflow", "while", "(", "++", "i", "<", "n", ")", "{", "o", "=", "row", "[", "i", "]", ";", "o", ".", "x", "=", "x", ";", "o", ".", "y", "=", "y", ";", "o", ".", "dy", "=", "v", ";", "x", "+=", "o", ".", "dx", "=", "v", "?", "round", "(", "o", ".", "area", "/", "v", ")", ":", "0", ";", "}", "o", ".", "z", "=", "true", ";", "o", ".", "dx", "+=", "rect", ".", "x", "+", "rect", ".", "dx", "-", "x", ";", "// rounding error", "rect", ".", "y", "+=", "v", ";", "rect", ".", "dy", "-=", "v", ";", "}", "else", "{", "// vertical subdivision", "if", "(", "flush", "||", "v", ">", "rect", ".", "dx", ")", "v", "=", "v", "?", "rect", ".", "dx", ":", "0", ";", "// over+underflow", "while", "(", "++", "i", "<", "n", ")", "{", "o", "=", "row", "[", "i", "]", ";", "o", ".", "x", "=", "x", ";", "o", ".", "y", "=", "y", ";", "o", ".", "dx", "=", "v", ";", "y", "+=", "o", ".", "dy", "=", "v", "?", "round", "(", "o", ".", "area", "/", "v", ")", ":", "0", ";", "}", "o", ".", "z", "=", "false", ";", "o", ".", "dy", "+=", "rect", ".", "y", "+", "rect", ".", "dy", "-", "y", ";", "// rounding error", "rect", ".", "x", "+=", "v", ";", "rect", ".", "dx", "-=", "v", ";", "}", "}"], "docstring": "Positions the specified row of nodes. Modifies `rect`.", "docstring_tokens": ["Positions", "the", "specified", "row", "of", "nodes", ".", "Modifies", "rect", "."], "sha": "03410c36839728de683c697670e1b205dc8193ee", "url": "https://github.com/azproduction/lmd/blob/03410c36839728de683c697670e1b205dc8193ee/stats_server/views/statics/vendors/3d/d3.layout.js#L1783-L1817", "partition": "test"}
{"repo": "nearform/nscale-kernel", "path": "lib/api.js", "func_name": "", "original_string": "function(user, name, namespace, cwd, cb) {\n    logger.info('create system name: ' + name + ', namespace: ' + namespace + ', cwd: ' + cwd);\n    _sr.createSystem(user, namespace, name, cwd, cb);\n  }", "language": "javascript", "code": "function(user, name, namespace, cwd, cb) {\n    logger.info('create system name: ' + name + ', namespace: ' + namespace + ', cwd: ' + cwd);\n    _sr.createSystem(user, namespace, name, cwd, cb);\n  }", "code_tokens": ["function", "(", "user", ",", "name", ",", "namespace", ",", "cwd", ",", "cb", ")", "{", "logger", ".", "info", "(", "'create system name: '", "+", "name", "+", "', namespace: '", "+", "namespace", "+", "', cwd: '", "+", "cwd", ")", ";", "_sr", ".", "createSystem", "(", "user", ",", "namespace", ",", "name", ",", "cwd", ",", "cb", ")", ";", "}"], "docstring": "create a new  blank system", "docstring_tokens": ["create", "a", "new", "blank", "system"], "sha": "5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3", "url": "https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/api.js#L82-L85", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(keyName, increment) {\n    if (Ember.isNone(increment)) { increment = 1; }\n    Ember.assert(\"Must pass a numeric value to incrementProperty\", (!isNaN(parseFloat(increment)) && isFinite(increment)));\n    set(this, keyName, (get(this, keyName) || 0) + increment);\n    return get(this, keyName);\n  }", "language": "javascript", "code": "function(keyName, increment) {\n    if (Ember.isNone(increment)) { increment = 1; }\n    Ember.assert(\"Must pass a numeric value to incrementProperty\", (!isNaN(parseFloat(increment)) && isFinite(increment)));\n    set(this, keyName, (get(this, keyName) || 0) + increment);\n    return get(this, keyName);\n  }", "code_tokens": ["function", "(", "keyName", ",", "increment", ")", "{", "if", "(", "Ember", ".", "isNone", "(", "increment", ")", ")", "{", "increment", "=", "1", ";", "}", "Ember", ".", "assert", "(", "\"Must pass a numeric value to incrementProperty\"", ",", "(", "!", "isNaN", "(", "parseFloat", "(", "increment", ")", ")", "&&", "isFinite", "(", "increment", ")", ")", ")", ";", "set", "(", "this", ",", "keyName", ",", "(", "get", "(", "this", ",", "keyName", ")", "||", "0", ")", "+", "increment", ")", ";", "return", "get", "(", "this", ",", "keyName", ")", ";", "}"], "docstring": "Set the value of a property to the current value plus some amount.\n\n```javascript\nperson.incrementProperty('age');\nteam.incrementProperty('score', 2);\n```\n\n@method incrementProperty\n@param {String} keyName The name of the property to increment\n@param {Number} increment The amount to increment by. Defaults to 1\n@return {Number} The new property value", "docstring_tokens": ["Set", "the", "value", "of", "a", "property", "to", "the", "current", "value", "plus", "some", "amount", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L12733-L12738", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/SegmentedButton.js", "func_name": "", "original_string": "function() {\n        var me = this,\n            pressedButtons = [],\n            ln, i, item, items;\n\n        //call the parent first so the items get converted into a MixedCollection\n        me.callParent(arguments);\n\n        items = this.getItems();\n        ln = items.length;\n\n        for (i = 0; i < ln; i++) {\n            item = items.items[i];\n            if (item.getInitialConfig('pressed')) {\n                pressedButtons.push(items.items[i]);\n            }\n        }\n\n        me.updateFirstAndLastCls(items);\n\n        me.setPressedButtons(pressedButtons);\n    }", "language": "javascript", "code": "function() {\n        var me = this,\n            pressedButtons = [],\n            ln, i, item, items;\n\n        //call the parent first so the items get converted into a MixedCollection\n        me.callParent(arguments);\n\n        items = this.getItems();\n        ln = items.length;\n\n        for (i = 0; i < ln; i++) {\n            item = items.items[i];\n            if (item.getInitialConfig('pressed')) {\n                pressedButtons.push(items.items[i]);\n            }\n        }\n\n        me.updateFirstAndLastCls(items);\n\n        me.setPressedButtons(pressedButtons);\n    }", "code_tokens": ["function", "(", ")", "{", "var", "me", "=", "this", ",", "pressedButtons", "=", "[", "]", ",", "ln", ",", "i", ",", "item", ",", "items", ";", "//call the parent first so the items get converted into a MixedCollection", "me", ".", "callParent", "(", "arguments", ")", ";", "items", "=", "this", ".", "getItems", "(", ")", ";", "ln", "=", "items", ".", "length", ";", "for", "(", "i", "=", "0", ";", "i", "<", "ln", ";", "i", "++", ")", "{", "item", "=", "items", ".", "items", "[", "i", "]", ";", "if", "(", "item", ".", "getInitialConfig", "(", "'pressed'", ")", ")", "{", "pressedButtons", ".", "push", "(", "items", ".", "items", "[", "i", "]", ")", ";", "}", "}", "me", ".", "updateFirstAndLastCls", "(", "items", ")", ";", "me", ".", "setPressedButtons", "(", "pressedButtons", ")", ";", "}"], "docstring": "We override `initItems` so we can check for the pressed config.", "docstring_tokens": ["We", "override", "initItems", "so", "we", "can", "check", "for", "the", "pressed", "config", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/SegmentedButton.js#L131-L152", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getTypeForBindingElement", "original_string": "function getTypeForBindingElement(declaration) {\n            var pattern = declaration.parent;\n            var parentType = getTypeForBindingElementParent(pattern.parent);\n            // If parent has the unknown (error) type, then so does this binding element\n            if (parentType === unknownType) {\n                return unknownType;\n            }\n            // If no type was specified or inferred for parent, or if the specified or inferred type is any,\n            // infer from the initializer of the binding element if one is present. Otherwise, go with the\n            // undefined or any type of the parent.\n            if (!parentType || isTypeAny(parentType)) {\n                if (declaration.initializer) {\n                    return checkExpressionCached(declaration.initializer);\n                }\n                return parentType;\n            }\n            var type;\n            if (pattern.kind === 161 /* ObjectBindingPattern */) {\n                // Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)\n                var name_10 = declaration.propertyName || declaration.name;\n                // Use type of the specified property, or otherwise, for a numeric name, the type of the numeric index signature,\n                // or otherwise the type of the string index signature.\n                type = getTypeOfPropertyOfType(parentType, name_10.text) ||\n                    isNumericLiteralName(name_10.text) && getIndexTypeOfType(parentType, 1 /* Number */) ||\n                    getIndexTypeOfType(parentType, 0 /* String */);\n                if (!type) {\n                    error(name_10, ts.Diagnostics.Type_0_has_no_property_1_and_no_string_index_signature, typeToString(parentType), ts.declarationNameToString(name_10));\n                    return unknownType;\n                }\n            }\n            else {\n                // This elementType will be used if the specific property corresponding to this index is not\n                // present (aka the tuple element property). This call also checks that the parentType is in\n                // fact an iterable or array (depending on target language).\n                var elementType = checkIteratedTypeOrElementType(parentType, pattern, /*allowStringInput*/ false);\n                if (!declaration.dotDotDotToken) {\n                    // Use specific property type when parent is a tuple or numeric index type when parent is an array\n                    var propName = \"\" + ts.indexOf(pattern.elements, declaration);\n                    type = isTupleLikeType(parentType)\n                        ? getTypeOfPropertyOfType(parentType, propName)\n                        : elementType;\n                    if (!type) {\n                        if (isTupleType(parentType)) {\n                            error(declaration, ts.Diagnostics.Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2, typeToString(parentType), parentType.elementTypes.length, pattern.elements.length);\n                        }\n                        else {\n                            error(declaration, ts.Diagnostics.Type_0_has_no_property_1, typeToString(parentType), propName);\n                        }\n                        return unknownType;\n                    }\n                }\n                else {\n                    // Rest element has an array type with the same element type as the parent type\n                    type = createArrayType(elementType);\n                }\n            }\n            return type;\n        }", "language": "javascript", "code": "function getTypeForBindingElement(declaration) {\n            var pattern = declaration.parent;\n            var parentType = getTypeForBindingElementParent(pattern.parent);\n            // If parent has the unknown (error) type, then so does this binding element\n            if (parentType === unknownType) {\n                return unknownType;\n            }\n            // If no type was specified or inferred for parent, or if the specified or inferred type is any,\n            // infer from the initializer of the binding element if one is present. Otherwise, go with the\n            // undefined or any type of the parent.\n            if (!parentType || isTypeAny(parentType)) {\n                if (declaration.initializer) {\n                    return checkExpressionCached(declaration.initializer);\n                }\n                return parentType;\n            }\n            var type;\n            if (pattern.kind === 161 /* ObjectBindingPattern */) {\n                // Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)\n                var name_10 = declaration.propertyName || declaration.name;\n                // Use type of the specified property, or otherwise, for a numeric name, the type of the numeric index signature,\n                // or otherwise the type of the string index signature.\n                type = getTypeOfPropertyOfType(parentType, name_10.text) ||\n                    isNumericLiteralName(name_10.text) && getIndexTypeOfType(parentType, 1 /* Number */) ||\n                    getIndexTypeOfType(parentType, 0 /* String */);\n                if (!type) {\n                    error(name_10, ts.Diagnostics.Type_0_has_no_property_1_and_no_string_index_signature, typeToString(parentType), ts.declarationNameToString(name_10));\n                    return unknownType;\n                }\n            }\n            else {\n                // This elementType will be used if the specific property corresponding to this index is not\n                // present (aka the tuple element property). This call also checks that the parentType is in\n                // fact an iterable or array (depending on target language).\n                var elementType = checkIteratedTypeOrElementType(parentType, pattern, /*allowStringInput*/ false);\n                if (!declaration.dotDotDotToken) {\n                    // Use specific property type when parent is a tuple or numeric index type when parent is an array\n                    var propName = \"\" + ts.indexOf(pattern.elements, declaration);\n                    type = isTupleLikeType(parentType)\n                        ? getTypeOfPropertyOfType(parentType, propName)\n                        : elementType;\n                    if (!type) {\n                        if (isTupleType(parentType)) {\n                            error(declaration, ts.Diagnostics.Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2, typeToString(parentType), parentType.elementTypes.length, pattern.elements.length);\n                        }\n                        else {\n                            error(declaration, ts.Diagnostics.Type_0_has_no_property_1, typeToString(parentType), propName);\n                        }\n                        return unknownType;\n                    }\n                }\n                else {\n                    // Rest element has an array type with the same element type as the parent type\n                    type = createArrayType(elementType);\n                }\n            }\n            return type;\n        }", "code_tokens": ["function", "getTypeForBindingElement", "(", "declaration", ")", "{", "var", "pattern", "=", "declaration", ".", "parent", ";", "var", "parentType", "=", "getTypeForBindingElementParent", "(", "pattern", ".", "parent", ")", ";", "// If parent has the unknown (error) type, then so does this binding element", "if", "(", "parentType", "===", "unknownType", ")", "{", "return", "unknownType", ";", "}", "// If no type was specified or inferred for parent, or if the specified or inferred type is any,", "// infer from the initializer of the binding element if one is present. Otherwise, go with the", "// undefined or any type of the parent.", "if", "(", "!", "parentType", "||", "isTypeAny", "(", "parentType", ")", ")", "{", "if", "(", "declaration", ".", "initializer", ")", "{", "return", "checkExpressionCached", "(", "declaration", ".", "initializer", ")", ";", "}", "return", "parentType", ";", "}", "var", "type", ";", "if", "(", "pattern", ".", "kind", "===", "161", "/* ObjectBindingPattern */", ")", "{", "// Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)", "var", "name_10", "=", "declaration", ".", "propertyName", "||", "declaration", ".", "name", ";", "// Use type of the specified property, or otherwise, for a numeric name, the type of the numeric index signature,", "// or otherwise the type of the string index signature.", "type", "=", "getTypeOfPropertyOfType", "(", "parentType", ",", "name_10", ".", "text", ")", "||", "isNumericLiteralName", "(", "name_10", ".", "text", ")", "&&", "getIndexTypeOfType", "(", "parentType", ",", "1", "/* Number */", ")", "||", "getIndexTypeOfType", "(", "parentType", ",", "0", "/* String */", ")", ";", "if", "(", "!", "type", ")", "{", "error", "(", "name_10", ",", "ts", ".", "Diagnostics", ".", "Type_0_has_no_property_1_and_no_string_index_signature", ",", "typeToString", "(", "parentType", ")", ",", "ts", ".", "declarationNameToString", "(", "name_10", ")", ")", ";", "return", "unknownType", ";", "}", "}", "else", "{", "// This elementType will be used if the specific property corresponding to this index is not", "// present (aka the tuple element property). This call also checks that the parentType is in", "// fact an iterable or array (depending on target language).", "var", "elementType", "=", "checkIteratedTypeOrElementType", "(", "parentType", ",", "pattern", ",", "/*allowStringInput*/", "false", ")", ";", "if", "(", "!", "declaration", ".", "dotDotDotToken", ")", "{", "// Use specific property type when parent is a tuple or numeric index type when parent is an array", "var", "propName", "=", "\"\"", "+", "ts", ".", "indexOf", "(", "pattern", ".", "elements", ",", "declaration", ")", ";", "type", "=", "isTupleLikeType", "(", "parentType", ")", "?", "getTypeOfPropertyOfType", "(", "parentType", ",", "propName", ")", ":", "elementType", ";", "if", "(", "!", "type", ")", "{", "if", "(", "isTupleType", "(", "parentType", ")", ")", "{", "error", "(", "declaration", ",", "ts", ".", "Diagnostics", ".", "Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2", ",", "typeToString", "(", "parentType", ")", ",", "parentType", ".", "elementTypes", ".", "length", ",", "pattern", ".", "elements", ".", "length", ")", ";", "}", "else", "{", "error", "(", "declaration", ",", "ts", ".", "Diagnostics", ".", "Type_0_has_no_property_1", ",", "typeToString", "(", "parentType", ")", ",", "propName", ")", ";", "}", "return", "unknownType", ";", "}", "}", "else", "{", "// Rest element has an array type with the same element type as the parent type", "type", "=", "createArrayType", "(", "elementType", ")", ";", "}", "}", "return", "type", ";", "}"], "docstring": "Return the inferred type for a binding element", "docstring_tokens": ["Return", "the", "inferred", "type", "for", "a", "binding", "element"], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L15355-L15412", "partition": "test"}
{"repo": "datastax/nodejs-driver", "path": "lib/types/index.js", "func_name": "FrameHeader", "original_string": "function FrameHeader(version, flags, streamId, opcode, bodyLength) {\n  this.version = version;\n  this.flags = flags;\n  this.streamId = streamId;\n  this.opcode = opcode;\n  this.bodyLength = bodyLength;\n}", "language": "javascript", "code": "function FrameHeader(version, flags, streamId, opcode, bodyLength) {\n  this.version = version;\n  this.flags = flags;\n  this.streamId = streamId;\n  this.opcode = opcode;\n  this.bodyLength = bodyLength;\n}", "code_tokens": ["function", "FrameHeader", "(", "version", ",", "flags", ",", "streamId", ",", "opcode", ",", "bodyLength", ")", "{", "this", ".", "version", "=", "version", ";", "this", ".", "flags", "=", "flags", ";", "this", ".", "streamId", "=", "streamId", ";", "this", ".", "opcode", "=", "opcode", ";", "this", ".", "bodyLength", "=", "bodyLength", ";", "}"], "docstring": "classes \nRepresents a frame header that could be used to read from a Buffer or to write to a Buffer\n@ignore\n@param {Number} version Protocol version\n@param {Number} flags\n@param {Number} streamId\n@param {Number} opcode\n@param {Number} bodyLength\n@constructor", "docstring_tokens": ["classes", "Represents", "a", "frame", "header", "that", "could", "be", "used", "to", "read", "from", "a", "Buffer", "or", "to", "write", "to", "a", "Buffer"], "sha": "6766188870f7099aeb393719820245b69d789d23", "url": "https://github.com/datastax/nodejs-driver/blob/6766188870f7099aeb393719820245b69d789d23/lib/types/index.js#L430-L436", "partition": "test"}
{"repo": "jonschlinkert/dry", "path": "lib/lexer.js", "func_name": "Lexer", "original_string": "function Lexer(file, options) {\n  this.options = utils.extend({}, options);\n  this.file = file;\n  this.regex = new RegexCache();\n  this.names = [];\n  this.ast = {\n    tags: {},\n    type: 'root',\n    name: 'root',\n    nodes: []\n  };\n\n  this.unknown = {tags: [], blocks: []};\n  this.known = {\n    tags: ['extends', 'layout'],\n    blocks: ['block']\n  };\n\n  this.delimiters = {\n    variable: ['{{', '}}'],\n    block: ['{%', '%}'],\n    es6: ['${', '}'],\n  };\n\n  this.tokens = [this.ast];\n  this.errors = [];\n  this.stack = [];\n  this.stash = [];\n  this.lexers = {};\n  this.fns = [];\n}", "language": "javascript", "code": "function Lexer(file, options) {\n  this.options = utils.extend({}, options);\n  this.file = file;\n  this.regex = new RegexCache();\n  this.names = [];\n  this.ast = {\n    tags: {},\n    type: 'root',\n    name: 'root',\n    nodes: []\n  };\n\n  this.unknown = {tags: [], blocks: []};\n  this.known = {\n    tags: ['extends', 'layout'],\n    blocks: ['block']\n  };\n\n  this.delimiters = {\n    variable: ['{{', '}}'],\n    block: ['{%', '%}'],\n    es6: ['${', '}'],\n  };\n\n  this.tokens = [this.ast];\n  this.errors = [];\n  this.stack = [];\n  this.stash = [];\n  this.lexers = {};\n  this.fns = [];\n}", "code_tokens": ["function", "Lexer", "(", "file", ",", "options", ")", "{", "this", ".", "options", "=", "utils", ".", "extend", "(", "{", "}", ",", "options", ")", ";", "this", ".", "file", "=", "file", ";", "this", ".", "regex", "=", "new", "RegexCache", "(", ")", ";", "this", ".", "names", "=", "[", "]", ";", "this", ".", "ast", "=", "{", "tags", ":", "{", "}", ",", "type", ":", "'root'", ",", "name", ":", "'root'", ",", "nodes", ":", "[", "]", "}", ";", "this", ".", "unknown", "=", "{", "tags", ":", "[", "]", ",", "blocks", ":", "[", "]", "}", ";", "this", ".", "known", "=", "{", "tags", ":", "[", "'extends'", ",", "'layout'", "]", ",", "blocks", ":", "[", "'block'", "]", "}", ";", "this", ".", "delimiters", "=", "{", "variable", ":", "[", "'{{'", ",", "'}}'", "]", ",", "block", ":", "[", "'{%'", ",", "'%}'", "]", ",", "es6", ":", "[", "'${'", ",", "'}'", "]", ",", "}", ";", "this", ".", "tokens", "=", "[", "this", ".", "ast", "]", ";", "this", ".", "errors", "=", "[", "]", ";", "this", ".", "stack", "=", "[", "]", ";", "this", ".", "stash", "=", "[", "]", ";", "this", ".", "lexers", "=", "{", "}", ";", "this", ".", "fns", "=", "[", "]", ";", "}"], "docstring": "Create a new `Lexer` for the given `file` and `options`.\n@param {object} `file`\n@param {object} `options`", "docstring_tokens": ["Create", "a", "new", "Lexer", "for", "the", "given", "file", "and", "options", "."], "sha": "c841f768d6dbc15a1018ca6927781745e7c83726", "url": "https://github.com/jonschlinkert/dry/blob/c841f768d6dbc15a1018ca6927781745e7c83726/lib/lexer.js#L14-L44", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/DateExtras.js", "func_name": "", "original_string": "function (min, max, unit) {\n        var ExtDate = Ext.Date, est, diff = +max - min;\n        switch (unit) {\n            case ExtDate.MILLI:\n                return diff;\n            case ExtDate.SECOND:\n                return Math.floor(diff / 1000);\n            case ExtDate.MINUTE:\n                return Math.floor(diff / 60000);\n            case ExtDate.HOUR:\n                return Math.floor(diff / 3600000);\n            case ExtDate.DAY:\n                return Math.floor(diff / 86400000);\n            case 'w':\n                return Math.floor(diff / 604800000);\n            case ExtDate.MONTH:\n                est = (max.getFullYear() * 12 + max.getMonth()) - (min.getFullYear() * 12 + min.getMonth());\n                if (Ext.Date.add(min, unit, est) > max) {\n                    return est - 1;\n                } else {\n                    return est;\n                }\n            case ExtDate.YEAR:\n                est = max.getFullYear() - min.getFullYear();\n                if (Ext.Date.add(min, unit, est) > max) {\n                    return est - 1;\n                } else {\n                    return est;\n                }\n        }\n    }", "language": "javascript", "code": "function (min, max, unit) {\n        var ExtDate = Ext.Date, est, diff = +max - min;\n        switch (unit) {\n            case ExtDate.MILLI:\n                return diff;\n            case ExtDate.SECOND:\n                return Math.floor(diff / 1000);\n            case ExtDate.MINUTE:\n                return Math.floor(diff / 60000);\n            case ExtDate.HOUR:\n                return Math.floor(diff / 3600000);\n            case ExtDate.DAY:\n                return Math.floor(diff / 86400000);\n            case 'w':\n                return Math.floor(diff / 604800000);\n            case ExtDate.MONTH:\n                est = (max.getFullYear() * 12 + max.getMonth()) - (min.getFullYear() * 12 + min.getMonth());\n                if (Ext.Date.add(min, unit, est) > max) {\n                    return est - 1;\n                } else {\n                    return est;\n                }\n            case ExtDate.YEAR:\n                est = max.getFullYear() - min.getFullYear();\n                if (Ext.Date.add(min, unit, est) > max) {\n                    return est - 1;\n                } else {\n                    return est;\n                }\n        }\n    }", "code_tokens": ["function", "(", "min", ",", "max", ",", "unit", ")", "{", "var", "ExtDate", "=", "Ext", ".", "Date", ",", "est", ",", "diff", "=", "+", "max", "-", "min", ";", "switch", "(", "unit", ")", "{", "case", "ExtDate", ".", "MILLI", ":", "return", "diff", ";", "case", "ExtDate", ".", "SECOND", ":", "return", "Math", ".", "floor", "(", "diff", "/", "1000", ")", ";", "case", "ExtDate", ".", "MINUTE", ":", "return", "Math", ".", "floor", "(", "diff", "/", "60000", ")", ";", "case", "ExtDate", ".", "HOUR", ":", "return", "Math", ".", "floor", "(", "diff", "/", "3600000", ")", ";", "case", "ExtDate", ".", "DAY", ":", "return", "Math", ".", "floor", "(", "diff", "/", "86400000", ")", ";", "case", "'w'", ":", "return", "Math", ".", "floor", "(", "diff", "/", "604800000", ")", ";", "case", "ExtDate", ".", "MONTH", ":", "est", "=", "(", "max", ".", "getFullYear", "(", ")", "*", "12", "+", "max", ".", "getMonth", "(", ")", ")", "-", "(", "min", ".", "getFullYear", "(", ")", "*", "12", "+", "min", ".", "getMonth", "(", ")", ")", ";", "if", "(", "Ext", ".", "Date", ".", "add", "(", "min", ",", "unit", ",", "est", ")", ">", "max", ")", "{", "return", "est", "-", "1", ";", "}", "else", "{", "return", "est", ";", "}", "case", "ExtDate", ".", "YEAR", ":", "est", "=", "max", ".", "getFullYear", "(", ")", "-", "min", ".", "getFullYear", "(", ")", ";", "if", "(", "Ext", ".", "Date", ".", "add", "(", "min", ",", "unit", ",", "est", ")", ">", "max", ")", "{", "return", "est", "-", "1", ";", "}", "else", "{", "return", "est", ";", "}", "}", "}"], "docstring": "Calculate how many units are there between two time.\n@param {Date} min The first time.\n@param {Date} max The second time.\n@param {String} unit The unit. This unit is compatible with the date interval constants.\n@return {Number} The maximum number n of units that min + n * unit <= max.", "docstring_tokens": ["Calculate", "how", "many", "units", "are", "there", "between", "two", "time", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/DateExtras.js#L1423-L1453", "partition": "test"}
{"repo": "seaneking/postcss-hexrgba", "path": "index.js", "func_name": "hexRgb", "original_string": "function hexRgb(hex){\n    let shorthandCheck = /^([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n        rgbRegex = /^([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i,\n        rgb;\n\n    hex = hex.replace(shorthandCheck, function(m, r, g, b) {\n      return r + r + g + g + b + b;\n    });\n\n    rgb = hex.replace(/^\\s+|\\s+$/g, '').match(rgbRegex);\n\n    // Convert it\n    return rgb ? [\n      parseInt(rgb[1], 16),\n      parseInt(rgb[2], 16),\n      parseInt(rgb[3], 16)\n    ] : false;\n  }", "language": "javascript", "code": "function hexRgb(hex){\n    let shorthandCheck = /^([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n        rgbRegex = /^([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i,\n        rgb;\n\n    hex = hex.replace(shorthandCheck, function(m, r, g, b) {\n      return r + r + g + g + b + b;\n    });\n\n    rgb = hex.replace(/^\\s+|\\s+$/g, '').match(rgbRegex);\n\n    // Convert it\n    return rgb ? [\n      parseInt(rgb[1], 16),\n      parseInt(rgb[2], 16),\n      parseInt(rgb[3], 16)\n    ] : false;\n  }", "code_tokens": ["function", "hexRgb", "(", "hex", ")", "{", "let", "shorthandCheck", "=", "/", "^([a-f\\d])([a-f\\d])([a-f\\d])$", "/", "i", ",", "rgbRegex", "=", "/", "^([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$", "/", "i", ",", "rgb", ";", "hex", "=", "hex", ".", "replace", "(", "shorthandCheck", ",", "function", "(", "m", ",", "r", ",", "g", ",", "b", ")", "{", "return", "r", "+", "r", "+", "g", "+", "g", "+", "b", "+", "b", ";", "}", ")", ";", "rgb", "=", "hex", ".", "replace", "(", "/", "^\\s+|\\s+$", "/", "g", ",", "''", ")", ".", "match", "(", "rgbRegex", ")", ";", "// Convert it", "return", "rgb", "?", "[", "parseInt", "(", "rgb", "[", "1", "]", ",", "16", ")", ",", "parseInt", "(", "rgb", "[", "2", "]", ",", "16", ")", ",", "parseInt", "(", "rgb", "[", "3", "]", ",", "16", ")", "]", ":", "false", ";", "}"], "docstring": "Hex to RGB converter\n@param  {string} hex hexidecimal string without #\n@return {array} RGB values", "docstring_tokens": ["Hex", "to", "RGB", "converter"], "sha": "da82e8fab5ca6200ea6f1174b96826f7a3e8cdad", "url": "https://github.com/seaneking/postcss-hexrgba/blob/da82e8fab5ca6200ea6f1174b96826f7a3e8cdad/index.js#L12-L29", "partition": "test"}
{"repo": "tstachl/desk.js", "path": "lib/resource/customer.js", "func_name": "Customer", "original_string": "function Customer(parent, definition) {\n  var key;\n  for (key in updateMixin) {\n    this[key] = updateMixin[key];\n  }\n  Customer.super_.apply(this, arguments);\n}", "language": "javascript", "code": "function Customer(parent, definition) {\n  var key;\n  for (key in updateMixin) {\n    this[key] = updateMixin[key];\n  }\n  Customer.super_.apply(this, arguments);\n}", "code_tokens": ["function", "Customer", "(", "parent", ",", "definition", ")", "{", "var", "key", ";", "for", "(", "key", "in", "updateMixin", ")", "{", "this", "[", "key", "]", "=", "updateMixin", "[", "key", "]", ";", "}", "Customer", ".", "super_", ".", "apply", "(", "this", ",", "arguments", ")", ";", "}"], "docstring": "Initialize a new `Customer` with the given `parent` and `definition`.\n\n@param {Function} parent The parent this resource is attached to.\n@param {Object} definition The resource definition.\n@api private", "docstring_tokens": ["Initialize", "a", "new", "Customer", "with", "the", "given", "parent", "and", "definition", "."], "sha": "b339196cce68dbbc79d3075f2ebe82372972f4f5", "url": "https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/resource/customer.js#L21-L27", "partition": "test"}
{"repo": "jdiehl/restify-magic", "path": "lib/create-server.js", "func_name": "typeConvert", "original_string": "function typeConvert(obj, onlyDate) {\n  var i, res;\n  if (typeof obj === \"object\") {\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        obj[i] = typeConvert(obj[i], onlyDate);\n      }\n    }\n  } else if (typeof obj === \"string\") {\n    if (!onlyDate && obj.match(/^([0-9.]+|true|false|undefined|null)$/)) {\n      obj = eval(obj);\n    } else {\n      res = obj.match(/^\"?(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z)\"?$/);\n      if (res) {\n        obj = new Date(res[1]);\n      }\n    }\n  }\n  return obj;\n}", "language": "javascript", "code": "function typeConvert(obj, onlyDate) {\n  var i, res;\n  if (typeof obj === \"object\") {\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        obj[i] = typeConvert(obj[i], onlyDate);\n      }\n    }\n  } else if (typeof obj === \"string\") {\n    if (!onlyDate && obj.match(/^([0-9.]+|true|false|undefined|null)$/)) {\n      obj = eval(obj);\n    } else {\n      res = obj.match(/^\"?(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z)\"?$/);\n      if (res) {\n        obj = new Date(res[1]);\n      }\n    }\n  }\n  return obj;\n}", "code_tokens": ["function", "typeConvert", "(", "obj", ",", "onlyDate", ")", "{", "var", "i", ",", "res", ";", "if", "(", "typeof", "obj", "===", "\"object\"", ")", "{", "for", "(", "i", "in", "obj", ")", "{", "if", "(", "obj", ".", "hasOwnProperty", "(", "i", ")", ")", "{", "obj", "[", "i", "]", "=", "typeConvert", "(", "obj", "[", "i", "]", ",", "onlyDate", ")", ";", "}", "}", "}", "else", "if", "(", "typeof", "obj", "===", "\"string\"", ")", "{", "if", "(", "!", "onlyDate", "&&", "obj", ".", "match", "(", "/", "^([0-9.]+|true|false|undefined|null)$", "/", ")", ")", "{", "obj", "=", "eval", "(", "obj", ")", ";", "}", "else", "{", "res", "=", "obj", ".", "match", "(", "/", "^\"?(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z)\"?$", "/", ")", ";", "if", "(", "res", ")", "{", "obj", "=", "new", "Date", "(", "res", "[", "1", "]", ")", ";", "}", "}", "}", "return", "obj", ";", "}"], "docstring": "simple string to native-type conversion middleware", "docstring_tokens": ["simple", "string", "to", "native", "-", "type", "conversion", "middleware"], "sha": "6bdce13c59c771327c1d06a5bd9da5830236fc75", "url": "https://github.com/jdiehl/restify-magic/blob/6bdce13c59c771327c1d06a5bd9da5830236fc75/lib/create-server.js#L18-L37", "partition": "test"}
{"repo": "kbirk/alfador", "path": "src/Vec2.js", "func_name": "Vec2", "original_string": "function Vec2() {\n        switch ( arguments.length ) {\n            case 1:\n                // array or VecN argument\n                var argument = arguments[0];\n                this.x = argument.x || argument[0] || 0.0;\n                this.y = argument.y || argument[1] || 0.0;\n                break;\n            case 2:\n                // individual component arguments\n                this.x = arguments[0];\n                this.y = arguments[1];\n                break;\n            default:\n                this.x = 0;\n                this.y = 0;\n                break;\n        }\n    }", "language": "javascript", "code": "function Vec2() {\n        switch ( arguments.length ) {\n            case 1:\n                // array or VecN argument\n                var argument = arguments[0];\n                this.x = argument.x || argument[0] || 0.0;\n                this.y = argument.y || argument[1] || 0.0;\n                break;\n            case 2:\n                // individual component arguments\n                this.x = arguments[0];\n                this.y = arguments[1];\n                break;\n            default:\n                this.x = 0;\n                this.y = 0;\n                break;\n        }\n    }", "code_tokens": ["function", "Vec2", "(", ")", "{", "switch", "(", "arguments", ".", "length", ")", "{", "case", "1", ":", "// array or VecN argument", "var", "argument", "=", "arguments", "[", "0", "]", ";", "this", ".", "x", "=", "argument", ".", "x", "||", "argument", "[", "0", "]", "||", "0.0", ";", "this", ".", "y", "=", "argument", ".", "y", "||", "argument", "[", "1", "]", "||", "0.0", ";", "break", ";", "case", "2", ":", "// individual component arguments", "this", ".", "x", "=", "arguments", "[", "0", "]", ";", "this", ".", "y", "=", "arguments", "[", "1", "]", ";", "break", ";", "default", ":", "this", ".", "x", "=", "0", ";", "this", ".", "y", "=", "0", ";", "break", ";", "}", "}"], "docstring": "Instantiates a Vec2 object.\n@class Vec2\n@classdesc A two component vector.", "docstring_tokens": ["Instantiates", "a", "Vec2", "object", "."], "sha": "77500f7ed85c84b4a9afdc7d044b47c376e0fdf8", "url": "https://github.com/kbirk/alfador/blob/77500f7ed85c84b4a9afdc7d044b47c376e0fdf8/src/Vec2.js#L12-L30", "partition": "test"}
{"repo": "mobilehero-archive/aplus-node", "path": "resolver/resolve-fix.js", "func_name": "injectCode", "original_string": "function injectCode() {\n\n\t\tvar fullpath = path.join(rootpath, \"app.js\");\n\t\tvar source = fs.readFileSync(fullpath, 'utf8');\n\t\tvar test = /\\/\\/ALLOY-RESOLVER/.test(source);\n\t\tlogger.trace(\"CODE INJECTED ALREADY: \" + test);\n\t\tif(!test) {\n\t\t\tsource = source.replace(/(var\\s+Alloy[^;]+;)/g, \"$1\\n//ALLOY-RESOLVER\\nvar process=require('/process');\\nAlloy.resolve=new (require('/resolver'))().resolve;\\n\");\n\t\t\tfs.writeFileSync(fullpath, source);\n\t\t}\n\t}", "language": "javascript", "code": "function injectCode() {\n\n\t\tvar fullpath = path.join(rootpath, \"app.js\");\n\t\tvar source = fs.readFileSync(fullpath, 'utf8');\n\t\tvar test = /\\/\\/ALLOY-RESOLVER/.test(source);\n\t\tlogger.trace(\"CODE INJECTED ALREADY: \" + test);\n\t\tif(!test) {\n\t\t\tsource = source.replace(/(var\\s+Alloy[^;]+;)/g, \"$1\\n//ALLOY-RESOLVER\\nvar process=require('/process');\\nAlloy.resolve=new (require('/resolver'))().resolve;\\n\");\n\t\t\tfs.writeFileSync(fullpath, source);\n\t\t}\n\t}", "code_tokens": ["function", "injectCode", "(", ")", "{", "var", "fullpath", "=", "path", ".", "join", "(", "rootpath", ",", "\"app.js\"", ")", ";", "var", "source", "=", "fs", ".", "readFileSync", "(", "fullpath", ",", "'utf8'", ")", ";", "var", "test", "=", "/", "\\/\\/ALLOY-RESOLVER", "/", ".", "test", "(", "source", ")", ";", "logger", ".", "trace", "(", "\"CODE INJECTED ALREADY: \"", "+", "test", ")", ";", "if", "(", "!", "test", ")", "{", "source", "=", "source", ".", "replace", "(", "/", "(var\\s+Alloy[^;]+;)", "/", "g", ",", "\"$1\\n//ALLOY-RESOLVER\\nvar process=require('/process');\\nAlloy.resolve=new (require('/resolver'))().resolve;\\n\"", ")", ";", "fs", ".", "writeFileSync", "(", "fullpath", ",", "source", ")", ";", "}", "}"], "docstring": "Inject necessary code into the file app.js", "docstring_tokens": ["Inject", "necessary", "code", "into", "the", "file", "app", ".", "js"], "sha": "a16e11722406eb42f7b9e182c1301ffe2b706b67", "url": "https://github.com/mobilehero-archive/aplus-node/blob/a16e11722406eb42f7b9e182c1301ffe2b706b67/resolver/resolve-fix.js#L62-L72", "partition": "test"}
{"repo": "moovel/node-yolo", "path": "util/has_lib.js", "func_name": "hasSystemLib", "original_string": "function hasSystemLib (lib) {\n  var libName = 'lib' + lib + '.+(so|dylib)'\n  var libNameRegex = new RegExp(libName)\n\n    // Try using ldconfig on linux systems\n  if (hasLdconfig()) {\n    try {\n      if (childProcess.execSync('ldconfig -p 2>/dev/null | grep -E \"' + libName + '\"').length) {\n        return true\n      }\n    } catch (err) {\n      // noop -- proceed to other search methods\n    }\n  }\n\n    // Try checking common library locations\n  return SYSTEM_PATHS.some(function (systemPath) {\n    try {\n      var dirListing = fs.readdirSync(systemPath)\n      return dirListing.some(function (file) {\n        return libNameRegex.test(file)\n      })\n    } catch (err) {\n      return false\n    }\n  })\n}", "language": "javascript", "code": "function hasSystemLib (lib) {\n  var libName = 'lib' + lib + '.+(so|dylib)'\n  var libNameRegex = new RegExp(libName)\n\n    // Try using ldconfig on linux systems\n  if (hasLdconfig()) {\n    try {\n      if (childProcess.execSync('ldconfig -p 2>/dev/null | grep -E \"' + libName + '\"').length) {\n        return true\n      }\n    } catch (err) {\n      // noop -- proceed to other search methods\n    }\n  }\n\n    // Try checking common library locations\n  return SYSTEM_PATHS.some(function (systemPath) {\n    try {\n      var dirListing = fs.readdirSync(systemPath)\n      return dirListing.some(function (file) {\n        return libNameRegex.test(file)\n      })\n    } catch (err) {\n      return false\n    }\n  })\n}", "code_tokens": ["function", "hasSystemLib", "(", "lib", ")", "{", "var", "libName", "=", "'lib'", "+", "lib", "+", "'.+(so|dylib)'", "var", "libNameRegex", "=", "new", "RegExp", "(", "libName", ")", "// Try using ldconfig on linux systems", "if", "(", "hasLdconfig", "(", ")", ")", "{", "try", "{", "if", "(", "childProcess", ".", "execSync", "(", "'ldconfig -p 2>/dev/null | grep -E \"'", "+", "libName", "+", "'\"'", ")", ".", "length", ")", "{", "return", "true", "}", "}", "catch", "(", "err", ")", "{", "// noop -- proceed to other search methods", "}", "}", "// Try checking common library locations", "return", "SYSTEM_PATHS", ".", "some", "(", "function", "(", "systemPath", ")", "{", "try", "{", "var", "dirListing", "=", "fs", ".", "readdirSync", "(", "systemPath", ")", "return", "dirListing", ".", "some", "(", "function", "(", "file", ")", "{", "return", "libNameRegex", ".", "test", "(", "file", ")", "}", ")", "}", "catch", "(", "err", ")", "{", "return", "false", "}", "}", ")", "}"], "docstring": "Checks for lib using ldconfig if present, or searching SYSTEM_PATHS\notherwise.\n@param String library name, e.g. 'jpeg' in 'libjpeg64.so' (see first line)\n@return Boolean exists", "docstring_tokens": ["Checks", "for", "lib", "using", "ldconfig", "if", "present", "or", "searching", "SYSTEM_PATHS", "otherwise", "."], "sha": "1c52c30de306854a7bd22d6cac4bc5bf9a71d3fa", "url": "https://github.com/moovel/node-yolo/blob/1c52c30de306854a7bd22d6cac4bc5bf9a71d3fa/util/has_lib.js#L36-L62", "partition": "test"}
{"repo": "olindata/node-puppet-hiera", "path": "index.js", "func_name": "getFile", "original_string": "function getFile(backend, file, cb) {\n  getBackendConfig(backend, function (err, config) {\n    file = [ config[':datadir'], '/', file ].join('');\n\n    fs.readFile(file, cb);\n  });\n}", "language": "javascript", "code": "function getFile(backend, file, cb) {\n  getBackendConfig(backend, function (err, config) {\n    file = [ config[':datadir'], '/', file ].join('');\n\n    fs.readFile(file, cb);\n  });\n}", "code_tokens": ["function", "getFile", "(", "backend", ",", "file", ",", "cb", ")", "{", "getBackendConfig", "(", "backend", ",", "function", "(", "err", ",", "config", ")", "{", "file", "=", "[", "config", "[", "':datadir'", "]", ",", "'/'", ",", "file", "]", ".", "join", "(", "''", ")", ";", "fs", ".", "readFile", "(", "file", ",", "cb", ")", ";", "}", ")", ";", "}"], "docstring": "Retrieves data from a Hiera file.\n\n@param {string} backend - the backend to load.\n@param {string} file - the Hiera file to load.\n@param {Function} cb - callback to invoke.\n\n@example getFile('yaml', 'defaults.yaml', function (err, data) { ... });", "docstring_tokens": ["Retrieves", "data", "from", "a", "Hiera", "file", "."], "sha": "fda35ca55ae054641f428873c9f2f763ea302422", "url": "https://github.com/olindata/node-puppet-hiera/blob/fda35ca55ae054641f428873c9f2f763ea302422/index.js#L119-L125", "partition": "test"}
{"repo": "auth0/sandboxjs", "path": "lib/cronJob.js", "func_name": "CronJob", "original_string": "function CronJob (sandbox, job) {\n    /**\n     * @property name - The name of the cron job\n     * @property schedule - The cron schedule of the job\n     * @property next_scheduled_at - The next time this job is scheduled\n     */\n    assign(this, job);\n\n    /**\n     * @property claims - The claims embedded in the Webtask's token\n     */\n    if (job.token) {\n        this.claims = Decode(job.token);\n    }\n    else {\n        this.claims = {\n            jtn: job.name,\n            ten: this.container,\n        };\n    }\n\n    /**\n     * @property sandbox - The {@see Sandbox} instance used to create this Webtask instance\n     */\n    this.sandbox = sandbox;\n\n    /**\n     * @property url - The public url that can be used to invoke webtask that the cron job runs\n     */\n    Object.defineProperty(this, 'url', {\n        enumerable: true,\n        get: function () {\n            return this.sandbox.url + '/api/run/' + this.container + '/' + this.name;\n        }\n    });\n}", "language": "javascript", "code": "function CronJob (sandbox, job) {\n    /**\n     * @property name - The name of the cron job\n     * @property schedule - The cron schedule of the job\n     * @property next_scheduled_at - The next time this job is scheduled\n     */\n    assign(this, job);\n\n    /**\n     * @property claims - The claims embedded in the Webtask's token\n     */\n    if (job.token) {\n        this.claims = Decode(job.token);\n    }\n    else {\n        this.claims = {\n            jtn: job.name,\n            ten: this.container,\n        };\n    }\n\n    /**\n     * @property sandbox - The {@see Sandbox} instance used to create this Webtask instance\n     */\n    this.sandbox = sandbox;\n\n    /**\n     * @property url - The public url that can be used to invoke webtask that the cron job runs\n     */\n    Object.defineProperty(this, 'url', {\n        enumerable: true,\n        get: function () {\n            return this.sandbox.url + '/api/run/' + this.container + '/' + this.name;\n        }\n    });\n}", "code_tokens": ["function", "CronJob", "(", "sandbox", ",", "job", ")", "{", "/**\n     * @property name - The name of the cron job\n     * @property schedule - The cron schedule of the job\n     * @property next_scheduled_at - The next time this job is scheduled\n     */", "assign", "(", "this", ",", "job", ")", ";", "/**\n     * @property claims - The claims embedded in the Webtask's token\n     */", "if", "(", "job", ".", "token", ")", "{", "this", ".", "claims", "=", "Decode", "(", "job", ".", "token", ")", ";", "}", "else", "{", "this", ".", "claims", "=", "{", "jtn", ":", "job", ".", "name", ",", "ten", ":", "this", ".", "container", ",", "}", ";", "}", "/**\n     * @property sandbox - The {@see Sandbox} instance used to create this Webtask instance\n     */", "this", ".", "sandbox", "=", "sandbox", ";", "/**\n     * @property url - The public url that can be used to invoke webtask that the cron job runs\n     */", "Object", ".", "defineProperty", "(", "this", ",", "'url'", ",", "{", "enumerable", ":", "true", ",", "get", ":", "function", "(", ")", "{", "return", "this", ".", "sandbox", ".", "url", "+", "'/api/run/'", "+", "this", ".", "container", "+", "'/'", "+", "this", ".", "name", ";", "}", "}", ")", ";", "}"], "docstring": "Creates an object representing a CronJob\n\n@constructor", "docstring_tokens": ["Creates", "an", "object", "representing", "a", "CronJob"], "sha": "285d9cc995eda9c2ad76618c2805b9d126994ab4", "url": "https://github.com/auth0/sandboxjs/blob/285d9cc995eda9c2ad76618c2805b9d126994ab4/lib/cronJob.js#L15-L50", "partition": "test"}
{"repo": "Kashoo/synctos", "path": "templates/sync-function/time-module.js", "func_name": "normalizeIso8601TimeZone", "original_string": "function normalizeIso8601TimeZone(value) {\n    return value ? value.multiplicationFactor * ((value.hour * 60) + value.minute) : -(new Date().getTimezoneOffset());\n  }", "language": "javascript", "code": "function normalizeIso8601TimeZone(value) {\n    return value ? value.multiplicationFactor * ((value.hour * 60) + value.minute) : -(new Date().getTimezoneOffset());\n  }", "code_tokens": ["function", "normalizeIso8601TimeZone", "(", "value", ")", "{", "return", "value", "?", "value", ".", "multiplicationFactor", "*", "(", "(", "value", ".", "hour", "*", "60", ")", "+", "value", ".", "minute", ")", ":", "-", "(", "new", "Date", "(", ")", ".", "getTimezoneOffset", "(", ")", ")", ";", "}"], "docstring": "Converts an ISO 8601 time zone into the number of minutes offset from UTC", "docstring_tokens": ["Converts", "an", "ISO", "8601", "time", "zone", "into", "the", "number", "of", "minutes", "offset", "from", "UTC"], "sha": "a6d59b4d4af2b837842d2107c57064c3fa12cc73", "url": "https://github.com/Kashoo/synctos/blob/a6d59b4d4af2b837842d2107c57064c3fa12cc73/templates/sync-function/time-module.js#L357-L359", "partition": "test"}
{"repo": "acalvoa/sails-hook-multitenant", "path": "examples/assets/dependencies/sails.io.js", "func_name": "runRequestQueue", "original_string": "function runRequestQueue (socket) {\n      var queue = socket.requestQueue;\n\n      if (!queue) return;\n      for (var i in queue) {\n\n        // Double-check that `queue[i]` will not\n        // inadvertently discover extra properties attached to the Object\n        // and/or Array prototype by other libraries/frameworks/tools.\n        // (e.g. Ember does this. See https://github.com/balderdashy/sails.io.js/pull/5)\n        var isSafeToDereference = ({}).hasOwnProperty.call(queue, i);\n        if (isSafeToDereference) {\n          // Get the arguments that were originally made to the \"request\" method\n          var requestArgs = queue[i];\n          // Call the request method again in the context of the socket, with the original args\n          socket.request.apply(socket, requestArgs);\n        }\n      }\n\n      // Now empty the queue to remove it as a source of additional complexity.\n      socket.requestQueue = null;\n    }", "language": "javascript", "code": "function runRequestQueue (socket) {\n      var queue = socket.requestQueue;\n\n      if (!queue) return;\n      for (var i in queue) {\n\n        // Double-check that `queue[i]` will not\n        // inadvertently discover extra properties attached to the Object\n        // and/or Array prototype by other libraries/frameworks/tools.\n        // (e.g. Ember does this. See https://github.com/balderdashy/sails.io.js/pull/5)\n        var isSafeToDereference = ({}).hasOwnProperty.call(queue, i);\n        if (isSafeToDereference) {\n          // Get the arguments that were originally made to the \"request\" method\n          var requestArgs = queue[i];\n          // Call the request method again in the context of the socket, with the original args\n          socket.request.apply(socket, requestArgs);\n        }\n      }\n\n      // Now empty the queue to remove it as a source of additional complexity.\n      socket.requestQueue = null;\n    }", "code_tokens": ["function", "runRequestQueue", "(", "socket", ")", "{", "var", "queue", "=", "socket", ".", "requestQueue", ";", "if", "(", "!", "queue", ")", "return", ";", "for", "(", "var", "i", "in", "queue", ")", "{", "// Double-check that `queue[i]` will not", "// inadvertently discover extra properties attached to the Object", "// and/or Array prototype by other libraries/frameworks/tools.", "// (e.g. Ember does this. See https://github.com/balderdashy/sails.io.js/pull/5)", "var", "isSafeToDereference", "=", "(", "{", "}", ")", ".", "hasOwnProperty", ".", "call", "(", "queue", ",", "i", ")", ";", "if", "(", "isSafeToDereference", ")", "{", "// Get the arguments that were originally made to the \"request\" method", "var", "requestArgs", "=", "queue", "[", "i", "]", ";", "// Call the request method again in the context of the socket, with the original args", "socket", ".", "request", ".", "apply", "(", "socket", ",", "requestArgs", ")", ";", "}", "}", "// Now empty the queue to remove it as a source of additional complexity.", "socket", ".", "requestQueue", "=", "null", ";", "}"], "docstring": "What is the `requestQueue`?\n\nThe request queue is used to simplify app-level connection logic--\ni.e. so you don't have to wait for the socket to be connected\nto start trying to  synchronize data.\n\n@api private\n@param  {SailsSocket}  socket", "docstring_tokens": ["What", "is", "the", "requestQueue", "?"], "sha": "640a51cc1cbf47487e20172524e9efbb765cdf25", "url": "https://github.com/acalvoa/sails-hook-multitenant/blob/640a51cc1cbf47487e20172524e9efbb765cdf25/examples/assets/dependencies/sails.io.js#L464-L485", "partition": "test"}
{"repo": "zdfs/grunt-datadriver", "path": "tasks/datadriver.js", "func_name": "", "original_string": "function(callback) {\n                grunt.log.debug('run mocha tests');\n\n                /**\n                 * save session ID\n                 */\n                sessionID = GLOBAL.browser.requestHandler.sessionID;\n\n                mocha.run(next(callback));\n            }", "language": "javascript", "code": "function(callback) {\n                grunt.log.debug('run mocha tests');\n\n                /**\n                 * save session ID\n                 */\n                sessionID = GLOBAL.browser.requestHandler.sessionID;\n\n                mocha.run(next(callback));\n            }", "code_tokens": ["function", "(", "callback", ")", "{", "grunt", ".", "log", ".", "debug", "(", "'run mocha tests'", ")", ";", "/**\n                 * save session ID\n                 */", "sessionID", "=", "GLOBAL", ".", "browser", ".", "requestHandler", ".", "sessionID", ";", "mocha", ".", "run", "(", "next", "(", "callback", ")", ")", ";", "}"], "docstring": "run mocha tests", "docstring_tokens": ["run", "mocha", "tests"], "sha": "8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e", "url": "https://github.com/zdfs/grunt-datadriver/blob/8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e/tasks/datadriver.js#L274-L283", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/branches.js", "func_name": "create", "original_string": "function create(repositoryState, driver, name, opts = {}) {\n    const {\n        // Base branch for the new branch\n        base = repositoryState.getCurrentBranch(),\n        // Fetch the working state and switch to it ?\n        checkout = true,\n        // Drop changes from base branch the new working state ?\n        clean = true,\n        // Drop changes from the base branch ?\n        cleanBase = false\n    } = opts;\n\n    let createdBranch;\n\n    return driver.createBranch(base, name)\n    // Update list of branches\n    .then((branch) => {\n        createdBranch = branch;\n        let branches = repositoryState.getBranches();\n        branches = branches.push(createdBranch);\n        return repositoryState.set('branches', branches);\n    })\n\n    // Update working state or fetch it if needed\n    .then((repoState) => {\n        let baseWk = repoState.getWorkingStateForBranch(base);\n\n        if (!baseWk) {\n            return checkout ? RepoUtils.fetchTree(repoState, driver, createdBranch) : repoState;\n        }\n\n        // Reuse base WorkingState clean\n        const headWk = clean ? baseWk.asClean() : baseWk;\n        repoState = RepoUtils.updateWorkingState(repoState, createdBranch, headWk);\n\n        // Clean base WorkingState\n        baseWk = cleanBase ? baseWk.asClean() : baseWk;\n        repoState = RepoUtils.updateWorkingState(repoState, base, baseWk);\n\n        return repoState;\n    })\n\n    // Checkout the branch\n    .then((repoState) => {\n        if (!checkout) {\n            return repoState;\n        }\n\n        return RepoUtils.checkout(repoState, createdBranch);\n    });\n}", "language": "javascript", "code": "function create(repositoryState, driver, name, opts = {}) {\n    const {\n        // Base branch for the new branch\n        base = repositoryState.getCurrentBranch(),\n        // Fetch the working state and switch to it ?\n        checkout = true,\n        // Drop changes from base branch the new working state ?\n        clean = true,\n        // Drop changes from the base branch ?\n        cleanBase = false\n    } = opts;\n\n    let createdBranch;\n\n    return driver.createBranch(base, name)\n    // Update list of branches\n    .then((branch) => {\n        createdBranch = branch;\n        let branches = repositoryState.getBranches();\n        branches = branches.push(createdBranch);\n        return repositoryState.set('branches', branches);\n    })\n\n    // Update working state or fetch it if needed\n    .then((repoState) => {\n        let baseWk = repoState.getWorkingStateForBranch(base);\n\n        if (!baseWk) {\n            return checkout ? RepoUtils.fetchTree(repoState, driver, createdBranch) : repoState;\n        }\n\n        // Reuse base WorkingState clean\n        const headWk = clean ? baseWk.asClean() : baseWk;\n        repoState = RepoUtils.updateWorkingState(repoState, createdBranch, headWk);\n\n        // Clean base WorkingState\n        baseWk = cleanBase ? baseWk.asClean() : baseWk;\n        repoState = RepoUtils.updateWorkingState(repoState, base, baseWk);\n\n        return repoState;\n    })\n\n    // Checkout the branch\n    .then((repoState) => {\n        if (!checkout) {\n            return repoState;\n        }\n\n        return RepoUtils.checkout(repoState, createdBranch);\n    });\n}", "code_tokens": ["function", "create", "(", "repositoryState", ",", "driver", ",", "name", ",", "opts", "=", "{", "}", ")", "{", "const", "{", "// Base branch for the new branch", "base", "=", "repositoryState", ".", "getCurrentBranch", "(", ")", ",", "// Fetch the working state and switch to it ?", "checkout", "=", "true", ",", "// Drop changes from base branch the new working state ?", "clean", "=", "true", ",", "// Drop changes from the base branch ?", "cleanBase", "=", "false", "}", "=", "opts", ";", "let", "createdBranch", ";", "return", "driver", ".", "createBranch", "(", "base", ",", "name", ")", "// Update list of branches", ".", "then", "(", "(", "branch", ")", "=>", "{", "createdBranch", "=", "branch", ";", "let", "branches", "=", "repositoryState", ".", "getBranches", "(", ")", ";", "branches", "=", "branches", ".", "push", "(", "createdBranch", ")", ";", "return", "repositoryState", ".", "set", "(", "'branches'", ",", "branches", ")", ";", "}", ")", "// Update working state or fetch it if needed", ".", "then", "(", "(", "repoState", ")", "=>", "{", "let", "baseWk", "=", "repoState", ".", "getWorkingStateForBranch", "(", "base", ")", ";", "if", "(", "!", "baseWk", ")", "{", "return", "checkout", "?", "RepoUtils", ".", "fetchTree", "(", "repoState", ",", "driver", ",", "createdBranch", ")", ":", "repoState", ";", "}", "// Reuse base WorkingState clean", "const", "headWk", "=", "clean", "?", "baseWk", ".", "asClean", "(", ")", ":", "baseWk", ";", "repoState", "=", "RepoUtils", ".", "updateWorkingState", "(", "repoState", ",", "createdBranch", ",", "headWk", ")", ";", "// Clean base WorkingState", "baseWk", "=", "cleanBase", "?", "baseWk", ".", "asClean", "(", ")", ":", "baseWk", ";", "repoState", "=", "RepoUtils", ".", "updateWorkingState", "(", "repoState", ",", "base", ",", "baseWk", ")", ";", "return", "repoState", ";", "}", ")", "// Checkout the branch", ".", "then", "(", "(", "repoState", ")", "=>", "{", "if", "(", "!", "checkout", ")", "{", "return", "repoState", ";", "}", "return", "RepoUtils", ".", "checkout", "(", "repoState", ",", "createdBranch", ")", ";", "}", ")", ";", "}"], "docstring": "Create a new branch with the given name.\n@param {RepositoryState} repoState\n@param {Driver} driver\n@param {String} name\n@param {Branch} [opts.base] Base branch, default to current branch\n@param {Boolean} [opts.checkout=false] Directly fetch and checkout the branch\n@return {Promise<RepositoryState>}", "docstring_tokens": ["Create", "a", "new", "branch", "with", "the", "given", "name", "."], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/branches.js#L13-L63", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/core/class/Loader.js", "func_name": "", "original_string": "function(url, onLoad, onError, scope, synchronous) {\n            var me = this,\n                isFileLoaded = this.isFileLoaded,\n                scriptElements = this.scriptElements,\n                noCacheUrl = url + (this.getConfig('disableCaching') ? ('?' + this.getConfig('disableCachingParam') + '=' + Ext.Date.now()) : ''),\n                xhr, status, content, onScriptError;\n\n            if (isFileLoaded[url]) {\n                return this;\n            }\n\n            scope = scope || this;\n\n            this.isLoading = true;\n\n            if (!synchronous) {\n                onScriptError = function() {\n                    //<debug error>\n                    onError.call(scope, \"Failed loading '\" + url + \"', please verify that the file exists\", synchronous);\n                    //</debug>\n                };\n\n                if (!Ext.isReady && Ext.onDocumentReady) {\n                    Ext.onDocumentReady(function() {\n                        if (!isFileLoaded[url]) {\n                            scriptElements[url] = me.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);\n                        }\n                    });\n                }\n                else {\n                    scriptElements[url] = this.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);\n                }\n            }\n            else {\n                if (typeof XMLHttpRequest != 'undefined') {\n                    xhr = new XMLHttpRequest();\n                } else {\n                    xhr = new ActiveXObject('Microsoft.XMLHTTP');\n                }\n\n                try {\n                    xhr.open('GET', noCacheUrl, false);\n                    xhr.send(null);\n                }\n                catch (e) {\n                    //<debug error>\n                    onError.call(this, \"Failed loading synchronously via XHR: '\" + url + \"'; It's likely that the file is either \" +\n                                       \"being loaded from a different domain or from the local file system whereby cross origin \" +\n                                       \"requests are not allowed due to security reasons. Use asynchronous loading with \" +\n                                       \"Ext.require instead.\", synchronous);\n                    //</debug>\n                }\n\n                status = (xhr.status == 1223) ? 204 : xhr.status;\n                content = xhr.responseText;\n\n                if ((status >= 200 && status < 300) || status == 304 || (status == 0 && content.length > 0)) {\n                    // Debugger friendly, file names are still shown even though they're eval'ed code\n                    // Breakpoints work on both Firebug and Chrome's Web Inspector\n                    Ext.globalEval(content + \"\\n//@ sourceURL=\" + url);\n                    onLoad.call(scope);\n                }\n                else {\n                    //<debug>\n                    onError.call(this, \"Failed loading synchronously via XHR: '\" + url + \"'; please \" +\n                                       \"verify that the file exists. \" +\n                                       \"XHR status code: \" + status, synchronous);\n                    //</debug>\n                }\n\n                // Prevent potential IE memory leak\n                xhr = null;\n            }\n        }", "language": "javascript", "code": "function(url, onLoad, onError, scope, synchronous) {\n            var me = this,\n                isFileLoaded = this.isFileLoaded,\n                scriptElements = this.scriptElements,\n                noCacheUrl = url + (this.getConfig('disableCaching') ? ('?' + this.getConfig('disableCachingParam') + '=' + Ext.Date.now()) : ''),\n                xhr, status, content, onScriptError;\n\n            if (isFileLoaded[url]) {\n                return this;\n            }\n\n            scope = scope || this;\n\n            this.isLoading = true;\n\n            if (!synchronous) {\n                onScriptError = function() {\n                    //<debug error>\n                    onError.call(scope, \"Failed loading '\" + url + \"', please verify that the file exists\", synchronous);\n                    //</debug>\n                };\n\n                if (!Ext.isReady && Ext.onDocumentReady) {\n                    Ext.onDocumentReady(function() {\n                        if (!isFileLoaded[url]) {\n                            scriptElements[url] = me.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);\n                        }\n                    });\n                }\n                else {\n                    scriptElements[url] = this.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);\n                }\n            }\n            else {\n                if (typeof XMLHttpRequest != 'undefined') {\n                    xhr = new XMLHttpRequest();\n                } else {\n                    xhr = new ActiveXObject('Microsoft.XMLHTTP');\n                }\n\n                try {\n                    xhr.open('GET', noCacheUrl, false);\n                    xhr.send(null);\n                }\n                catch (e) {\n                    //<debug error>\n                    onError.call(this, \"Failed loading synchronously via XHR: '\" + url + \"'; It's likely that the file is either \" +\n                                       \"being loaded from a different domain or from the local file system whereby cross origin \" +\n                                       \"requests are not allowed due to security reasons. Use asynchronous loading with \" +\n                                       \"Ext.require instead.\", synchronous);\n                    //</debug>\n                }\n\n                status = (xhr.status == 1223) ? 204 : xhr.status;\n                content = xhr.responseText;\n\n                if ((status >= 200 && status < 300) || status == 304 || (status == 0 && content.length > 0)) {\n                    // Debugger friendly, file names are still shown even though they're eval'ed code\n                    // Breakpoints work on both Firebug and Chrome's Web Inspector\n                    Ext.globalEval(content + \"\\n//@ sourceURL=\" + url);\n                    onLoad.call(scope);\n                }\n                else {\n                    //<debug>\n                    onError.call(this, \"Failed loading synchronously via XHR: '\" + url + \"'; please \" +\n                                       \"verify that the file exists. \" +\n                                       \"XHR status code: \" + status, synchronous);\n                    //</debug>\n                }\n\n                // Prevent potential IE memory leak\n                xhr = null;\n            }\n        }", "code_tokens": ["function", "(", "url", ",", "onLoad", ",", "onError", ",", "scope", ",", "synchronous", ")", "{", "var", "me", "=", "this", ",", "isFileLoaded", "=", "this", ".", "isFileLoaded", ",", "scriptElements", "=", "this", ".", "scriptElements", ",", "noCacheUrl", "=", "url", "+", "(", "this", ".", "getConfig", "(", "'disableCaching'", ")", "?", "(", "'?'", "+", "this", ".", "getConfig", "(", "'disableCachingParam'", ")", "+", "'='", "+", "Ext", ".", "Date", ".", "now", "(", ")", ")", ":", "''", ")", ",", "xhr", ",", "status", ",", "content", ",", "onScriptError", ";", "if", "(", "isFileLoaded", "[", "url", "]", ")", "{", "return", "this", ";", "}", "scope", "=", "scope", "||", "this", ";", "this", ".", "isLoading", "=", "true", ";", "if", "(", "!", "synchronous", ")", "{", "onScriptError", "=", "function", "(", ")", "{", "//<debug error>", "onError", ".", "call", "(", "scope", ",", "\"Failed loading '\"", "+", "url", "+", "\"', please verify that the file exists\"", ",", "synchronous", ")", ";", "//</debug>", "}", ";", "if", "(", "!", "Ext", ".", "isReady", "&&", "Ext", ".", "onDocumentReady", ")", "{", "Ext", ".", "onDocumentReady", "(", "function", "(", ")", "{", "if", "(", "!", "isFileLoaded", "[", "url", "]", ")", "{", "scriptElements", "[", "url", "]", "=", "me", ".", "injectScriptElement", "(", "noCacheUrl", ",", "onLoad", ",", "onScriptError", ",", "scope", ")", ";", "}", "}", ")", ";", "}", "else", "{", "scriptElements", "[", "url", "]", "=", "this", ".", "injectScriptElement", "(", "noCacheUrl", ",", "onLoad", ",", "onScriptError", ",", "scope", ")", ";", "}", "}", "else", "{", "if", "(", "typeof", "XMLHttpRequest", "!=", "'undefined'", ")", "{", "xhr", "=", "new", "XMLHttpRequest", "(", ")", ";", "}", "else", "{", "xhr", "=", "new", "ActiveXObject", "(", "'Microsoft.XMLHTTP'", ")", ";", "}", "try", "{", "xhr", ".", "open", "(", "'GET'", ",", "noCacheUrl", ",", "false", ")", ";", "xhr", ".", "send", "(", "null", ")", ";", "}", "catch", "(", "e", ")", "{", "//<debug error>", "onError", ".", "call", "(", "this", ",", "\"Failed loading synchronously via XHR: '\"", "+", "url", "+", "\"'; It's likely that the file is either \"", "+", "\"being loaded from a different domain or from the local file system whereby cross origin \"", "+", "\"requests are not allowed due to security reasons. Use asynchronous loading with \"", "+", "\"Ext.require instead.\"", ",", "synchronous", ")", ";", "//</debug>", "}", "status", "=", "(", "xhr", ".", "status", "==", "1223", ")", "?", "204", ":", "xhr", ".", "status", ";", "content", "=", "xhr", ".", "responseText", ";", "if", "(", "(", "status", ">=", "200", "&&", "status", "<", "300", ")", "||", "status", "==", "304", "||", "(", "status", "==", "0", "&&", "content", ".", "length", ">", "0", ")", ")", "{", "// Debugger friendly, file names are still shown even though they're eval'ed code", "// Breakpoints work on both Firebug and Chrome's Web Inspector", "Ext", ".", "globalEval", "(", "content", "+", "\"\\n//@ sourceURL=\"", "+", "url", ")", ";", "onLoad", ".", "call", "(", "scope", ")", ";", "}", "else", "{", "//<debug>", "onError", ".", "call", "(", "this", ",", "\"Failed loading synchronously via XHR: '\"", "+", "url", "+", "\"'; please \"", "+", "\"verify that the file exists. \"", "+", "\"XHR status code: \"", "+", "status", ",", "synchronous", ")", ";", "//</debug>", "}", "// Prevent potential IE memory leak", "xhr", "=", "null", ";", "}", "}"], "docstring": "Load a script file, supports both asynchronous and synchronous approaches\n@private", "docstring_tokens": ["Load", "a", "script", "file", "supports", "both", "asynchronous", "and", "synchronous", "approaches"], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/core/class/Loader.js#L643-L716", "partition": "test"}
{"repo": "everitoken/evtjs", "path": "src/ecc/key_utils.js", "func_name": "random32ByteBuffer", "original_string": "function random32ByteBuffer({cpuEntropyBits = 0, safe = true} = {}) {\n    assert.equal(typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\");\n    assert.equal(typeof safe, \"boolean\", \"boolean\");\n\n    if(safe) {\n        assert(entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\");\n    }\n\n    // if(entropyCount > 0) {\n    //     console.log(`Additional private key entropy: ${entropyCount} events`)\n    // }\n\n    const hash_array = [];\n    hash_array.push(randomBytes(32));\n    hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\n    hash_array.push(externalEntropyArray);\n    hash_array.push(browserEntropy());\n    return hash.sha256(Buffer.concat(hash_array));\n}", "language": "javascript", "code": "function random32ByteBuffer({cpuEntropyBits = 0, safe = true} = {}) {\n    assert.equal(typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\");\n    assert.equal(typeof safe, \"boolean\", \"boolean\");\n\n    if(safe) {\n        assert(entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\");\n    }\n\n    // if(entropyCount > 0) {\n    //     console.log(`Additional private key entropy: ${entropyCount} events`)\n    // }\n\n    const hash_array = [];\n    hash_array.push(randomBytes(32));\n    hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\n    hash_array.push(externalEntropyArray);\n    hash_array.push(browserEntropy());\n    return hash.sha256(Buffer.concat(hash_array));\n}", "code_tokens": ["function", "random32ByteBuffer", "(", "{", "cpuEntropyBits", "=", "0", ",", "safe", "=", "true", "}", "=", "{", "}", ")", "{", "assert", ".", "equal", "(", "typeof", "cpuEntropyBits", ",", "\"number\"", ",", "\"cpuEntropyBits\"", ")", ";", "assert", ".", "equal", "(", "typeof", "safe", ",", "\"boolean\"", ",", "\"boolean\"", ")", ";", "if", "(", "safe", ")", "{", "assert", "(", "entropyCount", ">=", "128", ",", "\"Call initialize() to add entropy (current: \"", "+", "entropyCount", "+", "\")\"", ")", ";", "}", "// if(entropyCount > 0) {", "//     console.log(`Additional private key entropy: ${entropyCount} events`)", "// }", "const", "hash_array", "=", "[", "]", ";", "hash_array", ".", "push", "(", "randomBytes", "(", "32", ")", ")", ";", "hash_array", ".", "push", "(", "Buffer", ".", "from", "(", "cpuEntropy", "(", "cpuEntropyBits", ")", ")", ")", ";", "hash_array", ".", "push", "(", "externalEntropyArray", ")", ";", "hash_array", ".", "push", "(", "browserEntropy", "(", ")", ")", ";", "return", "hash", ".", "sha256", "(", "Buffer", ".", "concat", "(", "hash_array", ")", ")", ";", "}"], "docstring": "Additional forms of entropy are used.  A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.\n\n@arg {number} [cpuEntropyBits = 0] generate entropy on the fly.  This is\nnot required, entropy can be added in advanced via addEntropy or initialize().\n\n@arg {boolean} [safe = true] false for testing, otherwise this will be\ntrue to ensure initialize() was called.\n\n@return a random buffer obtained from the secure random number generator.  Additional entropy is used.", "docstring_tokens": ["Additional", "forms", "of", "entropy", "are", "used", ".", "A", "week", "random", "number", "generator", "can", "run", "out", "of", "entropy", ".", "This", "should", "ensure", "even", "the", "worst", "random", "number", "implementation", "will", "be", "reasonably", "safe", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/key_utils.js#L32-L50", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "matcher", "original_string": "function matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  }\n  // pattern is a regex\n  if (pattern instanceof RegExp) {\n    return function(fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  }\n\n  // strings, all the way down...\n  pattern = utils.unixify(pattern, opts);\n\n  // pattern is a non-glob string\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  }\n  // pattern is a glob string\n  var re = makeRe(pattern, opts);\n\n  // `matchBase` is defined\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  }\n  // `matchBase` is not defined\n  return function(fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}", "language": "javascript", "code": "function matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  }\n  // pattern is a regex\n  if (pattern instanceof RegExp) {\n    return function(fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  }\n\n  // strings, all the way down...\n  pattern = utils.unixify(pattern, opts);\n\n  // pattern is a non-glob string\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  }\n  // pattern is a glob string\n  var re = makeRe(pattern, opts);\n\n  // `matchBase` is defined\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  }\n  // `matchBase` is not defined\n  return function(fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}", "code_tokens": ["function", "matcher", "(", "pattern", ",", "opts", ")", "{", "// pattern is a function", "if", "(", "typeof", "pattern", "===", "'function'", ")", "{", "return", "pattern", ";", "}", "// pattern is a regex", "if", "(", "pattern", "instanceof", "RegExp", ")", "{", "return", "function", "(", "fp", ")", "{", "return", "pattern", ".", "test", "(", "fp", ")", ";", "}", ";", "}", "if", "(", "typeof", "pattern", "!==", "'string'", ")", "{", "throw", "new", "TypeError", "(", "msg", "(", "'matcher'", ",", "'pattern'", ",", "'a string, regex, or function'", ")", ")", ";", "}", "// strings, all the way down...", "pattern", "=", "utils", ".", "unixify", "(", "pattern", ",", "opts", ")", ";", "// pattern is a non-glob string", "if", "(", "!", "utils", ".", "isGlob", "(", "pattern", ")", ")", "{", "return", "utils", ".", "matchPath", "(", "pattern", ",", "opts", ")", ";", "}", "// pattern is a glob string", "var", "re", "=", "makeRe", "(", "pattern", ",", "opts", ")", ";", "// `matchBase` is defined", "if", "(", "opts", "&&", "opts", ".", "matchBase", ")", "{", "return", "utils", ".", "hasFilename", "(", "re", ",", "opts", ")", ";", "}", "// `matchBase` is not defined", "return", "function", "(", "fp", ")", "{", "fp", "=", "utils", ".", "unixify", "(", "fp", ",", "opts", ")", ";", "return", "re", ".", "test", "(", "fp", ")", ";", "}", ";", "}"], "docstring": "Return a function for matching based on the\ngiven `pattern` and `options`.\n\n@param  {String} `pattern`\n@param  {Object} `options`\n@return {Function}", "docstring_tokens": ["Return", "a", "function", "for", "matching", "based", "on", "the", "given", "pattern", "and", "options", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L42315-L42350", "partition": "test"}
{"repo": "fomeboy/agency", "path": "lib/journal.js", "func_name": "logCreationEvent", "original_string": "function logCreationEvent(id, type, message, time) {\n    \n    if (logMode === 'l') {\n      if (!eventList.creationEvents[id]) {\n        eventList.creationEvents[id] =  [];\n      }\n      eventList.creationEvents[id].push({'type': type, 'event': message, \"timestamp\": time});\n    } else if (logMode === 'v') {\n      console.log(type + ': Agent ' + id +  ' ' + message + ' on ' + time);\n    }\n\n  }", "language": "javascript", "code": "function logCreationEvent(id, type, message, time) {\n    \n    if (logMode === 'l') {\n      if (!eventList.creationEvents[id]) {\n        eventList.creationEvents[id] =  [];\n      }\n      eventList.creationEvents[id].push({'type': type, 'event': message, \"timestamp\": time});\n    } else if (logMode === 'v') {\n      console.log(type + ': Agent ' + id +  ' ' + message + ' on ' + time);\n    }\n\n  }", "code_tokens": ["function", "logCreationEvent", "(", "id", ",", "type", ",", "message", ",", "time", ")", "{", "if", "(", "logMode", "===", "'l'", ")", "{", "if", "(", "!", "eventList", ".", "creationEvents", "[", "id", "]", ")", "{", "eventList", ".", "creationEvents", "[", "id", "]", "=", "[", "]", ";", "}", "eventList", ".", "creationEvents", "[", "id", "]", ".", "push", "(", "{", "'type'", ":", "type", ",", "'event'", ":", "message", ",", "\"timestamp\"", ":", "time", "}", ")", ";", "}", "else", "if", "(", "logMode", "===", "'v'", ")", "{", "console", ".", "log", "(", "type", "+", "': Agent '", "+", "id", "+", "' '", "+", "message", "+", "' on '", "+", "time", ")", ";", "}", "}"], "docstring": "records the agent's validation and creation events in a temporary structure if log method is 'l' or outputs the same events to the console if method is 'v'", "docstring_tokens": ["records", "the", "agent", "s", "validation", "and", "creation", "events", "in", "a", "temporary", "structure", "if", "log", "method", "is", "l", "or", "outputs", "the", "same", "events", "to", "the", "console", "if", "method", "is", "v"], "sha": "9a04b031142d5d44b09757444b899662b1d93b48", "url": "https://github.com/fomeboy/agency/blob/9a04b031142d5d44b09757444b899662b1d93b48/lib/journal.js#L40-L51", "partition": "test"}
{"repo": "commonform-archive/commonform-serve", "path": "routes/post.js", "func_name": "batchForms", "original_string": "function batchForms(batch, form, merkle) {\n  // Use commonform-stringify to produce the text to be stored.\n  var stringified = stringify(form)\n  var digest = merkle.digest\n  batch.put(digest, stringified)\n  // Recurse children.\n  form.content\n    .forEach(function(element, index) {\n      if (isChild(element)) {\n        var childForm = element.form\n        var childMerkle = merkle.content[index]\n        batchForms(batch, childForm, childMerkle) } }) }", "language": "javascript", "code": "function batchForms(batch, form, merkle) {\n  // Use commonform-stringify to produce the text to be stored.\n  var stringified = stringify(form)\n  var digest = merkle.digest\n  batch.put(digest, stringified)\n  // Recurse children.\n  form.content\n    .forEach(function(element, index) {\n      if (isChild(element)) {\n        var childForm = element.form\n        var childMerkle = merkle.content[index]\n        batchForms(batch, childForm, childMerkle) } }) }", "code_tokens": ["function", "batchForms", "(", "batch", ",", "form", ",", "merkle", ")", "{", "// Use commonform-stringify to produce the text to be stored.", "var", "stringified", "=", "stringify", "(", "form", ")", "var", "digest", "=", "merkle", ".", "digest", "batch", ".", "put", "(", "digest", ",", "stringified", ")", "// Recurse children.", "form", ".", "content", ".", "forEach", "(", "function", "(", "element", ",", "index", ")", "{", "if", "(", "isChild", "(", "element", ")", ")", "{", "var", "childForm", "=", "element", ".", "form", "var", "childMerkle", "=", "merkle", ".", "content", "[", "index", "]", "batchForms", "(", "batch", ",", "childForm", ",", "childMerkle", ")", "}", "}", ")", "}"], "docstring": "Given a new LevelUp chain-style batch, a denormalized Common Form, and the output of commonform-merkleize for that Common Form, add LevelUp put operations to the batch for the Common Form and each of its children.", "docstring_tokens": ["Given", "a", "new", "LevelUp", "chain", "-", "style", "batch", "a", "denormalized", "Common", "Form", "and", "the", "output", "of", "commonform", "-", "merkleize", "for", "that", "Common", "Form", "add", "LevelUp", "put", "operations", "to", "the", "batch", "for", "the", "Common", "Form", "and", "each", "of", "its", "children", "."], "sha": "b7ff827ba9b0262cfa9fb3f149c27203934eb00a", "url": "https://github.com/commonform-archive/commonform-serve/blob/b7ff827ba9b0262cfa9fb3f149c27203934eb00a/routes/post.js#L86-L97", "partition": "test"}
{"repo": "lps-js/lps.js", "path": "src/LPS.js", "func_name": "createProgramArgsUpdaterFunc", "original_string": "function createProgramArgsUpdaterFunc(programArgs) {\n  return (program) => {\n    let programArgsFact = buildProgramArgsPredicate(programArgs);\n    program.getFacts().add(programArgsFact);\n    return Promise.resolve(program);\n  };\n}", "language": "javascript", "code": "function createProgramArgsUpdaterFunc(programArgs) {\n  return (program) => {\n    let programArgsFact = buildProgramArgsPredicate(programArgs);\n    program.getFacts().add(programArgsFact);\n    return Promise.resolve(program);\n  };\n}", "code_tokens": ["function", "createProgramArgsUpdaterFunc", "(", "programArgs", ")", "{", "return", "(", "program", ")", "=>", "{", "let", "programArgsFact", "=", "buildProgramArgsPredicate", "(", "programArgs", ")", ";", "program", ".", "getFacts", "(", ")", ".", "add", "(", "programArgsFact", ")", ";", "return", "Promise", ".", "resolve", "(", "program", ")", ";", "}", ";", "}"], "docstring": "Create a function to update a given program with the given program arguments\n@param  {array} programArgs Array of program arguments\n@return {[type]}             [description]", "docstring_tokens": ["Create", "a", "function", "to", "update", "a", "given", "program", "with", "the", "given", "program", "arguments"], "sha": "f91fd5c5e738be909dea7996cb05014c716664d3", "url": "https://github.com/lps-js/lps.js/blob/f91fd5c5e738be909dea7996cb05014c716664d3/src/LPS.js#L72-L78", "partition": "test"}
{"repo": "alexisvincent/systemjs-hot-reloader", "path": "dist/index.js", "func_name": "Backoff$1", "original_string": "function Backoff$1(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}", "language": "javascript", "code": "function Backoff$1(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}", "code_tokens": ["function", "Backoff$1", "(", "opts", ")", "{", "opts", "=", "opts", "||", "{", "}", ";", "this", ".", "ms", "=", "opts", ".", "min", "||", "100", ";", "this", ".", "max", "=", "opts", ".", "max", "||", "10000", ";", "this", ".", "factor", "=", "opts", ".", "factor", "||", "2", ";", "this", ".", "jitter", "=", "opts", ".", "jitter", ">", "0", "&&", "opts", ".", "jitter", "<=", "1", "?", "opts", ".", "jitter", ":", "0", ";", "this", ".", "attempts", "=", "0", ";", "}"], "docstring": "Initialize backoff timer with `opts`.\n\n- `min` initial timeout in milliseconds [100]\n- `max` max timeout [10000]\n- `jitter` [0]\n- `factor` [2]\n\n@param {Object} opts\n@api public", "docstring_tokens": ["Initialize", "backoff", "timer", "with", "opts", "."], "sha": "e3cca45a50e69cba4c1988a251ef07f460c27619", "url": "https://github.com/alexisvincent/systemjs-hot-reloader/blob/e3cca45a50e69cba4c1988a251ef07f460c27619/dist/index.js#L7536-L7543", "partition": "test"}
{"repo": "GeoSensorWebLab/polarmap.js", "path": "js/leaflet.markercluster.js", "func_name": "", "original_string": "function () {\n    var bounds = new L.LatLngBounds();\n\n    if (this._topClusterLevel) {\n      bounds.extend(this._topClusterLevel._bounds);\n    }\n\n    for (var i = this._needsClustering.length - 1; i >= 0; i--) {\n      bounds.extend(this._needsClustering[i].getLatLng());\n    }\n\n    bounds.extend(this._nonPointGroup.getBounds());\n\n    return bounds;\n  }", "language": "javascript", "code": "function () {\n    var bounds = new L.LatLngBounds();\n\n    if (this._topClusterLevel) {\n      bounds.extend(this._topClusterLevel._bounds);\n    }\n\n    for (var i = this._needsClustering.length - 1; i >= 0; i--) {\n      bounds.extend(this._needsClustering[i].getLatLng());\n    }\n\n    bounds.extend(this._nonPointGroup.getBounds());\n\n    return bounds;\n  }", "code_tokens": ["function", "(", ")", "{", "var", "bounds", "=", "new", "L", ".", "LatLngBounds", "(", ")", ";", "if", "(", "this", ".", "_topClusterLevel", ")", "{", "bounds", ".", "extend", "(", "this", ".", "_topClusterLevel", ".", "_bounds", ")", ";", "}", "for", "(", "var", "i", "=", "this", ".", "_needsClustering", ".", "length", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "bounds", ".", "extend", "(", "this", ".", "_needsClustering", "[", "i", "]", ".", "getLatLng", "(", ")", ")", ";", "}", "bounds", ".", "extend", "(", "this", ".", "_nonPointGroup", ".", "getBounds", "(", ")", ")", ";", "return", "bounds", ";", "}"], "docstring": "Override FeatureGroup.getBounds as it doesn't work", "docstring_tokens": ["Override", "FeatureGroup", ".", "getBounds", "as", "it", "doesn", "t", "work"], "sha": "fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b", "url": "https://github.com/GeoSensorWebLab/polarmap.js/blob/fa1e87d0082f5d6ae0981b0c5dd80ed18e7f611b/js/leaflet.markercluster.js#L330-L344", "partition": "test"}
{"repo": "italia/bootstrap-italia", "path": "src/js/plugins/password-strength-meter/password-strength-meter.js", "func_name": "checkRepetition", "original_string": "function checkRepetition(rLen, str) {\n      var res = '',\n        repeated = false\n      for (var i = 0; i < str.length; i++) {\n        repeated = true\n        for (var j = 0; j < rLen && j + i + rLen < str.length; j++) {\n          repeated = repeated && str.charAt(j + i) === str.charAt(j + i + rLen)\n        }\n        if (j < rLen) {\n          repeated = false\n        }\n        if (repeated) {\n          i += rLen - 1\n          repeated = false\n        } else {\n          res += str.charAt(i)\n        }\n      }\n      return res\n    }", "language": "javascript", "code": "function checkRepetition(rLen, str) {\n      var res = '',\n        repeated = false\n      for (var i = 0; i < str.length; i++) {\n        repeated = true\n        for (var j = 0; j < rLen && j + i + rLen < str.length; j++) {\n          repeated = repeated && str.charAt(j + i) === str.charAt(j + i + rLen)\n        }\n        if (j < rLen) {\n          repeated = false\n        }\n        if (repeated) {\n          i += rLen - 1\n          repeated = false\n        } else {\n          res += str.charAt(i)\n        }\n      }\n      return res\n    }", "code_tokens": ["function", "checkRepetition", "(", "rLen", ",", "str", ")", "{", "var", "res", "=", "''", ",", "repeated", "=", "false", "for", "(", "var", "i", "=", "0", ";", "i", "<", "str", ".", "length", ";", "i", "++", ")", "{", "repeated", "=", "true", "for", "(", "var", "j", "=", "0", ";", "j", "<", "rLen", "&&", "j", "+", "i", "+", "rLen", "<", "str", ".", "length", ";", "j", "++", ")", "{", "repeated", "=", "repeated", "&&", "str", ".", "charAt", "(", "j", "+", "i", ")", "===", "str", ".", "charAt", "(", "j", "+", "i", "+", "rLen", ")", "}", "if", "(", "j", "<", "rLen", ")", "{", "repeated", "=", "false", "}", "if", "(", "repeated", ")", "{", "i", "+=", "rLen", "-", "1", "repeated", "=", "false", "}", "else", "{", "res", "+=", "str", ".", "charAt", "(", "i", ")", "}", "}", "return", "res", "}"], "docstring": "Checks for repetition of characters in\na string\n\n@param int rLen Repetition length.\n@param string str The string to be checked.\n@return string", "docstring_tokens": ["Checks", "for", "repetition", "of", "characters", "in", "a", "string"], "sha": "9d2177a1c0c731f83636d2164bd22702ef5767c2", "url": "https://github.com/italia/bootstrap-italia/blob/9d2177a1c0c731f83636d2164bd22702ef5767c2/src/js/plugins/password-strength-meter/password-strength-meter.js#L154-L173", "partition": "test"}
{"repo": "Mikhus/gulp-help-doc", "path": "index.js", "func_name": "chunk", "original_string": "function chunk(str, maxLen) {\n    var len  = maxLen || OPTIONS.lineWidth;\n    var curr = len;\n    var prev = 0;\n    var out  = [];\n\n    while (str[curr]) {\n        if (str[curr++] == ' ') {\n            out.push(str.substring(prev, curr));\n            prev = curr;\n            curr += len;\n        }\n    }\n\n    out.push(str.substr(prev));\n\n    return out;\n}", "language": "javascript", "code": "function chunk(str, maxLen) {\n    var len  = maxLen || OPTIONS.lineWidth;\n    var curr = len;\n    var prev = 0;\n    var out  = [];\n\n    while (str[curr]) {\n        if (str[curr++] == ' ') {\n            out.push(str.substring(prev, curr));\n            prev = curr;\n            curr += len;\n        }\n    }\n\n    out.push(str.substr(prev));\n\n    return out;\n}", "code_tokens": ["function", "chunk", "(", "str", ",", "maxLen", ")", "{", "var", "len", "=", "maxLen", "||", "OPTIONS", ".", "lineWidth", ";", "var", "curr", "=", "len", ";", "var", "prev", "=", "0", ";", "var", "out", "=", "[", "]", ";", "while", "(", "str", "[", "curr", "]", ")", "{", "if", "(", "str", "[", "curr", "++", "]", "==", "' '", ")", "{", "out", ".", "push", "(", "str", ".", "substring", "(", "prev", ",", "curr", ")", ")", ";", "prev", "=", "curr", ";", "curr", "+=", "len", ";", "}", "}", "out", ".", "push", "(", "str", ".", "substr", "(", "prev", ")", ")", ";", "return", "out", ";", "}"], "docstring": "Chunks given string into pieces making each chunk less or equal to\nOPTIONS.lineWidth, taking into account safe word-break\n\n@param {string} str\n@param {number} maxLen\n@returns {Array}\n@access private", "docstring_tokens": ["Chunks", "given", "string", "into", "pieces", "making", "each", "chunk", "less", "or", "equal", "to", "OPTIONS", ".", "lineWidth", "taking", "into", "account", "safe", "word", "-", "break"], "sha": "e00fb0dbd347a72b35b5395827900f9e8c460240", "url": "https://github.com/Mikhus/gulp-help-doc/blob/e00fb0dbd347a72b35b5395827900f9e8c460240/index.js#L228-L245", "partition": "test"}
{"repo": "GitbookIO/repofs", "path": "src/utils/change.js", "func_name": "revertForFile", "original_string": "function revertForFile(repoState, filePath) {\n    let workingState = repoState.getCurrentState();\n\n    // Remove file from changes map\n    const changes = workingState.getChanges().delete(filePath);\n\n    // Update workingState and repoState\n    workingState = workingState.set('changes', changes);\n    return RepoUtils.updateCurrentWorkingState(repoState, workingState);\n}", "language": "javascript", "code": "function revertForFile(repoState, filePath) {\n    let workingState = repoState.getCurrentState();\n\n    // Remove file from changes map\n    const changes = workingState.getChanges().delete(filePath);\n\n    // Update workingState and repoState\n    workingState = workingState.set('changes', changes);\n    return RepoUtils.updateCurrentWorkingState(repoState, workingState);\n}", "code_tokens": ["function", "revertForFile", "(", "repoState", ",", "filePath", ")", "{", "let", "workingState", "=", "repoState", ".", "getCurrentState", "(", ")", ";", "// Remove file from changes map", "const", "changes", "=", "workingState", ".", "getChanges", "(", ")", ".", "delete", "(", "filePath", ")", ";", "// Update workingState and repoState", "workingState", "=", "workingState", ".", "set", "(", "'changes'", ",", "changes", ")", ";", "return", "RepoUtils", ".", "updateCurrentWorkingState", "(", "repoState", ",", "workingState", ")", ";", "}"], "docstring": "Revert change for a specific file\n@param {RepositoryState}\n@param {Path}\n@return {RepositoryState}", "docstring_tokens": ["Revert", "change", "for", "a", "specific", "file"], "sha": "24f9880f3abb5aae4e4be56d0e88ba9d214447be", "url": "https://github.com/GitbookIO/repofs/blob/24f9880f3abb5aae4e4be56d0e88ba9d214447be/src/utils/change.js#L74-L83", "partition": "test"}
{"repo": "scttnlsn/monq", "path": "lib/worker.js", "func_name": "Worker", "original_string": "function Worker(queues, options) {\n    options || (options = {});\n\n    this.empty = 0;\n    this.queues = queues || [];\n    this.interval = options.interval || 5000;\n\n    this.callbacks = options.callbacks || {};\n    this.strategies = options.strategies || {};\n    this.universal = options.universal || false;\n\n    // Default retry strategies\n    this.strategies.linear || (this.strategies.linear = linear);\n    this.strategies.exponential || (this.strategies.exponential = exponential);\n\n    // This worker will only process jobs of this priority or higher\n    this.minPriority = options.minPriority;\n\n}", "language": "javascript", "code": "function Worker(queues, options) {\n    options || (options = {});\n\n    this.empty = 0;\n    this.queues = queues || [];\n    this.interval = options.interval || 5000;\n\n    this.callbacks = options.callbacks || {};\n    this.strategies = options.strategies || {};\n    this.universal = options.universal || false;\n\n    // Default retry strategies\n    this.strategies.linear || (this.strategies.linear = linear);\n    this.strategies.exponential || (this.strategies.exponential = exponential);\n\n    // This worker will only process jobs of this priority or higher\n    this.minPriority = options.minPriority;\n\n}", "code_tokens": ["function", "Worker", "(", "queues", ",", "options", ")", "{", "options", "||", "(", "options", "=", "{", "}", ")", ";", "this", ".", "empty", "=", "0", ";", "this", ".", "queues", "=", "queues", "||", "[", "]", ";", "this", ".", "interval", "=", "options", ".", "interval", "||", "5000", ";", "this", ".", "callbacks", "=", "options", ".", "callbacks", "||", "{", "}", ";", "this", ".", "strategies", "=", "options", ".", "strategies", "||", "{", "}", ";", "this", ".", "universal", "=", "options", ".", "universal", "||", "false", ";", "// Default retry strategies", "this", ".", "strategies", ".", "linear", "||", "(", "this", ".", "strategies", ".", "linear", "=", "linear", ")", ";", "this", ".", "strategies", ".", "exponential", "||", "(", "this", ".", "strategies", ".", "exponential", "=", "exponential", ")", ";", "// This worker will only process jobs of this priority or higher", "this", ".", "minPriority", "=", "options", ".", "minPriority", ";", "}"], "docstring": "Options for a new worker\n@typedef {Object} Worker~Options\n@property {Number} interval - the polling interval for the worker. Note: The worker will process jobs, one at a time, as fast as possible while queues have waiting jobs\n@property {Worker~Strategies} strategies - {@link Worker~Strategies} for retrying jobs\n@property {Worker~Callbacks} callbacks - Map of {@link Worker~Callback} for processing jobs\n@property {Number} minPriority - The lowest job priority the worker will process\n \n@constructor\n@param {string[]} queues - an array of queue names that this worker will listen for\n@param {Worker~Options} options - {@link Worker~Options} Options object", "docstring_tokens": ["Options", "for", "a", "new", "worker"], "sha": "3067be74e5f26c0fbfecaeaf32a0250febafa1a6", "url": "https://github.com/scttnlsn/monq/blob/3067be74e5f26c0fbfecaeaf32a0250febafa1a6/lib/worker.js#L21-L39", "partition": "test"}
{"repo": "zeit/next.js", "path": "packages/next/client/dev-error-overlay/hot-dev-client.js", "func_name": "processMessage", "original_string": "function processMessage (e) {\n  const obj = JSON.parse(e.data)\n  switch (obj.action) {\n    case 'building': {\n      console.log(\n        '[HMR] bundle ' + (obj.name ? \"'\" + obj.name + \"' \" : '') +\n        'rebuilding'\n      )\n      break\n    }\n    case 'built':\n    case 'sync': {\n      clearOutdatedErrors()\n\n      if (obj.hash) {\n        handleAvailableHash(obj.hash)\n      }\n\n      if (obj.warnings.length > 0) {\n        handleWarnings(obj.warnings)\n      }\n\n      if (obj.errors.length > 0) {\n        // When there is a compilation error coming from SSR we have to reload the page on next successful compile\n        if (obj.action === 'sync') {\n          hadRuntimeError = true\n        }\n        handleErrors(obj.errors)\n        break\n      }\n\n      handleSuccess()\n      break\n    }\n    default: {\n      if (customHmrEventHandler) {\n        customHmrEventHandler(obj)\n        break\n      }\n      break\n    }\n  }\n}", "language": "javascript", "code": "function processMessage (e) {\n  const obj = JSON.parse(e.data)\n  switch (obj.action) {\n    case 'building': {\n      console.log(\n        '[HMR] bundle ' + (obj.name ? \"'\" + obj.name + \"' \" : '') +\n        'rebuilding'\n      )\n      break\n    }\n    case 'built':\n    case 'sync': {\n      clearOutdatedErrors()\n\n      if (obj.hash) {\n        handleAvailableHash(obj.hash)\n      }\n\n      if (obj.warnings.length > 0) {\n        handleWarnings(obj.warnings)\n      }\n\n      if (obj.errors.length > 0) {\n        // When there is a compilation error coming from SSR we have to reload the page on next successful compile\n        if (obj.action === 'sync') {\n          hadRuntimeError = true\n        }\n        handleErrors(obj.errors)\n        break\n      }\n\n      handleSuccess()\n      break\n    }\n    default: {\n      if (customHmrEventHandler) {\n        customHmrEventHandler(obj)\n        break\n      }\n      break\n    }\n  }\n}", "code_tokens": ["function", "processMessage", "(", "e", ")", "{", "const", "obj", "=", "JSON", ".", "parse", "(", "e", ".", "data", ")", "switch", "(", "obj", ".", "action", ")", "{", "case", "'building'", ":", "{", "console", ".", "log", "(", "'[HMR] bundle '", "+", "(", "obj", ".", "name", "?", "\"'\"", "+", "obj", ".", "name", "+", "\"' \"", ":", "''", ")", "+", "'rebuilding'", ")", "break", "}", "case", "'built'", ":", "case", "'sync'", ":", "{", "clearOutdatedErrors", "(", ")", "if", "(", "obj", ".", "hash", ")", "{", "handleAvailableHash", "(", "obj", ".", "hash", ")", "}", "if", "(", "obj", ".", "warnings", ".", "length", ">", "0", ")", "{", "handleWarnings", "(", "obj", ".", "warnings", ")", "}", "if", "(", "obj", ".", "errors", ".", "length", ">", "0", ")", "{", "// When there is a compilation error coming from SSR we have to reload the page on next successful compile", "if", "(", "obj", ".", "action", "===", "'sync'", ")", "{", "hadRuntimeError", "=", "true", "}", "handleErrors", "(", "obj", ".", "errors", ")", "break", "}", "handleSuccess", "(", ")", "break", "}", "default", ":", "{", "if", "(", "customHmrEventHandler", ")", "{", "customHmrEventHandler", "(", "obj", ")", "break", "}", "break", "}", "}", "}"], "docstring": "Handle messages from the server.", "docstring_tokens": ["Handle", "messages", "from", "the", "server", "."], "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd", "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/hot-dev-client.js#L202-L244", "partition": "test"}
{"repo": "nearform/nscale-kernel", "path": "lib/api.js", "func_name": "", "original_string": "function(user, identifier, comment, out, cb) {\n    logger.info('compile system: ' + identifier);\n    var systemId = _sr.findSystem(identifier);\n    var system;\n\n    if (!systemId) { logger.error(ERR_NOSYSID); return cb(new Error(ERR_NOSYSID)); }\n\n    var repoPath = _sr.repoPath(systemId);\n    _compiler.compile(systemId, repoPath, out, function(err, systems) {\n      if (err) { return cb(err); }\n      async.eachSeries(_.keys(systems), function(key, next) {\n          system = systems[key];\n          _sr.writeFile(system.id, key + '.json', JSON.stringify(system, null, 2), next);\n        },\n        function(err) {\n          cb(err);\n        });\n    });\n  }", "language": "javascript", "code": "function(user, identifier, comment, out, cb) {\n    logger.info('compile system: ' + identifier);\n    var systemId = _sr.findSystem(identifier);\n    var system;\n\n    if (!systemId) { logger.error(ERR_NOSYSID); return cb(new Error(ERR_NOSYSID)); }\n\n    var repoPath = _sr.repoPath(systemId);\n    _compiler.compile(systemId, repoPath, out, function(err, systems) {\n      if (err) { return cb(err); }\n      async.eachSeries(_.keys(systems), function(key, next) {\n          system = systems[key];\n          _sr.writeFile(system.id, key + '.json', JSON.stringify(system, null, 2), next);\n        },\n        function(err) {\n          cb(err);\n        });\n    });\n  }", "code_tokens": ["function", "(", "user", ",", "identifier", ",", "comment", ",", "out", ",", "cb", ")", "{", "logger", ".", "info", "(", "'compile system: '", "+", "identifier", ")", ";", "var", "systemId", "=", "_sr", ".", "findSystem", "(", "identifier", ")", ";", "var", "system", ";", "if", "(", "!", "systemId", ")", "{", "logger", ".", "error", "(", "ERR_NOSYSID", ")", ";", "return", "cb", "(", "new", "Error", "(", "ERR_NOSYSID", ")", ")", ";", "}", "var", "repoPath", "=", "_sr", ".", "repoPath", "(", "systemId", ")", ";", "_compiler", ".", "compile", "(", "systemId", ",", "repoPath", ",", "out", ",", "function", "(", "err", ",", "systems", ")", "{", "if", "(", "err", ")", "{", "return", "cb", "(", "err", ")", ";", "}", "async", ".", "eachSeries", "(", "_", ".", "keys", "(", "systems", ")", ",", "function", "(", "key", ",", "next", ")", "{", "system", "=", "systems", "[", "key", "]", ";", "_sr", ".", "writeFile", "(", "system", ".", "id", ",", "key", "+", "'.json'", ",", "JSON", ".", "stringify", "(", "system", ",", "null", ",", "2", ")", ",", "next", ")", ";", "}", ",", "function", "(", "err", ")", "{", "cb", "(", "err", ")", ";", "}", ")", ";", "}", ")", ";", "}"], "docstring": "compile the system into the various targets and commit them to the repository", "docstring_tokens": ["compile", "the", "system", "into", "the", "various", "targets", "and", "commit", "them", "to", "the", "repository"], "sha": "5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3", "url": "https://github.com/nearform/nscale-kernel/blob/5b9a544a6f2ffdc87294fee3fd00b81667ac0ab3/lib/api.js#L629-L647", "partition": "test"}
{"repo": "neptunejs/react-parcoords", "path": "d3.parcoords.js", "func_name": "selected", "original_string": "function selected() {\n            var actives = d3.keys(__.dimensions).filter(is_brushed),\n                extents = actives.map(function(p) { return brushes[p].extent(); });\n\n            // We don't want to return the full data set when there are no axes brushed.\n            // Actually, when there are no axes brushed, by definition, no items are\n            // selected. So, let's avoid the filtering and just return false.\n            //if (actives.length === 0) return false;\n\n            // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n            if (actives.length === 0) return __.data;\n\n            // test if within range\n            var within = {\n                \"date\": function(d,p,dimension) {\n                    if (typeof __.dimensions[p].yscale.rangePoints === \"function\") { // if it is ordinal\n                        return extents[dimension][0] <= __.dimensions[p].yscale(d[p]) && __.dimensions[p].yscale(d[p]) <= extents[dimension][1]\n                    } else {\n                        return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]\n                    }\n                },\n                \"number\": function(d,p,dimension) {\n                    if (typeof __.dimensions[p].yscale.rangePoints === \"function\") { // if it is ordinal\n                        return extents[dimension][0] <= __.dimensions[p].yscale(d[p]) && __.dimensions[p].yscale(d[p]) <= extents[dimension][1]\n                    } else {\n                        return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]\n                    }\n                },\n                \"string\": function(d,p,dimension) {\n                    return extents[dimension][0] <= __.dimensions[p].yscale(d[p]) && __.dimensions[p].yscale(d[p]) <= extents[dimension][1]\n                }\n            };\n\n            return __.data\n                .filter(function(d) {\n                    switch(brush.predicate) {\n                        case \"AND\":\n                            return actives.every(function(p, dimension) {\n                                return within[__.dimensions[p].type](d,p,dimension);\n                            });\n                        case \"OR\":\n                            return actives.some(function(p, dimension) {\n                                return within[__.dimensions[p].type](d,p,dimension);\n                            });\n                        default:\n                            throw new Error(\"Unknown brush predicate \" + __.brushPredicate);\n                    }\n                });\n        }", "language": "javascript", "code": "function selected() {\n            var actives = d3.keys(__.dimensions).filter(is_brushed),\n                extents = actives.map(function(p) { return brushes[p].extent(); });\n\n            // We don't want to return the full data set when there are no axes brushed.\n            // Actually, when there are no axes brushed, by definition, no items are\n            // selected. So, let's avoid the filtering and just return false.\n            //if (actives.length === 0) return false;\n\n            // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n            if (actives.length === 0) return __.data;\n\n            // test if within range\n            var within = {\n                \"date\": function(d,p,dimension) {\n                    if (typeof __.dimensions[p].yscale.rangePoints === \"function\") { // if it is ordinal\n                        return extents[dimension][0] <= __.dimensions[p].yscale(d[p]) && __.dimensions[p].yscale(d[p]) <= extents[dimension][1]\n                    } else {\n                        return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]\n                    }\n                },\n                \"number\": function(d,p,dimension) {\n                    if (typeof __.dimensions[p].yscale.rangePoints === \"function\") { // if it is ordinal\n                        return extents[dimension][0] <= __.dimensions[p].yscale(d[p]) && __.dimensions[p].yscale(d[p]) <= extents[dimension][1]\n                    } else {\n                        return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]\n                    }\n                },\n                \"string\": function(d,p,dimension) {\n                    return extents[dimension][0] <= __.dimensions[p].yscale(d[p]) && __.dimensions[p].yscale(d[p]) <= extents[dimension][1]\n                }\n            };\n\n            return __.data\n                .filter(function(d) {\n                    switch(brush.predicate) {\n                        case \"AND\":\n                            return actives.every(function(p, dimension) {\n                                return within[__.dimensions[p].type](d,p,dimension);\n                            });\n                        case \"OR\":\n                            return actives.some(function(p, dimension) {\n                                return within[__.dimensions[p].type](d,p,dimension);\n                            });\n                        default:\n                            throw new Error(\"Unknown brush predicate \" + __.brushPredicate);\n                    }\n                });\n        }", "code_tokens": ["function", "selected", "(", ")", "{", "var", "actives", "=", "d3", ".", "keys", "(", "__", ".", "dimensions", ")", ".", "filter", "(", "is_brushed", ")", ",", "extents", "=", "actives", ".", "map", "(", "function", "(", "p", ")", "{", "return", "brushes", "[", "p", "]", ".", "extent", "(", ")", ";", "}", ")", ";", "// We don't want to return the full data set when there are no axes brushed.", "// Actually, when there are no axes brushed, by definition, no items are", "// selected. So, let's avoid the filtering and just return false.", "//if (actives.length === 0) return false;", "// Resolves broken examples for now. They expect to get the full dataset back from empty brushes", "if", "(", "actives", ".", "length", "===", "0", ")", "return", "__", ".", "data", ";", "// test if within range", "var", "within", "=", "{", "\"date\"", ":", "function", "(", "d", ",", "p", ",", "dimension", ")", "{", "if", "(", "typeof", "__", ".", "dimensions", "[", "p", "]", ".", "yscale", ".", "rangePoints", "===", "\"function\"", ")", "{", "// if it is ordinal", "return", "extents", "[", "dimension", "]", "[", "0", "]", "<=", "__", ".", "dimensions", "[", "p", "]", ".", "yscale", "(", "d", "[", "p", "]", ")", "&&", "__", ".", "dimensions", "[", "p", "]", ".", "yscale", "(", "d", "[", "p", "]", ")", "<=", "extents", "[", "dimension", "]", "[", "1", "]", "}", "else", "{", "return", "extents", "[", "dimension", "]", "[", "0", "]", "<=", "d", "[", "p", "]", "&&", "d", "[", "p", "]", "<=", "extents", "[", "dimension", "]", "[", "1", "]", "}", "}", ",", "\"number\"", ":", "function", "(", "d", ",", "p", ",", "dimension", ")", "{", "if", "(", "typeof", "__", ".", "dimensions", "[", "p", "]", ".", "yscale", ".", "rangePoints", "===", "\"function\"", ")", "{", "// if it is ordinal", "return", "extents", "[", "dimension", "]", "[", "0", "]", "<=", "__", ".", "dimensions", "[", "p", "]", ".", "yscale", "(", "d", "[", "p", "]", ")", "&&", "__", ".", "dimensions", "[", "p", "]", ".", "yscale", "(", "d", "[", "p", "]", ")", "<=", "extents", "[", "dimension", "]", "[", "1", "]", "}", "else", "{", "return", "extents", "[", "dimension", "]", "[", "0", "]", "<=", "d", "[", "p", "]", "&&", "d", "[", "p", "]", "<=", "extents", "[", "dimension", "]", "[", "1", "]", "}", "}", ",", "\"string\"", ":", "function", "(", "d", ",", "p", ",", "dimension", ")", "{", "return", "extents", "[", "dimension", "]", "[", "0", "]", "<=", "__", ".", "dimensions", "[", "p", "]", ".", "yscale", "(", "d", "[", "p", "]", ")", "&&", "__", ".", "dimensions", "[", "p", "]", ".", "yscale", "(", "d", "[", "p", "]", ")", "<=", "extents", "[", "dimension", "]", "[", "1", "]", "}", "}", ";", "return", "__", ".", "data", ".", "filter", "(", "function", "(", "d", ")", "{", "switch", "(", "brush", ".", "predicate", ")", "{", "case", "\"AND\"", ":", "return", "actives", ".", "every", "(", "function", "(", "p", ",", "dimension", ")", "{", "return", "within", "[", "__", ".", "dimensions", "[", "p", "]", ".", "type", "]", "(", "d", ",", "p", ",", "dimension", ")", ";", "}", ")", ";", "case", "\"OR\"", ":", "return", "actives", ".", "some", "(", "function", "(", "p", ",", "dimension", ")", "{", "return", "within", "[", "__", ".", "dimensions", "[", "p", "]", ".", "type", "]", "(", "d", ",", "p", ",", "dimension", ")", ";", "}", ")", ";", "default", ":", "throw", "new", "Error", "(", "\"Unknown brush predicate \"", "+", "__", ".", "brushPredicate", ")", ";", "}", "}", ")", ";", "}"], "docstring": "data within extents", "docstring_tokens": ["data", "within", "extents"], "sha": "e784bb05ab5aaf56ee8e54e7255b874a1f16d1d1", "url": "https://github.com/neptunejs/react-parcoords/blob/e784bb05ab5aaf56ee8e54e7255b874a1f16d1d1/d3.parcoords.js#L1157-L1205", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(view, childView, options) {\n    var buffer = view.buffer, _childViews = view._childViews;\n\n    childView = view.createChildView(childView, options);\n    if (!_childViews.length) { _childViews = view._childViews = _childViews.slice(); }\n    _childViews.push(childView);\n\n    childView.renderToBuffer(buffer);\n\n    view.propertyDidChange('childViews');\n\n    return childView;\n  }", "language": "javascript", "code": "function(view, childView, options) {\n    var buffer = view.buffer, _childViews = view._childViews;\n\n    childView = view.createChildView(childView, options);\n    if (!_childViews.length) { _childViews = view._childViews = _childViews.slice(); }\n    _childViews.push(childView);\n\n    childView.renderToBuffer(buffer);\n\n    view.propertyDidChange('childViews');\n\n    return childView;\n  }", "code_tokens": ["function", "(", "view", ",", "childView", ",", "options", ")", "{", "var", "buffer", "=", "view", ".", "buffer", ",", "_childViews", "=", "view", ".", "_childViews", ";", "childView", "=", "view", ".", "createChildView", "(", "childView", ",", "options", ")", ";", "if", "(", "!", "_childViews", ".", "length", ")", "{", "_childViews", "=", "view", ".", "_childViews", "=", "_childViews", ".", "slice", "(", ")", ";", "}", "_childViews", ".", "push", "(", "childView", ")", ";", "childView", ".", "renderToBuffer", "(", "buffer", ")", ";", "view", ".", "propertyDidChange", "(", "'childViews'", ")", ";", "return", "childView", ";", "}"], "docstring": "when a view is rendered in a buffer, appending a child view will render that view and append the resulting buffer into its buffer.", "docstring_tokens": ["when", "a", "view", "is", "rendered", "in", "a", "buffer", "appending", "a", "child", "view", "will", "render", "that", "view", "and", "append", "the", "resulting", "buffer", "into", "its", "buffer", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L25007-L25019", "partition": "test"}
{"repo": "ipfs/js-datastore-core", "path": "src/shard.js", "func_name": "parseShardFun", "original_string": "function parseShardFun (str /* : string */) /* : ShardV1 */ {\n  str = str.trim()\n\n  if (str.length === 0) {\n    throw new Error('empty shard string')\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`)\n  }\n\n  const parts = str.slice(PREFIX.length).split('/')\n  const version = parts[0]\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`)\n  }\n\n  const name = parts[1]\n\n  if (!parts[2]) {\n    throw new Error('missing param')\n  }\n\n  const param = parseInt(parts[2], 10)\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param)\n    case 'suffix':\n      return new Suffix(param)\n    case 'next-to-last':\n      return new NextToLast(param)\n    default:\n      throw new Error(`unkown sharding function: ${name}`)\n  }\n}", "language": "javascript", "code": "function parseShardFun (str /* : string */) /* : ShardV1 */ {\n  str = str.trim()\n\n  if (str.length === 0) {\n    throw new Error('empty shard string')\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`)\n  }\n\n  const parts = str.slice(PREFIX.length).split('/')\n  const version = parts[0]\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`)\n  }\n\n  const name = parts[1]\n\n  if (!parts[2]) {\n    throw new Error('missing param')\n  }\n\n  const param = parseInt(parts[2], 10)\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param)\n    case 'suffix':\n      return new Suffix(param)\n    case 'next-to-last':\n      return new NextToLast(param)\n    default:\n      throw new Error(`unkown sharding function: ${name}`)\n  }\n}", "code_tokens": ["function", "parseShardFun", "(", "str", "/* : string */", ")", "/* : ShardV1 */", "{", "str", "=", "str", ".", "trim", "(", ")", "if", "(", "str", ".", "length", "===", "0", ")", "{", "throw", "new", "Error", "(", "'empty shard string'", ")", "}", "if", "(", "!", "str", ".", "startsWith", "(", "PREFIX", ")", ")", "{", "throw", "new", "Error", "(", "`", "${", "str", "}", "`", ")", "}", "const", "parts", "=", "str", ".", "slice", "(", "PREFIX", ".", "length", ")", ".", "split", "(", "'/'", ")", "const", "version", "=", "parts", "[", "0", "]", "if", "(", "version", "!==", "'v1'", ")", "{", "throw", "new", "Error", "(", "`", "${", "version", "}", "`", ")", "}", "const", "name", "=", "parts", "[", "1", "]", "if", "(", "!", "parts", "[", "2", "]", ")", "{", "throw", "new", "Error", "(", "'missing param'", ")", "}", "const", "param", "=", "parseInt", "(", "parts", "[", "2", "]", ",", "10", ")", "switch", "(", "name", ")", "{", "case", "'prefix'", ":", "return", "new", "Prefix", "(", "param", ")", "case", "'suffix'", ":", "return", "new", "Suffix", "(", "param", ")", "case", "'next-to-last'", ":", "return", "new", "NextToLast", "(", "param", ")", "default", ":", "throw", "new", "Error", "(", "`", "${", "name", "}", "`", ")", "}", "}"], "docstring": "Convert a given string to the matching sharding function.\n\n@param {string} str\n@returns {ShardV1}", "docstring_tokens": ["Convert", "a", "given", "string", "to", "the", "matching", "sharding", "function", "."], "sha": "60de9e4f61f96503bbe589a42755ee9b24f961d0", "url": "https://github.com/ipfs/js-datastore-core/blob/60de9e4f61f96503bbe589a42755ee9b24f961d0/src/shard.js#L87-L123", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/dataview/DataView.js", "func_name": "", "original_string": "function() {\n        var me = this,\n            container = me.container;\n\n        if (!me.getStore()) {\n            if (!me.hasLoadedStore && !me.getDeferEmptyText()) {\n                me.showEmptyText();\n            }\n            return;\n        }\n        if (container) {\n            me.fireAction('refresh', [me], 'doRefresh');\n        }\n    }", "language": "javascript", "code": "function() {\n        var me = this,\n            container = me.container;\n\n        if (!me.getStore()) {\n            if (!me.hasLoadedStore && !me.getDeferEmptyText()) {\n                me.showEmptyText();\n            }\n            return;\n        }\n        if (container) {\n            me.fireAction('refresh', [me], 'doRefresh');\n        }\n    }", "code_tokens": ["function", "(", ")", "{", "var", "me", "=", "this", ",", "container", "=", "me", ".", "container", ";", "if", "(", "!", "me", ".", "getStore", "(", ")", ")", "{", "if", "(", "!", "me", ".", "hasLoadedStore", "&&", "!", "me", ".", "getDeferEmptyText", "(", ")", ")", "{", "me", ".", "showEmptyText", "(", ")", ";", "}", "return", ";", "}", "if", "(", "container", ")", "{", "me", ".", "fireAction", "(", "'refresh'", ",", "[", "me", "]", ",", "'doRefresh'", ")", ";", "}", "}"], "docstring": "Refreshes the view by reloading the data from the store and re-rendering the template.", "docstring_tokens": ["Refreshes", "the", "view", "by", "reloading", "the", "data", "from", "the", "store", "and", "re", "-", "rendering", "the", "template", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/dataview/DataView.js#L884-L897", "partition": "test"}
{"repo": "bigeasy/strata", "path": "benchmark/murmur3.js", "func_name": "fmix32", "original_string": "function fmix32 (hash) {\n    hash ^= hash >>> 16\n    hash = multiply(hash, 0x85ebca6b)\n    hash ^= hash >>> 13\n    hash = multiply(hash, 0xc2b2ae35)\n    hash ^= hash >>> 16\n    return hash\n}", "language": "javascript", "code": "function fmix32 (hash) {\n    hash ^= hash >>> 16\n    hash = multiply(hash, 0x85ebca6b)\n    hash ^= hash >>> 13\n    hash = multiply(hash, 0xc2b2ae35)\n    hash ^= hash >>> 16\n    return hash\n}", "code_tokens": ["function", "fmix32", "(", "hash", ")", "{", "hash", "^=", "hash", ">>>", "16", "hash", "=", "multiply", "(", "hash", ",", "0x85ebca6b", ")", "hash", "^=", "hash", ">>>", "13", "hash", "=", "multiply", "(", "hash", ",", "0xc2b2ae35", ")", "hash", "^=", "hash", ">>>", "16", "return", "hash", "}"], "docstring": "We don't use `>>> 0`. We let the values negate. The only use of addition in Murmur uses the result of a multiplication, which will be converted to unsigned integer by our 16-bit at a time multiplication.", "docstring_tokens": ["We", "don", "t", "use", ">>>", "0", ".", "We", "let", "the", "values", "negate", ".", "The", "only", "use", "of", "addition", "in", "Murmur", "uses", "the", "result", "of", "a", "multiplication", "which", "will", "be", "converted", "to", "unsigned", "integer", "by", "our", "16", "-", "bit", "at", "a", "time", "multiplication", "."], "sha": "76bc8cc38de0fc7eb7fad3c0c59dbe4d253ed35a", "url": "https://github.com/bigeasy/strata/blob/76bc8cc38de0fc7eb7fad3c0c59dbe4d253ed35a/benchmark/murmur3.js#L19-L26", "partition": "test"}
{"repo": "openstyles/stylelint-bundle", "path": "stylelint-bundle-worker.js", "func_name": "", "original_string": "function(input) {\n    if (typeof input !== 'string') {\n      throw new TypeError('expected a string');\n    }\n\n    this.init(this.options);\n    this.orig = input;\n    this.input = input;\n    var self = this;\n\n    function parse() {\n      // check input before calling `.next()`\n      input = self.input;\n\n      // get the next AST ndoe\n      var node = self.next();\n      if (node) {\n        var prev = self.prev();\n        if (prev) {\n          define(node, 'parent', prev);\n          if (prev.nodes) {\n            prev.nodes.push(node);\n          }\n        }\n\n        if (self.sets.hasOwnProperty(prev.type)) {\n          self.currentType = prev.type;\n        }\n      }\n\n      // if we got here but input is not changed, throw an error\n      if (self.input && input === self.input) {\n        throw new Error('no parsers registered for: \"' + self.input.slice(0, 5) + '\"');\n      }\n    }\n\n    while (this.input) parse();\n    if (this.stack.length && this.options.strict) {\n      var node = this.stack.pop();\n      throw this.error('missing opening ' + node.type + ': \"' + this.orig + '\"');\n    }\n\n    var eos = this.eos();\n    var tok = this.prev();\n    if (tok.type !== 'eos') {\n      this.ast.nodes.push(eos);\n    }\n\n    return this.ast;\n  }", "language": "javascript", "code": "function(input) {\n    if (typeof input !== 'string') {\n      throw new TypeError('expected a string');\n    }\n\n    this.init(this.options);\n    this.orig = input;\n    this.input = input;\n    var self = this;\n\n    function parse() {\n      // check input before calling `.next()`\n      input = self.input;\n\n      // get the next AST ndoe\n      var node = self.next();\n      if (node) {\n        var prev = self.prev();\n        if (prev) {\n          define(node, 'parent', prev);\n          if (prev.nodes) {\n            prev.nodes.push(node);\n          }\n        }\n\n        if (self.sets.hasOwnProperty(prev.type)) {\n          self.currentType = prev.type;\n        }\n      }\n\n      // if we got here but input is not changed, throw an error\n      if (self.input && input === self.input) {\n        throw new Error('no parsers registered for: \"' + self.input.slice(0, 5) + '\"');\n      }\n    }\n\n    while (this.input) parse();\n    if (this.stack.length && this.options.strict) {\n      var node = this.stack.pop();\n      throw this.error('missing opening ' + node.type + ': \"' + this.orig + '\"');\n    }\n\n    var eos = this.eos();\n    var tok = this.prev();\n    if (tok.type !== 'eos') {\n      this.ast.nodes.push(eos);\n    }\n\n    return this.ast;\n  }", "code_tokens": ["function", "(", "input", ")", "{", "if", "(", "typeof", "input", "!==", "'string'", ")", "{", "throw", "new", "TypeError", "(", "'expected a string'", ")", ";", "}", "this", ".", "init", "(", "this", ".", "options", ")", ";", "this", ".", "orig", "=", "input", ";", "this", ".", "input", "=", "input", ";", "var", "self", "=", "this", ";", "function", "parse", "(", ")", "{", "// check input before calling `.next()`", "input", "=", "self", ".", "input", ";", "// get the next AST ndoe", "var", "node", "=", "self", ".", "next", "(", ")", ";", "if", "(", "node", ")", "{", "var", "prev", "=", "self", ".", "prev", "(", ")", ";", "if", "(", "prev", ")", "{", "define", "(", "node", ",", "'parent'", ",", "prev", ")", ";", "if", "(", "prev", ".", "nodes", ")", "{", "prev", ".", "nodes", ".", "push", "(", "node", ")", ";", "}", "}", "if", "(", "self", ".", "sets", ".", "hasOwnProperty", "(", "prev", ".", "type", ")", ")", "{", "self", ".", "currentType", "=", "prev", ".", "type", ";", "}", "}", "// if we got here but input is not changed, throw an error", "if", "(", "self", ".", "input", "&&", "input", "===", "self", ".", "input", ")", "{", "throw", "new", "Error", "(", "'no parsers registered for: \"'", "+", "self", ".", "input", ".", "slice", "(", "0", ",", "5", ")", "+", "'\"'", ")", ";", "}", "}", "while", "(", "this", ".", "input", ")", "parse", "(", ")", ";", "if", "(", "this", ".", "stack", ".", "length", "&&", "this", ".", "options", ".", "strict", ")", "{", "var", "node", "=", "this", ".", "stack", ".", "pop", "(", ")", ";", "throw", "this", ".", "error", "(", "'missing opening '", "+", "node", ".", "type", "+", "': \"'", "+", "this", ".", "orig", "+", "'\"'", ")", ";", "}", "var", "eos", "=", "this", ".", "eos", "(", ")", ";", "var", "tok", "=", "this", ".", "prev", "(", ")", ";", "if", "(", "tok", ".", "type", "!==", "'eos'", ")", "{", "this", ".", "ast", ".", "nodes", ".", "push", "(", "eos", ")", ";", "}", "return", "this", ".", "ast", ";", "}"], "docstring": "Parse the given string.\n@return {Array}", "docstring_tokens": ["Parse", "the", "given", "string", "."], "sha": "9d5712e5f7f779f59cb2a447f281d4b5b606ae96", "url": "https://github.com/openstyles/stylelint-bundle/blob/9d5712e5f7f779f59cb2a447f281d4b5b606ae96/stylelint-bundle-worker.js#L65080-L65129", "partition": "test"}
{"repo": "zdfs/grunt-datadriver", "path": "tasks/datadriver.js", "func_name": "", "original_string": "function(result) {\n                var callback = arguments[arguments.length - 1];\n\n                if (!options.user && !options.key && !options.updateSauceJob) {\n                    return callback(null, result);\n                }\n\n                grunt.log.debug('update job on Sauce Labs');\n                var sauceAccount = new SauceLabs({\n                    username: options.user,\n                    password: options.key\n                });\n\n                sauceAccount.updateJob(sessionID, {\n                    passed: result,\n                    public: true\n                }, next(callback, result));\n            }", "language": "javascript", "code": "function(result) {\n                var callback = arguments[arguments.length - 1];\n\n                if (!options.user && !options.key && !options.updateSauceJob) {\n                    return callback(null, result);\n                }\n\n                grunt.log.debug('update job on Sauce Labs');\n                var sauceAccount = new SauceLabs({\n                    username: options.user,\n                    password: options.key\n                });\n\n                sauceAccount.updateJob(sessionID, {\n                    passed: result,\n                    public: true\n                }, next(callback, result));\n            }", "code_tokens": ["function", "(", "result", ")", "{", "var", "callback", "=", "arguments", "[", "arguments", ".", "length", "-", "1", "]", ";", "if", "(", "!", "options", ".", "user", "&&", "!", "options", ".", "key", "&&", "!", "options", ".", "updateSauceJob", ")", "{", "return", "callback", "(", "null", ",", "result", ")", ";", "}", "grunt", ".", "log", ".", "debug", "(", "'update job on Sauce Labs'", ")", ";", "var", "sauceAccount", "=", "new", "SauceLabs", "(", "{", "username", ":", "options", ".", "user", ",", "password", ":", "options", ".", "key", "}", ")", ";", "sauceAccount", ".", "updateJob", "(", "sessionID", ",", "{", "passed", ":", "result", ",", "public", ":", "true", "}", ",", "next", "(", "callback", ",", "result", ")", ")", ";", "}"], "docstring": "update job on Sauce Labs", "docstring_tokens": ["update", "job", "on", "Sauce", "Labs"], "sha": "8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e", "url": "https://github.com/zdfs/grunt-datadriver/blob/8c08f6dfe10a66c4b02a9a4fe42d4f64cb72354e/tasks/datadriver.js#L319-L336", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(view) {\n    view.clearBuffer();\n    var viewCollection = view._notifyWillDestroyElement();\n    viewCollection.transitionTo('preRender', false);\n\n    return view;\n  }", "language": "javascript", "code": "function(view) {\n    view.clearBuffer();\n    var viewCollection = view._notifyWillDestroyElement();\n    viewCollection.transitionTo('preRender', false);\n\n    return view;\n  }", "code_tokens": ["function", "(", "view", ")", "{", "view", ".", "clearBuffer", "(", ")", ";", "var", "viewCollection", "=", "view", ".", "_notifyWillDestroyElement", "(", ")", ";", "viewCollection", ".", "transitionTo", "(", "'preRender'", ",", "false", ")", ";", "return", "view", ";", "}"], "docstring": "when a view is rendered in a buffer, destroying the element will simply destroy the buffer and put the state back into the preRender state.", "docstring_tokens": ["when", "a", "view", "is", "rendered", "in", "a", "buffer", "destroying", "the", "element", "will", "simply", "destroy", "the", "buffer", "and", "put", "the", "state", "back", "into", "the", "preRender", "state", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L25024-L25030", "partition": "test"}
{"repo": "enhancv/popup-tools", "path": "src/PopupTools.js", "func_name": "popupExecute", "original_string": "function popupExecute(execute, url, name, options, callback) {\n    var popupName = name || defaultPopupName();\n    var popupOptions = optionsResolveCentered(assign({}, defaultOptions, options));\n    var popupCallback = callback || function noop() {};\n    var optionsString = optionsToString(popupOptions);\n    var win = execute(url, popupName, optionsString);\n    var isMessageSent = false;\n    var interval;\n\n    function popupCallbackOnce(err, data) {\n        if (!isMessageSent) {\n            isMessageSent = true;\n            popupCallback(err, data);\n        }\n    }\n\n    function onMessage(message) {\n        var data = message ? message.data : undefined;\n\n        if (data) {\n            popupCallbackOnce(undefined, data);\n            window.removeEventListener(\"message\", onMessage);\n        }\n    }\n\n    window.addEventListener(\"message\", onMessage, false);\n\n    if (win) {\n        interval = setInterval(function closePopupCallback() {\n            if (win == null || win.closed) {\n                setTimeout(function delayWindowClosing() {\n                    clearInterval(interval);\n                    popupCallbackOnce(new Error(\"Popup closed\"));\n                }, 500);\n            }\n        }, 100);\n    } else {\n        popupCallbackOnce(new Error(\"Popup blocked\"));\n    }\n\n    return win;\n}", "language": "javascript", "code": "function popupExecute(execute, url, name, options, callback) {\n    var popupName = name || defaultPopupName();\n    var popupOptions = optionsResolveCentered(assign({}, defaultOptions, options));\n    var popupCallback = callback || function noop() {};\n    var optionsString = optionsToString(popupOptions);\n    var win = execute(url, popupName, optionsString);\n    var isMessageSent = false;\n    var interval;\n\n    function popupCallbackOnce(err, data) {\n        if (!isMessageSent) {\n            isMessageSent = true;\n            popupCallback(err, data);\n        }\n    }\n\n    function onMessage(message) {\n        var data = message ? message.data : undefined;\n\n        if (data) {\n            popupCallbackOnce(undefined, data);\n            window.removeEventListener(\"message\", onMessage);\n        }\n    }\n\n    window.addEventListener(\"message\", onMessage, false);\n\n    if (win) {\n        interval = setInterval(function closePopupCallback() {\n            if (win == null || win.closed) {\n                setTimeout(function delayWindowClosing() {\n                    clearInterval(interval);\n                    popupCallbackOnce(new Error(\"Popup closed\"));\n                }, 500);\n            }\n        }, 100);\n    } else {\n        popupCallbackOnce(new Error(\"Popup blocked\"));\n    }\n\n    return win;\n}", "code_tokens": ["function", "popupExecute", "(", "execute", ",", "url", ",", "name", ",", "options", ",", "callback", ")", "{", "var", "popupName", "=", "name", "||", "defaultPopupName", "(", ")", ";", "var", "popupOptions", "=", "optionsResolveCentered", "(", "assign", "(", "{", "}", ",", "defaultOptions", ",", "options", ")", ")", ";", "var", "popupCallback", "=", "callback", "||", "function", "noop", "(", ")", "{", "}", ";", "var", "optionsString", "=", "optionsToString", "(", "popupOptions", ")", ";", "var", "win", "=", "execute", "(", "url", ",", "popupName", ",", "optionsString", ")", ";", "var", "isMessageSent", "=", "false", ";", "var", "interval", ";", "function", "popupCallbackOnce", "(", "err", ",", "data", ")", "{", "if", "(", "!", "isMessageSent", ")", "{", "isMessageSent", "=", "true", ";", "popupCallback", "(", "err", ",", "data", ")", ";", "}", "}", "function", "onMessage", "(", "message", ")", "{", "var", "data", "=", "message", "?", "message", ".", "data", ":", "undefined", ";", "if", "(", "data", ")", "{", "popupCallbackOnce", "(", "undefined", ",", "data", ")", ";", "window", ".", "removeEventListener", "(", "\"message\"", ",", "onMessage", ")", ";", "}", "}", "window", ".", "addEventListener", "(", "\"message\"", ",", "onMessage", ",", "false", ")", ";", "if", "(", "win", ")", "{", "interval", "=", "setInterval", "(", "function", "closePopupCallback", "(", ")", "{", "if", "(", "win", "==", "null", "||", "win", ".", "closed", ")", "{", "setTimeout", "(", "function", "delayWindowClosing", "(", ")", "{", "clearInterval", "(", "interval", ")", ";", "popupCallbackOnce", "(", "new", "Error", "(", "\"Popup closed\"", ")", ")", ";", "}", ",", "500", ")", ";", "}", "}", ",", "100", ")", ";", "}", "else", "{", "popupCallbackOnce", "(", "new", "Error", "(", "\"Popup blocked\"", ")", ")", ";", "}", "return", "win", ";", "}"], "docstring": "Open a popup using the first argument. Wait for it to close.\nReturns the window object\n\n@param  {Function}\n@param  {String}\n@param  {String}\n@param  {Object}\n@param  {Function}\n@return {Object}", "docstring_tokens": ["Open", "a", "popup", "using", "the", "first", "argument", ".", "Wait", "for", "it", "to", "close", ".", "Returns", "the", "window", "object"], "sha": "772b192920929112164f261c632d6d201a79f15a", "url": "https://github.com/enhancv/popup-tools/blob/772b192920929112164f261c632d6d201a79f15a/src/PopupTools.js#L127-L168", "partition": "test"}
{"repo": "75lb/reduce-without", "path": "lib/reduce-without.js", "func_name": "without", "original_string": "function without (toRemove) {\n  return function (prev, curr) {\n    if (!Array.isArray(prev)) {\n      prev = !testValue(prev, toRemove)\n        ? [ prev ]\n        : []\n    }\n    if (!testValue(curr, toRemove)) prev.push(curr)\n    return prev\n  }\n}", "language": "javascript", "code": "function without (toRemove) {\n  return function (prev, curr) {\n    if (!Array.isArray(prev)) {\n      prev = !testValue(prev, toRemove)\n        ? [ prev ]\n        : []\n    }\n    if (!testValue(curr, toRemove)) prev.push(curr)\n    return prev\n  }\n}", "code_tokens": ["function", "without", "(", "toRemove", ")", "{", "return", "function", "(", "prev", ",", "curr", ")", "{", "if", "(", "!", "Array", ".", "isArray", "(", "prev", ")", ")", "{", "prev", "=", "!", "testValue", "(", "prev", ",", "toRemove", ")", "?", "[", "prev", "]", ":", "[", "]", "}", "if", "(", "!", "testValue", "(", "curr", ",", "toRemove", ")", ")", "prev", ".", "push", "(", "curr", ")", "return", "prev", "}", "}"], "docstring": "Returns a new array with the same content as the input minus the specified values.\n\n@param {any | any[]} - one, or more [test-value](https://github.com/75lb/test-value) queries\n@returns {Array}\n@example\n> [ 1, 2, 3 ].reduce(without(2))\n[ 1, 3 ]\n\n> [ 1, 2, 3 ].reduce(without([ 2, 3 ]))\n[ 1 ]\n\n> data = [\n{ name: \"Dana\", age: 30 },\n{ name: \"Yana\", age: 20 },\n{ name: \"Zhana\", age: 10 }\n]\n> data.reduce(without({ name: /ana/ }))\n[]\n\n@alias module:reduce-without", "docstring_tokens": ["Returns", "a", "new", "array", "with", "the", "same", "content", "as", "the", "input", "minus", "the", "specified", "values", "."], "sha": "ffadbc3dd3334ead18bc35b394aef73be30fb7dc", "url": "https://github.com/75lb/reduce-without/blob/ffadbc3dd3334ead18bc35b394aef73be30fb7dc/lib/reduce-without.js#L33-L43", "partition": "test"}
{"repo": "codemanki/cloudscraper", "path": "lib/sandbox.js", "func_name": "Context", "original_string": "function Context (options) {\n  if (!options) options = { body: '', hostname: '' };\n\n  const body = options.body;\n  const href = 'http://' + options.hostname + '/';\n  const cache = Object.create(null);\n  const keys = [];\n\n  this.atob = function (str) {\n    return Buffer.from(str, 'base64').toString('binary');\n  };\n\n  // Used for eval during onRedirectChallenge\n  this.location = { reload: function () {} };\n\n  this.document = {\n    createElement: function () {\n      return { firstChild: { href: href } };\n    },\n    getElementById: function (id) {\n      if (keys.indexOf(id) === -1) {\n        const re = new RegExp(' id=[\\'\"]?' + id + '[^>]*>([^<]*)');\n        const match = body.match(re);\n\n        keys.push(id);\n        cache[id] = match === null ? match : { innerHTML: match[1] };\n      }\n\n      return cache[id];\n    }\n  };\n}", "language": "javascript", "code": "function Context (options) {\n  if (!options) options = { body: '', hostname: '' };\n\n  const body = options.body;\n  const href = 'http://' + options.hostname + '/';\n  const cache = Object.create(null);\n  const keys = [];\n\n  this.atob = function (str) {\n    return Buffer.from(str, 'base64').toString('binary');\n  };\n\n  // Used for eval during onRedirectChallenge\n  this.location = { reload: function () {} };\n\n  this.document = {\n    createElement: function () {\n      return { firstChild: { href: href } };\n    },\n    getElementById: function (id) {\n      if (keys.indexOf(id) === -1) {\n        const re = new RegExp(' id=[\\'\"]?' + id + '[^>]*>([^<]*)');\n        const match = body.match(re);\n\n        keys.push(id);\n        cache[id] = match === null ? match : { innerHTML: match[1] };\n      }\n\n      return cache[id];\n    }\n  };\n}", "code_tokens": ["function", "Context", "(", "options", ")", "{", "if", "(", "!", "options", ")", "options", "=", "{", "body", ":", "''", ",", "hostname", ":", "''", "}", ";", "const", "body", "=", "options", ".", "body", ";", "const", "href", "=", "'http://'", "+", "options", ".", "hostname", "+", "'/'", ";", "const", "cache", "=", "Object", ".", "create", "(", "null", ")", ";", "const", "keys", "=", "[", "]", ";", "this", ".", "atob", "=", "function", "(", "str", ")", "{", "return", "Buffer", ".", "from", "(", "str", ",", "'base64'", ")", ".", "toString", "(", "'binary'", ")", ";", "}", ";", "// Used for eval during onRedirectChallenge", "this", ".", "location", "=", "{", "reload", ":", "function", "(", ")", "{", "}", "}", ";", "this", ".", "document", "=", "{", "createElement", ":", "function", "(", ")", "{", "return", "{", "firstChild", ":", "{", "href", ":", "href", "}", "}", ";", "}", ",", "getElementById", ":", "function", "(", "id", ")", "{", "if", "(", "keys", ".", "indexOf", "(", "id", ")", "===", "-", "1", ")", "{", "const", "re", "=", "new", "RegExp", "(", "' id=[\\'\"]?'", "+", "id", "+", "'[^>]*>([^<]*)'", ")", ";", "const", "match", "=", "body", ".", "match", "(", "re", ")", ";", "keys", ".", "push", "(", "id", ")", ";", "cache", "[", "id", "]", "=", "match", "===", "null", "?", "match", ":", "{", "innerHTML", ":", "match", "[", "1", "]", "}", ";", "}", "return", "cache", "[", "id", "]", ";", "}", "}", ";", "}"], "docstring": "Global context used to evaluate standard IUAM JS challenge", "docstring_tokens": ["Global", "context", "used", "to", "evaluate", "standard", "IUAM", "JS", "challenge"], "sha": "c5b576af9f918d990d6ccedea07a7e4f837dc88f", "url": "https://github.com/codemanki/cloudscraper/blob/c5b576af9f918d990d6ccedea07a7e4f837dc88f/lib/sandbox.js#L19-L50", "partition": "test"}
{"repo": "typhonjs-node-esdoc/esdoc-plugin-dependency-graphs", "path": "template/html/d3-graph.js", "func_name": "fadeRelatedNodes", "original_string": "function fadeRelatedNodes(targetNode, selected, nodes, links)\n   {\n      var opacity = selected ? 0.1 : 1;\n\n      var elm = findElementByNode('circle', targetNode);\n\n      // Highlight circle\n      elm.classed('selected', opacity < 1);\n\n      // Clean links\n      $('path.link').removeAttr('data-show');\n\n      // Traverse all nodes and set `dimmed` class to nodes that are dimmed / not connected in addition to setting\n      // fill and stroke opacity.\n      nodes.style('stroke-opacity', function(otherNode)\n      {\n         var thisOpacity = isConnected(targetNode, otherNode) ? 1 : opacity;\n\n         this.setAttribute('fill-opacity', thisOpacity);\n         this.setAttribute('stroke-opacity', thisOpacity);\n\n         // Depending on opacity add or remove 'dimmed' class.\n         this.classList[thisOpacity === 1 ? 'remove' : 'add']('dimmed');\n\n         return thisOpacity;\n      });\n\n      // Traverse all links and set `data-show` and `marker-end` for connected links given the `targetNode`.\n      links.style('stroke-opacity', function(otherNode)\n      {\n         if (otherNode.source === targetNode)\n         {\n            // Highlight target / sources of the link\n            var elmNodes = graph.selectAll('.' + formatClassName('node', otherNode.target));\n            elmNodes.attr('fill-opacity', 1);\n            elmNodes.attr('stroke-opacity', 1);\n\n            elmNodes.classed('dimmed', false);\n\n            // Highlight arrows\n            var elmCurrentLink = $('path.link[data-source=' + otherNode.source.index + ']');\n            elmCurrentLink.attr('data-show', true);\n            elmCurrentLink.attr('marker-end', 'url(#regular)');\n\n            return 1;\n         }\n         else\n         {\n            return opacity;\n         }\n      });\n\n      // Modify all links that have not had 'data-show' added above.\n      var elmAllLinks = $('path.link:not([data-show])');\n      elmAllLinks.attr('marker-end', opacity === 1 ? 'url(#regular)' : '');\n   }", "language": "javascript", "code": "function fadeRelatedNodes(targetNode, selected, nodes, links)\n   {\n      var opacity = selected ? 0.1 : 1;\n\n      var elm = findElementByNode('circle', targetNode);\n\n      // Highlight circle\n      elm.classed('selected', opacity < 1);\n\n      // Clean links\n      $('path.link').removeAttr('data-show');\n\n      // Traverse all nodes and set `dimmed` class to nodes that are dimmed / not connected in addition to setting\n      // fill and stroke opacity.\n      nodes.style('stroke-opacity', function(otherNode)\n      {\n         var thisOpacity = isConnected(targetNode, otherNode) ? 1 : opacity;\n\n         this.setAttribute('fill-opacity', thisOpacity);\n         this.setAttribute('stroke-opacity', thisOpacity);\n\n         // Depending on opacity add or remove 'dimmed' class.\n         this.classList[thisOpacity === 1 ? 'remove' : 'add']('dimmed');\n\n         return thisOpacity;\n      });\n\n      // Traverse all links and set `data-show` and `marker-end` for connected links given the `targetNode`.\n      links.style('stroke-opacity', function(otherNode)\n      {\n         if (otherNode.source === targetNode)\n         {\n            // Highlight target / sources of the link\n            var elmNodes = graph.selectAll('.' + formatClassName('node', otherNode.target));\n            elmNodes.attr('fill-opacity', 1);\n            elmNodes.attr('stroke-opacity', 1);\n\n            elmNodes.classed('dimmed', false);\n\n            // Highlight arrows\n            var elmCurrentLink = $('path.link[data-source=' + otherNode.source.index + ']');\n            elmCurrentLink.attr('data-show', true);\n            elmCurrentLink.attr('marker-end', 'url(#regular)');\n\n            return 1;\n         }\n         else\n         {\n            return opacity;\n         }\n      });\n\n      // Modify all links that have not had 'data-show' added above.\n      var elmAllLinks = $('path.link:not([data-show])');\n      elmAllLinks.attr('marker-end', opacity === 1 ? 'url(#regular)' : '');\n   }", "code_tokens": ["function", "fadeRelatedNodes", "(", "targetNode", ",", "selected", ",", "nodes", ",", "links", ")", "{", "var", "opacity", "=", "selected", "?", "0.1", ":", "1", ";", "var", "elm", "=", "findElementByNode", "(", "'circle'", ",", "targetNode", ")", ";", "// Highlight circle", "elm", ".", "classed", "(", "'selected'", ",", "opacity", "<", "1", ")", ";", "// Clean links", "$", "(", "'path.link'", ")", ".", "removeAttr", "(", "'data-show'", ")", ";", "// Traverse all nodes and set `dimmed` class to nodes that are dimmed / not connected in addition to setting", "// fill and stroke opacity.", "nodes", ".", "style", "(", "'stroke-opacity'", ",", "function", "(", "otherNode", ")", "{", "var", "thisOpacity", "=", "isConnected", "(", "targetNode", ",", "otherNode", ")", "?", "1", ":", "opacity", ";", "this", ".", "setAttribute", "(", "'fill-opacity'", ",", "thisOpacity", ")", ";", "this", ".", "setAttribute", "(", "'stroke-opacity'", ",", "thisOpacity", ")", ";", "// Depending on opacity add or remove 'dimmed' class.", "this", ".", "classList", "[", "thisOpacity", "===", "1", "?", "'remove'", ":", "'add'", "]", "(", "'dimmed'", ")", ";", "return", "thisOpacity", ";", "}", ")", ";", "// Traverse all links and set `data-show` and `marker-end` for connected links given the `targetNode`.", "links", ".", "style", "(", "'stroke-opacity'", ",", "function", "(", "otherNode", ")", "{", "if", "(", "otherNode", ".", "source", "===", "targetNode", ")", "{", "// Highlight target / sources of the link", "var", "elmNodes", "=", "graph", ".", "selectAll", "(", "'.'", "+", "formatClassName", "(", "'node'", ",", "otherNode", ".", "target", ")", ")", ";", "elmNodes", ".", "attr", "(", "'fill-opacity'", ",", "1", ")", ";", "elmNodes", ".", "attr", "(", "'stroke-opacity'", ",", "1", ")", ";", "elmNodes", ".", "classed", "(", "'dimmed'", ",", "false", ")", ";", "// Highlight arrows", "var", "elmCurrentLink", "=", "$", "(", "'path.link[data-source='", "+", "otherNode", ".", "source", ".", "index", "+", "']'", ")", ";", "elmCurrentLink", ".", "attr", "(", "'data-show'", ",", "true", ")", ";", "elmCurrentLink", ".", "attr", "(", "'marker-end'", ",", "'url(#regular)'", ")", ";", "return", "1", ";", "}", "else", "{", "return", "opacity", ";", "}", "}", ")", ";", "// Modify all links that have not had 'data-show' added above.", "var", "elmAllLinks", "=", "$", "(", "'path.link:not([data-show])'", ")", ";", "elmAllLinks", ".", "attr", "(", "'marker-end'", ",", "opacity", "===", "1", "?", "'url(#regular)'", ":", "''", ")", ";", "}"], "docstring": "Fades and unfades connected nodes to a given `targetNode`.\n\n@param {object}   targetNode - The target node from which fading occurs / connections are calculated.\n@param {boolean}  selected - Indicates if the fade is in / out; true fades nodes / false un-fades nodes.\n@param {Array}    nodes - An array of all graph nodes.\n@param {Array}    links - An array of all graph links.", "docstring_tokens": ["Fades", "and", "unfades", "connected", "nodes", "to", "a", "given", "targetNode", "."], "sha": "af2d9cabce2d48edd4ad7ed81c722cc27efacb67", "url": "https://github.com/typhonjs-node-esdoc/esdoc-plugin-dependency-graphs/blob/af2d9cabce2d48edd4ad7ed81c722cc27efacb67/template/html/d3-graph.js#L239-L294", "partition": "test"}
{"repo": "GitbookIO/theme-default", "path": "src/js/theme/dropdown.js", "func_name": "init", "original_string": "function init() {\n    $(document).on('click', '.toggle-dropdown', toggleDropdown);\n    $(document).on('click', '.dropdown-menu', function(e){ e.stopPropagation(); });\n    $(document).on('click', closeDropdown);\n}", "language": "javascript", "code": "function init() {\n    $(document).on('click', '.toggle-dropdown', toggleDropdown);\n    $(document).on('click', '.dropdown-menu', function(e){ e.stopPropagation(); });\n    $(document).on('click', closeDropdown);\n}", "code_tokens": ["function", "init", "(", ")", "{", "$", "(", "document", ")", ".", "on", "(", "'click'", ",", "'.toggle-dropdown'", ",", "toggleDropdown", ")", ";", "$", "(", "document", ")", ".", "on", "(", "'click'", ",", "'.dropdown-menu'", ",", "function", "(", "e", ")", "{", "e", ".", "stopPropagation", "(", ")", ";", "}", ")", ";", "$", "(", "document", ")", ".", "on", "(", "'click'", ",", "closeDropdown", ")", ";", "}"], "docstring": "Bind all dropdown", "docstring_tokens": ["Bind", "all", "dropdown"], "sha": "a8e920453dc8e4eb522840b61606486622848099", "url": "https://github.com/GitbookIO/theme-default/blob/a8e920453dc8e4eb522840b61606486622848099/src/js/theme/dropdown.js#L16-L20", "partition": "test"}
{"repo": "apache/cordova-lib", "path": "src/cordova/util.js", "func_name": "findPlugins", "original_string": "function findPlugins (pluginDir) {\n    var plugins = [];\n\n    if (fs.existsSync(pluginDir)) {\n        plugins = fs.readdirSync(pluginDir).filter(function (fileName) {\n            var pluginPath = path.join(pluginDir, fileName);\n            var isPlugin = isDirectory(pluginPath) || isSymbolicLink(pluginPath);\n            return fileName !== '.svn' && fileName !== 'CVS' && isPlugin;\n        });\n    }\n\n    return plugins;\n}", "language": "javascript", "code": "function findPlugins (pluginDir) {\n    var plugins = [];\n\n    if (fs.existsSync(pluginDir)) {\n        plugins = fs.readdirSync(pluginDir).filter(function (fileName) {\n            var pluginPath = path.join(pluginDir, fileName);\n            var isPlugin = isDirectory(pluginPath) || isSymbolicLink(pluginPath);\n            return fileName !== '.svn' && fileName !== 'CVS' && isPlugin;\n        });\n    }\n\n    return plugins;\n}", "code_tokens": ["function", "findPlugins", "(", "pluginDir", ")", "{", "var", "plugins", "=", "[", "]", ";", "if", "(", "fs", ".", "existsSync", "(", "pluginDir", ")", ")", "{", "plugins", "=", "fs", ".", "readdirSync", "(", "pluginDir", ")", ".", "filter", "(", "function", "(", "fileName", ")", "{", "var", "pluginPath", "=", "path", ".", "join", "(", "pluginDir", ",", "fileName", ")", ";", "var", "isPlugin", "=", "isDirectory", "(", "pluginPath", ")", "||", "isSymbolicLink", "(", "pluginPath", ")", ";", "return", "fileName", "!==", "'.svn'", "&&", "fileName", "!==", "'CVS'", "&&", "isPlugin", ";", "}", ")", ";", "}", "return", "plugins", ";", "}"], "docstring": "list the directories in the path, ignoring any files", "docstring_tokens": ["list", "the", "directories", "in", "the", "path", "ignoring", "any", "files"], "sha": "dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5", "url": "https://github.com/apache/cordova-lib/blob/dbab1acbd3d5c2d3248c8aca91cbb7518e197ae5/src/cordova/util.js#L255-L267", "partition": "test"}
{"repo": "olegtaranenko/sencha-touch-node", "path": "lib/Ext/scroll/Scroller.js", "func_name": "", "original_string": "function(x, y, animation) {\n        if (this.isDestroyed) {\n            return this;\n        }\n\n        //<deprecated product=touch since=2.0>\n        if (typeof x != 'number' && arguments.length === 1) {\n            //<debug warn>\n            Ext.Logger.deprecate(\"Calling scrollTo() with an object argument is deprecated, \" +\n                \"please pass x and y arguments instead\", this);\n            //</debug>\n\n            y = x.y;\n            x = x.x;\n        }\n        //</deprecated>\n\n        var translatable = this.getTranslatable(),\n            position = this.position,\n            positionChanged = false,\n            translationX, translationY;\n\n        if (this.isAxisEnabled('x')) {\n            if (isNaN(x) || typeof x != 'number') {\n                x = position.x;\n            }\n            else {\n                if (position.x !== x) {\n                    position.x = x;\n                    positionChanged = true;\n                }\n            }\n\n            translationX = -x;\n        }\n\n        if (this.isAxisEnabled('y')) {\n            if (isNaN(y) || typeof y != 'number') {\n                y = position.y;\n            }\n            else {\n                if (position.y !== y) {\n                    position.y = y;\n                    positionChanged = true;\n                }\n            }\n\n            translationY = -y;\n        }\n\n        if (positionChanged) {\n            if (animation !== undefined && animation !== false) {\n                translatable.translateAnimated(translationX, translationY, animation);\n            }\n            else {\n                this.fireEvent('scroll', this, position.x, position.y);\n                translatable.translate(translationX, translationY);\n            }\n        }\n\n        return this;\n    }", "language": "javascript", "code": "function(x, y, animation) {\n        if (this.isDestroyed) {\n            return this;\n        }\n\n        //<deprecated product=touch since=2.0>\n        if (typeof x != 'number' && arguments.length === 1) {\n            //<debug warn>\n            Ext.Logger.deprecate(\"Calling scrollTo() with an object argument is deprecated, \" +\n                \"please pass x and y arguments instead\", this);\n            //</debug>\n\n            y = x.y;\n            x = x.x;\n        }\n        //</deprecated>\n\n        var translatable = this.getTranslatable(),\n            position = this.position,\n            positionChanged = false,\n            translationX, translationY;\n\n        if (this.isAxisEnabled('x')) {\n            if (isNaN(x) || typeof x != 'number') {\n                x = position.x;\n            }\n            else {\n                if (position.x !== x) {\n                    position.x = x;\n                    positionChanged = true;\n                }\n            }\n\n            translationX = -x;\n        }\n\n        if (this.isAxisEnabled('y')) {\n            if (isNaN(y) || typeof y != 'number') {\n                y = position.y;\n            }\n            else {\n                if (position.y !== y) {\n                    position.y = y;\n                    positionChanged = true;\n                }\n            }\n\n            translationY = -y;\n        }\n\n        if (positionChanged) {\n            if (animation !== undefined && animation !== false) {\n                translatable.translateAnimated(translationX, translationY, animation);\n            }\n            else {\n                this.fireEvent('scroll', this, position.x, position.y);\n                translatable.translate(translationX, translationY);\n            }\n        }\n\n        return this;\n    }", "code_tokens": ["function", "(", "x", ",", "y", ",", "animation", ")", "{", "if", "(", "this", ".", "isDestroyed", ")", "{", "return", "this", ";", "}", "//<deprecated product=touch since=2.0>", "if", "(", "typeof", "x", "!=", "'number'", "&&", "arguments", ".", "length", "===", "1", ")", "{", "//<debug warn>", "Ext", ".", "Logger", ".", "deprecate", "(", "\"Calling scrollTo() with an object argument is deprecated, \"", "+", "\"please pass x and y arguments instead\"", ",", "this", ")", ";", "//</debug>", "y", "=", "x", ".", "y", ";", "x", "=", "x", ".", "x", ";", "}", "//</deprecated>", "var", "translatable", "=", "this", ".", "getTranslatable", "(", ")", ",", "position", "=", "this", ".", "position", ",", "positionChanged", "=", "false", ",", "translationX", ",", "translationY", ";", "if", "(", "this", ".", "isAxisEnabled", "(", "'x'", ")", ")", "{", "if", "(", "isNaN", "(", "x", ")", "||", "typeof", "x", "!=", "'number'", ")", "{", "x", "=", "position", ".", "x", ";", "}", "else", "{", "if", "(", "position", ".", "x", "!==", "x", ")", "{", "position", ".", "x", "=", "x", ";", "positionChanged", "=", "true", ";", "}", "}", "translationX", "=", "-", "x", ";", "}", "if", "(", "this", ".", "isAxisEnabled", "(", "'y'", ")", ")", "{", "if", "(", "isNaN", "(", "y", ")", "||", "typeof", "y", "!=", "'number'", ")", "{", "y", "=", "position", ".", "y", ";", "}", "else", "{", "if", "(", "position", ".", "y", "!==", "y", ")", "{", "position", ".", "y", "=", "y", ";", "positionChanged", "=", "true", ";", "}", "}", "translationY", "=", "-", "y", ";", "}", "if", "(", "positionChanged", ")", "{", "if", "(", "animation", "!==", "undefined", "&&", "animation", "!==", "false", ")", "{", "translatable", ".", "translateAnimated", "(", "translationX", ",", "translationY", ",", "animation", ")", ";", "}", "else", "{", "this", ".", "fireEvent", "(", "'scroll'", ",", "this", ",", "position", ".", "x", ",", "position", ".", "y", ")", ";", "translatable", ".", "translate", "(", "translationX", ",", "translationY", ")", ";", "}", "}", "return", "this", ";", "}"], "docstring": "Scrolls to the given location.\n\n@param {Number} x The scroll position on the x axis.\n@param {Number} y The scroll position on the y axis.\n@param {Boolean/Object} animation (optional) Whether or not to animate the scrolling to the new position.\n\n@return {Ext.scroll.Scroller} this\n@chainable", "docstring_tokens": ["Scrolls", "to", "the", "given", "location", "."], "sha": "a46194e840a0c952503c08df39ed45a1f5e9887a", "url": "https://github.com/olegtaranenko/sencha-touch-node/blob/a46194e840a0c952503c08df39ed45a1f5e9887a/lib/Ext/scroll/Scroller.js#L758-L819", "partition": "test"}
{"repo": "cloudinary/cloudinary_js", "path": "js/jquery.cloudinary.js", "func_name": "RangeParam", "original_string": "function RangeParam(name, shortName, process) {\n      if (process == null) {\n        process = this.norm_range_value;\n      }\n      RangeParam.__super__.constructor.call(this, name, shortName, process);\n    }", "language": "javascript", "code": "function RangeParam(name, shortName, process) {\n      if (process == null) {\n        process = this.norm_range_value;\n      }\n      RangeParam.__super__.constructor.call(this, name, shortName, process);\n    }", "code_tokens": ["function", "RangeParam", "(", "name", ",", "shortName", ",", "process", ")", "{", "if", "(", "process", "==", "null", ")", "{", "process", "=", "this", ".", "norm_range_value", ";", "}", "RangeParam", ".", "__super__", ".", "constructor", ".", "call", "(", "this", ",", "name", ",", "shortName", ",", "process", ")", ";", "}"], "docstring": "A parameter that represents a range\n@param {string} name - The name of the parameter in snake_case\n@param {string} shortName - The name of the serialized form of the parameter\nIf a value is not provided, the parameter will not be serialized.\n@param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n@class RangeParam\n@extends Param\n@ignore", "docstring_tokens": ["A", "parameter", "that", "represents", "a", "range"], "sha": "c5ef98e858ba83e7c2c13a1d898748b571a5931b", "url": "https://github.com/cloudinary/cloudinary_js/blob/c5ef98e858ba83e7c2c13a1d898748b571a5931b/js/jquery.cloudinary.js#L1288-L1293", "partition": "test"}
{"repo": "jsantell/GhostTrain", "path": "lib/response.js", "func_name": "", "original_string": "function () {\n    var body;\n    var app = this.app;\n\n    // If status provide, set that, and set `body` to the content correctly\n    if (typeof arguments[0] === 'number') {\n      this.status(arguments[0]);\n      body = arguments[1];\n    } else {\n      body = arguments[0];\n    }\n\n    var type = this.get('Content-Type');\n\n    if (!body && type !== 'application/json') {\n      body = utils.STATUS_CODES[this.statusCode];\n      if (!type)\n        this.type('txt');\n    }\n    else if (typeof body === 'string') {\n      if (!type) {\n        this.charset = this.charset || 'utf-8';\n        this.type('html');\n      }\n    }\n    else if (typeof body === 'object') {\n      if (body === null)\n        body = '';\n      else if (!type || type === 'application/json') {\n        this.contentType('application/json');\n        // Cast object to string to normalize response\n        var replacer = app.get('json replacer');\n        var spaces = app.get('json spaces');\n        body = JSON.stringify(body, replacer, spaces);\n      }\n    }\n\n    this.end(body);\n    return this;\n  }", "language": "javascript", "code": "function () {\n    var body;\n    var app = this.app;\n\n    // If status provide, set that, and set `body` to the content correctly\n    if (typeof arguments[0] === 'number') {\n      this.status(arguments[0]);\n      body = arguments[1];\n    } else {\n      body = arguments[0];\n    }\n\n    var type = this.get('Content-Type');\n\n    if (!body && type !== 'application/json') {\n      body = utils.STATUS_CODES[this.statusCode];\n      if (!type)\n        this.type('txt');\n    }\n    else if (typeof body === 'string') {\n      if (!type) {\n        this.charset = this.charset || 'utf-8';\n        this.type('html');\n      }\n    }\n    else if (typeof body === 'object') {\n      if (body === null)\n        body = '';\n      else if (!type || type === 'application/json') {\n        this.contentType('application/json');\n        // Cast object to string to normalize response\n        var replacer = app.get('json replacer');\n        var spaces = app.get('json spaces');\n        body = JSON.stringify(body, replacer, spaces);\n      }\n    }\n\n    this.end(body);\n    return this;\n  }", "code_tokens": ["function", "(", ")", "{", "var", "body", ";", "var", "app", "=", "this", ".", "app", ";", "// If status provide, set that, and set `body` to the content correctly", "if", "(", "typeof", "arguments", "[", "0", "]", "===", "'number'", ")", "{", "this", ".", "status", "(", "arguments", "[", "0", "]", ")", ";", "body", "=", "arguments", "[", "1", "]", ";", "}", "else", "{", "body", "=", "arguments", "[", "0", "]", ";", "}", "var", "type", "=", "this", ".", "get", "(", "'Content-Type'", ")", ";", "if", "(", "!", "body", "&&", "type", "!==", "'application/json'", ")", "{", "body", "=", "utils", ".", "STATUS_CODES", "[", "this", ".", "statusCode", "]", ";", "if", "(", "!", "type", ")", "this", ".", "type", "(", "'txt'", ")", ";", "}", "else", "if", "(", "typeof", "body", "===", "'string'", ")", "{", "if", "(", "!", "type", ")", "{", "this", ".", "charset", "=", "this", ".", "charset", "||", "'utf-8'", ";", "this", ".", "type", "(", "'html'", ")", ";", "}", "}", "else", "if", "(", "typeof", "body", "===", "'object'", ")", "{", "if", "(", "body", "===", "null", ")", "body", "=", "''", ";", "else", "if", "(", "!", "type", "||", "type", "===", "'application/json'", ")", "{", "this", ".", "contentType", "(", "'application/json'", ")", ";", "// Cast object to string to normalize response", "var", "replacer", "=", "app", ".", "get", "(", "'json replacer'", ")", ";", "var", "spaces", "=", "app", ".", "get", "(", "'json spaces'", ")", ";", "body", "=", "JSON", ".", "stringify", "(", "body", ",", "replacer", ",", "spaces", ")", ";", "}", "}", "this", ".", "end", "(", "body", ")", ";", "return", "this", ";", "}"], "docstring": "Sends a response\n\nExamples:\nres.send({})\nres.send('text')\nres.send(404, 'Message')\nres.send(200)\n\n@param {Mixed} body or status code\n@param {Mixed} body\n@return {Response}", "docstring_tokens": ["Sends", "a", "response"], "sha": "e69b6cc33669035c1d571bff3805e1b6d8a50ccb", "url": "https://github.com/jsantell/GhostTrain/blob/e69b6cc33669035c1d571bff3805e1b6d8a50ccb/lib/response.js#L40-L79", "partition": "test"}
{"repo": "jshttp/negotiator", "path": "lib/language.js", "func_name": "getLanguagePriority", "original_string": "function getLanguagePriority(language, accepted, index) {\n  var priority = {o: -1, q: 0, s: 0};\n\n  for (var i = 0; i < accepted.length; i++) {\n    var spec = specify(language, accepted[i], index);\n\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\n      priority = spec;\n    }\n  }\n\n  return priority;\n}", "language": "javascript", "code": "function getLanguagePriority(language, accepted, index) {\n  var priority = {o: -1, q: 0, s: 0};\n\n  for (var i = 0; i < accepted.length; i++) {\n    var spec = specify(language, accepted[i], index);\n\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\n      priority = spec;\n    }\n  }\n\n  return priority;\n}", "code_tokens": ["function", "getLanguagePriority", "(", "language", ",", "accepted", ",", "index", ")", "{", "var", "priority", "=", "{", "o", ":", "-", "1", ",", "q", ":", "0", ",", "s", ":", "0", "}", ";", "for", "(", "var", "i", "=", "0", ";", "i", "<", "accepted", ".", "length", ";", "i", "++", ")", "{", "var", "spec", "=", "specify", "(", "language", ",", "accepted", "[", "i", "]", ",", "index", ")", ";", "if", "(", "spec", "&&", "(", "priority", ".", "s", "-", "spec", ".", "s", "||", "priority", ".", "q", "-", "spec", ".", "q", "||", "priority", ".", "o", "-", "spec", ".", "o", ")", "<", "0", ")", "{", "priority", "=", "spec", ";", "}", "}", "return", "priority", ";", "}"], "docstring": "Get the priority of a language.\n@private", "docstring_tokens": ["Get", "the", "priority", "of", "a", "language", "."], "sha": "99f418e11907b60e63f0addc09fc596ddc7be5be", "url": "https://github.com/jshttp/negotiator/blob/99f418e11907b60e63f0addc09fc596ddc7be5be/lib/language.js#L86-L98", "partition": "test"}
{"repo": "NathanWalker/nativescript-ng2-magic", "path": "install.js", "func_name": "displayFinalHelp", "original_string": "function displayFinalHelp()\n{\n    console.log(\"-------------- Welcome to the Magical World of NativeScript -----------------------------\");\n    console.log(\"To finish, follow this guide https://github.com/NathanWalker/nativescript-ng2-magic#usage\");\n    console.log(\"After you have completed the steps in the usage guide, you can then:\");\n    console.log(\"\");\n    console.log(\"Run your app in the iOS Simulator with these options:\");\n    console.log(\"  npm run start.ios\");\n    console.log(\"  npm run start.livesync.ios\");\n    console.log(\"\");\n    console.log(\"Run your app in an Android emulator with these options:\");\n    console.log(\"  npm run start.android\");\n    console.log(\"  npm run start.livesync.android\");\n    console.log(\"-----------------------------------------------------------------------------------------\");\n    console.log(\"\");\n}", "language": "javascript", "code": "function displayFinalHelp()\n{\n    console.log(\"-------------- Welcome to the Magical World of NativeScript -----------------------------\");\n    console.log(\"To finish, follow this guide https://github.com/NathanWalker/nativescript-ng2-magic#usage\");\n    console.log(\"After you have completed the steps in the usage guide, you can then:\");\n    console.log(\"\");\n    console.log(\"Run your app in the iOS Simulator with these options:\");\n    console.log(\"  npm run start.ios\");\n    console.log(\"  npm run start.livesync.ios\");\n    console.log(\"\");\n    console.log(\"Run your app in an Android emulator with these options:\");\n    console.log(\"  npm run start.android\");\n    console.log(\"  npm run start.livesync.android\");\n    console.log(\"-----------------------------------------------------------------------------------------\");\n    console.log(\"\");\n}", "code_tokens": ["function", "displayFinalHelp", "(", ")", "{", "console", ".", "log", "(", "\"-------------- Welcome to the Magical World of NativeScript -----------------------------\"", ")", ";", "console", ".", "log", "(", "\"To finish, follow this guide https://github.com/NathanWalker/nativescript-ng2-magic#usage\"", ")", ";", "console", ".", "log", "(", "\"After you have completed the steps in the usage guide, you can then:\"", ")", ";", "console", ".", "log", "(", "\"\"", ")", ";", "console", ".", "log", "(", "\"Run your app in the iOS Simulator with these options:\"", ")", ";", "console", ".", "log", "(", "\"  npm run start.ios\"", ")", ";", "console", ".", "log", "(", "\"  npm run start.livesync.ios\"", ")", ";", "console", ".", "log", "(", "\"\"", ")", ";", "console", ".", "log", "(", "\"Run your app in an Android emulator with these options:\"", ")", ";", "console", ".", "log", "(", "\"  npm run start.android\"", ")", ";", "console", ".", "log", "(", "\"  npm run start.livesync.android\"", ")", ";", "console", ".", "log", "(", "\"-----------------------------------------------------------------------------------------\"", ")", ";", "console", ".", "log", "(", "\"\"", ")", ";", "}"], "docstring": "Display final help screen!", "docstring_tokens": ["Display", "final", "help", "screen!"], "sha": "702395cf85add650170ca45ca6f582e6ad609863", "url": "https://github.com/NathanWalker/nativescript-ng2-magic/blob/702395cf85add650170ca45ca6f582e6ad609863/install.js#L471-L486", "partition": "test"}
{"repo": "tstachl/desk.js", "path": "lib/client.js", "func_name": "Client", "original_string": "function Client(options) {\n  options = options || {};\n\n  this.isClient = true;\n  this.subdomain = options.subdomain;\n  this.endpoint = options.endpoint;\n  if (!this.subdomain && !this.endpoint) throw new Error('No subdomain was specified.');\n\n  // Determine if we construct a URL from the subdomain or use a custom one\n  if(this.endpoint && typeof this.endpoint !== 'undefined') {\n    this.baseUrl = this.endpoint;\n  } else {\n    this.baseUrl = 'https://' + this.subdomain + '.desk.com';\n  }\n\n  if (options.username && options.password) {\n    this.auth = { username: options.username, password: options.password, sendImmediately: true };\n  } else if (options.consumerKey && options.consumerSecret && options.token && options.tokenSecret) {\n    this.auth = {\n      consumer_key: options.consumerKey,\n      consumer_secret: options.consumerSecret,\n      token: options.token,\n      token_secret: options.tokenSecret\n    };\n  } else {\n    throw new Error('No authentication specified, use either Basic Authentication or OAuth.');\n  }\n\n  this.retry = options.retry || false;\n  this.maxRetry = options.maxRetry || 3;\n  this.timeout = options.timeout;\n  this.logger = options.logger || null;\n  this.queue = async.queue(this.request.bind(this), 60);\n\n  linkMixin.call(this, JSON.parse(fs.readFileSync(__dirname + '/resources.json', 'utf-8')));\n}", "language": "javascript", "code": "function Client(options) {\n  options = options || {};\n\n  this.isClient = true;\n  this.subdomain = options.subdomain;\n  this.endpoint = options.endpoint;\n  if (!this.subdomain && !this.endpoint) throw new Error('No subdomain was specified.');\n\n  // Determine if we construct a URL from the subdomain or use a custom one\n  if(this.endpoint && typeof this.endpoint !== 'undefined') {\n    this.baseUrl = this.endpoint;\n  } else {\n    this.baseUrl = 'https://' + this.subdomain + '.desk.com';\n  }\n\n  if (options.username && options.password) {\n    this.auth = { username: options.username, password: options.password, sendImmediately: true };\n  } else if (options.consumerKey && options.consumerSecret && options.token && options.tokenSecret) {\n    this.auth = {\n      consumer_key: options.consumerKey,\n      consumer_secret: options.consumerSecret,\n      token: options.token,\n      token_secret: options.tokenSecret\n    };\n  } else {\n    throw new Error('No authentication specified, use either Basic Authentication or OAuth.');\n  }\n\n  this.retry = options.retry || false;\n  this.maxRetry = options.maxRetry || 3;\n  this.timeout = options.timeout;\n  this.logger = options.logger || null;\n  this.queue = async.queue(this.request.bind(this), 60);\n\n  linkMixin.call(this, JSON.parse(fs.readFileSync(__dirname + '/resources.json', 'utf-8')));\n}", "code_tokens": ["function", "Client", "(", "options", ")", "{", "options", "=", "options", "||", "{", "}", ";", "this", ".", "isClient", "=", "true", ";", "this", ".", "subdomain", "=", "options", ".", "subdomain", ";", "this", ".", "endpoint", "=", "options", ".", "endpoint", ";", "if", "(", "!", "this", ".", "subdomain", "&&", "!", "this", ".", "endpoint", ")", "throw", "new", "Error", "(", "'No subdomain was specified.'", ")", ";", "// Determine if we construct a URL from the subdomain or use a custom one", "if", "(", "this", ".", "endpoint", "&&", "typeof", "this", ".", "endpoint", "!==", "'undefined'", ")", "{", "this", ".", "baseUrl", "=", "this", ".", "endpoint", ";", "}", "else", "{", "this", ".", "baseUrl", "=", "'https://'", "+", "this", ".", "subdomain", "+", "'.desk.com'", ";", "}", "if", "(", "options", ".", "username", "&&", "options", ".", "password", ")", "{", "this", ".", "auth", "=", "{", "username", ":", "options", ".", "username", ",", "password", ":", "options", ".", "password", ",", "sendImmediately", ":", "true", "}", ";", "}", "else", "if", "(", "options", ".", "consumerKey", "&&", "options", ".", "consumerSecret", "&&", "options", ".", "token", "&&", "options", ".", "tokenSecret", ")", "{", "this", ".", "auth", "=", "{", "consumer_key", ":", "options", ".", "consumerKey", ",", "consumer_secret", ":", "options", ".", "consumerSecret", ",", "token", ":", "options", ".", "token", ",", "token_secret", ":", "options", ".", "tokenSecret", "}", ";", "}", "else", "{", "throw", "new", "Error", "(", "'No authentication specified, use either Basic Authentication or OAuth.'", ")", ";", "}", "this", ".", "retry", "=", "options", ".", "retry", "||", "false", ";", "this", ".", "maxRetry", "=", "options", ".", "maxRetry", "||", "3", ";", "this", ".", "timeout", "=", "options", ".", "timeout", ";", "this", ".", "logger", "=", "options", ".", "logger", "||", "null", ";", "this", ".", "queue", "=", "async", ".", "queue", "(", "this", ".", "request", ".", "bind", "(", "this", ")", ",", "60", ")", ";", "linkMixin", ".", "call", "(", "this", ",", "JSON", ".", "parse", "(", "fs", ".", "readFileSync", "(", "__dirname", "+", "'/resources.json'", ",", "'utf-8'", ")", ")", ")", ";", "}"], "docstring": "Initialize a new `Client` with the given `options`.\n\nOptions:\n\n- `subdomain` the desk.com subdomain to use\n- `endpoint` the desk.com custom domain to use - if you use your own domain\n- `username` username for basic authentication\n- `password` password for basic authentication\n- `consumerKey` consumer key for the oauth application\n- `consumerSecret` secret for the oauth application\n- `token` the token for the oauth authentication\n- `tokenSecret` secret for the oauth authentication\n- `retry` retry request on 429 and 503\n- `logger` logging function to use for request logging\n\n@param {Object} options\n@api private", "docstring_tokens": ["Initialize", "a", "new", "Client", "with", "the", "given", "options", "."], "sha": "b339196cce68dbbc79d3075f2ebe82372972f4f5", "url": "https://github.com/tstachl/desk.js/blob/b339196cce68dbbc79d3075f2ebe82372972f4f5/lib/client.js#L58-L93", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "getEffectiveCallArguments", "original_string": "function getEffectiveCallArguments(node) {\n            var args;\n            if (node.kind === 170 /* TaggedTemplateExpression */) {\n                var template = node.template;\n                args = [undefined];\n                if (template.kind === 183 /* TemplateExpression */) {\n                    ts.forEach(template.templateSpans, function (span) {\n                        args.push(span.expression);\n                    });\n                }\n            }\n            else if (node.kind === 139 /* Decorator */) {\n                // For a decorator, we return undefined as we will determine\n                // the number and types of arguments for a decorator using\n                // `getEffectiveArgumentCount` and `getEffectiveArgumentType` below.\n                return undefined;\n            }\n            else {\n                args = node.arguments || emptyArray;\n            }\n            return args;\n        }", "language": "javascript", "code": "function getEffectiveCallArguments(node) {\n            var args;\n            if (node.kind === 170 /* TaggedTemplateExpression */) {\n                var template = node.template;\n                args = [undefined];\n                if (template.kind === 183 /* TemplateExpression */) {\n                    ts.forEach(template.templateSpans, function (span) {\n                        args.push(span.expression);\n                    });\n                }\n            }\n            else if (node.kind === 139 /* Decorator */) {\n                // For a decorator, we return undefined as we will determine\n                // the number and types of arguments for a decorator using\n                // `getEffectiveArgumentCount` and `getEffectiveArgumentType` below.\n                return undefined;\n            }\n            else {\n                args = node.arguments || emptyArray;\n            }\n            return args;\n        }", "code_tokens": ["function", "getEffectiveCallArguments", "(", "node", ")", "{", "var", "args", ";", "if", "(", "node", ".", "kind", "===", "170", "/* TaggedTemplateExpression */", ")", "{", "var", "template", "=", "node", ".", "template", ";", "args", "=", "[", "undefined", "]", ";", "if", "(", "template", ".", "kind", "===", "183", "/* TemplateExpression */", ")", "{", "ts", ".", "forEach", "(", "template", ".", "templateSpans", ",", "function", "(", "span", ")", "{", "args", ".", "push", "(", "span", ".", "expression", ")", ";", "}", ")", ";", "}", "}", "else", "if", "(", "node", ".", "kind", "===", "139", "/* Decorator */", ")", "{", "// For a decorator, we return undefined as we will determine", "// the number and types of arguments for a decorator using", "// `getEffectiveArgumentCount` and `getEffectiveArgumentType` below.", "return", "undefined", ";", "}", "else", "{", "args", "=", "node", ".", "arguments", "||", "emptyArray", ";", "}", "return", "args", ";", "}"], "docstring": "Returns the effective arguments for an expression that works like a function invocation.\n\nIf 'node' is a CallExpression or a NewExpression, then its argument list is returned.\nIf 'node' is a TaggedTemplateExpression, a new argument list is constructed from the substitution\nexpressions, where the first element of the list is `undefined`.\nIf 'node' is a Decorator, the argument list will be `undefined`, and its arguments and types\nwill be supplied from calls to `getEffectiveArgumentCount` and `getEffectiveArgumentType`.", "docstring_tokens": ["Returns", "the", "effective", "arguments", "for", "an", "expression", "that", "works", "like", "a", "function", "invocation", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L21075-L21096", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function(store, type, record) {\n    var id = get(record, 'id');\n\n    return this.ajax(this.buildURL(type.typeKey, id), \"DELETE\");\n  }", "language": "javascript", "code": "function(store, type, record) {\n    var id = get(record, 'id');\n\n    return this.ajax(this.buildURL(type.typeKey, id), \"DELETE\");\n  }", "code_tokens": ["function", "(", "store", ",", "type", ",", "record", ")", "{", "var", "id", "=", "get", "(", "record", ",", "'id'", ")", ";", "return", "this", ".", "ajax", "(", "this", ".", "buildURL", "(", "type", ".", "typeKey", ",", "id", ")", ",", "\"DELETE\"", ")", ";", "}"], "docstring": "Called by the store when a record is deleted.\n\nThe `deleteRecord` method  makes an Ajax (HTTP DELETE) request to a URL computed by `buildURL`.\n\n@method deleteRecord\n@param {DS.Store} store\n@param {subclass of DS.Model} type\n@param {DS.Model} record\n@returns {Promise} promise", "docstring_tokens": ["Called", "by", "the", "store", "when", "a", "record", "is", "deleted", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L9408-L9412", "partition": "test"}
{"repo": "barbajs/barba", "path": "packages/core/__web__/scripts/transitions/hooks.js", "func_name": "append", "original_string": "function append(str, prefix = '') {\n  const item = document.createElement('li');\n\n  item.textContent = prefix + str;\n  list.appendChild(item);\n}", "language": "javascript", "code": "function append(str, prefix = '') {\n  const item = document.createElement('li');\n\n  item.textContent = prefix + str;\n  list.appendChild(item);\n}", "code_tokens": ["function", "append", "(", "str", ",", "prefix", "=", "''", ")", "{", "const", "item", "=", "document", ".", "createElement", "(", "'li'", ")", ";", "item", ".", "textContent", "=", "prefix", "+", "str", ";", "list", ".", "appendChild", "(", "item", ")", ";", "}"], "docstring": "Append list item\n\n@param {*} str List item content\n@param {string} prefix Prefix for global\n@returns {void}", "docstring_tokens": ["Append", "list", "item"], "sha": "f450491297648a684e0f50d8335384340d8b5254", "url": "https://github.com/barbajs/barba/blob/f450491297648a684e0f50d8335384340d8b5254/packages/core/__web__/scripts/transitions/hooks.js#L12-L17", "partition": "test"}
{"repo": "flowjs/flow.js", "path": "dist/flow.js", "func_name": "each", "original_string": "function each(obj, callback, context) {\n    if (!obj) {\n      return ;\n    }\n    var key;\n    // Is Array?\n    // Array.isArray won't work, not only arrays can be iterated by index https://github.com/flowjs/ng-flow/issues/236#\n    if (typeof(obj.length) !== 'undefined') {\n      for (key = 0; key < obj.length; key++) {\n        if (callback.call(context, obj[key], key) === false) {\n          return ;\n        }\n      }\n    } else {\n      for (key in obj) {\n        if (obj.hasOwnProperty(key) && callback.call(context, obj[key], key) === false) {\n          return ;\n        }\n      }\n    }\n  }", "language": "javascript", "code": "function each(obj, callback, context) {\n    if (!obj) {\n      return ;\n    }\n    var key;\n    // Is Array?\n    // Array.isArray won't work, not only arrays can be iterated by index https://github.com/flowjs/ng-flow/issues/236#\n    if (typeof(obj.length) !== 'undefined') {\n      for (key = 0; key < obj.length; key++) {\n        if (callback.call(context, obj[key], key) === false) {\n          return ;\n        }\n      }\n    } else {\n      for (key in obj) {\n        if (obj.hasOwnProperty(key) && callback.call(context, obj[key], key) === false) {\n          return ;\n        }\n      }\n    }\n  }", "code_tokens": ["function", "each", "(", "obj", ",", "callback", ",", "context", ")", "{", "if", "(", "!", "obj", ")", "{", "return", ";", "}", "var", "key", ";", "// Is Array?", "// Array.isArray won't work, not only arrays can be iterated by index https://github.com/flowjs/ng-flow/issues/236#", "if", "(", "typeof", "(", "obj", ".", "length", ")", "!==", "'undefined'", ")", "{", "for", "(", "key", "=", "0", ";", "key", "<", "obj", ".", "length", ";", "key", "++", ")", "{", "if", "(", "callback", ".", "call", "(", "context", ",", "obj", "[", "key", "]", ",", "key", ")", "===", "false", ")", "{", "return", ";", "}", "}", "}", "else", "{", "for", "(", "key", "in", "obj", ")", "{", "if", "(", "obj", ".", "hasOwnProperty", "(", "key", ")", "&&", "callback", ".", "call", "(", "context", ",", "obj", "[", "key", "]", ",", "key", ")", "===", "false", ")", "{", "return", ";", "}", "}", "}", "}"], "docstring": "Iterate each element of an object\n@function\n@param {Array|Object} obj object or an array to iterate\n@param {Function} callback first argument is a value and second is a key.\n@param {Object=} context Object to become context (`this`) for the iterator function.", "docstring_tokens": ["Iterate", "each", "element", "of", "an", "object"], "sha": "aadc5a72b1414d87ed1aa3563b30209f9b1f7773", "url": "https://github.com/flowjs/flow.js/blob/aadc5a72b1414d87ed1aa3563b30209f9b1f7773/dist/flow.js#L1577-L1597", "partition": "test"}
{"repo": "pureqml/qmlcore", "path": "platform/video.videojs/dist/video.es.js", "func_name": "setTextContent", "original_string": "function setTextContent(el, content) {\n  if (el.styleSheet) {\n    el.styleSheet.cssText = content;\n  } else {\n    el.textContent = content;\n  }\n}", "language": "javascript", "code": "function setTextContent(el, content) {\n  if (el.styleSheet) {\n    el.styleSheet.cssText = content;\n  } else {\n    el.textContent = content;\n  }\n}", "code_tokens": ["function", "setTextContent", "(", "el", ",", "content", ")", "{", "if", "(", "el", ".", "styleSheet", ")", "{", "el", ".", "styleSheet", ".", "cssText", "=", "content", ";", "}", "else", "{", "el", ".", "textContent", "=", "content", ";", "}", "}"], "docstring": "Add text to a DOM element.\n\n@param {Element} el\nThe Element to add text content to.\n\n@param {string} content\nThe text to add to the element.", "docstring_tokens": ["Add", "text", "to", "a", "DOM", "element", "."], "sha": "21416cb4b45dce6cf6c603dfa43d6683e0d48638", "url": "https://github.com/pureqml/qmlcore/blob/21416cb4b45dce6cf6c603dfa43d6683e0d48638/platform/video.videojs/dist/video.es.js#L2131-L2137", "partition": "test"}
{"repo": "soldair/node-tailfd", "path": "tail.js", "func_name": "", "original_string": "function(){\n    var z = this;\n    var l = 0;\n    Object.keys(z.tails).forEach(function(k) {\n      l += (z.tails[k].buf||'').length;\n    });\n    return l;\n  }", "language": "javascript", "code": "function(){\n    var z = this;\n    var l = 0;\n    Object.keys(z.tails).forEach(function(k) {\n      l += (z.tails[k].buf||'').length;\n    });\n    return l;\n  }", "code_tokens": ["function", "(", ")", "{", "var", "z", "=", "this", ";", "var", "l", "=", "0", ";", "Object", ".", "keys", "(", "z", ".", "tails", ")", ".", "forEach", "(", "function", "(", "k", ")", "{", "l", "+=", "(", "z", ".", "tails", "[", "k", "]", ".", "buf", "||", "''", ")", ".", "length", ";", "}", ")", ";", "return", "l", ";", "}"], "docstring": "return the total line buffer length from all active tails", "docstring_tokens": ["return", "the", "total", "line", "buffer", "length", "from", "all", "active", "tails"], "sha": "ef87ec6389edb7f53b540972aa32256d0b4fc850", "url": "https://github.com/soldair/node-tailfd/blob/ef87ec6389edb7f53b540972aa32256d0b4fc850/tail.js#L277-L284", "partition": "test"}
{"repo": "localnerve/picklr", "path": "lib/picklr.js", "func_name": "", "original_string": "function (stats, p) {\n    let result = stats.isDirectory();\n\n    if (result) {\n      result = !this.excludeDirs.test(p);\n    }\n\n    return result;\n  }", "language": "javascript", "code": "function (stats, p) {\n    let result = stats.isDirectory();\n\n    if (result) {\n      result = !this.excludeDirs.test(p);\n    }\n\n    return result;\n  }", "code_tokens": ["function", "(", "stats", ",", "p", ")", "{", "let", "result", "=", "stats", ".", "isDirectory", "(", ")", ";", "if", "(", "result", ")", "{", "result", "=", "!", "this", ".", "excludeDirs", ".", "test", "(", "p", ")", ";", "}", "return", "result", ";", "}"], "docstring": "Directory type determination.\n\n@private\n@returns true if given path is a directory.", "docstring_tokens": ["Directory", "type", "determination", "."], "sha": "ed4698eb096f87a74786b1a87273b3bfe9f1c930", "url": "https://github.com/localnerve/picklr/blob/ed4698eb096f87a74786b1a87273b3bfe9f1c930/lib/picklr.js#L88-L96", "partition": "test"}
{"repo": "aaronshaf/dem", "path": "index.js", "func_name": "", "original_string": "function(comment) {\n              const isLicense =\n                comment.toLowerCase().includes(\"license\") ||\n                comment.toLowerCase().includes(\"copyright\");\n              if (isLicense === false) {\n                return false;\n              }\n              if (lastLicense !== comment) {\n                lastLicense = comment;\n                return true;\n              } else {\n                return false;\n              }\n            }", "language": "javascript", "code": "function(comment) {\n              const isLicense =\n                comment.toLowerCase().includes(\"license\") ||\n                comment.toLowerCase().includes(\"copyright\");\n              if (isLicense === false) {\n                return false;\n              }\n              if (lastLicense !== comment) {\n                lastLicense = comment;\n                return true;\n              } else {\n                return false;\n              }\n            }", "code_tokens": ["function", "(", "comment", ")", "{", "const", "isLicense", "=", "comment", ".", "toLowerCase", "(", ")", ".", "includes", "(", "\"license\"", ")", "||", "comment", ".", "toLowerCase", "(", ")", ".", "includes", "(", "\"copyright\"", ")", ";", "if", "(", "isLicense", "===", "false", ")", "{", "return", "false", ";", "}", "if", "(", "lastLicense", "!==", "comment", ")", "{", "lastLicense", "=", "comment", ";", "return", "true", ";", "}", "else", "{", "return", "false", ";", "}", "}"], "docstring": "don't include redundant license or copyright notice", "docstring_tokens": ["don", "t", "include", "redundant", "license", "or", "copyright", "notice"], "sha": "d213d50d57ed64d0f37a600a8dfc4acf380742ff", "url": "https://github.com/aaronshaf/dem/blob/d213d50d57ed64d0f37a600a8dfc4acf380742ff/index.js#L53-L66", "partition": "test"}
{"repo": "acarl005/join-monster", "path": "src/array-to-connection.js", "func_name": "arrToConnection", "original_string": "function arrToConnection(data, sqlAST) {\n  // use \"post-order\" tree traversal\n  for (let astChild of sqlAST.children || []) {\n    if (Array.isArray(data)) {\n      for (let dataItem of data) {\n        recurseOnObjInData(dataItem, astChild)\n      }\n    } else if (data) {\n      recurseOnObjInData(data, astChild)\n    }\n  }\n  const pageInfo = {\n    hasNextPage: false,\n    hasPreviousPage: false\n  }\n  if (!data) {\n    if (sqlAST.paginate) {\n      return {\n        pageInfo,\n        edges: []\n      }\n    }\n    return null\n  }\n  // is cases where pagination was done, take the data and convert to the connection object\n  // if any two fields happen to become a reference to the same object (when their `uniqueKey`s are the same),\n  // we must prevent the recursive processing from visting the same object twice, because mutating the object the first\n  // time changes it everywhere. we'll set the `_paginated` property to true to prevent this\n  if (sqlAST.paginate && !data._paginated) {\n    if (sqlAST.sortKey || idx(sqlAST, _ => _.junction.sortKey)) {\n      if (idx(sqlAST, _ => _.args.first)) {\n        // we fetched an extra one in order to determine if there is a next page, if there is one, pop off that extra\n        if (data.length > sqlAST.args.first) {\n          pageInfo.hasNextPage = true\n          data.pop()\n        }\n      } else if (sqlAST.args && sqlAST.args.last) {\n        // if backward paging, do the same, but also reverse it\n        if (data.length > sqlAST.args.last) {\n          pageInfo.hasPreviousPage = true\n          data.pop()\n        }\n        data.reverse()\n      }\n      // convert nodes to edges and compute the cursor for each\n      // TODO: only compute all the cursor if asked for them\n      const sortKey = sqlAST.sortKey || sqlAST.junction.sortKey\n      const edges = data.map(obj => {\n        const cursor = {}\n        const key = sortKey.key\n        for (let column of wrap(key)) {\n          cursor[column] = obj[column]\n        }\n        return { cursor: objToCursor(cursor), node: obj }\n      })\n      if (data.length) {\n        pageInfo.startCursor = edges[0].cursor\n        pageInfo.endCursor = last(edges).cursor\n      }\n      return { edges, pageInfo, _paginated: true }\n    }\n    if (sqlAST.orderBy || (sqlAST.junction && sqlAST.junction.orderBy)) {\n      let offset = 0\n      if (idx(sqlAST, _ => _.args.after)) {\n        offset = cursorToOffset(sqlAST.args.after) + 1\n      }\n      // $total was a special column for determining the total number of items\n      const arrayLength = data[0] && parseInt(data[0].$total, 10)\n      const connection = connectionFromArraySlice(data, sqlAST.args || {}, { sliceStart: offset, arrayLength })\n      connection.total = arrayLength || 0\n      connection._paginated = true\n      return connection\n    }\n  }\n  return data\n}", "language": "javascript", "code": "function arrToConnection(data, sqlAST) {\n  // use \"post-order\" tree traversal\n  for (let astChild of sqlAST.children || []) {\n    if (Array.isArray(data)) {\n      for (let dataItem of data) {\n        recurseOnObjInData(dataItem, astChild)\n      }\n    } else if (data) {\n      recurseOnObjInData(data, astChild)\n    }\n  }\n  const pageInfo = {\n    hasNextPage: false,\n    hasPreviousPage: false\n  }\n  if (!data) {\n    if (sqlAST.paginate) {\n      return {\n        pageInfo,\n        edges: []\n      }\n    }\n    return null\n  }\n  // is cases where pagination was done, take the data and convert to the connection object\n  // if any two fields happen to become a reference to the same object (when their `uniqueKey`s are the same),\n  // we must prevent the recursive processing from visting the same object twice, because mutating the object the first\n  // time changes it everywhere. we'll set the `_paginated` property to true to prevent this\n  if (sqlAST.paginate && !data._paginated) {\n    if (sqlAST.sortKey || idx(sqlAST, _ => _.junction.sortKey)) {\n      if (idx(sqlAST, _ => _.args.first)) {\n        // we fetched an extra one in order to determine if there is a next page, if there is one, pop off that extra\n        if (data.length > sqlAST.args.first) {\n          pageInfo.hasNextPage = true\n          data.pop()\n        }\n      } else if (sqlAST.args && sqlAST.args.last) {\n        // if backward paging, do the same, but also reverse it\n        if (data.length > sqlAST.args.last) {\n          pageInfo.hasPreviousPage = true\n          data.pop()\n        }\n        data.reverse()\n      }\n      // convert nodes to edges and compute the cursor for each\n      // TODO: only compute all the cursor if asked for them\n      const sortKey = sqlAST.sortKey || sqlAST.junction.sortKey\n      const edges = data.map(obj => {\n        const cursor = {}\n        const key = sortKey.key\n        for (let column of wrap(key)) {\n          cursor[column] = obj[column]\n        }\n        return { cursor: objToCursor(cursor), node: obj }\n      })\n      if (data.length) {\n        pageInfo.startCursor = edges[0].cursor\n        pageInfo.endCursor = last(edges).cursor\n      }\n      return { edges, pageInfo, _paginated: true }\n    }\n    if (sqlAST.orderBy || (sqlAST.junction && sqlAST.junction.orderBy)) {\n      let offset = 0\n      if (idx(sqlAST, _ => _.args.after)) {\n        offset = cursorToOffset(sqlAST.args.after) + 1\n      }\n      // $total was a special column for determining the total number of items\n      const arrayLength = data[0] && parseInt(data[0].$total, 10)\n      const connection = connectionFromArraySlice(data, sqlAST.args || {}, { sliceStart: offset, arrayLength })\n      connection.total = arrayLength || 0\n      connection._paginated = true\n      return connection\n    }\n  }\n  return data\n}", "code_tokens": ["function", "arrToConnection", "(", "data", ",", "sqlAST", ")", "{", "// use \"post-order\" tree traversal", "for", "(", "let", "astChild", "of", "sqlAST", ".", "children", "||", "[", "]", ")", "{", "if", "(", "Array", ".", "isArray", "(", "data", ")", ")", "{", "for", "(", "let", "dataItem", "of", "data", ")", "{", "recurseOnObjInData", "(", "dataItem", ",", "astChild", ")", "}", "}", "else", "if", "(", "data", ")", "{", "recurseOnObjInData", "(", "data", ",", "astChild", ")", "}", "}", "const", "pageInfo", "=", "{", "hasNextPage", ":", "false", ",", "hasPreviousPage", ":", "false", "}", "if", "(", "!", "data", ")", "{", "if", "(", "sqlAST", ".", "paginate", ")", "{", "return", "{", "pageInfo", ",", "edges", ":", "[", "]", "}", "}", "return", "null", "}", "// is cases where pagination was done, take the data and convert to the connection object", "// if any two fields happen to become a reference to the same object (when their `uniqueKey`s are the same),", "// we must prevent the recursive processing from visting the same object twice, because mutating the object the first", "// time changes it everywhere. we'll set the `_paginated` property to true to prevent this", "if", "(", "sqlAST", ".", "paginate", "&&", "!", "data", ".", "_paginated", ")", "{", "if", "(", "sqlAST", ".", "sortKey", "||", "idx", "(", "sqlAST", ",", "_", "=>", "_", ".", "junction", ".", "sortKey", ")", ")", "{", "if", "(", "idx", "(", "sqlAST", ",", "_", "=>", "_", ".", "args", ".", "first", ")", ")", "{", "// we fetched an extra one in order to determine if there is a next page, if there is one, pop off that extra", "if", "(", "data", ".", "length", ">", "sqlAST", ".", "args", ".", "first", ")", "{", "pageInfo", ".", "hasNextPage", "=", "true", "data", ".", "pop", "(", ")", "}", "}", "else", "if", "(", "sqlAST", ".", "args", "&&", "sqlAST", ".", "args", ".", "last", ")", "{", "// if backward paging, do the same, but also reverse it", "if", "(", "data", ".", "length", ">", "sqlAST", ".", "args", ".", "last", ")", "{", "pageInfo", ".", "hasPreviousPage", "=", "true", "data", ".", "pop", "(", ")", "}", "data", ".", "reverse", "(", ")", "}", "// convert nodes to edges and compute the cursor for each", "// TODO: only compute all the cursor if asked for them", "const", "sortKey", "=", "sqlAST", ".", "sortKey", "||", "sqlAST", ".", "junction", ".", "sortKey", "const", "edges", "=", "data", ".", "map", "(", "obj", "=>", "{", "const", "cursor", "=", "{", "}", "const", "key", "=", "sortKey", ".", "key", "for", "(", "let", "column", "of", "wrap", "(", "key", ")", ")", "{", "cursor", "[", "column", "]", "=", "obj", "[", "column", "]", "}", "return", "{", "cursor", ":", "objToCursor", "(", "cursor", ")", ",", "node", ":", "obj", "}", "}", ")", "if", "(", "data", ".", "length", ")", "{", "pageInfo", ".", "startCursor", "=", "edges", "[", "0", "]", ".", "cursor", "pageInfo", ".", "endCursor", "=", "last", "(", "edges", ")", ".", "cursor", "}", "return", "{", "edges", ",", "pageInfo", ",", "_paginated", ":", "true", "}", "}", "if", "(", "sqlAST", ".", "orderBy", "||", "(", "sqlAST", ".", "junction", "&&", "sqlAST", ".", "junction", ".", "orderBy", ")", ")", "{", "let", "offset", "=", "0", "if", "(", "idx", "(", "sqlAST", ",", "_", "=>", "_", ".", "args", ".", "after", ")", ")", "{", "offset", "=", "cursorToOffset", "(", "sqlAST", ".", "args", ".", "after", ")", "+", "1", "}", "// $total was a special column for determining the total number of items", "const", "arrayLength", "=", "data", "[", "0", "]", "&&", "parseInt", "(", "data", "[", "0", "]", ".", "$total", ",", "10", ")", "const", "connection", "=", "connectionFromArraySlice", "(", "data", ",", "sqlAST", ".", "args", "||", "{", "}", ",", "{", "sliceStart", ":", "offset", ",", "arrayLength", "}", ")", "connection", ".", "total", "=", "arrayLength", "||", "0", "connection", ".", "_paginated", "=", "true", "return", "connection", "}", "}", "return", "data", "}"], "docstring": "a function for data manipulation AFTER its nested. this is only necessary when using the SQL pagination we have to interpret the slice that comes back and generate the Connection Object type", "docstring_tokens": ["a", "function", "for", "data", "manipulation", "AFTER", "its", "nested", ".", "this", "is", "only", "necessary", "when", "using", "the", "SQL", "pagination", "we", "have", "to", "interpret", "the", "slice", "that", "comes", "back", "and", "generate", "the", "Connection", "Object", "type"], "sha": "8db8b54aaefd2fd975d63e2ab3ec05922e25118c", "url": "https://github.com/acarl005/join-monster/blob/8db8b54aaefd2fd975d63e2ab3ec05922e25118c/src/array-to-connection.js#L8-L83", "partition": "test"}
{"repo": "lokku/jquery-nstslider", "path": "src/jquery.nstSlider.js", "func_name": "", "original_string": "function () {\n            var $this = this;\n\n            // re-set the slider step if specified\n            var lastStepHistogram = $this.data('last_step_histogram');\n            if (typeof lastStepHistogram !== 'undefined') {\n                methods.set_step_histogram.call($this, lastStepHistogram); \n            }\n\n            // re-center given values\n            _methods.set_position_from_val.call($this, \n                methods.get_current_min_value.call($this),\n                methods.get_current_max_value.call($this)\n            );\n\n            // re-highlight the range\n            var highlightRangeMin = $this.data('highlightedRangeMin');\n            if (typeof highlightRangeMin === 'number') {\n                // a highlight range is present, we must update it\n                var highlightRangeMax = $this.data('highlightedRangeMax');\n                methods.highlight_range.call($this, highlightRangeMin, highlightRangeMax);\n            }\n\n            _methods.notify_changed_implicit.call($this, 'refresh');\n            return $this;\n        }", "language": "javascript", "code": "function () {\n            var $this = this;\n\n            // re-set the slider step if specified\n            var lastStepHistogram = $this.data('last_step_histogram');\n            if (typeof lastStepHistogram !== 'undefined') {\n                methods.set_step_histogram.call($this, lastStepHistogram); \n            }\n\n            // re-center given values\n            _methods.set_position_from_val.call($this, \n                methods.get_current_min_value.call($this),\n                methods.get_current_max_value.call($this)\n            );\n\n            // re-highlight the range\n            var highlightRangeMin = $this.data('highlightedRangeMin');\n            if (typeof highlightRangeMin === 'number') {\n                // a highlight range is present, we must update it\n                var highlightRangeMax = $this.data('highlightedRangeMax');\n                methods.highlight_range.call($this, highlightRangeMin, highlightRangeMax);\n            }\n\n            _methods.notify_changed_implicit.call($this, 'refresh');\n            return $this;\n        }", "code_tokens": ["function", "(", ")", "{", "var", "$this", "=", "this", ";", "// re-set the slider step if specified", "var", "lastStepHistogram", "=", "$this", ".", "data", "(", "'last_step_histogram'", ")", ";", "if", "(", "typeof", "lastStepHistogram", "!==", "'undefined'", ")", "{", "methods", ".", "set_step_histogram", ".", "call", "(", "$this", ",", "lastStepHistogram", ")", ";", "}", "// re-center given values", "_methods", ".", "set_position_from_val", ".", "call", "(", "$this", ",", "methods", ".", "get_current_min_value", ".", "call", "(", "$this", ")", ",", "methods", ".", "get_current_max_value", ".", "call", "(", "$this", ")", ")", ";", "// re-highlight the range", "var", "highlightRangeMin", "=", "$this", ".", "data", "(", "'highlightedRangeMin'", ")", ";", "if", "(", "typeof", "highlightRangeMin", "===", "'number'", ")", "{", "// a highlight range is present, we must update it", "var", "highlightRangeMax", "=", "$this", ".", "data", "(", "'highlightedRangeMax'", ")", ";", "methods", ".", "highlight_range", ".", "call", "(", "$this", ",", "highlightRangeMin", ",", "highlightRangeMax", ")", ";", "}", "_methods", ".", "notify_changed_implicit", ".", "call", "(", "$this", ",", "'refresh'", ")", ";", "return", "$this", ";", "}"], "docstring": "just call set_position on the current values", "docstring_tokens": ["just", "call", "set_position", "on", "the", "current", "values"], "sha": "ebf2752c070f4fc0b787a26336f5952a4bb1a15c", "url": "https://github.com/lokku/jquery-nstslider/blob/ebf2752c070f4fc0b787a26336f5952a4bb1a15c/src/jquery.nstSlider.js#L1562-L1587", "partition": "test"}
{"repo": "mariusGundersen/descartes", "path": "lib/stringify.js", "func_name": "canonicalize", "original_string": "function canonicalize(value, stack) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  var type = getType(value);\n  function withStack(value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (stack.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (type) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function() {\n        canonicalizedObj = value.map(function(item) {\n          return canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, type);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function() {\n        Object.keys(value).sort().forEach(function(key) {\n          canonicalizedObj[key] = canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value.toString();\n  }\n\n  return canonicalizedObj;\n}", "language": "javascript", "code": "function canonicalize(value, stack) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  var type = getType(value);\n  function withStack(value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (stack.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (type) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function() {\n        canonicalizedObj = value.map(function(item) {\n          return canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, type);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function() {\n        Object.keys(value).sort().forEach(function(key) {\n          canonicalizedObj[key] = canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value.toString();\n  }\n\n  return canonicalizedObj;\n}", "code_tokens": ["function", "canonicalize", "(", "value", ",", "stack", ")", "{", "var", "canonicalizedObj", ";", "/* eslint-disable no-unused-vars */", "var", "prop", ";", "/* eslint-enable no-unused-vars */", "var", "type", "=", "getType", "(", "value", ")", ";", "function", "withStack", "(", "value", ",", "fn", ")", "{", "stack", ".", "push", "(", "value", ")", ";", "fn", "(", ")", ";", "stack", ".", "pop", "(", ")", ";", "}", "stack", "=", "stack", "||", "[", "]", ";", "if", "(", "stack", ".", "indexOf", "(", "value", ")", "!==", "-", "1", ")", "{", "return", "'[Circular]'", ";", "}", "switch", "(", "type", ")", "{", "case", "'undefined'", ":", "case", "'buffer'", ":", "case", "'null'", ":", "canonicalizedObj", "=", "value", ";", "break", ";", "case", "'array'", ":", "withStack", "(", "value", ",", "function", "(", ")", "{", "canonicalizedObj", "=", "value", ".", "map", "(", "function", "(", "item", ")", "{", "return", "canonicalize", "(", "item", ",", "stack", ")", ";", "}", ")", ";", "}", ")", ";", "break", ";", "case", "'function'", ":", "/* eslint-disable guard-for-in */", "for", "(", "prop", "in", "value", ")", "{", "canonicalizedObj", "=", "{", "}", ";", "break", ";", "}", "/* eslint-enable guard-for-in */", "if", "(", "!", "canonicalizedObj", ")", "{", "canonicalizedObj", "=", "emptyRepresentation", "(", "value", ",", "type", ")", ";", "break", ";", "}", "/* falls through */", "case", "'object'", ":", "canonicalizedObj", "=", "canonicalizedObj", "||", "{", "}", ";", "withStack", "(", "value", ",", "function", "(", ")", "{", "Object", ".", "keys", "(", "value", ")", ".", "sort", "(", ")", ".", "forEach", "(", "function", "(", "key", ")", "{", "canonicalizedObj", "[", "key", "]", "=", "canonicalize", "(", "value", "[", "key", "]", ",", "stack", ")", ";", "}", ")", ";", "}", ")", ";", "break", ";", "case", "'date'", ":", "case", "'number'", ":", "case", "'regexp'", ":", "case", "'boolean'", ":", "canonicalizedObj", "=", "value", ";", "break", ";", "default", ":", "canonicalizedObj", "=", "value", ".", "toString", "(", ")", ";", "}", "return", "canonicalizedObj", ";", "}"], "docstring": "Return a new Thing that has the keys in sorted order. Recursive.\n\nIf the Thing...\n- has already been seen, return string `'[Circular]'`\n- is `undefined`, return string `'[undefined]'`\n- is `null`, return value `null`\n- is some other primitive, return the value\n- is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n- is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n- is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`", "docstring_tokens": ["Return", "a", "new", "Thing", "that", "has", "the", "keys", "in", "sorted", "order", ".", "Recursive", "."], "sha": "743c71a6e042feaeab65d74be8f0c593850caa5d", "url": "https://github.com/mariusGundersen/descartes/blob/743c71a6e042feaeab65d74be8f0c593850caa5d/lib/stringify.js#L150-L212", "partition": "test"}
{"repo": "intelligo-systems/intelligo.js", "path": "dist/multilabel/PartialClassification.js", "func_name": "", "original_string": "function(opts) {\n\t\n\topts = opts || {};\n\tif (!opts.multilabelClassifierType) {\n\t\tconsole.dir(opts);\n\t\tthrow new Error(\"opts.multilabelClassifierType is null\");\n\t}\n\n\tif (!opts.numberofclassifiers) {\n\t\tconsole.dir(opts);\n\t\tthrow new Error(\"opts.numberofclassifiers is null\");\n\t}\n\n\t// this.splitLabel = opts.splitLabel || function(label)      {return label.split(/@/);}\n\tthis.classifier = this.intializeClassifiers(opts.numberofclassifiers, opts.multilabelClassifierType)\n}", "language": "javascript", "code": "function(opts) {\n\t\n\topts = opts || {};\n\tif (!opts.multilabelClassifierType) {\n\t\tconsole.dir(opts);\n\t\tthrow new Error(\"opts.multilabelClassifierType is null\");\n\t}\n\n\tif (!opts.numberofclassifiers) {\n\t\tconsole.dir(opts);\n\t\tthrow new Error(\"opts.numberofclassifiers is null\");\n\t}\n\n\t// this.splitLabel = opts.splitLabel || function(label)      {return label.split(/@/);}\n\tthis.classifier = this.intializeClassifiers(opts.numberofclassifiers, opts.multilabelClassifierType)\n}", "code_tokens": ["function", "(", "opts", ")", "{", "opts", "=", "opts", "||", "{", "}", ";", "if", "(", "!", "opts", ".", "multilabelClassifierType", ")", "{", "console", ".", "dir", "(", "opts", ")", ";", "throw", "new", "Error", "(", "\"opts.multilabelClassifierType is null\"", ")", ";", "}", "if", "(", "!", "opts", ".", "numberofclassifiers", ")", "{", "console", ".", "dir", "(", "opts", ")", ";", "throw", "new", "Error", "(", "\"opts.numberofclassifiers is null\"", ")", ";", "}", "// this.splitLabel = opts.splitLabel || function(label)      {return label.split(/@/);}", "this", ".", "classifier", "=", "this", ".", "intializeClassifiers", "(", "opts", ".", "numberofclassifiers", ",", "opts", ".", "multilabelClassifierType", ")", "}"], "docstring": "PartialClassification is a test classifier that learns and classifies the components\nof the labels separately according to the splitLabel routine. One of the examples could be\nclassifying intent, attribute, value separately by three different classifiers.\nWhen performing test by trainAndTest module, there is a check for toFormat routine, if it exists\nthen pretest format converting occurs.\n\n@author Vasily Konovalov\n@since March 2014", "docstring_tokens": ["PartialClassification", "is", "a", "test", "classifier", "that", "learns", "and", "classifies", "the", "components", "of", "the", "labels", "separately", "according", "to", "the", "splitLabel", "routine", ".", "One", "of", "the", "examples", "could", "be", "classifying", "intent", "attribute", "value", "separately", "by", "three", "different", "classifiers", ".", "When", "performing", "test", "by", "trainAndTest", "module", "there", "is", "a", "check", "for", "toFormat", "routine", "if", "it", "exists", "then", "pretest", "format", "converting", "occurs", "."], "sha": "9e75d48214fb41d346462f5d886bd92cc9956df6", "url": "https://github.com/intelligo-systems/intelligo.js/blob/9e75d48214fb41d346462f5d886bd92cc9956df6/dist/multilabel/PartialClassification.js#L16-L31", "partition": "test"}
{"repo": "ifrost/protoplast", "path": "js/component.js", "func_name": "", "original_string": "function(child, element, root) {\n        this._children.push(child);\n        (root || this.root).insertBefore(child.root, element);\n        (root || this.root).removeChild(element);\n    }", "language": "javascript", "code": "function(child, element, root) {\n        this._children.push(child);\n        (root || this.root).insertBefore(child.root, element);\n        (root || this.root).removeChild(element);\n    }", "code_tokens": ["function", "(", "child", ",", "element", ",", "root", ")", "{", "this", ".", "_children", ".", "push", "(", "child", ")", ";", "(", "root", "||", "this", ".", "root", ")", ".", "insertBefore", "(", "child", ".", "root", ",", "element", ")", ";", "(", "root", "||", "this", ".", "root", ")", ".", "removeChild", "(", "element", ")", ";", "}"], "docstring": "Attaches a component by replacing the provided element. Element must be an element inside the parent component.\n@param {Component} child\n@param {Element} element\n@param {HTMLElement} root if different than child.root", "docstring_tokens": ["Attaches", "a", "component", "by", "replacing", "the", "provided", "element", ".", "Element", "must", "be", "an", "element", "inside", "the", "parent", "component", "."], "sha": "6ff349404c38a92f8715ab746953adf2dc8d8df6", "url": "https://github.com/ifrost/protoplast/blob/6ff349404c38a92f8715ab746953adf2dc8d8df6/js/component.js#L224-L228", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "uniqSet", "original_string": "function uniqSet(arr) {\n    \tvar seen = new Set();\n    \treturn arr.filter(function (el) {\n    \t\tif (!seen.has(el)) {\n    \t\t\tseen.add(el);\n    \t\t\treturn true;\n    \t\t}\n    \t});\n    }", "language": "javascript", "code": "function uniqSet(arr) {\n    \tvar seen = new Set();\n    \treturn arr.filter(function (el) {\n    \t\tif (!seen.has(el)) {\n    \t\t\tseen.add(el);\n    \t\t\treturn true;\n    \t\t}\n    \t});\n    }", "code_tokens": ["function", "uniqSet", "(", "arr", ")", "{", "var", "seen", "=", "new", "Set", "(", ")", ";", "return", "arr", ".", "filter", "(", "function", "(", "el", ")", "{", "if", "(", "!", "seen", ".", "has", "(", "el", ")", ")", "{", "seen", ".", "add", "(", "el", ")", ";", "return", "true", ";", "}", "}", ")", ";", "}"], "docstring": "2 - a simple Set type is defined", "docstring_tokens": ["2", "-", "a", "simple", "Set", "type", "is", "defined"], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L44468-L44476", "partition": "test"}
{"repo": "wooorm/fault", "path": "index.js", "func_name": "create", "original_string": "function create(EConstructor) {\n  FormattedError.displayName = EConstructor.displayName || EConstructor.name\n\n  return FormattedError\n\n  function FormattedError(format) {\n    if (format) {\n      format = formatter.apply(null, arguments)\n    }\n\n    return new EConstructor(format)\n  }\n}", "language": "javascript", "code": "function create(EConstructor) {\n  FormattedError.displayName = EConstructor.displayName || EConstructor.name\n\n  return FormattedError\n\n  function FormattedError(format) {\n    if (format) {\n      format = formatter.apply(null, arguments)\n    }\n\n    return new EConstructor(format)\n  }\n}", "code_tokens": ["function", "create", "(", "EConstructor", ")", "{", "FormattedError", ".", "displayName", "=", "EConstructor", ".", "displayName", "||", "EConstructor", ".", "name", "return", "FormattedError", "function", "FormattedError", "(", "format", ")", "{", "if", "(", "format", ")", "{", "format", "=", "formatter", ".", "apply", "(", "null", ",", "arguments", ")", "}", "return", "new", "EConstructor", "(", "format", ")", "}", "}"], "docstring": "Create a new `EConstructor`, with the formatted `format` as a first argument.", "docstring_tokens": ["Create", "a", "new", "EConstructor", "with", "the", "formatted", "format", "as", "a", "first", "argument", "."], "sha": "e2b74b756eecf4f19d61eb26ab1f96cc4c081a9b", "url": "https://github.com/wooorm/fault/blob/e2b74b756eecf4f19d61eb26ab1f96cc4c081a9b/index.js#L19-L31", "partition": "test"}
{"repo": "Semantic-Org/Semantic-UI-React", "path": "src/elements/Container/Container.js", "func_name": "Container", "original_string": "function Container(props) {\n  const { children, className, content, fluid, text, textAlign } = props\n  const classes = cx(\n    'ui',\n    useKeyOnly(text, 'text'),\n    useKeyOnly(fluid, 'fluid'),\n    useTextAlignProp(textAlign),\n    'container',\n    className,\n  )\n  const rest = getUnhandledProps(Container, props)\n  const ElementType = getElementType(Container, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "language": "javascript", "code": "function Container(props) {\n  const { children, className, content, fluid, text, textAlign } = props\n  const classes = cx(\n    'ui',\n    useKeyOnly(text, 'text'),\n    useKeyOnly(fluid, 'fluid'),\n    useTextAlignProp(textAlign),\n    'container',\n    className,\n  )\n  const rest = getUnhandledProps(Container, props)\n  const ElementType = getElementType(Container, props)\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {childrenUtils.isNil(children) ? content : children}\n    </ElementType>\n  )\n}", "code_tokens": ["function", "Container", "(", "props", ")", "{", "const", "{", "children", ",", "className", ",", "content", ",", "fluid", ",", "text", ",", "textAlign", "}", "=", "props", "const", "classes", "=", "cx", "(", "'ui'", ",", "useKeyOnly", "(", "text", ",", "'text'", ")", ",", "useKeyOnly", "(", "fluid", ",", "'fluid'", ")", ",", "useTextAlignProp", "(", "textAlign", ")", ",", "'container'", ",", "className", ",", ")", "const", "rest", "=", "getUnhandledProps", "(", "Container", ",", "props", ")", "const", "ElementType", "=", "getElementType", "(", "Container", ",", "props", ")", "return", "(", "<", "ElementType", "{", "...", "rest", "}", "className", "=", "{", "classes", "}", ">", "\n      ", "{", "childrenUtils", ".", "isNil", "(", "children", ")", "?", "content", ":", "children", "}", "\n    ", "<", "/", "ElementType", ">", ")", "}"], "docstring": "A container limits content to a maximum width.", "docstring_tokens": ["A", "container", "limits", "content", "to", "a", "maximum", "width", "."], "sha": "c42f7351df35ba1861f1dce2b01c6861a4011075", "url": "https://github.com/Semantic-Org/Semantic-UI-React/blob/c42f7351df35ba1861f1dce2b01c6861a4011075/src/elements/Container/Container.js#L18-L36", "partition": "test"}
{"repo": "mesqueeb/vuex-easy-firestore", "path": "dist/index.esm.js", "func_name": "makeBatchFromSyncstack", "original_string": "function makeBatchFromSyncstack(state, getters, Firebase, batchMaxCount) {\n    if (batchMaxCount === void 0) { batchMaxCount = 500; }\n    // get state & getter variables\n    var firestorePath = state._conf.firestorePath;\n    var firestorePathComplete = getters.firestorePathComplete;\n    var dbRef = getters.dbRef;\n    var collectionMode = getters.collectionMode;\n    // make batch\n    var batch = Firebase.firestore().batch();\n    var log = {};\n    var count = 0;\n    // Add 'updates' to batch\n    var updates = grabUntilApiLimit('updates', count, batchMaxCount, state);\n    log['updates: '] = updates;\n    count = count + updates.length;\n    // Add to batch\n    updates.forEach(function (item) {\n        var id = item.id;\n        var docRef = (collectionMode) ? dbRef.doc(id) : dbRef;\n        if (state._conf.sync.guard.includes('id'))\n            delete item.id;\n        // @ts-ignore\n        batch.update(docRef, item);\n    });\n    // Add 'propDeletions' to batch\n    var propDeletions = grabUntilApiLimit('propDeletions', count, batchMaxCount, state);\n    log['prop deletions: '] = propDeletions;\n    count = count + propDeletions.length;\n    // Add to batch\n    propDeletions.forEach(function (item) {\n        var id = item.id;\n        var docRef = (collectionMode) ? dbRef.doc(id) : dbRef;\n        if (state._conf.sync.guard.includes('id'))\n            delete item.id;\n        // @ts-ignore\n        batch.update(docRef, item);\n    });\n    // Add 'deletions' to batch\n    var deletions = grabUntilApiLimit('deletions', count, batchMaxCount, state);\n    log['deletions: '] = deletions;\n    count = count + deletions.length;\n    // Add to batch\n    deletions.forEach(function (id) {\n        var docRef = dbRef.doc(id);\n        batch.delete(docRef);\n    });\n    // Add 'inserts' to batch\n    var inserts = grabUntilApiLimit('inserts', count, batchMaxCount, state);\n    log['inserts: '] = inserts;\n    count = count + inserts.length;\n    // Add to batch\n    inserts.forEach(function (item) {\n        var newRef = dbRef.doc(item.id);\n        batch.set(newRef, item);\n    });\n    // log the batch contents\n    if (state._conf.logging) {\n        console.group('[vuex-easy-firestore] api call batch:');\n        console.log(\"%cFirestore PATH: \" + firestorePathComplete + \" [\" + firestorePath + \"]\", 'color: grey');\n        Object.keys(log).forEach(function (key) {\n            console.log(key, log[key]);\n        });\n        console.groupEnd();\n    }\n    return batch;\n}", "language": "javascript", "code": "function makeBatchFromSyncstack(state, getters, Firebase, batchMaxCount) {\n    if (batchMaxCount === void 0) { batchMaxCount = 500; }\n    // get state & getter variables\n    var firestorePath = state._conf.firestorePath;\n    var firestorePathComplete = getters.firestorePathComplete;\n    var dbRef = getters.dbRef;\n    var collectionMode = getters.collectionMode;\n    // make batch\n    var batch = Firebase.firestore().batch();\n    var log = {};\n    var count = 0;\n    // Add 'updates' to batch\n    var updates = grabUntilApiLimit('updates', count, batchMaxCount, state);\n    log['updates: '] = updates;\n    count = count + updates.length;\n    // Add to batch\n    updates.forEach(function (item) {\n        var id = item.id;\n        var docRef = (collectionMode) ? dbRef.doc(id) : dbRef;\n        if (state._conf.sync.guard.includes('id'))\n            delete item.id;\n        // @ts-ignore\n        batch.update(docRef, item);\n    });\n    // Add 'propDeletions' to batch\n    var propDeletions = grabUntilApiLimit('propDeletions', count, batchMaxCount, state);\n    log['prop deletions: '] = propDeletions;\n    count = count + propDeletions.length;\n    // Add to batch\n    propDeletions.forEach(function (item) {\n        var id = item.id;\n        var docRef = (collectionMode) ? dbRef.doc(id) : dbRef;\n        if (state._conf.sync.guard.includes('id'))\n            delete item.id;\n        // @ts-ignore\n        batch.update(docRef, item);\n    });\n    // Add 'deletions' to batch\n    var deletions = grabUntilApiLimit('deletions', count, batchMaxCount, state);\n    log['deletions: '] = deletions;\n    count = count + deletions.length;\n    // Add to batch\n    deletions.forEach(function (id) {\n        var docRef = dbRef.doc(id);\n        batch.delete(docRef);\n    });\n    // Add 'inserts' to batch\n    var inserts = grabUntilApiLimit('inserts', count, batchMaxCount, state);\n    log['inserts: '] = inserts;\n    count = count + inserts.length;\n    // Add to batch\n    inserts.forEach(function (item) {\n        var newRef = dbRef.doc(item.id);\n        batch.set(newRef, item);\n    });\n    // log the batch contents\n    if (state._conf.logging) {\n        console.group('[vuex-easy-firestore] api call batch:');\n        console.log(\"%cFirestore PATH: \" + firestorePathComplete + \" [\" + firestorePath + \"]\", 'color: grey');\n        Object.keys(log).forEach(function (key) {\n            console.log(key, log[key]);\n        });\n        console.groupEnd();\n    }\n    return batch;\n}", "code_tokens": ["function", "makeBatchFromSyncstack", "(", "state", ",", "getters", ",", "Firebase", ",", "batchMaxCount", ")", "{", "if", "(", "batchMaxCount", "===", "void", "0", ")", "{", "batchMaxCount", "=", "500", ";", "}", "// get state & getter variables", "var", "firestorePath", "=", "state", ".", "_conf", ".", "firestorePath", ";", "var", "firestorePathComplete", "=", "getters", ".", "firestorePathComplete", ";", "var", "dbRef", "=", "getters", ".", "dbRef", ";", "var", "collectionMode", "=", "getters", ".", "collectionMode", ";", "// make batch", "var", "batch", "=", "Firebase", ".", "firestore", "(", ")", ".", "batch", "(", ")", ";", "var", "log", "=", "{", "}", ";", "var", "count", "=", "0", ";", "// Add 'updates' to batch", "var", "updates", "=", "grabUntilApiLimit", "(", "'updates'", ",", "count", ",", "batchMaxCount", ",", "state", ")", ";", "log", "[", "'updates: '", "]", "=", "updates", ";", "count", "=", "count", "+", "updates", ".", "length", ";", "// Add to batch", "updates", ".", "forEach", "(", "function", "(", "item", ")", "{", "var", "id", "=", "item", ".", "id", ";", "var", "docRef", "=", "(", "collectionMode", ")", "?", "dbRef", ".", "doc", "(", "id", ")", ":", "dbRef", ";", "if", "(", "state", ".", "_conf", ".", "sync", ".", "guard", ".", "includes", "(", "'id'", ")", ")", "delete", "item", ".", "id", ";", "// @ts-ignore", "batch", ".", "update", "(", "docRef", ",", "item", ")", ";", "}", ")", ";", "// Add 'propDeletions' to batch", "var", "propDeletions", "=", "grabUntilApiLimit", "(", "'propDeletions'", ",", "count", ",", "batchMaxCount", ",", "state", ")", ";", "log", "[", "'prop deletions: '", "]", "=", "propDeletions", ";", "count", "=", "count", "+", "propDeletions", ".", "length", ";", "// Add to batch", "propDeletions", ".", "forEach", "(", "function", "(", "item", ")", "{", "var", "id", "=", "item", ".", "id", ";", "var", "docRef", "=", "(", "collectionMode", ")", "?", "dbRef", ".", "doc", "(", "id", ")", ":", "dbRef", ";", "if", "(", "state", ".", "_conf", ".", "sync", ".", "guard", ".", "includes", "(", "'id'", ")", ")", "delete", "item", ".", "id", ";", "// @ts-ignore", "batch", ".", "update", "(", "docRef", ",", "item", ")", ";", "}", ")", ";", "// Add 'deletions' to batch", "var", "deletions", "=", "grabUntilApiLimit", "(", "'deletions'", ",", "count", ",", "batchMaxCount", ",", "state", ")", ";", "log", "[", "'deletions: '", "]", "=", "deletions", ";", "count", "=", "count", "+", "deletions", ".", "length", ";", "// Add to batch", "deletions", ".", "forEach", "(", "function", "(", "id", ")", "{", "var", "docRef", "=", "dbRef", ".", "doc", "(", "id", ")", ";", "batch", ".", "delete", "(", "docRef", ")", ";", "}", ")", ";", "// Add 'inserts' to batch", "var", "inserts", "=", "grabUntilApiLimit", "(", "'inserts'", ",", "count", ",", "batchMaxCount", ",", "state", ")", ";", "log", "[", "'inserts: '", "]", "=", "inserts", ";", "count", "=", "count", "+", "inserts", ".", "length", ";", "// Add to batch", "inserts", ".", "forEach", "(", "function", "(", "item", ")", "{", "var", "newRef", "=", "dbRef", ".", "doc", "(", "item", ".", "id", ")", ";", "batch", ".", "set", "(", "newRef", ",", "item", ")", ";", "}", ")", ";", "// log the batch contents", "if", "(", "state", ".", "_conf", ".", "logging", ")", "{", "console", ".", "group", "(", "'[vuex-easy-firestore] api call batch:'", ")", ";", "console", ".", "log", "(", "\"%cFirestore PATH: \"", "+", "firestorePathComplete", "+", "\" [\"", "+", "firestorePath", "+", "\"]\"", ",", "'color: grey'", ")", ";", "Object", ".", "keys", "(", "log", ")", ".", "forEach", "(", "function", "(", "key", ")", "{", "console", ".", "log", "(", "key", ",", "log", "[", "key", "]", ")", ";", "}", ")", ";", "console", ".", "groupEnd", "(", ")", ";", "}", "return", "batch", ";", "}"], "docstring": "Create a Firebase batch from a syncStack to be passed inside the state param.\n\n@export\n@param {IPluginState} state The state which should have `_sync.syncStack`, `_sync.userId`, `state._conf.firestorePath`\n@param {AnyObject} getters The getters which should have `dbRef`, `storeRef`, `collectionMode` and `firestorePathComplete`\n@param {any} Firebase dependency injection for Firebase & Firestore\n@param {number} [batchMaxCount=500] The max count of the batch. Defaults to 500 as per Firestore documentation.\n@returns {*} A Firebase firestore batch object.", "docstring_tokens": ["Create", "a", "Firebase", "batch", "from", "a", "syncStack", "to", "be", "passed", "inside", "the", "state", "param", "."], "sha": "08695ae1abd5c5bbfb6c3cfb618f17e7249f5667", "url": "https://github.com/mesqueeb/vuex-easy-firestore/blob/08695ae1abd5c5bbfb6c3cfb618f17e7249f5667/dist/index.esm.js#L530-L595", "partition": "test"}
{"repo": "daliwali/simulacra", "path": "lib/process_nodes.js", "func_name": "processNodes", "original_string": "function processNodes (scope, node, def) {\n  var document = scope ? scope.document : window.document\n  var key, branch, result, mirrorNode, parent, marker, indices\n  var i, j, treeWalker, orderedKeys\n\n  result = def[templateKey]\n\n  if (!result) {\n    node = node.cloneNode(true)\n\n    indices = []\n\n    matchNodes(scope, node, def)\n\n    orderedKeys = Object.keys(def).sort(function (a, b) {\n      var nodeA = def[a][0][matchedNodeKey]\n      var nodeB = def[b][0][matchedNodeKey]\n\n      if (nodeA && nodeB)\n        return nodeA.index - nodeB.index\n\n      return 0\n    })\n\n    for (i = 0; i < orderedKeys.length; i++) {\n      key = orderedKeys[i]\n      branch = def[key]\n      if (branch[isBoundToParentKey]) continue\n\n      result = branch[0][matchedNodeKey]\n      indices.push(result.index)\n      mirrorNode = result.node\n      parent = mirrorNode.parentNode\n\n      // This value is memoized so that `appendChild` can be used instead of\n      // `insertBefore`, which is a performance optimization.\n      if (mirrorNode.nextElementSibling === null)\n        branch[isMarkerLastKey] = true\n\n      if (processNodes.useCommentNode) {\n        marker = parent.insertBefore(\n          document.createComment(' end \"' + key + '\" '), mirrorNode)\n        parent.insertBefore(\n          document.createComment(' begin \"' + key + '\" '), marker)\n      }\n      else marker = parent.insertBefore(\n        document.createTextNode(''), mirrorNode)\n\n      branch[markerKey] = marker\n\n      parent.removeChild(mirrorNode)\n    }\n\n    Object.defineProperty(def, templateKey, {\n      value: {\n        node: node.cloneNode(true),\n        indices: indices\n      }\n    })\n  }\n  else {\n    node = result.node.cloneNode(true)\n    indices = result.indices\n    i = 0\n    j = 0\n\n    treeWalker = document.createTreeWalker(\n      node, showAll, acceptNode, false)\n\n    for (key in def) {\n      branch = def[key]\n      if (branch[isBoundToParentKey]) continue\n\n      while (treeWalker.nextNode()) {\n        if (i === indices[j]) {\n          branch[markerKey] = treeWalker.currentNode\n          i++\n          break\n        }\n        i++\n      }\n\n      j++\n    }\n  }\n\n  return node\n}", "language": "javascript", "code": "function processNodes (scope, node, def) {\n  var document = scope ? scope.document : window.document\n  var key, branch, result, mirrorNode, parent, marker, indices\n  var i, j, treeWalker, orderedKeys\n\n  result = def[templateKey]\n\n  if (!result) {\n    node = node.cloneNode(true)\n\n    indices = []\n\n    matchNodes(scope, node, def)\n\n    orderedKeys = Object.keys(def).sort(function (a, b) {\n      var nodeA = def[a][0][matchedNodeKey]\n      var nodeB = def[b][0][matchedNodeKey]\n\n      if (nodeA && nodeB)\n        return nodeA.index - nodeB.index\n\n      return 0\n    })\n\n    for (i = 0; i < orderedKeys.length; i++) {\n      key = orderedKeys[i]\n      branch = def[key]\n      if (branch[isBoundToParentKey]) continue\n\n      result = branch[0][matchedNodeKey]\n      indices.push(result.index)\n      mirrorNode = result.node\n      parent = mirrorNode.parentNode\n\n      // This value is memoized so that `appendChild` can be used instead of\n      // `insertBefore`, which is a performance optimization.\n      if (mirrorNode.nextElementSibling === null)\n        branch[isMarkerLastKey] = true\n\n      if (processNodes.useCommentNode) {\n        marker = parent.insertBefore(\n          document.createComment(' end \"' + key + '\" '), mirrorNode)\n        parent.insertBefore(\n          document.createComment(' begin \"' + key + '\" '), marker)\n      }\n      else marker = parent.insertBefore(\n        document.createTextNode(''), mirrorNode)\n\n      branch[markerKey] = marker\n\n      parent.removeChild(mirrorNode)\n    }\n\n    Object.defineProperty(def, templateKey, {\n      value: {\n        node: node.cloneNode(true),\n        indices: indices\n      }\n    })\n  }\n  else {\n    node = result.node.cloneNode(true)\n    indices = result.indices\n    i = 0\n    j = 0\n\n    treeWalker = document.createTreeWalker(\n      node, showAll, acceptNode, false)\n\n    for (key in def) {\n      branch = def[key]\n      if (branch[isBoundToParentKey]) continue\n\n      while (treeWalker.nextNode()) {\n        if (i === indices[j]) {\n          branch[markerKey] = treeWalker.currentNode\n          i++\n          break\n        }\n        i++\n      }\n\n      j++\n    }\n  }\n\n  return node\n}", "code_tokens": ["function", "processNodes", "(", "scope", ",", "node", ",", "def", ")", "{", "var", "document", "=", "scope", "?", "scope", ".", "document", ":", "window", ".", "document", "var", "key", ",", "branch", ",", "result", ",", "mirrorNode", ",", "parent", ",", "marker", ",", "indices", "var", "i", ",", "j", ",", "treeWalker", ",", "orderedKeys", "result", "=", "def", "[", "templateKey", "]", "if", "(", "!", "result", ")", "{", "node", "=", "node", ".", "cloneNode", "(", "true", ")", "indices", "=", "[", "]", "matchNodes", "(", "scope", ",", "node", ",", "def", ")", "orderedKeys", "=", "Object", ".", "keys", "(", "def", ")", ".", "sort", "(", "function", "(", "a", ",", "b", ")", "{", "var", "nodeA", "=", "def", "[", "a", "]", "[", "0", "]", "[", "matchedNodeKey", "]", "var", "nodeB", "=", "def", "[", "b", "]", "[", "0", "]", "[", "matchedNodeKey", "]", "if", "(", "nodeA", "&&", "nodeB", ")", "return", "nodeA", ".", "index", "-", "nodeB", ".", "index", "return", "0", "}", ")", "for", "(", "i", "=", "0", ";", "i", "<", "orderedKeys", ".", "length", ";", "i", "++", ")", "{", "key", "=", "orderedKeys", "[", "i", "]", "branch", "=", "def", "[", "key", "]", "if", "(", "branch", "[", "isBoundToParentKey", "]", ")", "continue", "result", "=", "branch", "[", "0", "]", "[", "matchedNodeKey", "]", "indices", ".", "push", "(", "result", ".", "index", ")", "mirrorNode", "=", "result", ".", "node", "parent", "=", "mirrorNode", ".", "parentNode", "// This value is memoized so that `appendChild` can be used instead of", "// `insertBefore`, which is a performance optimization.", "if", "(", "mirrorNode", ".", "nextElementSibling", "===", "null", ")", "branch", "[", "isMarkerLastKey", "]", "=", "true", "if", "(", "processNodes", ".", "useCommentNode", ")", "{", "marker", "=", "parent", ".", "insertBefore", "(", "document", ".", "createComment", "(", "' end \"'", "+", "key", "+", "'\" '", ")", ",", "mirrorNode", ")", "parent", ".", "insertBefore", "(", "document", ".", "createComment", "(", "' begin \"'", "+", "key", "+", "'\" '", ")", ",", "marker", ")", "}", "else", "marker", "=", "parent", ".", "insertBefore", "(", "document", ".", "createTextNode", "(", "''", ")", ",", "mirrorNode", ")", "branch", "[", "markerKey", "]", "=", "marker", "parent", ".", "removeChild", "(", "mirrorNode", ")", "}", "Object", ".", "defineProperty", "(", "def", ",", "templateKey", ",", "{", "value", ":", "{", "node", ":", "node", ".", "cloneNode", "(", "true", ")", ",", "indices", ":", "indices", "}", "}", ")", "}", "else", "{", "node", "=", "result", ".", "node", ".", "cloneNode", "(", "true", ")", "indices", "=", "result", ".", "indices", "i", "=", "0", "j", "=", "0", "treeWalker", "=", "document", ".", "createTreeWalker", "(", "node", ",", "showAll", ",", "acceptNode", ",", "false", ")", "for", "(", "key", "in", "def", ")", "{", "branch", "=", "def", "[", "key", "]", "if", "(", "branch", "[", "isBoundToParentKey", "]", ")", "continue", "while", "(", "treeWalker", ".", "nextNode", "(", ")", ")", "{", "if", "(", "i", "===", "indices", "[", "j", "]", ")", "{", "branch", "[", "markerKey", "]", "=", "treeWalker", ".", "currentNode", "i", "++", "break", "}", "i", "++", "}", "j", "++", "}", "}", "return", "node", "}"], "docstring": "Internal function to remove bound nodes and replace them with markers.\n\n@param {*} [scope]\n@param {Node} node\n@param {Object} def\n@return {Node}", "docstring_tokens": ["Internal", "function", "to", "remove", "bound", "nodes", "and", "replace", "them", "with", "markers", "."], "sha": "b6bb7e2486f7722101f9e416ec345d49f3afa901", "url": "https://github.com/daliwali/simulacra/blob/b6bb7e2486f7722101f9e416ec345d49f3afa901/lib/process_nodes.js#L31-L118", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(name, value) {\n    var attributes = this.elementAttributes = (this.elementAttributes || {});\n\n    if (arguments.length === 1) {\n      return attributes[name];\n    } else {\n      attributes[name] = value;\n    }\n\n    return this;\n  }", "language": "javascript", "code": "function(name, value) {\n    var attributes = this.elementAttributes = (this.elementAttributes || {});\n\n    if (arguments.length === 1) {\n      return attributes[name];\n    } else {\n      attributes[name] = value;\n    }\n\n    return this;\n  }", "code_tokens": ["function", "(", "name", ",", "value", ")", "{", "var", "attributes", "=", "this", ".", "elementAttributes", "=", "(", "this", ".", "elementAttributes", "||", "{", "}", ")", ";", "if", "(", "arguments", ".", "length", "===", "1", ")", "{", "return", "attributes", "[", "name", "]", ";", "}", "else", "{", "attributes", "[", "name", "]", "=", "value", ";", "}", "return", "this", ";", "}"], "docstring": "duck type attribute functionality like jQuery so a render buffer can be used like a jQuery object in attribute binding scenarios. \nAdds an attribute which will be rendered to the element.\n\n@method attr\n@param {String} name The name of the attribute\n@param {String} value The value to add to the attribute\n@chainable\n@return {Ember.RenderBuffer|String} this or the current attribute value", "docstring_tokens": ["duck", "type", "attribute", "functionality", "like", "jQuery", "so", "a", "render", "buffer", "can", "be", "used", "like", "a", "jQuery", "object", "in", "attribute", "binding", "scenarios", ".", "Adds", "an", "attribute", "which", "will", "be", "rendered", "to", "the", "element", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L21822-L21832", "partition": "test"}
{"repo": "DeadAlready/node-easy-pipe", "path": "lib/pipeStream.js", "func_name": "connectEvents", "original_string": "function connectEvents(self){\n    if(self.stdout){\n        self.stdout.on('data', function(d){\n            self.emit('data', d);\n        });\n        self.stderr.on('data', function(d){\n            self.emit('error', d);\n        });\n    }\n}", "language": "javascript", "code": "function connectEvents(self){\n    if(self.stdout){\n        self.stdout.on('data', function(d){\n            self.emit('data', d);\n        });\n        self.stderr.on('data', function(d){\n            self.emit('error', d);\n        });\n    }\n}", "code_tokens": ["function", "connectEvents", "(", "self", ")", "{", "if", "(", "self", ".", "stdout", ")", "{", "self", ".", "stdout", ".", "on", "(", "'data'", ",", "function", "(", "d", ")", "{", "self", ".", "emit", "(", "'data'", ",", "d", ")", ";", "}", ")", ";", "self", ".", "stderr", ".", "on", "(", "'data'", ",", "function", "(", "d", ")", "{", "self", ".", "emit", "(", "'error'", ",", "d", ")", ";", "}", ")", ";", "}", "}"], "docstring": "Function for connecting some events\n\n@param {EventEmitter} self", "docstring_tokens": ["Function", "for", "connecting", "some", "events"], "sha": "e739e052494cd6be96c95bc65e34442042243e7d", "url": "https://github.com/DeadAlready/node-easy-pipe/blob/e739e052494cd6be96c95bc65e34442042243e7d/lib/pipeStream.js#L218-L227", "partition": "test"}
{"repo": "trufflesuite/ganache-core", "path": "lib/utils/txrejectederror.js", "func_name": "TXRejectedError", "original_string": "function TXRejectedError(message) {\n  // Why not just Error.apply(this, [message])? See\n  // https://gist.github.com/justmoon/15511f92e5216fa2624b#anti-patterns\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n}", "language": "javascript", "code": "function TXRejectedError(message) {\n  // Why not just Error.apply(this, [message])? See\n  // https://gist.github.com/justmoon/15511f92e5216fa2624b#anti-patterns\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n}", "code_tokens": ["function", "TXRejectedError", "(", "message", ")", "{", "// Why not just Error.apply(this, [message])? See", "// https://gist.github.com/justmoon/15511f92e5216fa2624b#anti-patterns", "Error", ".", "captureStackTrace", "(", "this", ",", "this", ".", "constructor", ")", ";", "this", ".", "name", "=", "this", ".", "constructor", ".", "name", ";", "this", ".", "message", "=", "message", ";", "}"], "docstring": "raised when the transaction is rejected prior to running it in the EVM.", "docstring_tokens": ["raised", "when", "the", "transaction", "is", "rejected", "prior", "to", "running", "it", "in", "the", "EVM", "."], "sha": "cba166610008262266a60908d7ab4eb20fd856be", "url": "https://github.com/trufflesuite/ganache-core/blob/cba166610008262266a60908d7ab4eb20fd856be/lib/utils/txrejectederror.js#L4-L10", "partition": "test"}
{"repo": "zhiyelee/mdserver", "path": "lib/server.js", "func_name": "log", "original_string": "function log(req, res, next) {\n  console.log('['\n      + chalk.grey(ts())\n      + '] '\n      + chalk.white(decodeURI(req.url))\n  );\n  next();\n}", "language": "javascript", "code": "function log(req, res, next) {\n  console.log('['\n      + chalk.grey(ts())\n      + '] '\n      + chalk.white(decodeURI(req.url))\n  );\n  next();\n}", "code_tokens": ["function", "log", "(", "req", ",", "res", ",", "next", ")", "{", "console", ".", "log", "(", "'['", "+", "chalk", ".", "grey", "(", "ts", "(", ")", ")", "+", "'] '", "+", "chalk", ".", "white", "(", "decodeURI", "(", "req", ".", "url", ")", ")", ")", ";", "next", "(", ")", ";", "}"], "docstring": "simple log middleware, output the access log", "docstring_tokens": ["simple", "log", "middleware", "output", "the", "access", "log"], "sha": "0d8815934d095c2564fece1ac80b0c976adcc109", "url": "https://github.com/zhiyelee/mdserver/blob/0d8815934d095c2564fece1ac80b0c976adcc109/lib/server.js#L100-L107", "partition": "test"}
{"repo": "bholloway/browserify-nginject", "path": "lib/get-updater.js", "func_name": "getUpdater", "original_string": "function getUpdater(errorFn) {\n  errorFn = errorFn || new Function();\n  return updater;\n\n  /**\n   * The updater function for the esprima transform\n   * @param {string} file The filename for the Browserify transform\n   * @param {object} ast The esprima syntax tree\n   * @returns {object} The transformed esprima syntax tree\n   */\n  function updater(file, ast) {\n    if (ast.comments) {\n      ast.comments\n        .filter(testDocTag)\n        .map(getAnnotatedNode)\n        .concat(inferAngular(ast))    // find the items that are not explicitly annotated\n        .filter(testFirstOccurrence)  // ensure unique values\n        .forEach(processNode);\n    } else {\n      errorFn('Esprima AST is required to have top-level comments array');\n    }\n    return ast;\n  }\n\n  /**\n   * Get the node that is annotated by the comment or throw if not present.\n   * @throws {Error} Where comment does not annotate a node\n   * @param {object} comment The comment node\n   */\n  function getAnnotatedNode(comment) {\n\n    // find the first function declaration or expression following the annotation\n    var result;\n    if (comment.annotates) {\n      var candidateTrees;\n\n      // consider the context the block is in (i.e. what is its parent)\n      var parent = comment.annotates.parent;\n\n      // consider nodes from the annotated node forward\n      //  include the first non-generated node and all generated nodes preceding it\n      if (testNode.isBlockOrProgram(parent)) {\n        var body = parent.body;\n        var index = body.indexOf(comment.annotates);\n        var candidates = body.slice(index);\n        var length = candidates.map(testNode.isGeneratedCode).indexOf(false) + 1;\n        candidateTrees = candidates.slice(0, length || candidates.length);\n      }\n      // otherwise we can only consider the given node\n      else {\n        candidateTrees = [comment.annotates];\n      }\n\n      // try the nodes\n      while (!result && candidateTrees.length) {\n        result = esprimaTools\n          .orderNodes(candidateTrees.shift())\n          .filter(testNode.isFunctionNotIFFE)\n          .shift();\n      }\n    }\n\n    // throw where not valid\n    if (result) {\n      return result;\n    } else {\n      errorFn('Doc-tag @ngInject does not annotate anything');\n    }\n  }\n}", "language": "javascript", "code": "function getUpdater(errorFn) {\n  errorFn = errorFn || new Function();\n  return updater;\n\n  /**\n   * The updater function for the esprima transform\n   * @param {string} file The filename for the Browserify transform\n   * @param {object} ast The esprima syntax tree\n   * @returns {object} The transformed esprima syntax tree\n   */\n  function updater(file, ast) {\n    if (ast.comments) {\n      ast.comments\n        .filter(testDocTag)\n        .map(getAnnotatedNode)\n        .concat(inferAngular(ast))    // find the items that are not explicitly annotated\n        .filter(testFirstOccurrence)  // ensure unique values\n        .forEach(processNode);\n    } else {\n      errorFn('Esprima AST is required to have top-level comments array');\n    }\n    return ast;\n  }\n\n  /**\n   * Get the node that is annotated by the comment or throw if not present.\n   * @throws {Error} Where comment does not annotate a node\n   * @param {object} comment The comment node\n   */\n  function getAnnotatedNode(comment) {\n\n    // find the first function declaration or expression following the annotation\n    var result;\n    if (comment.annotates) {\n      var candidateTrees;\n\n      // consider the context the block is in (i.e. what is its parent)\n      var parent = comment.annotates.parent;\n\n      // consider nodes from the annotated node forward\n      //  include the first non-generated node and all generated nodes preceding it\n      if (testNode.isBlockOrProgram(parent)) {\n        var body = parent.body;\n        var index = body.indexOf(comment.annotates);\n        var candidates = body.slice(index);\n        var length = candidates.map(testNode.isGeneratedCode).indexOf(false) + 1;\n        candidateTrees = candidates.slice(0, length || candidates.length);\n      }\n      // otherwise we can only consider the given node\n      else {\n        candidateTrees = [comment.annotates];\n      }\n\n      // try the nodes\n      while (!result && candidateTrees.length) {\n        result = esprimaTools\n          .orderNodes(candidateTrees.shift())\n          .filter(testNode.isFunctionNotIFFE)\n          .shift();\n      }\n    }\n\n    // throw where not valid\n    if (result) {\n      return result;\n    } else {\n      errorFn('Doc-tag @ngInject does not annotate anything');\n    }\n  }\n}", "code_tokens": ["function", "getUpdater", "(", "errorFn", ")", "{", "errorFn", "=", "errorFn", "||", "new", "Function", "(", ")", ";", "return", "updater", ";", "/**\n   * The updater function for the esprima transform\n   * @param {string} file The filename for the Browserify transform\n   * @param {object} ast The esprima syntax tree\n   * @returns {object} The transformed esprima syntax tree\n   */", "function", "updater", "(", "file", ",", "ast", ")", "{", "if", "(", "ast", ".", "comments", ")", "{", "ast", ".", "comments", ".", "filter", "(", "testDocTag", ")", ".", "map", "(", "getAnnotatedNode", ")", ".", "concat", "(", "inferAngular", "(", "ast", ")", ")", "// find the items that are not explicitly annotated", ".", "filter", "(", "testFirstOccurrence", ")", "// ensure unique values", ".", "forEach", "(", "processNode", ")", ";", "}", "else", "{", "errorFn", "(", "'Esprima AST is required to have top-level comments array'", ")", ";", "}", "return", "ast", ";", "}", "/**\n   * Get the node that is annotated by the comment or throw if not present.\n   * @throws {Error} Where comment does not annotate a node\n   * @param {object} comment The comment node\n   */", "function", "getAnnotatedNode", "(", "comment", ")", "{", "// find the first function declaration or expression following the annotation", "var", "result", ";", "if", "(", "comment", ".", "annotates", ")", "{", "var", "candidateTrees", ";", "// consider the context the block is in (i.e. what is its parent)", "var", "parent", "=", "comment", ".", "annotates", ".", "parent", ";", "// consider nodes from the annotated node forward", "//  include the first non-generated node and all generated nodes preceding it", "if", "(", "testNode", ".", "isBlockOrProgram", "(", "parent", ")", ")", "{", "var", "body", "=", "parent", ".", "body", ";", "var", "index", "=", "body", ".", "indexOf", "(", "comment", ".", "annotates", ")", ";", "var", "candidates", "=", "body", ".", "slice", "(", "index", ")", ";", "var", "length", "=", "candidates", ".", "map", "(", "testNode", ".", "isGeneratedCode", ")", ".", "indexOf", "(", "false", ")", "+", "1", ";", "candidateTrees", "=", "candidates", ".", "slice", "(", "0", ",", "length", "||", "candidates", ".", "length", ")", ";", "}", "// otherwise we can only consider the given node", "else", "{", "candidateTrees", "=", "[", "comment", ".", "annotates", "]", ";", "}", "// try the nodes", "while", "(", "!", "result", "&&", "candidateTrees", ".", "length", ")", "{", "result", "=", "esprimaTools", ".", "orderNodes", "(", "candidateTrees", ".", "shift", "(", ")", ")", ".", "filter", "(", "testNode", ".", "isFunctionNotIFFE", ")", ".", "shift", "(", ")", ";", "}", "}", "// throw where not valid", "if", "(", "result", ")", "{", "return", "result", ";", "}", "else", "{", "errorFn", "(", "'Doc-tag @ngInject does not annotate anything'", ")", ";", "}", "}", "}"], "docstring": "Create an updater function for the esprima transform with the given error handler\n@param {function} [errorFn] An optional error handler function\n@returns {function(string, object):object} A method that transforms the esprima tree", "docstring_tokens": ["Create", "an", "updater", "function", "for", "the", "esprima", "transform", "with", "the", "given", "error", "handler"], "sha": "42cff52081b66d77e4e7fac923d4d824de13cfd3", "url": "https://github.com/bholloway/browserify-nginject/blob/42cff52081b66d77e4e7fac923d4d824de13cfd3/lib/get-updater.js#L14-L83", "partition": "test"}
{"repo": "twinssbc/Ionic2-Calendar", "path": "demo/typescript.js", "func_name": "createInstantiatedSymbolTable", "original_string": "function createInstantiatedSymbolTable(symbols, mapper, mappingThisOnly) {\n            var result = {};\n            for (var _i = 0; _i < symbols.length; _i++) {\n                var symbol = symbols[_i];\n                result[symbol.name] = mappingThisOnly && isIndependentMember(symbol) ? symbol : instantiateSymbol(symbol, mapper);\n            }\n            return result;\n        }", "language": "javascript", "code": "function createInstantiatedSymbolTable(symbols, mapper, mappingThisOnly) {\n            var result = {};\n            for (var _i = 0; _i < symbols.length; _i++) {\n                var symbol = symbols[_i];\n                result[symbol.name] = mappingThisOnly && isIndependentMember(symbol) ? symbol : instantiateSymbol(symbol, mapper);\n            }\n            return result;\n        }", "code_tokens": ["function", "createInstantiatedSymbolTable", "(", "symbols", ",", "mapper", ",", "mappingThisOnly", ")", "{", "var", "result", "=", "{", "}", ";", "for", "(", "var", "_i", "=", "0", ";", "_i", "<", "symbols", ".", "length", ";", "_i", "++", ")", "{", "var", "symbol", "=", "symbols", "[", "_i", "]", ";", "result", "[", "symbol", ".", "name", "]", "=", "mappingThisOnly", "&&", "isIndependentMember", "(", "symbol", ")", "?", "symbol", ":", "instantiateSymbol", "(", "symbol", ",", "mapper", ")", ";", "}", "return", "result", ";", "}"], "docstring": "The mappingThisOnly flag indicates that the only type parameter being mapped is \"this\". When the flag is true, we check symbols to see if we can quickly conclude they are free of \"this\" references, thus needing no instantiation.", "docstring_tokens": ["The", "mappingThisOnly", "flag", "indicates", "that", "the", "only", "type", "parameter", "being", "mapped", "is", "this", ".", "When", "the", "flag", "is", "true", "we", "check", "symbols", "to", "see", "if", "we", "can", "quickly", "conclude", "they", "are", "free", "of", "this", "references", "thus", "needing", "no", "instantiation", "."], "sha": "29c5389189364d3ccb23989c57e111c7d4009f0d", "url": "https://github.com/twinssbc/Ionic2-Calendar/blob/29c5389189364d3ccb23989c57e111c7d4009f0d/demo/typescript.js#L16126-L16133", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "setConfig", "original_string": "function setConfig (argv) {\n        var configLookup = {}\n    \n        // expand defaults/aliases, in-case any happen to reference\n        // the config.json file.\n        applyDefaultsAndAliases(configLookup, aliases, defaults)\n    \n        Object.keys(flags.configs).forEach(function (configKey) {\n          var configPath = argv[configKey] || configLookup[configKey]\n          if (configPath) {\n            try {\n              var config = require(path.resolve(process.cwd(), configPath))\n    \n              Object.keys(config).forEach(function (key) {\n                // setting arguments via CLI takes precedence over\n                // values within the config file.\n                if (argv[key] === undefined || (flags.defaulted[key])) {\n                  delete argv[key]\n                  setArg(key, config[key])\n                }\n              })\n            } catch (ex) {\n              if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n            }\n          }\n        })\n      }", "language": "javascript", "code": "function setConfig (argv) {\n        var configLookup = {}\n    \n        // expand defaults/aliases, in-case any happen to reference\n        // the config.json file.\n        applyDefaultsAndAliases(configLookup, aliases, defaults)\n    \n        Object.keys(flags.configs).forEach(function (configKey) {\n          var configPath = argv[configKey] || configLookup[configKey]\n          if (configPath) {\n            try {\n              var config = require(path.resolve(process.cwd(), configPath))\n    \n              Object.keys(config).forEach(function (key) {\n                // setting arguments via CLI takes precedence over\n                // values within the config file.\n                if (argv[key] === undefined || (flags.defaulted[key])) {\n                  delete argv[key]\n                  setArg(key, config[key])\n                }\n              })\n            } catch (ex) {\n              if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n            }\n          }\n        })\n      }", "code_tokens": ["function", "setConfig", "(", "argv", ")", "{", "var", "configLookup", "=", "{", "}", "// expand defaults/aliases, in-case any happen to reference", "// the config.json file.", "applyDefaultsAndAliases", "(", "configLookup", ",", "aliases", ",", "defaults", ")", "Object", ".", "keys", "(", "flags", ".", "configs", ")", ".", "forEach", "(", "function", "(", "configKey", ")", "{", "var", "configPath", "=", "argv", "[", "configKey", "]", "||", "configLookup", "[", "configKey", "]", "if", "(", "configPath", ")", "{", "try", "{", "var", "config", "=", "require", "(", "path", ".", "resolve", "(", "process", ".", "cwd", "(", ")", ",", "configPath", ")", ")", "Object", ".", "keys", "(", "config", ")", ".", "forEach", "(", "function", "(", "key", ")", "{", "// setting arguments via CLI takes precedence over", "// values within the config file.", "if", "(", "argv", "[", "key", "]", "===", "undefined", "||", "(", "flags", ".", "defaulted", "[", "key", "]", ")", ")", "{", "delete", "argv", "[", "key", "]", "setArg", "(", "key", ",", "config", "[", "key", "]", ")", "}", "}", ")", "}", "catch", "(", "ex", ")", "{", "if", "(", "argv", "[", "configKey", "]", ")", "error", "=", "Error", "(", "__", "(", "'Invalid JSON config file: %s'", ",", "configPath", ")", ")", "}", "}", "}", ")", "}"], "docstring": "set args from config.json file, this should be applied last so that defaults can be applied.", "docstring_tokens": ["set", "args", "from", "config", ".", "json", "file", "this", "should", "be", "applied", "last", "so", "that", "defaults", "can", "be", "applied", "."], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L77006-L77032", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-data.js", "func_name": "", "original_string": "function (type, payload) {\n    var serializer;\n    if (!payload) {\n      payload = type;\n      serializer = defaultSerializer(this.container);\n      Ember.assert(\"You cannot use `store#pushPayload` without a type unless your default serializer defines `pushPayload`\", serializer.pushPayload);\n    } else {\n      serializer = this.serializerFor(type);\n    }\n    serializer.pushPayload(this, payload);\n  }", "language": "javascript", "code": "function (type, payload) {\n    var serializer;\n    if (!payload) {\n      payload = type;\n      serializer = defaultSerializer(this.container);\n      Ember.assert(\"You cannot use `store#pushPayload` without a type unless your default serializer defines `pushPayload`\", serializer.pushPayload);\n    } else {\n      serializer = this.serializerFor(type);\n    }\n    serializer.pushPayload(this, payload);\n  }", "code_tokens": ["function", "(", "type", ",", "payload", ")", "{", "var", "serializer", ";", "if", "(", "!", "payload", ")", "{", "payload", "=", "type", ";", "serializer", "=", "defaultSerializer", "(", "this", ".", "container", ")", ";", "Ember", ".", "assert", "(", "\"You cannot use `store#pushPayload` without a type unless your default serializer defines `pushPayload`\"", ",", "serializer", ".", "pushPayload", ")", ";", "}", "else", "{", "serializer", "=", "this", ".", "serializerFor", "(", "type", ")", ";", "}", "serializer", ".", "pushPayload", "(", "this", ",", "payload", ")", ";", "}"], "docstring": "Push some raw data into the store.\n\nThe data will be automatically deserialized using the\nserializer for the `type` param.\n\nThis method can be used both to push in brand new\nrecords, as well as to update existing records.\n\nYou can push in more than one type of object at once.\nAll objects should be in the format expected by the\nserializer.\n\n```js\nApp.ApplicationSerializer = DS.ActiveModelSerializer;\n\nvar pushData = {\nposts: [\n{id: 1, post_title: \"Great post\", comment_ids: [2]}\n],\ncomments: [\n{id: 2, comment_body: \"Insightful comment\"}\n]\n}\n\nstore.pushPayload('post', pushData);\n```\n\n@method pushPayload\n@param {String} type\n@param {Object} payload\n@return {DS.Model} the record that was created or updated.", "docstring_tokens": ["Push", "some", "raw", "data", "into", "the", "store", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-data.js#L3101-L3111", "partition": "test"}
{"repo": "10xLaCroixDrinker/grunt-node-version", "path": "tasks/node_version.js", "func_name": "", "original_string": "function() {\n      prompt.start();\n\n      var prop = {\n        name: 'yesno',\n        message: 'You do not have any node versions installed that satisfy this project\\'s requirements ('.white + expected.yellow + '). Would you like to install the latest compatible version? (y/n)'.white,\n        validator: /y[es]*|n[o]?/,\n        required: true,\n        warning: 'Must respond yes or no'\n      };\n\n      prompt.get(prop, function (err, result) {\n        result = result.yesno.toLowerCase();\n        if (result === 'yes' ||\n            result === 'y') {\n          nvmInstall();\n        } else {\n          grunt[options.errorLevel]('Expected node v' + expected + ', but found ' + actual);\n        }\n      });\n\n    }", "language": "javascript", "code": "function() {\n      prompt.start();\n\n      var prop = {\n        name: 'yesno',\n        message: 'You do not have any node versions installed that satisfy this project\\'s requirements ('.white + expected.yellow + '). Would you like to install the latest compatible version? (y/n)'.white,\n        validator: /y[es]*|n[o]?/,\n        required: true,\n        warning: 'Must respond yes or no'\n      };\n\n      prompt.get(prop, function (err, result) {\n        result = result.yesno.toLowerCase();\n        if (result === 'yes' ||\n            result === 'y') {\n          nvmInstall();\n        } else {\n          grunt[options.errorLevel]('Expected node v' + expected + ', but found ' + actual);\n        }\n      });\n\n    }", "code_tokens": ["function", "(", ")", "{", "prompt", ".", "start", "(", ")", ";", "var", "prop", "=", "{", "name", ":", "'yesno'", ",", "message", ":", "'You do not have any node versions installed that satisfy this project\\'s requirements ('", ".", "white", "+", "expected", ".", "yellow", "+", "'). Would you like to install the latest compatible version? (y/n)'", ".", "white", ",", "validator", ":", "/", "y[es]*|n[o]?", "/", ",", "required", ":", "true", ",", "warning", ":", "'Must respond yes or no'", "}", ";", "prompt", ".", "get", "(", "prop", ",", "function", "(", "err", ",", "result", ")", "{", "result", "=", "result", ".", "yesno", ".", "toLowerCase", "(", ")", ";", "if", "(", "result", "===", "'yes'", "||", "result", "===", "'y'", ")", "{", "nvmInstall", "(", ")", ";", "}", "else", "{", "grunt", "[", "options", ".", "errorLevel", "]", "(", "'Expected node v'", "+", "expected", "+", "', but found '", "+", "actual", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Prompt to install", "docstring_tokens": ["Prompt", "to", "install"], "sha": "d16beba04f6a6325d2fa8202750165d3fc69b35b", "url": "https://github.com/10xLaCroixDrinker/grunt-node-version/blob/d16beba04f6a6325d2fa8202750165d3fc69b35b/tasks/node_version.js#L137-L158", "partition": "test"}
{"repo": "disnet/contracts.js", "path": "js/libs/ember-1.5.1.js", "func_name": "", "original_string": "function(callback) {\n    var guid = Ember.guidFor(this),\n        self = this;\n\n    Ember.$(window).on('popstate.ember-location-'+guid, function(e) {\n      // Ignore initial page load popstate event in Chrome\n      if (!popstateFired) {\n        popstateFired = true;\n        if (self.getURL() === self._previousURL) { return; }\n      }\n      callback(self.getURL());\n    });\n  }", "language": "javascript", "code": "function(callback) {\n    var guid = Ember.guidFor(this),\n        self = this;\n\n    Ember.$(window).on('popstate.ember-location-'+guid, function(e) {\n      // Ignore initial page load popstate event in Chrome\n      if (!popstateFired) {\n        popstateFired = true;\n        if (self.getURL() === self._previousURL) { return; }\n      }\n      callback(self.getURL());\n    });\n  }", "code_tokens": ["function", "(", "callback", ")", "{", "var", "guid", "=", "Ember", ".", "guidFor", "(", "this", ")", ",", "self", "=", "this", ";", "Ember", ".", "$", "(", "window", ")", ".", "on", "(", "'popstate.ember-location-'", "+", "guid", ",", "function", "(", "e", ")", "{", "// Ignore initial page load popstate event in Chrome", "if", "(", "!", "popstateFired", ")", "{", "popstateFired", "=", "true", ";", "if", "(", "self", ".", "getURL", "(", ")", "===", "self", ".", "_previousURL", ")", "{", "return", ";", "}", "}", "callback", "(", "self", ".", "getURL", "(", ")", ")", ";", "}", ")", ";", "}"], "docstring": "Register a callback to be invoked whenever the browser\nhistory changes, including using forward and back buttons.\n\n@private\n@method onUpdateURL\n@param callback {Function}", "docstring_tokens": ["Register", "a", "callback", "to", "be", "invoked", "whenever", "the", "browser", "history", "changes", "including", "using", "forward", "and", "back", "buttons", "."], "sha": "3ad1335a8c92597f116d97a6da5b3359ce90fca0", "url": "https://github.com/disnet/contracts.js/blob/3ad1335a8c92597f116d97a6da5b3359ce90fca0/js/libs/ember-1.5.1.js#L39669-L39681", "partition": "test"}
{"repo": "cubicmushroom/gulp-cm-phpspec-tasks", "path": "pakmanaged.js", "func_name": "expectKeyword", "original_string": "function expectKeyword(keyword, contextual) {\n            var token = lex();\n            if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||\n                    token.value !== keyword) {\n                throwUnexpected(token);\n            }\n        }", "language": "javascript", "code": "function expectKeyword(keyword, contextual) {\n            var token = lex();\n            if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||\n                    token.value !== keyword) {\n                throwUnexpected(token);\n            }\n        }", "code_tokens": ["function", "expectKeyword", "(", "keyword", ",", "contextual", ")", "{", "var", "token", "=", "lex", "(", ")", ";", "if", "(", "token", ".", "type", "!==", "(", "contextual", "?", "Token", ".", "Identifier", ":", "Token", ".", "Keyword", ")", "||", "token", ".", "value", "!==", "keyword", ")", "{", "throwUnexpected", "(", "token", ")", ";", "}", "}"], "docstring": "Expect the next token to match the specified keyword. If not, an exception will be thrown.", "docstring_tokens": ["Expect", "the", "next", "token", "to", "match", "the", "specified", "keyword", ".", "If", "not", "an", "exception", "will", "be", "thrown", "."], "sha": "671b5e6e9545c7a6a027f8b93c1349d491cf429e", "url": "https://github.com/cubicmushroom/gulp-cm-phpspec-tasks/blob/671b5e6e9545c7a6a027f8b93c1349d491cf429e/pakmanaged.js#L9727-L9733", "partition": "test"}
