function expandVars ( target , options ) { const vars = options . vars || { } ; const regexp = / \$\{(\w+)\} / g ; if ( typeof target === "string" ) { return _expand ( target ) ; } for ( let key in target ) { target [ key ] = _expand ( target [ key ] ) ; } return target ; function _expand ( val ) { let expanded = val ; let match ; while ( match = regexp . exec ( val ) ) { const varname = match [ 1 ] ; const varval = vars [ varname ] || process . env [ varname ] ; if ( ! varval ) { debug ( ` \$ ${ varname } ` ) ; continue ; } expanded = expanded . replace ( ` \$ ${ varname } ` , varval ) ; } return expanded ; } }	<s> Expand variables using variables from the options object or process environment . Modifies the passed object in place . </s>
async function parallel ( resolvers , limit = - 1 ) { // set default limit if ( limit < 1 ) { limit = 1000 ; } // buffer const results = [ ] ; // calculate chunk size // limit step size to input array size const chunkSize = Math . min ( limit , resolvers . length ) ; // process resolvers in chunks for ( let i = 0 ; i < resolvers . length ; i = i + chunkSize ) { // extract current chunk const chunk = resolvers . slice ( i , Math . min ( i + chunkSize , resolvers . length ) ) ; // resolve current chunk const intermediateResults = await Promise . all ( chunk . map ( ( r ) => r . resolve ( ) ) ) ; // push results into buffer results . push ( ... intermediateResults ) ; } // return results return results ; }	<s> resolves multiple promises in parallel </s>
function handleError ( type , filepath , opts , cb ) { return function ( err ) { switch ( type ) { case 'read' : if ( err . code === 'ENOENT' ) { err . message = formatError ( 'file does not exist' , filepath , err ) ; } else { err . message = formatError ( 'cannot read file' , filepath , err ) ; } break ; case 'write' : if ( ! opts . overwrite && err . code === 'EEXIST' ) { return cb ( ) ; } err . message = formatError ( 'cannot write to' , filepath , err ) ; break ; } cb ( err ) ; } ; }	<s> Handle errors with custom message formatting . </s>
function forOwn ( object , iteratee ) { Object . keys ( object ) . forEach ( function ( key ) { return iteratee ( object [ key ] , key , object ) ; } ) ; }	<s> Iterates over own enumerable string keyed properties of an object and invokes iteratee for each property . </s>
function EntityKey ( entityType , keyValues ) { assertParam ( entityType , "entityType" ) . isInstanceOf ( EntityType ) . check ( ) ; var subtypes = entityType . getSelfAndSubtypes ( ) ; if ( subtypes . length > 1 ) { this . _subtypes = subtypes . filter ( function ( st ) { return st . isAbstract === false ; } ) ; } if ( ! Array . isArray ( keyValues ) ) { keyValues = __arraySlice ( arguments , 1 ) ; } this . entityType = entityType ; entityType . keyProperties . forEach ( function ( kp , i ) { // insure that guid keys are comparable. if ( kp . dataType === DataType . Guid ) { keyValues [ i ] = keyValues [ i ] && keyValues [ i ] . toLowerCase ( ) ; } } ) ; this . values = keyValues ; this . _keyInGroup = createKeyString ( keyValues ) ; }	<s> An EntityKey is an object that represents the unique identity of an entity . EntityKey s are immutable . </s>
function Phaser ( element ) { check ( element , 'element' ) . is . anInstanceOf ( Element ) ( ) ; var priv = { } ; priv . elem = element ; priv . phase = null ; priv . listeners = [ ] ; priv . phaseTriggers = new MultiMap ( ) ; priv . started = false ; var pub = { } ; var methods = [ getPhase , nextPhase , addPhaseListener , removePhaseListener , addPhaseTrigger , removePhaseTrigger , startTransition , ] ; // This trick binds all methods to the public object // passing `priv` as the first argument to each call. methods . forEach ( function ( method ) { pub [ method . name ] = method . bind ( pub , priv ) ; } ) ; return pub ; }	<s> Creates Phaser . </s>
function logical_path_for_filename ( self , filename , filters ) { var logical_path = self . attributesFor ( filename ) . logicalPath ; if ( matches_filter ( filters , logical_path , filename ) ) { return logical_path ; } // If filename is an index file, retest with alias if ( path . basename ( filename ) . split ( '.' ) . shift ( ) === 'index' ) { logical_path = logical_path . replace ( / \/index\. / , '.' ) ; if ( matches_filter ( filters , logical_path , filename ) ) { return logical_path ; } } }	<s> Returns logicalPath for filename if it matches given filters </s>
function validateJSonStructure ( filePath , cb ) { fs . readFile ( filePath , function ( err , data ) { if ( err ) { return cb ( err ) ; } try { var jsonObject = JSON . parse ( data ) ; cb ( null , jsonObject ) ; } catch ( e ) { cb ( 'Invalid JSON file: ' + path . basename ( filePath ) ) ; } } ) ; }	<s> Checks that the received file is a well formed json </s>
function _getNodeOpacity ( node , highlightedNode , highlightedLink , config ) { const highlight = node . highlighted || node . id === ( highlightedLink && highlightedLink . source ) || node . id === ( highlightedLink && highlightedLink . target ) ; const someNodeHighlighted = ! ! ( highlightedNode || ( highlightedLink && highlightedLink . source && highlightedLink . target ) ) ; let opacity ; if ( someNodeHighlighted && config . highlightDegree === 0 ) { opacity = highlight ? config . node . opacity : config . highlightOpacity ; } else if ( someNodeHighlighted ) { opacity = highlight ? config . node . opacity : config . highlightOpacity ; } else { opacity = node . opacity || config . node . opacity ; } return opacity ; }	<s> Get the correct node opacity in order to properly make decisions based on context such as currently highlighted node . </s>
function ( element , type , handler ) { if ( element . addEventListener ) { addEvent = function ( element , type , handler ) { element . addEventListener ( type , handler , false ) ; } ; } else if ( element . attachEvent ) { addEvent = function ( element , type , handler ) { element . attachEvent ( 'on' + type , handler ) ; } ; } else { addEvent = function ( element , type , handler ) { element [ 'on' + type ] = handler ; } ; } addEvent ( element , type , handler ) ; }	<s> Cross - browser compatible event handler . </s>
