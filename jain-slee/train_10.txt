public boolean decorateAbstractSbb ( ) throws DeploymentException { ClassPool pool = component . getClassPool ( ) ; String sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; try { sbbAbstractClass = pool . get ( sbbAbstractClassName ) ; } catch ( NotFoundException nfe ) { throw new DeploymentException ( "Could not find Abstract Sbb Class: " + sbbAbstractClassName , nfe ) ; } // populate the list of concrete methods. It will be needed by the // decorating methods. concreteMethods = new HashMap ( ) ; CtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { int mods = methods [ i ] . getModifiers ( ) ; if ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { concreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; } } decorateENCBindCalls ( ) ; decorateNewThreadCalls ( ) ; if ( isAbstractSbbClassDecorated ) { try { String deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; sbbAbstractClass . writeFile ( deployDir ) ; sbbAbstractClass . detach ( ) ; // the file on disk is now in sync with the latest in-memory version if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Modified Abstract Class " + sbbAbstractClass . getName ( ) + " generated in the following path " + deployDir ) ; } //} catch (NotFoundException e) { //    String s = "Error writing modified abstract sbb class"; //    logger.error(s,e); //    throw new DeploymentException (s,e); } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } finally { sbbAbstractClass . defrost ( ) ; } return true ; } else { return false ; } }	<s> Decorate the abstract sbb Class </s>
protected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { if ( expr == null ) throw new NullPointerException ( "expr is null" ) ; // check for cycles if ( expr instanceof CompositeQueryExpression ) { ( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; } else if ( expr instanceof Not ) { ( ( Not ) expr ) . checkForCycles ( this ) ; } // no cycles, so add the expression to the list exprs . add ( expr ) ; }	<s> Add a query expression to this composite expression . </s>
private Object readResolve ( ) throws StreamCorruptedException { if ( level == LEVEL_OFF ) return OFF ; if ( level == LEVEL_SEVERE ) return SEVERE ; if ( level == LEVEL_WARNING ) return WARNING ; if ( level == LEVEL_INFO ) return INFO ; if ( level == LEVEL_CONFIG ) return CONFIG ; if ( level == LEVEL_FINE ) return FINE ; if ( level == LEVEL_FINER ) return FINER ; if ( level == LEVEL_FINEST ) return FINEST ; throw new StreamCorruptedException ( "Invalid internal state found" ) ; }	<s> Resolve deserialisation references so that the singleton property of each enumerated object is preserved . </s>
public boolean isHigherLevel ( TraceLevel other ) throws NullPointerException { if ( other == null ) throw new NullPointerException ( "other is null" ) ; return this . level < other . level ; }	<s> Determine if this TraceLevel object represents a level that is higher than some other TraceLevel object . For the purposes of the comparison OFF is considered a higher level than SEVERE and FINEST is the lowest level . </s>
public boolean isHigherLevel ( Level other ) throws NullPointerException { if ( other == null ) throw new NullPointerException ( "other is null" ) ; return this . level < other . level ; }	<s> Determine if this Level object represents a level that is higher or more severe that some other Level object . For the purposes of the comparison OFF is considered a higher level than SEVERE . </s>
public final void setProfileID ( String profileTableName , String profileName ) throws NullPointerException , IllegalArgumentException { if ( profileTableName == null ) throw new NullPointerException ( "profileTableName is null" ) ; if ( profileName == null ) throw new NullPointerException ( "profileName is null" ) ; if ( profileTableName . indexOf ( ' ' ) >= 0 ) throw new IllegalArgumentException ( "profileTableName cannot contain the '/' character" ) ; this . profileTableName = profileTableName ; this . profileName = profileName ; this . address = null ; }	<s> Set the profile table and profile referenced by this profile identifier to new values . </s>
public static Object readObject ( ObjectInputStream in , boolean vendorDataDeserializationEnabled ) throws IOException , ClassNotFoundException { // read non-transient fields in . defaultReadObject ( ) ; // read any possible marshalled vendor data from the stream MarshalledObject vendorData = in . readBoolean ( ) ? ( MarshalledObject ) in . readObject ( ) : null ; // now figure out what to return return ( vendorData != null && vendorDataDeserializationEnabled ) ? vendorData . get ( ) : null ; }	<s> Read the current object in the input stream from the stream optionally deserializing any vendor - specific data in the stream . </s>
public static void writeObject ( ObjectOutputStream out , Object vendorData ) throws IOException { // write non-transient fields out . defaultWriteObject ( ) ; // check if should we serialize vendor data? if ( vendorData != null ) { // serialize the vendor data out . writeBoolean ( true ) ; // write the vendor data in a marshalled object so deserialization can be deferred out . writeObject ( new MarshalledObject ( vendorData ) ) ; } else out . writeBoolean ( false ) ; }	<s> Write the current object and vendor - specific data to the output stream . </s>
protected void executeAfterRollbackActions ( ) { if ( afterRollbackActions != null ) { if ( trace ) { logger . trace ( "Executing rollback actions" ) ; } executeActions ( afterRollbackActions , trace ) ; afterRollbackActions = null ; } }	<s> Executes actions scheduled for after a rollback </s>
protected void executeBeforeCommitActions ( ) { if ( beforeCommitActions != null ) { if ( trace ) { logger . trace ( "Executing before commit actions" ) ; } executeActions ( beforeCommitActions , trace ) ; beforeCommitActions = null ; } }	<s> Executes actions scheduled for before commit </s>
